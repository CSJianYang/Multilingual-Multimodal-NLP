[
    {
        "title": "Valid Parentheses",
        "question_content": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\nAn input string is valid if:\n\n\tOpen brackets must be closed by the same type of brackets.\n\tOpen brackets must be closed in the correct order.\n\tEvery close bracket has a corresponding open bracket of the same type.\n\n&nbsp;\nExample 1:\n\nInput: s = \"()\"\nOutput: true\n\nExample 2:\n\nInput: s = \"()[]{}\"\nOutput: true\n\nExample 3:\n\nInput: s = \"(]\"\nOutput: false\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 104\n\ts consists of parentheses only '()[]{}'.",
        "solutions": [
            {
                "id": 9178,
                "title": "short-java-solution",
                "content": "    public boolean isValid(String s) {\\n\\t\\tStack<Character> stack = new Stack<Character>();\\n\\t\\tfor (char c : s.toCharArray()) {\\n\\t\\t\\tif (c == '(')\\n\\t\\t\\t\\tstack.push(')');\\n\\t\\t\\telse if (c == '{')\\n\\t\\t\\t\\tstack.push('}');\\n\\t\\t\\telse if (c == '[')\\n\\t\\t\\t\\tstack.push(']');\\n\\t\\t\\telse if (stack.isEmpty() || stack.pop() != c)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn stack.isEmpty();\\n\\t}",
                "solutionTags": [],
                "code": "    public boolean isValid(String s) {\\n\\t\\tStack<Character> stack = new Stack<Character>();\\n\\t\\tfor (char c : s.toCharArray()) {\\n\\t\\t\\tif (c == '(')\\n\\t\\t\\t\\tstack.push(')');\\n\\t\\t\\telse if (c == '{')\\n\\t\\t\\t\\tstack.push('}');\\n\\t\\t\\telse if (c == '[')\\n\\t\\t\\t\\tstack.push(']');\\n\\t\\t\\telse if (stack.isEmpty() || stack.pop() != c)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn stack.isEmpty();\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3399077,
                "title": "easy-solutions-in-java-python-and-c-look-at-once-with-exaplanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to determine if the given string of brackets is valid or not. We can use a stack data structure to keep track of opening brackets encountered and check if they match with the corresponding closing brackets.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere is the step-by-step approach of the algorithm:\\n1. Initialize an empty stack.\\n\\n2. Traverse the input string character by character.\\n\\n3. If the current character is an opening bracket (i.e., \\'(\\', \\'{\\', \\'[\\'), push it onto the stack.\\n\\n4. If the current character is a closing bracket (i.e., \\')\\', \\'}\\', \\']\\'), check if the stack is empty. If it is empty, return false, because the closing bracket does not have a corresponding opening bracket. Otherwise, pop the top element from the stack and check if it matches the current closing bracket. If it does not match, return false, because the brackets are not valid.\\n\\n5. After traversing the entire input string, if the stack is empty, return true, because all opening brackets have been matched with their corresponding closing brackets. Otherwise, return false, because some opening brackets have not been matched with their corresponding closing brackets.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is $$O(n)$$, where n is the length of the input string. This is because we traverse the string once and perform constant time operations for each character.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is $$O(n)$$, where n is the length of the input string. This is because the worst-case scenario is when all opening brackets are present in the string and the stack will have to store them all.\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n\\n# Code\\n```java []\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> stack = new Stack<Character>(); // create an empty stack\\n        for (char c : s.toCharArray()) { // loop through each character in the string\\n            if (c == \\'(\\') // if the character is an opening parenthesis\\n                stack.push(\\')\\'); // push the corresponding closing parenthesis onto the stack\\n            else if (c == \\'{\\') // if the character is an opening brace\\n                stack.push(\\'}\\'); // push the corresponding closing brace onto the stack\\n            else if (c == \\'[\\') // if the character is an opening bracket\\n                stack.push(\\']\\'); // push the corresponding closing bracket onto the stack\\n            else if (stack.isEmpty() || stack.pop() != c) // if the character is a closing bracket\\n                // if the stack is empty (i.e., there is no matching opening bracket) or the top of the stack\\n                // does not match the closing bracket, the string is not valid, so return false\\n                return false;\\n        }\\n        // if the stack is empty, all opening brackets have been matched with their corresponding closing brackets,\\n        // so the string is valid, otherwise, there are unmatched opening brackets, so return false\\n        return stack.isEmpty();\\n    }\\n}\\n\\n```\\n```java []\\nclass Solution {\\n    public boolean isValid(String s) {\\n        // Create an empty stack to keep track of opening brackets\\n        Stack<Character> stack = new Stack<Character>();\\n        \\n        // Loop through every character in the string\\n        for (char c : s.toCharArray()) {\\n            // If the character is an opening bracket, push it onto the stack\\n            if (c == \\'(\\' || c == \\'[\\' || c == \\'{\\') {\\n                stack.push(c);\\n            } else { // If the character is a closing bracket\\n                // If the stack is empty, there is no matching opening bracket, so return false\\n                if (stack.isEmpty()) {\\n                    return false;\\n                }\\n                // Otherwise, get the top of the stack and check if it\\'s the matching opening bracket\\n                char top = stack.peek();\\n                if ((c == \\')\\' && top == \\'(\\') || (c == \\']\\' && top == \\'[\\') || (c == \\'}\\' && top == \\'{\\')) {\\n                    // If it is, pop the opening bracket from the stack\\n                    stack.pop();\\n                } else { // Otherwise, the brackets don\\'t match, so return false\\n                    return false;\\n                }\\n            }\\n        }\\n        // If the stack is empty, all opening brackets have been closed, so return true\\n        // Otherwise, there are unmatched opening brackets, so return false\\n        return stack.isEmpty();\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution(object):\\n    def isValid(self, s):\\n        stack = [] # create an empty stack to store opening brackets\\n        for c in s: # loop through each character in the string\\n            if c in \\'([{\\': # if the character is an opening bracket\\n                stack.append(c) # push it onto the stack\\n            else: # if the character is a closing bracket\\n                if not stack or \\\\\\n                    (c == \\')\\' and stack[-1] != \\'(\\') or \\\\\\n                    (c == \\'}\\' and stack[-1] != \\'{\\') or \\\\\\n                    (c == \\']\\' and stack[-1] != \\'[\\'):\\n                    return False # the string is not valid, so return false\\n                stack.pop() # otherwise, pop the opening bracket from the stack\\n        return not stack # if the stack is empty, all opening brackets have been matched with their corresponding closing brackets,\\n                         # so the string is valid, otherwise, there are unmatched opening brackets, so return false\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st; // create an empty stack to store opening brackets\\n        for (char c : s) { // loop through each character in the string\\n            if (c == \\'(\\' || c == \\'{\\' || c == \\'[\\') { // if the character is an opening bracket\\n                st.push(c); // push it onto the stack\\n            } else { // if the character is a closing bracket\\n                if (st.empty() || // if the stack is empty or \\n                    (c == \\')\\' && st.top() != \\'(\\') || // the closing bracket doesn\\'t match the corresponding opening bracket at the top of the stack\\n                    (c == \\'}\\' && st.top() != \\'{\\') ||\\n                    (c == \\']\\' && st.top() != \\'[\\')) {\\n                    return false; // the string is not valid, so return false\\n                }\\n                st.pop(); // otherwise, pop the opening bracket from the stack\\n            }\\n        }\\n        return st.empty(); // if the stack is empty, all opening brackets have been matched with their corresponding closing brackets,\\n                           // so the string is valid, otherwise, there are unmatched opening brackets, so return false\\n    }\\n};\\n```\\n\\n```javascript []\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar isValid = function(s) {\\n    let stack = []; // create an empty stack to store opening brackets\\n    for (let c of s) { // loop through each character in the string\\n        if (c === \\'(\\' || c === \\'{\\' || c === \\'[\\') { // if the character is an opening bracket\\n            stack.push(c); // push it onto the stack\\n        } else { // if the character is a closing bracket\\n            if (!stack.length || // if the stack is empty or \\n                (c === \\')\\' && stack[stack.length - 1] !== \\'(\\') || // the closing bracket doesn\\'t match the corresponding opening bracket at the top of the stack\\n                (c === \\'}\\' && stack[stack.length - 1] !== \\'{\\') ||\\n                (c === \\']\\' && stack[stack.length - 1] !== \\'[\\')) {\\n                return false; // the string is not valid, so return false\\n            }\\n            stack.pop(); // otherwise, pop the opening bracket from the stack\\n        }\\n    }\\n    return !stack.length; // if the stack is empty, all opening brackets have been matched with their corresponding closing brackets,\\n                          // so the string is valid, otherwise, there are unmatched opening brackets, so return false\\n};\\n\\n```\\n\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n```java []\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> stack = new Stack<Character>(); // create an empty stack\\n        for (char c : s.toCharArray()) { // loop through each character in the string\\n            if (c == \\'(\\') // if the character is an opening parenthesis\\n                stack.push(\\')\\'); // push the corresponding closing parenthesis onto the stack\\n            else if (c == \\'{\\') // if the character is an opening brace\\n                stack.push(\\'}\\'); // push the corresponding closing brace onto the stack\\n            else if (c == \\'[\\') // if the character is an opening bracket\\n                stack.push(\\']\\'); // push the corresponding closing bracket onto the stack\\n            else if (stack.isEmpty() || stack.pop() != c) // if the character is a closing bracket\\n                // if the stack is empty (i.e., there is no matching opening bracket) or the top of the stack\\n                // does not match the closing bracket, the string is not valid, so return false\\n                return false;\\n        }\\n        // if the stack is empty, all opening brackets have been matched with their corresponding closing brackets,\\n        // so the string is valid, otherwise, there are unmatched opening brackets, so return false\\n        return stack.isEmpty();\\n    }\\n}\\n\\n```\n```java []\\nclass Solution {\\n    public boolean isValid(String s) {\\n        // Create an empty stack to keep track of opening brackets\\n        Stack<Character> stack = new Stack<Character>();\\n        \\n        // Loop through every character in the string\\n        for (char c : s.toCharArray()) {\\n            // If the character is an opening bracket, push it onto the stack\\n            if (c == \\'(\\' || c == \\'[\\' || c == \\'{\\') {\\n                stack.push(c);\\n            } else { // If the character is a closing bracket\\n                // If the stack is empty, there is no matching opening bracket, so return false\\n                if (stack.isEmpty()) {\\n                    return false;\\n                }\\n                // Otherwise, get the top of the stack and check if it\\'s the matching opening bracket\\n                char top = stack.peek();\\n                if ((c == \\')\\' && top == \\'(\\') || (c == \\']\\' && top == \\'[\\') || (c == \\'}\\' && top == \\'{\\')) {\\n                    // If it is, pop the opening bracket from the stack\\n                    stack.pop();\\n                } else { // Otherwise, the brackets don\\'t match, so return false\\n                    return false;\\n                }\\n            }\\n        }\\n        // If the stack is empty, all opening brackets have been closed, so return true\\n        // Otherwise, there are unmatched opening brackets, so return false\\n        return stack.isEmpty();\\n    }\\n}\\n\\n```\n```python []\\nclass Solution(object):\\n    def isValid(self, s):\\n        stack = [] # create an empty stack to store opening brackets\\n        for c in s: # loop through each character in the string\\n            if c in \\'([{\\': # if the character is an opening bracket\\n                stack.append(c) # push it onto the stack\\n            else: # if the character is a closing bracket\\n                if not stack or \\\\\\n                    (c == \\')\\' and stack[-1] != \\'(\\') or \\\\\\n                    (c == \\'}\\' and stack[-1] != \\'{\\') or \\\\\\n                    (c == \\']\\' and stack[-1] != \\'[\\'):\\n                    return False # the string is not valid, so return false\\n                stack.pop() # otherwise, pop the opening bracket from the stack\\n        return not stack # if the stack is empty, all opening brackets have been matched with their corresponding closing brackets,\\n                         # so the string is valid, otherwise, there are unmatched opening brackets, so return false\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st; // create an empty stack to store opening brackets\\n        for (char c : s) { // loop through each character in the string\\n            if (c == \\'(\\' || c == \\'{\\' || c == \\'[\\') { // if the character is an opening bracket\\n                st.push(c); // push it onto the stack\\n            } else { // if the character is a closing bracket\\n                if (st.empty() || // if the stack is empty or \\n                    (c == \\')\\' && st.top() != \\'(\\') || // the closing bracket doesn\\'t match the corresponding opening bracket at the top of the stack\\n                    (c == \\'}\\' && st.top() != \\'{\\') ||\\n                    (c == \\']\\' && st.top() != \\'[\\')) {\\n                    return false; // the string is not valid, so return false\\n                }\\n                st.pop(); // otherwise, pop the opening bracket from the stack\\n            }\\n        }\\n        return st.empty(); // if the stack is empty, all opening brackets have been matched with their corresponding closing brackets,\\n                           // so the string is valid, otherwise, there are unmatched opening brackets, so return false\\n    }\\n};\\n```\n```javascript []\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar isValid = function(s) {\\n    let stack = []; // create an empty stack to store opening brackets\\n    for (let c of s) { // loop through each character in the string\\n        if (c === \\'(\\' || c === \\'{\\' || c === \\'[\\') { // if the character is an opening bracket\\n            stack.push(c); // push it onto the stack\\n        } else { // if the character is a closing bracket\\n            if (!stack.length || // if the stack is empty or \\n                (c === \\')\\' && stack[stack.length - 1] !== \\'(\\') || // the closing bracket doesn\\'t match the corresponding opening bracket at the top of the stack\\n                (c === \\'}\\' && stack[stack.length - 1] !== \\'{\\') ||\\n                (c === \\']\\' && stack[stack.length - 1] !== \\'[\\')) {\\n                return false; // the string is not valid, so return false\\n            }\\n            stack.pop(); // otherwise, pop the opening bracket from the stack\\n        }\\n    }\\n    return !stack.length; // if the stack is empty, all opening brackets have been matched with their corresponding closing brackets,\\n                          // so the string is valid, otherwise, there are unmatched opening brackets, so return false\\n};\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 728304,
                "title": "c-easiest-solution-fully-explained-takes-0ms-beats-100-49",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;  //taking stack for keep tracking the order of the brackets..\\n        for(auto i:s)  //iterate over each and every elements\\n        {\\n            if(i==\\'(\\' or i==\\'{\\' or i==\\'[\\') st.push(i);  //if current element of the string will be opening bracket then we will just simply push it into the stack\\n            else  //if control comes to else part, it means that current element is a closing bracket, so check two conditions  current element matches with top of the stack and the stack must not be empty...\\n            {\\n                if(st.empty() or (st.top()==\\'(\\' and i!=\\')\\') or (st.top()==\\'{\\' and i!=\\'}\\') or (st.top()==\\'[\\' and i!=\\']\\')) return false;\\n                st.pop();  //if control reaches to that line, it means we have got the right pair of brackets, so just pop it.\\n            }\\n        }\\n        return st.empty();  //at last, it may possible that we left something into the stack unpair so return checking stack is empty or not..\\n    }\\n};\\n```\\n**If solutions helps you out in any way then don\\'t forget to upvote, for such detailed solutions.**\\n**Thank you:)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;  //taking stack for keep tracking the order of the brackets..\\n        for(auto i:s)  //iterate over each and every elements\\n        {\\n            if(i==\\'(\\' or i==\\'{\\' or i==\\'[\\') st.push(i);  //if current element of the string will be opening bracket then we will just simply push it into the stack\\n            else  //if control comes to else part, it means that current element is a closing bracket, so check two conditions  current element matches with top of the stack and the stack must not be empty...\\n            {\\n                if(st.empty() or (st.top()==\\'(\\' and i!=\\')\\') or (st.top()==\\'{\\' and i!=\\'}\\') or (st.top()==\\'[\\' and i!=\\']\\')) return false;\\n                st.pop();  //if control reaches to that line, it means we have got the right pair of brackets, so just pop it.\\n            }\\n        }\\n        return st.empty();  //at last, it may possible that we left something into the stack unpair so return checking stack is empty or not..\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 9203,
                "title": "simple-python-solution-with-stack",
                "content": "    class Solution:\\n        # @return a boolean\\n        def isValid(self, s):\\n            stack = []\\n            dict = {\"]\":\"[\", \"}\":\"{\", \")\":\"(\"}\\n            for char in s:\\n                if char in dict.values():\\n                    stack.append(char)\\n                elif char in dict.keys():\\n                    if stack == [] or dict[char] != stack.pop():\\n                        return False\\n                else:\\n                    return False\\n            return stack == []\\n\\nIt's quite obvious.",
                "solutionTags": [],
                "code": "class Solution:\\n        # @return a boolean\\n        def isValid(self, s):\\n            stack = []\\n            dict = {\"]\":\"[\", \"}",
                "codeTag": "Java"
            },
            {
                "id": 316753,
                "title": "python-4ms-faster-then-100-with-explanation",
                "content": "```\\nclass Solution(object):\\n\\tdef isValid(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        d = {\\'(\\':\\')\\', \\'{\\':\\'}\\',\\'[\\':\\']\\'}\\n        stack = []\\n        for i in s:\\n            if i in d:  # 1\\n                stack.append(i)\\n            elif len(stack) == 0 or d[stack.pop()] != i:  # 2\\n                return False\\n        return len(stack) == 0 # 3\\n\\t\\n# 1. if it\\'s the left bracket then we append it to the stack\\n# 2. else if it\\'s the right bracket and the stack is empty(meaning no matching left bracket), or the left bracket doesn\\'t match\\n# 3. finally check if the stack still contains unmatched left bracket\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution(object):\\n\\tdef isValid(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        d = {\\'(\\':\\')\\', \\'{\\':\\'}\\',\\'[\\':\\']\\'}\\n        stack = []\\n        for i in s:\\n            if i in d:  # 1\\n                stack.append(i)\\n            elif len(stack) == 0 or d[stack.pop()] != i:  # 2\\n                return False\\n        return len(stack) == 0 # 3\\n\\t\\n# 1. if it\\'s the left bracket then we append it to the stack\\n# 2. else if it\\'s the right bracket and the stack is empty(meaning no matching left bracket), or the left bracket doesn\\'t match\\n# 3. finally check if the stack still contains unmatched left bracket\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2411675,
                "title": "very-easy-100-fully-explained-c-java-python-js-python3",
                "content": "An input string is valid if:\\n1. Open brackets must be closed by the same type of brackets.\\n2. Open brackets must be closed in the correct order.\\n\\n# **C++ Solution:**\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Valid Parentheses.\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        // Initialize a stack and a index idx = 0...\\n        stack<char> stack;\\n        int idx = 0;\\n        // If the string is empty, return true...\\n        if(s.size() == 0){\\n            return true;\\n        }\\n        // Create a loop to check parentheses...\\n        while(idx < s.size()){\\n            // If it contains the below parentheses, push the char to stack...\\n            if( s[idx] == \\'(\\' || s[idx] == \\'[\\' || s[idx] == \\'{\\' ){\\n                stack.push(s[idx]);\\n            }\\n            // If the current char is a closing brace provided, pop the top element...\\n            // Stack is not empty...\\n            else if ( (s[idx] == \\')\\' && !stack.empty() && stack.top() == \\'(\\') ||\\n                        (s[idx] == \\'}\\' && !stack.empty() && stack.top() == \\'{\\') ||\\n                        (s[idx] == \\']\\' && !stack.empty() && stack.top() == \\'[\\')\\n                      ){\\n                stack.pop();\\n            }\\n            else {\\n                return false;       // If The string is not a valid parenthesis...\\n            }\\n            idx++;      // Increase the index...\\n        }\\n        // If stack.empty(), return true...\\n        if(stack.empty()) {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n# **Java Solution (Using Hashmap):**\\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        // Create hashmap to store the pairs...\\n        HashMap<Character, Character> Hmap = new HashMap<Character, Character>();\\n        Hmap.put(\\')\\',\\'(\\');\\n        Hmap.put(\\'}\\',\\'{\\');\\n        Hmap.put(\\']\\',\\'[\\');\\n        // Create stack data structure...\\n        Stack<Character> stack = new Stack<Character>();\\n        // Traverse each charater in input string...\\n        for (int idx = 0; idx < s.length(); idx++){\\n            // If open parentheses are present, push it to stack...\\n            if (s.charAt(idx) == \\'(\\' || s.charAt(idx) == \\'{\\' || s.charAt(idx) == \\'[\\') {\\n                stack.push(s.charAt(idx));\\n                continue;\\n            }\\n            // If the character is closing parentheses, check that the same type opening parentheses is being pushed to the stack or not...\\n            // If not, we need to return false...\\n            if (stack.size() == 0 || Hmap.get(s.charAt(idx)) != stack.pop()) {\\n                return false;\\n            }\\n        }\\n        // If the stack is empty, return true...\\n        if (stack.size() == 0) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n# **Python Solution:**\\n```\\nclass Solution(object):\\n    def isValid(self, s):\\n        # Create a pair of opening and closing parrenthesis...\\n        opcl = dict((\\'()\\', \\'[]\\', \\'{}\\'))\\n        # Create stack data structure...\\n        stack = []\\n        # Traverse each charater in input string...\\n        for idx in s:\\n            # If open parentheses are present, append it to stack...\\n            if idx in \\'([{\\':\\n                stack.append(idx)\\n            # If the character is closing parentheses, check that the same type opening parentheses is being pushed to the stack or not...\\n            # If not, we need to return false...\\n            elif len(stack) == 0 or idx != opcl[stack.pop()]:\\n                return False\\n        # At last, we check if the stack is empty or not...\\n        # If the stack is empty it means every opened parenthesis is being closed and we can return true, otherwise we return false...\\n        return len(stack) == 0\\n```\\n                    \\n# **JavaScript Solution:**\\n```\\nvar isValid = function(s) {\\n    // Initialize stack to store the closing brackets expected...\\n    let stack = [];\\n    // Traverse each charater in input string...\\n    for (let idx = 0; idx < s.length; idx++) {\\n        // If open parentheses are present, push it to stack...\\n        if (s[idx] == \\'{\\') {\\n            stack.push(\\'}\\');\\n        } else if (s[idx] == \\'[\\') {\\n            stack.push(\\']\\');\\n        } else if (s[idx] == \\'(\\') {\\n            stack.push(\\')\\');\\n        }\\n        // If a close bracket is found, check that it matches the last stored open bracket\\n        else if (stack.pop() !== s[idx]) {\\n            return false;\\n        }\\n    }\\n    return !stack.length;\\n};\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        # Create a pair of opening and closing parrenthesis...\\n        opcl = dict((\\'()\\', \\'[]\\', \\'{}\\'))\\n        # Create stack data structure...\\n        stack = []\\n        # Traverse each charater in input string...\\n        for idx in s:\\n            # If open parentheses are present, append it to stack...\\n            if idx in \\'([{\\':\\n                stack.append(idx)\\n            # If the character is closing parentheses, check that the same type opening parentheses is being pushed to the stack or not...\\n            # If not, we need to return false...\\n            elif len(stack) == 0 or idx != opcl[stack.pop()]:\\n                return False\\n        # At last, we check if the stack is empty or not...\\n        # If the stack is empty it means every opened parenthesis is being closed and we can return true, otherwise we return false...\\n        return len(stack) == 0\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        // Initialize a stack and a index idx = 0...\\n        stack<char> stack;\\n        int idx = 0;\\n        // If the string is empty, return true...\\n        if(s.size() == 0){\\n            return true;\\n        }\\n        // Create a loop to check parentheses...\\n        while(idx < s.size()){\\n            // If it contains the below parentheses, push the char to stack...\\n            if( s[idx] == \\'(\\' || s[idx] == \\'[\\' || s[idx] == \\'{\\' ){\\n                stack.push(s[idx]);\\n            }\\n            // If the current char is a closing brace provided, pop the top element...\\n            // Stack is not empty...\\n            else if ( (s[idx] == \\')\\' && !stack.empty() && stack.top() == \\'(\\') ||\\n                        (s[idx] == \\'}\\' && !stack.empty() && stack.top() == \\'{\\') ||\\n                        (s[idx] == \\']\\' && !stack.empty() && stack.top() == \\'[\\')\\n                      ){\\n                stack.pop();\\n            }\\n            else {\\n                return false;       // If The string is not a valid parenthesis...\\n            }\\n            idx++;      // Increase the index...\\n        }\\n        // If stack.empty(), return true...\\n        if(stack.empty()) {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        // Create hashmap to store the pairs...\\n        HashMap<Character, Character> Hmap = new HashMap<Character, Character>();\\n        Hmap.put(\\')\\',\\'(\\');\\n        Hmap.put(\\'}\\',\\'{\\');\\n        Hmap.put(\\']\\',\\'[\\');\\n        // Create stack data structure...\\n        Stack<Character> stack = new Stack<Character>();\\n        // Traverse each charater in input string...\\n        for (int idx = 0; idx < s.length(); idx++){\\n            // If open parentheses are present, push it to stack...\\n            if (s.charAt(idx) == \\'(\\' || s.charAt(idx) == \\'{\\' || s.charAt(idx) == \\'[\\') {\\n                stack.push(s.charAt(idx));\\n                continue;\\n            }\\n            // If the character is closing parentheses, check that the same type opening parentheses is being pushed to the stack or not...\\n            // If not, we need to return false...\\n            if (stack.size() == 0 || Hmap.get(s.charAt(idx)) != stack.pop()) {\\n                return false;\\n            }\\n        }\\n        // If the stack is empty, return true...\\n        if (stack.size() == 0) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def isValid(self, s):\\n        # Create a pair of opening and closing parrenthesis...\\n        opcl = dict((\\'()\\', \\'[]\\', \\'{}\\'))\\n        # Create stack data structure...\\n        stack = []\\n        # Traverse each charater in input string...\\n        for idx in s:\\n            # If open parentheses are present, append it to stack...\\n            if idx in \\'([{\\':\\n                stack.append(idx)\\n            # If the character is closing parentheses, check that the same type opening parentheses is being pushed to the stack or not...\\n            # If not, we need to return false...\\n            elif len(stack) == 0 or idx != opcl[stack.pop()]:\\n                return False\\n        # At last, we check if the stack is empty or not...\\n        # If the stack is empty it means every opened parenthesis is being closed and we can return true, otherwise we return false...\\n        return len(stack) == 0\\n```\n```\\nvar isValid = function(s) {\\n    // Initialize stack to store the closing brackets expected...\\n    let stack = [];\\n    // Traverse each charater in input string...\\n    for (let idx = 0; idx < s.length; idx++) {\\n        // If open parentheses are present, push it to stack...\\n        if (s[idx] == \\'{\\') {\\n            stack.push(\\'}\\');\\n        } else if (s[idx] == \\'[\\') {\\n            stack.push(\\']\\');\\n        } else if (s[idx] == \\'(\\') {\\n            stack.push(\\')\\');\\n        }\\n        // If a close bracket is found, check that it matches the last stored open bracket\\n        else if (stack.pop() !== s[idx]) {\\n            return false;\\n        }\\n    }\\n    return !stack.length;\\n};\\n```\n```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        # Create a pair of opening and closing parrenthesis...\\n        opcl = dict((\\'()\\', \\'[]\\', \\'{}\\'))\\n        # Create stack data structure...\\n        stack = []\\n        # Traverse each charater in input string...\\n        for idx in s:\\n            # If open parentheses are present, append it to stack...\\n            if idx in \\'([{\\':\\n                stack.append(idx)\\n            # If the character is closing parentheses, check that the same type opening parentheses is being pushed to the stack or not...\\n            # If not, we need to return false...\\n            elif len(stack) == 0 or idx != opcl[stack.pop()]:\\n                return False\\n        # At last, we check if the stack is empty or not...\\n        # If the stack is empty it means every opened parenthesis is being closed and we can return true, otherwise we return false...\\n        return len(stack) == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 469626,
                "title": "javascript-48-ms-faster-than-96-58",
                "content": "```\\nvar isValid = function(s) {   \\n    const stack = [];\\n    \\n    for (let i = 0 ; i < s.length ; i++) {\\n        let c = s.charAt(i);\\n        switch(c) {\\n            case \\'(\\': stack.push(\\')\\');\\n                break;\\n            case \\'[\\': stack.push(\\']\\');\\n                break;\\n            case \\'{\\': stack.push(\\'}\\');\\n                break;\\n            default:\\n                if (c !== stack.pop()) {\\n                    return false;\\n                }\\n        }\\n    }\\n    \\n    return stack.length === 0;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nvar isValid = function(s) {   \\n    const stack = [];\\n    \\n    for (let i = 0 ; i < s.length ; i++) {\\n        let c = s.charAt(i);\\n        switch(c) {\\n            case \\'(\\': stack.push(\\')\\');\\n                break;\\n            case \\'[\\': stack.push(\\']\\');\\n                break;\\n            case \\'{\\': stack.push(\\'}\\');\\n                break;\\n            default:\\n                if (c !== stack.pop()) {\\n                    return false;\\n                }\\n        }\\n    }\\n    \\n    return stack.length === 0;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 9252,
                "title": "2ms-c-sloution",
                "content": "Repetitive code but I guess this is clean, and easy to understand. This solution also accepts (and ignores) any characters other than parenthesis in the string. Hence, it can be used to check if the parenthesis matches in an equation for example.\\n\\n    #include <stack>\\n\\n    class Solution {\\n    public:\\n        bool isValid(string s) {\\n            stack<char> paren;\\n            for (char& c : s) {\\n                switch (c) {\\n                    case '(': \\n                    case '{': \\n                    case '[': paren.push(c); break;\\n                    case ')': if (paren.empty() || paren.top()!='(') return false; else paren.pop(); break;\\n                    case '}': if (paren.empty() || paren.top()!='{') return false; else paren.pop(); break;\\n                    case ']': if (paren.empty() || paren.top()!='[') return false; else paren.pop(); break;\\n                    default: ; // pass\\n                }\\n            }\\n            return paren.empty() ;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool isValid(string s) {\\n            stack<char> paren;\\n            for (char& c : s) {\\n                switch (c) {\\n                    case '(': \\n                    case '{': \\n                    case '[': paren.push(c); break;\\n                    case ')': if (paren.empty() || paren.top()!='(') return false; else paren.pop(); break;\\n                    case '}",
                "codeTag": "Java"
            },
            {
                "id": 9225,
                "title": "python-is-this-a-cheating-method-accepted-with-40ms-easy-to-understand-but",
                "content": "    class Solution(object):\\n        def isValid(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: bool\\n            \"\"\"\\n            n = len(s)\\n            if n == 0:\\n                return True\\n            \\n            if n % 2 != 0:\\n                return False\\n                \\n            while '()' in s or '{}' in s or '[]' in s:\\n                s = s.replace('{}','').replace('()','').replace('[]','')\\n            \\n            if s == '':\\n                return True\\n            else:\\n                return False",
                "solutionTags": [],
                "code": "class Solution(object):\\n        def isValid(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: bool\\n            \"\"\"\\n            n = len(s)\\n            if n == 0:\\n                return True\\n            \\n            if n % 2 != 0:\\n                return False\\n                \\n            while '()' in s or '{}",
                "codeTag": "Java"
            },
            {
                "id": 3100615,
                "title": "c-solution-using-stack-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInput string is valid if -: \\n- for every opening bracket we have a corresponding closing bracket of the same kind \\n- opening brackets of a kind comes before the closing \\n- Order of closing is maintained (inner ones are closed before the outer ones)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf we get any type of opening bracket we push it into the stack\\n\\nIf we get a bracket of closing type we compare it with the top element of the stack \\n\\n> opening bracket -> push \\nclosing bracket -> compare \\n\\nWhile comparing with the top of the stack there can be two cases \\n1. The stack can be empty \\n2. The stack can be non-empty \\n\\n1.If the stack is not empty \\nThen we compare the top element of the stack \\n- If the top element and the current element of the string i.e. the closing bracket are of the same type -> `pop the stack `\\n\\n- If not of the same type then -> `return false` \\n\\n2.If the stack is empty and we get a closing bracket -> means the string is not valid -> `return false`\\n\\nIn the end after all the iterations \\n- If the stack is empty i.e., all the opening brackets found their corresponding closing brackets and have been popped \\nThen we `return true `\\n\\n- Else `return false`\\n\\n# Complexity\\n- Time complexity:$$O(n)$$ - n is the length of the string \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$ - in the worst case when all the brackets of the string are of opening type our loop will just push all the characters of the string into the stack \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st ; \\n        for (int i = 0 ;  i< s.length() ; i++)\\n        {\\n            char ch = s[i];\\n\\n            // if opening bracket then push into the stack \\n            if (ch == \\'(\\' || ch == \\'{\\' || ch == \\'[\\')\\n            {\\n                st.push(ch) ; \\n            }\\n\\n            else {\\n                // if a closing bracket then we compare with the top of the stack \\n                // while comparing with top of stack we have 2 cases \\n                // the stack can be empty or the stack is not empty \\n                if (!st.empty())\\n                {\\n                    char top = st.top() ;\\n                    if ((ch == \\')\\' && top == \\'(\\') || \\n                        (ch == \\'}\\' && top == \\'{\\') ||\\n                        (ch == \\']\\' && top == \\'[\\')) \\n                        {\\n                            // if matches then pop \\n                            st.pop() ;\\n                        }\\n                        else \\n                        {\\n                            return false ; \\n                        }\\n                }\\n                else \\n                {\\n                    // if stack is empty and we get a closing bracket means the string is unbalanced \\n                    return false ;\\n                }\\n            }\\n        }\\n\\n        // in the end if the stack is empty -- meaning there is no opening bracket present in the stack -- meaning all opening brackets have found their corresponding closing bracket and have been popped then we return trie \\n        if (st.empty())\\n        {\\n            return true ; \\n        }\\n        return false ;\\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023 (1).png](https://assets.leetcode.com/users/images/8ceac782-5800-4ca1-99f2-30c9f6692d76_1674716457.577975.png)\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st ; \\n        for (int i = 0 ;  i< s.length() ; i++)\\n        {\\n            char ch = s[i];\\n\\n            // if opening bracket then push into the stack \\n            if (ch == \\'(\\' || ch == \\'{\\' || ch == \\'[\\')\\n            {\\n                st.push(ch) ; \\n            }\\n\\n            else {\\n                // if a closing bracket then we compare with the top of the stack \\n                // while comparing with top of stack we have 2 cases \\n                // the stack can be empty or the stack is not empty \\n                if (!st.empty())\\n                {\\n                    char top = st.top() ;\\n                    if ((ch == \\')\\' && top == \\'(\\') || \\n                        (ch == \\'}\\' && top == \\'{\\') ||\\n                        (ch == \\']\\' && top == \\'[\\')) \\n                        {\\n                            // if matches then pop \\n                            st.pop() ;\\n                        }\\n                        else \\n                        {\\n                            return false ; \\n                        }\\n                }\\n                else \\n                {\\n                    // if stack is empty and we get a closing bracket means the string is unbalanced \\n                    return false ;\\n                }\\n            }\\n        }\\n\\n        // in the end if the stack is empty -- meaning there is no opening bracket present in the stack -- meaning all opening brackets have found their corresponding closing bracket and have been popped then we return trie \\n        if (st.empty())\\n        {\\n            return true ; \\n        }\\n        return false ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2986468,
                "title": "simple-java-beats-100-runtime-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n    We can use a stack to store characters of the string.\\n    Then we can do two things:\\n    1. if char is open bracket (i.e. \\'(\\' or \\'{\\' or \\'[\\') then push it in stack.\\n    2. if char is closed bracket therefore we can check the following conditions:\\n\\n       1: if \\'{\\' is before \\'}\\'.\\n       2: if \\'(\\' is before \\')\\'.\\n       3: if \\'[\\' is before \\']\\'.\\n\\n       If any condition is false then return false.\\n\\nFollow the code below to understand the solution.\\n\\n         **If this solution helped you, give it an up-vote to help others** \\n\\n# Complexity\\n- Time complexity: O(n) where n = length of string.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n\\n\\n        // Create a new stack to store the characters.\\n        Stack<Character> stack = new Stack<>();\\n\\n\\n        // convert string into char array and access the characters using for each loop.\\n        for(char ch: s.toCharArray())\\n        {\\n            // check ch\\n            switch (ch)\\n            {\\n                // open bracket then push it in stack.\\n                // close bracket then pop the item and compare.\\n                case \\'(\\':\\n                case \\'{\\':\\n                case \\'[\\':\\n                    stack.push(ch);\\n                    break;\\n                case \\')\\':\\n                    if(stack.isEmpty() || stack.pop() != \\'(\\')\\n\\n                    // if the stack is empty then it means string have no open bracket.\\n                        // hence it is invalid.\\n                    {\\n                        return false;\\n                    }\\n                    break;\\n                case \\'}\\':\\n                    if(stack.isEmpty() || stack.pop() != \\'{\\')\\n                    {\\n                        return false;\\n                    }\\n                    break;\\n                case \\']\\':\\n                    if(stack.isEmpty() || stack.pop() != \\'[\\')\\n                    {\\n                        return false;\\n                    }\\n                    break;\\n            }\\n        }\\n\\n\\n        // After the loop we have to check one more condition.\\n        // return true only if the stack is empty.\\n        // if stack is not empty that means we have unused brackets.\\n\\n        return stack.isEmpty();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n\\n\\n        // Create a new stack to store the characters.\\n        Stack<Character> stack = new Stack<>();\\n\\n\\n        // convert string into char array and access the characters using for each loop.\\n        for(char ch: s.toCharArray())\\n        {\\n            // check ch\\n            switch (ch)\\n            {\\n                // open bracket then push it in stack.\\n                // close bracket then pop the item and compare.\\n                case \\'(\\':\\n                case \\'{\\':\\n                case \\'[\\':\\n                    stack.push(ch);\\n                    break;\\n                case \\')\\':\\n                    if(stack.isEmpty() || stack.pop() != \\'(\\')\\n\\n                    // if the stack is empty then it means string have no open bracket.\\n                        // hence it is invalid.\\n                    {\\n                        return false;\\n                    }\\n                    break;\\n                case \\'}\\':\\n                    if(stack.isEmpty() || stack.pop() != \\'{\\')\\n                    {\\n                        return false;\\n                    }\\n                    break;\\n                case \\']\\':\\n                    if(stack.isEmpty() || stack.pop() != \\'[\\')\\n                    {\\n                        return false;\\n                    }\\n                    break;\\n            }\\n        }\\n\\n\\n        // After the loop we have to check one more condition.\\n        // return true only if the stack is empty.\\n        // if stack is not empty that means we have unused brackets.\\n\\n        return stack.isEmpty();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 9248,
                "title": "my-easy-to-understand-java-solution-with-one-stack",
                "content": "    public class Solution {\\n        public boolean isValid(String s) {\\n            Stack<Character> stack = new Stack<Character>();\\n            // Iterate through string until empty\\n            for(int i = 0; i<s.length(); i++) {\\n                // Push any open parentheses onto stack\\n                if(s.charAt(i) == '(' || s.charAt(i) == '[' || s.charAt(i) == '{')\\n                    stack.push(s.charAt(i));\\n                // Check stack for corresponding closing parentheses, false if not valid\\n                else if(s.charAt(i) == ')' && !stack.empty() && stack.peek() == '(')\\n                    stack.pop();\\n                else if(s.charAt(i) == ']' && !stack.empty() && stack.peek() == '[')\\n                    stack.pop();\\n                else if(s.charAt(i) == '}' && !stack.empty() && stack.peek() == '{')\\n                    stack.pop();\\n                else\\n                    return false;\\n            }\\n            // return true if no open parentheses left in stack\\n            return stack.empty();\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isValid(String s) {\\n            Stack<Character> stack = new Stack<Character>();\\n            // Iterate through string until empty\\n            for(int i = 0; i<s.length(); i++) {\\n                // Push any open parentheses onto stack\\n                if(s.charAt(i) == '(' || s.charAt(i) == '[' || s.charAt(i) == '{')\\n                    stack.push(s.charAt(i));\\n                // Check stack for corresponding closing parentheses, false if not valid\\n                else if(s.charAt(i) == ')' && !stack.empty() && stack.peek() == '(')\\n                    stack.pop();\\n                else if(s.charAt(i) == ']' && !stack.empty() && stack.peek() == '[')\\n                    stack.pop();\\n                else if(s.charAt(i) == '}",
                "codeTag": "Java"
            },
            {
                "id": 885074,
                "title": "python-solution-in-5-lines",
                "content": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        while len(s) > 0:\\n            l = len(s)\\n            s = s.replace(\\'()\\',\\'\\').replace(\\'{}\\',\\'\\').replace(\\'[]\\',\\'\\')\\n            if l==len(s): return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        while len(s) > 0:\\n            l = len(s)\\n            s = s.replace(\\'()\\',\\'\\').replace(\\'{}\\',\\'\\').replace(\\'[]\\',\\'\\')\\n            if l==len(s): return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 9222,
                "title": "my-0ms-c-solution-using-stack",
                "content": "\\n\\n    bool isValid(string s) {\\n        stack<char> st;\\n        for(char c : s){\\n            if(c == '('|| c == '{' || c == '['){\\n                st.push(c);\\n            }else{\\n                if(st.empty()) return false;\\n                if(c == ')' && st.top() != '(') return false;\\n                if(c == '}' && st.top() != '{') return false;\\n                if(c == ']' && st.top() != '[') return false;\\n                st.pop();\\n            }\\n        }\\n        return st.empty();",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n\\n    bool isValid(string s) {\\n        stack<char> st;\\n        for(char c : s){\\n            if(c == '('|| c == '{' || c == '['){\\n                st.push(c);\\n            }else{\\n                if(st.empty()) return false;\\n                if(c == ')' && st.top() != '(') return false;\\n                if(c == '}' && st.top() != '{') return false;\\n                if(c == ']' && st.top() != '[') return false;\\n                st.pop();\\n            }\\n        }\\n        return st.empty();",
                "codeTag": "Unknown"
            },
            {
                "id": 3030914,
                "title": "pythoneasy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        while \\'()\\' in s or \\'[]\\'in s or \\'{}\\' in s:\\n            s = s.replace(\\'()\\',\\'\\').replace(\\'[]\\',\\'\\').replace(\\'{}\\',\\'\\')\\n        return False if len(s) !=0 else True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        while \\'()\\' in s or \\'[]\\'in s or \\'{}\\' in s:\\n            s = s.replace(\\'()\\',\\'\\').replace(\\'[]\\',\\'\\').replace(\\'{}\\',\\'\\')\\n        return False if len(s) !=0 else True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 9341,
                "title": "java-iterative-solution-beating-97",
                "content": "Just implement a simple stack using a char array and check that, for each closing bracket, there is its counterpart in the top of the stack.\\n\\n    public class Solution {\\n    \\tpublic boolean isValid(String s) {\\n    \\t\\tchar[] stack = new char[s.length()];\\n    \\t\\tint head = 0;\\n    \\t\\tfor(char c : s.toCharArray()) {\\n    \\t\\t\\tswitch(c) {\\n    \\t\\t\\t\\tcase '{':\\n    \\t\\t\\t\\tcase '[':\\n    \\t\\t\\t\\tcase '(':\\n    \\t\\t\\t\\t\\tstack[head++] = c;\\n    \\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\tcase '}':\\n    \\t\\t\\t\\t\\tif(head == 0 || stack[--head] != '{') return false;\\n    \\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\tcase ')':\\n    \\t\\t\\t\\t\\tif(head == 0 || stack[--head] != '(') return false;\\n    \\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\tcase ']':\\n    \\t\\t\\t\\t\\tif(head == 0 || stack[--head] != '[') return false;\\n    \\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn head == 0;\\n    \\n    \\t}\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n    \\tpublic boolean isValid(String s) {\\n    \\t\\tchar[] stack = new char[s.length()];\\n    \\t\\tint head = 0;\\n    \\t\\tfor(char c : s.toCharArray()) {\\n    \\t\\t\\tswitch(c) {\\n    \\t\\t\\t\\tcase '{':\\n    \\t\\t\\t\\tcase '[':\\n    \\t\\t\\t\\tcase '(':\\n    \\t\\t\\t\\t\\tstack[head++] = c;\\n    \\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\tcase '}",
                "codeTag": "Java"
            },
            {
                "id": 9478,
                "title": "no-stack-o-1-space-complexity-o-n-time-complexity-solution-in-c",
                "content": "    class Solution {\\n    public:\\n        bool isValid(string s) {\\n            int top = -1;\\n            for(int i =0;i<s.length();++i){\\n                if(top<0 || !isMatch(s[top], s[i])){\\n                    ++top;\\n                    s[top] = s[i];\\n                }else{\\n                    --top;\\n                }\\n            }\\n            return top == -1;\\n        }\\n        bool isMatch(char c1, char c2){\\n            if(c1 == '(' && c2 == ')') return true;\\n            if(c1 == '[' && c2 == ']') return true;\\n            if(c1 == '{' && c2 == '}') return true;\\n            return false;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool isValid(string s) {\\n            int top = -1;\\n            for(int i =0;i<s.length();++i){\\n                if(top<0 || !isMatch(s[top], s[i])){\\n                    ++top;\\n                    s[top] = s[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 9450,
                "title": "10-lines-simple-java-solution-using-stack",
                "content": "    public class Solution {\\n        public boolean isValid(String s) {\\n            Stack<Character> stack = new Stack<>();\\n            for(int i = 0; i < s.length(); i++) {\\n                char a = s.charAt(i);\\n                if(a == '(' || a == '[' || a == '{') stack.push(a);\\n                else if(stack.empty()) return false;\\n                else if(a == ')' && stack.pop() != '(') return false;\\n                else if(a == ']' && stack.pop() != '[') return false;\\n                else if(a == '}' && stack.pop() != '{') return false;\\n            }\\n            return stack.empty();\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isValid(String s) {\\n            Stack<Character> stack = new Stack<>();\\n            for(int i = 0; i < s.length(); i++) {\\n                char a = s.charAt(i);\\n                if(a == '(' || a == '[' || a == '{') stack.push(a);\\n                else if(stack.empty()) return false;\\n                else if(a == ')' && stack.pop() != '(') return false;\\n                else if(a == ']' && stack.pop() != '[') return false;\\n                else if(a == '}",
                "codeTag": "Java"
            },
            {
                "id": 3004494,
                "title": "javascript-time-space-o-n-w-stack",
                "content": "# Approach\\nWe have a few cases where we can immedietly stop looking for validity of the string. \\n\\nWhenever string has an odd number of items, it\\'s impossible to find a pair, so return false.\\n\\nIf very first item is a closing bracket, we know that we\\'ll never find a pair for it, so return false.\\n\\nNow, the meat of the solution. We need a way to keep track of visited brackets and a way to clear them when their pair has been found. Simple stack should do (in the implementation bellow, I am using an array to act as a stack).\\n\\nFor simiplicity, let\\'s also define a `pairs` map, where opening bracket is a key, and closing bracket is the value.\\n\\n**Steps:**\\n- If lenght of the string is odd, return `false`\\n- If first bracket is closing, return `false`\\n- If last bracket is an opening one, return `false`\\n- Loop over the string\\n    - If bracket is an opening bracket, push it on top of the stack\\n    - If bracket is a closing bracket, check if the top of the stack is matching with it\\'s pair. \\n        - If no match is found, it\\'s impossible to close the bracket so return `false`\\n- Finally, if stack is empty, string is valid\\n\\n\\n# Complexity\\n- Time complexity: O(N); we need to, worse case, iterate over every item in the string\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N); because of the usage of stack/array\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\n\\nconst pairs = {\\n    \"(\": \")\",\\n    \"[\": \"]\",\\n    \"{\": \"}\"\\n}\\n     \\nvar isValid = function(s) {\\n    \\n    // check if length is an odd number. if it is, return false\\n    // if there is an odd number, it means that at least one bracket is missing a pair\\n    if (s.length % 2 === 1) return false\\n    \\n    // if the first element is a closing bracket, it doesn\\'t matter what follows\\n    // it will never have a pair\\n    if (s[0] === \"]\" || s[0] === \")\" || s[0] === \"}\") return false\\n    \\n    // same goes for last element, we are just dealing with opening bracket\\n    if (s[s.length - 1] === \"[\" || s[s.length - 1] === \"(\" || s[s.length - 1] === \"{\") return false\\n    \\n    \\n    let stack = []\\n    \\n    for(let i=0; i<s.length; i++) {\\n        // if it\\'s an opening bracket, push into stack\\n        // else, assume it\\'s closing bracket and check if it matches anything\\n        if(s[i] === \"[\" || s[i] === \"(\" || s[i] === \"{\") {\\n            stack.push(s[i])\\n        } else if (pairs[stack.pop()] !== s[i]) {\\n            return false\\n        }\\n        \\n    }\\n    return stack.length === 0\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\n\\nconst pairs = {\\n    \"(\": \")\",\\n    \"[\": \"]\",\\n    \"{\": \"}\"\\n}\\n     \\nvar isValid = function(s) {\\n    \\n    // check if length is an odd number. if it is, return false\\n    // if there is an odd number, it means that at least one bracket is missing a pair\\n    if (s.length % 2 === 1) return false\\n    \\n    // if the first element is a closing bracket, it doesn\\'t matter what follows\\n    // it will never have a pair\\n    if (s[0] === \"]\" || s[0] === \")\" || s[0] === \"}\") return false\\n    \\n    // same goes for last element, we are just dealing with opening bracket\\n    if (s[s.length - 1] === \"[\" || s[s.length - 1] === \"(\" || s[s.length - 1] === \"{\") return false\\n    \\n    \\n    let stack = []\\n    \\n    for(let i=0; i<s.length; i++) {\\n        // if it\\'s an opening bracket, push into stack\\n        // else, assume it\\'s closing bracket and check if it matches anything\\n        if(s[i] === \"[\" || s[i] === \"(\" || s[i] === \"{\") {\\n            stack.push(s[i])\\n        } else if (pairs[stack.pop()] !== s[i]) {\\n            return false\\n        }\\n        \\n    }\\n    return stack.length === 0\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1844338,
                "title": "c-detailed-explanation-w-dry-run-commented-code-faster-than-100",
                "content": "***Brief note about Question-***\\n* We have to tell whether a string is valid or not.\\n```\\nLet\\'s take an example not given-\\nSuppose our string given to us as, s = \"(({{[[]]}}))\"\\n\\nso, the answer should return true.\\n```\\n___________\\n***Solution - I (Accepted)-***\\n* It is super duper easy to judge today\\'s problem.\\n* We have to keep some data structure which will tell us, either it\\'s opening term comes or not.\\n* Means suppose we met parentheses `\\'}\\'`, but parentheses does not came before already `\\'{\\'`, then it can never be valid.\\n* And the data structure we are going to use is `stack`.\\n* And why STACK? Because it will count of the last element that comes in.\\n* Stack works on the principle of` LIFO i.e Last In First Out.`\\n* Let\\'s dry run it on the above example.\\n```\\nSuppose our string given to us as, s = \"(({{[[]]}}))\"\\n\\nIntially, our stack is empty, and looks like, t = [],\\n\\ns = \"( ( { { [ [ ]  ] } } ) )\"\\n     \\u2191\\n\\t we met an opening bracket, we will say their is a probaility of meeting same closing bracket in future, so push into stack,\\n\\t now stack looks like, t = [\\'(\\']\\n\\t                             \\u2191 t.top()\\n\\t \\ns = \"( ( { { [ [ ]  ] } } ) )\"\\n       \\u2191\\n\\t   we met an opening bracket, we will say their is a probaility of meeting same closing bracket in future, so push into stack,\\n\\t  now stack looks like, t = [\\'(\\', \\'(\\']\\n\\t                                   \\u2191 t.top()\\n\\t  \\ns = \"( ( { { [ [ ]  ] } } ) )\"\\n         \\u2191\\n\\t     we met an opening bracket, we will say their is a probaility of meeting same closing bracket in future, so push into stack,\\n\\t     now stack looks like, t = [\\'(\\', \\'(\\', \\'{\\']\\n\\t\\t                                       \\u2191 t.top()\\n\\t\\t \\ns = \"( ( { { [ [ ]  ] } } ) )\"\\n           \\u2191\\n\\t       we met an opening bracket, we will say their is a probaility of meeting same closing bracket in future, so push into stack,\\n\\t       now stack looks like, t = [\\'(\\', \\'(\\', \\'{\\', \\'{\\']\\n\\t\\t                                              \\u2191 t.top()\\n\\t\\t   \\ns = \"( ( { { [ [ ]  ] } } ) )\"\\n             \\u2191\\n\\t       we met an opening bracket, we will say their is a probaility of meeting same closing bracket in future, so push into stack,\\n\\t       now stack looks like, t = [\\'(\\', \\'(\\', \\'{\\', \\'{\\', \\'[\\']\\n\\t\\t                                                   \\u2191 t.top()\\n\\t\\t   \\ns = \"( ( { { [ [ ]  ] } } ) )\"\\n               \\u2191\\n\\t       we met an opening bracket, we will say their is a probaility of meeting same closing bracket in future, so push into stack,\\n\\t       now stack looks like, t = [\\'(\\', \\'(\\', \\'{\\', \\'{\\', \\'[\\', \\'[\\']\\n\\t\\t                                                        \\u2191 t.top()\\n\\t\\t   \\ns = \"( ( { { [ [ ]  ] } } ) )\"\\n                 \\u2191\\n\\t       Now, we met an closing bracket, so we say our parentheses will valid only if it encounter the last same opening parentheses of this type,\\n\\t\\t   and how we encounter our last opening parentheses, for that we are using stack\\n\\t       our current stack looks like, t =  [\\'(\\', \\'(\\', \\'{\\', \\'{\\', \\'[\\', \\'[\\']\\n\\t\\t                                                                 \\u2191 t.top()\\n\\t\\t\\tso, yes our current bracket is \\']\\' and top of stack is \\'[\\', so they are valid,\\n\\t\\t\\ttherefore move forward and pop the top from stack,\\n\\t\\t\\t     t =  [\\'(\\', \\'(\\', \\'{\\', \\'{\\', \\'[\\']\\n\\t\\t                                    \\u2191 t.top()\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ns = \"( ( { { [ [ ] ] } } ) )\"\\n                   \\u2191\\n\\t       Now, we met an closing bracket, so we say our parentheses will valid only if it encounter the last same opening parentheses of this type,\\n\\t\\t   and how we encounter our last opening parentheses, for that we are using stack\\n\\t       our current stack looks like, t =  [\\'(\\', \\'(\\', \\'{\\', \\'{\\', \\'[\\']\\n\\t\\t                                                            \\u2191 t.top()\\n\\t\\t\\tso, yes our current bracket is \\']\\' and top of stack is \\'[\\', so they are valid,\\n\\t\\t\\ttherefore move forward and pop the top from stack,\\n\\t\\t\\t     t =  [\\'(\\', \\'(\\', \\'{\\', \\'{\\']\\n\\t\\t                               \\u2191 t.top()\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\ns = \"( ( { { [ [ ] ] } } ) )\"\\n                     \\u2191\\n\\t       Now, we met an closing bracket, so we say our parentheses will valid only if it encounter the last same opening parentheses of this type,\\n\\t\\t   and how we encounter our last opening parentheses, for that we are using stack\\n\\t       our current stack looks like, t =  [\\'(\\', \\'(\\', \\'{\\', \\'{\\']\\n\\t\\t                                                       \\u2191 t.top()\\n\\t\\t\\tso, yes our current bracket is \\'}\\' and top of stack is \\'{\\', so they are valid,\\n\\t\\t\\ttherefore move forward and pop the top from stack,\\n\\t\\t\\t     t =  [\\'(\\', \\'(\\', \\'{\\']\\n\\t\\t                          \\u2191 t.top()\\n\\t\\t\\t\\t\\t\\t\\t\\t  \\ns = \"( ( { { [ [ ] ] } } ) )\"\\n                       \\u2191\\n\\t       Now, we met an closing bracket, so we say our parentheses will valid only if it encounter the last same opening parentheses of this type,\\n\\t\\t   and how we encounter our last opening parentheses, for that we are using stack\\n\\t       our current stack looks like, t =  [\\'(\\', \\'(\\', \\'{\\']\\n\\t\\t                                                  \\u2191 t.top()\\n\\t\\t\\tso, yes our current bracket is \\'}\\' and top of stack is \\'{\\', so they are valid,\\n\\t\\t\\ttherefore move forward and pop the top from stack,\\n\\t\\t\\t     t =  [\\'(\\', \\'(\\',]\\n\\t\\t                     \\u2191 t.top()\\n\\t\\t\\t\\t\\t\\t\\t \\ns = \"( ( { { [ [ ] ] } } ) )\"\\n                         \\u2191\\n\\t       Now, we met an closing bracket, so we say our parentheses will valid only if it encounter the last same opening parentheses of this type,\\n\\t\\t   and how we encounter our last opening parentheses, for that we are using stack\\n\\t       our current stack looks like, t =  [\\'(\\', \\'(\\']\\n\\t\\t                                             \\u2191 t.top()\\n\\t\\t\\tso, yes our current bracket is \\')\\' and top of stack is \\'(\\', so they are valid,\\n\\t\\t\\ttherefore move forward and pop the top from stack,\\n\\t\\t\\t     t =  [\\'(\\']\\n\\t\\t                \\u2191 t.top()\\n\\t\\t\\t\\t\\t\\t\\t \\ns = \"( ( { { [ [ ] ] } } ) )\"\\n                           \\u2191\\n\\t       Now, we met an closing bracket, so we say our parentheses will valid only if it encounter the last same opening parentheses of this type,\\n\\t\\t   and how we encounter our last opening parentheses, for that we are using stack\\n\\t       our current stack looks like, t =  [\\'(\\']\\n\\t\\t                                        \\u2191 t.top()\\n\\t\\t\\tso, yes our current bracket is \\')\\' and top of stack is \\'(\\', so they are valid,\\n\\t\\t\\ttherefore move forward and pop the top from stack,\\n\\t\\t\\t     t =  [ ]\\n\\t\\t              \\nSince, we are on the last index and our stack is empty,\\ntherefore it is valid.\\n```\\n___________________\\n```\\nTime Complexity --> O(n) // where n is the size of the array\\nSpace Complexity --> O(maximum number of opening parentheses) \\n\\nIt paases [ 91 / 91] in built test cases\\n```\\n________\\n**Code (C++)**\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> t; // stack for storing opening parentheses\\n        int i; // variable i to travel\\n        \\n        for(auto i:s) // travel into whole string\\n        {\\n            // if any opening parentheses, push into stack\\n            if(i == \\'(\\' || i ==\\'{\\' || i == \\'[\\')\\n            {\\n                t.push(i);\\n            }\\n            else\\n            {\\n                // check condition for false\\n                if(t.empty() || (t.top() == \\'(\\' && i != \\')\\') || (t.top() == \\'{\\' && i != \\'}\\') || (t.top() == \\'[\\' && i != \\']\\'))\\n                {\\n                    return false;\\n                }\\n                \\n                t.pop(); // else pop from stack\\n            }\\n        }\\n        \\n        return t.empty(); // if stack is empty then it is valid, otherwise no\\n    }\\n};\\n```\\n***`If u find this useful , please consider to give a upvote!!`***",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nLet\\'s take an example not given-\\nSuppose our string given to us as, s = \"(({{[[]]}}))\"\\n\\nso, the answer should return true.\\n```\n```\\nSuppose our string given to us as, s = \"(({{[[]]}}))\"\\n\\nIntially, our stack is empty, and looks like, t = [],\\n\\ns = \"( ( { { [ [ ]  ] } } ) )\"\\n     \\u2191\\n\\t we met an opening bracket, we will say their is a probaility of meeting same closing bracket in future, so push into stack,\\n\\t now stack looks like, t = [\\'(\\']\\n\\t                             \\u2191 t.top()\\n\\t \\ns = \"( ( { { [ [ ]  ] } } ) )\"\\n       \\u2191\\n\\t   we met an opening bracket, we will say their is a probaility of meeting same closing bracket in future, so push into stack,\\n\\t  now stack looks like, t = [\\'(\\', \\'(\\']\\n\\t                                   \\u2191 t.top()\\n\\t  \\ns = \"( ( { { [ [ ]  ] } } ) )\"\\n         \\u2191\\n\\t     we met an opening bracket, we will say their is a probaility of meeting same closing bracket in future, so push into stack,\\n\\t     now stack looks like, t = [\\'(\\', \\'(\\', \\'{\\']\\n\\t\\t                                       \\u2191 t.top()\\n\\t\\t \\ns = \"( ( { { [ [ ]  ] } } ) )\"\\n           \\u2191\\n\\t       we met an opening bracket, we will say their is a probaility of meeting same closing bracket in future, so push into stack,\\n\\t       now stack looks like, t = [\\'(\\', \\'(\\', \\'{\\', \\'{\\']\\n\\t\\t                                              \\u2191 t.top()\\n\\t\\t   \\ns = \"( ( { { [ [ ]  ] } } ) )\"\\n             \\u2191\\n\\t       we met an opening bracket, we will say their is a probaility of meeting same closing bracket in future, so push into stack,\\n\\t       now stack looks like, t = [\\'(\\', \\'(\\', \\'{\\', \\'{\\', \\'[\\']\\n\\t\\t                                                   \\u2191 t.top()\\n\\t\\t   \\ns = \"( ( { { [ [ ]  ] } } ) )\"\\n               \\u2191\\n\\t       we met an opening bracket, we will say their is a probaility of meeting same closing bracket in future, so push into stack,\\n\\t       now stack looks like, t = [\\'(\\', \\'(\\', \\'{\\', \\'{\\', \\'[\\', \\'[\\']\\n\\t\\t                                                        \\u2191 t.top()\\n\\t\\t   \\ns = \"( ( { { [ [ ]  ] } } ) )\"\\n                 \\u2191\\n\\t       Now, we met an closing bracket, so we say our parentheses will valid only if it encounter the last same opening parentheses of this type,\\n\\t\\t   and how we encounter our last opening parentheses, for that we are using stack\\n\\t       our current stack looks like, t =  [\\'(\\', \\'(\\', \\'{\\', \\'{\\', \\'[\\', \\'[\\']\\n\\t\\t                                                                 \\u2191 t.top()\\n\\t\\t\\tso, yes our current bracket is \\']\\' and top of stack is \\'[\\', so they are valid,\\n\\t\\t\\ttherefore move forward and pop the top from stack,\\n\\t\\t\\t     t =  [\\'(\\', \\'(\\', \\'{\\', \\'{\\', \\'[\\']\\n\\t\\t                                    \\u2191 t.top()\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ns = \"( ( { { [ [ ] ] } } ) )\"\\n                   \\u2191\\n\\t       Now, we met an closing bracket, so we say our parentheses will valid only if it encounter the last same opening parentheses of this type,\\n\\t\\t   and how we encounter our last opening parentheses, for that we are using stack\\n\\t       our current stack looks like, t =  [\\'(\\', \\'(\\', \\'{\\', \\'{\\', \\'[\\']\\n\\t\\t                                                            \\u2191 t.top()\\n\\t\\t\\tso, yes our current bracket is \\']\\' and top of stack is \\'[\\', so they are valid,\\n\\t\\t\\ttherefore move forward and pop the top from stack,\\n\\t\\t\\t     t =  [\\'(\\', \\'(\\', \\'{\\', \\'{\\']\\n\\t\\t                               \\u2191 t.top()\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\ns = \"( ( { { [ [ ] ] } } ) )\"\\n                     \\u2191\\n\\t       Now, we met an closing bracket, so we say our parentheses will valid only if it encounter the last same opening parentheses of this type,\\n\\t\\t   and how we encounter our last opening parentheses, for that we are using stack\\n\\t       our current stack looks like, t =  [\\'(\\', \\'(\\', \\'{\\', \\'{\\']\\n\\t\\t                                                       \\u2191 t.top()\\n\\t\\t\\tso, yes our current bracket is \\'}\\' and top of stack is \\'{\\', so they are valid,\\n\\t\\t\\ttherefore move forward and pop the top from stack,\\n\\t\\t\\t     t =  [\\'(\\', \\'(\\', \\'{\\']\\n\\t\\t                          \\u2191 t.top()\\n\\t\\t\\t\\t\\t\\t\\t\\t  \\ns = \"( ( { { [ [ ] ] } } ) )\"\\n                       \\u2191\\n\\t       Now, we met an closing bracket, so we say our parentheses will valid only if it encounter the last same opening parentheses of this type,\\n\\t\\t   and how we encounter our last opening parentheses, for that we are using stack\\n\\t       our current stack looks like, t =  [\\'(\\', \\'(\\', \\'{\\']\\n\\t\\t                                                  \\u2191 t.top()\\n\\t\\t\\tso, yes our current bracket is \\'}\\' and top of stack is \\'{\\', so they are valid,\\n\\t\\t\\ttherefore move forward and pop the top from stack,\\n\\t\\t\\t     t =  [\\'(\\', \\'(\\',]\\n\\t\\t                     \\u2191 t.top()\\n\\t\\t\\t\\t\\t\\t\\t \\ns = \"( ( { { [ [ ] ] } } ) )\"\\n                         \\u2191\\n\\t       Now, we met an closing bracket, so we say our parentheses will valid only if it encounter the last same opening parentheses of this type,\\n\\t\\t   and how we encounter our last opening parentheses, for that we are using stack\\n\\t       our current stack looks like, t =  [\\'(\\', \\'(\\']\\n\\t\\t                                             \\u2191 t.top()\\n\\t\\t\\tso, yes our current bracket is \\')\\' and top of stack is \\'(\\', so they are valid,\\n\\t\\t\\ttherefore move forward and pop the top from stack,\\n\\t\\t\\t     t =  [\\'(\\']\\n\\t\\t                \\u2191 t.top()\\n\\t\\t\\t\\t\\t\\t\\t \\ns = \"( ( { { [ [ ] ] } } ) )\"\\n                           \\u2191\\n\\t       Now, we met an closing bracket, so we say our parentheses will valid only if it encounter the last same opening parentheses of this type,\\n\\t\\t   and how we encounter our last opening parentheses, for that we are using stack\\n\\t       our current stack looks like, t =  [\\'(\\']\\n\\t\\t                                        \\u2191 t.top()\\n\\t\\t\\tso, yes our current bracket is \\')\\' and top of stack is \\'(\\', so they are valid,\\n\\t\\t\\ttherefore move forward and pop the top from stack,\\n\\t\\t\\t     t =  [ ]\\n\\t\\t              \\nSince, we are on the last index and our stack is empty,\\ntherefore it is valid.\\n```\n```\\nTime Complexity --> O(n) // where n is the size of the array\\nSpace Complexity --> O(maximum number of opening parentheses) \\n\\nIt paases [ 91 / 91] in built test cases\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> t; // stack for storing opening parentheses\\n        int i; // variable i to travel\\n        \\n        for(auto i:s) // travel into whole string\\n        {\\n            // if any opening parentheses, push into stack\\n            if(i == \\'(\\' || i ==\\'{\\' || i == \\'[\\')\\n            {\\n                t.push(i);\\n            }\\n            else\\n            {\\n                // check condition for false\\n                if(t.empty() || (t.top() == \\'(\\' && i != \\')\\') || (t.top() == \\'{\\' && i != \\'}\\') || (t.top() == \\'[\\' && i != \\']\\'))\\n                {\\n                    return false;\\n                }\\n                \\n                t.pop(); // else pop from stack\\n            }\\n        }\\n        \\n        return t.empty(); // if stack is empty then it is valid, otherwise no\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 461807,
                "title": "short-python3-stack-solution",
                "content": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        opened = [\\'[\\', \\'(\\', \\'{\\']\\n        closed = [\\']\\', \\')\\', \\'}\\']\\n        stack = []\\n        for c in s:\\n            if c in opened:\\n                stack.append(c)\\n            else:\\n                if len(stack) != 0 and stack[-1] == opened[closed.index(c)]:\\n                    stack.pop()\\n                else:\\n                    return False\\n        return len(stack) == 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        opened = [\\'[\\', \\'(\\', \\'{\\']\\n        closed = [\\']\\', \\')\\', \\'}\\']\\n        stack = []\\n        for c in s:\\n            if c in opened:\\n                stack.append(c)\\n            else:\\n                if len(stack) != 0 and stack[-1] == opened[closed.index(c)]:\\n                    stack.pop()\\n                else:\\n                    return False\\n        return len(stack) == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 500491,
                "title": "rust-0ms",
                "content": "```\\nimpl Solution {\\n    pub fn is_valid(s: String) -> bool {\\n        let mut stack = Vec::new();\\n        for i in s.chars() {\\n            match i {\\n                \\'{\\' => stack.push(\\'}\\'),\\n                \\'(\\' => stack.push(\\')\\'),\\n                \\'[\\' => stack.push(\\']\\'),\\n                \\'}\\'|\\')\\'|\\']\\' if Some(i) != stack.pop() => return false,\\n                _ => (),\\n            }\\n        }   \\n        return stack.is_empty();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn is_valid(s: String) -> bool {\\n        let mut stack = Vec::new();\\n        for i in s.chars() {\\n            match i {\\n                \\'{\\' => stack.push(\\'}\\'),\\n                \\'(\\' => stack.push(\\')\\'),\\n                \\'[\\' => stack.push(\\']\\'),\\n                \\'}\\'|\\')\\'|\\']\\' if Some(i) != stack.pop() => return false,\\n                _ => (),\\n            }\\n        }   \\n        return stack.is_empty();\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3946910,
                "title": "java-runtime-2-ms-beats-87-53-stack",
                "content": "# Intuition\\nMy initial approach to solving this problem involves using a stack data structure to keep track of opening brackets. As I iterate through the given string, I\\'ll push the corresponding closing bracket onto the stack whenever I encounter an opening bracket. If I encounter a closing bracket, I\\'ll check if it matches the top element of the stack. If it does, I\\'ll pop the top element from the stack. At the end of the iteration, if the stack is empty, it means all brackets were properly closed, and the string is valid.\\n\\n# Approach\\nI will use a stack to maintain the order of opening brackets encountered. For each character in the given string, I will check if it is an opening bracket (\\'(\\', \\'{\\', \\'[\\'). If it is, I\\'ll push the corresponding closing bracket onto the stack. If it\\'s a closing bracket, I\\'ll compare it with the top element of the stack. If they match, I\\'ll pop the top element from the stack. If they don\\'t match or the stack is empty, the string is not valid. Finally, if the stack is empty after processing all characters, the string is valid.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n  The algorithm iterates through the string once, and each operation inside the loop (stack push, pop, and isEmpty) takes constant time on average.\\n- Space complexity: O(n)\\n  In the worst case, the stack could store all the opening brackets in the string, resulting in a space complexity proportional to the input size.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n         Stack<Character> stack = new Stack<>();\\n\\n        for (char x : s.toCharArray()\\n             ) {\\n\\n            if(x==\\'(\\'){\\n                \\n                stack.push(\\')\\');\\n            } else if (x==\\'{\\') {\\n                stack.push(\\'}\\');\\n                \\n            } else if (x==\\'[\\') {\\n                stack.push(\\']\\');\\n            } else if (stack.isEmpty() || stack.pop()!=x) {\\n\\n                return false;\\n            }\\n\\n        }\\n\\n\\n        return stack.isEmpty();\\n        \\n    }\\n}\\n```\\n![c0504eaf-5fb8-4a1d-a769-833262d1b86e_1674433591.3836212.webp](https://assets.leetcode.com/users/images/8a3b41d1-f0ca-472f-a9f7-8346b34a824e_1693297402.2918687.webp)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n         Stack<Character> stack = new Stack<>();\\n\\n        for (char x : s.toCharArray()\\n             ) {\\n\\n            if(x==\\'(\\'){\\n                \\n                stack.push(\\')\\');\\n            } else if (x==\\'{\\') {\\n                stack.push(\\'}\\');\\n                \\n            } else if (x==\\'[\\') {\\n                stack.push(\\']\\');\\n            } else if (stack.isEmpty() || stack.pop()!=x) {\\n\\n                return false;\\n            }\\n\\n        }\\n\\n\\n        return stack.isEmpty();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 356741,
                "title": "c-solution-elegant-and-simple-7-lines-runtime-faster-than-99-90-memory-less-than-48-94",
                "content": "Just one thing to note in this solution, use of `Stack<char>` helps to avoid unnecessary __boxing/unboxing__ and improves performance (_eq. runtime_) metrics:\\n```\\npublic class Solution {\\n    public bool IsValid(string s) {\\n        // Get ready initial state (enforce element type)\\n        var k = new Stack<char>();\\n        // Evaluate each character for potential mismatch \\n        foreach(char c in s) {\\n            // Push closing round bracket onto the stack\\n            if (c == \\'(\\') { k.Push(\\')\\'); continue; }\\n            // Push closing curly bracket onto the stack\\n            if (c == \\'{\\') { k.Push(\\'}\\'); continue; }\\n            // Push closing square bracket onto the stack\\n            if (c == \\'[\\') { k.Push(\\']\\'); continue; }\\n            // Look out for imbalanced strings or mismatches\\n            if (k.Count == 0 || c != k.Pop()) return false;\\n        }\\n        // Empty stack means string is valid and invalid otherwise\\n        return k.Count == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsValid(string s) {\\n        // Get ready initial state (enforce element type)\\n        var k = new Stack<char>();\\n        // Evaluate each character for potential mismatch \\n        foreach(char c in s) {\\n            // Push closing round bracket onto the stack\\n            if (c == \\'(\\') { k.Push(\\')\\'); continue; }\\n            // Push closing curly bracket onto the stack\\n            if (c == \\'{\\') { k.Push(\\'}\\'); continue; }\\n            // Push closing square bracket onto the stack\\n            if (c == \\'[\\') { k.Push(\\']\\'); continue; }\\n            // Look out for imbalanced strings or mismatches\\n            if (k.Count == 0 || c != k.Pop()) return false;\\n        }\\n        // Empty stack means string is valid and invalid otherwise\\n        return k.Count == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 9313,
                "title": "simple-java-solution-includes-a-string-length-check",
                "content": "```\\npublic boolean isValid(String s) {\\n\\n     if(s.length() % 2 == 1)\\n        return false;\\n     \\n     Stack<Character> stack = new Stack<Character>();\\n\\t for(int i = 0; i < s.length(); i++)\\n\\t {\\n\\t\\tif(s.charAt(i) == '(')\\n\\t\\t{\\n\\t\\t\\tstack.push(')');\\n\\t\\t}\\n\\t\\telse if(s.charAt(i) == '{')\\n\\t\\t{\\n\\t\\t\\tstack.push('}');\\n\\t\\t}\\n\\t\\telse if(s.charAt(i) == '[')\\n\\t\\t{\\n\\t\\t\\tstack.push(']');\\n\\t\\t}\\n\\t\\telse if(stack.isEmpty() || stack.pop() != s.charAt(i))\\n\\t\\t\\treturn false;\\n\\t }\\n\\t return stack.isEmpty();\\n}\\n```  \\n\\n\\nThe solution is similar to the other solutions but just includes a string length check that would return false if the string has an odd length. This avoids extraneous calculations.",
                "solutionTags": [],
                "code": "```\\npublic boolean isValid(String s) {\\n\\n     if(s.length() % 2 == 1)\\n        return false;\\n     \\n     Stack<Character> stack = new Stack<Character>();\\n\\t for(int i = 0; i < s.length(); i++)\\n\\t {\\n\\t\\tif(s.charAt(i) == '(')\\n\\t\\t{\\n\\t\\t\\tstack.push(')');\\n\\t\\t}\\n\\t\\telse if(s.charAt(i) == '{')\\n\\t\\t{\\n\\t\\t\\tstack.push('}');\\n\\t\\t}\\n\\t\\telse if(s.charAt(i) == '[')\\n\\t\\t{\\n\\t\\t\\tstack.push(']');\\n\\t\\t}\\n\\t\\telse if(stack.isEmpty() || stack.pop() != s.charAt(i))\\n\\t\\t\\treturn false;\\n\\t }\\n\\t return stack.isEmpty();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1026889,
                "title": "go-stack-100-0ms-unit-test",
                "content": "To solve the problem we need to match pairs of parentheses taking into account \\n\\n- the number of parentheses,\\n- their direction (open or closed) and \\n- their order. \\n\\nTo be able to do it we have to reverse the order of opening parenthesis temporarily to match them to their closing peers. A data structure that would able to \"reverse\" the parentheses\\' order satisfying this requirement is *stack*.\\n\\nWe traverse the string from left to right and check:\\n\\n1. If we see an opening parenthesis we put it to *stack*\\n2. If it\\u2019s the closing one, then it must correspond to the parenthesis at the top of our stack, so we check if it is true and we remove this pair of parentheses if it\\'s so. If not, we return false and stop the function\\u2019s execution immediately.\\n\\nAt the end, iff we have empty stack, we have valid string thus return true.\\n\\n```go\\nfunc isValid(s string) bool {\\n\\tif len(s) == 0 || len(s)%2 == 1 {\\n\\t\\treturn false\\n\\t}\\n    \\n\\tpairs := map[rune]rune{\\n\\t\\t\\'(\\': \\')\\',\\n\\t\\t\\'{\\': \\'}\\',\\n\\t\\t\\'[\\': \\']\\',\\n\\t}\\n\\tstack := []rune{}\\n\\n\\tfor _, r := range s {\\n\\t\\tif _, ok := pairs[r]; ok {\\n\\t\\t\\tstack = append(stack, r)\\n\\t\\t} else if len(stack) == 0 || pairs[stack[len(stack)-1]] != r {\\n\\t\\t\\treturn false\\n\\t\\t} else {\\n\\t\\t\\tstack = stack[:len(stack)-1]\\n\\t\\t}\\n\\t}\\n\\n\\treturn len(stack) == 0\\n}\\n```\\n\\n\\nThe code with test is availabe by https://play.golang.org/p/POjTpJd58Ui\\n\\nIf you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc isValid(s string) bool {\\n\\tif len(s) == 0 || len(s)%2 == 1 {\\n\\t\\treturn false\\n\\t}\\n    \\n\\tpairs := map[rune]rune{\\n\\t\\t\\'(\\': \\')\\',\\n\\t\\t\\'{\\': \\'}\\',\\n\\t\\t\\'[\\': \\']\\',\\n\\t}\\n\\tstack := []rune{}\\n\\n\\tfor _, r := range s {\\n\\t\\tif _, ok := pairs[r]; ok {\\n\\t\\t\\tstack = append(stack, r)\\n\\t\\t} else if len(stack) == 0 || pairs[stack[len(stack)-1]] != r {\\n\\t\\t\\treturn false\\n\\t\\t} else {\\n\\t\\t\\tstack = stack[:len(stack)-1]\\n\\t\\t}\\n\\t}\\n\\n\\treturn len(stack) == 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3050505,
                "title": "c-easiest-stack-implementation-with-comments",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;  //taking stack for keep tracking the order of the brackets..\\n        for(auto i:s)  //iterate over each and every elements\\n        {\\n            if(i==\\'(\\' or i==\\'{\\' or i==\\'[\\') st.push(i);  //if current element of the string will be opening bracket then we will just simply push it into the stack\\n            else  //if control comes to else part, it means that current element is a closing bracket, so check two conditions  current element matches with top of the stack and the stack must not be empty...\\n            {\\n                if(st.empty() or (st.top()==\\'(\\' and i!=\\')\\') or (st.top()==\\'{\\' and i!=\\'}\\') or (st.top()==\\'[\\' and i!=\\']\\')) return false;\\n                st.pop();  //if control reaches to that line, it means we have got the right pair of brackets, so just pop it.\\n            }\\n        }\\n        return st.empty();  //at last, it may possible that we left something into the stack unpair so return checking stack is empty or not..\\n    }\\n};\\n```\\n**Please upvote if it helps you. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;  //taking stack for keep tracking the order of the brackets..\\n        for(auto i:s)  //iterate over each and every elements\\n        {\\n            if(i==\\'(\\' or i==\\'{\\' or i==\\'[\\') st.push(i);  //if current element of the string will be opening bracket then we will just simply push it into the stack\\n            else  //if control comes to else part, it means that current element is a closing bracket, so check two conditions  current element matches with top of the stack and the stack must not be empty...\\n            {\\n                if(st.empty() or (st.top()==\\'(\\' and i!=\\')\\') or (st.top()==\\'{\\' and i!=\\'}\\') or (st.top()==\\'[\\' and i!=\\']\\')) return false;\\n                st.pop();  //if control reaches to that line, it means we have got the right pair of brackets, so just pop it.\\n            }\\n        }\\n        return st.empty();  //at last, it may possible that we left something into the stack unpair so return checking stack is empty or not..\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 442423,
                "title": "python-clear-and-fast-python-python-python-beat-100",
                "content": "```python\\n    def isValid(self, s: str) -> bool:\\n        dic = {\\'(\\':1 , \\')\\':2 , \\'[\\':3 , \\']\\':6 , \\'{\\':5 , \\'}\\':10}\\n        res = []\\n        for one in s:\\n            temp = dic[one]\\n            if(temp %2 ):\\n                res.append(temp)\\n            else:\\n                if(len(res) and res[-1]==temp//2):\\n                    del res[-1]\\n                else:\\n                    return False\\n        return res==[]\\n```\\nuse ```temp = dic[one]``` to replace calculate ```dic[one]``` many times, it save many times . It can Improve 79% to 97\\n% beat times.\\n\\nRuntime: 24 ms, faster than 97.46% of Python3 online submissions for Valid Parentheses.\\nMemory Usage: 12.9 MB, less than 100.00% of Python3 online submissions for Valid Parentheses.\\n\\n**If it helps you , Please give me a vote star\\nThanks**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\n    def isValid(self, s: str) -> bool:\\n        dic = {\\'(\\':1 , \\')\\':2 , \\'[\\':3 , \\']\\':6 , \\'{\\':5 , \\'}\\':10}\\n        res = []\\n        for one in s:\\n            temp = dic[one]\\n            if(temp %2 ):\\n                res.append(temp)\\n            else:\\n                if(len(res) and res[-1]==temp//2):\\n                    del res[-1]\\n                else:\\n                    return False\\n        return res==[]\\n```\n```temp = dic[one]```\n```dic[one]```",
                "codeTag": "Python3"
            },
            {
                "id": 164324,
                "title": "javascript-solution",
                "content": "```\\nvar isValid = function(s) {\\n    let map = {\\n        \")\": \"(\",\\n        \"]\": \"[\",\\n        \"}\": \"{\"\\n    }\\n    let arr = [];\\n    for(let i = 0; i < s.length; i ++){\\n        if(s[i] === \"(\" || s[i] === \"[\" || s[i] === \"{\"){\\n            arr.push(s[i]);\\n        }\\n        else{\\n            if(arr[arr.length - 1] === map[s[i]]){\\n                arr.pop();\\n            }\\n            else return false;\\n        }\\n    }\\n    return arr.length === 0 ? true : false;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isValid = function(s) {\\n    let map = {\\n        \")\": \"(\",\\n        \"]\": \"[\",\\n        \"}\": \"{\"\\n    }\\n    let arr = [];\\n    for(let i = 0; i < s.length; i ++){\\n        if(s[i] === \"(\" || s[i] === \"[\" || s[i] === \"{\"){\\n            arr.push(s[i]);\\n        }\\n        else{\\n            if(arr[arr.length - 1] === map[s[i]]){\\n                arr.pop();\\n            }\\n            else return false;\\n        }\\n    }\\n    return arr.length === 0 ? true : false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 174635,
                "title": "python-3-lines-o-1-memory",
                "content": "```\n    def isValid(self, s):\n\n        while '[]' in s or '()' in s or '{}' in s:\n            s = s.replace('[]','').replace('()','').replace('{}','')\n        return not len(s)",
                "solutionTags": [],
                "code": "    def isValid(self, s):\n        while '[]' in s or '()' in s or '{}' in s:\n            s = s.replace('[]','').replace('()','').replace('{}','')\n        return not len(s)",
                "codeTag": "Python3"
            },
            {
                "id": 518705,
                "title": "c-fast-simple-o-1-memory-no-stack",
                "content": "```\\nbool isValid(char *s) {\\n\\n    char *q=s;\\n    \\n    for (char *p=s; *p; p++) \\n        switch(*p) {\\n            case \\'(\\': *q++ = \\')\\'; continue;\\n            case \\'{\\': *q++ = \\'}\\'; continue;\\n            case \\'[\\': *q++ = \\']\\'; continue;\\n            default: if (q==s || *p != *--q) return false;\\n        }\\n    \\n    return q==s;\\n}\\n```\\n\\nActually I just hid it in `s`.\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isValid(char *s) {\\n\\n    char *q=s;\\n    \\n    for (char *p=s; *p; p++) \\n        switch(*p) {\\n            case \\'(\\': *q++ = \\')\\'; continue;\\n            case \\'{\\': *q++ = \\'}\\'; continue;\\n            case \\'[\\': *q++ = \\']\\'; continue;\\n            default: if (q==s || *p != *--q) return false;\\n        }\\n    \\n    return q==s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3360331,
                "title": "easy-solution-with-replace",
                "content": "# Intuition\\nNot the fastest to execute, but the fastest to think about it. Replaces all parenthesis with a empty string while they exists.\\n\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool IsValid(string s) {\\n        while (s.Contains(\"()\") || s.Contains(\"[]\") || s.Contains(\"{}\"))\\n        {\\n            s = s.Replace(\"()\", \"\").Replace(\"[]\", \"\").Replace(\"{}\", \"\");\\n        }\\n\\n        return s.Length == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsValid(string s) {\\n        while (s.Contains(\"()\") || s.Contains(\"[]\") || s.Contains(\"{}\"))\\n        {\\n            s = s.Replace(\"()\", \"\").Replace(\"[]\", \"\").Replace(\"{}\", \"\");\\n        }\\n\\n        return s.Length == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 9528,
                "title": "short-easy-to-follow-8ms-java-solution",
                "content": "    public class Solution {\\n        public boolean isValid(String s) {\\n            int length;\\n        \\n            do {\\n                length = s.length();\\n                s = s.replace(\"()\", \"\").replace(\"{}\", \"\").replace(\"[]\", \"\");\\n            } while(length != s.length());\\n        \\n            return s.length() == 0;\\n        }\\n    }\\n\\nIn this solution you essentially can remove parentheses that you know are valid until the string is empty. If the string is not empty, that means that the parentheses were malformed.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isValid(String s) {\\n            int length;\\n        \\n            do {\\n                length = s.length();\\n                s = s.replace(\"()\", \"\").replace(\"{}",
                "codeTag": "Java"
            },
            {
                "id": 491448,
                "title": "simple-ruby-solution",
                "content": "> Runtime: 24 ms, faster than 99.57% of Ruby online submissions for Valid Parentheses.\\n> Memory Usage: 9.3 MB, less than 100.00% of Ruby online submissions for Valid Parentheses.\\n\\n```ruby\\n# @param {String} s\\n# @return {Boolean}\\ndef is_valid(s)\\n    return true if s.empty?\\n    \\n    stack = []\\n    s.each_char do |c|\\n        case c\\n        when \\'(\\', \\'{\\', \\'[\\'\\n            stack.push(c)\\n        when \\')\\'\\n            return false if stack.pop() != \\'(\\'\\n        when \\'}\\'\\n            return false if stack.pop() != \\'{\\'\\n        when \\']\\'\\n            return false if stack.pop() != \\'[\\'\\n        end\\n    end\\n    return stack.empty?\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\n# @param {String} s\\n# @return {Boolean}\\ndef is_valid(s)\\n    return true if s.empty?\\n    \\n    stack = []\\n    s.each_char do |c|\\n        case c\\n        when \\'(\\', \\'{\\', \\'[\\'\\n            stack.push(c)\\n        when \\')\\'\\n            return false if stack.pop() != \\'(\\'\\n        when \\'}\\'\\n            return false if stack.pop() != \\'{\\'\\n        when \\']\\'\\n            return false if stack.pop() != \\'[\\'\\n        end\\n    end\\n    return stack.empty?\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2150150,
                "title": "python-solution",
                "content": "\\n    def isValid(self, s: str) -> bool:\\n        for x in range(len(s)//2):\\n            if s==\\'\\': return True\\n            s = s.replace(\\'()\\', \\'\\').replace(\\'{}\\', \\'\\').replace(\\'[]\\', \\'\\')\\n        return s==\\'\\'\\n                    \\n\\t\\t\\n##### Please UPVOTE my solution if you like it. Thanks",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n    def isValid(self, s: str) -> bool:\\n        for x in range(len(s)//2):\\n            if s==\\'\\': return True\\n            s = s.replace(\\'()\\', \\'\\').replace(\\'{}\\', \\'\\').replace(\\'[]\\', \\'\\')\\n        return s==\\'\\'\\n                    \\n\\t\\t\\n##### Please UPVOTE my solution if you like it. Thanks",
                "codeTag": "Python3"
            },
            {
                "id": 9187,
                "title": "12-lines-of-java",
                "content": "    public class Solution {\\n        public boolean isValid(String s) {\\n            Stack<Integer> p = new Stack<>();\\n            for(int i = 0; i < s.length(); i++) {\\n                int q = \"(){}[]\".indexOf(s.substring(i, i + 1));\\n                if(q % 2 == 1) {\\n                    if(p.isEmpty() || p.pop() != q - 1) return false;\\n                } else p.push(q);\\n            }\\n            return p.isEmpty();\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isValid(String s) {\\n            Stack<Integer> p = new Stack<>();\\n            for(int i = 0; i < s.length(); i++) {\\n                int q = \"(){}",
                "codeTag": "Java"
            },
            {
                "id": 401812,
                "title": "python-clean-and-elegant",
                "content": "```\\ndef isValid(self, s: str) -> bool:\\n        l = list()\\n        \\n        d = {\\'}\\':\\'{\\', \\')\\':\\'(\\', \\']\\':\\'[\\'}\\n        b_open = d.values()\\n        \\n        for b in s:\\n            if b in b_open:\\n                l.append(b)\\n            else:\\n                if len(l) > 0 and l[-1] == d[b]:\\n                        l.pop()\\n                else:\\n                    return False\\n        \\n        return len(l) == 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef isValid(self, s: str) -> bool:\\n        l = list()\\n        \\n        d = {\\'}\\':\\'{\\', \\')\\':\\'(\\', \\']\\':\\'[\\'}\\n        b_open = d.values()\\n        \\n        for b in s:\\n            if b in b_open:\\n                l.append(b)\\n            else:\\n                if len(l) > 0 and l[-1] == d[b]:\\n                        l.pop()\\n                else:\\n                    return False\\n        \\n        return len(l) == 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1644155,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranty of any kind. You are free to use the content freely and as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    func isValid(_ s: String) -> Bool {\\n        \\n        guard s.count % 2 == 0 else { return false }\\n        \\n        var stack: [Character] = []\\n        \\n        for ch in s {\\n            switch ch {\\n            case \"(\": stack.append(\")\")\\n            case \"[\": stack.append(\"]\")\\n            case \"{\": stack.append(\"}\")\\n            default:\\n                if stack.isEmpty || stack.removeLast() != ch {\\n                    return false\\n                }\\n            }\\n        }\\n        \\n        return stack.isEmpty\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<pre>\\n<b>Result:</b> Executed 3 tests, with 0 failures (0 unexpected) in 0.012 (0.014) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.isValid(\"()\")\\n        XCTAssertTrue(value)\\n    }\\n    func test1() {\\n        let value = solution.isValid(\"()[]{}\")\\n        XCTAssertTrue(value)\\n    }\\n    func test2() {\\n        let value = solution.isValid(\"(]\")\\n        XCTAssertFalse(value)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func isValid(_ s: String) -> Bool {\\n        \\n        guard s.count % 2 == 0 else { return false }\\n        \\n        var stack: [Character] = []\\n        \\n        for ch in s {\\n            switch ch {\\n            case \"(\": stack.append(\")\")\\n            case \"[\": stack.append(\"]\")\\n            case \"{\": stack.append(\"}\")\\n            default:\\n                if stack.isEmpty || stack.removeLast() != ch {\\n                    return false\\n                }\\n            }\\n        }\\n        \\n        return stack.isEmpty\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.isValid(\"()\")\\n        XCTAssertTrue(value)\\n    }\\n    func test1() {\\n        let value = solution.isValid(\"()[]{}\")\\n        XCTAssertTrue(value)\\n    }\\n    func test2() {\\n        let value = solution.isValid(\"(]\")\\n        XCTAssertFalse(value)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143060,
                "title": "simple-java-solution-100-easy-approach",
                "content": "\\n\\n# Approach\\nAs we do in BODMAS or Maths, every open bracket should have its closing bracket. So accordingly the order of the brackets matters much for example, if We have an opening bracket in order \"{ [ ( \" then the closing brackets should be \" ) ] }\".\\n\\nSo to deal with this problem we have to look for the data structure called Stack which follows FILO or LIFO.\\n\\nSo we will iterate through the given string, push the opening brackets in a stack, and pop them if we get matching closing brackets on the top.\\n\\nNow let\\'s understand this all with an $Example$.\\n\\nGiven String = \" { [ ( { } ) ] } \"\\n\\nNow let\\'s iterate through String and push opening Brackets inside the stack which will look like this:\\n\\n![imgonline-com-ua-twotoone-l0H1xJQgK7x.png](https://assets.leetcode.com/users/images/a12b809b-2ad5-414c-92d7-5dd416f25a1d_1675631379.698946.png)\\n\\n\\nNow when we Ittrate further we will start getting closing Brackets Now we will pop the Open Brackets in our Stack if and only if the closing brackets match the opening bracket on the top of the stack.\\n\\n![image.png](https://assets.leetcode.com/users/images/cb637454-43f0-4704-ab01-13550802d2ea_1675631584.836981.png)\\n\\nSo as we Can see closing bracket matches with the opening bracket on the top of the stack so now we will pop it.\\n\\n![image.png](https://assets.leetcode.com/users/images/837e04fb-5cb6-476f-ae8b-0b42b4d9b601_1675548125.451662.png)\\n\\nNow in the same way we will pop further remaining opening brackets if we get its matching closing bracket.\\n\\nFinally, after iteration is over we will get an empty stack which means Every opening bracket has got its appropriate pair.\\n\\n![image.png](https://assets.leetcode.com/users/images/6059051f-53f6-45a8-a9f5-f709cce7eab9_1675549053.0110495.png)\\n\\nAnd if the Stack is not Empty this means the is some missing pair or mismatch of the pair of the closing bracket and opening bracket.\\n\\n**Key Point :**\\n\\n**1. If Stack is empty then its True** and\\n**2. If Stack has 1 or more elements left after the operation then its False.**\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nThe Time Complexity for the code is O(s.length)\\n# Code\\n```\\nclass Solution {\\n         public static boolean isValid(String s) {\\n    // Inilization of Stack\\n        Stack<Character> st = new Stack<>();\\n    // Iterating through the given String\\n        for (int i = 0; i < s.length(); i++) {\\n    // Push Open Brackets in the Stack\\n            if (s.charAt(i) == \\'{\\' || s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\') {\\n                st.push(s.charAt(i));\\n            }\\n    // checking for the empty stack because if empty this means there is no open bracket at the start which is an invaild string.\\n            else if(st.empty()){\\n                return false;\\n            }\\n    // Check for the close brackets pair on the top and pop them\\n            else if (st.peek() == \\'{\\' && s.charAt(i) == \\'}\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'(\\' && s.charAt(i) == \\')\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'[\\' && s.charAt(i) == \\']\\' ) {\\n                st.pop();\\n            }else{\\n                return false;\\n            }\\n\\n        }\\n        return st.empty();\\n\\n\\n    }\\n}\\n    \\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/d62cac10-8f7e-46be-84df-8b4e98c468ad_1675627889.7365386.png)\\n",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n         public static boolean isValid(String s) {\\n    // Inilization of Stack\\n        Stack<Character> st = new Stack<>();\\n    // Iterating through the given String\\n        for (int i = 0; i < s.length(); i++) {\\n    // Push Open Brackets in the Stack\\n            if (s.charAt(i) == \\'{\\' || s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\') {\\n                st.push(s.charAt(i));\\n            }\\n    // checking for the empty stack because if empty this means there is no open bracket at the start which is an invaild string.\\n            else if(st.empty()){\\n                return false;\\n            }\\n    // Check for the close brackets pair on the top and pop them\\n            else if (st.peek() == \\'{\\' && s.charAt(i) == \\'}\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'(\\' && s.charAt(i) == \\')\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'[\\' && s.charAt(i) == \\']\\' ) {\\n                st.pop();\\n            }else{\\n                return false;\\n            }\\n\\n        }\\n        return st.empty();\\n\\n\\n    }\\n}\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844392,
                "title": "c-easy-simple-short-explained-with-algorithm",
                "content": "# 20. Valid Parentheses\\n**KNOCKCAT**\\n\\n* Don\\'t know who is downvoting but please if you can\\'t upvote don\\'t downvote too.\\n* I have to recreate the post. :)\\n\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Stack Problem with Initution.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\\n``` ```\\n[LeetCode](https://github.com/knockcat/Leetcode)      **LINK TO LEETCODE REPOSITORY**\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n``` ```\\n* **EXPLANATION**\\nThe valid parentheses problem involves checking that:\\n\\t1. all the **parentheses are matched**, i.e., **every opening parenthesis has a corresponding closing parenthesis**.\\n\\t2. the **matched parentheses are in the correct order**\\u200B, i.e., an **opening parenthesis should come before the closing parenthesis**.\\n\\t\\n\\t![image](https://assets.leetcode.com/users/images/9af80683-293e-4b0c-88fd-e31f475521e7_1647133006.346712.png)\\n\\t\\n\\n* **ALGORITHM**\\n1. **Declare** an **empty stack**.\\n2. **Push an opening parenthesis** on **top** of the **stack**.\\n3. In case of a cl**osing bracket,** **check if the stack is empty**.\\n4. **If not**, **pop in a closing parenthesis** if the top of the stack contains the corresponding opening parenthesis.\\n5. If the **parentheses are valid**,\\u200B then the **stack will be empty once the input string finishes.**\\n\\n\\n![image](https://assets.leetcode.com/users/images/43d47c5f-7e64-4555-bb0b-83b8e037b025_1647133071.1094875.png)\\n\\n**CODE WITH EXPLANATION**\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        //taking stack for keep tracking the order of the brackets..\\n        stack <char> st;\\n        \\n        int len = s.length();\\n        for (int i = 0; i<len ; i++)//iterate over each and every elements\\n        {\\n             //if current element of the string will be opening bracket\\n             //then we will just simply push it into the stack\\n            if(s[i] == \\'(\\' || s[i] == \\'{\\' || s[i] == \\'[\\')\\n                st.push(s[i]);\\n            else if(s[i] == \\')\\' || s[i] == \\'}\\' || s[i] == \\']\\')\\n            {\\n                if(st.empty())\\n                    return false;\\n                else if(s[i] == \\')\\' && st.top() != \\'(\\')\\n                    return false;\\n                else if(s[i] == \\'}\\' && st.top() != \\'{\\')\\n                    return false;\\n                else if(s[i] == \\']\\' && st.top() != \\'[\\')\\n                    return false;\\n                //if control reaches to that line,\\n                //it means we have got the right pair of brackets,\\n                //so just pop it.\\n                else \\n                    st.pop();\\n            }\\n        }\\n        if(st.empty())\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Stack Problem with Initution.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\n``` ```\n``` ```\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        //taking stack for keep tracking the order of the brackets..\\n        stack <char> st;\\n        \\n        int len = s.length();\\n        for (int i = 0; i<len ; i++)//iterate over each and every elements\\n        {\\n             //if current element of the string will be opening bracket\\n             //then we will just simply push it into the stack\\n            if(s[i] == \\'(\\' || s[i] == \\'{\\' || s[i] == \\'[\\')\\n                st.push(s[i]);\\n            else if(s[i] == \\')\\' || s[i] == \\'}\\' || s[i] == \\']\\')\\n            {\\n                if(st.empty())\\n                    return false;\\n                else if(s[i] == \\')\\' && st.top() != \\'(\\')\\n                    return false;\\n                else if(s[i] == \\'}\\' && st.top() != \\'{\\')\\n                    return false;\\n                else if(s[i] == \\']\\' && st.top() != \\'[\\')\\n                    return false;\\n                //if control reaches to that line,\\n                //it means we have got the right pair of brackets,\\n                //so just pop it.\\n                else \\n                    st.pop();\\n            }\\n        }\\n        if(st.empty())\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844055,
                "title": "java-c-i-gauranteed-you-ll-gonna-understand",
                "content": "`How\\'s going Ladies - n - Gentlemen`, today we are going to solve another coolest problem i.e. **Valid Parentheses**\\n\\nOkay, so let\\'s first of all understand the problem what it\\'s saying. \\n```\\nWe have given :\\nA string s containing just the characters \\'(\\', \\')\\', \\'{\\', \\'}\\', \\'[\\' and \\']\\', we have to check if input string is valid or not\\n\\nAn input string is valid if:\\n\\nOpen brackets must be closed by the same type of brackets.\\nOpen brackets must be closed in the correct order.\\n```\\n\\nOkay, so let\\'s take one example inorder to understand the problem:\\n\\n**Input**: s = \"()[]{}\"\\n**Output**: true\\n\\n![image](https://assets.leetcode.com/users/images/c5eba072-5d23-4bef-b01f-5aeb760ab67f_1647144130.6761522.png)\\n\\nSo, what we do is. We\\'ll use the help of Stack to solve this problem.\\n\\n***Just follow my step\\'s you\\'ll gonna understand***\\n\\n* Our First step is if we find an opening bracket there only 3 types of opening bracket possible. **Circular \\'(\\'**, **Spquare \\'[\\'** & **Curly \\'{\\'** if we find any of these we will put into our stack.\\n\\n\\n* After filling any of these into our stack, while moving forward if we find any of closing bracket we will pop it out. But there will be **3 cases**, **first one** the closing bracket has to be similar to opening bracket. If they are not similar we gonna simply return false, from there. **Second case** if we pop out every element means our `stack is empty` but we left with one more closing bracket, we gonna simply return false. **Third case** we will pop out every elemnt as they all are similar to their opening one. \\n* Finally in the end we\\'ll check if the stack becomes empty **return true** otherwise stack is not empty **return false**.   \\n\\nLet\\'s understand it visually:-\\n\\n![image](https://assets.leetcode.com/users/images/9a121388-3f2f-48f4-9fa7-77e629396a65_1647142941.9872801.gif)\\n\\n*Ihope Ladies - n - Gentlemen approach is clear* **Let\\'s code it up, then**\\n\\n**Java**\\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        // We need a stack\\n        Stack<Character> st = new Stack<>();\\n        // iterate over all the character\\'s available in the string\\n        for(int i = 0; i < s.length(); i++){\\n            char ch = s.charAt(i);\\n            // if we find opening then put in the stack\\n            if(ch == \\'(\\' || ch == \\'{\\' || ch == \\'[\\'){\\n                st.push(ch);\\n            }\\n            // if we find closing then there could be 3 condition\\'s\\n            else if(ch == \\')\\'){\\n                // if stack is empty return false\\n                if(st.isEmpty()) return false;\\n                // if the opening element we want is not equals to that present in stack return false \\n                else if(st.peek() != \\'(\\') return false;\\n                // if it\\'s the one we want pop it from stack\\n                else st.pop();\\n            }\\n            // similar for these as well\\n            else if(ch == \\']\\'){\\n                if(st.isEmpty()) return false;\\n                else if(st.peek() != \\'[\\') return false;\\n                else st.pop();\\n            }\\n            else if(ch == \\'}\\'){\\n                if(st.isEmpty()) return false;\\n                else if(st.peek() != \\'{\\') return false;\\n                else st.pop();\\n            }\\n        }\\n        // once we have pop each and every element it\\'s time to check, wether our stack is empty or not\\n        if(st.isEmpty()) return true; // if it\\'s return true\\n        return false; // otherwise return false;\\n    }\\n}\\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        // We need a stack\\n        stack<char> st;\\n        // iterate over all the character\\'s available in the string\\n        for(int i = 0; i < s.size(); i++){\\n            // if we find opening then put in the stack\\n            if(s[i] == \\'(\\' || s[i] == \\'{\\' || s[i] == \\'[\\'){\\n                st.push(s[i]);\\n            }\\n            // if we find closing then there could be 3 condition\\'s\\n            else if(s[i] == \\')\\'){\\n                // if stack is empty return false\\n                if(st.empty()) return false;\\n                // if the opening element we want is not equals to that present in stack return false \\n                else if(st.top() != \\'(\\') return false;\\n                // if it\\'s the one we want pop it from stack\\n                else st.pop();\\n            }\\n            // similar for these as well\\n            else if(s[i] == \\']\\'){\\n                if(st.empty()) return false;\\n                else if(st.top() != \\'[\\') return false;\\n                else st.pop();\\n            }\\n            else if(s[i] == \\'}\\'){\\n                if(st.empty()) return false;\\n                else if(st.top() != \\'{\\') return false;\\n                else st.pop();\\n            }\\n        }\\n        // once we have pop each and every element it\\'s time to check, wether our stack is empty or not\\n        if(st.empty()) return true; // if it\\'s return true\\n        return false; // otherwise return false;\\n    }\\n};\\n```\\n\\nANALYSIS:-\\n* **Time Complexity :-** BigO(N)\\n\\n* **Space Complexity :-** BigO(N)",
                "solutionTags": [],
                "code": "```\\nWe have given :\\nA string s containing just the characters \\'(\\', \\')\\', \\'{\\', \\'}\\', \\'[\\' and \\']\\', we have to check if input string is valid or not\\n\\nAn input string is valid if:\\n\\nOpen brackets must be closed by the same type of brackets.\\nOpen brackets must be closed in the correct order.\\n```\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        // We need a stack\\n        Stack<Character> st = new Stack<>();\\n        // iterate over all the character\\'s available in the string\\n        for(int i = 0; i < s.length(); i++){\\n            char ch = s.charAt(i);\\n            // if we find opening then put in the stack\\n            if(ch == \\'(\\' || ch == \\'{\\' || ch == \\'[\\'){\\n                st.push(ch);\\n            }\\n            // if we find closing then there could be 3 condition\\'s\\n            else if(ch == \\')\\'){\\n                // if stack is empty return false\\n                if(st.isEmpty()) return false;\\n                // if the opening element we want is not equals to that present in stack return false \\n                else if(st.peek() != \\'(\\') return false;\\n                // if it\\'s the one we want pop it from stack\\n                else st.pop();\\n            }\\n            // similar for these as well\\n            else if(ch == \\']\\'){\\n                if(st.isEmpty()) return false;\\n                else if(st.peek() != \\'[\\') return false;\\n                else st.pop();\\n            }\\n            else if(ch == \\'}\\'){\\n                if(st.isEmpty()) return false;\\n                else if(st.peek() != \\'{\\') return false;\\n                else st.pop();\\n            }\\n        }\\n        // once we have pop each and every element it\\'s time to check, wether our stack is empty or not\\n        if(st.isEmpty()) return true; // if it\\'s return true\\n        return false; // otherwise return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        // We need a stack\\n        stack<char> st;\\n        // iterate over all the character\\'s available in the string\\n        for(int i = 0; i < s.size(); i++){\\n            // if we find opening then put in the stack\\n            if(s[i] == \\'(\\' || s[i] == \\'{\\' || s[i] == \\'[\\'){\\n                st.push(s[i]);\\n            }\\n            // if we find closing then there could be 3 condition\\'s\\n            else if(s[i] == \\')\\'){\\n                // if stack is empty return false\\n                if(st.empty()) return false;\\n                // if the opening element we want is not equals to that present in stack return false \\n                else if(st.top() != \\'(\\') return false;\\n                // if it\\'s the one we want pop it from stack\\n                else st.pop();\\n            }\\n            // similar for these as well\\n            else if(s[i] == \\']\\'){\\n                if(st.empty()) return false;\\n                else if(st.top() != \\'[\\') return false;\\n                else st.pop();\\n            }\\n            else if(s[i] == \\'}\\'){\\n                if(st.empty()) return false;\\n                else if(st.top() != \\'{\\') return false;\\n                else st.pop();\\n            }\\n        }\\n        // once we have pop each and every element it\\'s time to check, wether our stack is empty or not\\n        if(st.empty()) return true; // if it\\'s return true\\n        return false; // otherwise return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836093,
                "title": "java-beats-100-with-using-hashmap",
                "content": "***Please upvote if it helps, it\\u2018s important for me.***\\n```\\npublic boolean isValid(String s) {\\n        HashMap map = new HashMap();\\n        map.put(\\'(\\',\\')\\');\\n        map.put(\\'[\\',\\']\\');\\n        map.put(\\'{\\',\\'}\\');\\n        Stack<Character> stack = new Stack<>();\\n\\n        for(int i = 0;i < s.length();i++){\\n            char c = s.charAt(i);\\n            if(c == \\'(\\' || c == \\'{\\' || c == \\'[\\'){\\n                stack.push(c);\\n            }else{\\n                if(stack.isEmpty()){\\n                    return false;\\n                }\\n                if(map.get(stack.pop()).equals(c)){\\n                    continue;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\npublic boolean isValid(String s) {\\n        HashMap map = new HashMap();\\n        map.put(\\'(\\',\\')\\');\\n        map.put(\\'[\\',\\']\\');\\n        map.put(\\'{\\',\\'}\\');\\n        Stack<Character> stack = new Stack<>();\\n\\n        for(int i = 0;i < s.length();i++){\\n            char c = s.charAt(i);\\n            if(c == \\'(\\' || c == \\'{\\' || c == \\'[\\'){\\n                stack.push(c);\\n            }else{\\n                if(stack.isEmpty()){\\n                    return false;\\n                }\\n                if(map.get(stack.pop()).equals(c)){\\n                    continue;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 485550,
                "title": "100-time-with-optimizations-explanation",
                "content": "This explanation is more for optimization than explaining over all what is happening.\\nFor those wanting to learn how I did Valid Parenthesis on a high level, I essentially utilized a hash table, stack and a simple loop.\\n\\nGoing into the optimizations\\n*(you can follow along with the numbered items with code comments)*:\\nWe can\\'t speed this up any further so we\\'re going to optimize for certain conditions.\\n1. I defeated a lot of edge cases in `O(1)` with basic + modulus check\\n\\t- It just makes sense that if a string has a odd length, we don\\'t need to waste any more time and just immediately return `false`\\n\\t- eg. `[](`, `{}]`, `}{}` there will never be a length of 3 items that will equate to returning `true`\\n2. The moment we encounter a character that can\\'t pop from the stack, immediately break from the loop and return `false`\\n3. Just add a `!` to turn the value into a boolean data type while also flipping the result\\n\\n\\n```\\n// 1\\nif (s.length === 0) return true\\nif (s.length === 1) return false\\nif (s.length % 2 !== 0) return false\\n\\nconst dictionary = {\\n\\t\\'}\\': \\'{\\',\\n\\t\\')\\': \\'(\\',\\n\\t\\']\\': \\'[\\'\\n}\\nconst stack = []\\n\\nfor (let i = 0; i < s.length; i++) {\\n\\tconst currChar = s[i]\\n\\tconst lastChar = stack[stack.length - 1]\\n\\tconst delChar = dictionary[currChar]\\n\\n\\tif (delChar) {\\n\\t\\t// 2\\n\\t\\tif (delChar === lastChar) {\\n\\t\\t\\tstack.pop()\\n\\t\\t} else {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t} else {\\n\\t\\tstack.push(currChar)\\n\\t}\\n}\\n\\n// 3\\nreturn !stack.length\\n```\\n\\nThe other route with a non-flipped dictionary.\\n\\nI won\\'t write any code for this but explain why this similar approach is not optimized.\\nIf you flip the dictionary, instead of using a stack you\\'ll have to use a queue. With a queue you have to use the `unshift()` and `shift()` methods and those operations are in `O(n)` versus using `O(1)` with `pop()` and `push()`. Overall the time complexity is roughly ~`O(n)` regardless of either method but one is clearly has less operations than the other :)",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\n// 1\\nif (s.length === 0) return true\\nif (s.length === 1) return false\\nif (s.length % 2 !== 0) return false\\n\\nconst dictionary = {\\n\\t\\'}\\': \\'{\\',\\n\\t\\')\\': \\'(\\',\\n\\t\\']\\': \\'[\\'\\n}\\nconst stack = []\\n\\nfor (let i = 0; i < s.length; i++) {\\n\\tconst currChar = s[i]\\n\\tconst lastChar = stack[stack.length - 1]\\n\\tconst delChar = dictionary[currChar]\\n\\n\\tif (delChar) {\\n\\t\\t// 2\\n\\t\\tif (delChar === lastChar) {\\n\\t\\t\\tstack.pop()\\n\\t\\t} else {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t} else {\\n\\t\\tstack.push(currChar)\\n\\t}\\n}\\n\\n// 3\\nreturn !stack.length\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 255333,
                "title": "python-3-lines-solution",
                "content": "Concise code in Python:\\n\\n```\\nclass Solution(object):\\n    def isValid(self, s):\\n        while \"()\" in s or \"{}\" in s or \\'[]\\' in s:\\n            s = s.replace(\"()\", \"\").replace(\\'{}\\', \"\").replace(\\'[]\\', \"\")\\n        return s == \\'\\'\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isValid(self, s):\\n        while \"()\" in s or \"{}\" in s or \\'[]\\' in s:\\n            s = s.replace(\"()\", \"\").replace(\\'{}\\', \"\").replace(\\'[]\\', \"\")\\n        return s == \\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2606878,
                "title": "javascript-stack-easy-to-understand",
                "content": "```\\nvar isValid = function(s) {\\n    s = s.split(\"\");\\n    var stack = [];\\n    for (var z of s) {\\n        if (z === \"(\" || z === \"{\" || z === \"[\") {\\n            stack.push(z);\\n        } else {\\n            var top = stack[stack.length - 1];\\n            if (z === \")\" && top === \"(\" || z === \"]\" && top === \"[\" || z === \"}\" && top === \"{\")\\n                stack.pop();\\n            else\\n                return false;\\n        }\\n    }\\n    return stack.length === 0;\\n};\\n//Please vote it. If you like it\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nvar isValid = function(s) {\\n    s = s.split(\"\");\\n    var stack = [];\\n    for (var z of s) {\\n        if (z === \"(\" || z === \"{\" || z === \"[\") {\\n            stack.push(z);\\n        } else {\\n            var top = stack[stack.length - 1];\\n            if (z === \")\" && top === \"(\" || z === \"]\" && top === \"[\" || z === \"}\" && top === \"{\")\\n                stack.pop();\\n            else\\n                return false;\\n        }\\n    }\\n    return stack.length === 0;\\n};\\n//Please vote it. If you like it\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1344275,
                "title": "simple-python-solution-4ms-13-5mb-memory-usage",
                "content": "Hello,\\n\\nplease find my solution down below:\\n\\n```\\nclass Solution(object):\\n    def isValid(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        \\n        \"\"\"\\n        Runtime: 4 ms, faster than 99.98% of Python online submissions for Valid Parentheses.\\n        Memory Usage: 13.5 MB, less than 59.39% of Python online submissions for Valid Parentheses.\\n        \"\"\"\\n        ##Mapping the Parentheses\\n        m = {\\'(\\' : \\')\\', \\'[\\': \\']\\', \\'{\\': \\'}\\'}\\n        ##Adding the expected values to stack\\n        stack = []\\n        \\n        ##Iterating through the input array\\n        for i in s:\\n            ## cheacking if the value in the map\\n            if i in m:\\n                ## append to stack the expected values\\n                stack.append(m[i])\\n            ##If not, then we check if the stack is not empty and that the value matches the last value added to the stack\\n            elif len(stack) > 0 and i == stack[-1]:\\n                ## if true, then we pop it (remove it)\\n                stack.pop()\\n            else:\\n                ## if none of the cases matches then we just return false\\n                return False\\n        ## if all the data in stack is popped then we just compare the length of stack to 0 (there should be no element left)\\n        return len(stack) == 0\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def isValid(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        \\n        \"\"\"\\n        Runtime: 4 ms, faster than 99.98% of Python online submissions for Valid Parentheses.\\n        Memory Usage: 13.5 MB, less than 59.39% of Python online submissions for Valid Parentheses.\\n        \"\"\"\\n        ##Mapping the Parentheses\\n        m = {\\'(\\' : \\')\\', \\'[\\': \\']\\', \\'{\\': \\'}\\'}\\n        ##Adding the expected values to stack\\n        stack = []\\n        \\n        ##Iterating through the input array\\n        for i in s:\\n            ## cheacking if the value in the map\\n            if i in m:\\n                ## append to stack the expected values\\n                stack.append(m[i])\\n            ##If not, then we check if the stack is not empty and that the value matches the last value added to the stack\\n            elif len(stack) > 0 and i == stack[-1]:\\n                ## if true, then we pop it (remove it)\\n                stack.pop()\\n            else:\\n                ## if none of the cases matches then we just return false\\n                return False\\n        ## if all the data in stack is popped then we just compare the length of stack to 0 (there should be no element left)\\n        return len(stack) == 0\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 9290,
                "title": "c-solution",
                "content": "```\\n        public bool IsValid(string s)\\n        {\\n            Stack<char> sign = new Stack<char>();\\n\\n            foreach (var item in s.ToCharArray())\\n                if (item == '(')\\n                    sign.Push(')');\\n                else if (item == '[')\\n                    sign.Push(']');\\n                else if (item == '{')\\n                    sign.Push('}');\\n                else if (sign.Count == 0 || sign.Pop() != item)\\n                    return false;\\n\\n            return sign.Count == 0;\\n        }",
                "solutionTags": [],
                "code": "```\\n        public bool IsValid(string s)\\n        {\\n            Stack<char> sign = new Stack<char>();\\n\\n            foreach (var item in s.ToCharArray())\\n                if (item == '(')\\n                    sign.Push(')');\\n                else if (item == '[')\\n                    sign.Push(']');\\n                else if (item == '{')\\n                    sign.Push('}');\\n                else if (sign.Count == 0 || sign.Pop() != item)\\n                    return false;\\n\\n            return sign.Count == 0;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3398778,
                "title": "easy-approach-short-code-beats-100-c-solution",
                "content": "# **PLEASE UPVOTE \\uD83D\\uDC4D**\\n# Approach\\n### - Using stacks, we check if a character is cloasing parantheses and top element of stack is not opening parantheses of same kind, then it is not a valid parantheses.\\n### - If the stack is not empty,that is there is an opening parentheses without a corresponding closing parentheses and we can return False, else return true.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        for(auto i:s)\\n        {\\n            // if element is open parantheses, push it in stack\\n            if(i==\\'(\\' or i==\\'{\\' or i==\\'[\\')\\n            st.push(i);\\n            else\\n            {\\n                // checking if top element is opening parantheses\\n                // of same kind as closing parantheses\\n                if(st.empty() or (st.top()==\\'(\\' and i!=\\')\\') or (st.top()==\\'{\\' and i!=\\'}\\') or (st.top()==\\'[\\' and i!=\\']\\')) return false;\\n                st.pop();\\n            }\\n        }\\n        // If the stack is not empty,that is there is an opening \\n        // parentheses without a corresponding closing parentheses and we can return False, else return true.\\n        return st.empty();\\n    }\\n};\\n```\\n\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/36eaaf9c-c98c-43d4-8ffc-ca4c8dda58e4_1681084938.55218.png)\\n",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        for(auto i:s)\\n        {\\n            // if element is open parantheses, push it in stack\\n            if(i==\\'(\\' or i==\\'{\\' or i==\\'[\\')\\n            st.push(i);\\n            else\\n            {\\n                // checking if top element is opening parantheses\\n                // of same kind as closing parantheses\\n                if(st.empty() or (st.top()==\\'(\\' and i!=\\')\\') or (st.top()==\\'{\\' and i!=\\'}\\') or (st.top()==\\'[\\' and i!=\\']\\')) return false;\\n                st.pop();\\n            }\\n        }\\n        // If the stack is not empty,that is there is an opening \\n        // parentheses without a corresponding closing parentheses and we can return False, else return true.\\n        return st.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 310836,
                "title": "go",
                "content": "```\\nfunc isValid(s string) bool {\\n    stack := make([]rune, 0)\\n    m := map[rune]rune {\\n        \\')\\': \\'(\\',\\n        \\']\\': \\'[\\',\\n        \\'}\\': \\'{\\',\\n    }\\n    for _, c := range s {\\n        switch c {\\n        case \\'(\\', \\'{\\', \\'[\\':\\n            stack = append(stack, c)\\n        case \\')\\', \\'}\\', \\']\\':\\n            if len(stack) == 0 || stack[len(stack) - 1] != m[c]{\\n                return false\\n            }\\n            stack = stack[:len(stack)-1]\\n        }\\n    }\\n    \\n    return len(stack) == 0\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isValid(s string) bool {\\n    stack := make([]rune, 0)\\n    m := map[rune]rune {\\n        \\')\\': \\'(\\',\\n        \\']\\': \\'[\\',\\n        \\'}\\': \\'{\\',\\n    }\\n    for _, c := range s {\\n        switch c {\\n        case \\'(\\', \\'{\\', \\'[\\':\\n            stack = append(stack, c)\\n        case \\')\\', \\'}\\', \\']\\':\\n            if len(stack) == 0 || stack[len(stack) - 1] != m[c]{\\n                return false\\n            }\\n            stack = stack[:len(stack)-1]\\n        }\\n    }\\n    \\n    return len(stack) == 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 9287,
                "title": "javascript-solution-with-a-stack",
                "content": "```javascript\\nvar map = {\\n    \"(\": \")\",\\n    \"[\": \"]\",\\n    \"{\": \"}\"\\n} \\n\\nvar isValid = function(s) {\\n    var stack = [];\\n    \\n    for (var i = 0; i < s.length; i++) {\\n        var el = s[i];\\n        \\n        if (map[el]) {\\n            stack.push(map[el]);\\n        } else {\\n            if (el !== stack.pop()) {\\n                return false;\\n            }\\n        }\\n    }\\n    \\n    return stack.length === 0;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar map = {\\n    \"(\": \")\",\\n    \"[\": \"]\",\\n    \"{\": \"}\"\\n} \\n\\nvar isValid = function(s) {\\n    var stack = [];\\n    \\n    for (var i = 0; i < s.length; i++) {\\n        var el = s[i];\\n        \\n        if (map[el]) {\\n            stack.push(map[el]);\\n        } else {\\n            if (el !== stack.pop()) {\\n                return false;\\n            }\\n        }\\n    }\\n    \\n    return stack.length === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2765288,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        stack = []\\n        \\n        mapping = {\\n            \\'(\\':\\')\\',\\n            \\'[\\':\\']\\',\\n            \\'{\\':\\'}\\'            \\n        }\\n        \\n        for char in s:\\n            if char in mapping.keys():\\n                stack.append(mapping[char])\\n            elif not stack or stack[-1]!=char:\\n                return False\\n            else:\\n                stack.pop()\\n        \\n        return len(stack)==0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        stack = []\\n        \\n        mapping = {\\n            \\'(\\':\\')\\',\\n            \\'[\\':\\']\\',\\n            \\'{\\':\\'}\\'            \\n        }\\n        \\n        for char in s:\\n            if char in mapping.keys():\\n                stack.append(mapping[char])\\n            elif not stack or stack[-1]!=char:\\n                return False\\n            else:\\n                stack.pop()\\n        \\n        return len(stack)==0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 9482,
                "title": "8-line-python-solution-stack-40ms",
                "content": "    def isValid(self, s):\\n        stack, match = [], {')': '(', ']': '[', '}': '{'}\\n        for ch in s:\\n            if ch in match:\\n                if not (stack and stack.pop() == match[ch]):\\n                    return False\\n            else:\\n                stack.append(ch)\\n        return not stack",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "    def isValid(self, s):\\n        stack, match = [], {')': '(', ']': '[', '}': '{'}\\n        for ch in s:\\n            if ch in match:\\n                if not (stack and stack.pop() == match[ch]):\\n                    return False\\n            else:\\n                stack.append(ch)\\n        return not stack",
                "codeTag": "Python3"
            },
            {
                "id": 3399238,
                "title": "image-explanation-simple-easy-concise-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\n`Valid Parentheses` by `Aryan Mittal`\\n![lc.png](https://assets.leetcode.com/users/images/3b59ee3a-2f4c-49ab-b21d-7c87869d1ba1_1681101370.6286416.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/bfdc7e48-69cf-413d-89c1-fe549116e9fc_1681088177.3930035.png)\\n![image.png](https://assets.leetcode.com/users/images/116f93bd-ce00-49d6-b640-066cb1b2b01e_1681088187.9960895.png)\\n![image.png](https://assets.leetcode.com/users/images/1e9d58fc-8d32-4f7a-8a94-54980103be4a_1681088198.6828957.png)\\n![image.png](https://assets.leetcode.com/users/images/4f20c5de-d995-4bc9-a95b-13e08808dd4e_1681088208.9085774.png)\\n![image.png](https://assets.leetcode.com/users/images/3db8acca-0621-47ab-9001-b5a4a24e23c2_1681088216.033085.png)\\n![image.png](https://assets.leetcode.com/users/images/14027d33-836b-4824-a79c-dfee0dbecb12_1681088224.4547505.png)\\n![image.png](https://assets.leetcode.com/users/images/5b747146-588d-4035-a460-5962b2cd5a2a_1681088239.9492495.png)\\n![image.png](https://assets.leetcode.com/users/images/0cf3a95f-434d-4f0e-bd72-5149822bbb5f_1681088245.5975442.png)\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        for(auto c:s)\\n        {\\n            if(c==\\'(\\' or c==\\'{\\' or c==\\'[\\') { \\n                st.push(c); \\n            }\\n            else {\\n                if(st.empty() or (st.top()==\\'(\\' and c!=\\')\\') or (st.top()==\\'{\\' and c!=\\'}\\') or (st.top()==\\'[\\' and c!=\\']\\')) return false;\\n                st.pop();\\n            }\\n        }\\n        return st.empty();\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> st = new Stack<>();\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\' || c == \\'{\\' || c == \\'[\\') {\\n                st.push(c);\\n            } else {\\n                if (st.isEmpty() || (st.peek() == \\'(\\' && c != \\')\\') || (st.peek() == \\'{\\' && c != \\'}\\') || (st.peek() == \\'[\\' && c != \\']\\')) {\\n                    return false;\\n                }\\n                st.pop();\\n            }\\n        }\\n        return st.isEmpty();\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        st = []\\n        for c in s:\\n            if c == \\'(\\' or c == \\'{\\' or c == \\'[\\':\\n                st.append(c)\\n            else:\\n                if not st or (st[-1] == \\'(\\' and c != \\')\\') or (st[-1] == \\'{\\' and c != \\'}\\') or (st[-1] == \\'[\\' and c != \\']\\'):\\n                    return False\\n                st.pop()\\n        return not st\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "String",
                    "Stack"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        for(auto c:s)\\n        {\\n            if(c==\\'(\\' or c==\\'{\\' or c==\\'[\\') { \\n                st.push(c); \\n            }\\n            else {\\n                if(st.empty() or (st.top()==\\'(\\' and c!=\\')\\') or (st.top()==\\'{\\' and c!=\\'}\\') or (st.top()==\\'[\\' and c!=\\']\\')) return false;\\n                st.pop();\\n            }\\n        }\\n        return st.empty();\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> st = new Stack<>();\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\' || c == \\'{\\' || c == \\'[\\') {\\n                st.push(c);\\n            } else {\\n                if (st.isEmpty() || (st.peek() == \\'(\\' && c != \\')\\') || (st.peek() == \\'{\\' && c != \\'}\\') || (st.peek() == \\'[\\' && c != \\']\\')) {\\n                    return false;\\n                }\\n                st.pop();\\n            }\\n        }\\n        return st.isEmpty();\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        st = []\\n        for c in s:\\n            if c == \\'(\\' or c == \\'{\\' or c == \\'[\\':\\n                st.append(c)\\n            else:\\n                if not st or (st[-1] == \\'(\\' and c != \\')\\') or (st[-1] == \\'{\\' and c != \\'}\\') or (st[-1] == \\'[\\' and c != \\']\\'):\\n                    return False\\n                st.pop()\\n        return not st\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1843839,
                "title": "python3-stack-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nUsually, the validity of brackets is checked by using a stack. Every time we see an open bracket, we push it to the stack. Every time we see a close bracket, we check whether the last element in the stack is an open bracket. If not, we return false. Since we have three types of brackets, we need a hashmap that maps open brackets to their close kin.\\n\\nTime: **O(n)**\\nSpace: **O(n)**\\n\\nRuntime: 28 ms, faster than **95.58%** of Python3 online submissions for Valid Parentheses.\\nMemory Usage: 13.8 MB, less than **82.06%** of Python3 online submissions for Valid Parentheses.\\n\\n```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        stack, hm = [], {\\'(\\': \\')\\', \\'{\\': \\'}\\', \\'[\\': \\']\\'}\\n        for ch in s:\\n\\t\\t\\t# open bracket\\n            if ch in hm: \\n                stack.append(ch)\\n\\t\\t\\t# close bracket\\n            else: \\n                if not stack or hm[stack[-1]] != ch: return False\\n                stack.pop()\\n\\n        return not stack\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        stack, hm = [], {\\'(\\': \\')\\', \\'{\\': \\'}\\', \\'[\\': \\']\\'}\\n        for ch in s:\\n\\t\\t\\t# open bracket\\n            if ch in hm: \\n                stack.append(ch)\\n\\t\\t\\t# close bracket\\n            else: \\n                if not stack or hm[stack[-1]] != ch: return False\\n                stack.pop()\\n\\n        return not stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2746306,
                "title": "java-runtime-1ms-faster-than-99-79-detailed-solution",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        char[] chars = s.toCharArray();\\n        Stack<Character> stack = new Stack<>();\\n        for (char element : chars) {\\n            if (element == \\'(\\' || element == \\'[\\' || element == \\'{\\') {\\n                stack.push(element);\\n                continue;\\n            } else if (stack.empty()) {\\n                return false;\\n            }\\n            char top = stack.pop();\\n            if (top == \\'(\\' && element != \\')\\') {\\n                return false;\\n            } else if (top == \\'[\\' && element != \\']\\') {\\n                return false;\\n            } else if (top == \\'{\\' && element != \\'}\\') {\\n                return false;\\n            }\\n        }\\n        return stack.empty();\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/c9c8b968-54da-4511-9145-29dcec3e8f7d_1666794336.4971058.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        char[] chars = s.toCharArray();\\n        Stack<Character> stack = new Stack<>();\\n        for (char element : chars) {\\n            if (element == \\'(\\' || element == \\'[\\' || element == \\'{\\') {\\n                stack.push(element);\\n                continue;\\n            } else if (stack.empty()) {\\n                return false;\\n            }\\n            char top = stack.pop();\\n            if (top == \\'(\\' && element != \\')\\') {\\n                return false;\\n            } else if (top == \\'[\\' && element != \\']\\') {\\n                return false;\\n            } else if (top == \\'{\\' && element != \\'}\\') {\\n                return false;\\n            }\\n        }\\n        return stack.empty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 980783,
                "title": "javascript-stack",
                "content": "Runtime: 64 ms, faster than 99.77% of JavaScript online submissions for Valid Parentheses.\\nMemory Usage: 38.7 MB, less than 66.60% of JavaScript online submissions for Valid Parentheses.\\n\\n```\\nfunction isValid(s) {\\n  const left = [];\\n  const legend = {\\n    \\'(\\': \\')\\',\\n    \\'{\\': \\'}\\',\\n    \\'[\\': \\']\\'\\n  };\\n  for (let i = 0; i < s.length; i++) {\\n    if (s[i] === \\'(\\' || s[i] === \\'{\\' || s[i] === \\'[\\') {\\n      left.push(s[i]);    \\n    } else if (legend[left.pop()] !== s[i]) {\\n      return false;\\n    }\\n  }\\n  return left.length ? 0 : 1;\\n};",
                "solutionTags": [],
                "code": "Runtime: 64 ms, faster than 99.77% of JavaScript online submissions for Valid Parentheses.\\nMemory Usage: 38.7 MB, less than 66.60% of JavaScript online submissions for Valid Parentheses.\\n\\n```\\nfunction isValid(s) {\\n  const left = [];\\n  const legend = {\\n    \\'(\\': \\')\\',\\n    \\'{\\': \\'}\\',\\n    \\'[\\': \\']\\'\\n  };\\n  for (let i = 0; i < s.length; i++) {\\n    if (s[i] === \\'(\\' || s[i] === \\'{\\' || s[i] === \\'[\\') {\\n      left.push(s[i]);    \\n    } else if (legend[left.pop()] !== s[i]) {\\n      return false;\\n    }\\n  }\\n  return left.length ? 0 : 1;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1529337,
                "title": "java-tc-o-n-sc-o-n-2-optimized-stack-solution-w-early-exit-conditions",
                "content": "```java\\n/**\\n * Using Stack. Space Optimized solution with early exit conditions.\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(N/2 + 1) = O(N)\\n *\\n * N = Length of input string.\\n */\\nclass Solution {\\n    public boolean isValid(String s) {\\n        // If the length is odd, return false\\n        if (s == null || s.length() % 2 != 0) {\\n            return false;\\n        }\\n\\n        int sLen = s.length();\\n        if (sLen == 0) {\\n            return true;\\n        }\\n\\n        // First Char cannot be closing bracket\\n        char firstChar = s.charAt(0);\\n        if (firstChar == \\')\\' || firstChar == \\'}\\' || firstChar == \\']\\') {\\n            return false;\\n        }\\n        // Last Char cannot be open bracket\\n        char lastChar = s.charAt(sLen - 1);\\n        if (lastChar == \\'(\\' || lastChar == \\'{\\' || lastChar == \\'[\\') {\\n            return false;\\n        }\\n\\n        Deque<Character> stack = new ArrayDeque<>();\\n        for (int i = 0; i < sLen; i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'(\\') {\\n                stack.push(\\')\\');\\n            } else if (c == \\'{\\') {\\n                stack.push(\\'}\\');\\n            } else if (c == \\'[\\') {\\n                stack.push(\\']\\');\\n            } else if (stack.isEmpty() || c != stack.pop()) {\\n                return false;\\n            }\\n\\n            // Since there are more characters in stack than remaining characters in S, we\\n            // can early exit.\\n            if (stack.size() > sLen - i) {\\n                return false;\\n            }\\n        }\\n\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```java\\n/**\\n * Using Stack. Space Optimized solution with early exit conditions.\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(N/2 + 1) = O(N)\\n *\\n * N = Length of input string.\\n */\\nclass Solution {\\n    public boolean isValid(String s) {\\n        // If the length is odd, return false\\n        if (s == null || s.length() % 2 != 0) {\\n            return false;\\n        }\\n\\n        int sLen = s.length();\\n        if (sLen == 0) {\\n            return true;\\n        }\\n\\n        // First Char cannot be closing bracket\\n        char firstChar = s.charAt(0);\\n        if (firstChar == \\')\\' || firstChar == \\'}\\' || firstChar == \\']\\') {\\n            return false;\\n        }\\n        // Last Char cannot be open bracket\\n        char lastChar = s.charAt(sLen - 1);\\n        if (lastChar == \\'(\\' || lastChar == \\'{\\' || lastChar == \\'[\\') {\\n            return false;\\n        }\\n\\n        Deque<Character> stack = new ArrayDeque<>();\\n        for (int i = 0; i < sLen; i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'(\\') {\\n                stack.push(\\')\\');\\n            } else if (c == \\'{\\') {\\n                stack.push(\\'}\\');\\n            } else if (c == \\'[\\') {\\n                stack.push(\\']\\');\\n            } else if (stack.isEmpty() || c != stack.pop()) {\\n                return false;\\n            }\\n\\n            // Since there are more characters in stack than remaining characters in S, we\\n            // can early exit.\\n            if (stack.size() > sLen - i) {\\n                return false;\\n            }\\n        }\\n\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 9271,
                "title": "my-python-solution",
                "content": "   \\n\\n     class Solution:\\n            # @param {string} s\\n            # @return {boolean}\\n            def isValid(self, s):\\n                stack=[]\\n                for i in s:\\n                    if i in ['(','[','{']:\\n                        stack.append(i)\\n                    else:\\n                        if not stack or {')':'(',']':'[','}':'{'}[i]!=stack[-1]:\\n                            return False\\n                        stack.pop()\\n                return not stack",
                "solutionTags": [],
                "code": "class Solution:\\n            # @param {string}",
                "codeTag": "Java"
            },
            {
                "id": 3398851,
                "title": "image-explanation-simple-easy-concise-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\n`Valid Parentheses` by `Aryan Mittal`\\n![lc.png](https://assets.leetcode.com/users/images/43f51701-e8e3-43f7-a817-9ad3cbda9f1a_1681093291.7883658.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/bfdc7e48-69cf-413d-89c1-fe549116e9fc_1681088177.3930035.png)\\n![image.png](https://assets.leetcode.com/users/images/116f93bd-ce00-49d6-b640-066cb1b2b01e_1681088187.9960895.png)\\n![image.png](https://assets.leetcode.com/users/images/1e9d58fc-8d32-4f7a-8a94-54980103be4a_1681088198.6828957.png)\\n![image.png](https://assets.leetcode.com/users/images/4f20c5de-d995-4bc9-a95b-13e08808dd4e_1681088208.9085774.png)\\n![image.png](https://assets.leetcode.com/users/images/3db8acca-0621-47ab-9001-b5a4a24e23c2_1681088216.033085.png)\\n![image.png](https://assets.leetcode.com/users/images/14027d33-836b-4824-a79c-dfee0dbecb12_1681088224.4547505.png)\\n![image.png](https://assets.leetcode.com/users/images/5b747146-588d-4035-a460-5962b2cd5a2a_1681088239.9492495.png)\\n![image.png](https://assets.leetcode.com/users/images/0cf3a95f-434d-4f0e-bd72-5149822bbb5f_1681088245.5975442.png)\\n![image.png](https://assets.leetcode.com/users/images/525cd301-753f-4453-918f-818b8452db3d_1681088410.9803467.png)\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        for(auto c:s)\\n        {\\n            if(c==\\'(\\' or c==\\'{\\' or c==\\'[\\') { \\n                st.push(c); \\n            }\\n            else {\\n                if(st.empty() or (st.top()==\\'(\\' and c!=\\')\\') or (st.top()==\\'{\\' and c!=\\'}\\') or (st.top()==\\'[\\' and c!=\\']\\')) return false;\\n                st.pop();\\n            }\\n        }\\n        return st.empty();\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> st = new Stack<>();\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\' || c == \\'{\\' || c == \\'[\\') {\\n                st.push(c);\\n            } else {\\n                if (st.isEmpty() || (st.peek() == \\'(\\' && c != \\')\\') || (st.peek() == \\'{\\' && c != \\'}\\') || (st.peek() == \\'[\\' && c != \\']\\')) {\\n                    return false;\\n                }\\n                st.pop();\\n            }\\n        }\\n        return st.isEmpty();\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        st = []\\n        for c in s:\\n            if c == \\'(\\' or c == \\'{\\' or c == \\'[\\':\\n                st.append(c)\\n            else:\\n                if not st or (st[-1] == \\'(\\' and c != \\')\\') or (st[-1] == \\'{\\' and c != \\'}\\') or (st[-1] == \\'[\\' and c != \\']\\'):\\n                    return False\\n                st.pop()\\n        return not st\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "String",
                    "Stack"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        for(auto c:s)\\n        {\\n            if(c==\\'(\\' or c==\\'{\\' or c==\\'[\\') { \\n                st.push(c); \\n            }\\n            else {\\n                if(st.empty() or (st.top()==\\'(\\' and c!=\\')\\') or (st.top()==\\'{\\' and c!=\\'}\\') or (st.top()==\\'[\\' and c!=\\']\\')) return false;\\n                st.pop();\\n            }\\n        }\\n        return st.empty();\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> st = new Stack<>();\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\' || c == \\'{\\' || c == \\'[\\') {\\n                st.push(c);\\n            } else {\\n                if (st.isEmpty() || (st.peek() == \\'(\\' && c != \\')\\') || (st.peek() == \\'{\\' && c != \\'}\\') || (st.peek() == \\'[\\' && c != \\']\\')) {\\n                    return false;\\n                }\\n                st.pop();\\n            }\\n        }\\n        return st.isEmpty();\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        st = []\\n        for c in s:\\n            if c == \\'(\\' or c == \\'{\\' or c == \\'[\\':\\n                st.append(c)\\n            else:\\n                if not st or (st[-1] == \\'(\\' and c != \\')\\') or (st[-1] == \\'{\\' and c != \\'}\\') or (st[-1] == \\'[\\' and c != \\']\\'):\\n                    return False\\n                st.pop()\\n        return not st\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263566,
                "title": "easiest-solution-of-all",
                "content": "I can\\'t believe this worked LMAO\\n\\n    public boolean isValid(String s) {\\n                while (s.indexOf(\"{}\") !=-1 || s.indexOf(\"[]\") !=-1 || s.indexOf(\"()\") !=-1 ){\\n            s=s.replace(\"()\",\"\");\\n            s=s.replace(\"[]\",\"\");\\n            s=s.replace(\"{}\",\"\");\\n            \\n        }\\n        return s.isEmpty();\\n    }\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "I can\\'t believe this worked LMAO\\n\\n    public boolean isValid(String s) {\\n                while (s.indexOf(\"{}\") !=-1 || s.indexOf(\"[]\") !=-1 || s.indexOf(\"()\") !=-1 ){\\n            s=s.replace(\"()\",\"\");\\n            s=s.replace(\"[]\",\"\");\\n            s=s.replace(\"{}\",\"\");\\n            \\n        }\\n        return s.isEmpty();\\n    }\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1025791,
                "title": "python-stack-solution-explained",
                "content": "This is very classical problem for using stacks, for me it was literally the first problem I saw on this topic. If you know that you need to use stack here, it becomes nice and easy.\\n\\nWhat is **valid parentheses**? It is when we meet some close bracket, it means that we need to find corresponding open bracked of the same type. We traverse our `s` and if we:\\n1. see open bracket we put it to stack\\n2. see closed bracket, then it must be equal to bracket in the top of our stack, so we check it and if it is true, we remove this pair of brackets.\\n3. In the end, if and only if we have empty stack, we have valid string.\\n\\n**Complexity**: time complexity is `O(n)`: we put and pop each element of string from our stack only once. Space complexity is `O(n)`.\\n\\n```\\nclass Solution:\\n    def isValid(self, s):\\n        dct = {\"[\": \"]\", \"(\": \")\", \"{\" : \"}\"}\\n        stack = []\\n        for char in s:\\n            if char in dct:\\n                stack.append(char)\\n            else:\\n                if not stack or char != dct[stack.pop()]: return False           \\n        return not stack\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, s):\\n        dct = {\"[\": \"]\", \"(\": \")\", \"{\" : \"}\"}\\n        stack = []\\n        for char in s:\\n            if char in dct:\\n                stack.append(char)\\n            else:\\n                if not stack or char != dct[stack.pop()]: return False           \\n        return not stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108171,
                "title": "javascript-solution",
                "content": "```\\nvar isValid = function (s) {\\n  const stack = [];\\n  const complement = {\\n    \\')\\': \\'(\\',\\n    \\'}\\': \\'{\\',\\n    \\']\\': \\'[\\',\\n  };\\n\\n  for (let char of s) {\\n    if (!complement[char]) stack.push(char);\\n    else if (stack.pop() !== complement[char]) return false;\\n  }\\n  return stack.length === 0;\\n};\\n```\\nAlternative:\\n``` \\nconst isValid = (s) => {\\n  const stack = [];\\n  for (const c of s) {\\n    if (c === \\'{\\' || c === \\'[\\' || c === \\'(\\') stack.push(c);\\n    else {\\n      const p = stack.pop(); // No need to check for empty before popping (returns undefined)\\n      if ((c === \\'}\\' && p !== \\'{\\') || (c === \\']\\' && p !== \\'[\\') || (c === \\')\\') & (p !== \\'(\\')) return false;\\n    }\\n  }\\n  return stack.length === 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isValid = function (s) {\\n  const stack = [];\\n  const complement = {\\n    \\')\\': \\'(\\',\\n    \\'}\\': \\'{\\',\\n    \\']\\': \\'[\\',\\n  };\\n\\n  for (let char of s) {\\n    if (!complement[char]) stack.push(char);\\n    else if (stack.pop() !== complement[char]) return false;\\n  }\\n  return stack.length === 0;\\n};\\n```\n``` \\nconst isValid = (s) => {\\n  const stack = [];\\n  for (const c of s) {\\n    if (c === \\'{\\' || c === \\'[\\' || c === \\'(\\') stack.push(c);\\n    else {\\n      const p = stack.pop(); // No need to check for empty before popping (returns undefined)\\n      if ((c === \\'}\\' && p !== \\'{\\') || (c === \\']\\' && p !== \\'[\\') || (c === \\')\\') & (p !== \\'(\\')) return false;\\n    }\\n  }\\n  return stack.length === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1026107,
                "title": "valid-parentheses-short-python-solution-o-n-with-explanation",
                "content": "**Idea**:\\nMaintain a stack of unmatched parentheses. At each character, if it is a closing parenthesis, check if it matches the most recent opening one (at top of the stack).\\n\\n**Implementation**:\\n- Use `list()` as a stack with `append()` to add an element at the end and `pop()` to pop an element at the end.  \\n- Simplify parenthesis-match checking logic using a `dict()` that stores the corresponding opening and closing character. (`pair` and `x != pair[st.pop()]`).\\n\\n**Caveats**:\\n- Be sure to always check if the stack is empty before trying to pop it. (`elif len(st) == 0 ...`)\\n- Don\\'t forget to check if there is any unmatched openings after processing the entire string. (`return len(st) == 0`).\\n\\n```python\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        pair = dict((\\'()\\', \\'[]\\', \\'{}\\'))\\n        st = []\\n        for x in s:\\n            if x in \\'([{\\':\\n                st.append(x)\\n            elif len(st) == 0 or x != pair[st.pop()]:\\n                return False\\n        return len(st) == 0\\n```\\n\\n**Complexity**:\\nTime: O(n), n being the length of `s`. Parsing through each character of the string. Assuming stack push and pop using `list()` takes O(1) and `dict` look up for `pair` takes O(1).\\nSpace: O(n), n being the length of `s`. Worst case `s` contains only openings and the stack would have to store all of them.\\n\\n**Submission Detail**:\\nRuntime: 32 ms (beats 63.20 % of python3 submissions)\\nMemory Usage: 14 MB (beats 97.10 % of python3 submissions)\\n\\n---\\nIf you find this helpful, please **upvote**! It will encourage me to write more like this. Thank you!! \\uD83E\\uDD17",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```python\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        pair = dict((\\'()\\', \\'[]\\', \\'{}\\'))\\n        st = []\\n        for x in s:\\n            if x in \\'([{\\':\\n                st.append(x)\\n            elif len(st) == 0 or x != pair[st.pop()]:\\n                return False\\n        return len(st) == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 885643,
                "title": "python-3-stack-based-simple-solution",
                "content": "**Suggestions to make it better are always welcomed.**\\n\\n1. Create a dictionary for O(1) lookup.\\n2. Create stack and add open braces on the top. If closing braces are encountered, then pop from stack and compare it\\'s closing brace with the encountered brace.\\n3. If closing brace is encountered but the stack is empty, then there\\'s no matching pair for it. Hence return False.\\n4. At the end, we want to make sure our stack is empty after all the matching pairs are found. If stack is not empty, return False.\\n\\n```\\ndef isValid(self, s: str) -> bool:\\n\\tmapping = {\\n\\t\\t\\'(\\': \\')\\',\\n\\t\\t\\'{\\': \\'}\\',\\n\\t\\t\\'[\\': \\']\\'\\n\\t}\\n\\tstack = []\\n\\n\\tfor c in s:\\n\\t\\tif c not in mapping:\\n\\t\\t\\tif not stack or mapping[stack.pop()]!=c:\\n\\t\\t\\t\\treturn False\\n\\t\\telse:\\n\\t\\t\\tstack.append(c)\\n\\n\\treturn len(stack)==0\\n```\\n\\n**I hope that you\\'ve found this useful.\\nIn that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\ndef isValid(self, s: str) -> bool:\\n\\tmapping = {\\n\\t\\t\\'(\\': \\')\\',\\n\\t\\t\\'{\\': \\'}\\',\\n\\t\\t\\'[\\': \\']\\'\\n\\t}\\n\\tstack = []\\n\\n\\tfor c in s:\\n\\t\\tif c not in mapping:\\n\\t\\t\\tif not stack or mapping[stack.pop()]!=c:\\n\\t\\t\\t\\treturn False\\n\\t\\telse:\\n\\t\\t\\tstack.append(c)\\n\\n\\treturn len(stack)==0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 839461,
                "title": "c-easy-solution-using-stack",
                "content": "**Do upvote if this code is useful for you!!**\\nclass Solution {\\npublic:\\n\\n    bool isValid(string s) {\\n         stack<char> sack;\\n         int n = s.size();\\n         for(int i=0;i<n;i++)\\n         {   \\n             if(s[i]==\\'(\\' || s[i]==\\'{\\' || s[i]==\\'[\\')\\n             { \\n               sack.push(s[i]);\\n               continue;\\n             }\\n             if(sack.empty())\\n                 return false;\\n             char x = sack.top();\\n             if((x==\\'(\\' && s[i]==\\')\\') || (x==\\'{\\' && s[i]==\\'}\\') || (x==\\'[\\' && s[i]==\\']\\'))\\n                 sack.pop();\\n             else\\n                return false;\\n         } \\n         if(sack.empty())\\n             return true;\\n         return false;\\n     }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool isValid(string s) {\\n         stack<char> sack;\\n         int n = s.size();\\n         for(int i=0;i<n;i++)\\n         {   \\n             if(s[i]==\\'(\\' || s[i]==\\'{\\' || s[i]==\\'[\\')\\n             { \\n               sack.push(s[i]);\\n               continue;\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 9588,
                "title": "python-easy-to-understand-solution-using-stack",
                "content": "\\n    def isValid(self, s):\\n        left, right, stack= \"({[\", \")}]\", []\\n        for item in s:\\n            if item in left:\\n                stack.append(item)\\n            elif not stack or left.find(stack.pop()) != right.find(item):\\n                return False\\n        return not stack",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "\\n    def isValid(self, s):\\n        left, right, stack= \"({[\", \")}]\", []\\n        for item in s:\\n            if item in left:\\n                stack.append(item)\\n            elif not stack or left.find(stack.pop()) != right.find(item):\\n                return False\\n        return not stack",
                "codeTag": "Python3"
            },
            {
                "id": 2057356,
                "title": "0ms-1liner-100-fastest-solution-explained-o-n-time-complexity-o-n-space-complexity",
                "content": "**As a professional with a passion for problem-solving and collaboration, I am always looking to expand my network of like-minded individuals on LinkedIn. By connecting with me, we can work together to tackle complex challenges, share ideas, and grow both professionally and personally.**\\n\\n**Whether you\\'re an expert in your field or just starting out, I welcome connections from all backgrounds and experiences. By building a diverse and collaborative network, we can leverage our unique perspectives and skill sets to push the boundaries of what\\'s possible.**\\n\\n**So, if you\\'re interested in connecting and exploring the potential for future collaborations, please don\\'t hesitate to reach out. Let\\'s start a conversation and see where it takes us!**\\n\\n---\\n\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\n\\n---\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* *** Java ***\\n\\n```\\n\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Map<Character,Character> mappings = new HashMap<Character,Character>(){{\\n            put(\\')\\', \\'(\\');\\n            put(\\'}\\', \\'{\\');\\n            put(\\']\\', \\'[\\');\\n        }};\\n\\n        Stack<Character> letters = new Stack<>();\\n\\t\\t\\n        for(int i = 0; i < s.length(); i++){\\n            char temp = s.charAt(i);\\n            if(mappings.containsKey(temp)){\\n                if(letters.isEmpty() || letters.pop() != mappings.get(temp)){\\n                    return false;\\n                }\\n            } else{\\n                letters.push(temp);\\n            }\\n        }\\n        return letters.isEmpty();\\n    }\\n}\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n***\"We are Anonymous. We are legion. We do not forgive. We do not forget. Expect us. Open your eyes..\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Combinatorics"
                ],
                "code": "```\\n```\n```\\n\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Map<Character,Character> mappings = new HashMap<Character,Character>(){{\\n            put(\\')\\', \\'(\\');\\n            put(\\'}\\', \\'{\\');\\n            put(\\']\\', \\'[\\');\\n        }};\\n\\n        Stack<Character> letters = new Stack<>();\\n\\t\\t\\n        for(int i = 0; i < s.length(); i++){\\n            char temp = s.charAt(i);\\n            if(mappings.containsKey(temp)){\\n                if(letters.isEmpty() || letters.pop() != mappings.get(temp)){\\n                    return false;\\n                }\\n            } else{\\n                letters.push(temp);\\n            }\\n        }\\n        return letters.isEmpty();\\n    }\\n}\\n\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 395598,
                "title": "java-time-98-memory-100-with-stack",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\' || c == \\'[\\' || c == \\'{\\')\\n                stack.push(c);\\n            else {\\n                if (stack.isEmpty())\\n                    return false;\\n                if (c == \\')\\') {\\n                    if (\\'(\\' != stack.pop())\\n                        return false;\\n                } else if (c == \\']\\') {\\n                    if (\\'[\\' != stack.pop())\\n                        return false;\\n                } else if (c == \\'}\\') {\\n                    if (\\'{\\' != stack.pop())\\n                        return false;\\n                }\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\' || c == \\'[\\' || c == \\'{\\')\\n                stack.push(c);\\n            else {\\n                if (stack.isEmpty())\\n                    return false;\\n                if (c == \\')\\') {\\n                    if (\\'(\\' != stack.pop())\\n                        return false;\\n                } else if (c == \\']\\') {\\n                    if (\\'[\\' != stack.pop())\\n                        return false;\\n                } else if (c == \\'}\\') {\\n                    if (\\'{\\' != stack.pop())\\n                        return false;\\n                }\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238613,
                "title": "c-stack",
                "content": "Each time we meet an opening bracket, push it to a stack. When we meet a closing one, check if the stack is not empty and the top opening bracket is a match. Finally, the stack should be empty.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> stk;\\n        for (char c : s) {\\n            if (c == \\'(\\' || c == \\'[\\' || c == \\'{\\') {\\n                stk.push(c);\\n            } else {\\n                if (stk.empty() || c == \\')\\' && stk.top() != \\'(\\' || c == \\']\\' && stk.top() != \\'[\\' || c == \\'}\\' && stk.top() != \\'{\\') {\\n                    return false;\\n                }\\n                stk.pop();\\n            }\\n        }\\n        return stk.empty();\\n    }\\n};\\n```\\n\\n[This post](https://leetcode.com/problems/valid-parentheses/discuss/9178/Short-java-solution) has a much clever idea: instead of storing the opening brackets, we store the corresponding closing ones and check for equality later.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> stk;\\n        for (char c : s) {\\n            if (c == \\'(\\') {\\n                stk.push(\\')\\');\\n            } else if (c == \\'[\\') {\\n                stk.push(\\']\\');\\n            } else if (c == \\'{\\') {\\n                stk.push(\\'}\\');\\n            } else {\\n                if (stk.empty() || stk.top() != c) {\\n                    return false;\\n                }\\n                stk.pop();\\n            }\\n        }\\n        return stk.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> stk;\\n        for (char c : s) {\\n            if (c == \\'(\\' || c == \\'[\\' || c == \\'{\\') {\\n                stk.push(c);\\n            } else {\\n                if (stk.empty() || c == \\')\\' && stk.top() != \\'(\\' || c == \\']\\' && stk.top() != \\'[\\' || c == \\'}\\' && stk.top() != \\'{\\') {\\n                    return false;\\n                }\\n                stk.pop();\\n            }\\n        }\\n        return stk.empty();\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> stk;\\n        for (char c : s) {\\n            if (c == \\'(\\') {\\n                stk.push(\\')\\');\\n            } else if (c == \\'[\\') {\\n                stk.push(\\']\\');\\n            } else if (c == \\'{\\') {\\n                stk.push(\\'}\\');\\n            } else {\\n                if (stk.empty() || stk.top() != c) {\\n                    return false;\\n                }\\n                stk.pop();\\n            }\\n        }\\n        return stk.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431599,
                "title": "python-runtime-99-7-space-100",
                "content": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        stack = []\\n        for char in s:\\n            if char == \"(\" or char == \"{\" or char == \"[\":\\n                stack.append(char) \\n            elif len(stack) <= 0:\\n                return False\\n            elif char == \")\" and stack.pop() != \"(\":\\n                return False\\n            elif char == \"]\" and stack.pop() != \"[\":\\n                return False\\n            elif char == \"}\" and stack.pop() != \"{\":\\n                return False\\n        if len(stack) == 0:\\n            return True\\n        return False\\n```\\n\\t\\t\\nPlease leave any comments or suggestions.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        stack = []\\n        for char in s:\\n            if char == \"(\" or char == \"{\" or char == \"[\":\\n                stack.append(char) \\n            elif len(stack) <= 0:\\n                return False\\n            elif char == \")\" and stack.pop() != \"(\":\\n                return False\\n            elif char == \"]\" and stack.pop() != \"[\":\\n                return False\\n            elif char == \"}\" and stack.pop() != \"{\":\\n                return False\\n        if len(stack) == 0:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399710,
                "title": "beat-100-c-beginner-friendly",
                "content": "# Approach\\n1. Firstly we will create a $$vector$$ and $$keep$$ $$pushing$$ $$characters$$ into it\\n\\n2. We will keep checking if $$does$$ $$it$$ $$form$$ $$a$$ $$pair?$$ if yes then $$remove$$ the $$last$$ $$pushed$$ $$character$$,\\n\\n3. Create $$IsPair$$ function to Check $$if$$ $$both$$ $$characters$$ $$form$$ $$a$$ $$pair$$\\n    `\\'[\\' and \\']\\' form a pair`\\n    `\\'{\\' and \\'}\\' form a pair`\\n    `\\'[\\' ans \\']\\' form a pair`\\n\\n4. At last, if we found every completing bracket for every starting bracket,  then $$vector$$ $$should$$ $$completely$$ $$become$$ $$empty$$, hence if vector is empty, return $$true,$$ else $$false;$$   \\n\\n\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // If they form a pair of matching brackets, {} or () or [], Returns true,\\n    // Otherwise, it returns false.\\n    bool isPair(char c1, char c2) {\\n        return ((c1 == \\'{\\' && c2 == \\'}\\') || \\n                (c1 == \\'(\\' && c2 == \\')\\') || \\n                (c1 == \\'[\\' && c2 == \\']\\') );\\n    }\\n\\n    bool isValid(string s) {\\n        int n = s.size(); \\n        // is size of string is odd the return false;\\n        if(n % 2 == 1) return false;\\n        // Declaring vector for storing symbols\\n        vector < char > v;\\n        for(int i = 0 ; i < n ; i++ ) {\\n            if(v.size() == 0) {\\n                v.push_back( s[i] );\\n                continue;\\n            }\\n            // if both characters form a pair, remove the last symbol from vector \\n            if(isPair( v[v.size() - 1], s[i] )) v.erase(v.begin() + v.size() - 1);\\n            else v.push_back( s[i] );\\n        }\\n\\n        // If vector is empty, then only return true, else return false;\\n        return ( v.size() == 0 );\\n    }\\n};\\n```\\n\\n---\\n\\n# Complexity \\n- Time complexity:\\n    `O(n)` \\n- Space complexity:\\n   `O(n)` \\n\\n\\n---\\n![cat upvote.png](https://assets.leetcode.com/users/images/da2f919a-ca13-4134-a0a1-b3a79fa1c1a3_1681111812.612747.png)\\n\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // If they form a pair of matching brackets, {} or () or [], Returns true,\\n    // Otherwise, it returns false.\\n    bool isPair(char c1, char c2) {\\n        return ((c1 == \\'{\\' && c2 == \\'}\\') || \\n                (c1 == \\'(\\' && c2 == \\')\\') || \\n                (c1 == \\'[\\' && c2 == \\']\\') );\\n    }\\n\\n    bool isValid(string s) {\\n        int n = s.size(); \\n        // is size of string is odd the return false;\\n        if(n % 2 == 1) return false;\\n        // Declaring vector for storing symbols\\n        vector < char > v;\\n        for(int i = 0 ; i < n ; i++ ) {\\n            if(v.size() == 0) {\\n                v.push_back( s[i] );\\n                continue;\\n            }\\n            // if both characters form a pair, remove the last symbol from vector \\n            if(isPair( v[v.size() - 1], s[i] )) v.erase(v.begin() + v.size() - 1);\\n            else v.push_back( s[i] );\\n        }\\n\\n        // If vector is empty, then only return true, else return false;\\n        return ( v.size() == 0 );\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2193939,
                "title": "python-stack-w-explaination",
                "content": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        st=[]\\n        leftb=[\"(\", \"{\",\"[\"]\\n        rightb=[\")\",\"}\",\"]\"]\\n        for i in s:\\n\\t\\t# If opening bracket is found, push in stack.\\n            if i in leftb: st.append(i)\\n\\t\\t\\telif i in rightb:\\n\\t\\t\\t # If the top element matches the closing bracket correponding to the \\n\\t\\t\\t # opening bracket, pop it.\\n                if len(st)!=0 and st[-1] == leftb[rightb.index(i)]:\\n                    st.pop()\\n\\t\\t     # If closing bracket doesnt match with its corresponding opening bracket.\\n                else:\\n                    return False\\n        return len(st)==0\\n```\\n***Pls upvote if you find it helpful.***",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        st=[]\\n        leftb=[\"(\", \"{\",\"[\"]\\n        rightb=[\")\",\"}\",\"]\"]\\n        for i in s:\\n\\t\\t# If opening bracket is found, push in stack.\\n            if i in leftb: st.append(i)\\n\\t\\t\\telif i in rightb:\\n\\t\\t\\t # If the top element matches the closing bracket correponding to the \\n\\t\\t\\t # opening bracket, pop it.\\n                if len(st)!=0 and st[-1] == leftb[rightb.index(i)]:\\n                    st.pop()\\n\\t\\t     # If closing bracket doesnt match with its corresponding opening bracket.\\n                else:\\n                    return False\\n        return len(st)==0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899625,
                "title": "100-fastest-swift-solution-time-o-n-space-o-n",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the s.\\n    //   - space: O(n), where n is the length of the s.\\n    \\n    func isValid(_ s: String) -> Bool {\\n        var stack = [Character]()        \\n        let dict: [Character: Character] = [\"(\": \")\", \"{\": \"}\", \"[\": \"]\"]\\n        \\n        for char in s {\\n            switch char {\\n            case \"(\", \"{\", \"[\": stack.append(char)\\n            case \")\", \"}\", \"]\": guard !stack.isEmpty, dict[stack.removeLast()] == char else { return false }\\n            default: return false\\n            }\\n        }\\n        return stack.isEmpty\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the s.\\n    //   - space: O(n), where n is the length of the s.\\n    \\n    func isValid(_ s: String) -> Bool {\\n        var stack = [Character]()        \\n        let dict: [Character: Character] = [\"(\": \")\", \"{\": \"}\", \"[\": \"]\"]\\n        \\n        for char in s {\\n            switch char {\\n            case \"(\", \"{\", \"[\": stack.append(char)\\n            case \")\", \"}\", \"]\": guard !stack.isEmpty, dict[stack.removeLast()] == char else { return false }\\n            default: return false\\n            }\\n        }\\n        return stack.isEmpty\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082926,
                "title": "video-step-by-step-visualization-using-a-stack",
                "content": "https://youtube.com/watch?v=YwvHeouhy6s\\n\\nSince the **last** bracket that is opened must also be the **first** one to be closed, it makes sense to use a data structure that uses the **Last In, First Out** (LIFO) principle.  Therefore, a **stack** is a good choice here.\\n\\nIf a bracket is an *opening* bracet, we\\'ll just push it on to the stack.  If it\\'s a *closing* bracket, then we\\'ll use the `pairs` dictionary to check if it\\'s the correct type of bracket (first pop the last opening bracket encountered, find the corresponding closing bracket, and compare it with the current bracket in the loop).  If the wrong type of closing bracket is found, then we can exit early and return False.\\n\\nIf we make it all the way to the end and all open brackets have been closed, then the stack should be empty.  This is why we `return len(stack) == 0` at the end.  This will return `True` if the stack is empty, and `False` if it\\'s not.\\n\\n```\\nclass Solution(object):\\n    def isValid(self, s):\\n        stack = [] # only use append and pop\\n        pairs = {\\n            \\'(\\': \\')\\',\\n            \\'{\\': \\'}\\',\\n            \\'[\\': \\']\\'\\n        }\\n        for bracket in s:\\n            if bracket in pairs:\\n                stack.append(bracket)\\n            elif len(stack) == 0 or bracket != pairs[stack.pop()]:\\n                return False\\n\\n        return len(stack) == 0\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution(object):\\n    def isValid(self, s):\\n        stack = [] # only use append and pop\\n        pairs = {\\n            \\'(\\': \\')\\',\\n            \\'{\\': \\'}\\',\\n            \\'[\\': \\']\\'\\n        }\\n        for bracket in s:\\n            if bracket in pairs:\\n                stack.append(bracket)\\n            elif len(stack) == 0 or bracket != pairs[stack.pop()]:\\n                return False\\n\\n        return len(stack) == 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888723,
                "title": "100-fastest-typescript-solution",
                "content": "```\\nconst brackets: {[key: string]: string} = {\\n  \\']\\': \\'[\\',\\n  \\'}\\': \\'{\\',\\n  \\')\\': \\'(\\' \\n}\\n\\nfunction isValid(s: string): boolean {\\n  const stack: string[] = []\\n  const chars = s.split(\\'\\')\\n\\n  for (const char of chars) {\\n    if (isClosing(char)) {\\n      const opening = stack.pop()\\n\\n      if (brackets[char] !== opening) { return false }\\n    } else { stack.push(char) }\\n  }\\n\\n  return stack.length === 0\\n}\\n\\nfunction isClosing(s: string): boolean {\\n  return brackets.hasOwnProperty(s)\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst brackets: {[key: string]: string} = {\\n  \\']\\': \\'[\\',\\n  \\'}\\': \\'{\\',\\n  \\')\\': \\'(\\' \\n}\\n\\nfunction isValid(s: string): boolean {\\n  const stack: string[] = []\\n  const chars = s.split(\\'\\')\\n\\n  for (const char of chars) {\\n    if (isClosing(char)) {\\n      const opening = stack.pop()\\n\\n      if (brackets[char] !== opening) { return false }\\n    } else { stack.push(char) }\\n  }\\n\\n  return stack.length === 0\\n}\\n\\nfunction isClosing(s: string): boolean {\\n  return brackets.hasOwnProperty(s)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 745022,
                "title": "easiest-js-solution",
                "content": "```\\nvar isValid = function(s) {\\n    if (s.replace(/[\\\\(\\\\)\\\\{\\\\}\\\\[\\\\]]/g,\"\") !== \"\") {\\n        return false; // invalid string\\n    }\\n    let stack = [];\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === \"(\") {\\n            stack.push(\")\");\\n        } else if (s[i] === \"[\") {\\n            stack.push(\"]\");\\n        } else if (s[i] === \"{\") {\\n            stack.push(\"}\");   \\n        } else { // encountered a closing bracket\\n            if (s[i] !== stack.pop()) {\\n                return false;\\n            }\\n        }\\n    }\\n    return stack.length === 0;\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n/*\\nIdea:\\n    When we encounter an opening bracket, we will need its closing bracket in the nearest future.\\n    Therefore, we push a closing bracket of the same type into a stack.\\n    When we encounter a closing bracket, it should be equivalent to the popped bracket (on top of stack).\\n    Otherwise, the given string is invalid.\\n    At the end, the stack should be empty (all parentheses had its own pair)\\n*/\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isValid = function(s) {\\n    if (s.replace(/[\\\\(\\\\)\\\\{\\\\}\\\\[\\\\]]/g,\"\") !== \"\") {\\n        return false; // invalid string\\n    }\\n    let stack = [];\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === \"(\") {\\n            stack.push(\")\");\\n        } else if (s[i] === \"[\") {\\n            stack.push(\"]\");\\n        } else if (s[i] === \"{\") {\\n            stack.push(\"}\");   \\n        } else { // encountered a closing bracket\\n            if (s[i] !== stack.pop()) {\\n                return false;\\n            }\\n        }\\n    }\\n    return stack.length === 0;\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n/*\\nIdea:\\n    When we encounter an opening bracket, we will need its closing bracket in the nearest future.\\n    Therefore, we push a closing bracket of the same type into a stack.\\n    When we encounter a closing bracket, it should be equivalent to the popped bracket (on top of stack).\\n    Otherwise, the given string is invalid.\\n    At the end, the stack should be empty (all parentheses had its own pair)\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 195174,
                "title": "scala-fp-solution",
                "content": "```\\nobject Solution {\\n    def isValid(s: String): Boolean = {\\n        val terminals = Array(\"()\", \"[]\", \"{}\")\\n        s.foldLeft(List[Char]()){(a,v) => a match {\\n            case x :: xs if (terminals.contains(\"\" + x + v)) => xs\\n            case _ => v +: a\\n        }}.isEmpty\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n    def isValid(s: String): Boolean = {\\n        val terminals = Array(\"()\", \"[]\", \"{}\")\\n        s.foldLeft(List[Char]()){(a,v) => a match {\\n            case x :: xs if (terminals.contains(\"\" + x + v)) => xs\\n            case _ => v +: a\\n        }}.isEmpty\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1965255,
                "title": "stack-in-java-100-efficient-easy-and-understandle-code",
                "content": "### please upvote if you found it helpful\\n\\t\\n\\t\\n\\tclass Solution {\\n\\t\\tpublic boolean isValid(String s) {\\n\\t\\t  Stack<Character> st = new Stack<>();\\n\\t\\t\\tfor(int i=0;i<s.length();i++){\\n\\t\\t\\t\\tchar ch = s.charAt(i);\\n\\t\\t\\t\\tif(ch==\\'(\\' || ch== \\'[\\' || ch==\\'{\\'){\\n\\t\\t\\t\\t\\tst.push(ch);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(st.isEmpty()==true){\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(ch==\\')\\' && st.pop()!=\\'(\\'){\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t else if(ch==\\']\\' && st.pop()!=\\'[\\'){\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t else if(ch==\\'}\\' && st.pop()!=\\'{\\'){\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn st.isEmpty();\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n\\t\\tpublic boolean isValid(String s) {\\n\\t\\t  Stack<Character> st = new Stack<>();\\n\\t\\t\\tfor(int i=0;i<s.length();i++){\\n\\t\\t\\t\\tchar ch = s.charAt(i);\\n\\t\\t\\t\\tif(ch==\\'(\\' || ch== \\'[\\' || ch==\\'{\\'){\\n\\t\\t\\t\\t\\tst.push(ch);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1638974,
                "title": "error-in-the-last-if-statement-expected-member-name-or-after-declaration-specifiers",
                "content": "class Solution {\\npublic:\\n    bool isValid(string s){\\n        string s2=\"\";\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(s[i]== \\'{\\' || s[i]==\\'[\\' || s[i]==\\'(\\'){\\n                s2+=s[i];\\n            }else if(s[i]==\\'}\\' || s[i]==\\'}\\'|| s[i]==\\']\\' ){\\n                if(s2.empty()){\\n                    return false;\\n                }else if(s[i]==\\'}\\'){\\n                    if( s2.back()!=\\'{\\'){\\n                        return false;\\n                    }\\n                }else if(s[i]==\\']\\'){\\n                    if( s2.back()!=\\'[\\'){\\n                        return false;\\n                    }\\n                }else if(s[i]==\\')\\'){\\n                    if( s2.back()!=\\'(\\'){\\n                        return false;\\n                    }\\n                }\\n                }else{\\n                    s2.pop_back();\\n                }\\n\\n            }else{\\n                return false;\\n            }\\n        }\\n        if(s2.empty()){\\n            return true;\\n        }else{\\n            return false;\\n        }     \\n    }\\n        \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isValid(string s){\\n        string s2=\"\";\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(s[i]== \\'{\\' || s[i]==\\'[\\' || s[i]==\\'(\\'){\\n                s2+=s[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1391878,
                "title": "easy-js-solution-easy-understandable",
                "content": "For loop the input string. \\n1. if encounter Closing bracket && its corresponding open bracket is on the top of the stack. => stack.pop\\n2. else cases => stack.push regardless.\\nwe return !stack.length\\n\\n```\\nvar isValid = function(s) {\\n    if (s.length % 2 !== 0 ) return false;\\n    \\n    var stack = [];\\n    for (let c of s) {\\n        if (c === \\')\\' && stack[stack.length -1] === \\'(\\'){\\n            stack.pop()\\n        } else if (c === \\'}\\' && stack[stack.length -1] === \\'{\\'){\\n            stack.pop()\\n        } else if (c === \\']\\' && stack[stack.length -1] === \\'[\\'){\\n            stack.pop()\\n        } else {\\n            stack.push(c)\\n        }\\n        \\n    }\\n    \\n    return !stack.length\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nvar isValid = function(s) {\\n    if (s.length % 2 !== 0 ) return false;\\n    \\n    var stack = [];\\n    for (let c of s) {\\n        if (c === \\')\\' && stack[stack.length -1] === \\'(\\'){\\n            stack.pop()\\n        } else if (c === \\'}\\' && stack[stack.length -1] === \\'{\\'){\\n            stack.pop()\\n        } else if (c === \\']\\' && stack[stack.length -1] === \\'[\\'){\\n            stack.pop()\\n        } else {\\n            stack.push(c)\\n        }\\n        \\n    }\\n    \\n    return !stack.length\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1025832,
                "title": "c-simple-and-clean-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        std::vector<char> stack;\\n        for (int i=0; i<s.length();i++)\\n        {\\n            if (s[i] == \\'{\\')\\n                stack.push_back(\\'}\\');\\n            else if (s[i] == \\'(\\')\\n                stack.push_back(\\')\\');\\n            else if (s[i] == \\'[\\')\\n                stack.push_back(\\']\\');\\n            else\\n            {\\n                if ((stack.empty()) || (s[i] != stack[stack.size()-1]))\\n                    return false;\\n                stack.pop_back();\\n            }\\n        }\\n        return stack.empty();\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        std::vector<char> stack;\\n        for (int i=0; i<s.length();i++)\\n        {\\n            if (s[i] == \\'{\\')\\n                stack.push_back(\\'}\\');\\n            else if (s[i] == \\'(\\')\\n                stack.push_back(\\')\\');\\n            else if (s[i] == \\'[\\')\\n                stack.push_back(\\']\\');\\n            else\\n            {\\n                if ((stack.empty()) || (s[i] != stack[stack.size()-1]))\\n                    return false;\\n                stack.pop_back();\\n            }\\n        }\\n        return stack.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 9660,
                "title": "sharing-my-simple-cpp-code-with-2ms",
                "content": "        class Solution {\\n        public:\\n            bool isValid(string s) {\\n                map<char, char> parenth_dict;\\n                parenth_dict['('] = ')';\\n                parenth_dict['{'] = '}';\\n                parenth_dict['['] = ']';\\n                \\n                stack<char> aux;\\n                for (int i = 0; i < s.size(); i++) {\\n                    if (s[i] == '(' || s[i] == '{' || s[i] == '[') \\n                        aux.push(s[i]);\\n                    else if (aux.empty() || parenth_dict[aux.top()] != s[i])\\n                        return false;\\n                    else\\n                        aux.pop();\\n                }\\n                \\n                return aux.empty();\\n                \\n            }\\n    \\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            bool isValid(string s) {\\n                map<char, char> parenth_dict;\\n                parenth_dict['('] = ')';\\n                parenth_dict['{'] = '}",
                "codeTag": "Java"
            },
            {
                "id": 3160536,
                "title": "c-stack-o-n",
                "content": "# Approach\\nThe solution uses a **Stack** data structure to store the open brackets as they are encountered in the input string. A Dictionary is also used to map open brackets to their corresponding closing brackets.\\n\\nHere\\'s an overview of the code step-by-step:\\n\\n- Initialize the Dictionary `bracketsMap` to store the mapping of open brackets to their corresponding closing brackets.\\n- Create a Stack `openBrackets` to store the open brackets as they are encountered in the input string.\\n- Iterate over each character in the input string `s`.\\n- If the character is an open bracket, push it onto the Stack `openBrackets`.\\n- If the character is a closing bracket, pop the top element from the Stack `openBrackets` and compare it with the corresponding closing bracket in the Dictionary `bracketsMap`. If the popped bracket and the corresponding bracket in the Dictionary do not match, return false as the input string is not valid.\\n- Repeat the process for each character in the input string.\\n- If the Stack `openBrackets` is empty at the end of the loop, return true, indicating that the input string is valid.\\n\\n\\n# Complexity\\n- Time complexity:\\n`O(n)`, where n is the length of the input string. The reason is that each character in the input string is processed only once, and the operations of pushing and popping elements onto the Stack and accessing elements in the Dictionary have a constant time complexity. \\n- Space complexity:\\n`O(n)`, as the Stack openBrackets may store up to n elements, in the worst case scenario where each character in the input string is an open bracket.\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool IsValid(string s) {\\n        Dictionary<char, char> bracketsMap = new Dictionary<char, char>{\\n            {\\'{\\',  \\'}\\'},\\n            {\\'(\\',  \\')\\'},\\n            {\\'[\\',  \\']\\'},\\n        };\\n        Stack<char> openBrackets = new Stack<char>();\\n        \\n        foreach (char bracket in s) {\\n            if (bracketsMap.ContainsKey(bracket)) {\\n                openBrackets.Push(bracket);\\n            } else {\\n                 if (openBrackets.Count == 0) {\\n                    return false;\\n                }\\n                if (bracketsMap[openBrackets.Pop()] == bracket) {\\n                    continue;\\n                };\\n                return false;\\n            }\\n        }\\n        return openBrackets.Count == 0;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#",
                    "Stack"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsValid(string s) {\\n        Dictionary<char, char> bracketsMap = new Dictionary<char, char>{\\n            {\\'{\\',  \\'}\\'},\\n            {\\'(\\',  \\')\\'},\\n            {\\'[\\',  \\']\\'},\\n        };\\n        Stack<char> openBrackets = new Stack<char>();\\n        \\n        foreach (char bracket in s) {\\n            if (bracketsMap.ContainsKey(bracket)) {\\n                openBrackets.Push(bracket);\\n            } else {\\n                 if (openBrackets.Count == 0) {\\n                    return false;\\n                }\\n                if (bracketsMap[openBrackets.Pop()] == bracket) {\\n                    continue;\\n                };\\n                return false;\\n            }\\n        }\\n        return openBrackets.Count == 0;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2545887,
                "title": "java-solution-easy-and-100-faster-stacks-o-n",
                "content": "****If Liked Please UpVote Me, Means A lot. Thankyou**** \\uD83D\\uDE0A\\uD83D\\uDE0D\\n\\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for(char c : s.toCharArray()){\\n            if(c == \\'{\\' || c == \\'[\\' || c == \\'(\\'){\\n                stack.push(c);\\n            }else{\\n                if(stack.isEmpty()){\\n                    return false;\\n                }else{\\n                    char top = stack.peek();\\n                    if(c == \\'}\\' && top == \\'{\\' ||\\n                      c == \\')\\' && top ==\\'(\\' ||\\n                      c == \\']\\' && top == \\'[\\'){\\n                        stack.pop();\\n                    }else{\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for(char c : s.toCharArray()){\\n            if(c == \\'{\\' || c == \\'[\\' || c == \\'(\\'){\\n                stack.push(c);\\n            }else{\\n                if(stack.isEmpty()){\\n                    return false;\\n                }else{\\n                    char top = stack.peek();\\n                    if(c == \\'}\\' && top == \\'{\\' ||\\n                      c == \\')\\' && top ==\\'(\\' ||\\n                      c == \\']\\' && top == \\'[\\'){\\n                        stack.pop();\\n                    }else{\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089154,
                "title": "python-stack-easy-understanding-beginners-detailed-explanation",
                "content": "* We first create an empty list named stack and then a dictionary with keys {, (, [ and values }, ), ] respectiovely associated with them.\\n* In python we have 2 functions for dictionary named .keys() and .values() which returns the keys as a list and values as a list.\\n* If we have a key we simply append that to our stack\\n* else, we check whether the last element in the stack is the key of this value and removing it by calling pop function.\\n* if stack is empty and we have a closed bracket/ paranthasis which means it is not a valid value, we simply return False.\\n* after iterating we return True which means stack is empty.\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.stack = []\\n        self.dictu = {\\'{\\': \\'}\\', \\'[\\': \\']\\', \\'(\\': \\')\\'}\\n        \\n    def isValid(self, s: str) -> bool:\\n        if len(s) == 1:\\n            return False\\n        for i in s:\\n            if i in self.dictu.keys():\\n                self.stack.append(i)\\n            if i in self.dictu.values():\\n                if not self.stack:\\n                    return False\\n                elif i != self.dictu[self.stack.pop()]:\\n                    return False\\n        return self.stack == []\\n```\\n\\nKindly Upvote if it helps :)",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.stack = []\\n        self.dictu = {\\'{\\': \\'}\\', \\'[\\': \\']\\', \\'(\\': \\')\\'}\\n        \\n    def isValid(self, s: str) -> bool:\\n        if len(s) == 1:\\n            return False\\n        for i in s:\\n            if i in self.dictu.keys():\\n                self.stack.append(i)\\n            if i in self.dictu.values():\\n                if not self.stack:\\n                    return False\\n                elif i != self.dictu[self.stack.pop()]:\\n                    return False\\n        return self.stack == []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1483318,
                "title": "c-clean-unordered-map-solution-beats-100",
                "content": "```\\nbool isValid(string s) {\\n        stack<char> st;\\n        unordered_map<char, char> mp = {{\\'(\\', \\')\\'}, {\\'{\\', \\'}\\'}, {\\'[\\', \\']\\'}};\\n\\t\\t\\n        for(char c: s) {\\n            if(mp.find(c) != mp.end()) {\\n                st.push(c);\\n            } else if(!st.empty() && mp[st.top()] == c) {\\n                    st.pop();\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        return st.empty();\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nbool isValid(string s) {\\n        stack<char> st;\\n        unordered_map<char, char> mp = {{\\'(\\', \\')\\'}, {\\'{\\', \\'}\\'}, {\\'[\\', \\']\\'}};\\n\\t\\t\\n        for(char c: s) {\\n            if(mp.find(c) != mp.end()) {\\n                st.push(c);\\n            } else if(!st.empty() && mp[st.top()] == c) {\\n                    st.pop();\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        return st.empty();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1407199,
                "title": "easy-solution-python-fater-than-90-please-upvote",
                "content": "Python3 implementation of stack using list\\n```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        stack = []\\n        length = len(s)\\n        for i in range(length):\\n            stack_len = len(stack)\\n            if stack_len == 0:\\n                stack.append(s[i])\\n            elif s[i] == \")\" and stack[stack_len-1] == \"(\":\\n                stack.pop(stack_len-1)\\n            elif s[i] == \"}\" and stack[stack_len-1] == \"{\":\\n                stack.pop(stack_len-1)\\n            elif s[i] == \"]\" and stack[stack_len-1] == \"[\":\\n                stack.pop(stack_len-1)\\n            else:\\n                stack.append(s[i])\\n        return len(stack) == 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        stack = []\\n        length = len(s)\\n        for i in range(length):\\n            stack_len = len(stack)\\n            if stack_len == 0:\\n                stack.append(s[i])\\n            elif s[i] == \")\" and stack[stack_len-1] == \"(\":\\n                stack.pop(stack_len-1)\\n            elif s[i] == \"}\" and stack[stack_len-1] == \"{\":\\n                stack.pop(stack_len-1)\\n            elif s[i] == \"]\" and stack[stack_len-1] == \"[\":\\n                stack.pop(stack_len-1)\\n            else:\\n                stack.append(s[i])\\n        return len(stack) == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 272483,
                "title": "golang-solution-0ms-2mb-100",
                "content": "// 40 = \\'(\\', 41 = \\')\\'\\n// 123 = \\'{\\', 125 = \\'}\\'\\n// 91 = \\'[\\', 93 = \\']\\'\\n```\\nfunc isValid(s string) bool {\\n    if s == \"\" {\\n        return true\\n    }\\n    \\n    tr := map[rune]rune{\\n        \\'}\\': \\'{\\',\\n        \\')\\': \\'(\\',\\n        \\']\\': \\'[\\',\\n    }\\n    \\n    stack := make([]rune, 0, 1)\\n    \\n    for _, ch := range s {\\n        switch ch {\\n        case 40,123,91:\\n            stack = append(stack, ch)\\n        case 41,125,93:    \\n            if len(stack) == 0 || stack[len(stack)-1] != tr[ch] {\\n                return false\\n            } else {\\n                stack = stack[:len(stack)-1]\\n            }\\n        }\\n    }\\n    \\n    return len(stack) == 0\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isValid(s string) bool {\\n    if s == \"\" {\\n        return true\\n    }\\n    \\n    tr := map[rune]rune{\\n        \\'}\\': \\'{\\',\\n        \\')\\': \\'(\\',\\n        \\']\\': \\'[\\',\\n    }\\n    \\n    stack := make([]rune, 0, 1)\\n    \\n    for _, ch := range s {\\n        switch ch {\\n        case 40,123,91:\\n            stack = append(stack, ch)\\n        case 41,125,93:    \\n            if len(stack) == 0 || stack[len(stack)-1] != tr[ch] {\\n                return false\\n            } else {\\n                stack = stack[:len(stack)-1]\\n            }\\n        }\\n    }\\n    \\n    return len(stack) == 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 9682,
                "title": "simple-accepted-java-solution",
                "content": "I think the code is clear to understand.\\n\\n    public boolean isValid(String s) {\\n        char[] chars = s.toCharArray();\\n        Map<Character,Character> pairs = new HashMap<Character,Character>();\\n        pairs.put('(', ')');\\n        pairs.put('{', '}');\\n        pairs.put('[', ']');\\n        \\n        Stack<Character> stack = new Stack<Character>();\\n        for (char c:chars) {\\n        \\tif (pairs.containsKey(c)) {\\n        \\t\\tstack.push(pairs.get(c));\\n        \\t} else {\\n        \\t\\tif (stack.isEmpty() || c != stack.pop()) return false;\\n        \\t}\\n        }\\n        return stack.isEmpty();\\n    }",
                "solutionTags": [],
                "code": "I think the code is clear to understand.\\n\\n    public boolean isValid(String s) {\\n        char[] chars = s.toCharArray();\\n        Map<Character,Character> pairs = new HashMap<Character,Character>();\\n        pairs.put('(', ')');\\n        pairs.put('{', '}');\\n        pairs.put('[', ']');\\n        \\n        Stack<Character> stack = new Stack<Character>();\\n        for (char c:chars) {\\n        \\tif (pairs.containsKey(c)) {\\n        \\t\\tstack.push(pairs.get(c));\\n        \\t} else {\\n        \\t\\tif (stack.isEmpty() || c != stack.pop()) return false;\\n        \\t}\\n        }\\n        return stack.isEmpty();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3512729,
                "title": "c-java-python-javascript-stack-with-explanation-simple-solution",
                "content": "# Intuition:\\nThe problem requires validating a given string containing only three types of brackets - (), {}, []. The idea is to use a stack to keep track of the opening brackets encountered and check if the closing brackets match the last opening bracket.\\n\\n# Approach:\\n1. Create a stack to store opening brackets.\\n2. Traverse the given string character by character.\\n3. If the current character is an opening bracket, push it onto the stack.\\n4. If the current character is a closing bracket, pop the top element from the stack and check if it matches the current closing bracket. If not, return false.\\n5. After traversing the entire string, if the stack is not empty, return false.\\n6. If the string is valid, return true.\\n\\n# Complexity:\\n- Time complexity: O(n), where n is the length of the given string. We traverse the entire string once.\\n- Space complexity: O(n), where n is the length of the given string. The maximum size of the stack would be n/2, in case all the opening brackets are encountered first.\\n\\n---\\n# C++\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        int count=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\' || s[i]==\\'{\\' || s[i]==\\'[\\'){\\n                st.push(s[i]);\\n                count++;\\n            }\\n            else{\\n                if(st.size() == 0) return false; \\n                char ch = st.top();\\n                st.pop();\\n                if( s[i]==\\')\\' && ch ==\\'(\\' ||   s[i]==\\']\\' && ch ==\\'[\\' ||  s[i]==\\'}\\' && ch ==\\'{\\'){ \\n                }\\n                else{\\n                    return false;\\n                }\\n                count--;\\n            }\\n        }\\n        if(count!=0){\\n            return false;\\n        }\\n    return true;\\n    }\\n};\\n```\\n\\n---\\n# Java\\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        int count = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\' || s.charAt(i) == \\'{\\' || s.charAt(i) == \\'[\\') {\\n                stack.push(s.charAt(i));\\n                count++;\\n            } else {\\n                if (stack.isEmpty()) return false;\\n                char ch = stack.pop();\\n                if ((s.charAt(i) == \\')\\' && ch == \\'(\\') || (s.charAt(i) == \\']\\' && ch == \\'[\\') || (s.charAt(i) == \\'}\\' && ch == \\'{\\')) {\\n                } else {\\n                    return false;\\n                }\\n                count--;\\n            }\\n        }\\n        return count == 0;\\n    }\\n}\\n\\n```\\n\\n---\\n# JavaScript\\n```\\nvar isValid = function(s) {\\n    const stack = [];\\n    let count = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === \\'(\\' || s[i] === \\'{\\' || s[i] === \\'[\\') {\\n            stack.push(s[i]);\\n            count++;\\n        } else {\\n            if (stack.length === 0) return false;\\n            const ch = stack.pop();\\n            if ((s[i] === \\')\\' && ch === \\'(\\') || (s[i] === \\']\\' && ch === \\'[\\') || (s[i] === \\'}\\' && ch === \\'{\\')) {\\n            } else {\\n                return false;\\n            }\\n            count--;\\n        }\\n    }\\n    return count === 0;\\n};\\n```\\n\\n---\\n# Python\\n```\\nclass Solution:\\n    def isValid(self, s):\\n        stack = []\\n        count = 0\\n        for i in range(len(s)):\\n            if s[i] == \\'(\\' or s[i] == \\'{\\' or s[i] == \\'[\\':\\n                stack.append(s[i])\\n                count += 1\\n            else:\\n                if len(stack) == 0:\\n                    return False\\n                ch = stack.pop()\\n                if (s[i] == \\')\\' and ch == \\'(\\') or (s[i] == \\']\\' and ch == \\'[\\') or (s[i] == \\'}\\' and ch == \\'{\\'):\\n                    pass\\n                else:\\n                    return False\\n                count -= 1\\n        return count == 0\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        int count=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\' || s[i]==\\'{\\' || s[i]==\\'[\\'){\\n                st.push(s[i]);\\n                count++;\\n            }\\n            else{\\n                if(st.size() == 0) return false; \\n                char ch = st.top();\\n                st.pop();\\n                if( s[i]==\\')\\' && ch ==\\'(\\' ||   s[i]==\\']\\' && ch ==\\'[\\' ||  s[i]==\\'}\\' && ch ==\\'{\\'){ \\n                }\\n                else{\\n                    return false;\\n                }\\n                count--;\\n            }\\n        }\\n        if(count!=0){\\n            return false;\\n        }\\n    return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        int count = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\' || s.charAt(i) == \\'{\\' || s.charAt(i) == \\'[\\') {\\n                stack.push(s.charAt(i));\\n                count++;\\n            } else {\\n                if (stack.isEmpty()) return false;\\n                char ch = stack.pop();\\n                if ((s.charAt(i) == \\')\\' && ch == \\'(\\') || (s.charAt(i) == \\']\\' && ch == \\'[\\') || (s.charAt(i) == \\'}\\' && ch == \\'{\\')) {\\n                } else {\\n                    return false;\\n                }\\n                count--;\\n            }\\n        }\\n        return count == 0;\\n    }\\n}\\n\\n```\n```\\nvar isValid = function(s) {\\n    const stack = [];\\n    let count = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === \\'(\\' || s[i] === \\'{\\' || s[i] === \\'[\\') {\\n            stack.push(s[i]);\\n            count++;\\n        } else {\\n            if (stack.length === 0) return false;\\n            const ch = stack.pop();\\n            if ((s[i] === \\')\\' && ch === \\'(\\') || (s[i] === \\']\\' && ch === \\'[\\') || (s[i] === \\'}\\' && ch === \\'{\\')) {\\n            } else {\\n                return false;\\n            }\\n            count--;\\n        }\\n    }\\n    return count === 0;\\n};\\n```\n```\\nclass Solution:\\n    def isValid(self, s):\\n        stack = []\\n        count = 0\\n        for i in range(len(s)):\\n            if s[i] == \\'(\\' or s[i] == \\'{\\' or s[i] == \\'[\\':\\n                stack.append(s[i])\\n                count += 1\\n            else:\\n                if len(stack) == 0:\\n                    return False\\n                ch = stack.pop()\\n                if (s[i] == \\')\\' and ch == \\'(\\') or (s[i] == \\']\\' and ch == \\'[\\') or (s[i] == \\'}\\' and ch == \\'{\\'):\\n                    pass\\n                else:\\n                    return False\\n                count -= 1\\n        return count == 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398979,
                "title": "java-easy-stack-solution-explained-beginner-friendly",
                "content": "# Intuition\\nWe can use stack for storing all the incoming open brackets and if matching closing bracket comes we need to pop the top of the stack. This is the intial thought\\n\\n---\\n\\n# Approach\\n1) Initialise Stack.\\n2) First thing is to idenity the incoming character is a opening or closing bracket. So i used *String openBrackets = \"{([\"; with function openBrackets.indexOf(s.charAt(i)) > -1*\\n- if **indexOf()** returns anything >-1 that is incoming character was an open bracket\\n- else if **indexOf()** return -1 then it was a close bracket as such charcter was not present in string openBrackets.\\n3) Once identified, if open bracket push to stack, if closing bracket then handle conditions\\n- if stack is empty we cannot push a close bracket first so false\\n- if open bracket on stack\\'s top doesn\\'t matches the closing bracket return false ex \\'{\\' should match \\'}\\', \\'[\\' should match \\']\\'\\n- else remove top charcter from stack\\n4) At end of loop if stack is not empty then there are open brackets remaining in the stack so return false, true otherwise\\n \\n\\n---\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n): As we go through all the characters once in the string.\\n\\n- Space complexity:\\nO(n): In the worst case we can have a max of n characters in stack\\n\\n---\\n\\nHope it is easy to understand.\\nLet me know if there is something unclear and i can fix it.\\n\\nOtherwise, please upvote if you like the solution, it would be encouraging\\n\\n-----\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        String openBrackets = \"{([\";\\n        for(int i=0; i<s.length(); i++){\\n            Character temp = s.charAt(i);\\n            if(openBrackets.indexOf(temp)> -1){\\n                stack.add(temp);\\n            }else{\\n                /* handles all cases for close brackets }]) */\\n                if(stack.isEmpty()){\\n                    return false;\\n                }else if(helper(stack.peek())!=temp){\\n                    return false;\\n                }else{\\n                    stack.pop();\\n                }\\n            }\\n        }\\n        return stack.empty() ? true : false;\\n    }\\n\\n    private Character helper(Character left){\\n        // methode returns what closing bracket should be on comparison with right bracket \\n        if(left == \\'(\\'){\\n            return \\')\\';\\n        }else if(left == \\'{\\'){\\n            return \\'}\\';\\n        }else{\\n            return \\']\\';\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        String openBrackets = \"{([\";\\n        for(int i=0; i<s.length(); i++){\\n            Character temp = s.charAt(i);\\n            if(openBrackets.indexOf(temp)> -1){\\n                stack.add(temp);\\n            }else{\\n                /* handles all cases for close brackets }]) */\\n                if(stack.isEmpty()){\\n                    return false;\\n                }else if(helper(stack.peek())!=temp){\\n                    return false;\\n                }else{\\n                    stack.pop();\\n                }\\n            }\\n        }\\n        return stack.empty() ? true : false;\\n    }\\n\\n    private Character helper(Character left){\\n        // methode returns what closing bracket should be on comparison with right bracket \\n        if(left == \\'(\\'){\\n            return \\')\\';\\n        }else if(left == \\'{\\'){\\n            return \\'}\\';\\n        }else{\\n            return \\']\\';\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681079,
                "title": "java-short-cute-solution",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n         Stack<Character> st=new Stack<Character>();\\n          for(char a:s.toCharArray())\\n        {\\n           \\n\\t\\t\\t//Check if stack not empty and the top element corresponds to curr char\\n            if(!st.isEmpty() && (st.peek()==a-1 || st.peek()==a-2))\\n                st.pop();\\n\\t\\t\\t//else these migh be starting brackets or unsatisfied closing brackets\\n            else\\n                st.push(a);\\n        }\\n           \\n           return st.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n         Stack<Character> st=new Stack<Character>();\\n          for(char a:s.toCharArray())\\n        {\\n           \\n\\t\\t\\t//Check if stack not empty and the top element corresponds to curr char\\n            if(!st.isEmpty() && (st.peek()==a-1 || st.peek()==a-2))\\n                st.pop();\\n\\t\\t\\t//else these migh be starting brackets or unsatisfied closing brackets\\n            else\\n                st.push(a);\\n        }\\n           \\n           return st.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447263,
                "title": "recursive-solution-on-kotlin",
                "content": "The following algorithm isn\\'t pretty fast and memorylight, but I think this non-standard approach seems interesting. \\n\\n```\\nclass Solution {\\n    fun isValid(s: String): Boolean {\\n        if (s == \"\") { return true }\\n        val simplified = s.replace(\"()\", \"\").replace(\"{}\", \"\").replace(\"[]\", \"\")\\n        if (simplified == s) { return false }\\n        return isValid(simplified)\\n    }\\n}\\n```\\n\\n**Explanation:**\\n- The base case of recursion is pretty easy.\\n```\\nif (s == \"\") { return true }\\n```\\nIf we\\'ve got an ***empty string***, it obviously satisfies the condition.\\n___\\nIn compex valid string all valid brackets cointains another valid brackets as well. And also single valid brackets can occur the the left or the right of main brackets. For example: `\"({[]})()[]\"`\\n- On the next line we delete all internal valid brackets, which don\\'t have another brackets inside. And also we rid off singe valid brackets.\\n```\\nval simplified = s.replace(\"()\", \"\").replace(\"{}\", \"\").replace(\"[]\", \"\")\\n```\\nAfter this line our abovementioned example would be: `\"({[]})()[]\"` -> `\"({})\"`. Much easy to solve it now, right?\\n___\\nClearly we can\\'t simplify our string more and more, because in a moment we can come to the case when string can\\'t be simplified anymore (in case if it\\'s an unvalid string of course)\\n- And this line allows us to check is the simplified string the same as the original. If they are the same, it means, that the basic string is unvalid and we can\\'t simplify it anymore. In this case function returns false.\\n```\\nif (simplified == s) { return false }\\n```\\n___\\nAnd we do cycle until it gives us a result\\n```\\nreturn isValid(simplified)\\n```\\n___\\n*Thanks for the reading.*\\n",
                "solutionTags": [
                    "Kotlin",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    fun isValid(s: String): Boolean {\\n        if (s == \"\") { return true }\\n        val simplified = s.replace(\"()\", \"\").replace(\"{}\", \"\").replace(\"[]\", \"\")\\n        if (simplified == s) { return false }\\n        return isValid(simplified)\\n    }\\n}\\n```\n```\\nif (s == \"\") { return true }\\n```\n```\\nval simplified = s.replace(\"()\", \"\").replace(\"{}\", \"\").replace(\"[]\", \"\")\\n```\n```\\nif (simplified == s) { return false }\\n```\n```\\nreturn isValid(simplified)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 638916,
                "title": "super-simple-java-solution-no-space-complexity",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {  \\n        while(s.contains(\"()\") || s.contains(\"[]\") ||  s.contains(\"{}\")) {\\n            s = s.replace(\"()\", \"\");\\n            s = s.replace(\"[]\", \"\");\\n            s = s.replace(\"{}\", \"\");\\n        }\\n        return s.length() == 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {  \\n        while(s.contains(\"()\") || s.contains(\"[]\") ||  s.contains(\"{}\")) {\\n            s = s.replace(\"()\", \"\");\\n            s = s.replace(\"[]\", \"\");\\n            s = s.replace(\"{}\", \"\");\\n        }\\n        return s.length() == 0;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 551171,
                "title": "shortest-8-lines-java-solution",
                "content": "```\\n    public boolean isValid(String s) {\\n        int length;\\n        do{\\n            length = s.length();\\n            s = s.replace(\"()\",\"\").replace(\"[]\",\"\").replace(\"{}\",\"\");\\n        }while(length != s.length());\\n        return s.isBlank();\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public boolean isValid(String s) {\\n        int length;\\n        do{\\n            length = s.length();\\n            s = s.replace(\"()\",\"\").replace(\"[]\",\"\").replace(\"{}\",\"\");\\n        }while(length != s.length());\\n        return s.isBlank();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 323938,
                "title": "a-recursive-parser-in-python",
                "content": "Since we only need to check whether the string is valid, \"parsing\" means consuming as much of the string as is valid. We then check whether the whole string has been consumed to determine whether the entire string is valid.\\n\\n```python\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        matching_bracket = {\\n            \\'(\\': \\')\\', \\n            \\'[\\': \\']\\', \\n            \\'{\\': \\'}\\',\\n        }\\n        \\n        def parse_string(s, start=0):\\n            \"\"\"Return the end of the longest valid string \\n            that begins at the index `start`.\\n\\n            Grammar:\\n                <string> -> \\'\\' | \\n                            <round> <string> | \\n                            <square> <string> | \\n                            <curly> <string>\\n                <round>  -> \\'(\\' <string> \\')\\'\\n                <square> -> \\'[\\' <string> \\']\\'\\n                <curly>  -> \\'{\\' <string> \\'}\\'\\n            \\n            >>> parse_string(\\'{}([)]\\')\\n            2\\n            >>> parse_string(\\'{[]}\\')\\n            4\\n            \"\"\"\\n            if len(s) <= start:\\n                # The string `s[start:]` is empty.\\n                return start\\n            elif s[start] in matching_bracket:\\n                # We\\'ve encountered an opening bracket.  Attempt\\n                # to parse the substring immediately after the\\n                # opening bracket.\\n                sub_end = parse_string(s, start=start+1)\\n                if sub_end == len(s) or s[sub_end] != matching_bracket[s[start]]:\\n                    # We\\'ve either reached the end of the string while\\n                    # attempting to parse the substring, or the character\\n                    # after the substring is not the closing bracket we \\n                    # expected.\\n                    return start\\n                else:\\n                    # The substring is valid, and is followed by the correct\\n                    # closing bracket.  Consume the closing bracket and parse\\n                    # the rest of the string.\\n                    return parse_string(s, start=sub_end+1)\\n            else:\\n                # We\\'ve encountered an unexpected character at the start\\n                # of the string.\\n                return start\\n        \\n        return parse_string(s) == len(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        matching_bracket = {\\n            \\'(\\': \\')\\', \\n            \\'[\\': \\']\\', \\n            \\'{\\': \\'}\\',\\n        }\\n        \\n        def parse_string(s, start=0):\\n            \"\"\"Return the end of the longest valid string \\n            that begins at the index `start`.\\n\\n            Grammar:\\n                <string> -> \\'\\' | \\n                            <round> <string> | \\n                            <square> <string> | \\n                            <curly> <string>\\n                <round>  -> \\'(\\' <string> \\')\\'\\n                <square> -> \\'[\\' <string> \\']\\'\\n                <curly>  -> \\'{\\' <string> \\'}\\'\\n            \\n            >>> parse_string(\\'{}([)]\\')\\n            2\\n            >>> parse_string(\\'{[]}\\')\\n            4\\n            \"\"\"\\n            if len(s) <= start:\\n                # The string `s[start:]` is empty.\\n                return start\\n            elif s[start] in matching_bracket:\\n                # We\\'ve encountered an opening bracket.  Attempt\\n                # to parse the substring immediately after the\\n                # opening bracket.\\n                sub_end = parse_string(s, start=start+1)\\n                if sub_end == len(s) or s[sub_end] != matching_bracket[s[start]]:\\n                    # We\\'ve either reached the end of the string while\\n                    # attempting to parse the substring, or the character\\n                    # after the substring is not the closing bracket we \\n                    # expected.\\n                    return start\\n                else:\\n                    # The substring is valid, and is followed by the correct\\n                    # closing bracket.  Consume the closing bracket and parse\\n                    # the rest of the string.\\n                    return parse_string(s, start=sub_end+1)\\n            else:\\n                # We\\'ve encountered an unexpected character at the start\\n                # of the string.\\n                return start\\n        \\n        return parse_string(s) == len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991174,
                "title": "simple-way-for-python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        ack = []\\n        lookfor = {\\')\\':\\'(\\', \\'}\\':\\'{\\', \\']\\':\\'[\\'}\\n\\n        for p in s:\\n            if p in lookfor.values():\\n                ack.append(p)\\n            elif ack and lookfor[p] == ack[-1]:\\n                ack.pop()\\n            else:\\n                return False\\n\\n        return ack == []\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        ack = []\\n        lookfor = {\\')\\':\\'(\\', \\'}\\':\\'{\\', \\']\\':\\'[\\'}\\n\\n        for p in s:\\n            if p in lookfor.values():\\n                ack.append(p)\\n            elif ack and lookfor[p] == ack[-1]:\\n                ack.pop()\\n            else:\\n                return False\\n\\n        return ack == []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315686,
                "title": "python3-solution-with-detailed-explanation",
                "content": "***Please upvote if this helps!***\\n```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        \\n        # TC = O(n) ; SC = O(n)\\n        # because we need to iterate over the string once\\n        # and we are using a check dictionary and stack for space \\n        # so space complexity = O(n)\\n        \\n        n = len(s)\\n        if n&1 or n < 2:\\n            return False\\n        \\n        # odd length strings wont ever be balanced/valid\\n        # similarly strings with a single bracket wont be valid\\n        \\n        check = {\\'(\\':\\')\\', \\'{\\':\\'}\\',\\'[\\':\\']\\'}\\n        stack1 = []\\n        for bracket in s:\\n            # if ith character is opening bracket\\n            # then add it to stack \\n            if bracket in check:\\n                stack1.append(bracket)\\n            # otherwise if the stack is empty \\n            # or if the closing bracket is not of the same type as the opening one\\n            # then sequence is not valid\\n            elif len(stack1) == 0 or check[stack1.pop()] != bracket:\\n                return False\\n            \\n        # if length of the stack is 0 meaning that all opening and closing \\n        # brackets matched then ans is Valid\\n        return len(stack1) == 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        \\n        # TC = O(n) ; SC = O(n)\\n        # because we need to iterate over the string once\\n        # and we are using a check dictionary and stack for space \\n        # so space complexity = O(n)\\n        \\n        n = len(s)\\n        if n&1 or n < 2:\\n            return False\\n        \\n        # odd length strings wont ever be balanced/valid\\n        # similarly strings with a single bracket wont be valid\\n        \\n        check = {\\'(\\':\\')\\', \\'{\\':\\'}\\',\\'[\\':\\']\\'}\\n        stack1 = []\\n        for bracket in s:\\n            # if ith character is opening bracket\\n            # then add it to stack \\n            if bracket in check:\\n                stack1.append(bracket)\\n            # otherwise if the stack is empty \\n            # or if the closing bracket is not of the same type as the opening one\\n            # then sequence is not valid\\n            elif len(stack1) == 0 or check[stack1.pop()] != bracket:\\n                return False\\n            \\n        # if length of the stack is 0 meaning that all opening and closing \\n        # brackets matched then ans is Valid\\n        return len(stack1) == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361893,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> st = new Stack<Character>();\\n        for(char c : s.toCharArray()){\\n            if(c == \\'(\\') st.push(\\')\\');\\n            else if(c == \\'[\\') st.push(\\']\\');\\n            else if(c == \\'{\\') st.push(\\'}\\');\\n            else if(st.isEmpty() || st.pop() != c)\\n                return false;\\n        }\\n        return st.isEmpty();\\n    }\\n}\\n```\\n\\nRuntime: 1 ms, faster than 98.47% of Java online submissions for Valid Parentheses.\\nMemory Usage: 34.3 MB, less than 100.00% of Java online submissions for Valid Parentheses.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> st = new Stack<Character>();\\n        for(char c : s.toCharArray()){\\n            if(c == \\'(\\') st.push(\\')\\');\\n            else if(c == \\'[\\') st.push(\\']\\');\\n            else if(c == \\'{\\') st.push(\\'}\\');\\n            else if(st.isEmpty() || st.pop() != c)\\n                return false;\\n        }\\n        return st.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 311506,
                "title": "python-stack-hash",
                "content": "\\'\\'\\'\\n\\n    def isValid(self, s: str) -> bool:\\n        stack = []\\n        left = set(\\'([{\\')\\n        right = set(\\')]}\\')\\n        check = {\\')\\':\\'(\\', \\']\\':\\'[\\', \\'}\\':\\'{\\'}\\n        for i in s:\\n            if i in left:\\n                stack.append(i)\\n            if i in right:\\n                if not stack:\\n                    return False\\n                elif stack.pop() != check[i]:\\n                    return False\\n                else:\\n                    continue\\n        if not stack:\\n            return True\\n        else:\\n            return False\\n\\t\\t\\t\\n\\'\\'\\'\\n\\n* Python solution with hash table and stack\\n\\n* We go through the \\'string\\' with one pass, so the time complexity would be O(n), spack complexity would be O(n).\\n\\n* Each time when element i is in left, we append it into stack. And each time when element is in right, we compare stack.pop() with the counterpart in hash table until we return False when we find the mismatch or we return True when stack is empty and one pass is done.",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n    def isValid(self, s: str) -> bool:\\n        stack = []\\n        left = set(\\'([{\\')\\n        right = set(\\')]}\\')\\n        check = {\\')\\':\\'(\\', \\']\\':\\'[\\', \\'}\\':\\'{\\'}\\n        for i in s:\\n            if i in left:\\n                stack.append(i)\\n            if i in right:\\n                if not stack:\\n                    return False\\n                elif stack.pop() != check[i]:\\n                    return False\\n                else:\\n                    continue\\n        if not stack:\\n            return True\\n        else:\\n            return False\\n\\t\\t\\t\\n\\'\\'\\'\\n\\n* Python solution with hash table and stack\\n\\n* We go through the \\'string\\' with one pass, so the time complexity would be O(n), spack complexity would be O(n).\\n\\n* Each time when element i is in left, we append it into stack. And each time when element is in right, we compare stack.pop() with the counterpart in hash table until we return False when we find the mismatch or we return True when stack is empty and one pass is done.",
                "codeTag": "Python3"
            },
            {
                "id": 207871,
                "title": "rust",
                "content": "```\\nfn is_valid(s: String) -> bool {\\n    let mut stack = Vec::new();\\n\\n    for c in s.chars() {\\n        stack.push(match c {\\n            \\'(\\' => \\')\\',\\n            \\'[\\' => \\']\\',\\n            \\'{\\' => \\'}\\',\\n            _ => {\\n                if Some(c) == stack.pop() {\\n                    continue;\\n                } else {\\n                    return false;\\n                }\\n            }\\n        })\\n    }\\n\\n    stack.is_empty()\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfn is_valid(s: String) -> bool {\\n    let mut stack = Vec::new();\\n\\n    for c in s.chars() {\\n        stack.push(match c {\\n            \\'(\\' => \\')\\',\\n            \\'[\\' => \\']\\',\\n            \\'{\\' => \\'}\\',\\n            _ => {\\n                if Some(c) == stack.pop() {\\n                    continue;\\n                } else {\\n                    return false;\\n                }\\n            }\\n        })\\n    }\\n\\n    stack.is_empty()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 9179,
                "title": "simple-javascript-solution",
                "content": "```\\nvar isValid = function(s) {\\n    var array = [];\\n    s = s.split( \"\" );\\n    for(let i = 0; i < s.length; i ++){\\n        if( s[i] === \"(\" ) array.push( \")\" );\\n        else if( s[i] === \"[\" ) array.push( \"]\" );\\n        else if( s[i] === \"{\" ) array.push( \"}\" );\\n        else if( s.length === 0 || array[array.length - 1] !== s[i] ) return false;\\n        else array.pop();\\n    }\\n    return array.length === 0;\\n};",
                "solutionTags": [],
                "code": "```\\nvar isValid = function(s) {\\n    var array = [];\\n    s = s.split( \"\" );\\n    for(let i = 0; i < s.length; i ++){\\n        if( s[i] === \"(\" ) array.push( \")\" );\\n        else if( s[i] === \"[\" ) array.push( \"]\" );\\n        else if( s[i] === \"{\" ) array.push( \"}\" );\\n        else if( s.length === 0 || array[array.length - 1] !== s[i] ) return false;\\n        else array.pop();\\n    }\\n    return array.length === 0;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 9613,
                "title": "o-1-space-7-short-lines-0-ms",
                "content": "Only constant extra space since I store my stack inside the given string.\\n\\n---\\n\\n**New solution:**\\n\\nPop if matching open+close, otherwise push. Stack will end up empty if and only if the input is valid.\\n\\n    bool isValid(string s) {\\n        int n = 0;\\n        for (char c : s)\\n            if (n && (c-s[n-1]+1)/2 == 1)\\n                n--;\\n            else\\n                s[n++] = c;\\n        return !n;\\n    }\\n\\nMinified for fun/comparison:\\n\\n    bool isValid(string s) {\\n        int n=0;for(int c:s)n&&(c-s[n-1]+1)/2==1?n--:s[n++]=c;return!n;\\n    }\\n\\n---\\n\\n**Old solution:**\\n\\n    bool isValid(string s) {\\n        int n = 0;\\n        for (char c : s)\\n            if (c%26%3)\\n                s[n++] = c;\\n            else if (!n || c%s[--n]>2)\\n                return false;\\n        return !n;\\n    }\\n\\n`c%26%3` checks whether `c` is an opening parenthesis.  \\n`c%s[--n]>2` checks whether `c` closes the parenthesis on top of the stack.\\n\\nMinified for fun/comparison:\\n\\n    bool isValid(string s){\\n        int n=0;for(int c:s)if(c%26%3)s[n++]=c;else if(!n||c%s[--n]>2)return 0;return!n;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "Only constant extra space since I store my stack inside the given string.\\n\\n---\\n\\n**New solution:**\\n\\nPop if matching open+close, otherwise push. Stack will end up empty if and only if the input is valid.\\n\\n    bool isValid(string s) {\\n        int n = 0;\\n        for (char c : s)\\n            if (n && (c-s[n-1]+1)/2 == 1)\\n                n--;\\n            else\\n                s[n++] = c;\\n        return !n;\\n    }\\n\\nMinified for fun/comparison:\\n\\n    bool isValid(string s) {\\n        int n=0;for(int c:s)n&&(c-s[n-1]+1)/2==1?n--:s[n++]=c;return!n;\\n    }\\n\\n---\\n\\n**Old solution:**\\n\\n    bool isValid(string s) {\\n        int n = 0;\\n        for (char c : s)\\n            if (c%26%3)\\n                s[n++] = c;\\n            else if (!n || c%s[--n]>2)\\n                return false;\\n        return !n;\\n    }\\n\\n`c%26%3` checks whether `c` is an opening parenthesis.  \\n`c%s[--n]>2` checks whether `c` closes the parenthesis on top of the stack.\\n\\nMinified for fun/comparison:\\n\\n    bool isValid(string s){\\n        int n=0;for(int c:s)if(c%26%3)s[n++]=c;else if(!n||c%s[--n]>2)return 0;return!n;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2474155,
                "title": "100-faster-c-well-commented-and-variable-named-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> bracketStack;\\n    \\n        for(int i=0;i<s.size();i++){\\n            char openingBracket = s[i];\\n            //pushing all the opening brackets in stack\\n            if(openingBracket == \\'(\\' || openingBracket == \\'{\\' || openingBracket == \\'[\\'){\\n                bracketStack.push(s[i]);\\n            }\\n            else{\\n                //as soon as the bracket isn\\'t opening check if the stack is empty or not\\n                if(!bracketStack.empty()){\\n                    char top = bracketStack.top();\\n                    //checking if the bracket is balanced or not\\n                    if(top==\\'(\\'  && s[i]==\\')\\'  || top==\\'{\\' &&  s[i]==\\'}\\' || top==\\'[\\' && s[i]==\\']\\'){\\n                        bracketStack.pop();\\n                    }\\n                    //if not balanced return false\\n                    else\\n                        return false;\\n                }\\n                //else if the stack is not empty return false\\n                else\\n                    return false;\\n            }\\n        }\\n        \\n        if(bracketStack.empty()) \\n            return true;\\n        //if after traversal of the entire string there is still a bracket left in the stack that means brackets are unbalanced\\n        return false;\\n    }\\n};\\n//please upvote if you find it useful\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> bracketStack;\\n    \\n        for(int i=0;i<s.size();i++){\\n            char openingBracket = s[i];\\n            //pushing all the opening brackets in stack\\n            if(openingBracket == \\'(\\' || openingBracket == \\'{\\' || openingBracket == \\'[\\'){\\n                bracketStack.push(s[i]);\\n            }\\n            else{\\n                //as soon as the bracket isn\\'t opening check if the stack is empty or not\\n                if(!bracketStack.empty()){\\n                    char top = bracketStack.top();\\n                    //checking if the bracket is balanced or not\\n                    if(top==\\'(\\'  && s[i]==\\')\\'  || top==\\'{\\' &&  s[i]==\\'}\\' || top==\\'[\\' && s[i]==\\']\\'){\\n                        bracketStack.pop();\\n                    }\\n                    //if not balanced return false\\n                    else\\n                        return false;\\n                }\\n                //else if the stack is not empty return false\\n                else\\n                    return false;\\n            }\\n        }\\n        \\n        if(bracketStack.empty()) \\n            return true;\\n        //if after traversal of the entire string there is still a bracket left in the stack that means brackets are unbalanced\\n        return false;\\n    }\\n};\\n//please upvote if you find it useful\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1799213,
                "title": "very-easy-java-solution",
                "content": "**/*Please upvote if it is hepful**\\n\\nclass Solution {\\n\\n    public boolean isValid(String s) {\\n        Stack<Character>st = new Stack<>();\\n        for(int i=0; i<s.length(); i++){\\n             char ch = s.charAt(i);\\n             if(ch == \\'{\\' || ch == \\'[\\' || ch == \\'(\\'){\\n                 st.push(ch);\\n             }\\n             else if(ch == \\')\\'){\\n                 if(st.size() == 0 || st.peek() != \\'(\\'){\\n                     return false;\\n                 }\\n                 else{\\n                     st.pop();\\n                 }\\n             }\\n             else if(ch == \\'}\\'){\\n                 if(st.size() == 0 || st.peek() != \\'{\\'){\\n                     return false;\\n                 }\\n                 else{\\n                     st.pop();\\n                 }\\n             }\\n             else if(ch == \\']\\'){\\n                 if(st.size() == 0 || st.peek() != \\'[\\'){\\n                     return false;\\n                 }\\n                 else{\\n                     st.pop();\\n                 }\\n             }\\n             \\n        }\\n        if(st.size() > 0){\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n**/*Please upvote if it is hepful**",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n\\n    public boolean isValid(String s) {\\n        Stack<Character>st = new Stack<>();\\n        for(int i=0; i<s.length(); i++){\\n             char ch = s.charAt(i);\\n             if(ch == \\'{\\' || ch == \\'[\\' || ch == \\'(\\'){\\n                 st.push(ch);\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 1793638,
                "title": "simple-python3-solution-90-lesser-memory-o-n-2-solution",
                "content": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        while((\"()\" in s) or (\"{}\" in s) or (\"[]\" in s)):\\n            if \"()\" in s:\\n                s = s.replace(\"()\", \"\")\\n            if \"{}\" in s:\\n                s = s.replace(\"{}\", \"\")\\n            if \"[]\" in s:\\n                s = s.replace(\"[]\", \"\")\\n        return s == \"\"\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        while((\"()\" in s) or (\"{}\" in s) or (\"[]\" in s)):\\n            if \"()\" in s:\\n                s = s.replace(\"()\", \"\")\\n            if \"{}\" in s:\\n                s = s.replace(\"{}\", \"\")\\n            if \"[]\" in s:\\n                s = s.replace(\"[]\", \"\")\\n        return s == \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 529582,
                "title": "javascript-readable-o-n-99-55",
                "content": "```\\nvar isValid = function(s) {\\n  const openMap = new Map([\\n    [\\'(\\', \\')\\'],\\n    [\\'[\\', \\']\\'],\\n    [\\'{\\', \\'}\\'],\\n  ]);\\n  const closeMap = new Map([\\n    [\\')\\', \\'(\\'],\\n    [\\']\\', \\'[\\'],\\n    [\\'}\\', \\'{\\'],\\n  ]);\\n  const stack = [];\\n\\n  for (let i = 0; i < s.length; i += 1) {\\n    if (openMap.get(s[i])) {\\n      stack.push(s[i]);\\n    } else {\\n      const item = stack.pop();\\n\\n      if (item !== closeMap.get(s[i])) {\\n        return false;\\n      }\\n    }\\n  }\\n\\n  return stack.length === 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isValid = function(s) {\\n  const openMap = new Map([\\n    [\\'(\\', \\')\\'],\\n    [\\'[\\', \\']\\'],\\n    [\\'{\\', \\'}\\'],\\n  ]);\\n  const closeMap = new Map([\\n    [\\')\\', \\'(\\'],\\n    [\\']\\', \\'[\\'],\\n    [\\'}\\', \\'{\\'],\\n  ]);\\n  const stack = [];\\n\\n  for (let i = 0; i < s.length; i += 1) {\\n    if (openMap.get(s[i])) {\\n      stack.push(s[i]);\\n    } else {\\n      const item = stack.pop();\\n\\n      if (item !== closeMap.get(s[i])) {\\n        return false;\\n      }\\n    }\\n  }\\n\\n  return stack.length === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 519976,
                "title": "super-readable-swift-solution-8-ms",
                "content": "```\\nclass Solution {\\n    func isValid(_ s: String) -> Bool {\\n    guard !s.isEmpty else { return true }\\n    var stack: [Character] = []\\n    \\n    for bracket in s {\\n        switch bracket {\\n            case \"{\":\\n            stack.append(\"}\")\\n            case \"(\":\\n            stack.append(\")\")\\n            case \"[\":\\n            stack.append(\"]\")\\n            default:\\n                guard bracket == stack.popLast() else { return false }\\n        }\\n    }\\n    return stack.isEmpty\\n}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isValid(_ s: String) -> Bool {\\n    guard !s.isEmpty else { return true }\\n    var stack: [Character] = []\\n    \\n    for bracket in s {\\n        switch bracket {\\n            case \"{\":\\n            stack.append(\"}\")\\n            case \"(\":\\n            stack.append(\")\")\\n            case \"[\":\\n            stack.append(\"]\")\\n            default:\\n                guard bracket == stack.popLast() else { return false }\\n        }\\n    }\\n    return stack.isEmpty\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150759,
                "title": "python-4-liner-beats-100",
                "content": "```\\n        stack, paren_map = [], {\\')\\': \\'(\\', \\']\\': \\'[\\', \\'}\\': \\'{\\'}\\n        for c in s:\\n            if c not in paren_map: stack.append(c)\\n            elif not stack or paren_map[c] != stack.pop(): return False\\n        return not stack\\n```",
                "solutionTags": [],
                "code": "```\\n        stack, paren_map = [], {\\')\\': \\'(\\', \\']\\': \\'[\\', \\'}\\': \\'{\\'}\\n        for c in s:\\n            if c not in paren_map: stack.append(c)\\n            elif not stack or paren_map[c] != stack.pop(): return False\\n        return not stack\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3399361,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "**Stack Approach**\\n\\nStack is widely known as `LIFO (last-in, first-out)` data structure. \\n\\nIt\\'s commonly used in `undo mechanisms in text editors` and `compiler syntax checking for matching brackets and braces`.\\n\\nParentheses/braces can be in this order `\\'()()\\'` or `\\'(())\\'`, since the last open `\\'(\\'` brace next sequence could be either `\\')\\'` or `\\'(\\'` another open brace to nested open braces. \\n\\nIf the input has any of the open `\\'(\\'` or `\\'{\\'` or `\\'[\\'` we can push onto a stack. If any close braces/parentheses comes then validate with last inserted character which is on the stack pop, should match corresponding open braces/paranetheses. \\n\\nTime Complexity: $O(n)$, where $n$ - # of characters in the string\\n\\nSpace complexity: $O(n)$\\n\\n<iframe src=\"https://leetcode.com/playground/jRD4gCwQ/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Stack"
                ],
                "code": "**Stack Approach**\\n\\nStack is widely known as `LIFO (last-in, first-out)` data structure. \\n\\nIt\\'s commonly used in `undo mechanisms in text editors` and `compiler syntax checking for matching brackets and braces`.\\n\\nParentheses/braces can be in this order `\\'()()\\'` or `\\'(())\\'`, since the last open `\\'(\\'` brace next sequence could be either `\\')\\'` or `\\'(\\'` another open brace to nested open braces. \\n\\nIf the input has any of the open `\\'(\\'` or `\\'{\\'` or `\\'[\\'` we can push onto a stack. If any close braces/parentheses comes then validate with last inserted character which is on the stack pop, should match corresponding open braces/paranetheses. \\n\\nTime Complexity: $O(n)$, where $n$ - # of characters in the string\\n\\nSpace complexity: $O(n)$\\n\\n<iframe src=\"https://leetcode.com/playground/jRD4gCwQ/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2319800,
                "title": "python-stack",
                "content": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        stack=[]\\n        \\n        for i in s:\\n            if stack:\\n                if i==\\')\\' and stack[-1] == \"(\":\\n                    stack.pop()\\n                elif i==\\']\\' and stack[-1] == \"[\":\\n                    stack.pop()\\n                elif i==\\'}\\' and stack[-1] == \"{\":\\n                    stack.pop()\\n                else:\\n                    stack.append(i)\\n            else:\\n                stack.append(i)\\n        return len(stack)==0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        stack=[]\\n        \\n        for i in s:\\n            if stack:\\n                if i==\\')\\' and stack[-1] == \"(\":\\n                    stack.pop()\\n                elif i==\\']\\' and stack[-1] == \"[\":\\n                    stack.pop()\\n                elif i==\\'}\\' and stack[-1] == \"{\":\\n                    stack.pop()\\n                else:\\n                    stack.append(i)\\n            else:\\n                stack.append(i)\\n        return len(stack)==0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1707383,
                "title": "using-stack-in-c",
                "content": "bool isValid(char * s){\\n    \\n    char stack[10000];\\n    int top=-1;\\n    \\n    while(*s!=\\'\\\\0\\')\\n    {\\n        if(*s==\\'(\\' ||*s==\\'[\\'||*s==\\'{\\' )\\n            stack[++top]=*s;\\n        else if(*s==\\')\\'){\\n            if(top==-1||stack[top]!=\\'(\\')\\n                return false;\\n            else\\n                top--;\\n        }\\n         else if(*s==\\']\\'){\\n            if(top==-1||stack[top]!=\\'[\\')\\n                return false;\\n            else\\n                top--;\\n        }\\n         else if(*s==\\'}\\'){\\n            if(top==-1||stack[top]!=\\'{\\')\\n                return false;\\n            else\\n                top--;\\n        }\\n        \\n        s++;\\n    }\\n    \\n    if(top!=-1)\\n        return false;\\n    else\\n    return true;\\n    \\n}",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "bool isValid(char * s){\\n    \\n    char stack[10000];\\n    int top=-1;\\n    \\n    while(*s!=\\'\\\\0\\')\\n    {\\n        if(*s==\\'(\\' ||*s==\\'[\\'||*s==\\'{\\' )\\n            stack[++top]=*s;\\n        else if(*s==\\')\\'){\\n            if(top==-1||stack[top]!=\\'(\\')\\n                return false;\\n            else\\n                top--;\\n        }\\n         else if(*s==\\']\\'){\\n            if(top==-1||stack[top]!=\\'[\\')\\n                return false;\\n            else\\n                top--;\\n        }\\n         else if(*s==\\'}\\'){\\n            if(top==-1||stack[top]!=\\'{\\')\\n                return false;\\n            else\\n                top--;\\n        }\\n        \\n        s++;\\n    }\\n    \\n    if(top!=-1)\\n        return false;\\n    else\\n    return true;\\n    \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1697542,
                "title": "c-easy-solution-100-faster-than-other-submission-do-check-it-out",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {   // Do like My Solution Please\\n        map<char,int> map;\\n        map[\\'(\\']=1;\\n        map[\\'{\\']=2;\\n        map[\\'[\\']=3;\\n        map[\\')\\']=4;\\n        map[\\'}\\']=5;\\n        map[\\']\\']=6;\\n        stack<int> stac; \\n        for(int i = 0 ; i < s.size() ; i++){\\n            if(s[i]==\\'(\\' || s[i]==\\'{\\' || s[i]==\\'[\\'){\\n                stac.push(map[s[i]]);\\n            }\\n            else{\\n                if(stac.size()==0){\\n                    return false;\\n                }\\n                else if(map[s[i]]-stac.top()!=3){\\n                    return false ;\\n                }\\n                else stac.pop();\\n            }\\n        }\\n        if(stac.size()!=0)return false ;\\n        return true ;\\n    }\\n\\t//THANK YOU !! DO LIKE MY SOLUTION IF IT HELPS YOU !!!\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {   // Do like My Solution Please\\n        map<char,int> map;\\n        map[\\'(\\']=1;\\n        map[\\'{\\']=2;\\n        map[\\'[\\']=3;\\n        map[\\')\\']=4;\\n        map[\\'}\\']=5;\\n        map[\\']\\']=6;\\n        stack<int> stac; \\n        for(int i = 0 ; i < s.size() ; i++){\\n            if(s[i]==\\'(\\' || s[i]==\\'{\\' || s[i]==\\'[\\'){\\n                stac.push(map[s[i]]);\\n            }\\n            else{\\n                if(stac.size()==0){\\n                    return false;\\n                }\\n                else if(map[s[i]]-stac.top()!=3){\\n                    return false ;\\n                }\\n                else stac.pop();\\n            }\\n        }\\n        if(stac.size()!=0)return false ;\\n        return true ;\\n    }\\n\\t//THANK YOU !! DO LIKE MY SOLUTION IF IT HELPS YOU !!!\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 289464,
                "title": "perfect-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Map<Character,Character> mappings = new HashMap<Character,Character>(){{\\n            put(\\')\\', \\'(\\');\\n            put(\\'}\\', \\'{\\');\\n            put(\\']\\', \\'[\\');\\n        }};\\n\\n        Stack<Character> letters = new Stack<>();\\n\\t\\t\\n        for(int i = 0; i < s.length(); i++){\\n            char temp = s.charAt(i);\\n            if(mappings.containsKey(temp)){\\n                if(letters.isEmpty() || letters.pop() != mappings.get(temp)){\\n                    return false;\\n                }\\n            } else{\\n                letters.push(temp);\\n            }\\n        }\\n        return letters.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Map<Character,Character> mappings = new HashMap<Character,Character>(){{\\n            put(\\')\\', \\'(\\');\\n            put(\\'}\\', \\'{\\');\\n            put(\\']\\', \\'[\\');\\n        }};\\n\\n        Stack<Character> letters = new Stack<>();\\n\\t\\t\\n        for(int i = 0; i < s.length(); i++){\\n            char temp = s.charAt(i);\\n            if(mappings.containsKey(temp)){\\n                if(letters.isEmpty() || letters.pop() != mappings.get(temp)){\\n                    return false;\\n                }\\n            } else{\\n                letters.push(temp);\\n            }\\n        }\\n        return letters.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152260,
                "title": "simple-python",
                "content": "Add left handed parentheses to the stack as they are encountered. If we encounter a right hand parentheses, check if the stack is empty (meaning we didn\\'t previously encounter its match)  or if the stack\\'s top element is its pair. At the end return True if the stack is empty\\n```\\nclass Solution:\\n    def isValid(self, s):\\n        d = {\\'{\\':\\'}\\', \\'(\\':\\')\\', \\'[\\':\\']\\'}\\n        stack = []\\n        for c in s:\\n            if c in d:\\n                stack.append(c)\\n            elif not stack or c != d[stack.pop()]:\\n                return False\\n        return not stack\\n````",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValid(self, s):\\n        d = {\\'{\\':\\'}\\', \\'(\\':\\')\\', \\'[\\':\\']\\'}\\n        stack = []\\n        for c in s:\\n            if c in d:\\n                stack.append(c)\\n            elif not stack or c != d[stack.pop()]:\\n                return False\\n        return not stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 9247,
                "title": "easy-python-solution-o-1-space",
                "content": "```\\ndef isValid(self, s):\\n    delta = len(s)\\n    while(delta != 0 and delta%2 == 0):\\n        s = s.replace(\"()\", \"\")\\n        s = s.replace(\"[]\", \"\")\\n        s = s.replace(\"{}\", \"\")\\n        # breaks while loop if string was not altered during current pass\\n        delta = len(s) if delta > len(s) else 0\\n    return len(s) == 0\\n```",
                "solutionTags": [],
                "code": "```\\ndef isValid(self, s):\\n    delta = len(s)\\n    while(delta != 0 and delta%2 == 0):\\n        s = s.replace(\"()\", \"\")\\n        s = s.replace(\"[]\", \"\")\\n        s = s.replace(\"{}\", \"\")\\n        # breaks while loop if string was not altered during current pass\\n        delta = len(s) if delta > len(s) else 0\\n    return len(s) == 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 9195,
                "title": "my-21-line-java-solution-without-in-code",
                "content": "    public class Solution {\\n    public boolean isValid(String s) {\\n        char [] arr = s.toCharArray();\\n\\t\\tStack stack = new Stack();\\n\\t\\tfor(char ch : arr){\\n\\t\\t\\tif(stack.isEmpty()){\\n\\t\\t\\t\\tstack.push(ch);\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tchar top = (char)stack.lastElement();\\n\\t\\t\\t\\tif(ch - top == 1 || ch - top == 2){\\n\\t\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tstack.push(ch);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(stack.isEmpty()){\\n\\t\\t    return true;\\n\\t\\t}\\n\\t\\treturn false;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n    public boolean isValid(String s) {\\n        char [] arr = s.toCharArray();\\n\\t\\tStack stack = new Stack();\\n\\t\\tfor(char ch : arr){\\n\\t\\t\\tif(stack.isEmpty()){\\n\\t\\t\\t\\tstack.push(ch);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 9565,
                "title": "java-solution-with-stack-very-easy-to-read-straightforward",
                "content": "    public class Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> stack = new Stack<Character>();\\n        if(s.equals(\"\")) return true;\\n        for(char ch : s.toCharArray()){\\n            if(ch=='('|| ch=='[' || ch=='{'){\\n                stack.push(ch);\\n            } else if(ch==')'){\\n                if(stack.empty() || stack.pop()!='(')\\n                    return false;\\n            } else if(ch==']'){\\n                if(stack.empty() || stack.pop()!='[')\\n                    return false;\\n            } else if(ch=='}'){\\n                if(stack.empty() || stack.pop()!='{')\\n                    return false;\\n            }\\n        }\\n        return stack.empty();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> stack = new Stack<Character>();\\n        if(s.equals(\"\")) return true;\\n        for(char ch : s.toCharArray()){\\n            if(ch=='('|| ch=='[' || ch=='{'){\\n                stack.push(ch);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3443865,
                "title": "best-swift-solution-easy-to-understand",
                "content": "# Approach\\nThe first check is to see if the length of the string is even or not. If it\\'s not even, then it\\'s not possible to have balanced parentheses, and the function returns `false`.\\n\\nThe second check is to use a `stack` to keep track of opening brackets. Whenever an opening bracket is encountered, its corresponding closing bracket is pushed onto the stack. Whenever a closing bracket is encountered, the stack\\'s top element is checked to see if it matches the closing bracket. If it doesn\\'t match or the stack is empty, then the string is not balanced, and the function returns `false`. If all the closing brackets match the stack\\'s top elements, the stack will be empty at the end of the string, and the function returns `true`.\\n\\n![stack.gif](https://assets.leetcode.com/users/images/9751eb6c-e6a1-477b-96d2-1642c8b3e86d_1682163247.552942.gif)\\n\\n\\n# Complexity\\nThe *time complexity* of this approach is $$O(n)$$ because it iterates through the entire string once, where $$n$$ is the length of the string.\\n\\nThe *space complexity* is also $$O(n)$$ because, in the worst-case scenario, the stack could contain all opening brackets before encountering any closing brackets.\\n\\n# Code\\n```swift\\nclass Solution {\\n    func isValid(_ s: String) -> Bool {\\n        guard s.count % 2 == 0 else { return false }\\n        var stack: [Character] = []\\n\\n        for item in s {\\n            switch item {\\n            case \"(\":\\n                stack.append(\")\")\\n            case \"[\":\\n                stack.append(\"]\")\\n            case \"{\":\\n                stack.append(\"}\")\\n            default:\\n                if stack.isEmpty || stack.removeLast() != item {\\n                    return false\\n                }\\n            }\\n        }\\n\\n        return stack.isEmpty\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "String",
                    "Stack"
                ],
                "code": "```swift\\nclass Solution {\\n    func isValid(_ s: String) -> Bool {\\n        guard s.count % 2 == 0 else { return false }\\n        var stack: [Character] = []\\n\\n        for item in s {\\n            switch item {\\n            case \"(\":\\n                stack.append(\")\")\\n            case \"[\":\\n                stack.append(\"]\")\\n            case \"{\":\\n                stack.append(\"}\")\\n            default:\\n                if stack.isEmpty || stack.removeLast() != item {\\n                    return false\\n                }\\n            }\\n        }\\n\\n        return stack.isEmpty\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401175,
                "title": "php-beats-100-javascript-bracket-validation-with-a-stack",
                "content": "# Approach\\nThis approach uses a stack to validate if a given string of brackets is valid. \\n\\nFirst, the length of the string is checked to ensure that it is even, as any string of brackets that is not even can not be balanced. \\n\\nThen, if s[i] is the opening brackets, matching closing bracket pushed onto the stack, and as the string is traversed, if the character is a closing bracket, the top of the stack popped off the stack and is checked to see if it matches. \\n\\nIf it does the process continues. \\nIf it does not match, the string is invalid. \\nAfter the loop is complete, the stack should be empty, as all of the opening brackets should have been popped off the stack. \\nIf it is not empty, the string is invalid.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ as the loop only needs to traverse the string once. \\n- Space complexity: $$O(n)$$ as in the worst case, the stack will contain all of the characters in the string.\\n\\n### JavaScript\\n```javascript\\nvar isValid = function (s) {\\n    const sLength = s.length;\\n    if (sLength % 2 !== 0) return false;\\n\\n    const brackets = {\\'(\\': \\')\\', \\'{\\': \\'}\\', \\'[\\': \\']\\'};\\n    const stack = [];\\n    for (let i = 0; i < sLength; i++) {\\n        if (brackets[s[i]]) {\\n            stack.push(s[i]);\\n        } else if (s[i] !== brackets[stack.pop()]) {\\n            return false;\\n        }\\n    }\\n    return stack.length === 0;\\n};\\n```\\n\\n### PHP\\n```php\\nclass Solution\\n{\\n    /**\\n     * @param String $s\\n     * @return Boolean\\n     */\\n    function isValid(string $s): bool {\\n        $sLength = strlen($s);\\n        if ($sLength % 2 !== 0) return false;\\n        $bracketSet = [\\'(\\' => \\')\\', \\'[\\' => \\']\\', \\'{\\' => \\'}\\'];\\n\\n        $bracketStack = [];\\n\\n        for ($i = 0; $i < $sLength; $i++) {\\n            if (array_key_exists($s[$i], $bracketSet)) {\\n                $bracketStack[] = $bracketSet[$s[$i]];\\n            } elseif (array_pop($bracketStack) !== $s[$i]) {\\n                return false;\\n            }\\n        }\\n        return count($bracketStack) === 0;\\n    }\\n}\\n```\\n\\n##### Thanks for reading! If you have any questions or suggestions, please leave a comment below. I would love to hear your thoughts! \\uD83D\\uDE0A\\n### **Please upvote if you found this post helpful! \\uD83D\\uDC4D**\\n",
                "solutionTags": [
                    "JavaScript",
                    "PHP",
                    "String",
                    "Stack"
                ],
                "code": "```javascript\\nvar isValid = function (s) {\\n    const sLength = s.length;\\n    if (sLength % 2 !== 0) return false;\\n\\n    const brackets = {\\'(\\': \\')\\', \\'{\\': \\'}\\', \\'[\\': \\']\\'};\\n    const stack = [];\\n    for (let i = 0; i < sLength; i++) {\\n        if (brackets[s[i]]) {\\n            stack.push(s[i]);\\n        } else if (s[i] !== brackets[stack.pop()]) {\\n            return false;\\n        }\\n    }\\n    return stack.length === 0;\\n};\\n```\n```php\\nclass Solution\\n{\\n    /**\\n     * @param String $s\\n     * @return Boolean\\n     */\\n    function isValid(string $s): bool {\\n        $sLength = strlen($s);\\n        if ($sLength % 2 !== 0) return false;\\n        $bracketSet = [\\'(\\' => \\')\\', \\'[\\' => \\']\\', \\'{\\' => \\'}\\'];\\n\\n        $bracketStack = [];\\n\\n        for ($i = 0; $i < $sLength; $i++) {\\n            if (array_key_exists($s[$i], $bracketSet)) {\\n                $bracketStack[] = $bracketSet[$s[$i]];\\n            } elseif (array_pop($bracketStack) !== $s[$i]) {\\n                return false;\\n            }\\n        }\\n        return count($bracketStack) === 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399435,
                "title": "c-easy-stack",
                "content": "# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        int a=0,b=0,c=0;\\n        stack<char>st;\\n        for(int i=0;i<s.size();i++){\\n            if(st.size()==0)st.push(s[i]);\\n            else {\\n                if(s[i]==\\'}\\'){\\n                    if(st.top()!=\\'{\\')return false;\\n                    st.pop();\\n                }\\n                else if(s[i]==\\']\\'){\\n                    if(st.top()!=\\'[\\')return false;\\n                    st.pop();\\n                }\\n                else if(s[i]==\\')\\'){\\n                    if(st.top()!=\\'(\\')return false;\\n                    st.pop();\\n                }\\n                else st.push(s[i]);\\n            }\\n        }\\n        if(st.size())return false;\\n        return true;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/aabdd456-ee53-4831-a5fa-a0d04042c943_1681105589.7481997.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        int a=0,b=0,c=0;\\n        stack<char>st;\\n        for(int i=0;i<s.size();i++){\\n            if(st.size()==0)st.push(s[i]);\\n            else {\\n                if(s[i]==\\'}\\'){\\n                    if(st.top()!=\\'{\\')return false;\\n                    st.pop();\\n                }\\n                else if(s[i]==\\']\\'){\\n                    if(st.top()!=\\'[\\')return false;\\n                    st.pop();\\n                }\\n                else if(s[i]==\\')\\'){\\n                    if(st.top()!=\\'(\\')return false;\\n                    st.pop();\\n                }\\n                else st.push(s[i]);\\n            }\\n        }\\n        if(st.size())return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085759,
                "title": "easy-fast-array-solution",
                "content": "# Intuition\\nThe main idea of the solution is a usage of a list of opened brackets for checking if brackets are closing correctly.\\n\\n# Approach\\n1. Creating a **dict** with **open-bracket as key** and **close-bracket as value**.\\n2. Creating an **empty list**.\\n3. Looping through the string of brackets.\\n    1. If the **current character** is an opened bracket we\\'ll append it to the list.\\n    2. Else if the current character is a closed bracket of the last opened we **delete** the last opened, else we exit the loop and return False.\\n4. If the list is empty after looping (*that means that all opened brackets were closed correctly*), the string is **valid**.\\n\\n# Code\\n```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        d = {\\'(\\':\\')\\', \\'{\\':\\'}\\',\\'[\\':\\']\\'}\\n        m = []\\n\\n        for x in s:\\n            if x in d:\\n                m.append(x)\\n\\n            else: \\n                if len(m) and d[m[-1]] == x:\\n                    del m[-1]\\n                else:\\n                    return False\\n\\n        return not m\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        d = {\\'(\\':\\')\\', \\'{\\':\\'}\\',\\'[\\':\\']\\'}\\n        m = []\\n\\n        for x in s:\\n            if x in d:\\n                m.append(x)\\n\\n            else: \\n                if len(m) and d[m[-1]] == x:\\n                    del m[-1]\\n                else:\\n                    return False\\n\\n        return not m\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676217,
                "title": "c-clean-code-easiest-solution-explaination-0-ms-beats",
                "content": "Firstly, we are inserting the string characters in stack if they are open brackets like ( \"[\" , \"(\" , \"[\" ), then if they\\'re other than open bracket, then we are comparing the stack top element if it is a pair of the string character or not, while makink sure that our stack is non empty.\\nIf we find a **valid pair with string character** then we are popping that character from the stack.\\nAt the end, if our stack comes out to be empty then return true, else return false.\\n\\n**Make Sure To Dry Run This Code**\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        \\n        if(s.size() == 1)\\n            return false;\\n        \\n        stack<char> stack;\\n        \\n        int i=0;\\n        while(i < s.size()){\\n            if(s[i] == \\'(\\' || \\n               s[i] == \\'{\\' ||\\n               s[i] == \\'[\\'   ){\\n                \\n                stack.push(s[i]);\\n                i++;\\n            }\\n            else {\\n                \\n                if(s[i] == \\')\\'){\\n                    \\n                    if(!stack.empty() && stack.top() == \\'(\\'){\\n                        stack.pop();\\n                        i++;}\\n                    \\n                    else return false;\\n                    \\n                }\\n                if(s[i] == \\']\\'){\\n                    \\n                    if(!stack.empty() && stack.top() == \\'[\\' ){\\n                        stack.pop();\\n                        i++;}\\n                    \\n                    else return false;\\n                    \\n                }  \\n                if(s[i] == \\'}\\'){\\n                    \\n                    if(!stack.empty() && stack.top() == \\'{\\'){\\n                        stack.pop();\\n                        i++;}\\n                    \\n                    else return false;\\n                }\\n            }\\n        }\\n        if(stack.empty())\\n            return true;\\n        else return false;\\n    }\\n};\\n```\\n\\n**Time Complexity :- O(n)**\\n**Space Complexity:- O(n)**\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        \\n        if(s.size() == 1)\\n            return false;\\n        \\n        stack<char> stack;\\n        \\n        int i=0;\\n        while(i < s.size()){\\n            if(s[i] == \\'(\\' || \\n               s[i] == \\'{\\' ||\\n               s[i] == \\'[\\'   ){\\n                \\n                stack.push(s[i]);\\n                i++;\\n            }\\n            else {\\n                \\n                if(s[i] == \\')\\'){\\n                    \\n                    if(!stack.empty() && stack.top() == \\'(\\'){\\n                        stack.pop();\\n                        i++;}\\n                    \\n                    else return false;\\n                    \\n                }\\n                if(s[i] == \\']\\'){\\n                    \\n                    if(!stack.empty() && stack.top() == \\'[\\' ){\\n                        stack.pop();\\n                        i++;}\\n                    \\n                    else return false;\\n                    \\n                }  \\n                if(s[i] == \\'}\\'){\\n                    \\n                    if(!stack.empty() && stack.top() == \\'{\\'){\\n                        stack.pop();\\n                        i++;}\\n                    \\n                    else return false;\\n                }\\n            }\\n        }\\n        if(stack.empty())\\n            return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2383522,
                "title": "fastest-solution-explained-0ms-100-o-n-time-complexity-o-n-space-complexity",
                "content": "\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 3.27MB*** (beats 99.04% / 90.42%).\\n* *** Java ***\\n\\n```\\n\\npublic class Solution {\\n    public boolean isValid(String s) {\\n        int length;\\n    \\n        do {\\n            length = s.length();\\n            s = s.replace(\"()\", \"\").replace(\"{}\", \"\").replace(\"[]\", \"\");\\n        } while(length != s.length());\\n    \\n        return s.length() == 0;\\n    }\\n}\\n\\n```\\nIn this solution you essentially can remove parentheses that you know are valid until the string is empty. If the string is not empty, that means that the parentheses were malformed.\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 10MB*** (beats 100.00% / 95.49%).\\n* *** Python ***\\n\\n```\\n\\nclass Solution(object):\\n\\tdef isValid(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        d = {\\'(\\':\\')\\', \\'{\\':\\'}\\',\\'[\\':\\']\\'}\\n        stack = []\\n        for i in s:\\n            if i in d:  # 1\\n                stack.append(i)\\n            elif len(stack) == 0 or d[stack.pop()] != i:  # 2\\n                return False\\n        return len(stack) == 0 # 3\\n\\t\\n# 1. if it\\'s the left bracket then we append it to the stack\\n# 2. else if it\\'s the right bracket and the stack is empty(meaning no matching left bracket), or the left bracket doesn\\'t match\\n# 3. finally check if the stack still contains unmatched left bracket\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 23.7MB*** (beats 59.24% / 60.42%).\\n* *** C++ ***\\n\\n\\n```\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;  //taking stack for keep tracking the order of the brackets..\\n        for(auto i:s)  //iterate over each and every elements\\n        {\\n            if(i==\\'(\\' or i==\\'{\\' or i==\\'[\\') st.push(i);  //if current element of the string will be opening bracket then we will just simply push it into the stack\\n            else  //if control comes to else part, it means that current element is a closing bracket, so check two conditions  current element matches with top of the stack and the stack must not be empty...\\n            {\\n                if(st.empty() or (st.top()==\\'(\\' and i!=\\')\\') or (st.top()==\\'{\\' and i!=\\'}\\') or (st.top()==\\'[\\' and i!=\\']\\')) return false;\\n                st.pop();  //if control reaches to that line, it means we have got the right pair of brackets, so just pop it.\\n            }\\n        }\\n        return st.empty();  //at last, it may possible that we left something into the stack unpair so return checking stack is empty or not..\\n    }\\n};\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 78MB*** (beats 100.00% / 100.00%).\\n* *** JavaScript ***\\n\\n\\n```\\n\\nvar isValid = function(s) {   \\n    const stack = [];\\n    \\n    for (let i = 0 ; i < s.length ; i++) {\\n        let c = s.charAt(i);\\n        switch(c) {\\n            case \\'(\\': stack.push(\\')\\');\\n                break;\\n            case \\'[\\': stack.push(\\']\\');\\n                break;\\n            case \\'{\\': stack.push(\\'}\\');\\n                break;\\n            default:\\n                if (c !== stack.pop()) {\\n                    return false;\\n                }\\n        }\\n    }\\n    \\n    return stack.length === 0;\\n};\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 15.23MB*** (beats 89.94% / 90.99%).\\n* *** Python3 ***\\n\\n\\n```\\n\\n    def isValid(self, s: str) -> bool:\\n        dic = {\\'(\\':1 , \\')\\':2 , \\'[\\':3 , \\']\\':6 , \\'{\\':5 , \\'}\\':10}\\n        res = []\\n        for one in s:\\n            temp = dic[one]\\n            if(temp %2 ):\\n                res.append(temp)\\n            else:\\n                if(len(res) and res[-1]==temp//2):\\n                    del res[-1]\\n                else:\\n                    return False\\n        return res==[]\\n\\n```\\nuse temp = dic[one] to replace calculate dic[one] many times, it save many times . It can Improve 79% to 97\\n% beat times.\\n\\nRuntime: 24 ms, faster than 97.46% of Python3 online submissions for Valid Parentheses.\\nMemory Usage: 12.9 MB, less than 100.00% of Python3 online submissions for Valid Parentheses.\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 33.33MB*** (beats 99.00% / 60.12%).\\n* *** Kotlin ***\\n\\n\\n```\\n\\nfun main() {\\n    \"(){}\".isValidParentheses().apply(::println) // true\\n    \"(){\".isValidParentheses().apply(::println) // false\\n    \"(){}[](){}()\".isValidParentheses().apply(::println) // true\\n    \"(){}[](){}()]\".isValidParentheses().apply(::println) // false\\n}\\n\\nfun String.isValidParentheses(): Boolean {\\n    val p = \\'(\\' to \\')\\'\\n    val b = \\'[\\' to \\']\\'\\n    val k = \\'{\\' to \\'}\\'\\n\\n    for ((index, value) in withIndex()) {\\n        if (index % 2 == 0) {\\n            val nextChar = getOrNull(index + 1)\\n            if (!when (value) {\\n                    p.first -> p.second == nextChar\\n                    b.first -> b.second == nextChar\\n                    k.first -> k.second == nextChar\\n                    else -> false\\n                }\\n            ) {\\n                return false\\n            }\\n        }\\n    }\\n\\n    return true\\n}\\n\\n```\\n\\n```\\nclass Solution {\\n    fun isValid(s: String): Boolean {\\n    val stack = ArrayDeque<Char>()\\n    s.forEach {\\n        when(it) {\\n            \\'(\\', \\'[\\', \\'{\\' -> stack.push(it)\\n            \\')\\' -> if (stack.poll() != \\'(\\') return false\\n            \\'}\\' -> if (stack.poll() != \\'{\\') return false\\n            \\']\\' -> if (stack.poll() != \\'[\\') return false\\n            }\\n        }\\n    \\n        return stack.isEmpty()\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 13.17MB*** (beats 79.34% / 99.92%).\\n* *** Swift ***\\n\\n\\n```\\n\\nclass Solution {\\n    func isValid(_ s: String) -> Bool {\\n        \\n        guard s.count % 2 == 0 else { return false }\\n        \\n        var stack: [Character] = []\\n        \\n        for ch in s {\\n            switch ch {\\n            case \"(\": stack.append(\")\")\\n            case \"[\": stack.append(\"]\")\\n            case \"{\": stack.append(\"}\")\\n            default:\\n                if stack.isEmpty || stack.removeLast() != ch {\\n                    return false\\n                }\\n            }\\n        }\\n        \\n        return stack.isEmpty\\n    }\\n}\\n\\n```\\n\\n```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the s.\\n    //   - space: O(n), where n is the length of the s.\\n    \\n    func isValid(_ s: String) -> Bool {\\n        var stack = [Character]()        \\n        let dict: [Character: Character] = [\"(\": \")\", \"{\": \"}\", \"[\": \"]\"]\\n        \\n        for char in s {\\n            switch char {\\n            case \"(\", \"{\", \"[\": stack.append(char)\\n            case \")\", \"}\", \"]\": guard !stack.isEmpty, dict[stack.removeLast()] == char else { return false }\\n            default: return false\\n            }\\n        }\\n        return stack.isEmpty\\n    }\\n\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 62.07MB*** (beats 99.99% / 99.99%).\\n* *** PHP ***\\n\\n\\nThis solution uses functionality like stack to solve the problem . As stack is LIFO structure so if for each open parenthesis such as ( OR { OR [ we have to insert corresponding closing parenthesis ) OR } OR ] .\\n\\nSo each time we iterate and get an open parenthesis we push the closing parenthesis and if we encounter a closing parenthesis we check and pop depending on the comparison .We can first ignore the ones which are of off length . At the enf of the program we have to check if the stack is empty or not . if not it\\'s false . Vice versa .\\n\\n```\\n\\nclass Solution {\\n\\n    /**\\n     * @param String $s\\n     * @return Boolean\\n     */\\n    function isValid($s) {\\n        if(strlen($s)%2!=0){\\n            return false;\\n        }\\n        \\n        $process_arr = array();\\n        $s_arr = str_split($s);\\n        foreach($s_arr as $i){\\n            switch($i){\\n                case \\'(\\':\\n                    array_push($process_arr,\\')\\');\\n                    break;\\n                case \\'{\\':\\n                    array_push($process_arr,\\'}\\');\\n                    break;\\n                case \\'[\\':\\n                    array_push($process_arr,\\']\\');\\n                    break;\\n                default:\\n                    if(empty($process_arr) || $i != $process_arr[count($process_arr)-1]){\\n                        return false;\\n                    }else{\\n                        array_pop($process_arr);\\n                    }\\n                    break;\\n                \\n            }\\n        }\\n        \\n        return count($process_arr)==0;\\n        \\n    }\\n}\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 1.17MB*** (beats 99.64% / 99.92%).\\n* *** C ***\\n\\n\\n```\\n\\nbool isValid(char *s) {\\n\\n    char *q=s;\\n    \\n    for (char *p=s; *p; p++) \\n        switch(*p) {\\n            case \\'(\\': *q++ = \\')\\'; continue;\\n            case \\'{\\': *q++ = \\'}\\'; continue;\\n            case \\'[\\': *q++ = \\']\\'; continue;\\n            default: if (q==s || *p != *--q) return false;\\n        }\\n    \\n    return q==s;\\n}\\n\\n```\\n\\n```\\n     Stack<Character> stack = new Stack<>();\\n    if(s.length()%2 != 0)\\n        return false;\\n    for(int i = 0;i<s.length();i++){\\n        if(s.charAt(i) == \\'(\\' || s.charAt(i) == \\'{\\' || s.charAt(i) == \\'[\\')\\n            stack.push(s.charAt(i));\\n        else if(stack.size() > 0 && s.charAt(i) == \\')\\' && stack.peek() == \\'(\\')\\n            stack.pop();\\n        else if(stack.size() > 0 && s.charAt(i) == \\'}\\' && stack.peek() == \\'{\\')\\n            stack.pop();\\n        else if(stack.size() > 0 && s.charAt(i) == \\']\\' && stack.peek() == \\'[\\')\\n            stack.pop();\\n        else \\n            return false;\\n    }\\n    return stack.size() == 0;\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin",
                    "PHP"
                ],
                "code": "```\\n```\n```\\n\\npublic class Solution {\\n    public boolean isValid(String s) {\\n        int length;\\n    \\n        do {\\n            length = s.length();\\n            s = s.replace(\"()\", \"\").replace(\"{}\", \"\").replace(\"[]\", \"\");\\n        } while(length != s.length());\\n    \\n        return s.length() == 0;\\n    }\\n}\\n\\n```\n```\\n```\n```\\n```\n```\\n\\nclass Solution(object):\\n\\tdef isValid(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        d = {\\'(\\':\\')\\', \\'{\\':\\'}\\',\\'[\\':\\']\\'}\\n        stack = []\\n        for i in s:\\n            if i in d:  # 1\\n                stack.append(i)\\n            elif len(stack) == 0 or d[stack.pop()] != i:  # 2\\n                return False\\n        return len(stack) == 0 # 3\\n\\t\\n# 1. if it\\'s the left bracket then we append it to the stack\\n# 2. else if it\\'s the right bracket and the stack is empty(meaning no matching left bracket), or the left bracket doesn\\'t match\\n# 3. finally check if the stack still contains unmatched left bracket\\n\\n```\n```\\n```\n```\\n```\n```\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;  //taking stack for keep tracking the order of the brackets..\\n        for(auto i:s)  //iterate over each and every elements\\n        {\\n            if(i==\\'(\\' or i==\\'{\\' or i==\\'[\\') st.push(i);  //if current element of the string will be opening bracket then we will just simply push it into the stack\\n            else  //if control comes to else part, it means that current element is a closing bracket, so check two conditions  current element matches with top of the stack and the stack must not be empty...\\n            {\\n                if(st.empty() or (st.top()==\\'(\\' and i!=\\')\\') or (st.top()==\\'{\\' and i!=\\'}\\') or (st.top()==\\'[\\' and i!=\\']\\')) return false;\\n                st.pop();  //if control reaches to that line, it means we have got the right pair of brackets, so just pop it.\\n            }\\n        }\\n        return st.empty();  //at last, it may possible that we left something into the stack unpair so return checking stack is empty or not..\\n    }\\n};\\n\\n```\n```\\n```\n```\\n```\n```\\n\\nvar isValid = function(s) {   \\n    const stack = [];\\n    \\n    for (let i = 0 ; i < s.length ; i++) {\\n        let c = s.charAt(i);\\n        switch(c) {\\n            case \\'(\\': stack.push(\\')\\');\\n                break;\\n            case \\'[\\': stack.push(\\']\\');\\n                break;\\n            case \\'{\\': stack.push(\\'}\\');\\n                break;\\n            default:\\n                if (c !== stack.pop()) {\\n                    return false;\\n                }\\n        }\\n    }\\n    \\n    return stack.length === 0;\\n};\\n\\n```\n```\\n```\n```\\n```\n```\\n\\n    def isValid(self, s: str) -> bool:\\n        dic = {\\'(\\':1 , \\')\\':2 , \\'[\\':3 , \\']\\':6 , \\'{\\':5 , \\'}\\':10}\\n        res = []\\n        for one in s:\\n            temp = dic[one]\\n            if(temp %2 ):\\n                res.append(temp)\\n            else:\\n                if(len(res) and res[-1]==temp//2):\\n                    del res[-1]\\n                else:\\n                    return False\\n        return res==[]\\n\\n```\n```\\n```\n```\\n```\n```\\n\\nfun main() {\\n    \"(){}\".isValidParentheses().apply(::println) // true\\n    \"(){\".isValidParentheses().apply(::println) // false\\n    \"(){}[](){}()\".isValidParentheses().apply(::println) // true\\n    \"(){}[](){}()]\".isValidParentheses().apply(::println) // false\\n}\\n\\nfun String.isValidParentheses(): Boolean {\\n    val p = \\'(\\' to \\')\\'\\n    val b = \\'[\\' to \\']\\'\\n    val k = \\'{\\' to \\'}\\'\\n\\n    for ((index, value) in withIndex()) {\\n        if (index % 2 == 0) {\\n            val nextChar = getOrNull(index + 1)\\n            if (!when (value) {\\n                    p.first -> p.second == nextChar\\n                    b.first -> b.second == nextChar\\n                    k.first -> k.second == nextChar\\n                    else -> false\\n                }\\n            ) {\\n                return false\\n            }\\n        }\\n    }\\n\\n    return true\\n}\\n\\n```\n```\\nclass Solution {\\n    fun isValid(s: String): Boolean {\\n    val stack = ArrayDeque<Char>()\\n    s.forEach {\\n        when(it) {\\n            \\'(\\', \\'[\\', \\'{\\' -> stack.push(it)\\n            \\')\\' -> if (stack.poll() != \\'(\\') return false\\n            \\'}\\' -> if (stack.poll() != \\'{\\') return false\\n            \\']\\' -> if (stack.poll() != \\'[\\') return false\\n            }\\n        }\\n    \\n        return stack.isEmpty()\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\n\\nclass Solution {\\n    func isValid(_ s: String) -> Bool {\\n        \\n        guard s.count % 2 == 0 else { return false }\\n        \\n        var stack: [Character] = []\\n        \\n        for ch in s {\\n            switch ch {\\n            case \"(\": stack.append(\")\")\\n            case \"[\": stack.append(\"]\")\\n            case \"{\": stack.append(\"}\")\\n            default:\\n                if stack.isEmpty || stack.removeLast() != ch {\\n                    return false\\n                }\\n            }\\n        }\\n        \\n        return stack.isEmpty\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the s.\\n    //   - space: O(n), where n is the length of the s.\\n    \\n    func isValid(_ s: String) -> Bool {\\n        var stack = [Character]()        \\n        let dict: [Character: Character] = [\"(\": \")\", \"{\": \"}\", \"[\": \"]\"]\\n        \\n        for char in s {\\n            switch char {\\n            case \"(\", \"{\", \"[\": stack.append(char)\\n            case \")\", \"}\", \"]\": guard !stack.isEmpty, dict[stack.removeLast()] == char else { return false }\\n            default: return false\\n            }\\n        }\\n        return stack.isEmpty\\n    }\\n\\n}\\n```\n```\\n```\n```\\n```\n```\\n\\nclass Solution {\\n\\n    /**\\n     * @param String $s\\n     * @return Boolean\\n     */\\n    function isValid($s) {\\n        if(strlen($s)%2!=0){\\n            return false;\\n        }\\n        \\n        $process_arr = array();\\n        $s_arr = str_split($s);\\n        foreach($s_arr as $i){\\n            switch($i){\\n                case \\'(\\':\\n                    array_push($process_arr,\\')\\');\\n                    break;\\n                case \\'{\\':\\n                    array_push($process_arr,\\'}\\');\\n                    break;\\n                case \\'[\\':\\n                    array_push($process_arr,\\']\\');\\n                    break;\\n                default:\\n                    if(empty($process_arr) || $i != $process_arr[count($process_arr)-1]){\\n                        return false;\\n                    }else{\\n                        array_pop($process_arr);\\n                    }\\n                    break;\\n                \\n            }\\n        }\\n        \\n        return count($process_arr)==0;\\n        \\n    }\\n}\\n\\n```\n```\\n```\n```\\n```\n```\\n\\nbool isValid(char *s) {\\n\\n    char *q=s;\\n    \\n    for (char *p=s; *p; p++) \\n        switch(*p) {\\n            case \\'(\\': *q++ = \\')\\'; continue;\\n            case \\'{\\': *q++ = \\'}\\'; continue;\\n            case \\'[\\': *q++ = \\']\\'; continue;\\n            default: if (q==s || *p != *--q) return false;\\n        }\\n    \\n    return q==s;\\n}\\n\\n```\n```\\n     Stack<Character> stack = new Stack<>();\\n    if(s.length()%2 != 0)\\n        return false;\\n    for(int i = 0;i<s.length();i++){\\n        if(s.charAt(i) == \\'(\\' || s.charAt(i) == \\'{\\' || s.charAt(i) == \\'[\\')\\n            stack.push(s.charAt(i));\\n        else if(stack.size() > 0 && s.charAt(i) == \\')\\' && stack.peek() == \\'(\\')\\n            stack.pop();\\n        else if(stack.size() > 0 && s.charAt(i) == \\'}\\' && stack.peek() == \\'{\\')\\n            stack.pop();\\n        else if(stack.size() > 0 && s.charAt(i) == \\']\\' && stack.peek() == \\'[\\')\\n            stack.pop();\\n        else \\n            return false;\\n    }\\n    return stack.size() == 0;\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1805568,
                "title": "python-3-why-use-stack",
                "content": "***Suggestions to make it better are always welcomed.***\\n\\n**Question**: What data structure we should use here?\\n**Answer:** We have solved this problem in past and already know the right DS to use.\\n**Thoughts**: See below on how to explain in interview\\n\\nWhen we traverse the string, if we see open brace, then a closing brace should come in next iterations. This is correct but doesn\\'t tell the right DS to use because we can\\'t see in the future iterations in advance. So, think inversely.\\n\\nIf we see closing brace, there should have been an opening brace to pair with. This means, we want to look at past values in reverse order. Only stacks gives us the option to look in reverse.\\n\\nWe can either write recursive function, or write iterative function with a stack.\\n\\nPossible failures that we should consider when writing code:\\n1. We want to look at the top value in the stack. If stack is empty and we try to access the top value, we\\'ll get index out of bound exception. So, always check len(stack) > 0.\\n2. After the end of iteration, if we just return True, that will be an incorrect output for some inputs. Either we have found all the pairs or have unpaired braces still stored in the stack. So, check the length of the stack again and return True if stack is empty.\\n\\n**Iterative solution:**\\n\\n```\\ndef isValid(self, s: str) -> bool:\\n\\tpairs = {\\')\\':\\'(\\', \\n\\t\\t\\t \\']\\':\\'[\\', \\n\\t\\t\\t \\'}\\':\\'{\\'}\\n\\n\\tstack = []\\n\\tfor char in s:\\n\\t\\tif char in pairs and len(stack)>0:\\n\\t\\t\\topeningBrace = pairs[char]\\n\\t\\t\\tif stack[-1] != openingBrace:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tstack.pop()\\n\\t\\telse:\\n\\t\\t\\tstack.append(char)\\n\\n\\treturn len(stack)==0\\n```\\n\\n**I hope that you\\'ve found this useful.\\nIn that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**",
                "solutionTags": [
                    "Python3",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\ndef isValid(self, s: str) -> bool:\\n\\tpairs = {\\')\\':\\'(\\', \\n\\t\\t\\t \\']\\':\\'[\\', \\n\\t\\t\\t \\'}\\':\\'{\\'}\\n\\n\\tstack = []\\n\\tfor char in s:\\n\\t\\tif char in pairs and len(stack)>0:\\n\\t\\t\\topeningBrace = pairs[char]\\n\\t\\t\\tif stack[-1] != openingBrace:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tstack.pop()\\n\\t\\telse:\\n\\t\\t\\tstack.append(char)\\n\\n\\treturn len(stack)==0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1512374,
                "title": "javascript-solution",
                "content": "```\\nvar isValid = function(s) {\\n    if (s.length <=1) return false\\n    \\n    let stack = []\\n    let hash = {\\n        \\'(\\' : \\')\\',\\n        \\'[\\' : \\']\\',\\n        \\'{\\' : \\'}\\'\\n    }\\n    \\n    for(let i = 0; i < s.length; i++){\\n        if (hash[s[i]]) stack.push(hash[s[i]])\\n        else if (s[i] !== stack.pop()) return false\\n    }\\n    return !stack.length\\n};\\n\\n// Runtime: 60 ms, faster than 99.58% of JavaScript online submissions for Valid Parentheses.\\n// Memory Usage: 39 MB, less than 69.89% of JavaScript online submissions for Valid Parentheses.\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isValid = function(s) {\\n    if (s.length <=1) return false\\n    \\n    let stack = []\\n    let hash = {\\n        \\'(\\' : \\')\\',\\n        \\'[\\' : \\']\\',\\n        \\'{\\' : \\'}\\'\\n    }\\n    \\n    for(let i = 0; i < s.length; i++){\\n        if (hash[s[i]]) stack.push(hash[s[i]])\\n        else if (s[i] !== stack.pop()) return false\\n    }\\n    return !stack.length\\n};\\n\\n// Runtime: 60 ms, faster than 99.58% of JavaScript online submissions for Valid Parentheses.\\n// Memory Usage: 39 MB, less than 69.89% of JavaScript online submissions for Valid Parentheses.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1494586,
                "title": "python3-solution-faster-than-99-36",
                "content": "\\tclass Solution:\\n\\t\\tdef isValid(self, s: str) -> bool:\\n\\t\\t\\tstack = []\\n\\t\\t\\tlookup = {\"(\":\")\",\"{\":\"}\",\"[\":\"]\"}\\n\\t\\t\\tfor i in s:\\n\\t\\t\\t\\tif i in lookup:\\n\\t\\t\\t\\t\\tstack.append(i)\\n\\t\\t\\t\\telif len(stack) == 0 or lookup[stack.pop()] != i:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\treturn len(stack) == 0\\n",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef isValid(self, s: str) -> bool:\\n\\t\\t\\tstack = []\\n\\t\\t\\tlookup = {\"(\":\")\",\"{\":\"}",
                "codeTag": "Java"
            },
            {
                "id": 1013295,
                "title": "easy-swift",
                "content": "```\\nclass Solution {\\n    func isValid(_ s: String) -> Bool {\\n        if s.count % 2 != 0 { return false }\\n        var stack: [Character] = []\\n        for bracket in s {\\n            switch bracket {\\n               case \"(\":\\n                    stack.append(\")\")\\n                case \"[\":\\n                    stack.append(\"]\")\\n                case \"{\":\\n                    stack.append(\"}\")\\n                default:\\n                    if stack.isEmpty || stack.removeLast() != bracket {\\n                        return false\\n                    }\\n            }\\n        }\\n        return stack.isEmpty\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isValid(_ s: String) -> Bool {\\n        if s.count % 2 != 0 { return false }\\n        var stack: [Character] = []\\n        for bracket in s {\\n            switch bracket {\\n               case \"(\":\\n                    stack.append(\")\")\\n                case \"[\":\\n                    stack.append(\"]\")\\n                case \"{\":\\n                    stack.append(\"}\")\\n                default:\\n                    if stack.isEmpty || stack.removeLast() != bracket {\\n                        return false\\n                    }\\n            }\\n        }\\n        return stack.isEmpty\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 662494,
                "title": "c-cleanest-parentheses-checker-using-stack-0-ms-6-5-mb-beats-100-time-and-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> stk;\\n        unordered_map<char, char> match{{\\'(\\', \\')\\'}, {\\'{\\', \\'}\\'}, {\\'[\\', \\']\\'}};\\n\\n        for(char c: s) {\\n            if(c == \\'(\\' || c == \\'{\\' || c == \\'[\\')    stk.push(c);\\n            else {\\n                if(stk.empty())   return false;\\n\\n                if(match[stk.top()] == c)     stk.pop();\\n                else    return false;\\n            }\\n        }\\n        return stk.empty();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> stk;\\n        unordered_map<char, char> match{{\\'(\\', \\')\\'}, {\\'{\\', \\'}\\'}, {\\'[\\', \\']\\'}};\\n\\n        for(char c: s) {\\n            if(c == \\'(\\' || c == \\'{\\' || c == \\'[\\')    stk.push(c);\\n            else {\\n                if(stk.empty())   return false;\\n\\n                if(match[stk.top()] == c)     stk.pop();\\n                else    return false;\\n            }\\n        }\\n        return stk.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340957,
                "title": "cpp-simple-solution-faster-than-100-submissions",
                "content": "Simple solution using stack, push when we see a character related to opening of parantheses, pop when we see a corresponding closing parantheses.\\n\\nHope this helps! Comment if you have any questions or queries, and I\\'ll try to help you out\\n\\n\\tclass Solution {\\n\\tpublic:\\n    bool isValid(string s) \\n    {\\n        if(s.empty())\\n            return true;\\n        \\n        stack<char> st;\\n        \\n        for(char c:s)\\n        {\\n            if(c == \\'(\\' || c == \\'{\\' || c == \\'[\\')\\n            {\\n                st.push(c);\\n            }\\n            else\\n            {\\n                if(st.empty()) return false;\\n                if(c == \\']\\' && st.top()!= \\'[\\') return false;\\n                if(c == \\'}\\' && st.top()!= \\'{\\') return false;\\n                if(c == \\')\\' && st.top()!= \\'(\\') return false;\\n                \\n                st.pop();\\n            }\\n        }\\n            \\n        return st.empty();\\n    }\\n\\t};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    bool isValid(string s) \\n    {\\n        if(s.empty())\\n            return true;\\n        \\n        stack<char> st;\\n        \\n        for(char c:s)\\n        {\\n            if(c == \\'(\\' || c == \\'{\\' || c == \\'[\\')\\n            {\\n                st.push(c);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 9481,
                "title": "java-concise-stack-solution",
                "content": "        \\n    public boolean isValid(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        String left = \"([{\";\\n        String right = \")]}\";\\n        for (char c: s.toCharArray()) {\\n            if (left.indexOf(c) > -1) \\n                stack.push(c);\\n            else if (stack.empty() || left.indexOf(stack.pop()) != right.indexOf(c))\\n                return false;\\n        }\\n        return stack.empty();",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "        \\n    public boolean isValid(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        String left = \"([{\";\\n        String right = \")]}\";\\n        for (char c: s.toCharArray()) {\\n            if (left.indexOf(c) > -1) \\n                stack.push(c);\\n            else if (stack.empty() || left.indexOf(stack.pop()) != right.indexOf(c))\\n                return false;\\n        }\\n        return stack.empty();",
                "codeTag": "Unknown"
            },
            {
                "id": 9563,
                "title": "easy-to-understand-javascript-code-with-stack-and-hashmap",
                "content": "    /**\\n     * @param {string} s\\n     * @return {boolean}\\n     */\\n    var isValid = function(s) {\\n        var temp = [];\\n        var map = {\\n            '(' : ')',\\n            '{' : '}',\\n            '[' : ']'\\n        };\\n        \\n        for(var i = 0; i < s.length; i++){\\n            if(s[i] === '(' || s[i] === '{' || s[i] === '[')\\n                temp.push(s[i]);\\n            else if(map[temp.pop()] !== s[i]){\\n                return false;\\n            }\\n        }\\n        \\n        if(temp.length > 0)\\n            return false;\\n        else\\n            return true;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    /**\\n     * @param {string} s\\n     * @return {boolean}\\n     */\\n    var isValid = function(s) {\\n        var temp = [];\\n        var map = {\\n            '(' : ')',\\n            '{' : '}',\\n            '[' : ']'\\n        };\\n        \\n        for(var i = 0; i < s.length; i++){\\n            if(s[i] === '(' || s[i] === '{' || s[i] === '[')\\n                temp.push(s[i]);\\n            else if(map[temp.pop()] !== s[i]){\\n                return false;\\n            }\\n        }\\n        \\n        if(temp.length > 0)\\n            return false;\\n        else\\n            return true;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3849151,
                "title": "easiest-approach-in-c",
                "content": "# Approach\\nSimply Map Each Character To its corresponding Bracket and then Use stack To implement the logic.\\n\\n<iframe src=\"https://leetcode.com/playground/6EdBuncU/shared\" frameBorder=\"0\" width=\"650\" height=\"428\"></iframe>\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "# Approach\\nSimply Map Each Character To its corresponding Bracket and then Use stack To implement the logic.\\n\\n<iframe src=\"https://leetcode.com/playground/6EdBuncU/shared\" frameBorder=\"0\" width=\"650\" height=\"428\"></iframe>\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3401676,
                "title": "typescript-fully-explained-solution-99-96-beats",
                "content": "# Introduction\\nI use a stack algorithm, which implies the concept of \"Last in, first out\"\\n\\n# Explanation\\n\\nWe go through the string and if we see that the bracket is an opening one, we add it to the stack, because any matching string must start with an opening bracket. We do this until we find a closing parenthesis.\\n\\n```\\nif ([\\'(\\', \\'[\\', \\'{\\'].includes(currentBracket)) {\\n        openBracketsStack.push(currentBracket)\\n}\\n```\\n\\nWhen we meet a closing parenthesis, the most interesting thing happens. Watch my hands. Since every open parenthesis must have a closing parenthesis, this means that the last parenthesis we meet must have a closing parenthesis, and so on. That is, we are sort of \"opening from the middle of parentheses. \\n\\nSo, we remove the last opening bracket from our stack and take the value for the closing bracket from our \"bracketsMap\", then compare our values and if they are not equal, it means that the string is not suitable for us anymore and return false\\n\\n```\\nelse if (openBracketsStack.pop() !== bracketsMap[currentBracket]) {\\n            return false\\n}\\n```\\n\\nWhen we get to the end of the string, and everything is successful, we return \"is the length of the stack equal to zero\". This happens because there can only be opening parentheses in the string, and then we have to return false, if the string fits, then the stack length will be 0, because every time we compare, we pull the last opening parenthesis out of the stack.\\n\\n```\\nreturn !openBracketsStack.length\\n```\\n\\n# Code\\n```\\nfunction isValid(s: string): boolean {\\n\\n    const bracketsMap = {\\n        \\')\\': \\'(\\',\\n        \\']\\': \\'[\\',\\n        \\'}\\': \\'{\\'\\n    }\\n\\n    let openBracketsStack = []\\n\\n    for (let i = 0; i < s.length; i++) {\\n        const currentBracket = s[i]\\n\\n        if ([\\'(\\', \\'[\\', \\'{\\'].includes(currentBracket)) {\\n            openBracketsStack.push(currentBracket)\\n        } else if (openBracketsStack.pop() !== bracketsMap[currentBracket]) {\\n            return false\\n        }\\n    }\\n    return !openBracketsStack.length\\n};\\n```\\n\\n# Ending\\nIf there are still questions, you can ask in the comments, I hope it was clear, thank you!",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nif ([\\'(\\', \\'[\\', \\'{\\'].includes(currentBracket)) {\\n        openBracketsStack.push(currentBracket)\\n}\\n```\n```\\nelse if (openBracketsStack.pop() !== bracketsMap[currentBracket]) {\\n            return false\\n}\\n```\n```\\nreturn !openBracketsStack.length\\n```\n```\\nfunction isValid(s: string): boolean {\\n\\n    const bracketsMap = {\\n        \\')\\': \\'(\\',\\n        \\']\\': \\'[\\',\\n        \\'}\\': \\'{\\'\\n    }\\n\\n    let openBracketsStack = []\\n\\n    for (let i = 0; i < s.length; i++) {\\n        const currentBracket = s[i]\\n\\n        if ([\\'(\\', \\'[\\', \\'{\\'].includes(currentBracket)) {\\n            openBracketsStack.push(currentBracket)\\n        } else if (openBracketsStack.pop() !== bracketsMap[currentBracket]) {\\n            return false\\n        }\\n    }\\n    return !openBracketsStack.length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3400874,
                "title": "c-no-extra-stack-space-o-1-sc-fast-0ms",
                "content": "**TODO(heder): Insert cute cat meme to ask for up-votes. ;)**\\n\\n# Approach 1: no extra stack\\n**NB: This approach is not recommended. It\\'s just for fun.**\\n\\nIf we are willing to rewrite the input we can solve this problem w/o extra memory, because we can use the beginning of the string as a \"stack\".\\n\\n```cpp\\n    static bool isValid(string& s) {\\n        char* p = s.data();\\n        for (char ch : s) {\\n            switch (ch) {\\n                case \\'(\\':\\n                    *p++ = \\')\\';\\n                    break;\\n                case \\'[\\':\\n                    *p++ = \\']\\';\\n                    break;\\n                case \\'{\\':\\n                    *p++ = \\'}\\';\\n                    break;\\n                default:\\n                    if (p == s.data()) return false;\\n                    \\n                    if (*--p != ch) return false;\\n                    break;\\n            }\\n        }\\n        return p == s.data();\\n    }\\n```\\n\\n**Complexity Analysis**\\nLet $$n$$ be the lenght of the input string then the\\n  * Time complexity is $$O(n)$$ as we need to look at each character and\\n  * Space complexity is $$O(1)$$ as we are not using any extra space.\\n\\n**Pro-Tips**\\n\\nI always have a header like this in my solutions. This speeds-up I/O:\\n\\n```cpp\\n// https://leetcode.com/problems/valid-parentheses/\\n// problem: 20\\nstatic int fast_io = []() { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0; }();\\n```\\n\\nWe could also use the following attribute for the function to speed things up:\\n\\n```cpp\\n    __attribute__((no_sanitize(\"address\")))\\n```\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```cpp\\n    static bool isValid(string& s) {\\n        char* p = s.data();\\n        for (char ch : s) {\\n            switch (ch) {\\n                case \\'(\\':\\n                    *p++ = \\')\\';\\n                    break;\\n                case \\'[\\':\\n                    *p++ = \\']\\';\\n                    break;\\n                case \\'{\\':\\n                    *p++ = \\'}\\';\\n                    break;\\n                default:\\n                    if (p == s.data()) return false;\\n                    \\n                    if (*--p != ch) return false;\\n                    break;\\n            }\\n        }\\n        return p == s.data();\\n    }\\n```\n```cpp\\n// https://leetcode.com/problems/valid-parentheses/\\n// problem: 20\\nstatic int fast_io = []() { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0; }();\\n```\n```cpp\\n    __attribute__((no_sanitize(\"address\")))\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2910499,
                "title": "easiest-faang-method-ever",
                "content": "\\n### **\\uD83D\\uDCA1 1 Imp. thing to keep in mind is :-**\\n```\\n{()[]} - Valid string\\n{(}[]) - Invalid string\\n[)(] - Invalid string\\n[]()$@{} - Invalid string \\n```\\n# \\uD83D\\uDCA5Complexity :-\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# \\uD83D\\uDCA5Code : Very Easy Beginnering Friendly Solution :)\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n       if(s.size()%2!=0)\\n         return 0;\\n         stack<int> st;\\n       for(int i=0;i<s.size();i++){\\n          if(s[i]==\\'(\\' || s[i]==\\'{\\' || s[i]==\\'[\\')\\n             st.push(s[i]);\\n          else if(s[i]==\\')\\' || s[i]==\\']\\' || s[i]==\\'}\\')\\n              if(st.empty()==false){\\n                  if(st.top()==\\'{\\' && s[i]==\\'}\\')\\n                     st.pop();\\n                  else if(st.top()==\\'(\\' && s[i]==\\')\\')   \\n                     st.pop();\\n                  else if(st.top()==\\'[\\' && s[i]==\\']\\')\\n                     st.pop();\\n                  else\\n                     return 0;    \\n              }\\n          else\\n             return 0;                 \\n       }\\n       if(st.empty())\\n          return 1;\\n       else\\n          return 0;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "String",
                    "Stack"
                ],
                "code": "```\\n{()[]} - Valid string\\n{(}[]) - Invalid string\\n[)(] - Invalid string\\n[]()$@{} - Invalid string \\n```\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n       if(s.size()%2!=0)\\n         return 0;\\n         stack<int> st;\\n       for(int i=0;i<s.size();i++){\\n          if(s[i]==\\'(\\' || s[i]==\\'{\\' || s[i]==\\'[\\')\\n             st.push(s[i]);\\n          else if(s[i]==\\')\\' || s[i]==\\']\\' || s[i]==\\'}\\')\\n              if(st.empty()==false){\\n                  if(st.top()==\\'{\\' && s[i]==\\'}\\')\\n                     st.pop();\\n                  else if(st.top()==\\'(\\' && s[i]==\\')\\')   \\n                     st.pop();\\n                  else if(st.top()==\\'[\\' && s[i]==\\']\\')\\n                     st.pop();\\n                  else\\n                     return 0;    \\n              }\\n          else\\n             return 0;                 \\n       }\\n       if(st.empty())\\n          return 1;\\n       else\\n          return 0;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2732537,
                "title": "very-intuitive-unordered-map-solution-properly-commented-easy-to-understand",
                "content": "// PLEASE DO UPVOTE IF THIS SOLUTION HELPS YOU :)\\n\\nclass Solution {\\npublic:\\n    \\n    // mapping each opening and closing bracket with int opposite in sign for ease check\\n    unordered_map<char,int> symbols = {{\\'(\\',-1},{\\'{\\',-2},{\\'[\\',-3},{\\']\\',3},{\\'}\\',2},{\\')\\',1}};\\n    \\n    bool isValid(string s) {\\n        // if string\\'s size is odd\\n        if(s.size() & 1) return false;\\n        \\n        // stack to store open brackets\\n        stack<char> st;\\n        // traversing string\\n        for (char bracket: s){\\n            // => we got open bracket\\n            if (symbols[bracket] < 0){\\n                st.push(bracket);\\n            }\\n            // => we got close bracket\\n            else\\n            {\\n                // CASE 1 : if we\\'ve closed bracket but no open bracket in stack\\n                if (st.empty()) return false;\\n                // CASE 2 : else than case 1\\n                // storing top char from stack in a variable named top\\n                char top = st.top();\\n                // after retrieving top element from stack, remove it from stack\\n                st.pop();\\n                // check if sum equals 0 for valid pair\\n                if (symbols[top] + symbols[bracket] != 0){\\n                    return false;\\n                }\\n            }\\n        }\\n        // after checking for each char of stack if it\\'s not empty => we\\'ve extra opening\\n        //      bracket, so we return false;\\n        if (!st.empty()) return false;\\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    // mapping each opening and closing bracket with int opposite in sign for ease check\\n    unordered_map<char,int> symbols = {{\\'(\\',-1}",
                "codeTag": "Java"
            },
            {
                "id": 2210991,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        if(s.length()%2==1){\\n            return false;\\n        }\\n        int check = 0;\\n        while(s.length()>0){\\n            check = s.length();\\n            s=s.replace(\"()\", \"\");\\n            s=s.replace(\"[]\", \"\");\\n            s=s.replace(\"{}\", \"\");\\n            if(check == s.length()){\\n                return false;\\n            }\\n        }\\n        return true;\\n            \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        if(s.length()%2==1){\\n            return false;\\n        }\\n        int check = 0;\\n        while(s.length()>0){\\n            check = s.length();\\n            s=s.replace(\"()\", \"\");\\n            s=s.replace(\"[]\", \"\");\\n            s=s.replace(\"{}\", \"\");\\n            if(check == s.length()){\\n                return false;\\n            }\\n        }\\n        return true;\\n            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846080,
                "title": "0-ms-100-faster-very-simple-solution-c-easy-to-understand",
                "content": "**PLEASE UPVOTE IF IT HELPS YOU**\\n```\\n bool isValid(string s) {\\n        stack<int> c;\\n        if(s[0]==\\')\\' || s[0]==\\']\\' || s[0]==\\'}\\')\\n             return false;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\' || s[i]==\\'[\\'  || s[i]==\\'{\\')\\n            {\\n                c.push(s[i]);\\n            }\\n            else if(s[i]==\\')\\')\\n                {\\n                    if(c.size()==0 || c.top()!=\\'(\\')\\n                        return false;\\n                    else if(c.top()==\\'(\\')\\n                    {\\n                        c.pop();\\n                        continue;\\n                    }\\n                }\\n          else if(s[i]==\\']\\')\\n                {\\n                    if(c.size()==0 || c.top()!=\\'[\\')\\n                        return false;\\n                    else if(c.top()==\\'[\\')\\n                    {\\n                        c.pop();\\n                        continue;\\n                    }\\n                }\\n              else if(s[i]==\\'}\\')\\n                {\\n                    if(c.size()==0 || c.top()!=\\'{\\')\\n                        return false;\\n                    else if(c.top()==\\'{\\')\\n                    {\\n                        c.pop();\\n                        continue;\\n                    }\\n                }\\n        }\\n        if(c.size()==0)\\n            return true;\\n        else\\n           return false;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n bool isValid(string s) {\\n        stack<int> c;\\n        if(s[0]==\\')\\' || s[0]==\\']\\' || s[0]==\\'}\\')\\n             return false;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\' || s[i]==\\'[\\'  || s[i]==\\'{\\')\\n            {\\n                c.push(s[i]);\\n            }\\n            else if(s[i]==\\')\\')\\n                {\\n                    if(c.size()==0 || c.top()!=\\'(\\')\\n                        return false;\\n                    else if(c.top()==\\'(\\')\\n                    {\\n                        c.pop();\\n                        continue;\\n                    }\\n                }\\n          else if(s[i]==\\']\\')\\n                {\\n                    if(c.size()==0 || c.top()!=\\'[\\')\\n                        return false;\\n                    else if(c.top()==\\'[\\')\\n                    {\\n                        c.pop();\\n                        continue;\\n                    }\\n                }\\n              else if(s[i]==\\'}\\')\\n                {\\n                    if(c.size()==0 || c.top()!=\\'{\\')\\n                        return false;\\n                    else if(c.top()==\\'{\\')\\n                    {\\n                        c.pop();\\n                        continue;\\n                    }\\n                }\\n        }\\n        if(c.size()==0)\\n            return true;\\n        else\\n           return false;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1757824,
                "title": "java-code",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for(int i = 0 ; i < s.length(); i++){\\n           \\n            char a = s.charAt(i);\\n            \\n            // if opening bracket, stack push\\n            // if close bracker, stacktop check and push\\n            \\n            if(a == \\'(\\' || a == \\'{\\' || a == \\'[\\'){\\n                stack.push(a);\\n            }\\n            else if(stack.empty()) return false;\\n            else if(a == \\')\\' && stack.pop() != \\'(\\') return false;\\n            else if(a == \\']\\' && stack.pop() != \\'[\\') return false;\\n            else if(a == \\'}\\' && stack.pop() != \\'{\\') return false;\\n        }\\n        return stack.empty();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for(int i = 0 ; i < s.length(); i++){\\n           \\n            char a = s.charAt(i);\\n            \\n            // if opening bracket, stack push\\n            // if close bracker, stacktop check and push\\n            \\n            if(a == \\'(\\' || a == \\'{\\' || a == \\'[\\'){\\n                stack.push(a);\\n            }\\n            else if(stack.empty()) return false;\\n            else if(a == \\')\\' && stack.pop() != \\'(\\') return false;\\n            else if(a == \\']\\' && stack.pop() != \\'[\\') return false;\\n            else if(a == \\'}\\' && stack.pop() != \\'{\\') return false;\\n        }\\n        return stack.empty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665841,
                "title": "i-don-t-what-is-wrong-in-this",
                "content": "class Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        for(int i =0;i<s.length();i++){\\n            if(s[i]==\\'(\\' || s[i]==\\'{\\' || s[i]==\\'[\\'){\\n                st.push(s[i]);\\n            }\\n            else{\\n                if(s[i]==\\')\\' and st.top()==\\'(\\'){\\n                    st.pop();\\n                    continue;\\n                }\\n                else if(s[i]==\\'}\\' and st.top()==\\'{\\'){\\n                    st.pop();\\n                    continue;\\n                }\\n                else if(s[i]==\\']\\' and st.top()==\\'[\\'){\\n                    st.pop();\\n                    continue;\\n                }\\n                else\\n                    return false;\\n            }\\n            \\n        }\\n        if(st.empty()==false)\\n            return false;\\n        return true;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        for(int i =0;i<s.length();i++){\\n            if(s[i]==\\'(\\' || s[i]==\\'{\\' || s[i]==\\'[\\'){\\n                st.push(s[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1583971,
                "title": "easy-c-solution-using-stack-optimal-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st; \\n        \\n        for(int i=0;i<s.size();i++){\\n            \\n            if(s[i]==\\'(\\' || s[i]==\\'[\\' || s[i]==\\'{\\')\\n                st.push(s[i]);  \\n            else{\\n                if(!st.empty() && ((s[i]==\\')\\' && st.top()==\\'(\\') || (s[i]==\\']\\' && st.top()==\\'[\\') || (s[i]==\\'}\\' && st.top()==\\'{\\') ))\\n                    st.pop();\\n                else\\n                    return false; \\n            }\\n        }\\n        \\n        if(st.empty())\\n            return true;\\n        \\n        return false;\\n    }\\n};\\n```\\nPlease upvote if you like the solution. Always open for queries",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st; \\n        \\n        for(int i=0;i<s.size();i++){\\n            \\n            if(s[i]==\\'(\\' || s[i]==\\'[\\' || s[i]==\\'{\\')\\n                st.push(s[i]);  \\n            else{\\n                if(!st.empty() && ((s[i]==\\')\\' && st.top()==\\'(\\') || (s[i]==\\']\\' && st.top()==\\'[\\') || (s[i]==\\'}\\' && st.top()==\\'{\\') ))\\n                    st.pop();\\n                else\\n                    return false; \\n            }\\n        }\\n        \\n        if(st.empty())\\n            return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1535849,
                "title": "javascript-regex-solution-goat",
                "content": "```\\nvar isValid = function(s) {\\n\\t//This regex will search if the string contains \"{}\" OR \"()\" OR \"{}\"\\n    const regex = /(\\\\{\\\\})|(\\\\[\\\\])|(\\\\(\\\\))/g;\\n\\t\\n\\t//Check if the string contains one of possible pairs\\n    while(s.match(regex)) {\\n\\t\\t// Replace all the pairs with an empty string\\n        s = s.replace(regex, \\'\\');\\n    };\\n\\t\\n\\t//The if string is empty, then were only valid pairs, so it is true.\\n\\t//if the string contains data (like \"{]\") then there was an invalid pair, so it is false\\n    return s === \\'\\'; \\n};\\n```\\n\\n```{{()}}[]([])```\\nthe regex with match the \"()\" and the 2 \"[]\"\\nthe replace will now give the string ```{{}}()```\\nthe regex will match with \"{}\" and \"()\"\\nthe replace will now give the string ```{}```\\nthe regex will match with \"{}\"\\nthe replace will now give the string \"\"\\nthe regex will not match and the loop ends\\nreturn if \"\" === \"\"\\n\\n```{] ```\\nther regex will not match\\nthe string left over is ```{] ```\\nreturn if \"{]\" === \"\"",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isValid = function(s) {\\n\\t//This regex will search if the string contains \"{}\" OR \"()\" OR \"{}\"\\n    const regex = /(\\\\{\\\\})|(\\\\[\\\\])|(\\\\(\\\\))/g;\\n\\t\\n\\t//Check if the string contains one of possible pairs\\n    while(s.match(regex)) {\\n\\t\\t// Replace all the pairs with an empty string\\n        s = s.replace(regex, \\'\\');\\n    };\\n\\t\\n\\t//The if string is empty, then were only valid pairs, so it is true.\\n\\t//if the string contains data (like \"{]\") then there was an invalid pair, so it is false\\n    return s === \\'\\'; \\n};\\n```\n```{{()}}[]([])```\n```{{}}()```\n```{}```\n```{] ```\n```{] ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1503526,
                "title": "python3-stack",
                "content": "\\n```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        mp = {\"(\": \")\", \"[\": \"]\", \"{\": \"}\"}\\n        stack = []\\n        for ch in s: \\n            if ch in mp: stack.append(ch) \\n            elif not stack or mp[stack.pop()] != ch: return False \\n        return not stack\\n```\\n\\nAdded Java solution\\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> stk = new Stack<>(); \\n        for (char ch : s.toCharArray()) {\\n            if (ch == \\'(\\') stk.push(\\')\\'); \\n            else if (ch == \\'[\\') stk.push(\\']\\'); \\n            else if (ch == \\'{\\') stk.push(\\'}\\'); \\n            else if (stk.empty() || stk.pop() != ch) return false; \\n        }\\n        return stk.empty(); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        mp = {\"(\": \")\", \"[\": \"]\", \"{\": \"}\"}\\n        stack = []\\n        for ch in s: \\n            if ch in mp: stack.append(ch) \\n            elif not stack or mp[stack.pop()] != ch: return False \\n        return not stack\\n```\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> stk = new Stack<>(); \\n        for (char ch : s.toCharArray()) {\\n            if (ch == \\'(\\') stk.push(\\')\\'); \\n            else if (ch == \\'[\\') stk.push(\\']\\'); \\n            else if (ch == \\'{\\') stk.push(\\'}\\'); \\n            else if (stk.empty() || stk.pop() != ch) return false; \\n        }\\n        return stk.empty(); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1268758,
                "title": "easy-algorithm-using-stack-python",
                "content": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        \\n        stack = []\\n        opening = \"({[\"\\n        closing = \")}]\"\\n        \\n        for char in s:\\n            if char in opening:\\n                stack.append(char)\\n            elif char in closing:\\n                if len(stack) == 0:\\n                    return False\\n                elif closing.index(char) != opening.index(stack.pop()):\\n                    return False \\n        \\n        return len(stack) == 0\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        \\n        stack = []\\n        opening = \"({[\"\\n        closing = \")}]\"\\n        \\n        for char in s:\\n            if char in opening:\\n                stack.append(char)\\n            elif char in closing:\\n                if len(stack) == 0:\\n                    return False\\n                elif closing.index(char) != opening.index(stack.pop()):\\n                    return False \\n        \\n        return len(stack) == 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 652024,
                "title": "python-3-solution-runtime-32-ms-just-5-line-code-easy-to-understand",
                "content": "class Solution:\\n    \\n    def isValid(self, s: str) -> bool:\\n        while(\\'()\\' in s or  \\'{}\\' in s or \\'[]\\' in s):\\n            s = s.replace(\\'()\\' , \\'\\')\\n            s = s.replace(\\'[]\\' , \\'\\')\\n            s = s.replace(\\'{}\\' , \\'\\')\\n                        \\n        if s != \\'\\' :\\n            return False\\n        else :\\n            return True\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    \\n    def isValid(self, s: str) -> bool:\\n        while(\\'()\\' in s or  \\'{}",
                "codeTag": "Java"
            },
            {
                "id": 637697,
                "title": "php-4ms",
                "content": "Runtime: 4 ms, faster than 92.86% of PHP online submissions for Valid Parentheses.\\nMemory Usage: 14.9 MB, less than 100.00% of PHP online submissions for Valid Parentheses.\\n\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String $s\\n     * @return Boolean\\n     */\\n    function isValid($s) {\\n        $parentheses = [\\n            \"(\" => \")\",\\n            \"[\" => \"]\",\\n            \"{\" => \"}\",\\n        ];\\n        \\n        $stack = array();\\n        \\n        for($i = 0; $i < strlen($s); $i++) {\\n            if (isset($parentheses[$s[$i]])) {\\n                array_push($stack, $s[$i]);\\n            } else {\\n                $parenthesis = array_pop($stack);\\n        \\n                if ($s[$i] != $parentheses[$parenthesis]) {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return empty($stack);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    /**\\n     * @param String $s\\n     * @return Boolean\\n     */\\n    function isValid($s) {\\n        $parentheses = [\\n            \"(\" => \")\",\\n            \"[\" => \"]\",\\n            \"{\" => \"}",
                "codeTag": "Java"
            },
            {
                "id": 599391,
                "title": "c-solution-with-explaination-100-speed-and-space",
                "content": "```\\nI will be using the stack based approach cuz its the easiest to implement if you know the data strucure well.\\nThere are five thing you will have to look for:\\n1. If the character is any of the opening braces.\\n2. If the character is an closing braces and the stack top is the corresponding opening braces.\\n3. If the character is an closing braces and the stack top is n0t the corresponding opening braces.\\n4. If the character is a closing braces but the stack is empty.\\n5. After all the checks finally if the stack is empty.\\n\\nBefore looking into th answer just think logically as to how to tacked these five cases.\\n\\n1. Push it into the stack.\\n2. Pop out of the stack.\\n3. return false.\\n4. return false.\\n5. If stack is not empty return false.\\n\\nFinally return true as we have handled all the cases of the test failing.\\n\\n\\n    bool isValid(string s) {\\n       if(s.size()==0)return true;\\n        stack<char> st;\\n        for(char &ch:s)\\n        {\\n            if(ch==\\'(\\' || ch==\\'{\\' || ch==\\'[\\')st.push(ch);\\n            else\\n            {\\n                if(st.empty())return false;\\n                if(st.top()==\\'[\\' &&ch==\\']\\')st.pop();\\n                else if(st.top()==\\'{\\' &&ch==\\'}\\')st.pop();\\n                else if(st.top()==\\'(\\' &&ch==\\')\\')st.pop();\\n                else return false;\\n            }\\n        }\\n        if(!st.empty())return false;\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nI will be using the stack based approach cuz its the easiest to implement if you know the data strucure well.\\nThere are five thing you will have to look for:\\n1. If the character is any of the opening braces.\\n2. If the character is an closing braces and the stack top is the corresponding opening braces.\\n3. If the character is an closing braces and the stack top is n0t the corresponding opening braces.\\n4. If the character is a closing braces but the stack is empty.\\n5. After all the checks finally if the stack is empty.\\n\\nBefore looking into th answer just think logically as to how to tacked these five cases.\\n\\n1. Push it into the stack.\\n2. Pop out of the stack.\\n3. return false.\\n4. return false.\\n5. If stack is not empty return false.\\n\\nFinally return true as we have handled all the cases of the test failing.\\n\\n\\n    bool isValid(string s) {\\n       if(s.size()==0)return true;\\n        stack<char> st;\\n        for(char &ch:s)\\n        {\\n            if(ch==\\'(\\' || ch==\\'{\\' || ch==\\'[\\')st.push(ch);\\n            else\\n            {\\n                if(st.empty())return false;\\n                if(st.top()==\\'[\\' &&ch==\\']\\')st.pop();\\n                else if(st.top()==\\'{\\' &&ch==\\'}\\')st.pop();\\n                else if(st.top()==\\'(\\' &&ch==\\')\\')st.pop();\\n                else return false;\\n            }\\n        }\\n        if(!st.empty())return false;\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 521507,
                "title": "in-c",
                "content": "```\\n\\n\\nbool isValid(char * s){\\n    char *stack = malloc(strlen(s));\\n    assert(stack);\\n    int top = 0;\\n    int i;\\n    char c, e;\\n\\tbool ret = false;\\n    \\n    for (i = 0; i < strlen(s); i++) {\\n        c = s[i];\\n        if (c == \\')\\') {\\n            if (top == 0)\\n                goto out;\\n            e = stack[--top];\\n            if (e != \\'(\\')\\n                goto out;\\n        } else if (c == \\'}\\') {\\n            if (top == 0)\\n                goto out;\\n            e = stack[--top];\\n            if (e != \\'{\\')\\n                goto out;\\n        } else if (c == \\']\\') {\\n            if (top == 0)\\n                goto out;\\n            e = stack[--top];\\n            if (e != \\'[\\')\\n                goto out;\\n        } else {\\n            stack[top++] = c;\\n        }\\n    }\\n\\n    ret = top == 0;\\nout:\\n    free(stack);\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n\\nbool isValid(char * s){\\n    char *stack = malloc(strlen(s));\\n    assert(stack);\\n    int top = 0;\\n    int i;\\n    char c, e;\\n\\tbool ret = false;\\n    \\n    for (i = 0; i < strlen(s); i++) {\\n        c = s[i];\\n        if (c == \\')\\') {\\n            if (top == 0)\\n                goto out;\\n            e = stack[--top];\\n            if (e != \\'(\\')\\n                goto out;\\n        } else if (c == \\'}\\') {\\n            if (top == 0)\\n                goto out;\\n            e = stack[--top];\\n            if (e != \\'{\\')\\n                goto out;\\n        } else if (c == \\']\\') {\\n            if (top == 0)\\n                goto out;\\n            e = stack[--top];\\n            if (e != \\'[\\')\\n                goto out;\\n        } else {\\n            stack[top++] = c;\\n        }\\n    }\\n\\n    ret = top == 0;\\nout:\\n    free(stack);\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 387026,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        stack = []\\n        \\n        for x in s:\\n            if x in {\\'(\\', \\'[\\', \\'{\\'}:\\n                stack.append(x)\\n            else:\\n                if not stack or stack.pop() + x not in {\\'()\\', \\'[]\\', \\'{}\\'}:\\n                    return False\\n    \\n        return not stack",
                "solutionTags": [],
                "code": "class Solution:\\n    def isValid(self, s: str) -> bool:\\n        stack = []\\n        \\n        for x in s:\\n            if x in {\\'(\\', \\'[\\', \\'{\\'}",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567810,
                "content": [
                    {
                        "username": "sunwangshu",
                        "content": "The brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\\n\\nFrom this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid. \\nThen I think the problem description should be updated."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "Exactly."
                    },
                    {
                        "username": "Awesome_7",
                        "content": "my code is expecting false for that in test case 70.\\ncan somebody look at this:\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        string opening=\"\";\\n        string closing=\"\";\\n\\n        for(auto i:s){\\n            if(i==\\'(\\' || i==\\'{\\' || i==\\'[\\' ){\\n                opening.push_back(i);\\n            }else{\\n                closing.push_back(i);\\n            }\\n        }\\n\\n        if(opening.length()!=closing.length()){\\n            return false;\\n        }\\n\\n        for(int i=0;i<opening.length();i++){\\n            if(opening[i]==\\'(\\'&& closing[i]!=\\')\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'{\\'&& closing[i]!=\\'}\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'[\\'&& closing[i]!=\\']\\'){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "chavaninc",
                        "content": "Came here to say this. Sadly I already had my submission wrong"
                    },
                    {
                        "username": "hkurmi",
                        "content": "exactly just got my first submission wrong becouse of this"
                    },
                    {
                        "username": "rafaelcitj",
                        "content": "[@D-Panda](/D-Panda) I had exact the same question after reading the description, thanks for clarifying."
                    },
                    {
                        "username": "rayhanul17",
                        "content": "[@hosua](/hosua) haha"
                    },
                    {
                        "username": "siddhanttamgadge4",
                        "content": "Yes it is allowed!"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua)  : )"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua) : ^)"
                    },
                    {
                        "username": "D-Panda",
                        "content": "it is valid"
                    },
                    {
                        "username": "hosua",
                        "content": "To answer your question 6 years later, yes, it is valid. "
                    },
                    {
                        "username": "rishavm",
                        "content": "Totally Agree! Due to lack of description in the question. My submission was rejected 3-4 times on the test cases which are not fulfilling the description of the problem. Although question is easy, but lack of description cause us time and our record."
                    },
                    {
                        "username": "omerkarabulut169",
                        "content": "Same my code 66/92 because of that"
                    },
                    {
                        "username": "minhtq9700",
                        "content": "yeah"
                    },
                    {
                        "username": "lwear2",
                        "content": "I agree.  Solved it twice from scratch only to find there are new requirements that manifest in testing.  Now I\\'m having to start again from scratch and pretty frustrated.  My second approach (recursive) simply won\\'t work in one submission test case.  This may be a little TOO real world for the learning environment.  There are classes in Requirements Engineering.  Like Agile and algorithms, they are very important to the professional.\\n\\nI strongly suggest clarifying the fact that the coder should allow for nested parentheses and that the nesting may be complex.\\n\\nRather than this wording, \"Open brackets must be closed in the CORRECT order.\"  (In whose mind?)\\n\\nI strongly suggest this: \"For strings that involve complex nesting, each bracket must be closed in the correct order.\"\\n\\nThis makes clear that \"correct\" is referring to nesting order, not front to back, or first open, or outside to inside, or some other \"correct\" order."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "sxltie",
                        "content": "precisely.. from the description one can\\u2019t even tell if (()) is valid or not.. they don\\u2019t include nested parentheses"
                    },
                    {
                        "username": "tonybrasunas",
                        "content": "The description for this one should say `([]{})` is valid too. Otherwise it's not clear that validating nested parentheses is part of the requirements."
                    },
                    {
                        "username": "bupty3e3",
                        "content": "Yeah, this question wasn\\'t that clear to this end."
                    },
                    {
                        "username": "ecapoferri",
                        "content": "Thanks for posting. I was wondering and went to discussion for clarification."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "bryanAM",
                        "content": "It\\'s a really **good** problem. But I don\\'t think it\\'s appropriate to call it **Easy**. If you\\'ve never had a question like this before, and if you\\'re new to python and programming - which is my guess the target audiance for easy questions - it\\'s a little difficult."
                    },
                    {
                        "username": "a098707730135",
                        "content": "[@JuanQP](/JuanQP) Thank you so much! You gave me the most useful hint!"
                    },
                    {
                        "username": "Rave17",
                        "content": "[@nicolobos77](/nicolobos77) thank you very much. this was crucial advice for leetcode newbie like me"
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "Totally agree. It isnt an easy problem."
                    },
                    {
                        "username": "gurunathkulkarni164",
                        "content": "You go to know stack for this problem."
                    },
                    {
                        "username": "JuanQP",
                        "content": "The only thing you need to solve this is knowing what a stack is. In first year of any engineering or comp-sci career you learn this in the first year"
                    },
                    {
                        "username": "nicolobos77",
                        "content": "It\\'s easy you just have to implement a memory managment with a char* as a stack in C, you push every open bracket, and pop one when there\\'s a close bracket that matches with the last opened bracket, if it doesn\\'t match, just return false, and if the string loop ended and there\\'s at least one bracket in the stack, return false, if it ends with an empty stack and every bracket is open and close correctly return true"
                    },
                    {
                        "username": "matthcraig",
                        "content": "The word \"easy\" in leetcode is a total misnomer and a relative description.  There are no easy leetcode questions.  "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "ikr"
                    },
                    {
                        "username": "tryhard00",
                        "content": "This problem could be considered easy but only if you realized the crux of it. If you tried to do it using pure conditionals, which I did for the first 3 hours, you\\'re in for a very bad time. I finally gave up on conditionals when it had a nested within nested case. I was about to go 3d array to store each set but it was so logically complex I almost quit. Then I saw it. So this problem could considered medium if you didn\\'t see the easy answer. Overall, a very clever question. It had so many caveats that I kept getting rejected and it was giving me pstd by the end. lol. For those who are stuck, the hint is what goes in last must come out first."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "Your hint at the last helped me solve the problem quickly \\uD83D\\uDE0A. Thanks."
                    },
                    {
                        "username": "zaynahmad20",
                        "content": "You sure do know how to not spoil a question and give a good hint. Thanks lol"
                    },
                    {
                        "username": "ejaza",
                        "content": "wow man thanks a great hint now i am able to do it \"the hint is what goes in last must come out first.\""
                    },
                    {
                        "username": "johnopj",
                        "content": "Exactly!! The door opened last should be closed first."
                    },
                    {
                        "username": "devindesu",
                        "content": "Mother $^#& I spent much more than 3 hours trying to force it to work with nested conditionals...Thank you for the hint. If they're gonna classify this as Easy they should at least defined the stack class for us  lol"
                    },
                    {
                        "username": "amitkhedkar41",
                        "content": "From this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid.\\nThen I think the problem description should be updated"
                    },
                    {
                        "username": "meergato247",
                        "content": "Exactly. I assumed the pairs just had to be {} () or [], the problem statement never said anything about them possibly being inside one another. "
                    },
                    {
                        "username": "RSK_Ua",
                        "content": "Here is some tip:\\nThe first line of the function uses a guard statement to check if the length of the input string is even. If the length is odd, the function returns false because it means that the brackets are not properly balanced.\\nThe next line creates an empty stack of characters to store the opening brackets.\\nThe function then loops through each character item in the input string s.\\nFor each character item, the code checks whether it is an opening bracket: (, [, or {. If it is, the corresponding closing bracket is pushed onto the stack. For example, if the character is (, the character ) is pushed onto the stack.\\nIf the character is a closing bracket: ), ], or }, the code checks whether the stack is empty. If the stack is empty, it means that there is no opening bracket to match the closing bracket, so the function returns false. If the stack is not empty, the last opening bracket is removed from the stack and checked against the current closing bracket. If the brackets do not match, the function returns false.\\nAfter looping through all the characters in the input string, the function checks whether the stack is empty. If it is, it means that all the opening brackets have been matched with their corresponding closing brackets, so the function returns true. If the stack is not empty, it means that there are unmatched opening brackets, so the function returns false."
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "well explained, I managed to create a solution based on your logic. Thanks a lot\\n"
                    },
                    {
                        "username": "shekardaval",
                        "content": "for the string \\'(]\\' my code is working fine with python 3.7, but here its showing wrong output"
                    },
                    {
                        "username": "benjayy",
                        "content": "I fixed it by returning the boolean rather than the strings. "
                    },
                    {
                        "username": "Aleks_Kim",
                        "content": "[@gvolsky](/gvolsky) Thank you, it is really solution"
                    },
                    {
                        "username": "muqeetkhawaja",
                        "content": "[@gvolsky](/gvolsky) Thanks Brother."
                    },
                    {
                        "username": "gvolsky",
                        "content": "Maybe you, like me, return 'true' and 'false' as strings, not as booleans True and False."
                    },
                    {
                        "username": "wayneli-5",
                        "content": "[@saiharish_g](/saiharish_g) I have this issue too. Have you found a solution? Thank you!"
                    },
                    {
                        "username": "keerthisravanigude",
                        "content": "[@fizah](/fizah) ya same with me also\\n"
                    },
                    {
                        "username": "saiharish_g",
                        "content": "so have you find the real issue actually??"
                    },
                    {
                        "username": "fizah",
                        "content": "same"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "user8796tT",
                        "content": "whats wrong with this TC \"{[]}\" in custom test cases run it succeed but it fails on submission.  \\n![image](https://assets.leetcode.com/users/images/0a36f8a9-6403-4cb8-a073-933a7ded9abe_1609523958.1513097.png)\\n\""
                    },
                    {
                        "username": "ms0686714",
                        "content": "Might be a global variable issue.Make sure initialize the global variable in the begining of main function."
                    },
                    {
                        "username": "kanwarudaysingh",
                        "content": "I was asked to do this in o(1) memory in an interview! Anyone knows how to do that?"
                    },
                    {
                        "username": "0bro",
                        "content": "They probably also required 10 years experience in Rust (Rust came out 8 years ago) lol"
                    },
                    {
                        "username": "data-stack",
                        "content": "Well, you can solve it with a regular expression in O(1) space complexity "
                    },
                    {
                        "username": "rennasccenth",
                        "content": "[@psi_psi](/psi_psi) \"For every\" states something that needs to be iterated, which means nothing less than O(n)"
                    },
                    {
                        "username": "charonme",
                        "content": "I tried a stackless solution with O(1) additional space (not counting the in-place modification of the input string), but it\\'s O(n^2) time"
                    },
                    {
                        "username": "psi_psi",
                        "content": "For every closing char, repeat the search (recursively and repeatedly) backwards (and with inversed opening and closing chars) until you are out of string or you reach the next (in this case, previous) opening char in the string. If that next one is your corresponding opening char, you continue forwards. It is not going to be very fast."
                    },
                    {
                        "username": "astro12",
                        "content": "What is the company name? I\\'ll make sure I\\'ll add that to my blacklist"
                    },
                    {
                        "username": "jigar100",
                        "content": "Did the interviewer asked to do this in O(1) space by maintaining O(n) time complexity"
                    },
                    {
                        "username": "lwear2",
                        "content": "https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/715/introduction/4654/\\n\\nIn the section of Space Analysis it indicates that input and output arrays are not included in memory analysis for BigO.  So, cycle through the input as many times as necessary, modifying the array each time and don\\'t create any new storage space for the array."
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Did u find solution to do that as o1  (javscript)"
                    },
                    {
                        "username": "Alexander2049",
                        "content": "Description is not good enough. Should be shown some more test cases as \"( [ ) ]\", because \"Open brackets must be closed in the correct order\" could be missunderstood."
                    },
                    {
                        "username": "ananya_dash16",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) Same with me.\\n"
                    },
                    {
                        "username": "rahulschandak",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) I have the same doubt"
                    },
                    {
                        "username": "AnkushKrVerma",
                        "content": "yess even now i can\\'t understand the problem.\\nwhy the TC \"( [ ) ]\" returning false ???\\nhelp me understand the problem "
                    }
                ]
            },
            {
                "id": 1571052,
                "content": [
                    {
                        "username": "sunwangshu",
                        "content": "The brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\\n\\nFrom this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid. \\nThen I think the problem description should be updated."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "Exactly."
                    },
                    {
                        "username": "Awesome_7",
                        "content": "my code is expecting false for that in test case 70.\\ncan somebody look at this:\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        string opening=\"\";\\n        string closing=\"\";\\n\\n        for(auto i:s){\\n            if(i==\\'(\\' || i==\\'{\\' || i==\\'[\\' ){\\n                opening.push_back(i);\\n            }else{\\n                closing.push_back(i);\\n            }\\n        }\\n\\n        if(opening.length()!=closing.length()){\\n            return false;\\n        }\\n\\n        for(int i=0;i<opening.length();i++){\\n            if(opening[i]==\\'(\\'&& closing[i]!=\\')\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'{\\'&& closing[i]!=\\'}\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'[\\'&& closing[i]!=\\']\\'){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "chavaninc",
                        "content": "Came here to say this. Sadly I already had my submission wrong"
                    },
                    {
                        "username": "hkurmi",
                        "content": "exactly just got my first submission wrong becouse of this"
                    },
                    {
                        "username": "rafaelcitj",
                        "content": "[@D-Panda](/D-Panda) I had exact the same question after reading the description, thanks for clarifying."
                    },
                    {
                        "username": "rayhanul17",
                        "content": "[@hosua](/hosua) haha"
                    },
                    {
                        "username": "siddhanttamgadge4",
                        "content": "Yes it is allowed!"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua)  : )"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua) : ^)"
                    },
                    {
                        "username": "D-Panda",
                        "content": "it is valid"
                    },
                    {
                        "username": "hosua",
                        "content": "To answer your question 6 years later, yes, it is valid. "
                    },
                    {
                        "username": "rishavm",
                        "content": "Totally Agree! Due to lack of description in the question. My submission was rejected 3-4 times on the test cases which are not fulfilling the description of the problem. Although question is easy, but lack of description cause us time and our record."
                    },
                    {
                        "username": "omerkarabulut169",
                        "content": "Same my code 66/92 because of that"
                    },
                    {
                        "username": "minhtq9700",
                        "content": "yeah"
                    },
                    {
                        "username": "lwear2",
                        "content": "I agree.  Solved it twice from scratch only to find there are new requirements that manifest in testing.  Now I\\'m having to start again from scratch and pretty frustrated.  My second approach (recursive) simply won\\'t work in one submission test case.  This may be a little TOO real world for the learning environment.  There are classes in Requirements Engineering.  Like Agile and algorithms, they are very important to the professional.\\n\\nI strongly suggest clarifying the fact that the coder should allow for nested parentheses and that the nesting may be complex.\\n\\nRather than this wording, \"Open brackets must be closed in the CORRECT order.\"  (In whose mind?)\\n\\nI strongly suggest this: \"For strings that involve complex nesting, each bracket must be closed in the correct order.\"\\n\\nThis makes clear that \"correct\" is referring to nesting order, not front to back, or first open, or outside to inside, or some other \"correct\" order."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "sxltie",
                        "content": "precisely.. from the description one can\\u2019t even tell if (()) is valid or not.. they don\\u2019t include nested parentheses"
                    },
                    {
                        "username": "tonybrasunas",
                        "content": "The description for this one should say `([]{})` is valid too. Otherwise it's not clear that validating nested parentheses is part of the requirements."
                    },
                    {
                        "username": "bupty3e3",
                        "content": "Yeah, this question wasn\\'t that clear to this end."
                    },
                    {
                        "username": "ecapoferri",
                        "content": "Thanks for posting. I was wondering and went to discussion for clarification."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "bryanAM",
                        "content": "It\\'s a really **good** problem. But I don\\'t think it\\'s appropriate to call it **Easy**. If you\\'ve never had a question like this before, and if you\\'re new to python and programming - which is my guess the target audiance for easy questions - it\\'s a little difficult."
                    },
                    {
                        "username": "a098707730135",
                        "content": "[@JuanQP](/JuanQP) Thank you so much! You gave me the most useful hint!"
                    },
                    {
                        "username": "Rave17",
                        "content": "[@nicolobos77](/nicolobos77) thank you very much. this was crucial advice for leetcode newbie like me"
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "Totally agree. It isnt an easy problem."
                    },
                    {
                        "username": "gurunathkulkarni164",
                        "content": "You go to know stack for this problem."
                    },
                    {
                        "username": "JuanQP",
                        "content": "The only thing you need to solve this is knowing what a stack is. In first year of any engineering or comp-sci career you learn this in the first year"
                    },
                    {
                        "username": "nicolobos77",
                        "content": "It\\'s easy you just have to implement a memory managment with a char* as a stack in C, you push every open bracket, and pop one when there\\'s a close bracket that matches with the last opened bracket, if it doesn\\'t match, just return false, and if the string loop ended and there\\'s at least one bracket in the stack, return false, if it ends with an empty stack and every bracket is open and close correctly return true"
                    },
                    {
                        "username": "matthcraig",
                        "content": "The word \"easy\" in leetcode is a total misnomer and a relative description.  There are no easy leetcode questions.  "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "ikr"
                    },
                    {
                        "username": "tryhard00",
                        "content": "This problem could be considered easy but only if you realized the crux of it. If you tried to do it using pure conditionals, which I did for the first 3 hours, you\\'re in for a very bad time. I finally gave up on conditionals when it had a nested within nested case. I was about to go 3d array to store each set but it was so logically complex I almost quit. Then I saw it. So this problem could considered medium if you didn\\'t see the easy answer. Overall, a very clever question. It had so many caveats that I kept getting rejected and it was giving me pstd by the end. lol. For those who are stuck, the hint is what goes in last must come out first."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "Your hint at the last helped me solve the problem quickly \\uD83D\\uDE0A. Thanks."
                    },
                    {
                        "username": "zaynahmad20",
                        "content": "You sure do know how to not spoil a question and give a good hint. Thanks lol"
                    },
                    {
                        "username": "ejaza",
                        "content": "wow man thanks a great hint now i am able to do it \"the hint is what goes in last must come out first.\""
                    },
                    {
                        "username": "johnopj",
                        "content": "Exactly!! The door opened last should be closed first."
                    },
                    {
                        "username": "devindesu",
                        "content": "Mother $^#& I spent much more than 3 hours trying to force it to work with nested conditionals...Thank you for the hint. If they're gonna classify this as Easy they should at least defined the stack class for us  lol"
                    },
                    {
                        "username": "amitkhedkar41",
                        "content": "From this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid.\\nThen I think the problem description should be updated"
                    },
                    {
                        "username": "meergato247",
                        "content": "Exactly. I assumed the pairs just had to be {} () or [], the problem statement never said anything about them possibly being inside one another. "
                    },
                    {
                        "username": "RSK_Ua",
                        "content": "Here is some tip:\\nThe first line of the function uses a guard statement to check if the length of the input string is even. If the length is odd, the function returns false because it means that the brackets are not properly balanced.\\nThe next line creates an empty stack of characters to store the opening brackets.\\nThe function then loops through each character item in the input string s.\\nFor each character item, the code checks whether it is an opening bracket: (, [, or {. If it is, the corresponding closing bracket is pushed onto the stack. For example, if the character is (, the character ) is pushed onto the stack.\\nIf the character is a closing bracket: ), ], or }, the code checks whether the stack is empty. If the stack is empty, it means that there is no opening bracket to match the closing bracket, so the function returns false. If the stack is not empty, the last opening bracket is removed from the stack and checked against the current closing bracket. If the brackets do not match, the function returns false.\\nAfter looping through all the characters in the input string, the function checks whether the stack is empty. If it is, it means that all the opening brackets have been matched with their corresponding closing brackets, so the function returns true. If the stack is not empty, it means that there are unmatched opening brackets, so the function returns false."
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "well explained, I managed to create a solution based on your logic. Thanks a lot\\n"
                    },
                    {
                        "username": "shekardaval",
                        "content": "for the string \\'(]\\' my code is working fine with python 3.7, but here its showing wrong output"
                    },
                    {
                        "username": "benjayy",
                        "content": "I fixed it by returning the boolean rather than the strings. "
                    },
                    {
                        "username": "Aleks_Kim",
                        "content": "[@gvolsky](/gvolsky) Thank you, it is really solution"
                    },
                    {
                        "username": "muqeetkhawaja",
                        "content": "[@gvolsky](/gvolsky) Thanks Brother."
                    },
                    {
                        "username": "gvolsky",
                        "content": "Maybe you, like me, return 'true' and 'false' as strings, not as booleans True and False."
                    },
                    {
                        "username": "wayneli-5",
                        "content": "[@saiharish_g](/saiharish_g) I have this issue too. Have you found a solution? Thank you!"
                    },
                    {
                        "username": "keerthisravanigude",
                        "content": "[@fizah](/fizah) ya same with me also\\n"
                    },
                    {
                        "username": "saiharish_g",
                        "content": "so have you find the real issue actually??"
                    },
                    {
                        "username": "fizah",
                        "content": "same"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "user8796tT",
                        "content": "whats wrong with this TC \"{[]}\" in custom test cases run it succeed but it fails on submission.  \\n![image](https://assets.leetcode.com/users/images/0a36f8a9-6403-4cb8-a073-933a7ded9abe_1609523958.1513097.png)\\n\""
                    },
                    {
                        "username": "ms0686714",
                        "content": "Might be a global variable issue.Make sure initialize the global variable in the begining of main function."
                    },
                    {
                        "username": "kanwarudaysingh",
                        "content": "I was asked to do this in o(1) memory in an interview! Anyone knows how to do that?"
                    },
                    {
                        "username": "0bro",
                        "content": "They probably also required 10 years experience in Rust (Rust came out 8 years ago) lol"
                    },
                    {
                        "username": "data-stack",
                        "content": "Well, you can solve it with a regular expression in O(1) space complexity "
                    },
                    {
                        "username": "rennasccenth",
                        "content": "[@psi_psi](/psi_psi) \"For every\" states something that needs to be iterated, which means nothing less than O(n)"
                    },
                    {
                        "username": "charonme",
                        "content": "I tried a stackless solution with O(1) additional space (not counting the in-place modification of the input string), but it\\'s O(n^2) time"
                    },
                    {
                        "username": "psi_psi",
                        "content": "For every closing char, repeat the search (recursively and repeatedly) backwards (and with inversed opening and closing chars) until you are out of string or you reach the next (in this case, previous) opening char in the string. If that next one is your corresponding opening char, you continue forwards. It is not going to be very fast."
                    },
                    {
                        "username": "astro12",
                        "content": "What is the company name? I\\'ll make sure I\\'ll add that to my blacklist"
                    },
                    {
                        "username": "jigar100",
                        "content": "Did the interviewer asked to do this in O(1) space by maintaining O(n) time complexity"
                    },
                    {
                        "username": "lwear2",
                        "content": "https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/715/introduction/4654/\\n\\nIn the section of Space Analysis it indicates that input and output arrays are not included in memory analysis for BigO.  So, cycle through the input as many times as necessary, modifying the array each time and don\\'t create any new storage space for the array."
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Did u find solution to do that as o1  (javscript)"
                    },
                    {
                        "username": "Alexander2049",
                        "content": "Description is not good enough. Should be shown some more test cases as \"( [ ) ]\", because \"Open brackets must be closed in the correct order\" could be missunderstood."
                    },
                    {
                        "username": "ananya_dash16",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) Same with me.\\n"
                    },
                    {
                        "username": "rahulschandak",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) I have the same doubt"
                    },
                    {
                        "username": "AnkushKrVerma",
                        "content": "yess even now i can\\'t understand the problem.\\nwhy the TC \"( [ ) ]\" returning false ???\\nhelp me understand the problem "
                    }
                ]
            },
            {
                "id": 1572706,
                "content": [
                    {
                        "username": "sunwangshu",
                        "content": "The brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\\n\\nFrom this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid. \\nThen I think the problem description should be updated."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "Exactly."
                    },
                    {
                        "username": "Awesome_7",
                        "content": "my code is expecting false for that in test case 70.\\ncan somebody look at this:\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        string opening=\"\";\\n        string closing=\"\";\\n\\n        for(auto i:s){\\n            if(i==\\'(\\' || i==\\'{\\' || i==\\'[\\' ){\\n                opening.push_back(i);\\n            }else{\\n                closing.push_back(i);\\n            }\\n        }\\n\\n        if(opening.length()!=closing.length()){\\n            return false;\\n        }\\n\\n        for(int i=0;i<opening.length();i++){\\n            if(opening[i]==\\'(\\'&& closing[i]!=\\')\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'{\\'&& closing[i]!=\\'}\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'[\\'&& closing[i]!=\\']\\'){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "chavaninc",
                        "content": "Came here to say this. Sadly I already had my submission wrong"
                    },
                    {
                        "username": "hkurmi",
                        "content": "exactly just got my first submission wrong becouse of this"
                    },
                    {
                        "username": "rafaelcitj",
                        "content": "[@D-Panda](/D-Panda) I had exact the same question after reading the description, thanks for clarifying."
                    },
                    {
                        "username": "rayhanul17",
                        "content": "[@hosua](/hosua) haha"
                    },
                    {
                        "username": "siddhanttamgadge4",
                        "content": "Yes it is allowed!"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua)  : )"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua) : ^)"
                    },
                    {
                        "username": "D-Panda",
                        "content": "it is valid"
                    },
                    {
                        "username": "hosua",
                        "content": "To answer your question 6 years later, yes, it is valid. "
                    },
                    {
                        "username": "rishavm",
                        "content": "Totally Agree! Due to lack of description in the question. My submission was rejected 3-4 times on the test cases which are not fulfilling the description of the problem. Although question is easy, but lack of description cause us time and our record."
                    },
                    {
                        "username": "omerkarabulut169",
                        "content": "Same my code 66/92 because of that"
                    },
                    {
                        "username": "minhtq9700",
                        "content": "yeah"
                    },
                    {
                        "username": "lwear2",
                        "content": "I agree.  Solved it twice from scratch only to find there are new requirements that manifest in testing.  Now I\\'m having to start again from scratch and pretty frustrated.  My second approach (recursive) simply won\\'t work in one submission test case.  This may be a little TOO real world for the learning environment.  There are classes in Requirements Engineering.  Like Agile and algorithms, they are very important to the professional.\\n\\nI strongly suggest clarifying the fact that the coder should allow for nested parentheses and that the nesting may be complex.\\n\\nRather than this wording, \"Open brackets must be closed in the CORRECT order.\"  (In whose mind?)\\n\\nI strongly suggest this: \"For strings that involve complex nesting, each bracket must be closed in the correct order.\"\\n\\nThis makes clear that \"correct\" is referring to nesting order, not front to back, or first open, or outside to inside, or some other \"correct\" order."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "sxltie",
                        "content": "precisely.. from the description one can\\u2019t even tell if (()) is valid or not.. they don\\u2019t include nested parentheses"
                    },
                    {
                        "username": "tonybrasunas",
                        "content": "The description for this one should say `([]{})` is valid too. Otherwise it's not clear that validating nested parentheses is part of the requirements."
                    },
                    {
                        "username": "bupty3e3",
                        "content": "Yeah, this question wasn\\'t that clear to this end."
                    },
                    {
                        "username": "ecapoferri",
                        "content": "Thanks for posting. I was wondering and went to discussion for clarification."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "bryanAM",
                        "content": "It\\'s a really **good** problem. But I don\\'t think it\\'s appropriate to call it **Easy**. If you\\'ve never had a question like this before, and if you\\'re new to python and programming - which is my guess the target audiance for easy questions - it\\'s a little difficult."
                    },
                    {
                        "username": "a098707730135",
                        "content": "[@JuanQP](/JuanQP) Thank you so much! You gave me the most useful hint!"
                    },
                    {
                        "username": "Rave17",
                        "content": "[@nicolobos77](/nicolobos77) thank you very much. this was crucial advice for leetcode newbie like me"
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "Totally agree. It isnt an easy problem."
                    },
                    {
                        "username": "gurunathkulkarni164",
                        "content": "You go to know stack for this problem."
                    },
                    {
                        "username": "JuanQP",
                        "content": "The only thing you need to solve this is knowing what a stack is. In first year of any engineering or comp-sci career you learn this in the first year"
                    },
                    {
                        "username": "nicolobos77",
                        "content": "It\\'s easy you just have to implement a memory managment with a char* as a stack in C, you push every open bracket, and pop one when there\\'s a close bracket that matches with the last opened bracket, if it doesn\\'t match, just return false, and if the string loop ended and there\\'s at least one bracket in the stack, return false, if it ends with an empty stack and every bracket is open and close correctly return true"
                    },
                    {
                        "username": "matthcraig",
                        "content": "The word \"easy\" in leetcode is a total misnomer and a relative description.  There are no easy leetcode questions.  "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "ikr"
                    },
                    {
                        "username": "tryhard00",
                        "content": "This problem could be considered easy but only if you realized the crux of it. If you tried to do it using pure conditionals, which I did for the first 3 hours, you\\'re in for a very bad time. I finally gave up on conditionals when it had a nested within nested case. I was about to go 3d array to store each set but it was so logically complex I almost quit. Then I saw it. So this problem could considered medium if you didn\\'t see the easy answer. Overall, a very clever question. It had so many caveats that I kept getting rejected and it was giving me pstd by the end. lol. For those who are stuck, the hint is what goes in last must come out first."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "Your hint at the last helped me solve the problem quickly \\uD83D\\uDE0A. Thanks."
                    },
                    {
                        "username": "zaynahmad20",
                        "content": "You sure do know how to not spoil a question and give a good hint. Thanks lol"
                    },
                    {
                        "username": "ejaza",
                        "content": "wow man thanks a great hint now i am able to do it \"the hint is what goes in last must come out first.\""
                    },
                    {
                        "username": "johnopj",
                        "content": "Exactly!! The door opened last should be closed first."
                    },
                    {
                        "username": "devindesu",
                        "content": "Mother $^#& I spent much more than 3 hours trying to force it to work with nested conditionals...Thank you for the hint. If they're gonna classify this as Easy they should at least defined the stack class for us  lol"
                    },
                    {
                        "username": "amitkhedkar41",
                        "content": "From this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid.\\nThen I think the problem description should be updated"
                    },
                    {
                        "username": "meergato247",
                        "content": "Exactly. I assumed the pairs just had to be {} () or [], the problem statement never said anything about them possibly being inside one another. "
                    },
                    {
                        "username": "RSK_Ua",
                        "content": "Here is some tip:\\nThe first line of the function uses a guard statement to check if the length of the input string is even. If the length is odd, the function returns false because it means that the brackets are not properly balanced.\\nThe next line creates an empty stack of characters to store the opening brackets.\\nThe function then loops through each character item in the input string s.\\nFor each character item, the code checks whether it is an opening bracket: (, [, or {. If it is, the corresponding closing bracket is pushed onto the stack. For example, if the character is (, the character ) is pushed onto the stack.\\nIf the character is a closing bracket: ), ], or }, the code checks whether the stack is empty. If the stack is empty, it means that there is no opening bracket to match the closing bracket, so the function returns false. If the stack is not empty, the last opening bracket is removed from the stack and checked against the current closing bracket. If the brackets do not match, the function returns false.\\nAfter looping through all the characters in the input string, the function checks whether the stack is empty. If it is, it means that all the opening brackets have been matched with their corresponding closing brackets, so the function returns true. If the stack is not empty, it means that there are unmatched opening brackets, so the function returns false."
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "well explained, I managed to create a solution based on your logic. Thanks a lot\\n"
                    },
                    {
                        "username": "shekardaval",
                        "content": "for the string \\'(]\\' my code is working fine with python 3.7, but here its showing wrong output"
                    },
                    {
                        "username": "benjayy",
                        "content": "I fixed it by returning the boolean rather than the strings. "
                    },
                    {
                        "username": "Aleks_Kim",
                        "content": "[@gvolsky](/gvolsky) Thank you, it is really solution"
                    },
                    {
                        "username": "muqeetkhawaja",
                        "content": "[@gvolsky](/gvolsky) Thanks Brother."
                    },
                    {
                        "username": "gvolsky",
                        "content": "Maybe you, like me, return 'true' and 'false' as strings, not as booleans True and False."
                    },
                    {
                        "username": "wayneli-5",
                        "content": "[@saiharish_g](/saiharish_g) I have this issue too. Have you found a solution? Thank you!"
                    },
                    {
                        "username": "keerthisravanigude",
                        "content": "[@fizah](/fizah) ya same with me also\\n"
                    },
                    {
                        "username": "saiharish_g",
                        "content": "so have you find the real issue actually??"
                    },
                    {
                        "username": "fizah",
                        "content": "same"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "user8796tT",
                        "content": "whats wrong with this TC \"{[]}\" in custom test cases run it succeed but it fails on submission.  \\n![image](https://assets.leetcode.com/users/images/0a36f8a9-6403-4cb8-a073-933a7ded9abe_1609523958.1513097.png)\\n\""
                    },
                    {
                        "username": "ms0686714",
                        "content": "Might be a global variable issue.Make sure initialize the global variable in the begining of main function."
                    },
                    {
                        "username": "kanwarudaysingh",
                        "content": "I was asked to do this in o(1) memory in an interview! Anyone knows how to do that?"
                    },
                    {
                        "username": "0bro",
                        "content": "They probably also required 10 years experience in Rust (Rust came out 8 years ago) lol"
                    },
                    {
                        "username": "data-stack",
                        "content": "Well, you can solve it with a regular expression in O(1) space complexity "
                    },
                    {
                        "username": "rennasccenth",
                        "content": "[@psi_psi](/psi_psi) \"For every\" states something that needs to be iterated, which means nothing less than O(n)"
                    },
                    {
                        "username": "charonme",
                        "content": "I tried a stackless solution with O(1) additional space (not counting the in-place modification of the input string), but it\\'s O(n^2) time"
                    },
                    {
                        "username": "psi_psi",
                        "content": "For every closing char, repeat the search (recursively and repeatedly) backwards (and with inversed opening and closing chars) until you are out of string or you reach the next (in this case, previous) opening char in the string. If that next one is your corresponding opening char, you continue forwards. It is not going to be very fast."
                    },
                    {
                        "username": "astro12",
                        "content": "What is the company name? I\\'ll make sure I\\'ll add that to my blacklist"
                    },
                    {
                        "username": "jigar100",
                        "content": "Did the interviewer asked to do this in O(1) space by maintaining O(n) time complexity"
                    },
                    {
                        "username": "lwear2",
                        "content": "https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/715/introduction/4654/\\n\\nIn the section of Space Analysis it indicates that input and output arrays are not included in memory analysis for BigO.  So, cycle through the input as many times as necessary, modifying the array each time and don\\'t create any new storage space for the array."
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Did u find solution to do that as o1  (javscript)"
                    },
                    {
                        "username": "Alexander2049",
                        "content": "Description is not good enough. Should be shown some more test cases as \"( [ ) ]\", because \"Open brackets must be closed in the correct order\" could be missunderstood."
                    },
                    {
                        "username": "ananya_dash16",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) Same with me.\\n"
                    },
                    {
                        "username": "rahulschandak",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) I have the same doubt"
                    },
                    {
                        "username": "AnkushKrVerma",
                        "content": "yess even now i can\\'t understand the problem.\\nwhy the TC \"( [ ) ]\" returning false ???\\nhelp me understand the problem "
                    }
                ]
            },
            {
                "id": 1643473,
                "content": [
                    {
                        "username": "sunwangshu",
                        "content": "The brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\\n\\nFrom this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid. \\nThen I think the problem description should be updated."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "Exactly."
                    },
                    {
                        "username": "Awesome_7",
                        "content": "my code is expecting false for that in test case 70.\\ncan somebody look at this:\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        string opening=\"\";\\n        string closing=\"\";\\n\\n        for(auto i:s){\\n            if(i==\\'(\\' || i==\\'{\\' || i==\\'[\\' ){\\n                opening.push_back(i);\\n            }else{\\n                closing.push_back(i);\\n            }\\n        }\\n\\n        if(opening.length()!=closing.length()){\\n            return false;\\n        }\\n\\n        for(int i=0;i<opening.length();i++){\\n            if(opening[i]==\\'(\\'&& closing[i]!=\\')\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'{\\'&& closing[i]!=\\'}\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'[\\'&& closing[i]!=\\']\\'){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "chavaninc",
                        "content": "Came here to say this. Sadly I already had my submission wrong"
                    },
                    {
                        "username": "hkurmi",
                        "content": "exactly just got my first submission wrong becouse of this"
                    },
                    {
                        "username": "rafaelcitj",
                        "content": "[@D-Panda](/D-Panda) I had exact the same question after reading the description, thanks for clarifying."
                    },
                    {
                        "username": "rayhanul17",
                        "content": "[@hosua](/hosua) haha"
                    },
                    {
                        "username": "siddhanttamgadge4",
                        "content": "Yes it is allowed!"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua)  : )"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua) : ^)"
                    },
                    {
                        "username": "D-Panda",
                        "content": "it is valid"
                    },
                    {
                        "username": "hosua",
                        "content": "To answer your question 6 years later, yes, it is valid. "
                    },
                    {
                        "username": "rishavm",
                        "content": "Totally Agree! Due to lack of description in the question. My submission was rejected 3-4 times on the test cases which are not fulfilling the description of the problem. Although question is easy, but lack of description cause us time and our record."
                    },
                    {
                        "username": "omerkarabulut169",
                        "content": "Same my code 66/92 because of that"
                    },
                    {
                        "username": "minhtq9700",
                        "content": "yeah"
                    },
                    {
                        "username": "lwear2",
                        "content": "I agree.  Solved it twice from scratch only to find there are new requirements that manifest in testing.  Now I\\'m having to start again from scratch and pretty frustrated.  My second approach (recursive) simply won\\'t work in one submission test case.  This may be a little TOO real world for the learning environment.  There are classes in Requirements Engineering.  Like Agile and algorithms, they are very important to the professional.\\n\\nI strongly suggest clarifying the fact that the coder should allow for nested parentheses and that the nesting may be complex.\\n\\nRather than this wording, \"Open brackets must be closed in the CORRECT order.\"  (In whose mind?)\\n\\nI strongly suggest this: \"For strings that involve complex nesting, each bracket must be closed in the correct order.\"\\n\\nThis makes clear that \"correct\" is referring to nesting order, not front to back, or first open, or outside to inside, or some other \"correct\" order."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "sxltie",
                        "content": "precisely.. from the description one can\\u2019t even tell if (()) is valid or not.. they don\\u2019t include nested parentheses"
                    },
                    {
                        "username": "tonybrasunas",
                        "content": "The description for this one should say `([]{})` is valid too. Otherwise it's not clear that validating nested parentheses is part of the requirements."
                    },
                    {
                        "username": "bupty3e3",
                        "content": "Yeah, this question wasn\\'t that clear to this end."
                    },
                    {
                        "username": "ecapoferri",
                        "content": "Thanks for posting. I was wondering and went to discussion for clarification."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "bryanAM",
                        "content": "It\\'s a really **good** problem. But I don\\'t think it\\'s appropriate to call it **Easy**. If you\\'ve never had a question like this before, and if you\\'re new to python and programming - which is my guess the target audiance for easy questions - it\\'s a little difficult."
                    },
                    {
                        "username": "a098707730135",
                        "content": "[@JuanQP](/JuanQP) Thank you so much! You gave me the most useful hint!"
                    },
                    {
                        "username": "Rave17",
                        "content": "[@nicolobos77](/nicolobos77) thank you very much. this was crucial advice for leetcode newbie like me"
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "Totally agree. It isnt an easy problem."
                    },
                    {
                        "username": "gurunathkulkarni164",
                        "content": "You go to know stack for this problem."
                    },
                    {
                        "username": "JuanQP",
                        "content": "The only thing you need to solve this is knowing what a stack is. In first year of any engineering or comp-sci career you learn this in the first year"
                    },
                    {
                        "username": "nicolobos77",
                        "content": "It\\'s easy you just have to implement a memory managment with a char* as a stack in C, you push every open bracket, and pop one when there\\'s a close bracket that matches with the last opened bracket, if it doesn\\'t match, just return false, and if the string loop ended and there\\'s at least one bracket in the stack, return false, if it ends with an empty stack and every bracket is open and close correctly return true"
                    },
                    {
                        "username": "matthcraig",
                        "content": "The word \"easy\" in leetcode is a total misnomer and a relative description.  There are no easy leetcode questions.  "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "ikr"
                    },
                    {
                        "username": "tryhard00",
                        "content": "This problem could be considered easy but only if you realized the crux of it. If you tried to do it using pure conditionals, which I did for the first 3 hours, you\\'re in for a very bad time. I finally gave up on conditionals when it had a nested within nested case. I was about to go 3d array to store each set but it was so logically complex I almost quit. Then I saw it. So this problem could considered medium if you didn\\'t see the easy answer. Overall, a very clever question. It had so many caveats that I kept getting rejected and it was giving me pstd by the end. lol. For those who are stuck, the hint is what goes in last must come out first."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "Your hint at the last helped me solve the problem quickly \\uD83D\\uDE0A. Thanks."
                    },
                    {
                        "username": "zaynahmad20",
                        "content": "You sure do know how to not spoil a question and give a good hint. Thanks lol"
                    },
                    {
                        "username": "ejaza",
                        "content": "wow man thanks a great hint now i am able to do it \"the hint is what goes in last must come out first.\""
                    },
                    {
                        "username": "johnopj",
                        "content": "Exactly!! The door opened last should be closed first."
                    },
                    {
                        "username": "devindesu",
                        "content": "Mother $^#& I spent much more than 3 hours trying to force it to work with nested conditionals...Thank you for the hint. If they're gonna classify this as Easy they should at least defined the stack class for us  lol"
                    },
                    {
                        "username": "amitkhedkar41",
                        "content": "From this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid.\\nThen I think the problem description should be updated"
                    },
                    {
                        "username": "meergato247",
                        "content": "Exactly. I assumed the pairs just had to be {} () or [], the problem statement never said anything about them possibly being inside one another. "
                    },
                    {
                        "username": "RSK_Ua",
                        "content": "Here is some tip:\\nThe first line of the function uses a guard statement to check if the length of the input string is even. If the length is odd, the function returns false because it means that the brackets are not properly balanced.\\nThe next line creates an empty stack of characters to store the opening brackets.\\nThe function then loops through each character item in the input string s.\\nFor each character item, the code checks whether it is an opening bracket: (, [, or {. If it is, the corresponding closing bracket is pushed onto the stack. For example, if the character is (, the character ) is pushed onto the stack.\\nIf the character is a closing bracket: ), ], or }, the code checks whether the stack is empty. If the stack is empty, it means that there is no opening bracket to match the closing bracket, so the function returns false. If the stack is not empty, the last opening bracket is removed from the stack and checked against the current closing bracket. If the brackets do not match, the function returns false.\\nAfter looping through all the characters in the input string, the function checks whether the stack is empty. If it is, it means that all the opening brackets have been matched with their corresponding closing brackets, so the function returns true. If the stack is not empty, it means that there are unmatched opening brackets, so the function returns false."
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "well explained, I managed to create a solution based on your logic. Thanks a lot\\n"
                    },
                    {
                        "username": "shekardaval",
                        "content": "for the string \\'(]\\' my code is working fine with python 3.7, but here its showing wrong output"
                    },
                    {
                        "username": "benjayy",
                        "content": "I fixed it by returning the boolean rather than the strings. "
                    },
                    {
                        "username": "Aleks_Kim",
                        "content": "[@gvolsky](/gvolsky) Thank you, it is really solution"
                    },
                    {
                        "username": "muqeetkhawaja",
                        "content": "[@gvolsky](/gvolsky) Thanks Brother."
                    },
                    {
                        "username": "gvolsky",
                        "content": "Maybe you, like me, return 'true' and 'false' as strings, not as booleans True and False."
                    },
                    {
                        "username": "wayneli-5",
                        "content": "[@saiharish_g](/saiharish_g) I have this issue too. Have you found a solution? Thank you!"
                    },
                    {
                        "username": "keerthisravanigude",
                        "content": "[@fizah](/fizah) ya same with me also\\n"
                    },
                    {
                        "username": "saiharish_g",
                        "content": "so have you find the real issue actually??"
                    },
                    {
                        "username": "fizah",
                        "content": "same"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "user8796tT",
                        "content": "whats wrong with this TC \"{[]}\" in custom test cases run it succeed but it fails on submission.  \\n![image](https://assets.leetcode.com/users/images/0a36f8a9-6403-4cb8-a073-933a7ded9abe_1609523958.1513097.png)\\n\""
                    },
                    {
                        "username": "ms0686714",
                        "content": "Might be a global variable issue.Make sure initialize the global variable in the begining of main function."
                    },
                    {
                        "username": "kanwarudaysingh",
                        "content": "I was asked to do this in o(1) memory in an interview! Anyone knows how to do that?"
                    },
                    {
                        "username": "0bro",
                        "content": "They probably also required 10 years experience in Rust (Rust came out 8 years ago) lol"
                    },
                    {
                        "username": "data-stack",
                        "content": "Well, you can solve it with a regular expression in O(1) space complexity "
                    },
                    {
                        "username": "rennasccenth",
                        "content": "[@psi_psi](/psi_psi) \"For every\" states something that needs to be iterated, which means nothing less than O(n)"
                    },
                    {
                        "username": "charonme",
                        "content": "I tried a stackless solution with O(1) additional space (not counting the in-place modification of the input string), but it\\'s O(n^2) time"
                    },
                    {
                        "username": "psi_psi",
                        "content": "For every closing char, repeat the search (recursively and repeatedly) backwards (and with inversed opening and closing chars) until you are out of string or you reach the next (in this case, previous) opening char in the string. If that next one is your corresponding opening char, you continue forwards. It is not going to be very fast."
                    },
                    {
                        "username": "astro12",
                        "content": "What is the company name? I\\'ll make sure I\\'ll add that to my blacklist"
                    },
                    {
                        "username": "jigar100",
                        "content": "Did the interviewer asked to do this in O(1) space by maintaining O(n) time complexity"
                    },
                    {
                        "username": "lwear2",
                        "content": "https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/715/introduction/4654/\\n\\nIn the section of Space Analysis it indicates that input and output arrays are not included in memory analysis for BigO.  So, cycle through the input as many times as necessary, modifying the array each time and don\\'t create any new storage space for the array."
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Did u find solution to do that as o1  (javscript)"
                    },
                    {
                        "username": "Alexander2049",
                        "content": "Description is not good enough. Should be shown some more test cases as \"( [ ) ]\", because \"Open brackets must be closed in the correct order\" could be missunderstood."
                    },
                    {
                        "username": "ananya_dash16",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) Same with me.\\n"
                    },
                    {
                        "username": "rahulschandak",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) I have the same doubt"
                    },
                    {
                        "username": "AnkushKrVerma",
                        "content": "yess even now i can\\'t understand the problem.\\nwhy the TC \"( [ ) ]\" returning false ???\\nhelp me understand the problem "
                    }
                ]
            },
            {
                "id": 1673405,
                "content": [
                    {
                        "username": "sunwangshu",
                        "content": "The brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\\n\\nFrom this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid. \\nThen I think the problem description should be updated."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "Exactly."
                    },
                    {
                        "username": "Awesome_7",
                        "content": "my code is expecting false for that in test case 70.\\ncan somebody look at this:\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        string opening=\"\";\\n        string closing=\"\";\\n\\n        for(auto i:s){\\n            if(i==\\'(\\' || i==\\'{\\' || i==\\'[\\' ){\\n                opening.push_back(i);\\n            }else{\\n                closing.push_back(i);\\n            }\\n        }\\n\\n        if(opening.length()!=closing.length()){\\n            return false;\\n        }\\n\\n        for(int i=0;i<opening.length();i++){\\n            if(opening[i]==\\'(\\'&& closing[i]!=\\')\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'{\\'&& closing[i]!=\\'}\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'[\\'&& closing[i]!=\\']\\'){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "chavaninc",
                        "content": "Came here to say this. Sadly I already had my submission wrong"
                    },
                    {
                        "username": "hkurmi",
                        "content": "exactly just got my first submission wrong becouse of this"
                    },
                    {
                        "username": "rafaelcitj",
                        "content": "[@D-Panda](/D-Panda) I had exact the same question after reading the description, thanks for clarifying."
                    },
                    {
                        "username": "rayhanul17",
                        "content": "[@hosua](/hosua) haha"
                    },
                    {
                        "username": "siddhanttamgadge4",
                        "content": "Yes it is allowed!"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua)  : )"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua) : ^)"
                    },
                    {
                        "username": "D-Panda",
                        "content": "it is valid"
                    },
                    {
                        "username": "hosua",
                        "content": "To answer your question 6 years later, yes, it is valid. "
                    },
                    {
                        "username": "rishavm",
                        "content": "Totally Agree! Due to lack of description in the question. My submission was rejected 3-4 times on the test cases which are not fulfilling the description of the problem. Although question is easy, but lack of description cause us time and our record."
                    },
                    {
                        "username": "omerkarabulut169",
                        "content": "Same my code 66/92 because of that"
                    },
                    {
                        "username": "minhtq9700",
                        "content": "yeah"
                    },
                    {
                        "username": "lwear2",
                        "content": "I agree.  Solved it twice from scratch only to find there are new requirements that manifest in testing.  Now I\\'m having to start again from scratch and pretty frustrated.  My second approach (recursive) simply won\\'t work in one submission test case.  This may be a little TOO real world for the learning environment.  There are classes in Requirements Engineering.  Like Agile and algorithms, they are very important to the professional.\\n\\nI strongly suggest clarifying the fact that the coder should allow for nested parentheses and that the nesting may be complex.\\n\\nRather than this wording, \"Open brackets must be closed in the CORRECT order.\"  (In whose mind?)\\n\\nI strongly suggest this: \"For strings that involve complex nesting, each bracket must be closed in the correct order.\"\\n\\nThis makes clear that \"correct\" is referring to nesting order, not front to back, or first open, or outside to inside, or some other \"correct\" order."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "sxltie",
                        "content": "precisely.. from the description one can\\u2019t even tell if (()) is valid or not.. they don\\u2019t include nested parentheses"
                    },
                    {
                        "username": "tonybrasunas",
                        "content": "The description for this one should say `([]{})` is valid too. Otherwise it's not clear that validating nested parentheses is part of the requirements."
                    },
                    {
                        "username": "bupty3e3",
                        "content": "Yeah, this question wasn\\'t that clear to this end."
                    },
                    {
                        "username": "ecapoferri",
                        "content": "Thanks for posting. I was wondering and went to discussion for clarification."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "bryanAM",
                        "content": "It\\'s a really **good** problem. But I don\\'t think it\\'s appropriate to call it **Easy**. If you\\'ve never had a question like this before, and if you\\'re new to python and programming - which is my guess the target audiance for easy questions - it\\'s a little difficult."
                    },
                    {
                        "username": "a098707730135",
                        "content": "[@JuanQP](/JuanQP) Thank you so much! You gave me the most useful hint!"
                    },
                    {
                        "username": "Rave17",
                        "content": "[@nicolobos77](/nicolobos77) thank you very much. this was crucial advice for leetcode newbie like me"
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "Totally agree. It isnt an easy problem."
                    },
                    {
                        "username": "gurunathkulkarni164",
                        "content": "You go to know stack for this problem."
                    },
                    {
                        "username": "JuanQP",
                        "content": "The only thing you need to solve this is knowing what a stack is. In first year of any engineering or comp-sci career you learn this in the first year"
                    },
                    {
                        "username": "nicolobos77",
                        "content": "It\\'s easy you just have to implement a memory managment with a char* as a stack in C, you push every open bracket, and pop one when there\\'s a close bracket that matches with the last opened bracket, if it doesn\\'t match, just return false, and if the string loop ended and there\\'s at least one bracket in the stack, return false, if it ends with an empty stack and every bracket is open and close correctly return true"
                    },
                    {
                        "username": "matthcraig",
                        "content": "The word \"easy\" in leetcode is a total misnomer and a relative description.  There are no easy leetcode questions.  "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "ikr"
                    },
                    {
                        "username": "tryhard00",
                        "content": "This problem could be considered easy but only if you realized the crux of it. If you tried to do it using pure conditionals, which I did for the first 3 hours, you\\'re in for a very bad time. I finally gave up on conditionals when it had a nested within nested case. I was about to go 3d array to store each set but it was so logically complex I almost quit. Then I saw it. So this problem could considered medium if you didn\\'t see the easy answer. Overall, a very clever question. It had so many caveats that I kept getting rejected and it was giving me pstd by the end. lol. For those who are stuck, the hint is what goes in last must come out first."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "Your hint at the last helped me solve the problem quickly \\uD83D\\uDE0A. Thanks."
                    },
                    {
                        "username": "zaynahmad20",
                        "content": "You sure do know how to not spoil a question and give a good hint. Thanks lol"
                    },
                    {
                        "username": "ejaza",
                        "content": "wow man thanks a great hint now i am able to do it \"the hint is what goes in last must come out first.\""
                    },
                    {
                        "username": "johnopj",
                        "content": "Exactly!! The door opened last should be closed first."
                    },
                    {
                        "username": "devindesu",
                        "content": "Mother $^#& I spent much more than 3 hours trying to force it to work with nested conditionals...Thank you for the hint. If they're gonna classify this as Easy they should at least defined the stack class for us  lol"
                    },
                    {
                        "username": "amitkhedkar41",
                        "content": "From this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid.\\nThen I think the problem description should be updated"
                    },
                    {
                        "username": "meergato247",
                        "content": "Exactly. I assumed the pairs just had to be {} () or [], the problem statement never said anything about them possibly being inside one another. "
                    },
                    {
                        "username": "RSK_Ua",
                        "content": "Here is some tip:\\nThe first line of the function uses a guard statement to check if the length of the input string is even. If the length is odd, the function returns false because it means that the brackets are not properly balanced.\\nThe next line creates an empty stack of characters to store the opening brackets.\\nThe function then loops through each character item in the input string s.\\nFor each character item, the code checks whether it is an opening bracket: (, [, or {. If it is, the corresponding closing bracket is pushed onto the stack. For example, if the character is (, the character ) is pushed onto the stack.\\nIf the character is a closing bracket: ), ], or }, the code checks whether the stack is empty. If the stack is empty, it means that there is no opening bracket to match the closing bracket, so the function returns false. If the stack is not empty, the last opening bracket is removed from the stack and checked against the current closing bracket. If the brackets do not match, the function returns false.\\nAfter looping through all the characters in the input string, the function checks whether the stack is empty. If it is, it means that all the opening brackets have been matched with their corresponding closing brackets, so the function returns true. If the stack is not empty, it means that there are unmatched opening brackets, so the function returns false."
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "well explained, I managed to create a solution based on your logic. Thanks a lot\\n"
                    },
                    {
                        "username": "shekardaval",
                        "content": "for the string \\'(]\\' my code is working fine with python 3.7, but here its showing wrong output"
                    },
                    {
                        "username": "benjayy",
                        "content": "I fixed it by returning the boolean rather than the strings. "
                    },
                    {
                        "username": "Aleks_Kim",
                        "content": "[@gvolsky](/gvolsky) Thank you, it is really solution"
                    },
                    {
                        "username": "muqeetkhawaja",
                        "content": "[@gvolsky](/gvolsky) Thanks Brother."
                    },
                    {
                        "username": "gvolsky",
                        "content": "Maybe you, like me, return 'true' and 'false' as strings, not as booleans True and False."
                    },
                    {
                        "username": "wayneli-5",
                        "content": "[@saiharish_g](/saiharish_g) I have this issue too. Have you found a solution? Thank you!"
                    },
                    {
                        "username": "keerthisravanigude",
                        "content": "[@fizah](/fizah) ya same with me also\\n"
                    },
                    {
                        "username": "saiharish_g",
                        "content": "so have you find the real issue actually??"
                    },
                    {
                        "username": "fizah",
                        "content": "same"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "user8796tT",
                        "content": "whats wrong with this TC \"{[]}\" in custom test cases run it succeed but it fails on submission.  \\n![image](https://assets.leetcode.com/users/images/0a36f8a9-6403-4cb8-a073-933a7ded9abe_1609523958.1513097.png)\\n\""
                    },
                    {
                        "username": "ms0686714",
                        "content": "Might be a global variable issue.Make sure initialize the global variable in the begining of main function."
                    },
                    {
                        "username": "kanwarudaysingh",
                        "content": "I was asked to do this in o(1) memory in an interview! Anyone knows how to do that?"
                    },
                    {
                        "username": "0bro",
                        "content": "They probably also required 10 years experience in Rust (Rust came out 8 years ago) lol"
                    },
                    {
                        "username": "data-stack",
                        "content": "Well, you can solve it with a regular expression in O(1) space complexity "
                    },
                    {
                        "username": "rennasccenth",
                        "content": "[@psi_psi](/psi_psi) \"For every\" states something that needs to be iterated, which means nothing less than O(n)"
                    },
                    {
                        "username": "charonme",
                        "content": "I tried a stackless solution with O(1) additional space (not counting the in-place modification of the input string), but it\\'s O(n^2) time"
                    },
                    {
                        "username": "psi_psi",
                        "content": "For every closing char, repeat the search (recursively and repeatedly) backwards (and with inversed opening and closing chars) until you are out of string or you reach the next (in this case, previous) opening char in the string. If that next one is your corresponding opening char, you continue forwards. It is not going to be very fast."
                    },
                    {
                        "username": "astro12",
                        "content": "What is the company name? I\\'ll make sure I\\'ll add that to my blacklist"
                    },
                    {
                        "username": "jigar100",
                        "content": "Did the interviewer asked to do this in O(1) space by maintaining O(n) time complexity"
                    },
                    {
                        "username": "lwear2",
                        "content": "https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/715/introduction/4654/\\n\\nIn the section of Space Analysis it indicates that input and output arrays are not included in memory analysis for BigO.  So, cycle through the input as many times as necessary, modifying the array each time and don\\'t create any new storage space for the array."
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Did u find solution to do that as o1  (javscript)"
                    },
                    {
                        "username": "Alexander2049",
                        "content": "Description is not good enough. Should be shown some more test cases as \"( [ ) ]\", because \"Open brackets must be closed in the correct order\" could be missunderstood."
                    },
                    {
                        "username": "ananya_dash16",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) Same with me.\\n"
                    },
                    {
                        "username": "rahulschandak",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) I have the same doubt"
                    },
                    {
                        "username": "AnkushKrVerma",
                        "content": "yess even now i can\\'t understand the problem.\\nwhy the TC \"( [ ) ]\" returning false ???\\nhelp me understand the problem "
                    }
                ]
            },
            {
                "id": 1875337,
                "content": [
                    {
                        "username": "sunwangshu",
                        "content": "The brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\\n\\nFrom this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid. \\nThen I think the problem description should be updated."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "Exactly."
                    },
                    {
                        "username": "Awesome_7",
                        "content": "my code is expecting false for that in test case 70.\\ncan somebody look at this:\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        string opening=\"\";\\n        string closing=\"\";\\n\\n        for(auto i:s){\\n            if(i==\\'(\\' || i==\\'{\\' || i==\\'[\\' ){\\n                opening.push_back(i);\\n            }else{\\n                closing.push_back(i);\\n            }\\n        }\\n\\n        if(opening.length()!=closing.length()){\\n            return false;\\n        }\\n\\n        for(int i=0;i<opening.length();i++){\\n            if(opening[i]==\\'(\\'&& closing[i]!=\\')\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'{\\'&& closing[i]!=\\'}\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'[\\'&& closing[i]!=\\']\\'){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "chavaninc",
                        "content": "Came here to say this. Sadly I already had my submission wrong"
                    },
                    {
                        "username": "hkurmi",
                        "content": "exactly just got my first submission wrong becouse of this"
                    },
                    {
                        "username": "rafaelcitj",
                        "content": "[@D-Panda](/D-Panda) I had exact the same question after reading the description, thanks for clarifying."
                    },
                    {
                        "username": "rayhanul17",
                        "content": "[@hosua](/hosua) haha"
                    },
                    {
                        "username": "siddhanttamgadge4",
                        "content": "Yes it is allowed!"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua)  : )"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua) : ^)"
                    },
                    {
                        "username": "D-Panda",
                        "content": "it is valid"
                    },
                    {
                        "username": "hosua",
                        "content": "To answer your question 6 years later, yes, it is valid. "
                    },
                    {
                        "username": "rishavm",
                        "content": "Totally Agree! Due to lack of description in the question. My submission was rejected 3-4 times on the test cases which are not fulfilling the description of the problem. Although question is easy, but lack of description cause us time and our record."
                    },
                    {
                        "username": "omerkarabulut169",
                        "content": "Same my code 66/92 because of that"
                    },
                    {
                        "username": "minhtq9700",
                        "content": "yeah"
                    },
                    {
                        "username": "lwear2",
                        "content": "I agree.  Solved it twice from scratch only to find there are new requirements that manifest in testing.  Now I\\'m having to start again from scratch and pretty frustrated.  My second approach (recursive) simply won\\'t work in one submission test case.  This may be a little TOO real world for the learning environment.  There are classes in Requirements Engineering.  Like Agile and algorithms, they are very important to the professional.\\n\\nI strongly suggest clarifying the fact that the coder should allow for nested parentheses and that the nesting may be complex.\\n\\nRather than this wording, \"Open brackets must be closed in the CORRECT order.\"  (In whose mind?)\\n\\nI strongly suggest this: \"For strings that involve complex nesting, each bracket must be closed in the correct order.\"\\n\\nThis makes clear that \"correct\" is referring to nesting order, not front to back, or first open, or outside to inside, or some other \"correct\" order."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "sxltie",
                        "content": "precisely.. from the description one can\\u2019t even tell if (()) is valid or not.. they don\\u2019t include nested parentheses"
                    },
                    {
                        "username": "tonybrasunas",
                        "content": "The description for this one should say `([]{})` is valid too. Otherwise it's not clear that validating nested parentheses is part of the requirements."
                    },
                    {
                        "username": "bupty3e3",
                        "content": "Yeah, this question wasn\\'t that clear to this end."
                    },
                    {
                        "username": "ecapoferri",
                        "content": "Thanks for posting. I was wondering and went to discussion for clarification."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "bryanAM",
                        "content": "It\\'s a really **good** problem. But I don\\'t think it\\'s appropriate to call it **Easy**. If you\\'ve never had a question like this before, and if you\\'re new to python and programming - which is my guess the target audiance for easy questions - it\\'s a little difficult."
                    },
                    {
                        "username": "a098707730135",
                        "content": "[@JuanQP](/JuanQP) Thank you so much! You gave me the most useful hint!"
                    },
                    {
                        "username": "Rave17",
                        "content": "[@nicolobos77](/nicolobos77) thank you very much. this was crucial advice for leetcode newbie like me"
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "Totally agree. It isnt an easy problem."
                    },
                    {
                        "username": "gurunathkulkarni164",
                        "content": "You go to know stack for this problem."
                    },
                    {
                        "username": "JuanQP",
                        "content": "The only thing you need to solve this is knowing what a stack is. In first year of any engineering or comp-sci career you learn this in the first year"
                    },
                    {
                        "username": "nicolobos77",
                        "content": "It\\'s easy you just have to implement a memory managment with a char* as a stack in C, you push every open bracket, and pop one when there\\'s a close bracket that matches with the last opened bracket, if it doesn\\'t match, just return false, and if the string loop ended and there\\'s at least one bracket in the stack, return false, if it ends with an empty stack and every bracket is open and close correctly return true"
                    },
                    {
                        "username": "matthcraig",
                        "content": "The word \"easy\" in leetcode is a total misnomer and a relative description.  There are no easy leetcode questions.  "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "ikr"
                    },
                    {
                        "username": "tryhard00",
                        "content": "This problem could be considered easy but only if you realized the crux of it. If you tried to do it using pure conditionals, which I did for the first 3 hours, you\\'re in for a very bad time. I finally gave up on conditionals when it had a nested within nested case. I was about to go 3d array to store each set but it was so logically complex I almost quit. Then I saw it. So this problem could considered medium if you didn\\'t see the easy answer. Overall, a very clever question. It had so many caveats that I kept getting rejected and it was giving me pstd by the end. lol. For those who are stuck, the hint is what goes in last must come out first."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "Your hint at the last helped me solve the problem quickly \\uD83D\\uDE0A. Thanks."
                    },
                    {
                        "username": "zaynahmad20",
                        "content": "You sure do know how to not spoil a question and give a good hint. Thanks lol"
                    },
                    {
                        "username": "ejaza",
                        "content": "wow man thanks a great hint now i am able to do it \"the hint is what goes in last must come out first.\""
                    },
                    {
                        "username": "johnopj",
                        "content": "Exactly!! The door opened last should be closed first."
                    },
                    {
                        "username": "devindesu",
                        "content": "Mother $^#& I spent much more than 3 hours trying to force it to work with nested conditionals...Thank you for the hint. If they're gonna classify this as Easy they should at least defined the stack class for us  lol"
                    },
                    {
                        "username": "amitkhedkar41",
                        "content": "From this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid.\\nThen I think the problem description should be updated"
                    },
                    {
                        "username": "meergato247",
                        "content": "Exactly. I assumed the pairs just had to be {} () or [], the problem statement never said anything about them possibly being inside one another. "
                    },
                    {
                        "username": "RSK_Ua",
                        "content": "Here is some tip:\\nThe first line of the function uses a guard statement to check if the length of the input string is even. If the length is odd, the function returns false because it means that the brackets are not properly balanced.\\nThe next line creates an empty stack of characters to store the opening brackets.\\nThe function then loops through each character item in the input string s.\\nFor each character item, the code checks whether it is an opening bracket: (, [, or {. If it is, the corresponding closing bracket is pushed onto the stack. For example, if the character is (, the character ) is pushed onto the stack.\\nIf the character is a closing bracket: ), ], or }, the code checks whether the stack is empty. If the stack is empty, it means that there is no opening bracket to match the closing bracket, so the function returns false. If the stack is not empty, the last opening bracket is removed from the stack and checked against the current closing bracket. If the brackets do not match, the function returns false.\\nAfter looping through all the characters in the input string, the function checks whether the stack is empty. If it is, it means that all the opening brackets have been matched with their corresponding closing brackets, so the function returns true. If the stack is not empty, it means that there are unmatched opening brackets, so the function returns false."
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "well explained, I managed to create a solution based on your logic. Thanks a lot\\n"
                    },
                    {
                        "username": "shekardaval",
                        "content": "for the string \\'(]\\' my code is working fine with python 3.7, but here its showing wrong output"
                    },
                    {
                        "username": "benjayy",
                        "content": "I fixed it by returning the boolean rather than the strings. "
                    },
                    {
                        "username": "Aleks_Kim",
                        "content": "[@gvolsky](/gvolsky) Thank you, it is really solution"
                    },
                    {
                        "username": "muqeetkhawaja",
                        "content": "[@gvolsky](/gvolsky) Thanks Brother."
                    },
                    {
                        "username": "gvolsky",
                        "content": "Maybe you, like me, return 'true' and 'false' as strings, not as booleans True and False."
                    },
                    {
                        "username": "wayneli-5",
                        "content": "[@saiharish_g](/saiharish_g) I have this issue too. Have you found a solution? Thank you!"
                    },
                    {
                        "username": "keerthisravanigude",
                        "content": "[@fizah](/fizah) ya same with me also\\n"
                    },
                    {
                        "username": "saiharish_g",
                        "content": "so have you find the real issue actually??"
                    },
                    {
                        "username": "fizah",
                        "content": "same"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "user8796tT",
                        "content": "whats wrong with this TC \"{[]}\" in custom test cases run it succeed but it fails on submission.  \\n![image](https://assets.leetcode.com/users/images/0a36f8a9-6403-4cb8-a073-933a7ded9abe_1609523958.1513097.png)\\n\""
                    },
                    {
                        "username": "ms0686714",
                        "content": "Might be a global variable issue.Make sure initialize the global variable in the begining of main function."
                    },
                    {
                        "username": "kanwarudaysingh",
                        "content": "I was asked to do this in o(1) memory in an interview! Anyone knows how to do that?"
                    },
                    {
                        "username": "0bro",
                        "content": "They probably also required 10 years experience in Rust (Rust came out 8 years ago) lol"
                    },
                    {
                        "username": "data-stack",
                        "content": "Well, you can solve it with a regular expression in O(1) space complexity "
                    },
                    {
                        "username": "rennasccenth",
                        "content": "[@psi_psi](/psi_psi) \"For every\" states something that needs to be iterated, which means nothing less than O(n)"
                    },
                    {
                        "username": "charonme",
                        "content": "I tried a stackless solution with O(1) additional space (not counting the in-place modification of the input string), but it\\'s O(n^2) time"
                    },
                    {
                        "username": "psi_psi",
                        "content": "For every closing char, repeat the search (recursively and repeatedly) backwards (and with inversed opening and closing chars) until you are out of string or you reach the next (in this case, previous) opening char in the string. If that next one is your corresponding opening char, you continue forwards. It is not going to be very fast."
                    },
                    {
                        "username": "astro12",
                        "content": "What is the company name? I\\'ll make sure I\\'ll add that to my blacklist"
                    },
                    {
                        "username": "jigar100",
                        "content": "Did the interviewer asked to do this in O(1) space by maintaining O(n) time complexity"
                    },
                    {
                        "username": "lwear2",
                        "content": "https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/715/introduction/4654/\\n\\nIn the section of Space Analysis it indicates that input and output arrays are not included in memory analysis for BigO.  So, cycle through the input as many times as necessary, modifying the array each time and don\\'t create any new storage space for the array."
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Did u find solution to do that as o1  (javscript)"
                    },
                    {
                        "username": "Alexander2049",
                        "content": "Description is not good enough. Should be shown some more test cases as \"( [ ) ]\", because \"Open brackets must be closed in the correct order\" could be missunderstood."
                    },
                    {
                        "username": "ananya_dash16",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) Same with me.\\n"
                    },
                    {
                        "username": "rahulschandak",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) I have the same doubt"
                    },
                    {
                        "username": "AnkushKrVerma",
                        "content": "yess even now i can\\'t understand the problem.\\nwhy the TC \"( [ ) ]\" returning false ???\\nhelp me understand the problem "
                    }
                ]
            },
            {
                "id": 1569769,
                "content": [
                    {
                        "username": "sunwangshu",
                        "content": "The brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\\n\\nFrom this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid. \\nThen I think the problem description should be updated."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "Exactly."
                    },
                    {
                        "username": "Awesome_7",
                        "content": "my code is expecting false for that in test case 70.\\ncan somebody look at this:\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        string opening=\"\";\\n        string closing=\"\";\\n\\n        for(auto i:s){\\n            if(i==\\'(\\' || i==\\'{\\' || i==\\'[\\' ){\\n                opening.push_back(i);\\n            }else{\\n                closing.push_back(i);\\n            }\\n        }\\n\\n        if(opening.length()!=closing.length()){\\n            return false;\\n        }\\n\\n        for(int i=0;i<opening.length();i++){\\n            if(opening[i]==\\'(\\'&& closing[i]!=\\')\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'{\\'&& closing[i]!=\\'}\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'[\\'&& closing[i]!=\\']\\'){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "chavaninc",
                        "content": "Came here to say this. Sadly I already had my submission wrong"
                    },
                    {
                        "username": "hkurmi",
                        "content": "exactly just got my first submission wrong becouse of this"
                    },
                    {
                        "username": "rafaelcitj",
                        "content": "[@D-Panda](/D-Panda) I had exact the same question after reading the description, thanks for clarifying."
                    },
                    {
                        "username": "rayhanul17",
                        "content": "[@hosua](/hosua) haha"
                    },
                    {
                        "username": "siddhanttamgadge4",
                        "content": "Yes it is allowed!"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua)  : )"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua) : ^)"
                    },
                    {
                        "username": "D-Panda",
                        "content": "it is valid"
                    },
                    {
                        "username": "hosua",
                        "content": "To answer your question 6 years later, yes, it is valid. "
                    },
                    {
                        "username": "rishavm",
                        "content": "Totally Agree! Due to lack of description in the question. My submission was rejected 3-4 times on the test cases which are not fulfilling the description of the problem. Although question is easy, but lack of description cause us time and our record."
                    },
                    {
                        "username": "omerkarabulut169",
                        "content": "Same my code 66/92 because of that"
                    },
                    {
                        "username": "minhtq9700",
                        "content": "yeah"
                    },
                    {
                        "username": "lwear2",
                        "content": "I agree.  Solved it twice from scratch only to find there are new requirements that manifest in testing.  Now I\\'m having to start again from scratch and pretty frustrated.  My second approach (recursive) simply won\\'t work in one submission test case.  This may be a little TOO real world for the learning environment.  There are classes in Requirements Engineering.  Like Agile and algorithms, they are very important to the professional.\\n\\nI strongly suggest clarifying the fact that the coder should allow for nested parentheses and that the nesting may be complex.\\n\\nRather than this wording, \"Open brackets must be closed in the CORRECT order.\"  (In whose mind?)\\n\\nI strongly suggest this: \"For strings that involve complex nesting, each bracket must be closed in the correct order.\"\\n\\nThis makes clear that \"correct\" is referring to nesting order, not front to back, or first open, or outside to inside, or some other \"correct\" order."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "sxltie",
                        "content": "precisely.. from the description one can\\u2019t even tell if (()) is valid or not.. they don\\u2019t include nested parentheses"
                    },
                    {
                        "username": "tonybrasunas",
                        "content": "The description for this one should say `([]{})` is valid too. Otherwise it's not clear that validating nested parentheses is part of the requirements."
                    },
                    {
                        "username": "bupty3e3",
                        "content": "Yeah, this question wasn\\'t that clear to this end."
                    },
                    {
                        "username": "ecapoferri",
                        "content": "Thanks for posting. I was wondering and went to discussion for clarification."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "bryanAM",
                        "content": "It\\'s a really **good** problem. But I don\\'t think it\\'s appropriate to call it **Easy**. If you\\'ve never had a question like this before, and if you\\'re new to python and programming - which is my guess the target audiance for easy questions - it\\'s a little difficult."
                    },
                    {
                        "username": "a098707730135",
                        "content": "[@JuanQP](/JuanQP) Thank you so much! You gave me the most useful hint!"
                    },
                    {
                        "username": "Rave17",
                        "content": "[@nicolobos77](/nicolobos77) thank you very much. this was crucial advice for leetcode newbie like me"
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "Totally agree. It isnt an easy problem."
                    },
                    {
                        "username": "gurunathkulkarni164",
                        "content": "You go to know stack for this problem."
                    },
                    {
                        "username": "JuanQP",
                        "content": "The only thing you need to solve this is knowing what a stack is. In first year of any engineering or comp-sci career you learn this in the first year"
                    },
                    {
                        "username": "nicolobos77",
                        "content": "It\\'s easy you just have to implement a memory managment with a char* as a stack in C, you push every open bracket, and pop one when there\\'s a close bracket that matches with the last opened bracket, if it doesn\\'t match, just return false, and if the string loop ended and there\\'s at least one bracket in the stack, return false, if it ends with an empty stack and every bracket is open and close correctly return true"
                    },
                    {
                        "username": "matthcraig",
                        "content": "The word \"easy\" in leetcode is a total misnomer and a relative description.  There are no easy leetcode questions.  "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "ikr"
                    },
                    {
                        "username": "tryhard00",
                        "content": "This problem could be considered easy but only if you realized the crux of it. If you tried to do it using pure conditionals, which I did for the first 3 hours, you\\'re in for a very bad time. I finally gave up on conditionals when it had a nested within nested case. I was about to go 3d array to store each set but it was so logically complex I almost quit. Then I saw it. So this problem could considered medium if you didn\\'t see the easy answer. Overall, a very clever question. It had so many caveats that I kept getting rejected and it was giving me pstd by the end. lol. For those who are stuck, the hint is what goes in last must come out first."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "Your hint at the last helped me solve the problem quickly \\uD83D\\uDE0A. Thanks."
                    },
                    {
                        "username": "zaynahmad20",
                        "content": "You sure do know how to not spoil a question and give a good hint. Thanks lol"
                    },
                    {
                        "username": "ejaza",
                        "content": "wow man thanks a great hint now i am able to do it \"the hint is what goes in last must come out first.\""
                    },
                    {
                        "username": "johnopj",
                        "content": "Exactly!! The door opened last should be closed first."
                    },
                    {
                        "username": "devindesu",
                        "content": "Mother $^#& I spent much more than 3 hours trying to force it to work with nested conditionals...Thank you for the hint. If they're gonna classify this as Easy they should at least defined the stack class for us  lol"
                    },
                    {
                        "username": "amitkhedkar41",
                        "content": "From this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid.\\nThen I think the problem description should be updated"
                    },
                    {
                        "username": "meergato247",
                        "content": "Exactly. I assumed the pairs just had to be {} () or [], the problem statement never said anything about them possibly being inside one another. "
                    },
                    {
                        "username": "RSK_Ua",
                        "content": "Here is some tip:\\nThe first line of the function uses a guard statement to check if the length of the input string is even. If the length is odd, the function returns false because it means that the brackets are not properly balanced.\\nThe next line creates an empty stack of characters to store the opening brackets.\\nThe function then loops through each character item in the input string s.\\nFor each character item, the code checks whether it is an opening bracket: (, [, or {. If it is, the corresponding closing bracket is pushed onto the stack. For example, if the character is (, the character ) is pushed onto the stack.\\nIf the character is a closing bracket: ), ], or }, the code checks whether the stack is empty. If the stack is empty, it means that there is no opening bracket to match the closing bracket, so the function returns false. If the stack is not empty, the last opening bracket is removed from the stack and checked against the current closing bracket. If the brackets do not match, the function returns false.\\nAfter looping through all the characters in the input string, the function checks whether the stack is empty. If it is, it means that all the opening brackets have been matched with their corresponding closing brackets, so the function returns true. If the stack is not empty, it means that there are unmatched opening brackets, so the function returns false."
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "well explained, I managed to create a solution based on your logic. Thanks a lot\\n"
                    },
                    {
                        "username": "shekardaval",
                        "content": "for the string \\'(]\\' my code is working fine with python 3.7, but here its showing wrong output"
                    },
                    {
                        "username": "benjayy",
                        "content": "I fixed it by returning the boolean rather than the strings. "
                    },
                    {
                        "username": "Aleks_Kim",
                        "content": "[@gvolsky](/gvolsky) Thank you, it is really solution"
                    },
                    {
                        "username": "muqeetkhawaja",
                        "content": "[@gvolsky](/gvolsky) Thanks Brother."
                    },
                    {
                        "username": "gvolsky",
                        "content": "Maybe you, like me, return 'true' and 'false' as strings, not as booleans True and False."
                    },
                    {
                        "username": "wayneli-5",
                        "content": "[@saiharish_g](/saiharish_g) I have this issue too. Have you found a solution? Thank you!"
                    },
                    {
                        "username": "keerthisravanigude",
                        "content": "[@fizah](/fizah) ya same with me also\\n"
                    },
                    {
                        "username": "saiharish_g",
                        "content": "so have you find the real issue actually??"
                    },
                    {
                        "username": "fizah",
                        "content": "same"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "user8796tT",
                        "content": "whats wrong with this TC \"{[]}\" in custom test cases run it succeed but it fails on submission.  \\n![image](https://assets.leetcode.com/users/images/0a36f8a9-6403-4cb8-a073-933a7ded9abe_1609523958.1513097.png)\\n\""
                    },
                    {
                        "username": "ms0686714",
                        "content": "Might be a global variable issue.Make sure initialize the global variable in the begining of main function."
                    },
                    {
                        "username": "kanwarudaysingh",
                        "content": "I was asked to do this in o(1) memory in an interview! Anyone knows how to do that?"
                    },
                    {
                        "username": "0bro",
                        "content": "They probably also required 10 years experience in Rust (Rust came out 8 years ago) lol"
                    },
                    {
                        "username": "data-stack",
                        "content": "Well, you can solve it with a regular expression in O(1) space complexity "
                    },
                    {
                        "username": "rennasccenth",
                        "content": "[@psi_psi](/psi_psi) \"For every\" states something that needs to be iterated, which means nothing less than O(n)"
                    },
                    {
                        "username": "charonme",
                        "content": "I tried a stackless solution with O(1) additional space (not counting the in-place modification of the input string), but it\\'s O(n^2) time"
                    },
                    {
                        "username": "psi_psi",
                        "content": "For every closing char, repeat the search (recursively and repeatedly) backwards (and with inversed opening and closing chars) until you are out of string or you reach the next (in this case, previous) opening char in the string. If that next one is your corresponding opening char, you continue forwards. It is not going to be very fast."
                    },
                    {
                        "username": "astro12",
                        "content": "What is the company name? I\\'ll make sure I\\'ll add that to my blacklist"
                    },
                    {
                        "username": "jigar100",
                        "content": "Did the interviewer asked to do this in O(1) space by maintaining O(n) time complexity"
                    },
                    {
                        "username": "lwear2",
                        "content": "https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/715/introduction/4654/\\n\\nIn the section of Space Analysis it indicates that input and output arrays are not included in memory analysis for BigO.  So, cycle through the input as many times as necessary, modifying the array each time and don\\'t create any new storage space for the array."
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Did u find solution to do that as o1  (javscript)"
                    },
                    {
                        "username": "Alexander2049",
                        "content": "Description is not good enough. Should be shown some more test cases as \"( [ ) ]\", because \"Open brackets must be closed in the correct order\" could be missunderstood."
                    },
                    {
                        "username": "ananya_dash16",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) Same with me.\\n"
                    },
                    {
                        "username": "rahulschandak",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) I have the same doubt"
                    },
                    {
                        "username": "AnkushKrVerma",
                        "content": "yess even now i can\\'t understand the problem.\\nwhy the TC \"( [ ) ]\" returning false ???\\nhelp me understand the problem "
                    }
                ]
            },
            {
                "id": 1570278,
                "content": [
                    {
                        "username": "sunwangshu",
                        "content": "The brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\\n\\nFrom this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid. \\nThen I think the problem description should be updated."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "Exactly."
                    },
                    {
                        "username": "Awesome_7",
                        "content": "my code is expecting false for that in test case 70.\\ncan somebody look at this:\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        string opening=\"\";\\n        string closing=\"\";\\n\\n        for(auto i:s){\\n            if(i==\\'(\\' || i==\\'{\\' || i==\\'[\\' ){\\n                opening.push_back(i);\\n            }else{\\n                closing.push_back(i);\\n            }\\n        }\\n\\n        if(opening.length()!=closing.length()){\\n            return false;\\n        }\\n\\n        for(int i=0;i<opening.length();i++){\\n            if(opening[i]==\\'(\\'&& closing[i]!=\\')\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'{\\'&& closing[i]!=\\'}\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'[\\'&& closing[i]!=\\']\\'){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "chavaninc",
                        "content": "Came here to say this. Sadly I already had my submission wrong"
                    },
                    {
                        "username": "hkurmi",
                        "content": "exactly just got my first submission wrong becouse of this"
                    },
                    {
                        "username": "rafaelcitj",
                        "content": "[@D-Panda](/D-Panda) I had exact the same question after reading the description, thanks for clarifying."
                    },
                    {
                        "username": "rayhanul17",
                        "content": "[@hosua](/hosua) haha"
                    },
                    {
                        "username": "siddhanttamgadge4",
                        "content": "Yes it is allowed!"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua)  : )"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua) : ^)"
                    },
                    {
                        "username": "D-Panda",
                        "content": "it is valid"
                    },
                    {
                        "username": "hosua",
                        "content": "To answer your question 6 years later, yes, it is valid. "
                    },
                    {
                        "username": "rishavm",
                        "content": "Totally Agree! Due to lack of description in the question. My submission was rejected 3-4 times on the test cases which are not fulfilling the description of the problem. Although question is easy, but lack of description cause us time and our record."
                    },
                    {
                        "username": "omerkarabulut169",
                        "content": "Same my code 66/92 because of that"
                    },
                    {
                        "username": "minhtq9700",
                        "content": "yeah"
                    },
                    {
                        "username": "lwear2",
                        "content": "I agree.  Solved it twice from scratch only to find there are new requirements that manifest in testing.  Now I\\'m having to start again from scratch and pretty frustrated.  My second approach (recursive) simply won\\'t work in one submission test case.  This may be a little TOO real world for the learning environment.  There are classes in Requirements Engineering.  Like Agile and algorithms, they are very important to the professional.\\n\\nI strongly suggest clarifying the fact that the coder should allow for nested parentheses and that the nesting may be complex.\\n\\nRather than this wording, \"Open brackets must be closed in the CORRECT order.\"  (In whose mind?)\\n\\nI strongly suggest this: \"For strings that involve complex nesting, each bracket must be closed in the correct order.\"\\n\\nThis makes clear that \"correct\" is referring to nesting order, not front to back, or first open, or outside to inside, or some other \"correct\" order."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "sxltie",
                        "content": "precisely.. from the description one can\\u2019t even tell if (()) is valid or not.. they don\\u2019t include nested parentheses"
                    },
                    {
                        "username": "tonybrasunas",
                        "content": "The description for this one should say `([]{})` is valid too. Otherwise it's not clear that validating nested parentheses is part of the requirements."
                    },
                    {
                        "username": "bupty3e3",
                        "content": "Yeah, this question wasn\\'t that clear to this end."
                    },
                    {
                        "username": "ecapoferri",
                        "content": "Thanks for posting. I was wondering and went to discussion for clarification."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "bryanAM",
                        "content": "It\\'s a really **good** problem. But I don\\'t think it\\'s appropriate to call it **Easy**. If you\\'ve never had a question like this before, and if you\\'re new to python and programming - which is my guess the target audiance for easy questions - it\\'s a little difficult."
                    },
                    {
                        "username": "a098707730135",
                        "content": "[@JuanQP](/JuanQP) Thank you so much! You gave me the most useful hint!"
                    },
                    {
                        "username": "Rave17",
                        "content": "[@nicolobos77](/nicolobos77) thank you very much. this was crucial advice for leetcode newbie like me"
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "Totally agree. It isnt an easy problem."
                    },
                    {
                        "username": "gurunathkulkarni164",
                        "content": "You go to know stack for this problem."
                    },
                    {
                        "username": "JuanQP",
                        "content": "The only thing you need to solve this is knowing what a stack is. In first year of any engineering or comp-sci career you learn this in the first year"
                    },
                    {
                        "username": "nicolobos77",
                        "content": "It\\'s easy you just have to implement a memory managment with a char* as a stack in C, you push every open bracket, and pop one when there\\'s a close bracket that matches with the last opened bracket, if it doesn\\'t match, just return false, and if the string loop ended and there\\'s at least one bracket in the stack, return false, if it ends with an empty stack and every bracket is open and close correctly return true"
                    },
                    {
                        "username": "matthcraig",
                        "content": "The word \"easy\" in leetcode is a total misnomer and a relative description.  There are no easy leetcode questions.  "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "ikr"
                    },
                    {
                        "username": "tryhard00",
                        "content": "This problem could be considered easy but only if you realized the crux of it. If you tried to do it using pure conditionals, which I did for the first 3 hours, you\\'re in for a very bad time. I finally gave up on conditionals when it had a nested within nested case. I was about to go 3d array to store each set but it was so logically complex I almost quit. Then I saw it. So this problem could considered medium if you didn\\'t see the easy answer. Overall, a very clever question. It had so many caveats that I kept getting rejected and it was giving me pstd by the end. lol. For those who are stuck, the hint is what goes in last must come out first."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "Your hint at the last helped me solve the problem quickly \\uD83D\\uDE0A. Thanks."
                    },
                    {
                        "username": "zaynahmad20",
                        "content": "You sure do know how to not spoil a question and give a good hint. Thanks lol"
                    },
                    {
                        "username": "ejaza",
                        "content": "wow man thanks a great hint now i am able to do it \"the hint is what goes in last must come out first.\""
                    },
                    {
                        "username": "johnopj",
                        "content": "Exactly!! The door opened last should be closed first."
                    },
                    {
                        "username": "devindesu",
                        "content": "Mother $^#& I spent much more than 3 hours trying to force it to work with nested conditionals...Thank you for the hint. If they're gonna classify this as Easy they should at least defined the stack class for us  lol"
                    },
                    {
                        "username": "amitkhedkar41",
                        "content": "From this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid.\\nThen I think the problem description should be updated"
                    },
                    {
                        "username": "meergato247",
                        "content": "Exactly. I assumed the pairs just had to be {} () or [], the problem statement never said anything about them possibly being inside one another. "
                    },
                    {
                        "username": "RSK_Ua",
                        "content": "Here is some tip:\\nThe first line of the function uses a guard statement to check if the length of the input string is even. If the length is odd, the function returns false because it means that the brackets are not properly balanced.\\nThe next line creates an empty stack of characters to store the opening brackets.\\nThe function then loops through each character item in the input string s.\\nFor each character item, the code checks whether it is an opening bracket: (, [, or {. If it is, the corresponding closing bracket is pushed onto the stack. For example, if the character is (, the character ) is pushed onto the stack.\\nIf the character is a closing bracket: ), ], or }, the code checks whether the stack is empty. If the stack is empty, it means that there is no opening bracket to match the closing bracket, so the function returns false. If the stack is not empty, the last opening bracket is removed from the stack and checked against the current closing bracket. If the brackets do not match, the function returns false.\\nAfter looping through all the characters in the input string, the function checks whether the stack is empty. If it is, it means that all the opening brackets have been matched with their corresponding closing brackets, so the function returns true. If the stack is not empty, it means that there are unmatched opening brackets, so the function returns false."
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "well explained, I managed to create a solution based on your logic. Thanks a lot\\n"
                    },
                    {
                        "username": "shekardaval",
                        "content": "for the string \\'(]\\' my code is working fine with python 3.7, but here its showing wrong output"
                    },
                    {
                        "username": "benjayy",
                        "content": "I fixed it by returning the boolean rather than the strings. "
                    },
                    {
                        "username": "Aleks_Kim",
                        "content": "[@gvolsky](/gvolsky) Thank you, it is really solution"
                    },
                    {
                        "username": "muqeetkhawaja",
                        "content": "[@gvolsky](/gvolsky) Thanks Brother."
                    },
                    {
                        "username": "gvolsky",
                        "content": "Maybe you, like me, return 'true' and 'false' as strings, not as booleans True and False."
                    },
                    {
                        "username": "wayneli-5",
                        "content": "[@saiharish_g](/saiharish_g) I have this issue too. Have you found a solution? Thank you!"
                    },
                    {
                        "username": "keerthisravanigude",
                        "content": "[@fizah](/fizah) ya same with me also\\n"
                    },
                    {
                        "username": "saiharish_g",
                        "content": "so have you find the real issue actually??"
                    },
                    {
                        "username": "fizah",
                        "content": "same"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "user8796tT",
                        "content": "whats wrong with this TC \"{[]}\" in custom test cases run it succeed but it fails on submission.  \\n![image](https://assets.leetcode.com/users/images/0a36f8a9-6403-4cb8-a073-933a7ded9abe_1609523958.1513097.png)\\n\""
                    },
                    {
                        "username": "ms0686714",
                        "content": "Might be a global variable issue.Make sure initialize the global variable in the begining of main function."
                    },
                    {
                        "username": "kanwarudaysingh",
                        "content": "I was asked to do this in o(1) memory in an interview! Anyone knows how to do that?"
                    },
                    {
                        "username": "0bro",
                        "content": "They probably also required 10 years experience in Rust (Rust came out 8 years ago) lol"
                    },
                    {
                        "username": "data-stack",
                        "content": "Well, you can solve it with a regular expression in O(1) space complexity "
                    },
                    {
                        "username": "rennasccenth",
                        "content": "[@psi_psi](/psi_psi) \"For every\" states something that needs to be iterated, which means nothing less than O(n)"
                    },
                    {
                        "username": "charonme",
                        "content": "I tried a stackless solution with O(1) additional space (not counting the in-place modification of the input string), but it\\'s O(n^2) time"
                    },
                    {
                        "username": "psi_psi",
                        "content": "For every closing char, repeat the search (recursively and repeatedly) backwards (and with inversed opening and closing chars) until you are out of string or you reach the next (in this case, previous) opening char in the string. If that next one is your corresponding opening char, you continue forwards. It is not going to be very fast."
                    },
                    {
                        "username": "astro12",
                        "content": "What is the company name? I\\'ll make sure I\\'ll add that to my blacklist"
                    },
                    {
                        "username": "jigar100",
                        "content": "Did the interviewer asked to do this in O(1) space by maintaining O(n) time complexity"
                    },
                    {
                        "username": "lwear2",
                        "content": "https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/715/introduction/4654/\\n\\nIn the section of Space Analysis it indicates that input and output arrays are not included in memory analysis for BigO.  So, cycle through the input as many times as necessary, modifying the array each time and don\\'t create any new storage space for the array."
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Did u find solution to do that as o1  (javscript)"
                    },
                    {
                        "username": "Alexander2049",
                        "content": "Description is not good enough. Should be shown some more test cases as \"( [ ) ]\", because \"Open brackets must be closed in the correct order\" could be missunderstood."
                    },
                    {
                        "username": "ananya_dash16",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) Same with me.\\n"
                    },
                    {
                        "username": "rahulschandak",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) I have the same doubt"
                    },
                    {
                        "username": "AnkushKrVerma",
                        "content": "yess even now i can\\'t understand the problem.\\nwhy the TC \"( [ ) ]\" returning false ???\\nhelp me understand the problem "
                    }
                ]
            },
            {
                "id": 1571051,
                "content": [
                    {
                        "username": "sunwangshu",
                        "content": "The brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\\n\\nFrom this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid. \\nThen I think the problem description should be updated."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "Exactly."
                    },
                    {
                        "username": "Awesome_7",
                        "content": "my code is expecting false for that in test case 70.\\ncan somebody look at this:\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        string opening=\"\";\\n        string closing=\"\";\\n\\n        for(auto i:s){\\n            if(i==\\'(\\' || i==\\'{\\' || i==\\'[\\' ){\\n                opening.push_back(i);\\n            }else{\\n                closing.push_back(i);\\n            }\\n        }\\n\\n        if(opening.length()!=closing.length()){\\n            return false;\\n        }\\n\\n        for(int i=0;i<opening.length();i++){\\n            if(opening[i]==\\'(\\'&& closing[i]!=\\')\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'{\\'&& closing[i]!=\\'}\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'[\\'&& closing[i]!=\\']\\'){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "chavaninc",
                        "content": "Came here to say this. Sadly I already had my submission wrong"
                    },
                    {
                        "username": "hkurmi",
                        "content": "exactly just got my first submission wrong becouse of this"
                    },
                    {
                        "username": "rafaelcitj",
                        "content": "[@D-Panda](/D-Panda) I had exact the same question after reading the description, thanks for clarifying."
                    },
                    {
                        "username": "rayhanul17",
                        "content": "[@hosua](/hosua) haha"
                    },
                    {
                        "username": "siddhanttamgadge4",
                        "content": "Yes it is allowed!"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua)  : )"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua) : ^)"
                    },
                    {
                        "username": "D-Panda",
                        "content": "it is valid"
                    },
                    {
                        "username": "hosua",
                        "content": "To answer your question 6 years later, yes, it is valid. "
                    },
                    {
                        "username": "rishavm",
                        "content": "Totally Agree! Due to lack of description in the question. My submission was rejected 3-4 times on the test cases which are not fulfilling the description of the problem. Although question is easy, but lack of description cause us time and our record."
                    },
                    {
                        "username": "omerkarabulut169",
                        "content": "Same my code 66/92 because of that"
                    },
                    {
                        "username": "minhtq9700",
                        "content": "yeah"
                    },
                    {
                        "username": "lwear2",
                        "content": "I agree.  Solved it twice from scratch only to find there are new requirements that manifest in testing.  Now I\\'m having to start again from scratch and pretty frustrated.  My second approach (recursive) simply won\\'t work in one submission test case.  This may be a little TOO real world for the learning environment.  There are classes in Requirements Engineering.  Like Agile and algorithms, they are very important to the professional.\\n\\nI strongly suggest clarifying the fact that the coder should allow for nested parentheses and that the nesting may be complex.\\n\\nRather than this wording, \"Open brackets must be closed in the CORRECT order.\"  (In whose mind?)\\n\\nI strongly suggest this: \"For strings that involve complex nesting, each bracket must be closed in the correct order.\"\\n\\nThis makes clear that \"correct\" is referring to nesting order, not front to back, or first open, or outside to inside, or some other \"correct\" order."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "sxltie",
                        "content": "precisely.. from the description one can\\u2019t even tell if (()) is valid or not.. they don\\u2019t include nested parentheses"
                    },
                    {
                        "username": "tonybrasunas",
                        "content": "The description for this one should say `([]{})` is valid too. Otherwise it's not clear that validating nested parentheses is part of the requirements."
                    },
                    {
                        "username": "bupty3e3",
                        "content": "Yeah, this question wasn\\'t that clear to this end."
                    },
                    {
                        "username": "ecapoferri",
                        "content": "Thanks for posting. I was wondering and went to discussion for clarification."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "bryanAM",
                        "content": "It\\'s a really **good** problem. But I don\\'t think it\\'s appropriate to call it **Easy**. If you\\'ve never had a question like this before, and if you\\'re new to python and programming - which is my guess the target audiance for easy questions - it\\'s a little difficult."
                    },
                    {
                        "username": "a098707730135",
                        "content": "[@JuanQP](/JuanQP) Thank you so much! You gave me the most useful hint!"
                    },
                    {
                        "username": "Rave17",
                        "content": "[@nicolobos77](/nicolobos77) thank you very much. this was crucial advice for leetcode newbie like me"
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "Totally agree. It isnt an easy problem."
                    },
                    {
                        "username": "gurunathkulkarni164",
                        "content": "You go to know stack for this problem."
                    },
                    {
                        "username": "JuanQP",
                        "content": "The only thing you need to solve this is knowing what a stack is. In first year of any engineering or comp-sci career you learn this in the first year"
                    },
                    {
                        "username": "nicolobos77",
                        "content": "It\\'s easy you just have to implement a memory managment with a char* as a stack in C, you push every open bracket, and pop one when there\\'s a close bracket that matches with the last opened bracket, if it doesn\\'t match, just return false, and if the string loop ended and there\\'s at least one bracket in the stack, return false, if it ends with an empty stack and every bracket is open and close correctly return true"
                    },
                    {
                        "username": "matthcraig",
                        "content": "The word \"easy\" in leetcode is a total misnomer and a relative description.  There are no easy leetcode questions.  "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "ikr"
                    },
                    {
                        "username": "tryhard00",
                        "content": "This problem could be considered easy but only if you realized the crux of it. If you tried to do it using pure conditionals, which I did for the first 3 hours, you\\'re in for a very bad time. I finally gave up on conditionals when it had a nested within nested case. I was about to go 3d array to store each set but it was so logically complex I almost quit. Then I saw it. So this problem could considered medium if you didn\\'t see the easy answer. Overall, a very clever question. It had so many caveats that I kept getting rejected and it was giving me pstd by the end. lol. For those who are stuck, the hint is what goes in last must come out first."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "Your hint at the last helped me solve the problem quickly \\uD83D\\uDE0A. Thanks."
                    },
                    {
                        "username": "zaynahmad20",
                        "content": "You sure do know how to not spoil a question and give a good hint. Thanks lol"
                    },
                    {
                        "username": "ejaza",
                        "content": "wow man thanks a great hint now i am able to do it \"the hint is what goes in last must come out first.\""
                    },
                    {
                        "username": "johnopj",
                        "content": "Exactly!! The door opened last should be closed first."
                    },
                    {
                        "username": "devindesu",
                        "content": "Mother $^#& I spent much more than 3 hours trying to force it to work with nested conditionals...Thank you for the hint. If they're gonna classify this as Easy they should at least defined the stack class for us  lol"
                    },
                    {
                        "username": "amitkhedkar41",
                        "content": "From this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid.\\nThen I think the problem description should be updated"
                    },
                    {
                        "username": "meergato247",
                        "content": "Exactly. I assumed the pairs just had to be {} () or [], the problem statement never said anything about them possibly being inside one another. "
                    },
                    {
                        "username": "RSK_Ua",
                        "content": "Here is some tip:\\nThe first line of the function uses a guard statement to check if the length of the input string is even. If the length is odd, the function returns false because it means that the brackets are not properly balanced.\\nThe next line creates an empty stack of characters to store the opening brackets.\\nThe function then loops through each character item in the input string s.\\nFor each character item, the code checks whether it is an opening bracket: (, [, or {. If it is, the corresponding closing bracket is pushed onto the stack. For example, if the character is (, the character ) is pushed onto the stack.\\nIf the character is a closing bracket: ), ], or }, the code checks whether the stack is empty. If the stack is empty, it means that there is no opening bracket to match the closing bracket, so the function returns false. If the stack is not empty, the last opening bracket is removed from the stack and checked against the current closing bracket. If the brackets do not match, the function returns false.\\nAfter looping through all the characters in the input string, the function checks whether the stack is empty. If it is, it means that all the opening brackets have been matched with their corresponding closing brackets, so the function returns true. If the stack is not empty, it means that there are unmatched opening brackets, so the function returns false."
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "well explained, I managed to create a solution based on your logic. Thanks a lot\\n"
                    },
                    {
                        "username": "shekardaval",
                        "content": "for the string \\'(]\\' my code is working fine with python 3.7, but here its showing wrong output"
                    },
                    {
                        "username": "benjayy",
                        "content": "I fixed it by returning the boolean rather than the strings. "
                    },
                    {
                        "username": "Aleks_Kim",
                        "content": "[@gvolsky](/gvolsky) Thank you, it is really solution"
                    },
                    {
                        "username": "muqeetkhawaja",
                        "content": "[@gvolsky](/gvolsky) Thanks Brother."
                    },
                    {
                        "username": "gvolsky",
                        "content": "Maybe you, like me, return 'true' and 'false' as strings, not as booleans True and False."
                    },
                    {
                        "username": "wayneli-5",
                        "content": "[@saiharish_g](/saiharish_g) I have this issue too. Have you found a solution? Thank you!"
                    },
                    {
                        "username": "keerthisravanigude",
                        "content": "[@fizah](/fizah) ya same with me also\\n"
                    },
                    {
                        "username": "saiharish_g",
                        "content": "so have you find the real issue actually??"
                    },
                    {
                        "username": "fizah",
                        "content": "same"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "user8796tT",
                        "content": "whats wrong with this TC \"{[]}\" in custom test cases run it succeed but it fails on submission.  \\n![image](https://assets.leetcode.com/users/images/0a36f8a9-6403-4cb8-a073-933a7ded9abe_1609523958.1513097.png)\\n\""
                    },
                    {
                        "username": "ms0686714",
                        "content": "Might be a global variable issue.Make sure initialize the global variable in the begining of main function."
                    },
                    {
                        "username": "kanwarudaysingh",
                        "content": "I was asked to do this in o(1) memory in an interview! Anyone knows how to do that?"
                    },
                    {
                        "username": "0bro",
                        "content": "They probably also required 10 years experience in Rust (Rust came out 8 years ago) lol"
                    },
                    {
                        "username": "data-stack",
                        "content": "Well, you can solve it with a regular expression in O(1) space complexity "
                    },
                    {
                        "username": "rennasccenth",
                        "content": "[@psi_psi](/psi_psi) \"For every\" states something that needs to be iterated, which means nothing less than O(n)"
                    },
                    {
                        "username": "charonme",
                        "content": "I tried a stackless solution with O(1) additional space (not counting the in-place modification of the input string), but it\\'s O(n^2) time"
                    },
                    {
                        "username": "psi_psi",
                        "content": "For every closing char, repeat the search (recursively and repeatedly) backwards (and with inversed opening and closing chars) until you are out of string or you reach the next (in this case, previous) opening char in the string. If that next one is your corresponding opening char, you continue forwards. It is not going to be very fast."
                    },
                    {
                        "username": "astro12",
                        "content": "What is the company name? I\\'ll make sure I\\'ll add that to my blacklist"
                    },
                    {
                        "username": "jigar100",
                        "content": "Did the interviewer asked to do this in O(1) space by maintaining O(n) time complexity"
                    },
                    {
                        "username": "lwear2",
                        "content": "https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/715/introduction/4654/\\n\\nIn the section of Space Analysis it indicates that input and output arrays are not included in memory analysis for BigO.  So, cycle through the input as many times as necessary, modifying the array each time and don\\'t create any new storage space for the array."
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Did u find solution to do that as o1  (javscript)"
                    },
                    {
                        "username": "Alexander2049",
                        "content": "Description is not good enough. Should be shown some more test cases as \"( [ ) ]\", because \"Open brackets must be closed in the correct order\" could be missunderstood."
                    },
                    {
                        "username": "ananya_dash16",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) Same with me.\\n"
                    },
                    {
                        "username": "rahulschandak",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) I have the same doubt"
                    },
                    {
                        "username": "AnkushKrVerma",
                        "content": "yess even now i can\\'t understand the problem.\\nwhy the TC \"( [ ) ]\" returning false ???\\nhelp me understand the problem "
                    }
                ]
            },
            {
                "id": 1918267,
                "content": [
                    {
                        "username": "sunwangshu",
                        "content": "The brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\\n\\nFrom this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid. \\nThen I think the problem description should be updated."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "Exactly."
                    },
                    {
                        "username": "Awesome_7",
                        "content": "my code is expecting false for that in test case 70.\\ncan somebody look at this:\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        string opening=\"\";\\n        string closing=\"\";\\n\\n        for(auto i:s){\\n            if(i==\\'(\\' || i==\\'{\\' || i==\\'[\\' ){\\n                opening.push_back(i);\\n            }else{\\n                closing.push_back(i);\\n            }\\n        }\\n\\n        if(opening.length()!=closing.length()){\\n            return false;\\n        }\\n\\n        for(int i=0;i<opening.length();i++){\\n            if(opening[i]==\\'(\\'&& closing[i]!=\\')\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'{\\'&& closing[i]!=\\'}\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'[\\'&& closing[i]!=\\']\\'){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "chavaninc",
                        "content": "Came here to say this. Sadly I already had my submission wrong"
                    },
                    {
                        "username": "hkurmi",
                        "content": "exactly just got my first submission wrong becouse of this"
                    },
                    {
                        "username": "rafaelcitj",
                        "content": "[@D-Panda](/D-Panda) I had exact the same question after reading the description, thanks for clarifying."
                    },
                    {
                        "username": "rayhanul17",
                        "content": "[@hosua](/hosua) haha"
                    },
                    {
                        "username": "siddhanttamgadge4",
                        "content": "Yes it is allowed!"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua)  : )"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua) : ^)"
                    },
                    {
                        "username": "D-Panda",
                        "content": "it is valid"
                    },
                    {
                        "username": "hosua",
                        "content": "To answer your question 6 years later, yes, it is valid. "
                    },
                    {
                        "username": "rishavm",
                        "content": "Totally Agree! Due to lack of description in the question. My submission was rejected 3-4 times on the test cases which are not fulfilling the description of the problem. Although question is easy, but lack of description cause us time and our record."
                    },
                    {
                        "username": "omerkarabulut169",
                        "content": "Same my code 66/92 because of that"
                    },
                    {
                        "username": "minhtq9700",
                        "content": "yeah"
                    },
                    {
                        "username": "lwear2",
                        "content": "I agree.  Solved it twice from scratch only to find there are new requirements that manifest in testing.  Now I\\'m having to start again from scratch and pretty frustrated.  My second approach (recursive) simply won\\'t work in one submission test case.  This may be a little TOO real world for the learning environment.  There are classes in Requirements Engineering.  Like Agile and algorithms, they are very important to the professional.\\n\\nI strongly suggest clarifying the fact that the coder should allow for nested parentheses and that the nesting may be complex.\\n\\nRather than this wording, \"Open brackets must be closed in the CORRECT order.\"  (In whose mind?)\\n\\nI strongly suggest this: \"For strings that involve complex nesting, each bracket must be closed in the correct order.\"\\n\\nThis makes clear that \"correct\" is referring to nesting order, not front to back, or first open, or outside to inside, or some other \"correct\" order."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "sxltie",
                        "content": "precisely.. from the description one can\\u2019t even tell if (()) is valid or not.. they don\\u2019t include nested parentheses"
                    },
                    {
                        "username": "tonybrasunas",
                        "content": "The description for this one should say `([]{})` is valid too. Otherwise it's not clear that validating nested parentheses is part of the requirements."
                    },
                    {
                        "username": "bupty3e3",
                        "content": "Yeah, this question wasn\\'t that clear to this end."
                    },
                    {
                        "username": "ecapoferri",
                        "content": "Thanks for posting. I was wondering and went to discussion for clarification."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "bryanAM",
                        "content": "It\\'s a really **good** problem. But I don\\'t think it\\'s appropriate to call it **Easy**. If you\\'ve never had a question like this before, and if you\\'re new to python and programming - which is my guess the target audiance for easy questions - it\\'s a little difficult."
                    },
                    {
                        "username": "a098707730135",
                        "content": "[@JuanQP](/JuanQP) Thank you so much! You gave me the most useful hint!"
                    },
                    {
                        "username": "Rave17",
                        "content": "[@nicolobos77](/nicolobos77) thank you very much. this was crucial advice for leetcode newbie like me"
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "Totally agree. It isnt an easy problem."
                    },
                    {
                        "username": "gurunathkulkarni164",
                        "content": "You go to know stack for this problem."
                    },
                    {
                        "username": "JuanQP",
                        "content": "The only thing you need to solve this is knowing what a stack is. In first year of any engineering or comp-sci career you learn this in the first year"
                    },
                    {
                        "username": "nicolobos77",
                        "content": "It\\'s easy you just have to implement a memory managment with a char* as a stack in C, you push every open bracket, and pop one when there\\'s a close bracket that matches with the last opened bracket, if it doesn\\'t match, just return false, and if the string loop ended and there\\'s at least one bracket in the stack, return false, if it ends with an empty stack and every bracket is open and close correctly return true"
                    },
                    {
                        "username": "matthcraig",
                        "content": "The word \"easy\" in leetcode is a total misnomer and a relative description.  There are no easy leetcode questions.  "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "ikr"
                    },
                    {
                        "username": "tryhard00",
                        "content": "This problem could be considered easy but only if you realized the crux of it. If you tried to do it using pure conditionals, which I did for the first 3 hours, you\\'re in for a very bad time. I finally gave up on conditionals when it had a nested within nested case. I was about to go 3d array to store each set but it was so logically complex I almost quit. Then I saw it. So this problem could considered medium if you didn\\'t see the easy answer. Overall, a very clever question. It had so many caveats that I kept getting rejected and it was giving me pstd by the end. lol. For those who are stuck, the hint is what goes in last must come out first."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "Your hint at the last helped me solve the problem quickly \\uD83D\\uDE0A. Thanks."
                    },
                    {
                        "username": "zaynahmad20",
                        "content": "You sure do know how to not spoil a question and give a good hint. Thanks lol"
                    },
                    {
                        "username": "ejaza",
                        "content": "wow man thanks a great hint now i am able to do it \"the hint is what goes in last must come out first.\""
                    },
                    {
                        "username": "johnopj",
                        "content": "Exactly!! The door opened last should be closed first."
                    },
                    {
                        "username": "devindesu",
                        "content": "Mother $^#& I spent much more than 3 hours trying to force it to work with nested conditionals...Thank you for the hint. If they're gonna classify this as Easy they should at least defined the stack class for us  lol"
                    },
                    {
                        "username": "amitkhedkar41",
                        "content": "From this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid.\\nThen I think the problem description should be updated"
                    },
                    {
                        "username": "meergato247",
                        "content": "Exactly. I assumed the pairs just had to be {} () or [], the problem statement never said anything about them possibly being inside one another. "
                    },
                    {
                        "username": "RSK_Ua",
                        "content": "Here is some tip:\\nThe first line of the function uses a guard statement to check if the length of the input string is even. If the length is odd, the function returns false because it means that the brackets are not properly balanced.\\nThe next line creates an empty stack of characters to store the opening brackets.\\nThe function then loops through each character item in the input string s.\\nFor each character item, the code checks whether it is an opening bracket: (, [, or {. If it is, the corresponding closing bracket is pushed onto the stack. For example, if the character is (, the character ) is pushed onto the stack.\\nIf the character is a closing bracket: ), ], or }, the code checks whether the stack is empty. If the stack is empty, it means that there is no opening bracket to match the closing bracket, so the function returns false. If the stack is not empty, the last opening bracket is removed from the stack and checked against the current closing bracket. If the brackets do not match, the function returns false.\\nAfter looping through all the characters in the input string, the function checks whether the stack is empty. If it is, it means that all the opening brackets have been matched with their corresponding closing brackets, so the function returns true. If the stack is not empty, it means that there are unmatched opening brackets, so the function returns false."
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "well explained, I managed to create a solution based on your logic. Thanks a lot\\n"
                    },
                    {
                        "username": "shekardaval",
                        "content": "for the string \\'(]\\' my code is working fine with python 3.7, but here its showing wrong output"
                    },
                    {
                        "username": "benjayy",
                        "content": "I fixed it by returning the boolean rather than the strings. "
                    },
                    {
                        "username": "Aleks_Kim",
                        "content": "[@gvolsky](/gvolsky) Thank you, it is really solution"
                    },
                    {
                        "username": "muqeetkhawaja",
                        "content": "[@gvolsky](/gvolsky) Thanks Brother."
                    },
                    {
                        "username": "gvolsky",
                        "content": "Maybe you, like me, return 'true' and 'false' as strings, not as booleans True and False."
                    },
                    {
                        "username": "wayneli-5",
                        "content": "[@saiharish_g](/saiharish_g) I have this issue too. Have you found a solution? Thank you!"
                    },
                    {
                        "username": "keerthisravanigude",
                        "content": "[@fizah](/fizah) ya same with me also\\n"
                    },
                    {
                        "username": "saiharish_g",
                        "content": "so have you find the real issue actually??"
                    },
                    {
                        "username": "fizah",
                        "content": "same"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "user8796tT",
                        "content": "whats wrong with this TC \"{[]}\" in custom test cases run it succeed but it fails on submission.  \\n![image](https://assets.leetcode.com/users/images/0a36f8a9-6403-4cb8-a073-933a7ded9abe_1609523958.1513097.png)\\n\""
                    },
                    {
                        "username": "ms0686714",
                        "content": "Might be a global variable issue.Make sure initialize the global variable in the begining of main function."
                    },
                    {
                        "username": "kanwarudaysingh",
                        "content": "I was asked to do this in o(1) memory in an interview! Anyone knows how to do that?"
                    },
                    {
                        "username": "0bro",
                        "content": "They probably also required 10 years experience in Rust (Rust came out 8 years ago) lol"
                    },
                    {
                        "username": "data-stack",
                        "content": "Well, you can solve it with a regular expression in O(1) space complexity "
                    },
                    {
                        "username": "rennasccenth",
                        "content": "[@psi_psi](/psi_psi) \"For every\" states something that needs to be iterated, which means nothing less than O(n)"
                    },
                    {
                        "username": "charonme",
                        "content": "I tried a stackless solution with O(1) additional space (not counting the in-place modification of the input string), but it\\'s O(n^2) time"
                    },
                    {
                        "username": "psi_psi",
                        "content": "For every closing char, repeat the search (recursively and repeatedly) backwards (and with inversed opening and closing chars) until you are out of string or you reach the next (in this case, previous) opening char in the string. If that next one is your corresponding opening char, you continue forwards. It is not going to be very fast."
                    },
                    {
                        "username": "astro12",
                        "content": "What is the company name? I\\'ll make sure I\\'ll add that to my blacklist"
                    },
                    {
                        "username": "jigar100",
                        "content": "Did the interviewer asked to do this in O(1) space by maintaining O(n) time complexity"
                    },
                    {
                        "username": "lwear2",
                        "content": "https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/715/introduction/4654/\\n\\nIn the section of Space Analysis it indicates that input and output arrays are not included in memory analysis for BigO.  So, cycle through the input as many times as necessary, modifying the array each time and don\\'t create any new storage space for the array."
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Did u find solution to do that as o1  (javscript)"
                    },
                    {
                        "username": "Alexander2049",
                        "content": "Description is not good enough. Should be shown some more test cases as \"( [ ) ]\", because \"Open brackets must be closed in the correct order\" could be missunderstood."
                    },
                    {
                        "username": "ananya_dash16",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) Same with me.\\n"
                    },
                    {
                        "username": "rahulschandak",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) I have the same doubt"
                    },
                    {
                        "username": "AnkushKrVerma",
                        "content": "yess even now i can\\'t understand the problem.\\nwhy the TC \"( [ ) ]\" returning false ???\\nhelp me understand the problem "
                    }
                ]
            },
            {
                "id": 1567810,
                "content": [
                    {
                        "username": "sunwangshu",
                        "content": "The brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\\n\\nFrom this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid. \\nThen I think the problem description should be updated."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "Exactly."
                    },
                    {
                        "username": "Awesome_7",
                        "content": "my code is expecting false for that in test case 70.\\ncan somebody look at this:\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        string opening=\"\";\\n        string closing=\"\";\\n\\n        for(auto i:s){\\n            if(i==\\'(\\' || i==\\'{\\' || i==\\'[\\' ){\\n                opening.push_back(i);\\n            }else{\\n                closing.push_back(i);\\n            }\\n        }\\n\\n        if(opening.length()!=closing.length()){\\n            return false;\\n        }\\n\\n        for(int i=0;i<opening.length();i++){\\n            if(opening[i]==\\'(\\'&& closing[i]!=\\')\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'{\\'&& closing[i]!=\\'}\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'[\\'&& closing[i]!=\\']\\'){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "chavaninc",
                        "content": "Came here to say this. Sadly I already had my submission wrong"
                    },
                    {
                        "username": "hkurmi",
                        "content": "exactly just got my first submission wrong becouse of this"
                    },
                    {
                        "username": "rafaelcitj",
                        "content": "[@D-Panda](/D-Panda) I had exact the same question after reading the description, thanks for clarifying."
                    },
                    {
                        "username": "rayhanul17",
                        "content": "[@hosua](/hosua) haha"
                    },
                    {
                        "username": "siddhanttamgadge4",
                        "content": "Yes it is allowed!"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua)  : )"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua) : ^)"
                    },
                    {
                        "username": "D-Panda",
                        "content": "it is valid"
                    },
                    {
                        "username": "hosua",
                        "content": "To answer your question 6 years later, yes, it is valid. "
                    },
                    {
                        "username": "rishavm",
                        "content": "Totally Agree! Due to lack of description in the question. My submission was rejected 3-4 times on the test cases which are not fulfilling the description of the problem. Although question is easy, but lack of description cause us time and our record."
                    },
                    {
                        "username": "omerkarabulut169",
                        "content": "Same my code 66/92 because of that"
                    },
                    {
                        "username": "minhtq9700",
                        "content": "yeah"
                    },
                    {
                        "username": "lwear2",
                        "content": "I agree.  Solved it twice from scratch only to find there are new requirements that manifest in testing.  Now I\\'m having to start again from scratch and pretty frustrated.  My second approach (recursive) simply won\\'t work in one submission test case.  This may be a little TOO real world for the learning environment.  There are classes in Requirements Engineering.  Like Agile and algorithms, they are very important to the professional.\\n\\nI strongly suggest clarifying the fact that the coder should allow for nested parentheses and that the nesting may be complex.\\n\\nRather than this wording, \"Open brackets must be closed in the CORRECT order.\"  (In whose mind?)\\n\\nI strongly suggest this: \"For strings that involve complex nesting, each bracket must be closed in the correct order.\"\\n\\nThis makes clear that \"correct\" is referring to nesting order, not front to back, or first open, or outside to inside, or some other \"correct\" order."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "sxltie",
                        "content": "precisely.. from the description one can\\u2019t even tell if (()) is valid or not.. they don\\u2019t include nested parentheses"
                    },
                    {
                        "username": "tonybrasunas",
                        "content": "The description for this one should say `([]{})` is valid too. Otherwise it's not clear that validating nested parentheses is part of the requirements."
                    },
                    {
                        "username": "bupty3e3",
                        "content": "Yeah, this question wasn\\'t that clear to this end."
                    },
                    {
                        "username": "ecapoferri",
                        "content": "Thanks for posting. I was wondering and went to discussion for clarification."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "bryanAM",
                        "content": "It\\'s a really **good** problem. But I don\\'t think it\\'s appropriate to call it **Easy**. If you\\'ve never had a question like this before, and if you\\'re new to python and programming - which is my guess the target audiance for easy questions - it\\'s a little difficult."
                    },
                    {
                        "username": "a098707730135",
                        "content": "[@JuanQP](/JuanQP) Thank you so much! You gave me the most useful hint!"
                    },
                    {
                        "username": "Rave17",
                        "content": "[@nicolobos77](/nicolobos77) thank you very much. this was crucial advice for leetcode newbie like me"
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "Totally agree. It isnt an easy problem."
                    },
                    {
                        "username": "gurunathkulkarni164",
                        "content": "You go to know stack for this problem."
                    },
                    {
                        "username": "JuanQP",
                        "content": "The only thing you need to solve this is knowing what a stack is. In first year of any engineering or comp-sci career you learn this in the first year"
                    },
                    {
                        "username": "nicolobos77",
                        "content": "It\\'s easy you just have to implement a memory managment with a char* as a stack in C, you push every open bracket, and pop one when there\\'s a close bracket that matches with the last opened bracket, if it doesn\\'t match, just return false, and if the string loop ended and there\\'s at least one bracket in the stack, return false, if it ends with an empty stack and every bracket is open and close correctly return true"
                    },
                    {
                        "username": "matthcraig",
                        "content": "The word \"easy\" in leetcode is a total misnomer and a relative description.  There are no easy leetcode questions.  "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "ikr"
                    },
                    {
                        "username": "tryhard00",
                        "content": "This problem could be considered easy but only if you realized the crux of it. If you tried to do it using pure conditionals, which I did for the first 3 hours, you\\'re in for a very bad time. I finally gave up on conditionals when it had a nested within nested case. I was about to go 3d array to store each set but it was so logically complex I almost quit. Then I saw it. So this problem could considered medium if you didn\\'t see the easy answer. Overall, a very clever question. It had so many caveats that I kept getting rejected and it was giving me pstd by the end. lol. For those who are stuck, the hint is what goes in last must come out first."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "Your hint at the last helped me solve the problem quickly \\uD83D\\uDE0A. Thanks."
                    },
                    {
                        "username": "zaynahmad20",
                        "content": "You sure do know how to not spoil a question and give a good hint. Thanks lol"
                    },
                    {
                        "username": "ejaza",
                        "content": "wow man thanks a great hint now i am able to do it \"the hint is what goes in last must come out first.\""
                    },
                    {
                        "username": "johnopj",
                        "content": "Exactly!! The door opened last should be closed first."
                    },
                    {
                        "username": "devindesu",
                        "content": "Mother $^#& I spent much more than 3 hours trying to force it to work with nested conditionals...Thank you for the hint. If they're gonna classify this as Easy they should at least defined the stack class for us  lol"
                    },
                    {
                        "username": "amitkhedkar41",
                        "content": "From this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid.\\nThen I think the problem description should be updated"
                    },
                    {
                        "username": "meergato247",
                        "content": "Exactly. I assumed the pairs just had to be {} () or [], the problem statement never said anything about them possibly being inside one another. "
                    },
                    {
                        "username": "RSK_Ua",
                        "content": "Here is some tip:\\nThe first line of the function uses a guard statement to check if the length of the input string is even. If the length is odd, the function returns false because it means that the brackets are not properly balanced.\\nThe next line creates an empty stack of characters to store the opening brackets.\\nThe function then loops through each character item in the input string s.\\nFor each character item, the code checks whether it is an opening bracket: (, [, or {. If it is, the corresponding closing bracket is pushed onto the stack. For example, if the character is (, the character ) is pushed onto the stack.\\nIf the character is a closing bracket: ), ], or }, the code checks whether the stack is empty. If the stack is empty, it means that there is no opening bracket to match the closing bracket, so the function returns false. If the stack is not empty, the last opening bracket is removed from the stack and checked against the current closing bracket. If the brackets do not match, the function returns false.\\nAfter looping through all the characters in the input string, the function checks whether the stack is empty. If it is, it means that all the opening brackets have been matched with their corresponding closing brackets, so the function returns true. If the stack is not empty, it means that there are unmatched opening brackets, so the function returns false."
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "well explained, I managed to create a solution based on your logic. Thanks a lot\\n"
                    },
                    {
                        "username": "shekardaval",
                        "content": "for the string \\'(]\\' my code is working fine with python 3.7, but here its showing wrong output"
                    },
                    {
                        "username": "benjayy",
                        "content": "I fixed it by returning the boolean rather than the strings. "
                    },
                    {
                        "username": "Aleks_Kim",
                        "content": "[@gvolsky](/gvolsky) Thank you, it is really solution"
                    },
                    {
                        "username": "muqeetkhawaja",
                        "content": "[@gvolsky](/gvolsky) Thanks Brother."
                    },
                    {
                        "username": "gvolsky",
                        "content": "Maybe you, like me, return 'true' and 'false' as strings, not as booleans True and False."
                    },
                    {
                        "username": "wayneli-5",
                        "content": "[@saiharish_g](/saiharish_g) I have this issue too. Have you found a solution? Thank you!"
                    },
                    {
                        "username": "keerthisravanigude",
                        "content": "[@fizah](/fizah) ya same with me also\\n"
                    },
                    {
                        "username": "saiharish_g",
                        "content": "so have you find the real issue actually??"
                    },
                    {
                        "username": "fizah",
                        "content": "same"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "user8796tT",
                        "content": "whats wrong with this TC \"{[]}\" in custom test cases run it succeed but it fails on submission.  \\n![image](https://assets.leetcode.com/users/images/0a36f8a9-6403-4cb8-a073-933a7ded9abe_1609523958.1513097.png)\\n\""
                    },
                    {
                        "username": "ms0686714",
                        "content": "Might be a global variable issue.Make sure initialize the global variable in the begining of main function."
                    },
                    {
                        "username": "kanwarudaysingh",
                        "content": "I was asked to do this in o(1) memory in an interview! Anyone knows how to do that?"
                    },
                    {
                        "username": "0bro",
                        "content": "They probably also required 10 years experience in Rust (Rust came out 8 years ago) lol"
                    },
                    {
                        "username": "data-stack",
                        "content": "Well, you can solve it with a regular expression in O(1) space complexity "
                    },
                    {
                        "username": "rennasccenth",
                        "content": "[@psi_psi](/psi_psi) \"For every\" states something that needs to be iterated, which means nothing less than O(n)"
                    },
                    {
                        "username": "charonme",
                        "content": "I tried a stackless solution with O(1) additional space (not counting the in-place modification of the input string), but it\\'s O(n^2) time"
                    },
                    {
                        "username": "psi_psi",
                        "content": "For every closing char, repeat the search (recursively and repeatedly) backwards (and with inversed opening and closing chars) until you are out of string or you reach the next (in this case, previous) opening char in the string. If that next one is your corresponding opening char, you continue forwards. It is not going to be very fast."
                    },
                    {
                        "username": "astro12",
                        "content": "What is the company name? I\\'ll make sure I\\'ll add that to my blacklist"
                    },
                    {
                        "username": "jigar100",
                        "content": "Did the interviewer asked to do this in O(1) space by maintaining O(n) time complexity"
                    },
                    {
                        "username": "lwear2",
                        "content": "https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/715/introduction/4654/\\n\\nIn the section of Space Analysis it indicates that input and output arrays are not included in memory analysis for BigO.  So, cycle through the input as many times as necessary, modifying the array each time and don\\'t create any new storage space for the array."
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Did u find solution to do that as o1  (javscript)"
                    },
                    {
                        "username": "Alexander2049",
                        "content": "Description is not good enough. Should be shown some more test cases as \"( [ ) ]\", because \"Open brackets must be closed in the correct order\" could be missunderstood."
                    },
                    {
                        "username": "ananya_dash16",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) Same with me.\\n"
                    },
                    {
                        "username": "rahulschandak",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) I have the same doubt"
                    },
                    {
                        "username": "AnkushKrVerma",
                        "content": "yess even now i can\\'t understand the problem.\\nwhy the TC \"( [ ) ]\" returning false ???\\nhelp me understand the problem "
                    }
                ]
            },
            {
                "id": 1571052,
                "content": [
                    {
                        "username": "sunwangshu",
                        "content": "The brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\\n\\nFrom this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid. \\nThen I think the problem description should be updated."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "Exactly."
                    },
                    {
                        "username": "Awesome_7",
                        "content": "my code is expecting false for that in test case 70.\\ncan somebody look at this:\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        string opening=\"\";\\n        string closing=\"\";\\n\\n        for(auto i:s){\\n            if(i==\\'(\\' || i==\\'{\\' || i==\\'[\\' ){\\n                opening.push_back(i);\\n            }else{\\n                closing.push_back(i);\\n            }\\n        }\\n\\n        if(opening.length()!=closing.length()){\\n            return false;\\n        }\\n\\n        for(int i=0;i<opening.length();i++){\\n            if(opening[i]==\\'(\\'&& closing[i]!=\\')\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'{\\'&& closing[i]!=\\'}\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'[\\'&& closing[i]!=\\']\\'){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "chavaninc",
                        "content": "Came here to say this. Sadly I already had my submission wrong"
                    },
                    {
                        "username": "hkurmi",
                        "content": "exactly just got my first submission wrong becouse of this"
                    },
                    {
                        "username": "rafaelcitj",
                        "content": "[@D-Panda](/D-Panda) I had exact the same question after reading the description, thanks for clarifying."
                    },
                    {
                        "username": "rayhanul17",
                        "content": "[@hosua](/hosua) haha"
                    },
                    {
                        "username": "siddhanttamgadge4",
                        "content": "Yes it is allowed!"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua)  : )"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua) : ^)"
                    },
                    {
                        "username": "D-Panda",
                        "content": "it is valid"
                    },
                    {
                        "username": "hosua",
                        "content": "To answer your question 6 years later, yes, it is valid. "
                    },
                    {
                        "username": "rishavm",
                        "content": "Totally Agree! Due to lack of description in the question. My submission was rejected 3-4 times on the test cases which are not fulfilling the description of the problem. Although question is easy, but lack of description cause us time and our record."
                    },
                    {
                        "username": "omerkarabulut169",
                        "content": "Same my code 66/92 because of that"
                    },
                    {
                        "username": "minhtq9700",
                        "content": "yeah"
                    },
                    {
                        "username": "lwear2",
                        "content": "I agree.  Solved it twice from scratch only to find there are new requirements that manifest in testing.  Now I\\'m having to start again from scratch and pretty frustrated.  My second approach (recursive) simply won\\'t work in one submission test case.  This may be a little TOO real world for the learning environment.  There are classes in Requirements Engineering.  Like Agile and algorithms, they are very important to the professional.\\n\\nI strongly suggest clarifying the fact that the coder should allow for nested parentheses and that the nesting may be complex.\\n\\nRather than this wording, \"Open brackets must be closed in the CORRECT order.\"  (In whose mind?)\\n\\nI strongly suggest this: \"For strings that involve complex nesting, each bracket must be closed in the correct order.\"\\n\\nThis makes clear that \"correct\" is referring to nesting order, not front to back, or first open, or outside to inside, or some other \"correct\" order."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "sxltie",
                        "content": "precisely.. from the description one can\\u2019t even tell if (()) is valid or not.. they don\\u2019t include nested parentheses"
                    },
                    {
                        "username": "tonybrasunas",
                        "content": "The description for this one should say `([]{})` is valid too. Otherwise it's not clear that validating nested parentheses is part of the requirements."
                    },
                    {
                        "username": "bupty3e3",
                        "content": "Yeah, this question wasn\\'t that clear to this end."
                    },
                    {
                        "username": "ecapoferri",
                        "content": "Thanks for posting. I was wondering and went to discussion for clarification."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "bryanAM",
                        "content": "It\\'s a really **good** problem. But I don\\'t think it\\'s appropriate to call it **Easy**. If you\\'ve never had a question like this before, and if you\\'re new to python and programming - which is my guess the target audiance for easy questions - it\\'s a little difficult."
                    },
                    {
                        "username": "a098707730135",
                        "content": "[@JuanQP](/JuanQP) Thank you so much! You gave me the most useful hint!"
                    },
                    {
                        "username": "Rave17",
                        "content": "[@nicolobos77](/nicolobos77) thank you very much. this was crucial advice for leetcode newbie like me"
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "Totally agree. It isnt an easy problem."
                    },
                    {
                        "username": "gurunathkulkarni164",
                        "content": "You go to know stack for this problem."
                    },
                    {
                        "username": "JuanQP",
                        "content": "The only thing you need to solve this is knowing what a stack is. In first year of any engineering or comp-sci career you learn this in the first year"
                    },
                    {
                        "username": "nicolobos77",
                        "content": "It\\'s easy you just have to implement a memory managment with a char* as a stack in C, you push every open bracket, and pop one when there\\'s a close bracket that matches with the last opened bracket, if it doesn\\'t match, just return false, and if the string loop ended and there\\'s at least one bracket in the stack, return false, if it ends with an empty stack and every bracket is open and close correctly return true"
                    },
                    {
                        "username": "matthcraig",
                        "content": "The word \"easy\" in leetcode is a total misnomer and a relative description.  There are no easy leetcode questions.  "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "ikr"
                    },
                    {
                        "username": "tryhard00",
                        "content": "This problem could be considered easy but only if you realized the crux of it. If you tried to do it using pure conditionals, which I did for the first 3 hours, you\\'re in for a very bad time. I finally gave up on conditionals when it had a nested within nested case. I was about to go 3d array to store each set but it was so logically complex I almost quit. Then I saw it. So this problem could considered medium if you didn\\'t see the easy answer. Overall, a very clever question. It had so many caveats that I kept getting rejected and it was giving me pstd by the end. lol. For those who are stuck, the hint is what goes in last must come out first."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "Your hint at the last helped me solve the problem quickly \\uD83D\\uDE0A. Thanks."
                    },
                    {
                        "username": "zaynahmad20",
                        "content": "You sure do know how to not spoil a question and give a good hint. Thanks lol"
                    },
                    {
                        "username": "ejaza",
                        "content": "wow man thanks a great hint now i am able to do it \"the hint is what goes in last must come out first.\""
                    },
                    {
                        "username": "johnopj",
                        "content": "Exactly!! The door opened last should be closed first."
                    },
                    {
                        "username": "devindesu",
                        "content": "Mother $^#& I spent much more than 3 hours trying to force it to work with nested conditionals...Thank you for the hint. If they're gonna classify this as Easy they should at least defined the stack class for us  lol"
                    },
                    {
                        "username": "amitkhedkar41",
                        "content": "From this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid.\\nThen I think the problem description should be updated"
                    },
                    {
                        "username": "meergato247",
                        "content": "Exactly. I assumed the pairs just had to be {} () or [], the problem statement never said anything about them possibly being inside one another. "
                    },
                    {
                        "username": "RSK_Ua",
                        "content": "Here is some tip:\\nThe first line of the function uses a guard statement to check if the length of the input string is even. If the length is odd, the function returns false because it means that the brackets are not properly balanced.\\nThe next line creates an empty stack of characters to store the opening brackets.\\nThe function then loops through each character item in the input string s.\\nFor each character item, the code checks whether it is an opening bracket: (, [, or {. If it is, the corresponding closing bracket is pushed onto the stack. For example, if the character is (, the character ) is pushed onto the stack.\\nIf the character is a closing bracket: ), ], or }, the code checks whether the stack is empty. If the stack is empty, it means that there is no opening bracket to match the closing bracket, so the function returns false. If the stack is not empty, the last opening bracket is removed from the stack and checked against the current closing bracket. If the brackets do not match, the function returns false.\\nAfter looping through all the characters in the input string, the function checks whether the stack is empty. If it is, it means that all the opening brackets have been matched with their corresponding closing brackets, so the function returns true. If the stack is not empty, it means that there are unmatched opening brackets, so the function returns false."
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "well explained, I managed to create a solution based on your logic. Thanks a lot\\n"
                    },
                    {
                        "username": "shekardaval",
                        "content": "for the string \\'(]\\' my code is working fine with python 3.7, but here its showing wrong output"
                    },
                    {
                        "username": "benjayy",
                        "content": "I fixed it by returning the boolean rather than the strings. "
                    },
                    {
                        "username": "Aleks_Kim",
                        "content": "[@gvolsky](/gvolsky) Thank you, it is really solution"
                    },
                    {
                        "username": "muqeetkhawaja",
                        "content": "[@gvolsky](/gvolsky) Thanks Brother."
                    },
                    {
                        "username": "gvolsky",
                        "content": "Maybe you, like me, return 'true' and 'false' as strings, not as booleans True and False."
                    },
                    {
                        "username": "wayneli-5",
                        "content": "[@saiharish_g](/saiharish_g) I have this issue too. Have you found a solution? Thank you!"
                    },
                    {
                        "username": "keerthisravanigude",
                        "content": "[@fizah](/fizah) ya same with me also\\n"
                    },
                    {
                        "username": "saiharish_g",
                        "content": "so have you find the real issue actually??"
                    },
                    {
                        "username": "fizah",
                        "content": "same"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "user8796tT",
                        "content": "whats wrong with this TC \"{[]}\" in custom test cases run it succeed but it fails on submission.  \\n![image](https://assets.leetcode.com/users/images/0a36f8a9-6403-4cb8-a073-933a7ded9abe_1609523958.1513097.png)\\n\""
                    },
                    {
                        "username": "ms0686714",
                        "content": "Might be a global variable issue.Make sure initialize the global variable in the begining of main function."
                    },
                    {
                        "username": "kanwarudaysingh",
                        "content": "I was asked to do this in o(1) memory in an interview! Anyone knows how to do that?"
                    },
                    {
                        "username": "0bro",
                        "content": "They probably also required 10 years experience in Rust (Rust came out 8 years ago) lol"
                    },
                    {
                        "username": "data-stack",
                        "content": "Well, you can solve it with a regular expression in O(1) space complexity "
                    },
                    {
                        "username": "rennasccenth",
                        "content": "[@psi_psi](/psi_psi) \"For every\" states something that needs to be iterated, which means nothing less than O(n)"
                    },
                    {
                        "username": "charonme",
                        "content": "I tried a stackless solution with O(1) additional space (not counting the in-place modification of the input string), but it\\'s O(n^2) time"
                    },
                    {
                        "username": "psi_psi",
                        "content": "For every closing char, repeat the search (recursively and repeatedly) backwards (and with inversed opening and closing chars) until you are out of string or you reach the next (in this case, previous) opening char in the string. If that next one is your corresponding opening char, you continue forwards. It is not going to be very fast."
                    },
                    {
                        "username": "astro12",
                        "content": "What is the company name? I\\'ll make sure I\\'ll add that to my blacklist"
                    },
                    {
                        "username": "jigar100",
                        "content": "Did the interviewer asked to do this in O(1) space by maintaining O(n) time complexity"
                    },
                    {
                        "username": "lwear2",
                        "content": "https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/715/introduction/4654/\\n\\nIn the section of Space Analysis it indicates that input and output arrays are not included in memory analysis for BigO.  So, cycle through the input as many times as necessary, modifying the array each time and don\\'t create any new storage space for the array."
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Did u find solution to do that as o1  (javscript)"
                    },
                    {
                        "username": "Alexander2049",
                        "content": "Description is not good enough. Should be shown some more test cases as \"( [ ) ]\", because \"Open brackets must be closed in the correct order\" could be missunderstood."
                    },
                    {
                        "username": "ananya_dash16",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) Same with me.\\n"
                    },
                    {
                        "username": "rahulschandak",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) I have the same doubt"
                    },
                    {
                        "username": "AnkushKrVerma",
                        "content": "yess even now i can\\'t understand the problem.\\nwhy the TC \"( [ ) ]\" returning false ???\\nhelp me understand the problem "
                    }
                ]
            },
            {
                "id": 1572706,
                "content": [
                    {
                        "username": "sunwangshu",
                        "content": "The brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\\n\\nFrom this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid. \\nThen I think the problem description should be updated."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "Exactly."
                    },
                    {
                        "username": "Awesome_7",
                        "content": "my code is expecting false for that in test case 70.\\ncan somebody look at this:\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        string opening=\"\";\\n        string closing=\"\";\\n\\n        for(auto i:s){\\n            if(i==\\'(\\' || i==\\'{\\' || i==\\'[\\' ){\\n                opening.push_back(i);\\n            }else{\\n                closing.push_back(i);\\n            }\\n        }\\n\\n        if(opening.length()!=closing.length()){\\n            return false;\\n        }\\n\\n        for(int i=0;i<opening.length();i++){\\n            if(opening[i]==\\'(\\'&& closing[i]!=\\')\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'{\\'&& closing[i]!=\\'}\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'[\\'&& closing[i]!=\\']\\'){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "chavaninc",
                        "content": "Came here to say this. Sadly I already had my submission wrong"
                    },
                    {
                        "username": "hkurmi",
                        "content": "exactly just got my first submission wrong becouse of this"
                    },
                    {
                        "username": "rafaelcitj",
                        "content": "[@D-Panda](/D-Panda) I had exact the same question after reading the description, thanks for clarifying."
                    },
                    {
                        "username": "rayhanul17",
                        "content": "[@hosua](/hosua) haha"
                    },
                    {
                        "username": "siddhanttamgadge4",
                        "content": "Yes it is allowed!"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua)  : )"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua) : ^)"
                    },
                    {
                        "username": "D-Panda",
                        "content": "it is valid"
                    },
                    {
                        "username": "hosua",
                        "content": "To answer your question 6 years later, yes, it is valid. "
                    },
                    {
                        "username": "rishavm",
                        "content": "Totally Agree! Due to lack of description in the question. My submission was rejected 3-4 times on the test cases which are not fulfilling the description of the problem. Although question is easy, but lack of description cause us time and our record."
                    },
                    {
                        "username": "omerkarabulut169",
                        "content": "Same my code 66/92 because of that"
                    },
                    {
                        "username": "minhtq9700",
                        "content": "yeah"
                    },
                    {
                        "username": "lwear2",
                        "content": "I agree.  Solved it twice from scratch only to find there are new requirements that manifest in testing.  Now I\\'m having to start again from scratch and pretty frustrated.  My second approach (recursive) simply won\\'t work in one submission test case.  This may be a little TOO real world for the learning environment.  There are classes in Requirements Engineering.  Like Agile and algorithms, they are very important to the professional.\\n\\nI strongly suggest clarifying the fact that the coder should allow for nested parentheses and that the nesting may be complex.\\n\\nRather than this wording, \"Open brackets must be closed in the CORRECT order.\"  (In whose mind?)\\n\\nI strongly suggest this: \"For strings that involve complex nesting, each bracket must be closed in the correct order.\"\\n\\nThis makes clear that \"correct\" is referring to nesting order, not front to back, or first open, or outside to inside, or some other \"correct\" order."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "sxltie",
                        "content": "precisely.. from the description one can\\u2019t even tell if (()) is valid or not.. they don\\u2019t include nested parentheses"
                    },
                    {
                        "username": "tonybrasunas",
                        "content": "The description for this one should say `([]{})` is valid too. Otherwise it's not clear that validating nested parentheses is part of the requirements."
                    },
                    {
                        "username": "bupty3e3",
                        "content": "Yeah, this question wasn\\'t that clear to this end."
                    },
                    {
                        "username": "ecapoferri",
                        "content": "Thanks for posting. I was wondering and went to discussion for clarification."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "bryanAM",
                        "content": "It\\'s a really **good** problem. But I don\\'t think it\\'s appropriate to call it **Easy**. If you\\'ve never had a question like this before, and if you\\'re new to python and programming - which is my guess the target audiance for easy questions - it\\'s a little difficult."
                    },
                    {
                        "username": "a098707730135",
                        "content": "[@JuanQP](/JuanQP) Thank you so much! You gave me the most useful hint!"
                    },
                    {
                        "username": "Rave17",
                        "content": "[@nicolobos77](/nicolobos77) thank you very much. this was crucial advice for leetcode newbie like me"
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "Totally agree. It isnt an easy problem."
                    },
                    {
                        "username": "gurunathkulkarni164",
                        "content": "You go to know stack for this problem."
                    },
                    {
                        "username": "JuanQP",
                        "content": "The only thing you need to solve this is knowing what a stack is. In first year of any engineering or comp-sci career you learn this in the first year"
                    },
                    {
                        "username": "nicolobos77",
                        "content": "It\\'s easy you just have to implement a memory managment with a char* as a stack in C, you push every open bracket, and pop one when there\\'s a close bracket that matches with the last opened bracket, if it doesn\\'t match, just return false, and if the string loop ended and there\\'s at least one bracket in the stack, return false, if it ends with an empty stack and every bracket is open and close correctly return true"
                    },
                    {
                        "username": "matthcraig",
                        "content": "The word \"easy\" in leetcode is a total misnomer and a relative description.  There are no easy leetcode questions.  "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "ikr"
                    },
                    {
                        "username": "tryhard00",
                        "content": "This problem could be considered easy but only if you realized the crux of it. If you tried to do it using pure conditionals, which I did for the first 3 hours, you\\'re in for a very bad time. I finally gave up on conditionals when it had a nested within nested case. I was about to go 3d array to store each set but it was so logically complex I almost quit. Then I saw it. So this problem could considered medium if you didn\\'t see the easy answer. Overall, a very clever question. It had so many caveats that I kept getting rejected and it was giving me pstd by the end. lol. For those who are stuck, the hint is what goes in last must come out first."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "Your hint at the last helped me solve the problem quickly \\uD83D\\uDE0A. Thanks."
                    },
                    {
                        "username": "zaynahmad20",
                        "content": "You sure do know how to not spoil a question and give a good hint. Thanks lol"
                    },
                    {
                        "username": "ejaza",
                        "content": "wow man thanks a great hint now i am able to do it \"the hint is what goes in last must come out first.\""
                    },
                    {
                        "username": "johnopj",
                        "content": "Exactly!! The door opened last should be closed first."
                    },
                    {
                        "username": "devindesu",
                        "content": "Mother $^#& I spent much more than 3 hours trying to force it to work with nested conditionals...Thank you for the hint. If they're gonna classify this as Easy they should at least defined the stack class for us  lol"
                    },
                    {
                        "username": "amitkhedkar41",
                        "content": "From this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid.\\nThen I think the problem description should be updated"
                    },
                    {
                        "username": "meergato247",
                        "content": "Exactly. I assumed the pairs just had to be {} () or [], the problem statement never said anything about them possibly being inside one another. "
                    },
                    {
                        "username": "RSK_Ua",
                        "content": "Here is some tip:\\nThe first line of the function uses a guard statement to check if the length of the input string is even. If the length is odd, the function returns false because it means that the brackets are not properly balanced.\\nThe next line creates an empty stack of characters to store the opening brackets.\\nThe function then loops through each character item in the input string s.\\nFor each character item, the code checks whether it is an opening bracket: (, [, or {. If it is, the corresponding closing bracket is pushed onto the stack. For example, if the character is (, the character ) is pushed onto the stack.\\nIf the character is a closing bracket: ), ], or }, the code checks whether the stack is empty. If the stack is empty, it means that there is no opening bracket to match the closing bracket, so the function returns false. If the stack is not empty, the last opening bracket is removed from the stack and checked against the current closing bracket. If the brackets do not match, the function returns false.\\nAfter looping through all the characters in the input string, the function checks whether the stack is empty. If it is, it means that all the opening brackets have been matched with their corresponding closing brackets, so the function returns true. If the stack is not empty, it means that there are unmatched opening brackets, so the function returns false."
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "well explained, I managed to create a solution based on your logic. Thanks a lot\\n"
                    },
                    {
                        "username": "shekardaval",
                        "content": "for the string \\'(]\\' my code is working fine with python 3.7, but here its showing wrong output"
                    },
                    {
                        "username": "benjayy",
                        "content": "I fixed it by returning the boolean rather than the strings. "
                    },
                    {
                        "username": "Aleks_Kim",
                        "content": "[@gvolsky](/gvolsky) Thank you, it is really solution"
                    },
                    {
                        "username": "muqeetkhawaja",
                        "content": "[@gvolsky](/gvolsky) Thanks Brother."
                    },
                    {
                        "username": "gvolsky",
                        "content": "Maybe you, like me, return 'true' and 'false' as strings, not as booleans True and False."
                    },
                    {
                        "username": "wayneli-5",
                        "content": "[@saiharish_g](/saiharish_g) I have this issue too. Have you found a solution? Thank you!"
                    },
                    {
                        "username": "keerthisravanigude",
                        "content": "[@fizah](/fizah) ya same with me also\\n"
                    },
                    {
                        "username": "saiharish_g",
                        "content": "so have you find the real issue actually??"
                    },
                    {
                        "username": "fizah",
                        "content": "same"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "user8796tT",
                        "content": "whats wrong with this TC \"{[]}\" in custom test cases run it succeed but it fails on submission.  \\n![image](https://assets.leetcode.com/users/images/0a36f8a9-6403-4cb8-a073-933a7ded9abe_1609523958.1513097.png)\\n\""
                    },
                    {
                        "username": "ms0686714",
                        "content": "Might be a global variable issue.Make sure initialize the global variable in the begining of main function."
                    },
                    {
                        "username": "kanwarudaysingh",
                        "content": "I was asked to do this in o(1) memory in an interview! Anyone knows how to do that?"
                    },
                    {
                        "username": "0bro",
                        "content": "They probably also required 10 years experience in Rust (Rust came out 8 years ago) lol"
                    },
                    {
                        "username": "data-stack",
                        "content": "Well, you can solve it with a regular expression in O(1) space complexity "
                    },
                    {
                        "username": "rennasccenth",
                        "content": "[@psi_psi](/psi_psi) \"For every\" states something that needs to be iterated, which means nothing less than O(n)"
                    },
                    {
                        "username": "charonme",
                        "content": "I tried a stackless solution with O(1) additional space (not counting the in-place modification of the input string), but it\\'s O(n^2) time"
                    },
                    {
                        "username": "psi_psi",
                        "content": "For every closing char, repeat the search (recursively and repeatedly) backwards (and with inversed opening and closing chars) until you are out of string or you reach the next (in this case, previous) opening char in the string. If that next one is your corresponding opening char, you continue forwards. It is not going to be very fast."
                    },
                    {
                        "username": "astro12",
                        "content": "What is the company name? I\\'ll make sure I\\'ll add that to my blacklist"
                    },
                    {
                        "username": "jigar100",
                        "content": "Did the interviewer asked to do this in O(1) space by maintaining O(n) time complexity"
                    },
                    {
                        "username": "lwear2",
                        "content": "https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/715/introduction/4654/\\n\\nIn the section of Space Analysis it indicates that input and output arrays are not included in memory analysis for BigO.  So, cycle through the input as many times as necessary, modifying the array each time and don\\'t create any new storage space for the array."
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Did u find solution to do that as o1  (javscript)"
                    },
                    {
                        "username": "Alexander2049",
                        "content": "Description is not good enough. Should be shown some more test cases as \"( [ ) ]\", because \"Open brackets must be closed in the correct order\" could be missunderstood."
                    },
                    {
                        "username": "ananya_dash16",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) Same with me.\\n"
                    },
                    {
                        "username": "rahulschandak",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) I have the same doubt"
                    },
                    {
                        "username": "AnkushKrVerma",
                        "content": "yess even now i can\\'t understand the problem.\\nwhy the TC \"( [ ) ]\" returning false ???\\nhelp me understand the problem "
                    }
                ]
            },
            {
                "id": 1643473,
                "content": [
                    {
                        "username": "sunwangshu",
                        "content": "The brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\\n\\nFrom this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid. \\nThen I think the problem description should be updated."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "Exactly."
                    },
                    {
                        "username": "Awesome_7",
                        "content": "my code is expecting false for that in test case 70.\\ncan somebody look at this:\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        string opening=\"\";\\n        string closing=\"\";\\n\\n        for(auto i:s){\\n            if(i==\\'(\\' || i==\\'{\\' || i==\\'[\\' ){\\n                opening.push_back(i);\\n            }else{\\n                closing.push_back(i);\\n            }\\n        }\\n\\n        if(opening.length()!=closing.length()){\\n            return false;\\n        }\\n\\n        for(int i=0;i<opening.length();i++){\\n            if(opening[i]==\\'(\\'&& closing[i]!=\\')\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'{\\'&& closing[i]!=\\'}\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'[\\'&& closing[i]!=\\']\\'){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "chavaninc",
                        "content": "Came here to say this. Sadly I already had my submission wrong"
                    },
                    {
                        "username": "hkurmi",
                        "content": "exactly just got my first submission wrong becouse of this"
                    },
                    {
                        "username": "rafaelcitj",
                        "content": "[@D-Panda](/D-Panda) I had exact the same question after reading the description, thanks for clarifying."
                    },
                    {
                        "username": "rayhanul17",
                        "content": "[@hosua](/hosua) haha"
                    },
                    {
                        "username": "siddhanttamgadge4",
                        "content": "Yes it is allowed!"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua)  : )"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua) : ^)"
                    },
                    {
                        "username": "D-Panda",
                        "content": "it is valid"
                    },
                    {
                        "username": "hosua",
                        "content": "To answer your question 6 years later, yes, it is valid. "
                    },
                    {
                        "username": "rishavm",
                        "content": "Totally Agree! Due to lack of description in the question. My submission was rejected 3-4 times on the test cases which are not fulfilling the description of the problem. Although question is easy, but lack of description cause us time and our record."
                    },
                    {
                        "username": "omerkarabulut169",
                        "content": "Same my code 66/92 because of that"
                    },
                    {
                        "username": "minhtq9700",
                        "content": "yeah"
                    },
                    {
                        "username": "lwear2",
                        "content": "I agree.  Solved it twice from scratch only to find there are new requirements that manifest in testing.  Now I\\'m having to start again from scratch and pretty frustrated.  My second approach (recursive) simply won\\'t work in one submission test case.  This may be a little TOO real world for the learning environment.  There are classes in Requirements Engineering.  Like Agile and algorithms, they are very important to the professional.\\n\\nI strongly suggest clarifying the fact that the coder should allow for nested parentheses and that the nesting may be complex.\\n\\nRather than this wording, \"Open brackets must be closed in the CORRECT order.\"  (In whose mind?)\\n\\nI strongly suggest this: \"For strings that involve complex nesting, each bracket must be closed in the correct order.\"\\n\\nThis makes clear that \"correct\" is referring to nesting order, not front to back, or first open, or outside to inside, or some other \"correct\" order."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "sxltie",
                        "content": "precisely.. from the description one can\\u2019t even tell if (()) is valid or not.. they don\\u2019t include nested parentheses"
                    },
                    {
                        "username": "tonybrasunas",
                        "content": "The description for this one should say `([]{})` is valid too. Otherwise it's not clear that validating nested parentheses is part of the requirements."
                    },
                    {
                        "username": "bupty3e3",
                        "content": "Yeah, this question wasn\\'t that clear to this end."
                    },
                    {
                        "username": "ecapoferri",
                        "content": "Thanks for posting. I was wondering and went to discussion for clarification."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "bryanAM",
                        "content": "It\\'s a really **good** problem. But I don\\'t think it\\'s appropriate to call it **Easy**. If you\\'ve never had a question like this before, and if you\\'re new to python and programming - which is my guess the target audiance for easy questions - it\\'s a little difficult."
                    },
                    {
                        "username": "a098707730135",
                        "content": "[@JuanQP](/JuanQP) Thank you so much! You gave me the most useful hint!"
                    },
                    {
                        "username": "Rave17",
                        "content": "[@nicolobos77](/nicolobos77) thank you very much. this was crucial advice for leetcode newbie like me"
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "Totally agree. It isnt an easy problem."
                    },
                    {
                        "username": "gurunathkulkarni164",
                        "content": "You go to know stack for this problem."
                    },
                    {
                        "username": "JuanQP",
                        "content": "The only thing you need to solve this is knowing what a stack is. In first year of any engineering or comp-sci career you learn this in the first year"
                    },
                    {
                        "username": "nicolobos77",
                        "content": "It\\'s easy you just have to implement a memory managment with a char* as a stack in C, you push every open bracket, and pop one when there\\'s a close bracket that matches with the last opened bracket, if it doesn\\'t match, just return false, and if the string loop ended and there\\'s at least one bracket in the stack, return false, if it ends with an empty stack and every bracket is open and close correctly return true"
                    },
                    {
                        "username": "matthcraig",
                        "content": "The word \"easy\" in leetcode is a total misnomer and a relative description.  There are no easy leetcode questions.  "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "ikr"
                    },
                    {
                        "username": "tryhard00",
                        "content": "This problem could be considered easy but only if you realized the crux of it. If you tried to do it using pure conditionals, which I did for the first 3 hours, you\\'re in for a very bad time. I finally gave up on conditionals when it had a nested within nested case. I was about to go 3d array to store each set but it was so logically complex I almost quit. Then I saw it. So this problem could considered medium if you didn\\'t see the easy answer. Overall, a very clever question. It had so many caveats that I kept getting rejected and it was giving me pstd by the end. lol. For those who are stuck, the hint is what goes in last must come out first."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "Your hint at the last helped me solve the problem quickly \\uD83D\\uDE0A. Thanks."
                    },
                    {
                        "username": "zaynahmad20",
                        "content": "You sure do know how to not spoil a question and give a good hint. Thanks lol"
                    },
                    {
                        "username": "ejaza",
                        "content": "wow man thanks a great hint now i am able to do it \"the hint is what goes in last must come out first.\""
                    },
                    {
                        "username": "johnopj",
                        "content": "Exactly!! The door opened last should be closed first."
                    },
                    {
                        "username": "devindesu",
                        "content": "Mother $^#& I spent much more than 3 hours trying to force it to work with nested conditionals...Thank you for the hint. If they're gonna classify this as Easy they should at least defined the stack class for us  lol"
                    },
                    {
                        "username": "amitkhedkar41",
                        "content": "From this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid.\\nThen I think the problem description should be updated"
                    },
                    {
                        "username": "meergato247",
                        "content": "Exactly. I assumed the pairs just had to be {} () or [], the problem statement never said anything about them possibly being inside one another. "
                    },
                    {
                        "username": "RSK_Ua",
                        "content": "Here is some tip:\\nThe first line of the function uses a guard statement to check if the length of the input string is even. If the length is odd, the function returns false because it means that the brackets are not properly balanced.\\nThe next line creates an empty stack of characters to store the opening brackets.\\nThe function then loops through each character item in the input string s.\\nFor each character item, the code checks whether it is an opening bracket: (, [, or {. If it is, the corresponding closing bracket is pushed onto the stack. For example, if the character is (, the character ) is pushed onto the stack.\\nIf the character is a closing bracket: ), ], or }, the code checks whether the stack is empty. If the stack is empty, it means that there is no opening bracket to match the closing bracket, so the function returns false. If the stack is not empty, the last opening bracket is removed from the stack and checked against the current closing bracket. If the brackets do not match, the function returns false.\\nAfter looping through all the characters in the input string, the function checks whether the stack is empty. If it is, it means that all the opening brackets have been matched with their corresponding closing brackets, so the function returns true. If the stack is not empty, it means that there are unmatched opening brackets, so the function returns false."
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "well explained, I managed to create a solution based on your logic. Thanks a lot\\n"
                    },
                    {
                        "username": "shekardaval",
                        "content": "for the string \\'(]\\' my code is working fine with python 3.7, but here its showing wrong output"
                    },
                    {
                        "username": "benjayy",
                        "content": "I fixed it by returning the boolean rather than the strings. "
                    },
                    {
                        "username": "Aleks_Kim",
                        "content": "[@gvolsky](/gvolsky) Thank you, it is really solution"
                    },
                    {
                        "username": "muqeetkhawaja",
                        "content": "[@gvolsky](/gvolsky) Thanks Brother."
                    },
                    {
                        "username": "gvolsky",
                        "content": "Maybe you, like me, return 'true' and 'false' as strings, not as booleans True and False."
                    },
                    {
                        "username": "wayneli-5",
                        "content": "[@saiharish_g](/saiharish_g) I have this issue too. Have you found a solution? Thank you!"
                    },
                    {
                        "username": "keerthisravanigude",
                        "content": "[@fizah](/fizah) ya same with me also\\n"
                    },
                    {
                        "username": "saiharish_g",
                        "content": "so have you find the real issue actually??"
                    },
                    {
                        "username": "fizah",
                        "content": "same"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "user8796tT",
                        "content": "whats wrong with this TC \"{[]}\" in custom test cases run it succeed but it fails on submission.  \\n![image](https://assets.leetcode.com/users/images/0a36f8a9-6403-4cb8-a073-933a7ded9abe_1609523958.1513097.png)\\n\""
                    },
                    {
                        "username": "ms0686714",
                        "content": "Might be a global variable issue.Make sure initialize the global variable in the begining of main function."
                    },
                    {
                        "username": "kanwarudaysingh",
                        "content": "I was asked to do this in o(1) memory in an interview! Anyone knows how to do that?"
                    },
                    {
                        "username": "0bro",
                        "content": "They probably also required 10 years experience in Rust (Rust came out 8 years ago) lol"
                    },
                    {
                        "username": "data-stack",
                        "content": "Well, you can solve it with a regular expression in O(1) space complexity "
                    },
                    {
                        "username": "rennasccenth",
                        "content": "[@psi_psi](/psi_psi) \"For every\" states something that needs to be iterated, which means nothing less than O(n)"
                    },
                    {
                        "username": "charonme",
                        "content": "I tried a stackless solution with O(1) additional space (not counting the in-place modification of the input string), but it\\'s O(n^2) time"
                    },
                    {
                        "username": "psi_psi",
                        "content": "For every closing char, repeat the search (recursively and repeatedly) backwards (and with inversed opening and closing chars) until you are out of string or you reach the next (in this case, previous) opening char in the string. If that next one is your corresponding opening char, you continue forwards. It is not going to be very fast."
                    },
                    {
                        "username": "astro12",
                        "content": "What is the company name? I\\'ll make sure I\\'ll add that to my blacklist"
                    },
                    {
                        "username": "jigar100",
                        "content": "Did the interviewer asked to do this in O(1) space by maintaining O(n) time complexity"
                    },
                    {
                        "username": "lwear2",
                        "content": "https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/715/introduction/4654/\\n\\nIn the section of Space Analysis it indicates that input and output arrays are not included in memory analysis for BigO.  So, cycle through the input as many times as necessary, modifying the array each time and don\\'t create any new storage space for the array."
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Did u find solution to do that as o1  (javscript)"
                    },
                    {
                        "username": "Alexander2049",
                        "content": "Description is not good enough. Should be shown some more test cases as \"( [ ) ]\", because \"Open brackets must be closed in the correct order\" could be missunderstood."
                    },
                    {
                        "username": "ananya_dash16",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) Same with me.\\n"
                    },
                    {
                        "username": "rahulschandak",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) I have the same doubt"
                    },
                    {
                        "username": "AnkushKrVerma",
                        "content": "yess even now i can\\'t understand the problem.\\nwhy the TC \"( [ ) ]\" returning false ???\\nhelp me understand the problem "
                    }
                ]
            },
            {
                "id": 1673405,
                "content": [
                    {
                        "username": "sunwangshu",
                        "content": "The brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\\n\\nFrom this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid. \\nThen I think the problem description should be updated."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "Exactly."
                    },
                    {
                        "username": "Awesome_7",
                        "content": "my code is expecting false for that in test case 70.\\ncan somebody look at this:\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        string opening=\"\";\\n        string closing=\"\";\\n\\n        for(auto i:s){\\n            if(i==\\'(\\' || i==\\'{\\' || i==\\'[\\' ){\\n                opening.push_back(i);\\n            }else{\\n                closing.push_back(i);\\n            }\\n        }\\n\\n        if(opening.length()!=closing.length()){\\n            return false;\\n        }\\n\\n        for(int i=0;i<opening.length();i++){\\n            if(opening[i]==\\'(\\'&& closing[i]!=\\')\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'{\\'&& closing[i]!=\\'}\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'[\\'&& closing[i]!=\\']\\'){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "chavaninc",
                        "content": "Came here to say this. Sadly I already had my submission wrong"
                    },
                    {
                        "username": "hkurmi",
                        "content": "exactly just got my first submission wrong becouse of this"
                    },
                    {
                        "username": "rafaelcitj",
                        "content": "[@D-Panda](/D-Panda) I had exact the same question after reading the description, thanks for clarifying."
                    },
                    {
                        "username": "rayhanul17",
                        "content": "[@hosua](/hosua) haha"
                    },
                    {
                        "username": "siddhanttamgadge4",
                        "content": "Yes it is allowed!"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua)  : )"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua) : ^)"
                    },
                    {
                        "username": "D-Panda",
                        "content": "it is valid"
                    },
                    {
                        "username": "hosua",
                        "content": "To answer your question 6 years later, yes, it is valid. "
                    },
                    {
                        "username": "rishavm",
                        "content": "Totally Agree! Due to lack of description in the question. My submission was rejected 3-4 times on the test cases which are not fulfilling the description of the problem. Although question is easy, but lack of description cause us time and our record."
                    },
                    {
                        "username": "omerkarabulut169",
                        "content": "Same my code 66/92 because of that"
                    },
                    {
                        "username": "minhtq9700",
                        "content": "yeah"
                    },
                    {
                        "username": "lwear2",
                        "content": "I agree.  Solved it twice from scratch only to find there are new requirements that manifest in testing.  Now I\\'m having to start again from scratch and pretty frustrated.  My second approach (recursive) simply won\\'t work in one submission test case.  This may be a little TOO real world for the learning environment.  There are classes in Requirements Engineering.  Like Agile and algorithms, they are very important to the professional.\\n\\nI strongly suggest clarifying the fact that the coder should allow for nested parentheses and that the nesting may be complex.\\n\\nRather than this wording, \"Open brackets must be closed in the CORRECT order.\"  (In whose mind?)\\n\\nI strongly suggest this: \"For strings that involve complex nesting, each bracket must be closed in the correct order.\"\\n\\nThis makes clear that \"correct\" is referring to nesting order, not front to back, or first open, or outside to inside, or some other \"correct\" order."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "sxltie",
                        "content": "precisely.. from the description one can\\u2019t even tell if (()) is valid or not.. they don\\u2019t include nested parentheses"
                    },
                    {
                        "username": "tonybrasunas",
                        "content": "The description for this one should say `([]{})` is valid too. Otherwise it's not clear that validating nested parentheses is part of the requirements."
                    },
                    {
                        "username": "bupty3e3",
                        "content": "Yeah, this question wasn\\'t that clear to this end."
                    },
                    {
                        "username": "ecapoferri",
                        "content": "Thanks for posting. I was wondering and went to discussion for clarification."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "bryanAM",
                        "content": "It\\'s a really **good** problem. But I don\\'t think it\\'s appropriate to call it **Easy**. If you\\'ve never had a question like this before, and if you\\'re new to python and programming - which is my guess the target audiance for easy questions - it\\'s a little difficult."
                    },
                    {
                        "username": "a098707730135",
                        "content": "[@JuanQP](/JuanQP) Thank you so much! You gave me the most useful hint!"
                    },
                    {
                        "username": "Rave17",
                        "content": "[@nicolobos77](/nicolobos77) thank you very much. this was crucial advice for leetcode newbie like me"
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "Totally agree. It isnt an easy problem."
                    },
                    {
                        "username": "gurunathkulkarni164",
                        "content": "You go to know stack for this problem."
                    },
                    {
                        "username": "JuanQP",
                        "content": "The only thing you need to solve this is knowing what a stack is. In first year of any engineering or comp-sci career you learn this in the first year"
                    },
                    {
                        "username": "nicolobos77",
                        "content": "It\\'s easy you just have to implement a memory managment with a char* as a stack in C, you push every open bracket, and pop one when there\\'s a close bracket that matches with the last opened bracket, if it doesn\\'t match, just return false, and if the string loop ended and there\\'s at least one bracket in the stack, return false, if it ends with an empty stack and every bracket is open and close correctly return true"
                    },
                    {
                        "username": "matthcraig",
                        "content": "The word \"easy\" in leetcode is a total misnomer and a relative description.  There are no easy leetcode questions.  "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "ikr"
                    },
                    {
                        "username": "tryhard00",
                        "content": "This problem could be considered easy but only if you realized the crux of it. If you tried to do it using pure conditionals, which I did for the first 3 hours, you\\'re in for a very bad time. I finally gave up on conditionals when it had a nested within nested case. I was about to go 3d array to store each set but it was so logically complex I almost quit. Then I saw it. So this problem could considered medium if you didn\\'t see the easy answer. Overall, a very clever question. It had so many caveats that I kept getting rejected and it was giving me pstd by the end. lol. For those who are stuck, the hint is what goes in last must come out first."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "Your hint at the last helped me solve the problem quickly \\uD83D\\uDE0A. Thanks."
                    },
                    {
                        "username": "zaynahmad20",
                        "content": "You sure do know how to not spoil a question and give a good hint. Thanks lol"
                    },
                    {
                        "username": "ejaza",
                        "content": "wow man thanks a great hint now i am able to do it \"the hint is what goes in last must come out first.\""
                    },
                    {
                        "username": "johnopj",
                        "content": "Exactly!! The door opened last should be closed first."
                    },
                    {
                        "username": "devindesu",
                        "content": "Mother $^#& I spent much more than 3 hours trying to force it to work with nested conditionals...Thank you for the hint. If they're gonna classify this as Easy they should at least defined the stack class for us  lol"
                    },
                    {
                        "username": "amitkhedkar41",
                        "content": "From this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid.\\nThen I think the problem description should be updated"
                    },
                    {
                        "username": "meergato247",
                        "content": "Exactly. I assumed the pairs just had to be {} () or [], the problem statement never said anything about them possibly being inside one another. "
                    },
                    {
                        "username": "RSK_Ua",
                        "content": "Here is some tip:\\nThe first line of the function uses a guard statement to check if the length of the input string is even. If the length is odd, the function returns false because it means that the brackets are not properly balanced.\\nThe next line creates an empty stack of characters to store the opening brackets.\\nThe function then loops through each character item in the input string s.\\nFor each character item, the code checks whether it is an opening bracket: (, [, or {. If it is, the corresponding closing bracket is pushed onto the stack. For example, if the character is (, the character ) is pushed onto the stack.\\nIf the character is a closing bracket: ), ], or }, the code checks whether the stack is empty. If the stack is empty, it means that there is no opening bracket to match the closing bracket, so the function returns false. If the stack is not empty, the last opening bracket is removed from the stack and checked against the current closing bracket. If the brackets do not match, the function returns false.\\nAfter looping through all the characters in the input string, the function checks whether the stack is empty. If it is, it means that all the opening brackets have been matched with their corresponding closing brackets, so the function returns true. If the stack is not empty, it means that there are unmatched opening brackets, so the function returns false."
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "well explained, I managed to create a solution based on your logic. Thanks a lot\\n"
                    },
                    {
                        "username": "shekardaval",
                        "content": "for the string \\'(]\\' my code is working fine with python 3.7, but here its showing wrong output"
                    },
                    {
                        "username": "benjayy",
                        "content": "I fixed it by returning the boolean rather than the strings. "
                    },
                    {
                        "username": "Aleks_Kim",
                        "content": "[@gvolsky](/gvolsky) Thank you, it is really solution"
                    },
                    {
                        "username": "muqeetkhawaja",
                        "content": "[@gvolsky](/gvolsky) Thanks Brother."
                    },
                    {
                        "username": "gvolsky",
                        "content": "Maybe you, like me, return 'true' and 'false' as strings, not as booleans True and False."
                    },
                    {
                        "username": "wayneli-5",
                        "content": "[@saiharish_g](/saiharish_g) I have this issue too. Have you found a solution? Thank you!"
                    },
                    {
                        "username": "keerthisravanigude",
                        "content": "[@fizah](/fizah) ya same with me also\\n"
                    },
                    {
                        "username": "saiharish_g",
                        "content": "so have you find the real issue actually??"
                    },
                    {
                        "username": "fizah",
                        "content": "same"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "user8796tT",
                        "content": "whats wrong with this TC \"{[]}\" in custom test cases run it succeed but it fails on submission.  \\n![image](https://assets.leetcode.com/users/images/0a36f8a9-6403-4cb8-a073-933a7ded9abe_1609523958.1513097.png)\\n\""
                    },
                    {
                        "username": "ms0686714",
                        "content": "Might be a global variable issue.Make sure initialize the global variable in the begining of main function."
                    },
                    {
                        "username": "kanwarudaysingh",
                        "content": "I was asked to do this in o(1) memory in an interview! Anyone knows how to do that?"
                    },
                    {
                        "username": "0bro",
                        "content": "They probably also required 10 years experience in Rust (Rust came out 8 years ago) lol"
                    },
                    {
                        "username": "data-stack",
                        "content": "Well, you can solve it with a regular expression in O(1) space complexity "
                    },
                    {
                        "username": "rennasccenth",
                        "content": "[@psi_psi](/psi_psi) \"For every\" states something that needs to be iterated, which means nothing less than O(n)"
                    },
                    {
                        "username": "charonme",
                        "content": "I tried a stackless solution with O(1) additional space (not counting the in-place modification of the input string), but it\\'s O(n^2) time"
                    },
                    {
                        "username": "psi_psi",
                        "content": "For every closing char, repeat the search (recursively and repeatedly) backwards (and with inversed opening and closing chars) until you are out of string or you reach the next (in this case, previous) opening char in the string. If that next one is your corresponding opening char, you continue forwards. It is not going to be very fast."
                    },
                    {
                        "username": "astro12",
                        "content": "What is the company name? I\\'ll make sure I\\'ll add that to my blacklist"
                    },
                    {
                        "username": "jigar100",
                        "content": "Did the interviewer asked to do this in O(1) space by maintaining O(n) time complexity"
                    },
                    {
                        "username": "lwear2",
                        "content": "https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/715/introduction/4654/\\n\\nIn the section of Space Analysis it indicates that input and output arrays are not included in memory analysis for BigO.  So, cycle through the input as many times as necessary, modifying the array each time and don\\'t create any new storage space for the array."
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Did u find solution to do that as o1  (javscript)"
                    },
                    {
                        "username": "Alexander2049",
                        "content": "Description is not good enough. Should be shown some more test cases as \"( [ ) ]\", because \"Open brackets must be closed in the correct order\" could be missunderstood."
                    },
                    {
                        "username": "ananya_dash16",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) Same with me.\\n"
                    },
                    {
                        "username": "rahulschandak",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) I have the same doubt"
                    },
                    {
                        "username": "AnkushKrVerma",
                        "content": "yess even now i can\\'t understand the problem.\\nwhy the TC \"( [ ) ]\" returning false ???\\nhelp me understand the problem "
                    }
                ]
            },
            {
                "id": 1875337,
                "content": [
                    {
                        "username": "sunwangshu",
                        "content": "The brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\\n\\nFrom this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid. \\nThen I think the problem description should be updated."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "Exactly."
                    },
                    {
                        "username": "Awesome_7",
                        "content": "my code is expecting false for that in test case 70.\\ncan somebody look at this:\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        string opening=\"\";\\n        string closing=\"\";\\n\\n        for(auto i:s){\\n            if(i==\\'(\\' || i==\\'{\\' || i==\\'[\\' ){\\n                opening.push_back(i);\\n            }else{\\n                closing.push_back(i);\\n            }\\n        }\\n\\n        if(opening.length()!=closing.length()){\\n            return false;\\n        }\\n\\n        for(int i=0;i<opening.length();i++){\\n            if(opening[i]==\\'(\\'&& closing[i]!=\\')\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'{\\'&& closing[i]!=\\'}\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'[\\'&& closing[i]!=\\']\\'){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "chavaninc",
                        "content": "Came here to say this. Sadly I already had my submission wrong"
                    },
                    {
                        "username": "hkurmi",
                        "content": "exactly just got my first submission wrong becouse of this"
                    },
                    {
                        "username": "rafaelcitj",
                        "content": "[@D-Panda](/D-Panda) I had exact the same question after reading the description, thanks for clarifying."
                    },
                    {
                        "username": "rayhanul17",
                        "content": "[@hosua](/hosua) haha"
                    },
                    {
                        "username": "siddhanttamgadge4",
                        "content": "Yes it is allowed!"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua)  : )"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua) : ^)"
                    },
                    {
                        "username": "D-Panda",
                        "content": "it is valid"
                    },
                    {
                        "username": "hosua",
                        "content": "To answer your question 6 years later, yes, it is valid. "
                    },
                    {
                        "username": "rishavm",
                        "content": "Totally Agree! Due to lack of description in the question. My submission was rejected 3-4 times on the test cases which are not fulfilling the description of the problem. Although question is easy, but lack of description cause us time and our record."
                    },
                    {
                        "username": "omerkarabulut169",
                        "content": "Same my code 66/92 because of that"
                    },
                    {
                        "username": "minhtq9700",
                        "content": "yeah"
                    },
                    {
                        "username": "lwear2",
                        "content": "I agree.  Solved it twice from scratch only to find there are new requirements that manifest in testing.  Now I\\'m having to start again from scratch and pretty frustrated.  My second approach (recursive) simply won\\'t work in one submission test case.  This may be a little TOO real world for the learning environment.  There are classes in Requirements Engineering.  Like Agile and algorithms, they are very important to the professional.\\n\\nI strongly suggest clarifying the fact that the coder should allow for nested parentheses and that the nesting may be complex.\\n\\nRather than this wording, \"Open brackets must be closed in the CORRECT order.\"  (In whose mind?)\\n\\nI strongly suggest this: \"For strings that involve complex nesting, each bracket must be closed in the correct order.\"\\n\\nThis makes clear that \"correct\" is referring to nesting order, not front to back, or first open, or outside to inside, or some other \"correct\" order."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "sxltie",
                        "content": "precisely.. from the description one can\\u2019t even tell if (()) is valid or not.. they don\\u2019t include nested parentheses"
                    },
                    {
                        "username": "tonybrasunas",
                        "content": "The description for this one should say `([]{})` is valid too. Otherwise it's not clear that validating nested parentheses is part of the requirements."
                    },
                    {
                        "username": "bupty3e3",
                        "content": "Yeah, this question wasn\\'t that clear to this end."
                    },
                    {
                        "username": "ecapoferri",
                        "content": "Thanks for posting. I was wondering and went to discussion for clarification."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "bryanAM",
                        "content": "It\\'s a really **good** problem. But I don\\'t think it\\'s appropriate to call it **Easy**. If you\\'ve never had a question like this before, and if you\\'re new to python and programming - which is my guess the target audiance for easy questions - it\\'s a little difficult."
                    },
                    {
                        "username": "a098707730135",
                        "content": "[@JuanQP](/JuanQP) Thank you so much! You gave me the most useful hint!"
                    },
                    {
                        "username": "Rave17",
                        "content": "[@nicolobos77](/nicolobos77) thank you very much. this was crucial advice for leetcode newbie like me"
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "Totally agree. It isnt an easy problem."
                    },
                    {
                        "username": "gurunathkulkarni164",
                        "content": "You go to know stack for this problem."
                    },
                    {
                        "username": "JuanQP",
                        "content": "The only thing you need to solve this is knowing what a stack is. In first year of any engineering or comp-sci career you learn this in the first year"
                    },
                    {
                        "username": "nicolobos77",
                        "content": "It\\'s easy you just have to implement a memory managment with a char* as a stack in C, you push every open bracket, and pop one when there\\'s a close bracket that matches with the last opened bracket, if it doesn\\'t match, just return false, and if the string loop ended and there\\'s at least one bracket in the stack, return false, if it ends with an empty stack and every bracket is open and close correctly return true"
                    },
                    {
                        "username": "matthcraig",
                        "content": "The word \"easy\" in leetcode is a total misnomer and a relative description.  There are no easy leetcode questions.  "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "ikr"
                    },
                    {
                        "username": "tryhard00",
                        "content": "This problem could be considered easy but only if you realized the crux of it. If you tried to do it using pure conditionals, which I did for the first 3 hours, you\\'re in for a very bad time. I finally gave up on conditionals when it had a nested within nested case. I was about to go 3d array to store each set but it was so logically complex I almost quit. Then I saw it. So this problem could considered medium if you didn\\'t see the easy answer. Overall, a very clever question. It had so many caveats that I kept getting rejected and it was giving me pstd by the end. lol. For those who are stuck, the hint is what goes in last must come out first."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "Your hint at the last helped me solve the problem quickly \\uD83D\\uDE0A. Thanks."
                    },
                    {
                        "username": "zaynahmad20",
                        "content": "You sure do know how to not spoil a question and give a good hint. Thanks lol"
                    },
                    {
                        "username": "ejaza",
                        "content": "wow man thanks a great hint now i am able to do it \"the hint is what goes in last must come out first.\""
                    },
                    {
                        "username": "johnopj",
                        "content": "Exactly!! The door opened last should be closed first."
                    },
                    {
                        "username": "devindesu",
                        "content": "Mother $^#& I spent much more than 3 hours trying to force it to work with nested conditionals...Thank you for the hint. If they're gonna classify this as Easy they should at least defined the stack class for us  lol"
                    },
                    {
                        "username": "amitkhedkar41",
                        "content": "From this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid.\\nThen I think the problem description should be updated"
                    },
                    {
                        "username": "meergato247",
                        "content": "Exactly. I assumed the pairs just had to be {} () or [], the problem statement never said anything about them possibly being inside one another. "
                    },
                    {
                        "username": "RSK_Ua",
                        "content": "Here is some tip:\\nThe first line of the function uses a guard statement to check if the length of the input string is even. If the length is odd, the function returns false because it means that the brackets are not properly balanced.\\nThe next line creates an empty stack of characters to store the opening brackets.\\nThe function then loops through each character item in the input string s.\\nFor each character item, the code checks whether it is an opening bracket: (, [, or {. If it is, the corresponding closing bracket is pushed onto the stack. For example, if the character is (, the character ) is pushed onto the stack.\\nIf the character is a closing bracket: ), ], or }, the code checks whether the stack is empty. If the stack is empty, it means that there is no opening bracket to match the closing bracket, so the function returns false. If the stack is not empty, the last opening bracket is removed from the stack and checked against the current closing bracket. If the brackets do not match, the function returns false.\\nAfter looping through all the characters in the input string, the function checks whether the stack is empty. If it is, it means that all the opening brackets have been matched with their corresponding closing brackets, so the function returns true. If the stack is not empty, it means that there are unmatched opening brackets, so the function returns false."
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "well explained, I managed to create a solution based on your logic. Thanks a lot\\n"
                    },
                    {
                        "username": "shekardaval",
                        "content": "for the string \\'(]\\' my code is working fine with python 3.7, but here its showing wrong output"
                    },
                    {
                        "username": "benjayy",
                        "content": "I fixed it by returning the boolean rather than the strings. "
                    },
                    {
                        "username": "Aleks_Kim",
                        "content": "[@gvolsky](/gvolsky) Thank you, it is really solution"
                    },
                    {
                        "username": "muqeetkhawaja",
                        "content": "[@gvolsky](/gvolsky) Thanks Brother."
                    },
                    {
                        "username": "gvolsky",
                        "content": "Maybe you, like me, return 'true' and 'false' as strings, not as booleans True and False."
                    },
                    {
                        "username": "wayneli-5",
                        "content": "[@saiharish_g](/saiharish_g) I have this issue too. Have you found a solution? Thank you!"
                    },
                    {
                        "username": "keerthisravanigude",
                        "content": "[@fizah](/fizah) ya same with me also\\n"
                    },
                    {
                        "username": "saiharish_g",
                        "content": "so have you find the real issue actually??"
                    },
                    {
                        "username": "fizah",
                        "content": "same"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "user8796tT",
                        "content": "whats wrong with this TC \"{[]}\" in custom test cases run it succeed but it fails on submission.  \\n![image](https://assets.leetcode.com/users/images/0a36f8a9-6403-4cb8-a073-933a7ded9abe_1609523958.1513097.png)\\n\""
                    },
                    {
                        "username": "ms0686714",
                        "content": "Might be a global variable issue.Make sure initialize the global variable in the begining of main function."
                    },
                    {
                        "username": "kanwarudaysingh",
                        "content": "I was asked to do this in o(1) memory in an interview! Anyone knows how to do that?"
                    },
                    {
                        "username": "0bro",
                        "content": "They probably also required 10 years experience in Rust (Rust came out 8 years ago) lol"
                    },
                    {
                        "username": "data-stack",
                        "content": "Well, you can solve it with a regular expression in O(1) space complexity "
                    },
                    {
                        "username": "rennasccenth",
                        "content": "[@psi_psi](/psi_psi) \"For every\" states something that needs to be iterated, which means nothing less than O(n)"
                    },
                    {
                        "username": "charonme",
                        "content": "I tried a stackless solution with O(1) additional space (not counting the in-place modification of the input string), but it\\'s O(n^2) time"
                    },
                    {
                        "username": "psi_psi",
                        "content": "For every closing char, repeat the search (recursively and repeatedly) backwards (and with inversed opening and closing chars) until you are out of string or you reach the next (in this case, previous) opening char in the string. If that next one is your corresponding opening char, you continue forwards. It is not going to be very fast."
                    },
                    {
                        "username": "astro12",
                        "content": "What is the company name? I\\'ll make sure I\\'ll add that to my blacklist"
                    },
                    {
                        "username": "jigar100",
                        "content": "Did the interviewer asked to do this in O(1) space by maintaining O(n) time complexity"
                    },
                    {
                        "username": "lwear2",
                        "content": "https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/715/introduction/4654/\\n\\nIn the section of Space Analysis it indicates that input and output arrays are not included in memory analysis for BigO.  So, cycle through the input as many times as necessary, modifying the array each time and don\\'t create any new storage space for the array."
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Did u find solution to do that as o1  (javscript)"
                    },
                    {
                        "username": "Alexander2049",
                        "content": "Description is not good enough. Should be shown some more test cases as \"( [ ) ]\", because \"Open brackets must be closed in the correct order\" could be missunderstood."
                    },
                    {
                        "username": "ananya_dash16",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) Same with me.\\n"
                    },
                    {
                        "username": "rahulschandak",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) I have the same doubt"
                    },
                    {
                        "username": "AnkushKrVerma",
                        "content": "yess even now i can\\'t understand the problem.\\nwhy the TC \"( [ ) ]\" returning false ???\\nhelp me understand the problem "
                    }
                ]
            },
            {
                "id": 1569769,
                "content": [
                    {
                        "username": "sunwangshu",
                        "content": "The brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\\n\\nFrom this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid. \\nThen I think the problem description should be updated."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "Exactly."
                    },
                    {
                        "username": "Awesome_7",
                        "content": "my code is expecting false for that in test case 70.\\ncan somebody look at this:\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        string opening=\"\";\\n        string closing=\"\";\\n\\n        for(auto i:s){\\n            if(i==\\'(\\' || i==\\'{\\' || i==\\'[\\' ){\\n                opening.push_back(i);\\n            }else{\\n                closing.push_back(i);\\n            }\\n        }\\n\\n        if(opening.length()!=closing.length()){\\n            return false;\\n        }\\n\\n        for(int i=0;i<opening.length();i++){\\n            if(opening[i]==\\'(\\'&& closing[i]!=\\')\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'{\\'&& closing[i]!=\\'}\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'[\\'&& closing[i]!=\\']\\'){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "chavaninc",
                        "content": "Came here to say this. Sadly I already had my submission wrong"
                    },
                    {
                        "username": "hkurmi",
                        "content": "exactly just got my first submission wrong becouse of this"
                    },
                    {
                        "username": "rafaelcitj",
                        "content": "[@D-Panda](/D-Panda) I had exact the same question after reading the description, thanks for clarifying."
                    },
                    {
                        "username": "rayhanul17",
                        "content": "[@hosua](/hosua) haha"
                    },
                    {
                        "username": "siddhanttamgadge4",
                        "content": "Yes it is allowed!"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua)  : )"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua) : ^)"
                    },
                    {
                        "username": "D-Panda",
                        "content": "it is valid"
                    },
                    {
                        "username": "hosua",
                        "content": "To answer your question 6 years later, yes, it is valid. "
                    },
                    {
                        "username": "rishavm",
                        "content": "Totally Agree! Due to lack of description in the question. My submission was rejected 3-4 times on the test cases which are not fulfilling the description of the problem. Although question is easy, but lack of description cause us time and our record."
                    },
                    {
                        "username": "omerkarabulut169",
                        "content": "Same my code 66/92 because of that"
                    },
                    {
                        "username": "minhtq9700",
                        "content": "yeah"
                    },
                    {
                        "username": "lwear2",
                        "content": "I agree.  Solved it twice from scratch only to find there are new requirements that manifest in testing.  Now I\\'m having to start again from scratch and pretty frustrated.  My second approach (recursive) simply won\\'t work in one submission test case.  This may be a little TOO real world for the learning environment.  There are classes in Requirements Engineering.  Like Agile and algorithms, they are very important to the professional.\\n\\nI strongly suggest clarifying the fact that the coder should allow for nested parentheses and that the nesting may be complex.\\n\\nRather than this wording, \"Open brackets must be closed in the CORRECT order.\"  (In whose mind?)\\n\\nI strongly suggest this: \"For strings that involve complex nesting, each bracket must be closed in the correct order.\"\\n\\nThis makes clear that \"correct\" is referring to nesting order, not front to back, or first open, or outside to inside, or some other \"correct\" order."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "sxltie",
                        "content": "precisely.. from the description one can\\u2019t even tell if (()) is valid or not.. they don\\u2019t include nested parentheses"
                    },
                    {
                        "username": "tonybrasunas",
                        "content": "The description for this one should say `([]{})` is valid too. Otherwise it's not clear that validating nested parentheses is part of the requirements."
                    },
                    {
                        "username": "bupty3e3",
                        "content": "Yeah, this question wasn\\'t that clear to this end."
                    },
                    {
                        "username": "ecapoferri",
                        "content": "Thanks for posting. I was wondering and went to discussion for clarification."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "bryanAM",
                        "content": "It\\'s a really **good** problem. But I don\\'t think it\\'s appropriate to call it **Easy**. If you\\'ve never had a question like this before, and if you\\'re new to python and programming - which is my guess the target audiance for easy questions - it\\'s a little difficult."
                    },
                    {
                        "username": "a098707730135",
                        "content": "[@JuanQP](/JuanQP) Thank you so much! You gave me the most useful hint!"
                    },
                    {
                        "username": "Rave17",
                        "content": "[@nicolobos77](/nicolobos77) thank you very much. this was crucial advice for leetcode newbie like me"
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "Totally agree. It isnt an easy problem."
                    },
                    {
                        "username": "gurunathkulkarni164",
                        "content": "You go to know stack for this problem."
                    },
                    {
                        "username": "JuanQP",
                        "content": "The only thing you need to solve this is knowing what a stack is. In first year of any engineering or comp-sci career you learn this in the first year"
                    },
                    {
                        "username": "nicolobos77",
                        "content": "It\\'s easy you just have to implement a memory managment with a char* as a stack in C, you push every open bracket, and pop one when there\\'s a close bracket that matches with the last opened bracket, if it doesn\\'t match, just return false, and if the string loop ended and there\\'s at least one bracket in the stack, return false, if it ends with an empty stack and every bracket is open and close correctly return true"
                    },
                    {
                        "username": "matthcraig",
                        "content": "The word \"easy\" in leetcode is a total misnomer and a relative description.  There are no easy leetcode questions.  "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "ikr"
                    },
                    {
                        "username": "tryhard00",
                        "content": "This problem could be considered easy but only if you realized the crux of it. If you tried to do it using pure conditionals, which I did for the first 3 hours, you\\'re in for a very bad time. I finally gave up on conditionals when it had a nested within nested case. I was about to go 3d array to store each set but it was so logically complex I almost quit. Then I saw it. So this problem could considered medium if you didn\\'t see the easy answer. Overall, a very clever question. It had so many caveats that I kept getting rejected and it was giving me pstd by the end. lol. For those who are stuck, the hint is what goes in last must come out first."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "Your hint at the last helped me solve the problem quickly \\uD83D\\uDE0A. Thanks."
                    },
                    {
                        "username": "zaynahmad20",
                        "content": "You sure do know how to not spoil a question and give a good hint. Thanks lol"
                    },
                    {
                        "username": "ejaza",
                        "content": "wow man thanks a great hint now i am able to do it \"the hint is what goes in last must come out first.\""
                    },
                    {
                        "username": "johnopj",
                        "content": "Exactly!! The door opened last should be closed first."
                    },
                    {
                        "username": "devindesu",
                        "content": "Mother $^#& I spent much more than 3 hours trying to force it to work with nested conditionals...Thank you for the hint. If they're gonna classify this as Easy they should at least defined the stack class for us  lol"
                    },
                    {
                        "username": "amitkhedkar41",
                        "content": "From this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid.\\nThen I think the problem description should be updated"
                    },
                    {
                        "username": "meergato247",
                        "content": "Exactly. I assumed the pairs just had to be {} () or [], the problem statement never said anything about them possibly being inside one another. "
                    },
                    {
                        "username": "RSK_Ua",
                        "content": "Here is some tip:\\nThe first line of the function uses a guard statement to check if the length of the input string is even. If the length is odd, the function returns false because it means that the brackets are not properly balanced.\\nThe next line creates an empty stack of characters to store the opening brackets.\\nThe function then loops through each character item in the input string s.\\nFor each character item, the code checks whether it is an opening bracket: (, [, or {. If it is, the corresponding closing bracket is pushed onto the stack. For example, if the character is (, the character ) is pushed onto the stack.\\nIf the character is a closing bracket: ), ], or }, the code checks whether the stack is empty. If the stack is empty, it means that there is no opening bracket to match the closing bracket, so the function returns false. If the stack is not empty, the last opening bracket is removed from the stack and checked against the current closing bracket. If the brackets do not match, the function returns false.\\nAfter looping through all the characters in the input string, the function checks whether the stack is empty. If it is, it means that all the opening brackets have been matched with their corresponding closing brackets, so the function returns true. If the stack is not empty, it means that there are unmatched opening brackets, so the function returns false."
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "well explained, I managed to create a solution based on your logic. Thanks a lot\\n"
                    },
                    {
                        "username": "shekardaval",
                        "content": "for the string \\'(]\\' my code is working fine with python 3.7, but here its showing wrong output"
                    },
                    {
                        "username": "benjayy",
                        "content": "I fixed it by returning the boolean rather than the strings. "
                    },
                    {
                        "username": "Aleks_Kim",
                        "content": "[@gvolsky](/gvolsky) Thank you, it is really solution"
                    },
                    {
                        "username": "muqeetkhawaja",
                        "content": "[@gvolsky](/gvolsky) Thanks Brother."
                    },
                    {
                        "username": "gvolsky",
                        "content": "Maybe you, like me, return 'true' and 'false' as strings, not as booleans True and False."
                    },
                    {
                        "username": "wayneli-5",
                        "content": "[@saiharish_g](/saiharish_g) I have this issue too. Have you found a solution? Thank you!"
                    },
                    {
                        "username": "keerthisravanigude",
                        "content": "[@fizah](/fizah) ya same with me also\\n"
                    },
                    {
                        "username": "saiharish_g",
                        "content": "so have you find the real issue actually??"
                    },
                    {
                        "username": "fizah",
                        "content": "same"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "user8796tT",
                        "content": "whats wrong with this TC \"{[]}\" in custom test cases run it succeed but it fails on submission.  \\n![image](https://assets.leetcode.com/users/images/0a36f8a9-6403-4cb8-a073-933a7ded9abe_1609523958.1513097.png)\\n\""
                    },
                    {
                        "username": "ms0686714",
                        "content": "Might be a global variable issue.Make sure initialize the global variable in the begining of main function."
                    },
                    {
                        "username": "kanwarudaysingh",
                        "content": "I was asked to do this in o(1) memory in an interview! Anyone knows how to do that?"
                    },
                    {
                        "username": "0bro",
                        "content": "They probably also required 10 years experience in Rust (Rust came out 8 years ago) lol"
                    },
                    {
                        "username": "data-stack",
                        "content": "Well, you can solve it with a regular expression in O(1) space complexity "
                    },
                    {
                        "username": "rennasccenth",
                        "content": "[@psi_psi](/psi_psi) \"For every\" states something that needs to be iterated, which means nothing less than O(n)"
                    },
                    {
                        "username": "charonme",
                        "content": "I tried a stackless solution with O(1) additional space (not counting the in-place modification of the input string), but it\\'s O(n^2) time"
                    },
                    {
                        "username": "psi_psi",
                        "content": "For every closing char, repeat the search (recursively and repeatedly) backwards (and with inversed opening and closing chars) until you are out of string or you reach the next (in this case, previous) opening char in the string. If that next one is your corresponding opening char, you continue forwards. It is not going to be very fast."
                    },
                    {
                        "username": "astro12",
                        "content": "What is the company name? I\\'ll make sure I\\'ll add that to my blacklist"
                    },
                    {
                        "username": "jigar100",
                        "content": "Did the interviewer asked to do this in O(1) space by maintaining O(n) time complexity"
                    },
                    {
                        "username": "lwear2",
                        "content": "https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/715/introduction/4654/\\n\\nIn the section of Space Analysis it indicates that input and output arrays are not included in memory analysis for BigO.  So, cycle through the input as many times as necessary, modifying the array each time and don\\'t create any new storage space for the array."
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Did u find solution to do that as o1  (javscript)"
                    },
                    {
                        "username": "Alexander2049",
                        "content": "Description is not good enough. Should be shown some more test cases as \"( [ ) ]\", because \"Open brackets must be closed in the correct order\" could be missunderstood."
                    },
                    {
                        "username": "ananya_dash16",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) Same with me.\\n"
                    },
                    {
                        "username": "rahulschandak",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) I have the same doubt"
                    },
                    {
                        "username": "AnkushKrVerma",
                        "content": "yess even now i can\\'t understand the problem.\\nwhy the TC \"( [ ) ]\" returning false ???\\nhelp me understand the problem "
                    }
                ]
            },
            {
                "id": 1570278,
                "content": [
                    {
                        "username": "sunwangshu",
                        "content": "The brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\\n\\nFrom this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid. \\nThen I think the problem description should be updated."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "Exactly."
                    },
                    {
                        "username": "Awesome_7",
                        "content": "my code is expecting false for that in test case 70.\\ncan somebody look at this:\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        string opening=\"\";\\n        string closing=\"\";\\n\\n        for(auto i:s){\\n            if(i==\\'(\\' || i==\\'{\\' || i==\\'[\\' ){\\n                opening.push_back(i);\\n            }else{\\n                closing.push_back(i);\\n            }\\n        }\\n\\n        if(opening.length()!=closing.length()){\\n            return false;\\n        }\\n\\n        for(int i=0;i<opening.length();i++){\\n            if(opening[i]==\\'(\\'&& closing[i]!=\\')\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'{\\'&& closing[i]!=\\'}\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'[\\'&& closing[i]!=\\']\\'){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "chavaninc",
                        "content": "Came here to say this. Sadly I already had my submission wrong"
                    },
                    {
                        "username": "hkurmi",
                        "content": "exactly just got my first submission wrong becouse of this"
                    },
                    {
                        "username": "rafaelcitj",
                        "content": "[@D-Panda](/D-Panda) I had exact the same question after reading the description, thanks for clarifying."
                    },
                    {
                        "username": "rayhanul17",
                        "content": "[@hosua](/hosua) haha"
                    },
                    {
                        "username": "siddhanttamgadge4",
                        "content": "Yes it is allowed!"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua)  : )"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua) : ^)"
                    },
                    {
                        "username": "D-Panda",
                        "content": "it is valid"
                    },
                    {
                        "username": "hosua",
                        "content": "To answer your question 6 years later, yes, it is valid. "
                    },
                    {
                        "username": "rishavm",
                        "content": "Totally Agree! Due to lack of description in the question. My submission was rejected 3-4 times on the test cases which are not fulfilling the description of the problem. Although question is easy, but lack of description cause us time and our record."
                    },
                    {
                        "username": "omerkarabulut169",
                        "content": "Same my code 66/92 because of that"
                    },
                    {
                        "username": "minhtq9700",
                        "content": "yeah"
                    },
                    {
                        "username": "lwear2",
                        "content": "I agree.  Solved it twice from scratch only to find there are new requirements that manifest in testing.  Now I\\'m having to start again from scratch and pretty frustrated.  My second approach (recursive) simply won\\'t work in one submission test case.  This may be a little TOO real world for the learning environment.  There are classes in Requirements Engineering.  Like Agile and algorithms, they are very important to the professional.\\n\\nI strongly suggest clarifying the fact that the coder should allow for nested parentheses and that the nesting may be complex.\\n\\nRather than this wording, \"Open brackets must be closed in the CORRECT order.\"  (In whose mind?)\\n\\nI strongly suggest this: \"For strings that involve complex nesting, each bracket must be closed in the correct order.\"\\n\\nThis makes clear that \"correct\" is referring to nesting order, not front to back, or first open, or outside to inside, or some other \"correct\" order."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "sxltie",
                        "content": "precisely.. from the description one can\\u2019t even tell if (()) is valid or not.. they don\\u2019t include nested parentheses"
                    },
                    {
                        "username": "tonybrasunas",
                        "content": "The description for this one should say `([]{})` is valid too. Otherwise it's not clear that validating nested parentheses is part of the requirements."
                    },
                    {
                        "username": "bupty3e3",
                        "content": "Yeah, this question wasn\\'t that clear to this end."
                    },
                    {
                        "username": "ecapoferri",
                        "content": "Thanks for posting. I was wondering and went to discussion for clarification."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "bryanAM",
                        "content": "It\\'s a really **good** problem. But I don\\'t think it\\'s appropriate to call it **Easy**. If you\\'ve never had a question like this before, and if you\\'re new to python and programming - which is my guess the target audiance for easy questions - it\\'s a little difficult."
                    },
                    {
                        "username": "a098707730135",
                        "content": "[@JuanQP](/JuanQP) Thank you so much! You gave me the most useful hint!"
                    },
                    {
                        "username": "Rave17",
                        "content": "[@nicolobos77](/nicolobos77) thank you very much. this was crucial advice for leetcode newbie like me"
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "Totally agree. It isnt an easy problem."
                    },
                    {
                        "username": "gurunathkulkarni164",
                        "content": "You go to know stack for this problem."
                    },
                    {
                        "username": "JuanQP",
                        "content": "The only thing you need to solve this is knowing what a stack is. In first year of any engineering or comp-sci career you learn this in the first year"
                    },
                    {
                        "username": "nicolobos77",
                        "content": "It\\'s easy you just have to implement a memory managment with a char* as a stack in C, you push every open bracket, and pop one when there\\'s a close bracket that matches with the last opened bracket, if it doesn\\'t match, just return false, and if the string loop ended and there\\'s at least one bracket in the stack, return false, if it ends with an empty stack and every bracket is open and close correctly return true"
                    },
                    {
                        "username": "matthcraig",
                        "content": "The word \"easy\" in leetcode is a total misnomer and a relative description.  There are no easy leetcode questions.  "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "ikr"
                    },
                    {
                        "username": "tryhard00",
                        "content": "This problem could be considered easy but only if you realized the crux of it. If you tried to do it using pure conditionals, which I did for the first 3 hours, you\\'re in for a very bad time. I finally gave up on conditionals when it had a nested within nested case. I was about to go 3d array to store each set but it was so logically complex I almost quit. Then I saw it. So this problem could considered medium if you didn\\'t see the easy answer. Overall, a very clever question. It had so many caveats that I kept getting rejected and it was giving me pstd by the end. lol. For those who are stuck, the hint is what goes in last must come out first."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "Your hint at the last helped me solve the problem quickly \\uD83D\\uDE0A. Thanks."
                    },
                    {
                        "username": "zaynahmad20",
                        "content": "You sure do know how to not spoil a question and give a good hint. Thanks lol"
                    },
                    {
                        "username": "ejaza",
                        "content": "wow man thanks a great hint now i am able to do it \"the hint is what goes in last must come out first.\""
                    },
                    {
                        "username": "johnopj",
                        "content": "Exactly!! The door opened last should be closed first."
                    },
                    {
                        "username": "devindesu",
                        "content": "Mother $^#& I spent much more than 3 hours trying to force it to work with nested conditionals...Thank you for the hint. If they're gonna classify this as Easy they should at least defined the stack class for us  lol"
                    },
                    {
                        "username": "amitkhedkar41",
                        "content": "From this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid.\\nThen I think the problem description should be updated"
                    },
                    {
                        "username": "meergato247",
                        "content": "Exactly. I assumed the pairs just had to be {} () or [], the problem statement never said anything about them possibly being inside one another. "
                    },
                    {
                        "username": "RSK_Ua",
                        "content": "Here is some tip:\\nThe first line of the function uses a guard statement to check if the length of the input string is even. If the length is odd, the function returns false because it means that the brackets are not properly balanced.\\nThe next line creates an empty stack of characters to store the opening brackets.\\nThe function then loops through each character item in the input string s.\\nFor each character item, the code checks whether it is an opening bracket: (, [, or {. If it is, the corresponding closing bracket is pushed onto the stack. For example, if the character is (, the character ) is pushed onto the stack.\\nIf the character is a closing bracket: ), ], or }, the code checks whether the stack is empty. If the stack is empty, it means that there is no opening bracket to match the closing bracket, so the function returns false. If the stack is not empty, the last opening bracket is removed from the stack and checked against the current closing bracket. If the brackets do not match, the function returns false.\\nAfter looping through all the characters in the input string, the function checks whether the stack is empty. If it is, it means that all the opening brackets have been matched with their corresponding closing brackets, so the function returns true. If the stack is not empty, it means that there are unmatched opening brackets, so the function returns false."
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "well explained, I managed to create a solution based on your logic. Thanks a lot\\n"
                    },
                    {
                        "username": "shekardaval",
                        "content": "for the string \\'(]\\' my code is working fine with python 3.7, but here its showing wrong output"
                    },
                    {
                        "username": "benjayy",
                        "content": "I fixed it by returning the boolean rather than the strings. "
                    },
                    {
                        "username": "Aleks_Kim",
                        "content": "[@gvolsky](/gvolsky) Thank you, it is really solution"
                    },
                    {
                        "username": "muqeetkhawaja",
                        "content": "[@gvolsky](/gvolsky) Thanks Brother."
                    },
                    {
                        "username": "gvolsky",
                        "content": "Maybe you, like me, return 'true' and 'false' as strings, not as booleans True and False."
                    },
                    {
                        "username": "wayneli-5",
                        "content": "[@saiharish_g](/saiharish_g) I have this issue too. Have you found a solution? Thank you!"
                    },
                    {
                        "username": "keerthisravanigude",
                        "content": "[@fizah](/fizah) ya same with me also\\n"
                    },
                    {
                        "username": "saiharish_g",
                        "content": "so have you find the real issue actually??"
                    },
                    {
                        "username": "fizah",
                        "content": "same"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "user8796tT",
                        "content": "whats wrong with this TC \"{[]}\" in custom test cases run it succeed but it fails on submission.  \\n![image](https://assets.leetcode.com/users/images/0a36f8a9-6403-4cb8-a073-933a7ded9abe_1609523958.1513097.png)\\n\""
                    },
                    {
                        "username": "ms0686714",
                        "content": "Might be a global variable issue.Make sure initialize the global variable in the begining of main function."
                    },
                    {
                        "username": "kanwarudaysingh",
                        "content": "I was asked to do this in o(1) memory in an interview! Anyone knows how to do that?"
                    },
                    {
                        "username": "0bro",
                        "content": "They probably also required 10 years experience in Rust (Rust came out 8 years ago) lol"
                    },
                    {
                        "username": "data-stack",
                        "content": "Well, you can solve it with a regular expression in O(1) space complexity "
                    },
                    {
                        "username": "rennasccenth",
                        "content": "[@psi_psi](/psi_psi) \"For every\" states something that needs to be iterated, which means nothing less than O(n)"
                    },
                    {
                        "username": "charonme",
                        "content": "I tried a stackless solution with O(1) additional space (not counting the in-place modification of the input string), but it\\'s O(n^2) time"
                    },
                    {
                        "username": "psi_psi",
                        "content": "For every closing char, repeat the search (recursively and repeatedly) backwards (and with inversed opening and closing chars) until you are out of string or you reach the next (in this case, previous) opening char in the string. If that next one is your corresponding opening char, you continue forwards. It is not going to be very fast."
                    },
                    {
                        "username": "astro12",
                        "content": "What is the company name? I\\'ll make sure I\\'ll add that to my blacklist"
                    },
                    {
                        "username": "jigar100",
                        "content": "Did the interviewer asked to do this in O(1) space by maintaining O(n) time complexity"
                    },
                    {
                        "username": "lwear2",
                        "content": "https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/715/introduction/4654/\\n\\nIn the section of Space Analysis it indicates that input and output arrays are not included in memory analysis for BigO.  So, cycle through the input as many times as necessary, modifying the array each time and don\\'t create any new storage space for the array."
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Did u find solution to do that as o1  (javscript)"
                    },
                    {
                        "username": "Alexander2049",
                        "content": "Description is not good enough. Should be shown some more test cases as \"( [ ) ]\", because \"Open brackets must be closed in the correct order\" could be missunderstood."
                    },
                    {
                        "username": "ananya_dash16",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) Same with me.\\n"
                    },
                    {
                        "username": "rahulschandak",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) I have the same doubt"
                    },
                    {
                        "username": "AnkushKrVerma",
                        "content": "yess even now i can\\'t understand the problem.\\nwhy the TC \"( [ ) ]\" returning false ???\\nhelp me understand the problem "
                    }
                ]
            },
            {
                "id": 1571051,
                "content": [
                    {
                        "username": "sunwangshu",
                        "content": "The brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\\n\\nFrom this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid. \\nThen I think the problem description should be updated."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "Exactly."
                    },
                    {
                        "username": "Awesome_7",
                        "content": "my code is expecting false for that in test case 70.\\ncan somebody look at this:\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        string opening=\"\";\\n        string closing=\"\";\\n\\n        for(auto i:s){\\n            if(i==\\'(\\' || i==\\'{\\' || i==\\'[\\' ){\\n                opening.push_back(i);\\n            }else{\\n                closing.push_back(i);\\n            }\\n        }\\n\\n        if(opening.length()!=closing.length()){\\n            return false;\\n        }\\n\\n        for(int i=0;i<opening.length();i++){\\n            if(opening[i]==\\'(\\'&& closing[i]!=\\')\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'{\\'&& closing[i]!=\\'}\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'[\\'&& closing[i]!=\\']\\'){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "chavaninc",
                        "content": "Came here to say this. Sadly I already had my submission wrong"
                    },
                    {
                        "username": "hkurmi",
                        "content": "exactly just got my first submission wrong becouse of this"
                    },
                    {
                        "username": "rafaelcitj",
                        "content": "[@D-Panda](/D-Panda) I had exact the same question after reading the description, thanks for clarifying."
                    },
                    {
                        "username": "rayhanul17",
                        "content": "[@hosua](/hosua) haha"
                    },
                    {
                        "username": "siddhanttamgadge4",
                        "content": "Yes it is allowed!"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua)  : )"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua) : ^)"
                    },
                    {
                        "username": "D-Panda",
                        "content": "it is valid"
                    },
                    {
                        "username": "hosua",
                        "content": "To answer your question 6 years later, yes, it is valid. "
                    },
                    {
                        "username": "rishavm",
                        "content": "Totally Agree! Due to lack of description in the question. My submission was rejected 3-4 times on the test cases which are not fulfilling the description of the problem. Although question is easy, but lack of description cause us time and our record."
                    },
                    {
                        "username": "omerkarabulut169",
                        "content": "Same my code 66/92 because of that"
                    },
                    {
                        "username": "minhtq9700",
                        "content": "yeah"
                    },
                    {
                        "username": "lwear2",
                        "content": "I agree.  Solved it twice from scratch only to find there are new requirements that manifest in testing.  Now I\\'m having to start again from scratch and pretty frustrated.  My second approach (recursive) simply won\\'t work in one submission test case.  This may be a little TOO real world for the learning environment.  There are classes in Requirements Engineering.  Like Agile and algorithms, they are very important to the professional.\\n\\nI strongly suggest clarifying the fact that the coder should allow for nested parentheses and that the nesting may be complex.\\n\\nRather than this wording, \"Open brackets must be closed in the CORRECT order.\"  (In whose mind?)\\n\\nI strongly suggest this: \"For strings that involve complex nesting, each bracket must be closed in the correct order.\"\\n\\nThis makes clear that \"correct\" is referring to nesting order, not front to back, or first open, or outside to inside, or some other \"correct\" order."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "sxltie",
                        "content": "precisely.. from the description one can\\u2019t even tell if (()) is valid or not.. they don\\u2019t include nested parentheses"
                    },
                    {
                        "username": "tonybrasunas",
                        "content": "The description for this one should say `([]{})` is valid too. Otherwise it's not clear that validating nested parentheses is part of the requirements."
                    },
                    {
                        "username": "bupty3e3",
                        "content": "Yeah, this question wasn\\'t that clear to this end."
                    },
                    {
                        "username": "ecapoferri",
                        "content": "Thanks for posting. I was wondering and went to discussion for clarification."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "bryanAM",
                        "content": "It\\'s a really **good** problem. But I don\\'t think it\\'s appropriate to call it **Easy**. If you\\'ve never had a question like this before, and if you\\'re new to python and programming - which is my guess the target audiance for easy questions - it\\'s a little difficult."
                    },
                    {
                        "username": "a098707730135",
                        "content": "[@JuanQP](/JuanQP) Thank you so much! You gave me the most useful hint!"
                    },
                    {
                        "username": "Rave17",
                        "content": "[@nicolobos77](/nicolobos77) thank you very much. this was crucial advice for leetcode newbie like me"
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "Totally agree. It isnt an easy problem."
                    },
                    {
                        "username": "gurunathkulkarni164",
                        "content": "You go to know stack for this problem."
                    },
                    {
                        "username": "JuanQP",
                        "content": "The only thing you need to solve this is knowing what a stack is. In first year of any engineering or comp-sci career you learn this in the first year"
                    },
                    {
                        "username": "nicolobos77",
                        "content": "It\\'s easy you just have to implement a memory managment with a char* as a stack in C, you push every open bracket, and pop one when there\\'s a close bracket that matches with the last opened bracket, if it doesn\\'t match, just return false, and if the string loop ended and there\\'s at least one bracket in the stack, return false, if it ends with an empty stack and every bracket is open and close correctly return true"
                    },
                    {
                        "username": "matthcraig",
                        "content": "The word \"easy\" in leetcode is a total misnomer and a relative description.  There are no easy leetcode questions.  "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "ikr"
                    },
                    {
                        "username": "tryhard00",
                        "content": "This problem could be considered easy but only if you realized the crux of it. If you tried to do it using pure conditionals, which I did for the first 3 hours, you\\'re in for a very bad time. I finally gave up on conditionals when it had a nested within nested case. I was about to go 3d array to store each set but it was so logically complex I almost quit. Then I saw it. So this problem could considered medium if you didn\\'t see the easy answer. Overall, a very clever question. It had so many caveats that I kept getting rejected and it was giving me pstd by the end. lol. For those who are stuck, the hint is what goes in last must come out first."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "Your hint at the last helped me solve the problem quickly \\uD83D\\uDE0A. Thanks."
                    },
                    {
                        "username": "zaynahmad20",
                        "content": "You sure do know how to not spoil a question and give a good hint. Thanks lol"
                    },
                    {
                        "username": "ejaza",
                        "content": "wow man thanks a great hint now i am able to do it \"the hint is what goes in last must come out first.\""
                    },
                    {
                        "username": "johnopj",
                        "content": "Exactly!! The door opened last should be closed first."
                    },
                    {
                        "username": "devindesu",
                        "content": "Mother $^#& I spent much more than 3 hours trying to force it to work with nested conditionals...Thank you for the hint. If they're gonna classify this as Easy they should at least defined the stack class for us  lol"
                    },
                    {
                        "username": "amitkhedkar41",
                        "content": "From this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid.\\nThen I think the problem description should be updated"
                    },
                    {
                        "username": "meergato247",
                        "content": "Exactly. I assumed the pairs just had to be {} () or [], the problem statement never said anything about them possibly being inside one another. "
                    },
                    {
                        "username": "RSK_Ua",
                        "content": "Here is some tip:\\nThe first line of the function uses a guard statement to check if the length of the input string is even. If the length is odd, the function returns false because it means that the brackets are not properly balanced.\\nThe next line creates an empty stack of characters to store the opening brackets.\\nThe function then loops through each character item in the input string s.\\nFor each character item, the code checks whether it is an opening bracket: (, [, or {. If it is, the corresponding closing bracket is pushed onto the stack. For example, if the character is (, the character ) is pushed onto the stack.\\nIf the character is a closing bracket: ), ], or }, the code checks whether the stack is empty. If the stack is empty, it means that there is no opening bracket to match the closing bracket, so the function returns false. If the stack is not empty, the last opening bracket is removed from the stack and checked against the current closing bracket. If the brackets do not match, the function returns false.\\nAfter looping through all the characters in the input string, the function checks whether the stack is empty. If it is, it means that all the opening brackets have been matched with their corresponding closing brackets, so the function returns true. If the stack is not empty, it means that there are unmatched opening brackets, so the function returns false."
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "well explained, I managed to create a solution based on your logic. Thanks a lot\\n"
                    },
                    {
                        "username": "shekardaval",
                        "content": "for the string \\'(]\\' my code is working fine with python 3.7, but here its showing wrong output"
                    },
                    {
                        "username": "benjayy",
                        "content": "I fixed it by returning the boolean rather than the strings. "
                    },
                    {
                        "username": "Aleks_Kim",
                        "content": "[@gvolsky](/gvolsky) Thank you, it is really solution"
                    },
                    {
                        "username": "muqeetkhawaja",
                        "content": "[@gvolsky](/gvolsky) Thanks Brother."
                    },
                    {
                        "username": "gvolsky",
                        "content": "Maybe you, like me, return 'true' and 'false' as strings, not as booleans True and False."
                    },
                    {
                        "username": "wayneli-5",
                        "content": "[@saiharish_g](/saiharish_g) I have this issue too. Have you found a solution? Thank you!"
                    },
                    {
                        "username": "keerthisravanigude",
                        "content": "[@fizah](/fizah) ya same with me also\\n"
                    },
                    {
                        "username": "saiharish_g",
                        "content": "so have you find the real issue actually??"
                    },
                    {
                        "username": "fizah",
                        "content": "same"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "user8796tT",
                        "content": "whats wrong with this TC \"{[]}\" in custom test cases run it succeed but it fails on submission.  \\n![image](https://assets.leetcode.com/users/images/0a36f8a9-6403-4cb8-a073-933a7ded9abe_1609523958.1513097.png)\\n\""
                    },
                    {
                        "username": "ms0686714",
                        "content": "Might be a global variable issue.Make sure initialize the global variable in the begining of main function."
                    },
                    {
                        "username": "kanwarudaysingh",
                        "content": "I was asked to do this in o(1) memory in an interview! Anyone knows how to do that?"
                    },
                    {
                        "username": "0bro",
                        "content": "They probably also required 10 years experience in Rust (Rust came out 8 years ago) lol"
                    },
                    {
                        "username": "data-stack",
                        "content": "Well, you can solve it with a regular expression in O(1) space complexity "
                    },
                    {
                        "username": "rennasccenth",
                        "content": "[@psi_psi](/psi_psi) \"For every\" states something that needs to be iterated, which means nothing less than O(n)"
                    },
                    {
                        "username": "charonme",
                        "content": "I tried a stackless solution with O(1) additional space (not counting the in-place modification of the input string), but it\\'s O(n^2) time"
                    },
                    {
                        "username": "psi_psi",
                        "content": "For every closing char, repeat the search (recursively and repeatedly) backwards (and with inversed opening and closing chars) until you are out of string or you reach the next (in this case, previous) opening char in the string. If that next one is your corresponding opening char, you continue forwards. It is not going to be very fast."
                    },
                    {
                        "username": "astro12",
                        "content": "What is the company name? I\\'ll make sure I\\'ll add that to my blacklist"
                    },
                    {
                        "username": "jigar100",
                        "content": "Did the interviewer asked to do this in O(1) space by maintaining O(n) time complexity"
                    },
                    {
                        "username": "lwear2",
                        "content": "https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/715/introduction/4654/\\n\\nIn the section of Space Analysis it indicates that input and output arrays are not included in memory analysis for BigO.  So, cycle through the input as many times as necessary, modifying the array each time and don\\'t create any new storage space for the array."
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Did u find solution to do that as o1  (javscript)"
                    },
                    {
                        "username": "Alexander2049",
                        "content": "Description is not good enough. Should be shown some more test cases as \"( [ ) ]\", because \"Open brackets must be closed in the correct order\" could be missunderstood."
                    },
                    {
                        "username": "ananya_dash16",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) Same with me.\\n"
                    },
                    {
                        "username": "rahulschandak",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) I have the same doubt"
                    },
                    {
                        "username": "AnkushKrVerma",
                        "content": "yess even now i can\\'t understand the problem.\\nwhy the TC \"( [ ) ]\" returning false ???\\nhelp me understand the problem "
                    }
                ]
            },
            {
                "id": 1918267,
                "content": [
                    {
                        "username": "sunwangshu",
                        "content": "The brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\\n\\nFrom this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid. \\nThen I think the problem description should be updated."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "Exactly."
                    },
                    {
                        "username": "Awesome_7",
                        "content": "my code is expecting false for that in test case 70.\\ncan somebody look at this:\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        string opening=\"\";\\n        string closing=\"\";\\n\\n        for(auto i:s){\\n            if(i==\\'(\\' || i==\\'{\\' || i==\\'[\\' ){\\n                opening.push_back(i);\\n            }else{\\n                closing.push_back(i);\\n            }\\n        }\\n\\n        if(opening.length()!=closing.length()){\\n            return false;\\n        }\\n\\n        for(int i=0;i<opening.length();i++){\\n            if(opening[i]==\\'(\\'&& closing[i]!=\\')\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'{\\'&& closing[i]!=\\'}\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'[\\'&& closing[i]!=\\']\\'){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "chavaninc",
                        "content": "Came here to say this. Sadly I already had my submission wrong"
                    },
                    {
                        "username": "hkurmi",
                        "content": "exactly just got my first submission wrong becouse of this"
                    },
                    {
                        "username": "rafaelcitj",
                        "content": "[@D-Panda](/D-Panda) I had exact the same question after reading the description, thanks for clarifying."
                    },
                    {
                        "username": "rayhanul17",
                        "content": "[@hosua](/hosua) haha"
                    },
                    {
                        "username": "siddhanttamgadge4",
                        "content": "Yes it is allowed!"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua)  : )"
                    },
                    {
                        "username": "James2134",
                        "content": "[@hosua](/hosua) : ^)"
                    },
                    {
                        "username": "D-Panda",
                        "content": "it is valid"
                    },
                    {
                        "username": "hosua",
                        "content": "To answer your question 6 years later, yes, it is valid. "
                    },
                    {
                        "username": "rishavm",
                        "content": "Totally Agree! Due to lack of description in the question. My submission was rejected 3-4 times on the test cases which are not fulfilling the description of the problem. Although question is easy, but lack of description cause us time and our record."
                    },
                    {
                        "username": "omerkarabulut169",
                        "content": "Same my code 66/92 because of that"
                    },
                    {
                        "username": "minhtq9700",
                        "content": "yeah"
                    },
                    {
                        "username": "lwear2",
                        "content": "I agree.  Solved it twice from scratch only to find there are new requirements that manifest in testing.  Now I\\'m having to start again from scratch and pretty frustrated.  My second approach (recursive) simply won\\'t work in one submission test case.  This may be a little TOO real world for the learning environment.  There are classes in Requirements Engineering.  Like Agile and algorithms, they are very important to the professional.\\n\\nI strongly suggest clarifying the fact that the coder should allow for nested parentheses and that the nesting may be complex.\\n\\nRather than this wording, \"Open brackets must be closed in the CORRECT order.\"  (In whose mind?)\\n\\nI strongly suggest this: \"For strings that involve complex nesting, each bracket must be closed in the correct order.\"\\n\\nThis makes clear that \"correct\" is referring to nesting order, not front to back, or first open, or outside to inside, or some other \"correct\" order."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "sxltie",
                        "content": "precisely.. from the description one can\\u2019t even tell if (()) is valid or not.. they don\\u2019t include nested parentheses"
                    },
                    {
                        "username": "tonybrasunas",
                        "content": "The description for this one should say `([]{})` is valid too. Otherwise it's not clear that validating nested parentheses is part of the requirements."
                    },
                    {
                        "username": "bupty3e3",
                        "content": "Yeah, this question wasn\\'t that clear to this end."
                    },
                    {
                        "username": "ecapoferri",
                        "content": "Thanks for posting. I was wondering and went to discussion for clarification."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "bryanAM",
                        "content": "It\\'s a really **good** problem. But I don\\'t think it\\'s appropriate to call it **Easy**. If you\\'ve never had a question like this before, and if you\\'re new to python and programming - which is my guess the target audiance for easy questions - it\\'s a little difficult."
                    },
                    {
                        "username": "a098707730135",
                        "content": "[@JuanQP](/JuanQP) Thank you so much! You gave me the most useful hint!"
                    },
                    {
                        "username": "Rave17",
                        "content": "[@nicolobos77](/nicolobos77) thank you very much. this was crucial advice for leetcode newbie like me"
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "Totally agree. It isnt an easy problem."
                    },
                    {
                        "username": "gurunathkulkarni164",
                        "content": "You go to know stack for this problem."
                    },
                    {
                        "username": "JuanQP",
                        "content": "The only thing you need to solve this is knowing what a stack is. In first year of any engineering or comp-sci career you learn this in the first year"
                    },
                    {
                        "username": "nicolobos77",
                        "content": "It\\'s easy you just have to implement a memory managment with a char* as a stack in C, you push every open bracket, and pop one when there\\'s a close bracket that matches with the last opened bracket, if it doesn\\'t match, just return false, and if the string loop ended and there\\'s at least one bracket in the stack, return false, if it ends with an empty stack and every bracket is open and close correctly return true"
                    },
                    {
                        "username": "matthcraig",
                        "content": "The word \"easy\" in leetcode is a total misnomer and a relative description.  There are no easy leetcode questions.  "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "ikr"
                    },
                    {
                        "username": "tryhard00",
                        "content": "This problem could be considered easy but only if you realized the crux of it. If you tried to do it using pure conditionals, which I did for the first 3 hours, you\\'re in for a very bad time. I finally gave up on conditionals when it had a nested within nested case. I was about to go 3d array to store each set but it was so logically complex I almost quit. Then I saw it. So this problem could considered medium if you didn\\'t see the easy answer. Overall, a very clever question. It had so many caveats that I kept getting rejected and it was giving me pstd by the end. lol. For those who are stuck, the hint is what goes in last must come out first."
                    },
                    {
                        "username": "rahulramdasi44",
                        "content": "Your hint at the last helped me solve the problem quickly \\uD83D\\uDE0A. Thanks."
                    },
                    {
                        "username": "zaynahmad20",
                        "content": "You sure do know how to not spoil a question and give a good hint. Thanks lol"
                    },
                    {
                        "username": "ejaza",
                        "content": "wow man thanks a great hint now i am able to do it \"the hint is what goes in last must come out first.\""
                    },
                    {
                        "username": "johnopj",
                        "content": "Exactly!! The door opened last should be closed first."
                    },
                    {
                        "username": "devindesu",
                        "content": "Mother $^#& I spent much more than 3 hours trying to force it to work with nested conditionals...Thank you for the hint. If they're gonna classify this as Easy they should at least defined the stack class for us  lol"
                    },
                    {
                        "username": "amitkhedkar41",
                        "content": "From this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid.\\nThen I think the problem description should be updated"
                    },
                    {
                        "username": "meergato247",
                        "content": "Exactly. I assumed the pairs just had to be {} () or [], the problem statement never said anything about them possibly being inside one another. "
                    },
                    {
                        "username": "RSK_Ua",
                        "content": "Here is some tip:\\nThe first line of the function uses a guard statement to check if the length of the input string is even. If the length is odd, the function returns false because it means that the brackets are not properly balanced.\\nThe next line creates an empty stack of characters to store the opening brackets.\\nThe function then loops through each character item in the input string s.\\nFor each character item, the code checks whether it is an opening bracket: (, [, or {. If it is, the corresponding closing bracket is pushed onto the stack. For example, if the character is (, the character ) is pushed onto the stack.\\nIf the character is a closing bracket: ), ], or }, the code checks whether the stack is empty. If the stack is empty, it means that there is no opening bracket to match the closing bracket, so the function returns false. If the stack is not empty, the last opening bracket is removed from the stack and checked against the current closing bracket. If the brackets do not match, the function returns false.\\nAfter looping through all the characters in the input string, the function checks whether the stack is empty. If it is, it means that all the opening brackets have been matched with their corresponding closing brackets, so the function returns true. If the stack is not empty, it means that there are unmatched opening brackets, so the function returns false."
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "well explained, I managed to create a solution based on your logic. Thanks a lot\\n"
                    },
                    {
                        "username": "shekardaval",
                        "content": "for the string \\'(]\\' my code is working fine with python 3.7, but here its showing wrong output"
                    },
                    {
                        "username": "benjayy",
                        "content": "I fixed it by returning the boolean rather than the strings. "
                    },
                    {
                        "username": "Aleks_Kim",
                        "content": "[@gvolsky](/gvolsky) Thank you, it is really solution"
                    },
                    {
                        "username": "muqeetkhawaja",
                        "content": "[@gvolsky](/gvolsky) Thanks Brother."
                    },
                    {
                        "username": "gvolsky",
                        "content": "Maybe you, like me, return 'true' and 'false' as strings, not as booleans True and False."
                    },
                    {
                        "username": "wayneli-5",
                        "content": "[@saiharish_g](/saiharish_g) I have this issue too. Have you found a solution? Thank you!"
                    },
                    {
                        "username": "keerthisravanigude",
                        "content": "[@fizah](/fizah) ya same with me also\\n"
                    },
                    {
                        "username": "saiharish_g",
                        "content": "so have you find the real issue actually??"
                    },
                    {
                        "username": "fizah",
                        "content": "same"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "user8796tT",
                        "content": "whats wrong with this TC \"{[]}\" in custom test cases run it succeed but it fails on submission.  \\n![image](https://assets.leetcode.com/users/images/0a36f8a9-6403-4cb8-a073-933a7ded9abe_1609523958.1513097.png)\\n\""
                    },
                    {
                        "username": "ms0686714",
                        "content": "Might be a global variable issue.Make sure initialize the global variable in the begining of main function."
                    },
                    {
                        "username": "kanwarudaysingh",
                        "content": "I was asked to do this in o(1) memory in an interview! Anyone knows how to do that?"
                    },
                    {
                        "username": "0bro",
                        "content": "They probably also required 10 years experience in Rust (Rust came out 8 years ago) lol"
                    },
                    {
                        "username": "data-stack",
                        "content": "Well, you can solve it with a regular expression in O(1) space complexity "
                    },
                    {
                        "username": "rennasccenth",
                        "content": "[@psi_psi](/psi_psi) \"For every\" states something that needs to be iterated, which means nothing less than O(n)"
                    },
                    {
                        "username": "charonme",
                        "content": "I tried a stackless solution with O(1) additional space (not counting the in-place modification of the input string), but it\\'s O(n^2) time"
                    },
                    {
                        "username": "psi_psi",
                        "content": "For every closing char, repeat the search (recursively and repeatedly) backwards (and with inversed opening and closing chars) until you are out of string or you reach the next (in this case, previous) opening char in the string. If that next one is your corresponding opening char, you continue forwards. It is not going to be very fast."
                    },
                    {
                        "username": "astro12",
                        "content": "What is the company name? I\\'ll make sure I\\'ll add that to my blacklist"
                    },
                    {
                        "username": "jigar100",
                        "content": "Did the interviewer asked to do this in O(1) space by maintaining O(n) time complexity"
                    },
                    {
                        "username": "lwear2",
                        "content": "https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/715/introduction/4654/\\n\\nIn the section of Space Analysis it indicates that input and output arrays are not included in memory analysis for BigO.  So, cycle through the input as many times as necessary, modifying the array each time and don\\'t create any new storage space for the array."
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Did u find solution to do that as o1  (javscript)"
                    },
                    {
                        "username": "Alexander2049",
                        "content": "Description is not good enough. Should be shown some more test cases as \"( [ ) ]\", because \"Open brackets must be closed in the correct order\" could be missunderstood."
                    },
                    {
                        "username": "ananya_dash16",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) Same with me.\\n"
                    },
                    {
                        "username": "rahulschandak",
                        "content": "[@AnkushKrVerma](/AnkushKrVerma) I have the same doubt"
                    },
                    {
                        "username": "AnkushKrVerma",
                        "content": "yess even now i can\\'t understand the problem.\\nwhy the TC \"( [ ) ]\" returning false ???\\nhelp me understand the problem "
                    }
                ]
            },
            {
                "id": 1568839,
                "content": [
                    {
                        "username": "luxy622",
                        "content": "Is there a solution without stack and use only constant space?"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "yes \nhere is 0ms solution without using stack and using constant space complexity\n\n```c++\nbool isValid(string s) {\n        char last = s[0];\n        string current_string = \"\";\n        current_string = current_string + s[0];\n        for(int index = 1; index < s.size(); index++)\n        {\n            if(last == '(' && s[index] == ')')\n            {\n                current_string.pop_back();\n                last = '-';\n            }\n            else if(last == '[' && s[index] == ']')\n            {\n                current_string.pop_back();\n                last = '-';\n            }\n            else if(last == '{' && s[index] == '}')\n            {\n                current_string.pop_back();\n                last = '-';\n            }\n            else\n            {\n                last = s[index];\n                current_string = current_string + s[index];\n            }\n            if(last == '-' && current_string.size() > 0)\n            {\n                last = current_string[current_string.size()-1];\n            }\n        }\n        return current_string.size() == 0 ? true : false;\n    }\n```"
                    },
                    {
                        "username": "rohetoric",
                        "content": "[@sayWhatOneMoreTime](/sayWhatOneMoreTime) but why are you iterating till half of the string?"
                    },
                    {
                        "username": "rohetoric",
                        "content": "[@sayWhatOneMoreTime](/sayWhatOneMoreTime) Implementation wo stack. Smart!"
                    },
                    {
                        "username": "i__a_m__sai",
                        "content": "i got passed 88/93 testcases no stack approach."
                    },
                    {
                        "username": "kingctan",
                        "content": "My Java version without using stack. Very easy to understand.\\n  public static boolean isValid(String s) {\\n    //    if (s.length() % 2 != 0) return false;\\n        // if (s.charAt(0) == \\'}\\' ||\\n        //         s.charAt(0) == \\']\\' ||\\n        //         s.charAt(0) == \\')\\' ||\\n        //         s.charAt(s.length()-1) == \\'{\\' ||\\n        //         s.charAt(s.length()-1) == \\'[\\' ||\\n        //         s.charAt(s.length()-1) == \\'(\\'\\n        // ) return false;\\n        while (s.contains(\"{}\") || s.contains(\"()\") || s.contains(\"[]\")) {\\n            s = s.replace(\"{}\", \"\");\\n            s = s.replace(\"()\", \"\");\\n            s = s.replace(\"[]\", \"\");\\n        }\\n        return s.isEmpty();\\n   }"
                    },
                    {
                        "username": "sametcodes",
                        "content": "Here is one, but time complexity is $$O(n^2)$$ since it works recursively.\\n\\n```javascript\\nfunction isValid(s: string): boolean {\\n    let st = s.replace(/\\\\(\\\\)|\\\\[\\\\]|\\\\{\\\\}/g, \"\");\\n    if(st === \"\") return true;\\n    if(st === s && s) return false;\\n\\n    return isValid(st);\\n};\\n```"
                    },
                    {
                        "username": "ze0ng",
                        "content": "[@sayWhatOneMoreTime](/sayWhatOneMoreTime) thanks, the time complexity on this one is O(n^3) if I am not mistaken; str.replace is O(n^2) apparently in Python. Although clever, it is bad practice to modify the input."
                    },
                    {
                        "username": "sayWhatOneMoreTime",
                        "content": "[@Xiaoyan Lu](/luxy622) I have this solution (not the fastest, but quite easy to understand):\n```\nclass Solution(object):\n    def isValid(self, s):\n        legit_brackets = [\"[]\",\"{}\",\"()\"]\n\n        for i in range(0,len(s)/2):\n            for bracket_type in legit_brackets:\n                s= s.replace(bracket_type,\"\")\n        return len(s) == 0       \n```\n\nI'm basically removing every combination of brackets that i found. If the string at the end is empty, everything was valid. "
                    },
                    {
                        "username": "drecep",
                        "content": "[@drecep](/drecep) here is my solution i cannot post to solution. i dont know why"
                    },
                    {
                        "username": "drecep",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n\\t  boolean v=false;\\n\\t int[] p1=new int[7500];\\n\\t\\t    int[] p2=new int[7500];\\n\\t\\t    int[] p3=new int[7500];\\n\\t\\t    int i=0; int j=0; int P1=0;int P2=0; int P3=0;\\n\\t\\t    while(i<s.length()){\\n\\t\\t         \\n\\t\\t         char c= s.charAt(i);\\n\\n\\t\\t         switch(c){\\n\\t\\t                case \\'(\\': {j++;P1++;p1[P1]=j;\\n                        \\n                        \\n                         break;}\\n\\t\\t                 case \\'[\\':{ j++;P2++;p2[P2]=j; break;}\\n\\t\\t                  case \\'{\\': {j++;P3++; p3[P3]=j;  break;}\\n\\t\\t                  case \\')\\': { if(P1==0||p1[P1]!=j){ v=false; return v;}\\n\\n\\t\\t                      if(p1[P1]==j){j--; P1--; v=true;\\n                              } break;}\\n\\n\\t\\t                  case \\']\\':{   if(P2==0||p2[P2]!=j){ v=false; return v;}\\n\\n\\t\\t                      if(p2[P2]==j){j--;P2--; v=true;} break;}\\n\\n\\t\\t                  case \\'}\\':{ if(P3==0||p3[P3]!=j){ v=false; return v;}\\n\\t\\t                      \\n\\t\\t                      if(p3[P3]==j){j--; P3--; v=true;} break;}\\n\\t\\t         }\\n\\n\\t\\ti++;\\n\\t\\t    }\\n\\t\\t     \\n        if(P3>0||P2>0||P1>0) v=false;\\n\\t\\treturn v;\\n}\\n}"
                    },
                    {
                        "username": "user0586c",
                        "content": "I feel like the description should be updated with a disclaimer that said: order of opening and closing of brackets if not supposed to adhere to mathematical known order.\\n\\nE.g:\\n\\' ( [ { } ] ) \\' is Valid\\n\\' [ ( { } ) ] \\' is Valid, etc.\\n"
                    },
                    {
                        "username": "xsyro",
                        "content": "This was my initial java solution\n\n\n\n```\npublic boolean isValid(String s) {\n        Map<Character, Character> characterMap = new HashMap<>(s.toCharArray().length);\n        characterMap.put(')', '(');\n        characterMap.put('(', ')');\n        characterMap.put('{', '}');\n        characterMap.put('}', '{');\n        characterMap.put(']', '[');\n        characterMap.put('[', ']');\n\n        Stack<Character> sStacks = new Stack<>();\n        for (char c : s.toCharArray()) {\n            sStacks.push(c);\n        }\n\n        for (char fromLeftChar : s.toCharArray()) {\n            char fromRightChar = sStacks.pop();\n            if(characterMap.get(fromRightChar) != fromLeftChar)\n                return false;\n        }\n        return true;\n\n    }``"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kingctan",
                        "content": "Java solution. A simple loop. O(N) at least but easy to understand.\\n    public static boolean isValid(String s) {\\n        while (s.contains(\"{}\") || s.contains(\"()\") || s.contains(\"[]\")) {\\n            s = s.replace(\"{}\", \"\");\\n            s = s.replace(\"()\", \"\");\\n            s = s.replace(\"[]\", \"\");\\n        }\\n        return s.isEmpty();\\n    }"
                    },
                    {
                        "username": "juansymontano",
                        "content": "To anyone who is having a hard time as I did.\\nMy best advice is to treat it as a palindrome.\\n\\nIt doesn\\'t matter how you approach it just think of \"palindrome\" and you\\'ll get it."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes how a stack is used in this problem:\\nyoutube.com/watch?v=YwvHeouhy6s"
                    },
                    {
                        "username": "harshit_singh17",
                        "content": "the no of times I changed my approach because a new test case made gave me a wrong answer is insane, this question definitely doesn\\'t belong to easy category!"
                    },
                    {
                        "username": "Envoy49",
                        "content": "Note from OpenAI:\\n\\nThe task of determining whether an input string of brackets is valid is considered to be of medium complexity.\\n"
                    },
                    {
                        "username": "tbhosale",
                        "content": "If problem needs to be resolved only by using data structures such as stacks, then it should not fall under beginners umbrella. As a beginner i am running around loops and inbuilt functions of string only. This looks a bit harsh. Anyway i will now move on to learn about stack and come back to solve this problem. :)"
                    },
                    {
                        "username": "Kamerro",
                        "content": "Damn, that was quite difficult. I spent almost 2h solving that \\'Easy\\' challenge :)"
                    }
                ]
            },
            {
                "id": 1748511,
                "content": [
                    {
                        "username": "luxy622",
                        "content": "Is there a solution without stack and use only constant space?"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "yes \nhere is 0ms solution without using stack and using constant space complexity\n\n```c++\nbool isValid(string s) {\n        char last = s[0];\n        string current_string = \"\";\n        current_string = current_string + s[0];\n        for(int index = 1; index < s.size(); index++)\n        {\n            if(last == '(' && s[index] == ')')\n            {\n                current_string.pop_back();\n                last = '-';\n            }\n            else if(last == '[' && s[index] == ']')\n            {\n                current_string.pop_back();\n                last = '-';\n            }\n            else if(last == '{' && s[index] == '}')\n            {\n                current_string.pop_back();\n                last = '-';\n            }\n            else\n            {\n                last = s[index];\n                current_string = current_string + s[index];\n            }\n            if(last == '-' && current_string.size() > 0)\n            {\n                last = current_string[current_string.size()-1];\n            }\n        }\n        return current_string.size() == 0 ? true : false;\n    }\n```"
                    },
                    {
                        "username": "rohetoric",
                        "content": "[@sayWhatOneMoreTime](/sayWhatOneMoreTime) but why are you iterating till half of the string?"
                    },
                    {
                        "username": "rohetoric",
                        "content": "[@sayWhatOneMoreTime](/sayWhatOneMoreTime) Implementation wo stack. Smart!"
                    },
                    {
                        "username": "i__a_m__sai",
                        "content": "i got passed 88/93 testcases no stack approach."
                    },
                    {
                        "username": "kingctan",
                        "content": "My Java version without using stack. Very easy to understand.\\n  public static boolean isValid(String s) {\\n    //    if (s.length() % 2 != 0) return false;\\n        // if (s.charAt(0) == \\'}\\' ||\\n        //         s.charAt(0) == \\']\\' ||\\n        //         s.charAt(0) == \\')\\' ||\\n        //         s.charAt(s.length()-1) == \\'{\\' ||\\n        //         s.charAt(s.length()-1) == \\'[\\' ||\\n        //         s.charAt(s.length()-1) == \\'(\\'\\n        // ) return false;\\n        while (s.contains(\"{}\") || s.contains(\"()\") || s.contains(\"[]\")) {\\n            s = s.replace(\"{}\", \"\");\\n            s = s.replace(\"()\", \"\");\\n            s = s.replace(\"[]\", \"\");\\n        }\\n        return s.isEmpty();\\n   }"
                    },
                    {
                        "username": "sametcodes",
                        "content": "Here is one, but time complexity is $$O(n^2)$$ since it works recursively.\\n\\n```javascript\\nfunction isValid(s: string): boolean {\\n    let st = s.replace(/\\\\(\\\\)|\\\\[\\\\]|\\\\{\\\\}/g, \"\");\\n    if(st === \"\") return true;\\n    if(st === s && s) return false;\\n\\n    return isValid(st);\\n};\\n```"
                    },
                    {
                        "username": "ze0ng",
                        "content": "[@sayWhatOneMoreTime](/sayWhatOneMoreTime) thanks, the time complexity on this one is O(n^3) if I am not mistaken; str.replace is O(n^2) apparently in Python. Although clever, it is bad practice to modify the input."
                    },
                    {
                        "username": "sayWhatOneMoreTime",
                        "content": "[@Xiaoyan Lu](/luxy622) I have this solution (not the fastest, but quite easy to understand):\n```\nclass Solution(object):\n    def isValid(self, s):\n        legit_brackets = [\"[]\",\"{}\",\"()\"]\n\n        for i in range(0,len(s)/2):\n            for bracket_type in legit_brackets:\n                s= s.replace(bracket_type,\"\")\n        return len(s) == 0       \n```\n\nI'm basically removing every combination of brackets that i found. If the string at the end is empty, everything was valid. "
                    },
                    {
                        "username": "drecep",
                        "content": "[@drecep](/drecep) here is my solution i cannot post to solution. i dont know why"
                    },
                    {
                        "username": "drecep",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n\\t  boolean v=false;\\n\\t int[] p1=new int[7500];\\n\\t\\t    int[] p2=new int[7500];\\n\\t\\t    int[] p3=new int[7500];\\n\\t\\t    int i=0; int j=0; int P1=0;int P2=0; int P3=0;\\n\\t\\t    while(i<s.length()){\\n\\t\\t         \\n\\t\\t         char c= s.charAt(i);\\n\\n\\t\\t         switch(c){\\n\\t\\t                case \\'(\\': {j++;P1++;p1[P1]=j;\\n                        \\n                        \\n                         break;}\\n\\t\\t                 case \\'[\\':{ j++;P2++;p2[P2]=j; break;}\\n\\t\\t                  case \\'{\\': {j++;P3++; p3[P3]=j;  break;}\\n\\t\\t                  case \\')\\': { if(P1==0||p1[P1]!=j){ v=false; return v;}\\n\\n\\t\\t                      if(p1[P1]==j){j--; P1--; v=true;\\n                              } break;}\\n\\n\\t\\t                  case \\']\\':{   if(P2==0||p2[P2]!=j){ v=false; return v;}\\n\\n\\t\\t                      if(p2[P2]==j){j--;P2--; v=true;} break;}\\n\\n\\t\\t                  case \\'}\\':{ if(P3==0||p3[P3]!=j){ v=false; return v;}\\n\\t\\t                      \\n\\t\\t                      if(p3[P3]==j){j--; P3--; v=true;} break;}\\n\\t\\t         }\\n\\n\\t\\ti++;\\n\\t\\t    }\\n\\t\\t     \\n        if(P3>0||P2>0||P1>0) v=false;\\n\\t\\treturn v;\\n}\\n}"
                    },
                    {
                        "username": "user0586c",
                        "content": "I feel like the description should be updated with a disclaimer that said: order of opening and closing of brackets if not supposed to adhere to mathematical known order.\\n\\nE.g:\\n\\' ( [ { } ] ) \\' is Valid\\n\\' [ ( { } ) ] \\' is Valid, etc.\\n"
                    },
                    {
                        "username": "xsyro",
                        "content": "This was my initial java solution\n\n\n\n```\npublic boolean isValid(String s) {\n        Map<Character, Character> characterMap = new HashMap<>(s.toCharArray().length);\n        characterMap.put(')', '(');\n        characterMap.put('(', ')');\n        characterMap.put('{', '}');\n        characterMap.put('}', '{');\n        characterMap.put(']', '[');\n        characterMap.put('[', ']');\n\n        Stack<Character> sStacks = new Stack<>();\n        for (char c : s.toCharArray()) {\n            sStacks.push(c);\n        }\n\n        for (char fromLeftChar : s.toCharArray()) {\n            char fromRightChar = sStacks.pop();\n            if(characterMap.get(fromRightChar) != fromLeftChar)\n                return false;\n        }\n        return true;\n\n    }``"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kingctan",
                        "content": "Java solution. A simple loop. O(N) at least but easy to understand.\\n    public static boolean isValid(String s) {\\n        while (s.contains(\"{}\") || s.contains(\"()\") || s.contains(\"[]\")) {\\n            s = s.replace(\"{}\", \"\");\\n            s = s.replace(\"()\", \"\");\\n            s = s.replace(\"[]\", \"\");\\n        }\\n        return s.isEmpty();\\n    }"
                    },
                    {
                        "username": "juansymontano",
                        "content": "To anyone who is having a hard time as I did.\\nMy best advice is to treat it as a palindrome.\\n\\nIt doesn\\'t matter how you approach it just think of \"palindrome\" and you\\'ll get it."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes how a stack is used in this problem:\\nyoutube.com/watch?v=YwvHeouhy6s"
                    },
                    {
                        "username": "harshit_singh17",
                        "content": "the no of times I changed my approach because a new test case made gave me a wrong answer is insane, this question definitely doesn\\'t belong to easy category!"
                    },
                    {
                        "username": "Envoy49",
                        "content": "Note from OpenAI:\\n\\nThe task of determining whether an input string of brackets is valid is considered to be of medium complexity.\\n"
                    },
                    {
                        "username": "tbhosale",
                        "content": "If problem needs to be resolved only by using data structures such as stacks, then it should not fall under beginners umbrella. As a beginner i am running around loops and inbuilt functions of string only. This looks a bit harsh. Anyway i will now move on to learn about stack and come back to solve this problem. :)"
                    },
                    {
                        "username": "Kamerro",
                        "content": "Damn, that was quite difficult. I spent almost 2h solving that \\'Easy\\' challenge :)"
                    }
                ]
            },
            {
                "id": 1566707,
                "content": [
                    {
                        "username": "luxy622",
                        "content": "Is there a solution without stack and use only constant space?"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "yes \nhere is 0ms solution without using stack and using constant space complexity\n\n```c++\nbool isValid(string s) {\n        char last = s[0];\n        string current_string = \"\";\n        current_string = current_string + s[0];\n        for(int index = 1; index < s.size(); index++)\n        {\n            if(last == '(' && s[index] == ')')\n            {\n                current_string.pop_back();\n                last = '-';\n            }\n            else if(last == '[' && s[index] == ']')\n            {\n                current_string.pop_back();\n                last = '-';\n            }\n            else if(last == '{' && s[index] == '}')\n            {\n                current_string.pop_back();\n                last = '-';\n            }\n            else\n            {\n                last = s[index];\n                current_string = current_string + s[index];\n            }\n            if(last == '-' && current_string.size() > 0)\n            {\n                last = current_string[current_string.size()-1];\n            }\n        }\n        return current_string.size() == 0 ? true : false;\n    }\n```"
                    },
                    {
                        "username": "rohetoric",
                        "content": "[@sayWhatOneMoreTime](/sayWhatOneMoreTime) but why are you iterating till half of the string?"
                    },
                    {
                        "username": "rohetoric",
                        "content": "[@sayWhatOneMoreTime](/sayWhatOneMoreTime) Implementation wo stack. Smart!"
                    },
                    {
                        "username": "i__a_m__sai",
                        "content": "i got passed 88/93 testcases no stack approach."
                    },
                    {
                        "username": "kingctan",
                        "content": "My Java version without using stack. Very easy to understand.\\n  public static boolean isValid(String s) {\\n    //    if (s.length() % 2 != 0) return false;\\n        // if (s.charAt(0) == \\'}\\' ||\\n        //         s.charAt(0) == \\']\\' ||\\n        //         s.charAt(0) == \\')\\' ||\\n        //         s.charAt(s.length()-1) == \\'{\\' ||\\n        //         s.charAt(s.length()-1) == \\'[\\' ||\\n        //         s.charAt(s.length()-1) == \\'(\\'\\n        // ) return false;\\n        while (s.contains(\"{}\") || s.contains(\"()\") || s.contains(\"[]\")) {\\n            s = s.replace(\"{}\", \"\");\\n            s = s.replace(\"()\", \"\");\\n            s = s.replace(\"[]\", \"\");\\n        }\\n        return s.isEmpty();\\n   }"
                    },
                    {
                        "username": "sametcodes",
                        "content": "Here is one, but time complexity is $$O(n^2)$$ since it works recursively.\\n\\n```javascript\\nfunction isValid(s: string): boolean {\\n    let st = s.replace(/\\\\(\\\\)|\\\\[\\\\]|\\\\{\\\\}/g, \"\");\\n    if(st === \"\") return true;\\n    if(st === s && s) return false;\\n\\n    return isValid(st);\\n};\\n```"
                    },
                    {
                        "username": "ze0ng",
                        "content": "[@sayWhatOneMoreTime](/sayWhatOneMoreTime) thanks, the time complexity on this one is O(n^3) if I am not mistaken; str.replace is O(n^2) apparently in Python. Although clever, it is bad practice to modify the input."
                    },
                    {
                        "username": "sayWhatOneMoreTime",
                        "content": "[@Xiaoyan Lu](/luxy622) I have this solution (not the fastest, but quite easy to understand):\n```\nclass Solution(object):\n    def isValid(self, s):\n        legit_brackets = [\"[]\",\"{}\",\"()\"]\n\n        for i in range(0,len(s)/2):\n            for bracket_type in legit_brackets:\n                s= s.replace(bracket_type,\"\")\n        return len(s) == 0       \n```\n\nI'm basically removing every combination of brackets that i found. If the string at the end is empty, everything was valid. "
                    },
                    {
                        "username": "drecep",
                        "content": "[@drecep](/drecep) here is my solution i cannot post to solution. i dont know why"
                    },
                    {
                        "username": "drecep",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n\\t  boolean v=false;\\n\\t int[] p1=new int[7500];\\n\\t\\t    int[] p2=new int[7500];\\n\\t\\t    int[] p3=new int[7500];\\n\\t\\t    int i=0; int j=0; int P1=0;int P2=0; int P3=0;\\n\\t\\t    while(i<s.length()){\\n\\t\\t         \\n\\t\\t         char c= s.charAt(i);\\n\\n\\t\\t         switch(c){\\n\\t\\t                case \\'(\\': {j++;P1++;p1[P1]=j;\\n                        \\n                        \\n                         break;}\\n\\t\\t                 case \\'[\\':{ j++;P2++;p2[P2]=j; break;}\\n\\t\\t                  case \\'{\\': {j++;P3++; p3[P3]=j;  break;}\\n\\t\\t                  case \\')\\': { if(P1==0||p1[P1]!=j){ v=false; return v;}\\n\\n\\t\\t                      if(p1[P1]==j){j--; P1--; v=true;\\n                              } break;}\\n\\n\\t\\t                  case \\']\\':{   if(P2==0||p2[P2]!=j){ v=false; return v;}\\n\\n\\t\\t                      if(p2[P2]==j){j--;P2--; v=true;} break;}\\n\\n\\t\\t                  case \\'}\\':{ if(P3==0||p3[P3]!=j){ v=false; return v;}\\n\\t\\t                      \\n\\t\\t                      if(p3[P3]==j){j--; P3--; v=true;} break;}\\n\\t\\t         }\\n\\n\\t\\ti++;\\n\\t\\t    }\\n\\t\\t     \\n        if(P3>0||P2>0||P1>0) v=false;\\n\\t\\treturn v;\\n}\\n}"
                    },
                    {
                        "username": "user0586c",
                        "content": "I feel like the description should be updated with a disclaimer that said: order of opening and closing of brackets if not supposed to adhere to mathematical known order.\\n\\nE.g:\\n\\' ( [ { } ] ) \\' is Valid\\n\\' [ ( { } ) ] \\' is Valid, etc.\\n"
                    },
                    {
                        "username": "xsyro",
                        "content": "This was my initial java solution\n\n\n\n```\npublic boolean isValid(String s) {\n        Map<Character, Character> characterMap = new HashMap<>(s.toCharArray().length);\n        characterMap.put(')', '(');\n        characterMap.put('(', ')');\n        characterMap.put('{', '}');\n        characterMap.put('}', '{');\n        characterMap.put(']', '[');\n        characterMap.put('[', ']');\n\n        Stack<Character> sStacks = new Stack<>();\n        for (char c : s.toCharArray()) {\n            sStacks.push(c);\n        }\n\n        for (char fromLeftChar : s.toCharArray()) {\n            char fromRightChar = sStacks.pop();\n            if(characterMap.get(fromRightChar) != fromLeftChar)\n                return false;\n        }\n        return true;\n\n    }``"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kingctan",
                        "content": "Java solution. A simple loop. O(N) at least but easy to understand.\\n    public static boolean isValid(String s) {\\n        while (s.contains(\"{}\") || s.contains(\"()\") || s.contains(\"[]\")) {\\n            s = s.replace(\"{}\", \"\");\\n            s = s.replace(\"()\", \"\");\\n            s = s.replace(\"[]\", \"\");\\n        }\\n        return s.isEmpty();\\n    }"
                    },
                    {
                        "username": "juansymontano",
                        "content": "To anyone who is having a hard time as I did.\\nMy best advice is to treat it as a palindrome.\\n\\nIt doesn\\'t matter how you approach it just think of \"palindrome\" and you\\'ll get it."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes how a stack is used in this problem:\\nyoutube.com/watch?v=YwvHeouhy6s"
                    },
                    {
                        "username": "harshit_singh17",
                        "content": "the no of times I changed my approach because a new test case made gave me a wrong answer is insane, this question definitely doesn\\'t belong to easy category!"
                    },
                    {
                        "username": "Envoy49",
                        "content": "Note from OpenAI:\\n\\nThe task of determining whether an input string of brackets is valid is considered to be of medium complexity.\\n"
                    },
                    {
                        "username": "tbhosale",
                        "content": "If problem needs to be resolved only by using data structures such as stacks, then it should not fall under beginners umbrella. As a beginner i am running around loops and inbuilt functions of string only. This looks a bit harsh. Anyway i will now move on to learn about stack and come back to solve this problem. :)"
                    },
                    {
                        "username": "Kamerro",
                        "content": "Damn, that was quite difficult. I spent almost 2h solving that \\'Easy\\' challenge :)"
                    }
                ]
            },
            {
                "id": 1770113,
                "content": [
                    {
                        "username": "luxy622",
                        "content": "Is there a solution without stack and use only constant space?"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "yes \nhere is 0ms solution without using stack and using constant space complexity\n\n```c++\nbool isValid(string s) {\n        char last = s[0];\n        string current_string = \"\";\n        current_string = current_string + s[0];\n        for(int index = 1; index < s.size(); index++)\n        {\n            if(last == '(' && s[index] == ')')\n            {\n                current_string.pop_back();\n                last = '-';\n            }\n            else if(last == '[' && s[index] == ']')\n            {\n                current_string.pop_back();\n                last = '-';\n            }\n            else if(last == '{' && s[index] == '}')\n            {\n                current_string.pop_back();\n                last = '-';\n            }\n            else\n            {\n                last = s[index];\n                current_string = current_string + s[index];\n            }\n            if(last == '-' && current_string.size() > 0)\n            {\n                last = current_string[current_string.size()-1];\n            }\n        }\n        return current_string.size() == 0 ? true : false;\n    }\n```"
                    },
                    {
                        "username": "rohetoric",
                        "content": "[@sayWhatOneMoreTime](/sayWhatOneMoreTime) but why are you iterating till half of the string?"
                    },
                    {
                        "username": "rohetoric",
                        "content": "[@sayWhatOneMoreTime](/sayWhatOneMoreTime) Implementation wo stack. Smart!"
                    },
                    {
                        "username": "i__a_m__sai",
                        "content": "i got passed 88/93 testcases no stack approach."
                    },
                    {
                        "username": "kingctan",
                        "content": "My Java version without using stack. Very easy to understand.\\n  public static boolean isValid(String s) {\\n    //    if (s.length() % 2 != 0) return false;\\n        // if (s.charAt(0) == \\'}\\' ||\\n        //         s.charAt(0) == \\']\\' ||\\n        //         s.charAt(0) == \\')\\' ||\\n        //         s.charAt(s.length()-1) == \\'{\\' ||\\n        //         s.charAt(s.length()-1) == \\'[\\' ||\\n        //         s.charAt(s.length()-1) == \\'(\\'\\n        // ) return false;\\n        while (s.contains(\"{}\") || s.contains(\"()\") || s.contains(\"[]\")) {\\n            s = s.replace(\"{}\", \"\");\\n            s = s.replace(\"()\", \"\");\\n            s = s.replace(\"[]\", \"\");\\n        }\\n        return s.isEmpty();\\n   }"
                    },
                    {
                        "username": "sametcodes",
                        "content": "Here is one, but time complexity is $$O(n^2)$$ since it works recursively.\\n\\n```javascript\\nfunction isValid(s: string): boolean {\\n    let st = s.replace(/\\\\(\\\\)|\\\\[\\\\]|\\\\{\\\\}/g, \"\");\\n    if(st === \"\") return true;\\n    if(st === s && s) return false;\\n\\n    return isValid(st);\\n};\\n```"
                    },
                    {
                        "username": "ze0ng",
                        "content": "[@sayWhatOneMoreTime](/sayWhatOneMoreTime) thanks, the time complexity on this one is O(n^3) if I am not mistaken; str.replace is O(n^2) apparently in Python. Although clever, it is bad practice to modify the input."
                    },
                    {
                        "username": "sayWhatOneMoreTime",
                        "content": "[@Xiaoyan Lu](/luxy622) I have this solution (not the fastest, but quite easy to understand):\n```\nclass Solution(object):\n    def isValid(self, s):\n        legit_brackets = [\"[]\",\"{}\",\"()\"]\n\n        for i in range(0,len(s)/2):\n            for bracket_type in legit_brackets:\n                s= s.replace(bracket_type,\"\")\n        return len(s) == 0       \n```\n\nI'm basically removing every combination of brackets that i found. If the string at the end is empty, everything was valid. "
                    },
                    {
                        "username": "drecep",
                        "content": "[@drecep](/drecep) here is my solution i cannot post to solution. i dont know why"
                    },
                    {
                        "username": "drecep",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n\\t  boolean v=false;\\n\\t int[] p1=new int[7500];\\n\\t\\t    int[] p2=new int[7500];\\n\\t\\t    int[] p3=new int[7500];\\n\\t\\t    int i=0; int j=0; int P1=0;int P2=0; int P3=0;\\n\\t\\t    while(i<s.length()){\\n\\t\\t         \\n\\t\\t         char c= s.charAt(i);\\n\\n\\t\\t         switch(c){\\n\\t\\t                case \\'(\\': {j++;P1++;p1[P1]=j;\\n                        \\n                        \\n                         break;}\\n\\t\\t                 case \\'[\\':{ j++;P2++;p2[P2]=j; break;}\\n\\t\\t                  case \\'{\\': {j++;P3++; p3[P3]=j;  break;}\\n\\t\\t                  case \\')\\': { if(P1==0||p1[P1]!=j){ v=false; return v;}\\n\\n\\t\\t                      if(p1[P1]==j){j--; P1--; v=true;\\n                              } break;}\\n\\n\\t\\t                  case \\']\\':{   if(P2==0||p2[P2]!=j){ v=false; return v;}\\n\\n\\t\\t                      if(p2[P2]==j){j--;P2--; v=true;} break;}\\n\\n\\t\\t                  case \\'}\\':{ if(P3==0||p3[P3]!=j){ v=false; return v;}\\n\\t\\t                      \\n\\t\\t                      if(p3[P3]==j){j--; P3--; v=true;} break;}\\n\\t\\t         }\\n\\n\\t\\ti++;\\n\\t\\t    }\\n\\t\\t     \\n        if(P3>0||P2>0||P1>0) v=false;\\n\\t\\treturn v;\\n}\\n}"
                    },
                    {
                        "username": "user0586c",
                        "content": "I feel like the description should be updated with a disclaimer that said: order of opening and closing of brackets if not supposed to adhere to mathematical known order.\\n\\nE.g:\\n\\' ( [ { } ] ) \\' is Valid\\n\\' [ ( { } ) ] \\' is Valid, etc.\\n"
                    },
                    {
                        "username": "xsyro",
                        "content": "This was my initial java solution\n\n\n\n```\npublic boolean isValid(String s) {\n        Map<Character, Character> characterMap = new HashMap<>(s.toCharArray().length);\n        characterMap.put(')', '(');\n        characterMap.put('(', ')');\n        characterMap.put('{', '}');\n        characterMap.put('}', '{');\n        characterMap.put(']', '[');\n        characterMap.put('[', ']');\n\n        Stack<Character> sStacks = new Stack<>();\n        for (char c : s.toCharArray()) {\n            sStacks.push(c);\n        }\n\n        for (char fromLeftChar : s.toCharArray()) {\n            char fromRightChar = sStacks.pop();\n            if(characterMap.get(fromRightChar) != fromLeftChar)\n                return false;\n        }\n        return true;\n\n    }``"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kingctan",
                        "content": "Java solution. A simple loop. O(N) at least but easy to understand.\\n    public static boolean isValid(String s) {\\n        while (s.contains(\"{}\") || s.contains(\"()\") || s.contains(\"[]\")) {\\n            s = s.replace(\"{}\", \"\");\\n            s = s.replace(\"()\", \"\");\\n            s = s.replace(\"[]\", \"\");\\n        }\\n        return s.isEmpty();\\n    }"
                    },
                    {
                        "username": "juansymontano",
                        "content": "To anyone who is having a hard time as I did.\\nMy best advice is to treat it as a palindrome.\\n\\nIt doesn\\'t matter how you approach it just think of \"palindrome\" and you\\'ll get it."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes how a stack is used in this problem:\\nyoutube.com/watch?v=YwvHeouhy6s"
                    },
                    {
                        "username": "harshit_singh17",
                        "content": "the no of times I changed my approach because a new test case made gave me a wrong answer is insane, this question definitely doesn\\'t belong to easy category!"
                    },
                    {
                        "username": "Envoy49",
                        "content": "Note from OpenAI:\\n\\nThe task of determining whether an input string of brackets is valid is considered to be of medium complexity.\\n"
                    },
                    {
                        "username": "tbhosale",
                        "content": "If problem needs to be resolved only by using data structures such as stacks, then it should not fall under beginners umbrella. As a beginner i am running around loops and inbuilt functions of string only. This looks a bit harsh. Anyway i will now move on to learn about stack and come back to solve this problem. :)"
                    },
                    {
                        "username": "Kamerro",
                        "content": "Damn, that was quite difficult. I spent almost 2h solving that \\'Easy\\' challenge :)"
                    }
                ]
            },
            {
                "id": 1738237,
                "content": [
                    {
                        "username": "luxy622",
                        "content": "Is there a solution without stack and use only constant space?"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "yes \nhere is 0ms solution without using stack and using constant space complexity\n\n```c++\nbool isValid(string s) {\n        char last = s[0];\n        string current_string = \"\";\n        current_string = current_string + s[0];\n        for(int index = 1; index < s.size(); index++)\n        {\n            if(last == '(' && s[index] == ')')\n            {\n                current_string.pop_back();\n                last = '-';\n            }\n            else if(last == '[' && s[index] == ']')\n            {\n                current_string.pop_back();\n                last = '-';\n            }\n            else if(last == '{' && s[index] == '}')\n            {\n                current_string.pop_back();\n                last = '-';\n            }\n            else\n            {\n                last = s[index];\n                current_string = current_string + s[index];\n            }\n            if(last == '-' && current_string.size() > 0)\n            {\n                last = current_string[current_string.size()-1];\n            }\n        }\n        return current_string.size() == 0 ? true : false;\n    }\n```"
                    },
                    {
                        "username": "rohetoric",
                        "content": "[@sayWhatOneMoreTime](/sayWhatOneMoreTime) but why are you iterating till half of the string?"
                    },
                    {
                        "username": "rohetoric",
                        "content": "[@sayWhatOneMoreTime](/sayWhatOneMoreTime) Implementation wo stack. Smart!"
                    },
                    {
                        "username": "i__a_m__sai",
                        "content": "i got passed 88/93 testcases no stack approach."
                    },
                    {
                        "username": "kingctan",
                        "content": "My Java version without using stack. Very easy to understand.\\n  public static boolean isValid(String s) {\\n    //    if (s.length() % 2 != 0) return false;\\n        // if (s.charAt(0) == \\'}\\' ||\\n        //         s.charAt(0) == \\']\\' ||\\n        //         s.charAt(0) == \\')\\' ||\\n        //         s.charAt(s.length()-1) == \\'{\\' ||\\n        //         s.charAt(s.length()-1) == \\'[\\' ||\\n        //         s.charAt(s.length()-1) == \\'(\\'\\n        // ) return false;\\n        while (s.contains(\"{}\") || s.contains(\"()\") || s.contains(\"[]\")) {\\n            s = s.replace(\"{}\", \"\");\\n            s = s.replace(\"()\", \"\");\\n            s = s.replace(\"[]\", \"\");\\n        }\\n        return s.isEmpty();\\n   }"
                    },
                    {
                        "username": "sametcodes",
                        "content": "Here is one, but time complexity is $$O(n^2)$$ since it works recursively.\\n\\n```javascript\\nfunction isValid(s: string): boolean {\\n    let st = s.replace(/\\\\(\\\\)|\\\\[\\\\]|\\\\{\\\\}/g, \"\");\\n    if(st === \"\") return true;\\n    if(st === s && s) return false;\\n\\n    return isValid(st);\\n};\\n```"
                    },
                    {
                        "username": "ze0ng",
                        "content": "[@sayWhatOneMoreTime](/sayWhatOneMoreTime) thanks, the time complexity on this one is O(n^3) if I am not mistaken; str.replace is O(n^2) apparently in Python. Although clever, it is bad practice to modify the input."
                    },
                    {
                        "username": "sayWhatOneMoreTime",
                        "content": "[@Xiaoyan Lu](/luxy622) I have this solution (not the fastest, but quite easy to understand):\n```\nclass Solution(object):\n    def isValid(self, s):\n        legit_brackets = [\"[]\",\"{}\",\"()\"]\n\n        for i in range(0,len(s)/2):\n            for bracket_type in legit_brackets:\n                s= s.replace(bracket_type,\"\")\n        return len(s) == 0       \n```\n\nI'm basically removing every combination of brackets that i found. If the string at the end is empty, everything was valid. "
                    },
                    {
                        "username": "drecep",
                        "content": "[@drecep](/drecep) here is my solution i cannot post to solution. i dont know why"
                    },
                    {
                        "username": "drecep",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n\\t  boolean v=false;\\n\\t int[] p1=new int[7500];\\n\\t\\t    int[] p2=new int[7500];\\n\\t\\t    int[] p3=new int[7500];\\n\\t\\t    int i=0; int j=0; int P1=0;int P2=0; int P3=0;\\n\\t\\t    while(i<s.length()){\\n\\t\\t         \\n\\t\\t         char c= s.charAt(i);\\n\\n\\t\\t         switch(c){\\n\\t\\t                case \\'(\\': {j++;P1++;p1[P1]=j;\\n                        \\n                        \\n                         break;}\\n\\t\\t                 case \\'[\\':{ j++;P2++;p2[P2]=j; break;}\\n\\t\\t                  case \\'{\\': {j++;P3++; p3[P3]=j;  break;}\\n\\t\\t                  case \\')\\': { if(P1==0||p1[P1]!=j){ v=false; return v;}\\n\\n\\t\\t                      if(p1[P1]==j){j--; P1--; v=true;\\n                              } break;}\\n\\n\\t\\t                  case \\']\\':{   if(P2==0||p2[P2]!=j){ v=false; return v;}\\n\\n\\t\\t                      if(p2[P2]==j){j--;P2--; v=true;} break;}\\n\\n\\t\\t                  case \\'}\\':{ if(P3==0||p3[P3]!=j){ v=false; return v;}\\n\\t\\t                      \\n\\t\\t                      if(p3[P3]==j){j--; P3--; v=true;} break;}\\n\\t\\t         }\\n\\n\\t\\ti++;\\n\\t\\t    }\\n\\t\\t     \\n        if(P3>0||P2>0||P1>0) v=false;\\n\\t\\treturn v;\\n}\\n}"
                    },
                    {
                        "username": "user0586c",
                        "content": "I feel like the description should be updated with a disclaimer that said: order of opening and closing of brackets if not supposed to adhere to mathematical known order.\\n\\nE.g:\\n\\' ( [ { } ] ) \\' is Valid\\n\\' [ ( { } ) ] \\' is Valid, etc.\\n"
                    },
                    {
                        "username": "xsyro",
                        "content": "This was my initial java solution\n\n\n\n```\npublic boolean isValid(String s) {\n        Map<Character, Character> characterMap = new HashMap<>(s.toCharArray().length);\n        characterMap.put(')', '(');\n        characterMap.put('(', ')');\n        characterMap.put('{', '}');\n        characterMap.put('}', '{');\n        characterMap.put(']', '[');\n        characterMap.put('[', ']');\n\n        Stack<Character> sStacks = new Stack<>();\n        for (char c : s.toCharArray()) {\n            sStacks.push(c);\n        }\n\n        for (char fromLeftChar : s.toCharArray()) {\n            char fromRightChar = sStacks.pop();\n            if(characterMap.get(fromRightChar) != fromLeftChar)\n                return false;\n        }\n        return true;\n\n    }``"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kingctan",
                        "content": "Java solution. A simple loop. O(N) at least but easy to understand.\\n    public static boolean isValid(String s) {\\n        while (s.contains(\"{}\") || s.contains(\"()\") || s.contains(\"[]\")) {\\n            s = s.replace(\"{}\", \"\");\\n            s = s.replace(\"()\", \"\");\\n            s = s.replace(\"[]\", \"\");\\n        }\\n        return s.isEmpty();\\n    }"
                    },
                    {
                        "username": "juansymontano",
                        "content": "To anyone who is having a hard time as I did.\\nMy best advice is to treat it as a palindrome.\\n\\nIt doesn\\'t matter how you approach it just think of \"palindrome\" and you\\'ll get it."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes how a stack is used in this problem:\\nyoutube.com/watch?v=YwvHeouhy6s"
                    },
                    {
                        "username": "harshit_singh17",
                        "content": "the no of times I changed my approach because a new test case made gave me a wrong answer is insane, this question definitely doesn\\'t belong to easy category!"
                    },
                    {
                        "username": "Envoy49",
                        "content": "Note from OpenAI:\\n\\nThe task of determining whether an input string of brackets is valid is considered to be of medium complexity.\\n"
                    },
                    {
                        "username": "tbhosale",
                        "content": "If problem needs to be resolved only by using data structures such as stacks, then it should not fall under beginners umbrella. As a beginner i am running around loops and inbuilt functions of string only. This looks a bit harsh. Anyway i will now move on to learn about stack and come back to solve this problem. :)"
                    },
                    {
                        "username": "Kamerro",
                        "content": "Damn, that was quite difficult. I spent almost 2h solving that \\'Easy\\' challenge :)"
                    }
                ]
            },
            {
                "id": 1876486,
                "content": [
                    {
                        "username": "luxy622",
                        "content": "Is there a solution without stack and use only constant space?"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "yes \nhere is 0ms solution without using stack and using constant space complexity\n\n```c++\nbool isValid(string s) {\n        char last = s[0];\n        string current_string = \"\";\n        current_string = current_string + s[0];\n        for(int index = 1; index < s.size(); index++)\n        {\n            if(last == '(' && s[index] == ')')\n            {\n                current_string.pop_back();\n                last = '-';\n            }\n            else if(last == '[' && s[index] == ']')\n            {\n                current_string.pop_back();\n                last = '-';\n            }\n            else if(last == '{' && s[index] == '}')\n            {\n                current_string.pop_back();\n                last = '-';\n            }\n            else\n            {\n                last = s[index];\n                current_string = current_string + s[index];\n            }\n            if(last == '-' && current_string.size() > 0)\n            {\n                last = current_string[current_string.size()-1];\n            }\n        }\n        return current_string.size() == 0 ? true : false;\n    }\n```"
                    },
                    {
                        "username": "rohetoric",
                        "content": "[@sayWhatOneMoreTime](/sayWhatOneMoreTime) but why are you iterating till half of the string?"
                    },
                    {
                        "username": "rohetoric",
                        "content": "[@sayWhatOneMoreTime](/sayWhatOneMoreTime) Implementation wo stack. Smart!"
                    },
                    {
                        "username": "i__a_m__sai",
                        "content": "i got passed 88/93 testcases no stack approach."
                    },
                    {
                        "username": "kingctan",
                        "content": "My Java version without using stack. Very easy to understand.\\n  public static boolean isValid(String s) {\\n    //    if (s.length() % 2 != 0) return false;\\n        // if (s.charAt(0) == \\'}\\' ||\\n        //         s.charAt(0) == \\']\\' ||\\n        //         s.charAt(0) == \\')\\' ||\\n        //         s.charAt(s.length()-1) == \\'{\\' ||\\n        //         s.charAt(s.length()-1) == \\'[\\' ||\\n        //         s.charAt(s.length()-1) == \\'(\\'\\n        // ) return false;\\n        while (s.contains(\"{}\") || s.contains(\"()\") || s.contains(\"[]\")) {\\n            s = s.replace(\"{}\", \"\");\\n            s = s.replace(\"()\", \"\");\\n            s = s.replace(\"[]\", \"\");\\n        }\\n        return s.isEmpty();\\n   }"
                    },
                    {
                        "username": "sametcodes",
                        "content": "Here is one, but time complexity is $$O(n^2)$$ since it works recursively.\\n\\n```javascript\\nfunction isValid(s: string): boolean {\\n    let st = s.replace(/\\\\(\\\\)|\\\\[\\\\]|\\\\{\\\\}/g, \"\");\\n    if(st === \"\") return true;\\n    if(st === s && s) return false;\\n\\n    return isValid(st);\\n};\\n```"
                    },
                    {
                        "username": "ze0ng",
                        "content": "[@sayWhatOneMoreTime](/sayWhatOneMoreTime) thanks, the time complexity on this one is O(n^3) if I am not mistaken; str.replace is O(n^2) apparently in Python. Although clever, it is bad practice to modify the input."
                    },
                    {
                        "username": "sayWhatOneMoreTime",
                        "content": "[@Xiaoyan Lu](/luxy622) I have this solution (not the fastest, but quite easy to understand):\n```\nclass Solution(object):\n    def isValid(self, s):\n        legit_brackets = [\"[]\",\"{}\",\"()\"]\n\n        for i in range(0,len(s)/2):\n            for bracket_type in legit_brackets:\n                s= s.replace(bracket_type,\"\")\n        return len(s) == 0       \n```\n\nI'm basically removing every combination of brackets that i found. If the string at the end is empty, everything was valid. "
                    },
                    {
                        "username": "drecep",
                        "content": "[@drecep](/drecep) here is my solution i cannot post to solution. i dont know why"
                    },
                    {
                        "username": "drecep",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n\\t  boolean v=false;\\n\\t int[] p1=new int[7500];\\n\\t\\t    int[] p2=new int[7500];\\n\\t\\t    int[] p3=new int[7500];\\n\\t\\t    int i=0; int j=0; int P1=0;int P2=0; int P3=0;\\n\\t\\t    while(i<s.length()){\\n\\t\\t         \\n\\t\\t         char c= s.charAt(i);\\n\\n\\t\\t         switch(c){\\n\\t\\t                case \\'(\\': {j++;P1++;p1[P1]=j;\\n                        \\n                        \\n                         break;}\\n\\t\\t                 case \\'[\\':{ j++;P2++;p2[P2]=j; break;}\\n\\t\\t                  case \\'{\\': {j++;P3++; p3[P3]=j;  break;}\\n\\t\\t                  case \\')\\': { if(P1==0||p1[P1]!=j){ v=false; return v;}\\n\\n\\t\\t                      if(p1[P1]==j){j--; P1--; v=true;\\n                              } break;}\\n\\n\\t\\t                  case \\']\\':{   if(P2==0||p2[P2]!=j){ v=false; return v;}\\n\\n\\t\\t                      if(p2[P2]==j){j--;P2--; v=true;} break;}\\n\\n\\t\\t                  case \\'}\\':{ if(P3==0||p3[P3]!=j){ v=false; return v;}\\n\\t\\t                      \\n\\t\\t                      if(p3[P3]==j){j--; P3--; v=true;} break;}\\n\\t\\t         }\\n\\n\\t\\ti++;\\n\\t\\t    }\\n\\t\\t     \\n        if(P3>0||P2>0||P1>0) v=false;\\n\\t\\treturn v;\\n}\\n}"
                    },
                    {
                        "username": "user0586c",
                        "content": "I feel like the description should be updated with a disclaimer that said: order of opening and closing of brackets if not supposed to adhere to mathematical known order.\\n\\nE.g:\\n\\' ( [ { } ] ) \\' is Valid\\n\\' [ ( { } ) ] \\' is Valid, etc.\\n"
                    },
                    {
                        "username": "xsyro",
                        "content": "This was my initial java solution\n\n\n\n```\npublic boolean isValid(String s) {\n        Map<Character, Character> characterMap = new HashMap<>(s.toCharArray().length);\n        characterMap.put(')', '(');\n        characterMap.put('(', ')');\n        characterMap.put('{', '}');\n        characterMap.put('}', '{');\n        characterMap.put(']', '[');\n        characterMap.put('[', ']');\n\n        Stack<Character> sStacks = new Stack<>();\n        for (char c : s.toCharArray()) {\n            sStacks.push(c);\n        }\n\n        for (char fromLeftChar : s.toCharArray()) {\n            char fromRightChar = sStacks.pop();\n            if(characterMap.get(fromRightChar) != fromLeftChar)\n                return false;\n        }\n        return true;\n\n    }``"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kingctan",
                        "content": "Java solution. A simple loop. O(N) at least but easy to understand.\\n    public static boolean isValid(String s) {\\n        while (s.contains(\"{}\") || s.contains(\"()\") || s.contains(\"[]\")) {\\n            s = s.replace(\"{}\", \"\");\\n            s = s.replace(\"()\", \"\");\\n            s = s.replace(\"[]\", \"\");\\n        }\\n        return s.isEmpty();\\n    }"
                    },
                    {
                        "username": "juansymontano",
                        "content": "To anyone who is having a hard time as I did.\\nMy best advice is to treat it as a palindrome.\\n\\nIt doesn\\'t matter how you approach it just think of \"palindrome\" and you\\'ll get it."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes how a stack is used in this problem:\\nyoutube.com/watch?v=YwvHeouhy6s"
                    },
                    {
                        "username": "harshit_singh17",
                        "content": "the no of times I changed my approach because a new test case made gave me a wrong answer is insane, this question definitely doesn\\'t belong to easy category!"
                    },
                    {
                        "username": "Envoy49",
                        "content": "Note from OpenAI:\\n\\nThe task of determining whether an input string of brackets is valid is considered to be of medium complexity.\\n"
                    },
                    {
                        "username": "tbhosale",
                        "content": "If problem needs to be resolved only by using data structures such as stacks, then it should not fall under beginners umbrella. As a beginner i am running around loops and inbuilt functions of string only. This looks a bit harsh. Anyway i will now move on to learn about stack and come back to solve this problem. :)"
                    },
                    {
                        "username": "Kamerro",
                        "content": "Damn, that was quite difficult. I spent almost 2h solving that \\'Easy\\' challenge :)"
                    }
                ]
            },
            {
                "id": 1778979,
                "content": [
                    {
                        "username": "luxy622",
                        "content": "Is there a solution without stack and use only constant space?"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "yes \nhere is 0ms solution without using stack and using constant space complexity\n\n```c++\nbool isValid(string s) {\n        char last = s[0];\n        string current_string = \"\";\n        current_string = current_string + s[0];\n        for(int index = 1; index < s.size(); index++)\n        {\n            if(last == '(' && s[index] == ')')\n            {\n                current_string.pop_back();\n                last = '-';\n            }\n            else if(last == '[' && s[index] == ']')\n            {\n                current_string.pop_back();\n                last = '-';\n            }\n            else if(last == '{' && s[index] == '}')\n            {\n                current_string.pop_back();\n                last = '-';\n            }\n            else\n            {\n                last = s[index];\n                current_string = current_string + s[index];\n            }\n            if(last == '-' && current_string.size() > 0)\n            {\n                last = current_string[current_string.size()-1];\n            }\n        }\n        return current_string.size() == 0 ? true : false;\n    }\n```"
                    },
                    {
                        "username": "rohetoric",
                        "content": "[@sayWhatOneMoreTime](/sayWhatOneMoreTime) but why are you iterating till half of the string?"
                    },
                    {
                        "username": "rohetoric",
                        "content": "[@sayWhatOneMoreTime](/sayWhatOneMoreTime) Implementation wo stack. Smart!"
                    },
                    {
                        "username": "i__a_m__sai",
                        "content": "i got passed 88/93 testcases no stack approach."
                    },
                    {
                        "username": "kingctan",
                        "content": "My Java version without using stack. Very easy to understand.\\n  public static boolean isValid(String s) {\\n    //    if (s.length() % 2 != 0) return false;\\n        // if (s.charAt(0) == \\'}\\' ||\\n        //         s.charAt(0) == \\']\\' ||\\n        //         s.charAt(0) == \\')\\' ||\\n        //         s.charAt(s.length()-1) == \\'{\\' ||\\n        //         s.charAt(s.length()-1) == \\'[\\' ||\\n        //         s.charAt(s.length()-1) == \\'(\\'\\n        // ) return false;\\n        while (s.contains(\"{}\") || s.contains(\"()\") || s.contains(\"[]\")) {\\n            s = s.replace(\"{}\", \"\");\\n            s = s.replace(\"()\", \"\");\\n            s = s.replace(\"[]\", \"\");\\n        }\\n        return s.isEmpty();\\n   }"
                    },
                    {
                        "username": "sametcodes",
                        "content": "Here is one, but time complexity is $$O(n^2)$$ since it works recursively.\\n\\n```javascript\\nfunction isValid(s: string): boolean {\\n    let st = s.replace(/\\\\(\\\\)|\\\\[\\\\]|\\\\{\\\\}/g, \"\");\\n    if(st === \"\") return true;\\n    if(st === s && s) return false;\\n\\n    return isValid(st);\\n};\\n```"
                    },
                    {
                        "username": "ze0ng",
                        "content": "[@sayWhatOneMoreTime](/sayWhatOneMoreTime) thanks, the time complexity on this one is O(n^3) if I am not mistaken; str.replace is O(n^2) apparently in Python. Although clever, it is bad practice to modify the input."
                    },
                    {
                        "username": "sayWhatOneMoreTime",
                        "content": "[@Xiaoyan Lu](/luxy622) I have this solution (not the fastest, but quite easy to understand):\n```\nclass Solution(object):\n    def isValid(self, s):\n        legit_brackets = [\"[]\",\"{}\",\"()\"]\n\n        for i in range(0,len(s)/2):\n            for bracket_type in legit_brackets:\n                s= s.replace(bracket_type,\"\")\n        return len(s) == 0       \n```\n\nI'm basically removing every combination of brackets that i found. If the string at the end is empty, everything was valid. "
                    },
                    {
                        "username": "drecep",
                        "content": "[@drecep](/drecep) here is my solution i cannot post to solution. i dont know why"
                    },
                    {
                        "username": "drecep",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n\\t  boolean v=false;\\n\\t int[] p1=new int[7500];\\n\\t\\t    int[] p2=new int[7500];\\n\\t\\t    int[] p3=new int[7500];\\n\\t\\t    int i=0; int j=0; int P1=0;int P2=0; int P3=0;\\n\\t\\t    while(i<s.length()){\\n\\t\\t         \\n\\t\\t         char c= s.charAt(i);\\n\\n\\t\\t         switch(c){\\n\\t\\t                case \\'(\\': {j++;P1++;p1[P1]=j;\\n                        \\n                        \\n                         break;}\\n\\t\\t                 case \\'[\\':{ j++;P2++;p2[P2]=j; break;}\\n\\t\\t                  case \\'{\\': {j++;P3++; p3[P3]=j;  break;}\\n\\t\\t                  case \\')\\': { if(P1==0||p1[P1]!=j){ v=false; return v;}\\n\\n\\t\\t                      if(p1[P1]==j){j--; P1--; v=true;\\n                              } break;}\\n\\n\\t\\t                  case \\']\\':{   if(P2==0||p2[P2]!=j){ v=false; return v;}\\n\\n\\t\\t                      if(p2[P2]==j){j--;P2--; v=true;} break;}\\n\\n\\t\\t                  case \\'}\\':{ if(P3==0||p3[P3]!=j){ v=false; return v;}\\n\\t\\t                      \\n\\t\\t                      if(p3[P3]==j){j--; P3--; v=true;} break;}\\n\\t\\t         }\\n\\n\\t\\ti++;\\n\\t\\t    }\\n\\t\\t     \\n        if(P3>0||P2>0||P1>0) v=false;\\n\\t\\treturn v;\\n}\\n}"
                    },
                    {
                        "username": "user0586c",
                        "content": "I feel like the description should be updated with a disclaimer that said: order of opening and closing of brackets if not supposed to adhere to mathematical known order.\\n\\nE.g:\\n\\' ( [ { } ] ) \\' is Valid\\n\\' [ ( { } ) ] \\' is Valid, etc.\\n"
                    },
                    {
                        "username": "xsyro",
                        "content": "This was my initial java solution\n\n\n\n```\npublic boolean isValid(String s) {\n        Map<Character, Character> characterMap = new HashMap<>(s.toCharArray().length);\n        characterMap.put(')', '(');\n        characterMap.put('(', ')');\n        characterMap.put('{', '}');\n        characterMap.put('}', '{');\n        characterMap.put(']', '[');\n        characterMap.put('[', ']');\n\n        Stack<Character> sStacks = new Stack<>();\n        for (char c : s.toCharArray()) {\n            sStacks.push(c);\n        }\n\n        for (char fromLeftChar : s.toCharArray()) {\n            char fromRightChar = sStacks.pop();\n            if(characterMap.get(fromRightChar) != fromLeftChar)\n                return false;\n        }\n        return true;\n\n    }``"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kingctan",
                        "content": "Java solution. A simple loop. O(N) at least but easy to understand.\\n    public static boolean isValid(String s) {\\n        while (s.contains(\"{}\") || s.contains(\"()\") || s.contains(\"[]\")) {\\n            s = s.replace(\"{}\", \"\");\\n            s = s.replace(\"()\", \"\");\\n            s = s.replace(\"[]\", \"\");\\n        }\\n        return s.isEmpty();\\n    }"
                    },
                    {
                        "username": "juansymontano",
                        "content": "To anyone who is having a hard time as I did.\\nMy best advice is to treat it as a palindrome.\\n\\nIt doesn\\'t matter how you approach it just think of \"palindrome\" and you\\'ll get it."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes how a stack is used in this problem:\\nyoutube.com/watch?v=YwvHeouhy6s"
                    },
                    {
                        "username": "harshit_singh17",
                        "content": "the no of times I changed my approach because a new test case made gave me a wrong answer is insane, this question definitely doesn\\'t belong to easy category!"
                    },
                    {
                        "username": "Envoy49",
                        "content": "Note from OpenAI:\\n\\nThe task of determining whether an input string of brackets is valid is considered to be of medium complexity.\\n"
                    },
                    {
                        "username": "tbhosale",
                        "content": "If problem needs to be resolved only by using data structures such as stacks, then it should not fall under beginners umbrella. As a beginner i am running around loops and inbuilt functions of string only. This looks a bit harsh. Anyway i will now move on to learn about stack and come back to solve this problem. :)"
                    },
                    {
                        "username": "Kamerro",
                        "content": "Damn, that was quite difficult. I spent almost 2h solving that \\'Easy\\' challenge :)"
                    }
                ]
            },
            {
                "id": 1753593,
                "content": [
                    {
                        "username": "luxy622",
                        "content": "Is there a solution without stack and use only constant space?"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "yes \nhere is 0ms solution without using stack and using constant space complexity\n\n```c++\nbool isValid(string s) {\n        char last = s[0];\n        string current_string = \"\";\n        current_string = current_string + s[0];\n        for(int index = 1; index < s.size(); index++)\n        {\n            if(last == '(' && s[index] == ')')\n            {\n                current_string.pop_back();\n                last = '-';\n            }\n            else if(last == '[' && s[index] == ']')\n            {\n                current_string.pop_back();\n                last = '-';\n            }\n            else if(last == '{' && s[index] == '}')\n            {\n                current_string.pop_back();\n                last = '-';\n            }\n            else\n            {\n                last = s[index];\n                current_string = current_string + s[index];\n            }\n            if(last == '-' && current_string.size() > 0)\n            {\n                last = current_string[current_string.size()-1];\n            }\n        }\n        return current_string.size() == 0 ? true : false;\n    }\n```"
                    },
                    {
                        "username": "rohetoric",
                        "content": "[@sayWhatOneMoreTime](/sayWhatOneMoreTime) but why are you iterating till half of the string?"
                    },
                    {
                        "username": "rohetoric",
                        "content": "[@sayWhatOneMoreTime](/sayWhatOneMoreTime) Implementation wo stack. Smart!"
                    },
                    {
                        "username": "i__a_m__sai",
                        "content": "i got passed 88/93 testcases no stack approach."
                    },
                    {
                        "username": "kingctan",
                        "content": "My Java version without using stack. Very easy to understand.\\n  public static boolean isValid(String s) {\\n    //    if (s.length() % 2 != 0) return false;\\n        // if (s.charAt(0) == \\'}\\' ||\\n        //         s.charAt(0) == \\']\\' ||\\n        //         s.charAt(0) == \\')\\' ||\\n        //         s.charAt(s.length()-1) == \\'{\\' ||\\n        //         s.charAt(s.length()-1) == \\'[\\' ||\\n        //         s.charAt(s.length()-1) == \\'(\\'\\n        // ) return false;\\n        while (s.contains(\"{}\") || s.contains(\"()\") || s.contains(\"[]\")) {\\n            s = s.replace(\"{}\", \"\");\\n            s = s.replace(\"()\", \"\");\\n            s = s.replace(\"[]\", \"\");\\n        }\\n        return s.isEmpty();\\n   }"
                    },
                    {
                        "username": "sametcodes",
                        "content": "Here is one, but time complexity is $$O(n^2)$$ since it works recursively.\\n\\n```javascript\\nfunction isValid(s: string): boolean {\\n    let st = s.replace(/\\\\(\\\\)|\\\\[\\\\]|\\\\{\\\\}/g, \"\");\\n    if(st === \"\") return true;\\n    if(st === s && s) return false;\\n\\n    return isValid(st);\\n};\\n```"
                    },
                    {
                        "username": "ze0ng",
                        "content": "[@sayWhatOneMoreTime](/sayWhatOneMoreTime) thanks, the time complexity on this one is O(n^3) if I am not mistaken; str.replace is O(n^2) apparently in Python. Although clever, it is bad practice to modify the input."
                    },
                    {
                        "username": "sayWhatOneMoreTime",
                        "content": "[@Xiaoyan Lu](/luxy622) I have this solution (not the fastest, but quite easy to understand):\n```\nclass Solution(object):\n    def isValid(self, s):\n        legit_brackets = [\"[]\",\"{}\",\"()\"]\n\n        for i in range(0,len(s)/2):\n            for bracket_type in legit_brackets:\n                s= s.replace(bracket_type,\"\")\n        return len(s) == 0       \n```\n\nI'm basically removing every combination of brackets that i found. If the string at the end is empty, everything was valid. "
                    },
                    {
                        "username": "drecep",
                        "content": "[@drecep](/drecep) here is my solution i cannot post to solution. i dont know why"
                    },
                    {
                        "username": "drecep",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n\\t  boolean v=false;\\n\\t int[] p1=new int[7500];\\n\\t\\t    int[] p2=new int[7500];\\n\\t\\t    int[] p3=new int[7500];\\n\\t\\t    int i=0; int j=0; int P1=0;int P2=0; int P3=0;\\n\\t\\t    while(i<s.length()){\\n\\t\\t         \\n\\t\\t         char c= s.charAt(i);\\n\\n\\t\\t         switch(c){\\n\\t\\t                case \\'(\\': {j++;P1++;p1[P1]=j;\\n                        \\n                        \\n                         break;}\\n\\t\\t                 case \\'[\\':{ j++;P2++;p2[P2]=j; break;}\\n\\t\\t                  case \\'{\\': {j++;P3++; p3[P3]=j;  break;}\\n\\t\\t                  case \\')\\': { if(P1==0||p1[P1]!=j){ v=false; return v;}\\n\\n\\t\\t                      if(p1[P1]==j){j--; P1--; v=true;\\n                              } break;}\\n\\n\\t\\t                  case \\']\\':{   if(P2==0||p2[P2]!=j){ v=false; return v;}\\n\\n\\t\\t                      if(p2[P2]==j){j--;P2--; v=true;} break;}\\n\\n\\t\\t                  case \\'}\\':{ if(P3==0||p3[P3]!=j){ v=false; return v;}\\n\\t\\t                      \\n\\t\\t                      if(p3[P3]==j){j--; P3--; v=true;} break;}\\n\\t\\t         }\\n\\n\\t\\ti++;\\n\\t\\t    }\\n\\t\\t     \\n        if(P3>0||P2>0||P1>0) v=false;\\n\\t\\treturn v;\\n}\\n}"
                    },
                    {
                        "username": "user0586c",
                        "content": "I feel like the description should be updated with a disclaimer that said: order of opening and closing of brackets if not supposed to adhere to mathematical known order.\\n\\nE.g:\\n\\' ( [ { } ] ) \\' is Valid\\n\\' [ ( { } ) ] \\' is Valid, etc.\\n"
                    },
                    {
                        "username": "xsyro",
                        "content": "This was my initial java solution\n\n\n\n```\npublic boolean isValid(String s) {\n        Map<Character, Character> characterMap = new HashMap<>(s.toCharArray().length);\n        characterMap.put(')', '(');\n        characterMap.put('(', ')');\n        characterMap.put('{', '}');\n        characterMap.put('}', '{');\n        characterMap.put(']', '[');\n        characterMap.put('[', ']');\n\n        Stack<Character> sStacks = new Stack<>();\n        for (char c : s.toCharArray()) {\n            sStacks.push(c);\n        }\n\n        for (char fromLeftChar : s.toCharArray()) {\n            char fromRightChar = sStacks.pop();\n            if(characterMap.get(fromRightChar) != fromLeftChar)\n                return false;\n        }\n        return true;\n\n    }``"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kingctan",
                        "content": "Java solution. A simple loop. O(N) at least but easy to understand.\\n    public static boolean isValid(String s) {\\n        while (s.contains(\"{}\") || s.contains(\"()\") || s.contains(\"[]\")) {\\n            s = s.replace(\"{}\", \"\");\\n            s = s.replace(\"()\", \"\");\\n            s = s.replace(\"[]\", \"\");\\n        }\\n        return s.isEmpty();\\n    }"
                    },
                    {
                        "username": "juansymontano",
                        "content": "To anyone who is having a hard time as I did.\\nMy best advice is to treat it as a palindrome.\\n\\nIt doesn\\'t matter how you approach it just think of \"palindrome\" and you\\'ll get it."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes how a stack is used in this problem:\\nyoutube.com/watch?v=YwvHeouhy6s"
                    },
                    {
                        "username": "harshit_singh17",
                        "content": "the no of times I changed my approach because a new test case made gave me a wrong answer is insane, this question definitely doesn\\'t belong to easy category!"
                    },
                    {
                        "username": "Envoy49",
                        "content": "Note from OpenAI:\\n\\nThe task of determining whether an input string of brackets is valid is considered to be of medium complexity.\\n"
                    },
                    {
                        "username": "tbhosale",
                        "content": "If problem needs to be resolved only by using data structures such as stacks, then it should not fall under beginners umbrella. As a beginner i am running around loops and inbuilt functions of string only. This looks a bit harsh. Anyway i will now move on to learn about stack and come back to solve this problem. :)"
                    },
                    {
                        "username": "Kamerro",
                        "content": "Damn, that was quite difficult. I spent almost 2h solving that \\'Easy\\' challenge :)"
                    }
                ]
            },
            {
                "id": 1951356,
                "content": [
                    {
                        "username": "luxy622",
                        "content": "Is there a solution without stack and use only constant space?"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "yes \nhere is 0ms solution without using stack and using constant space complexity\n\n```c++\nbool isValid(string s) {\n        char last = s[0];\n        string current_string = \"\";\n        current_string = current_string + s[0];\n        for(int index = 1; index < s.size(); index++)\n        {\n            if(last == '(' && s[index] == ')')\n            {\n                current_string.pop_back();\n                last = '-';\n            }\n            else if(last == '[' && s[index] == ']')\n            {\n                current_string.pop_back();\n                last = '-';\n            }\n            else if(last == '{' && s[index] == '}')\n            {\n                current_string.pop_back();\n                last = '-';\n            }\n            else\n            {\n                last = s[index];\n                current_string = current_string + s[index];\n            }\n            if(last == '-' && current_string.size() > 0)\n            {\n                last = current_string[current_string.size()-1];\n            }\n        }\n        return current_string.size() == 0 ? true : false;\n    }\n```"
                    },
                    {
                        "username": "rohetoric",
                        "content": "[@sayWhatOneMoreTime](/sayWhatOneMoreTime) but why are you iterating till half of the string?"
                    },
                    {
                        "username": "rohetoric",
                        "content": "[@sayWhatOneMoreTime](/sayWhatOneMoreTime) Implementation wo stack. Smart!"
                    },
                    {
                        "username": "i__a_m__sai",
                        "content": "i got passed 88/93 testcases no stack approach."
                    },
                    {
                        "username": "kingctan",
                        "content": "My Java version without using stack. Very easy to understand.\\n  public static boolean isValid(String s) {\\n    //    if (s.length() % 2 != 0) return false;\\n        // if (s.charAt(0) == \\'}\\' ||\\n        //         s.charAt(0) == \\']\\' ||\\n        //         s.charAt(0) == \\')\\' ||\\n        //         s.charAt(s.length()-1) == \\'{\\' ||\\n        //         s.charAt(s.length()-1) == \\'[\\' ||\\n        //         s.charAt(s.length()-1) == \\'(\\'\\n        // ) return false;\\n        while (s.contains(\"{}\") || s.contains(\"()\") || s.contains(\"[]\")) {\\n            s = s.replace(\"{}\", \"\");\\n            s = s.replace(\"()\", \"\");\\n            s = s.replace(\"[]\", \"\");\\n        }\\n        return s.isEmpty();\\n   }"
                    },
                    {
                        "username": "sametcodes",
                        "content": "Here is one, but time complexity is $$O(n^2)$$ since it works recursively.\\n\\n```javascript\\nfunction isValid(s: string): boolean {\\n    let st = s.replace(/\\\\(\\\\)|\\\\[\\\\]|\\\\{\\\\}/g, \"\");\\n    if(st === \"\") return true;\\n    if(st === s && s) return false;\\n\\n    return isValid(st);\\n};\\n```"
                    },
                    {
                        "username": "ze0ng",
                        "content": "[@sayWhatOneMoreTime](/sayWhatOneMoreTime) thanks, the time complexity on this one is O(n^3) if I am not mistaken; str.replace is O(n^2) apparently in Python. Although clever, it is bad practice to modify the input."
                    },
                    {
                        "username": "sayWhatOneMoreTime",
                        "content": "[@Xiaoyan Lu](/luxy622) I have this solution (not the fastest, but quite easy to understand):\n```\nclass Solution(object):\n    def isValid(self, s):\n        legit_brackets = [\"[]\",\"{}\",\"()\"]\n\n        for i in range(0,len(s)/2):\n            for bracket_type in legit_brackets:\n                s= s.replace(bracket_type,\"\")\n        return len(s) == 0       \n```\n\nI'm basically removing every combination of brackets that i found. If the string at the end is empty, everything was valid. "
                    },
                    {
                        "username": "drecep",
                        "content": "[@drecep](/drecep) here is my solution i cannot post to solution. i dont know why"
                    },
                    {
                        "username": "drecep",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n\\t  boolean v=false;\\n\\t int[] p1=new int[7500];\\n\\t\\t    int[] p2=new int[7500];\\n\\t\\t    int[] p3=new int[7500];\\n\\t\\t    int i=0; int j=0; int P1=0;int P2=0; int P3=0;\\n\\t\\t    while(i<s.length()){\\n\\t\\t         \\n\\t\\t         char c= s.charAt(i);\\n\\n\\t\\t         switch(c){\\n\\t\\t                case \\'(\\': {j++;P1++;p1[P1]=j;\\n                        \\n                        \\n                         break;}\\n\\t\\t                 case \\'[\\':{ j++;P2++;p2[P2]=j; break;}\\n\\t\\t                  case \\'{\\': {j++;P3++; p3[P3]=j;  break;}\\n\\t\\t                  case \\')\\': { if(P1==0||p1[P1]!=j){ v=false; return v;}\\n\\n\\t\\t                      if(p1[P1]==j){j--; P1--; v=true;\\n                              } break;}\\n\\n\\t\\t                  case \\']\\':{   if(P2==0||p2[P2]!=j){ v=false; return v;}\\n\\n\\t\\t                      if(p2[P2]==j){j--;P2--; v=true;} break;}\\n\\n\\t\\t                  case \\'}\\':{ if(P3==0||p3[P3]!=j){ v=false; return v;}\\n\\t\\t                      \\n\\t\\t                      if(p3[P3]==j){j--; P3--; v=true;} break;}\\n\\t\\t         }\\n\\n\\t\\ti++;\\n\\t\\t    }\\n\\t\\t     \\n        if(P3>0||P2>0||P1>0) v=false;\\n\\t\\treturn v;\\n}\\n}"
                    },
                    {
                        "username": "user0586c",
                        "content": "I feel like the description should be updated with a disclaimer that said: order of opening and closing of brackets if not supposed to adhere to mathematical known order.\\n\\nE.g:\\n\\' ( [ { } ] ) \\' is Valid\\n\\' [ ( { } ) ] \\' is Valid, etc.\\n"
                    },
                    {
                        "username": "xsyro",
                        "content": "This was my initial java solution\n\n\n\n```\npublic boolean isValid(String s) {\n        Map<Character, Character> characterMap = new HashMap<>(s.toCharArray().length);\n        characterMap.put(')', '(');\n        characterMap.put('(', ')');\n        characterMap.put('{', '}');\n        characterMap.put('}', '{');\n        characterMap.put(']', '[');\n        characterMap.put('[', ']');\n\n        Stack<Character> sStacks = new Stack<>();\n        for (char c : s.toCharArray()) {\n            sStacks.push(c);\n        }\n\n        for (char fromLeftChar : s.toCharArray()) {\n            char fromRightChar = sStacks.pop();\n            if(characterMap.get(fromRightChar) != fromLeftChar)\n                return false;\n        }\n        return true;\n\n    }``"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kingctan",
                        "content": "Java solution. A simple loop. O(N) at least but easy to understand.\\n    public static boolean isValid(String s) {\\n        while (s.contains(\"{}\") || s.contains(\"()\") || s.contains(\"[]\")) {\\n            s = s.replace(\"{}\", \"\");\\n            s = s.replace(\"()\", \"\");\\n            s = s.replace(\"[]\", \"\");\\n        }\\n        return s.isEmpty();\\n    }"
                    },
                    {
                        "username": "juansymontano",
                        "content": "To anyone who is having a hard time as I did.\\nMy best advice is to treat it as a palindrome.\\n\\nIt doesn\\'t matter how you approach it just think of \"palindrome\" and you\\'ll get it."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes how a stack is used in this problem:\\nyoutube.com/watch?v=YwvHeouhy6s"
                    },
                    {
                        "username": "harshit_singh17",
                        "content": "the no of times I changed my approach because a new test case made gave me a wrong answer is insane, this question definitely doesn\\'t belong to easy category!"
                    },
                    {
                        "username": "Envoy49",
                        "content": "Note from OpenAI:\\n\\nThe task of determining whether an input string of brackets is valid is considered to be of medium complexity.\\n"
                    },
                    {
                        "username": "tbhosale",
                        "content": "If problem needs to be resolved only by using data structures such as stacks, then it should not fall under beginners umbrella. As a beginner i am running around loops and inbuilt functions of string only. This looks a bit harsh. Anyway i will now move on to learn about stack and come back to solve this problem. :)"
                    },
                    {
                        "username": "Kamerro",
                        "content": "Damn, that was quite difficult. I spent almost 2h solving that \\'Easy\\' challenge :)"
                    }
                ]
            },
            {
                "id": 1953664,
                "content": [
                    {
                        "username": "luxy622",
                        "content": "Is there a solution without stack and use only constant space?"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "yes \nhere is 0ms solution without using stack and using constant space complexity\n\n```c++\nbool isValid(string s) {\n        char last = s[0];\n        string current_string = \"\";\n        current_string = current_string + s[0];\n        for(int index = 1; index < s.size(); index++)\n        {\n            if(last == '(' && s[index] == ')')\n            {\n                current_string.pop_back();\n                last = '-';\n            }\n            else if(last == '[' && s[index] == ']')\n            {\n                current_string.pop_back();\n                last = '-';\n            }\n            else if(last == '{' && s[index] == '}')\n            {\n                current_string.pop_back();\n                last = '-';\n            }\n            else\n            {\n                last = s[index];\n                current_string = current_string + s[index];\n            }\n            if(last == '-' && current_string.size() > 0)\n            {\n                last = current_string[current_string.size()-1];\n            }\n        }\n        return current_string.size() == 0 ? true : false;\n    }\n```"
                    },
                    {
                        "username": "rohetoric",
                        "content": "[@sayWhatOneMoreTime](/sayWhatOneMoreTime) but why are you iterating till half of the string?"
                    },
                    {
                        "username": "rohetoric",
                        "content": "[@sayWhatOneMoreTime](/sayWhatOneMoreTime) Implementation wo stack. Smart!"
                    },
                    {
                        "username": "i__a_m__sai",
                        "content": "i got passed 88/93 testcases no stack approach."
                    },
                    {
                        "username": "kingctan",
                        "content": "My Java version without using stack. Very easy to understand.\\n  public static boolean isValid(String s) {\\n    //    if (s.length() % 2 != 0) return false;\\n        // if (s.charAt(0) == \\'}\\' ||\\n        //         s.charAt(0) == \\']\\' ||\\n        //         s.charAt(0) == \\')\\' ||\\n        //         s.charAt(s.length()-1) == \\'{\\' ||\\n        //         s.charAt(s.length()-1) == \\'[\\' ||\\n        //         s.charAt(s.length()-1) == \\'(\\'\\n        // ) return false;\\n        while (s.contains(\"{}\") || s.contains(\"()\") || s.contains(\"[]\")) {\\n            s = s.replace(\"{}\", \"\");\\n            s = s.replace(\"()\", \"\");\\n            s = s.replace(\"[]\", \"\");\\n        }\\n        return s.isEmpty();\\n   }"
                    },
                    {
                        "username": "sametcodes",
                        "content": "Here is one, but time complexity is $$O(n^2)$$ since it works recursively.\\n\\n```javascript\\nfunction isValid(s: string): boolean {\\n    let st = s.replace(/\\\\(\\\\)|\\\\[\\\\]|\\\\{\\\\}/g, \"\");\\n    if(st === \"\") return true;\\n    if(st === s && s) return false;\\n\\n    return isValid(st);\\n};\\n```"
                    },
                    {
                        "username": "ze0ng",
                        "content": "[@sayWhatOneMoreTime](/sayWhatOneMoreTime) thanks, the time complexity on this one is O(n^3) if I am not mistaken; str.replace is O(n^2) apparently in Python. Although clever, it is bad practice to modify the input."
                    },
                    {
                        "username": "sayWhatOneMoreTime",
                        "content": "[@Xiaoyan Lu](/luxy622) I have this solution (not the fastest, but quite easy to understand):\n```\nclass Solution(object):\n    def isValid(self, s):\n        legit_brackets = [\"[]\",\"{}\",\"()\"]\n\n        for i in range(0,len(s)/2):\n            for bracket_type in legit_brackets:\n                s= s.replace(bracket_type,\"\")\n        return len(s) == 0       \n```\n\nI'm basically removing every combination of brackets that i found. If the string at the end is empty, everything was valid. "
                    },
                    {
                        "username": "drecep",
                        "content": "[@drecep](/drecep) here is my solution i cannot post to solution. i dont know why"
                    },
                    {
                        "username": "drecep",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n\\t  boolean v=false;\\n\\t int[] p1=new int[7500];\\n\\t\\t    int[] p2=new int[7500];\\n\\t\\t    int[] p3=new int[7500];\\n\\t\\t    int i=0; int j=0; int P1=0;int P2=0; int P3=0;\\n\\t\\t    while(i<s.length()){\\n\\t\\t         \\n\\t\\t         char c= s.charAt(i);\\n\\n\\t\\t         switch(c){\\n\\t\\t                case \\'(\\': {j++;P1++;p1[P1]=j;\\n                        \\n                        \\n                         break;}\\n\\t\\t                 case \\'[\\':{ j++;P2++;p2[P2]=j; break;}\\n\\t\\t                  case \\'{\\': {j++;P3++; p3[P3]=j;  break;}\\n\\t\\t                  case \\')\\': { if(P1==0||p1[P1]!=j){ v=false; return v;}\\n\\n\\t\\t                      if(p1[P1]==j){j--; P1--; v=true;\\n                              } break;}\\n\\n\\t\\t                  case \\']\\':{   if(P2==0||p2[P2]!=j){ v=false; return v;}\\n\\n\\t\\t                      if(p2[P2]==j){j--;P2--; v=true;} break;}\\n\\n\\t\\t                  case \\'}\\':{ if(P3==0||p3[P3]!=j){ v=false; return v;}\\n\\t\\t                      \\n\\t\\t                      if(p3[P3]==j){j--; P3--; v=true;} break;}\\n\\t\\t         }\\n\\n\\t\\ti++;\\n\\t\\t    }\\n\\t\\t     \\n        if(P3>0||P2>0||P1>0) v=false;\\n\\t\\treturn v;\\n}\\n}"
                    },
                    {
                        "username": "user0586c",
                        "content": "I feel like the description should be updated with a disclaimer that said: order of opening and closing of brackets if not supposed to adhere to mathematical known order.\\n\\nE.g:\\n\\' ( [ { } ] ) \\' is Valid\\n\\' [ ( { } ) ] \\' is Valid, etc.\\n"
                    },
                    {
                        "username": "xsyro",
                        "content": "This was my initial java solution\n\n\n\n```\npublic boolean isValid(String s) {\n        Map<Character, Character> characterMap = new HashMap<>(s.toCharArray().length);\n        characterMap.put(')', '(');\n        characterMap.put('(', ')');\n        characterMap.put('{', '}');\n        characterMap.put('}', '{');\n        characterMap.put(']', '[');\n        characterMap.put('[', ']');\n\n        Stack<Character> sStacks = new Stack<>();\n        for (char c : s.toCharArray()) {\n            sStacks.push(c);\n        }\n\n        for (char fromLeftChar : s.toCharArray()) {\n            char fromRightChar = sStacks.pop();\n            if(characterMap.get(fromRightChar) != fromLeftChar)\n                return false;\n        }\n        return true;\n\n    }``"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kingctan",
                        "content": "Java solution. A simple loop. O(N) at least but easy to understand.\\n    public static boolean isValid(String s) {\\n        while (s.contains(\"{}\") || s.contains(\"()\") || s.contains(\"[]\")) {\\n            s = s.replace(\"{}\", \"\");\\n            s = s.replace(\"()\", \"\");\\n            s = s.replace(\"[]\", \"\");\\n        }\\n        return s.isEmpty();\\n    }"
                    },
                    {
                        "username": "juansymontano",
                        "content": "To anyone who is having a hard time as I did.\\nMy best advice is to treat it as a palindrome.\\n\\nIt doesn\\'t matter how you approach it just think of \"palindrome\" and you\\'ll get it."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes how a stack is used in this problem:\\nyoutube.com/watch?v=YwvHeouhy6s"
                    },
                    {
                        "username": "harshit_singh17",
                        "content": "the no of times I changed my approach because a new test case made gave me a wrong answer is insane, this question definitely doesn\\'t belong to easy category!"
                    },
                    {
                        "username": "Envoy49",
                        "content": "Note from OpenAI:\\n\\nThe task of determining whether an input string of brackets is valid is considered to be of medium complexity.\\n"
                    },
                    {
                        "username": "tbhosale",
                        "content": "If problem needs to be resolved only by using data structures such as stacks, then it should not fall under beginners umbrella. As a beginner i am running around loops and inbuilt functions of string only. This looks a bit harsh. Anyway i will now move on to learn about stack and come back to solve this problem. :)"
                    },
                    {
                        "username": "Kamerro",
                        "content": "Damn, that was quite difficult. I spent almost 2h solving that \\'Easy\\' challenge :)"
                    }
                ]
            },
            {
                "id": 2001019,
                "content": [
                    {
                        "username": "Alenzy",
                        "content": "This can\\'t be considered \"easy\""
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I am coding the solution in Java and I have an issue for the test 92 : \n\ni have an \"Output Limit Exceeded\" for this case. In this last test the input is : \"s=\" . Thus, there is no intput and i don't know why i have nothing returned.\n\nMoreover, this test doesn't have to exist because in the description it's said that s.length >= 1 . And in this test it's not the case, i would like to know if anybody had the same issue. \n\nI tried to add the case were s is blank, or null, or empty and it deosn't change anything, it looks like my code doesn't even run."
                    },
                    {
                        "username": "demitsuria",
                        "content": "I have the same"
                    },
                    {
                        "username": "idris0himeur",
                        "content": "in the test 68 with s= \"([)]\" , according to the description, the expected result is true, but the actual result is returning false.  ? can someone explain this ?   it seems from the discription that nested parentheses are accepted !"
                    },
                    {
                        "username": "robin_wadekar30",
                        "content": "Okay, but can we use Stack.........??"
                    },
                    {
                        "username": "MoGHenry",
                        "content": "for anyone who are concern about the unclear description of the instruction, the interviewer is expecting you to ask for a clarify. That\\'s a key points for an interview"
                    },
                    {
                        "username": "seraphsword",
                        "content": "The interviewer would be expecting you to know how parentheses work in math more likely."
                    },
                    {
                        "username": "majdfir4s",
                        "content": "the description is trash and not clear .. need to be updated"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Finally .........\\nGraphs week is over...\\uD83D\\uDE0A"
                    },
                    {
                        "username": "jpmorganchase",
                        "content": "recursion is effecitvely a stack.\n\ncan we do with constant space, linear time, and not modify the input?"
                    },
                    {
                        "username": "kelvin2602",
                        "content": "so I try case \"[{](})\"\\nI attempted to evaluate the case \"{\", and indeed, it resulted in a \"false\" outcome. This outcome aligns with the typical expectation that an opening bracket should be followed by a corresponding closing bracket. However, when an opening bracket is placed within another pair of brackets and the closing bracket for the innermost pair is positioned outside, the result is also \"false.\" This discrepancy occurs because the closing bracket, although appearing outside the inner pair, effectively closes the innermost bracket, making it distinct from the opening bracket outside. In such cases, even though the bracket appears outside, it is still considered a different bracket from the one inside, resulting in an unbalanced configuration."
                    },
                    {
                        "username": "CC_Debjyoti",
                        "content": "Was finally able to solve this question after many hrs using 10 lines of else if\\'s GG :)"
                    }
                ]
            },
            {
                "id": 1796177,
                "content": [
                    {
                        "username": "Alenzy",
                        "content": "This can\\'t be considered \"easy\""
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I am coding the solution in Java and I have an issue for the test 92 : \n\ni have an \"Output Limit Exceeded\" for this case. In this last test the input is : \"s=\" . Thus, there is no intput and i don't know why i have nothing returned.\n\nMoreover, this test doesn't have to exist because in the description it's said that s.length >= 1 . And in this test it's not the case, i would like to know if anybody had the same issue. \n\nI tried to add the case were s is blank, or null, or empty and it deosn't change anything, it looks like my code doesn't even run."
                    },
                    {
                        "username": "demitsuria",
                        "content": "I have the same"
                    },
                    {
                        "username": "idris0himeur",
                        "content": "in the test 68 with s= \"([)]\" , according to the description, the expected result is true, but the actual result is returning false.  ? can someone explain this ?   it seems from the discription that nested parentheses are accepted !"
                    },
                    {
                        "username": "robin_wadekar30",
                        "content": "Okay, but can we use Stack.........??"
                    },
                    {
                        "username": "MoGHenry",
                        "content": "for anyone who are concern about the unclear description of the instruction, the interviewer is expecting you to ask for a clarify. That\\'s a key points for an interview"
                    },
                    {
                        "username": "seraphsword",
                        "content": "The interviewer would be expecting you to know how parentheses work in math more likely."
                    },
                    {
                        "username": "majdfir4s",
                        "content": "the description is trash and not clear .. need to be updated"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Finally .........\\nGraphs week is over...\\uD83D\\uDE0A"
                    },
                    {
                        "username": "jpmorganchase",
                        "content": "recursion is effecitvely a stack.\n\ncan we do with constant space, linear time, and not modify the input?"
                    },
                    {
                        "username": "kelvin2602",
                        "content": "so I try case \"[{](})\"\\nI attempted to evaluate the case \"{\", and indeed, it resulted in a \"false\" outcome. This outcome aligns with the typical expectation that an opening bracket should be followed by a corresponding closing bracket. However, when an opening bracket is placed within another pair of brackets and the closing bracket for the innermost pair is positioned outside, the result is also \"false.\" This discrepancy occurs because the closing bracket, although appearing outside the inner pair, effectively closes the innermost bracket, making it distinct from the opening bracket outside. In such cases, even though the bracket appears outside, it is still considered a different bracket from the one inside, resulting in an unbalanced configuration."
                    },
                    {
                        "username": "CC_Debjyoti",
                        "content": "Was finally able to solve this question after many hrs using 10 lines of else if\\'s GG :)"
                    }
                ]
            },
            {
                "id": 2036206,
                "content": [
                    {
                        "username": "Alenzy",
                        "content": "This can\\'t be considered \"easy\""
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I am coding the solution in Java and I have an issue for the test 92 : \n\ni have an \"Output Limit Exceeded\" for this case. In this last test the input is : \"s=\" . Thus, there is no intput and i don't know why i have nothing returned.\n\nMoreover, this test doesn't have to exist because in the description it's said that s.length >= 1 . And in this test it's not the case, i would like to know if anybody had the same issue. \n\nI tried to add the case were s is blank, or null, or empty and it deosn't change anything, it looks like my code doesn't even run."
                    },
                    {
                        "username": "demitsuria",
                        "content": "I have the same"
                    },
                    {
                        "username": "idris0himeur",
                        "content": "in the test 68 with s= \"([)]\" , according to the description, the expected result is true, but the actual result is returning false.  ? can someone explain this ?   it seems from the discription that nested parentheses are accepted !"
                    },
                    {
                        "username": "robin_wadekar30",
                        "content": "Okay, but can we use Stack.........??"
                    },
                    {
                        "username": "MoGHenry",
                        "content": "for anyone who are concern about the unclear description of the instruction, the interviewer is expecting you to ask for a clarify. That\\'s a key points for an interview"
                    },
                    {
                        "username": "seraphsword",
                        "content": "The interviewer would be expecting you to know how parentheses work in math more likely."
                    },
                    {
                        "username": "majdfir4s",
                        "content": "the description is trash and not clear .. need to be updated"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Finally .........\\nGraphs week is over...\\uD83D\\uDE0A"
                    },
                    {
                        "username": "jpmorganchase",
                        "content": "recursion is effecitvely a stack.\n\ncan we do with constant space, linear time, and not modify the input?"
                    },
                    {
                        "username": "kelvin2602",
                        "content": "so I try case \"[{](})\"\\nI attempted to evaluate the case \"{\", and indeed, it resulted in a \"false\" outcome. This outcome aligns with the typical expectation that an opening bracket should be followed by a corresponding closing bracket. However, when an opening bracket is placed within another pair of brackets and the closing bracket for the innermost pair is positioned outside, the result is also \"false.\" This discrepancy occurs because the closing bracket, although appearing outside the inner pair, effectively closes the innermost bracket, making it distinct from the opening bracket outside. In such cases, even though the bracket appears outside, it is still considered a different bracket from the one inside, resulting in an unbalanced configuration."
                    },
                    {
                        "username": "CC_Debjyoti",
                        "content": "Was finally able to solve this question after many hrs using 10 lines of else if\\'s GG :)"
                    }
                ]
            },
            {
                "id": 1967985,
                "content": [
                    {
                        "username": "Alenzy",
                        "content": "This can\\'t be considered \"easy\""
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I am coding the solution in Java and I have an issue for the test 92 : \n\ni have an \"Output Limit Exceeded\" for this case. In this last test the input is : \"s=\" . Thus, there is no intput and i don't know why i have nothing returned.\n\nMoreover, this test doesn't have to exist because in the description it's said that s.length >= 1 . And in this test it's not the case, i would like to know if anybody had the same issue. \n\nI tried to add the case were s is blank, or null, or empty and it deosn't change anything, it looks like my code doesn't even run."
                    },
                    {
                        "username": "demitsuria",
                        "content": "I have the same"
                    },
                    {
                        "username": "idris0himeur",
                        "content": "in the test 68 with s= \"([)]\" , according to the description, the expected result is true, but the actual result is returning false.  ? can someone explain this ?   it seems from the discription that nested parentheses are accepted !"
                    },
                    {
                        "username": "robin_wadekar30",
                        "content": "Okay, but can we use Stack.........??"
                    },
                    {
                        "username": "MoGHenry",
                        "content": "for anyone who are concern about the unclear description of the instruction, the interviewer is expecting you to ask for a clarify. That\\'s a key points for an interview"
                    },
                    {
                        "username": "seraphsword",
                        "content": "The interviewer would be expecting you to know how parentheses work in math more likely."
                    },
                    {
                        "username": "majdfir4s",
                        "content": "the description is trash and not clear .. need to be updated"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Finally .........\\nGraphs week is over...\\uD83D\\uDE0A"
                    },
                    {
                        "username": "jpmorganchase",
                        "content": "recursion is effecitvely a stack.\n\ncan we do with constant space, linear time, and not modify the input?"
                    },
                    {
                        "username": "kelvin2602",
                        "content": "so I try case \"[{](})\"\\nI attempted to evaluate the case \"{\", and indeed, it resulted in a \"false\" outcome. This outcome aligns with the typical expectation that an opening bracket should be followed by a corresponding closing bracket. However, when an opening bracket is placed within another pair of brackets and the closing bracket for the innermost pair is positioned outside, the result is also \"false.\" This discrepancy occurs because the closing bracket, although appearing outside the inner pair, effectively closes the innermost bracket, making it distinct from the opening bracket outside. In such cases, even though the bracket appears outside, it is still considered a different bracket from the one inside, resulting in an unbalanced configuration."
                    },
                    {
                        "username": "CC_Debjyoti",
                        "content": "Was finally able to solve this question after many hrs using 10 lines of else if\\'s GG :)"
                    }
                ]
            },
            {
                "id": 1935129,
                "content": [
                    {
                        "username": "Alenzy",
                        "content": "This can\\'t be considered \"easy\""
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I am coding the solution in Java and I have an issue for the test 92 : \n\ni have an \"Output Limit Exceeded\" for this case. In this last test the input is : \"s=\" . Thus, there is no intput and i don't know why i have nothing returned.\n\nMoreover, this test doesn't have to exist because in the description it's said that s.length >= 1 . And in this test it's not the case, i would like to know if anybody had the same issue. \n\nI tried to add the case were s is blank, or null, or empty and it deosn't change anything, it looks like my code doesn't even run."
                    },
                    {
                        "username": "demitsuria",
                        "content": "I have the same"
                    },
                    {
                        "username": "idris0himeur",
                        "content": "in the test 68 with s= \"([)]\" , according to the description, the expected result is true, but the actual result is returning false.  ? can someone explain this ?   it seems from the discription that nested parentheses are accepted !"
                    },
                    {
                        "username": "robin_wadekar30",
                        "content": "Okay, but can we use Stack.........??"
                    },
                    {
                        "username": "MoGHenry",
                        "content": "for anyone who are concern about the unclear description of the instruction, the interviewer is expecting you to ask for a clarify. That\\'s a key points for an interview"
                    },
                    {
                        "username": "seraphsword",
                        "content": "The interviewer would be expecting you to know how parentheses work in math more likely."
                    },
                    {
                        "username": "majdfir4s",
                        "content": "the description is trash and not clear .. need to be updated"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Finally .........\\nGraphs week is over...\\uD83D\\uDE0A"
                    },
                    {
                        "username": "jpmorganchase",
                        "content": "recursion is effecitvely a stack.\n\ncan we do with constant space, linear time, and not modify the input?"
                    },
                    {
                        "username": "kelvin2602",
                        "content": "so I try case \"[{](})\"\\nI attempted to evaluate the case \"{\", and indeed, it resulted in a \"false\" outcome. This outcome aligns with the typical expectation that an opening bracket should be followed by a corresponding closing bracket. However, when an opening bracket is placed within another pair of brackets and the closing bracket for the innermost pair is positioned outside, the result is also \"false.\" This discrepancy occurs because the closing bracket, although appearing outside the inner pair, effectively closes the innermost bracket, making it distinct from the opening bracket outside. In such cases, even though the bracket appears outside, it is still considered a different bracket from the one inside, resulting in an unbalanced configuration."
                    },
                    {
                        "username": "CC_Debjyoti",
                        "content": "Was finally able to solve this question after many hrs using 10 lines of else if\\'s GG :)"
                    }
                ]
            },
            {
                "id": 1930333,
                "content": [
                    {
                        "username": "Alenzy",
                        "content": "This can\\'t be considered \"easy\""
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I am coding the solution in Java and I have an issue for the test 92 : \n\ni have an \"Output Limit Exceeded\" for this case. In this last test the input is : \"s=\" . Thus, there is no intput and i don't know why i have nothing returned.\n\nMoreover, this test doesn't have to exist because in the description it's said that s.length >= 1 . And in this test it's not the case, i would like to know if anybody had the same issue. \n\nI tried to add the case were s is blank, or null, or empty and it deosn't change anything, it looks like my code doesn't even run."
                    },
                    {
                        "username": "demitsuria",
                        "content": "I have the same"
                    },
                    {
                        "username": "idris0himeur",
                        "content": "in the test 68 with s= \"([)]\" , according to the description, the expected result is true, but the actual result is returning false.  ? can someone explain this ?   it seems from the discription that nested parentheses are accepted !"
                    },
                    {
                        "username": "robin_wadekar30",
                        "content": "Okay, but can we use Stack.........??"
                    },
                    {
                        "username": "MoGHenry",
                        "content": "for anyone who are concern about the unclear description of the instruction, the interviewer is expecting you to ask for a clarify. That\\'s a key points for an interview"
                    },
                    {
                        "username": "seraphsword",
                        "content": "The interviewer would be expecting you to know how parentheses work in math more likely."
                    },
                    {
                        "username": "majdfir4s",
                        "content": "the description is trash and not clear .. need to be updated"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Finally .........\\nGraphs week is over...\\uD83D\\uDE0A"
                    },
                    {
                        "username": "jpmorganchase",
                        "content": "recursion is effecitvely a stack.\n\ncan we do with constant space, linear time, and not modify the input?"
                    },
                    {
                        "username": "kelvin2602",
                        "content": "so I try case \"[{](})\"\\nI attempted to evaluate the case \"{\", and indeed, it resulted in a \"false\" outcome. This outcome aligns with the typical expectation that an opening bracket should be followed by a corresponding closing bracket. However, when an opening bracket is placed within another pair of brackets and the closing bracket for the innermost pair is positioned outside, the result is also \"false.\" This discrepancy occurs because the closing bracket, although appearing outside the inner pair, effectively closes the innermost bracket, making it distinct from the opening bracket outside. In such cases, even though the bracket appears outside, it is still considered a different bracket from the one inside, resulting in an unbalanced configuration."
                    },
                    {
                        "username": "CC_Debjyoti",
                        "content": "Was finally able to solve this question after many hrs using 10 lines of else if\\'s GG :)"
                    }
                ]
            },
            {
                "id": 1859377,
                "content": [
                    {
                        "username": "Alenzy",
                        "content": "This can\\'t be considered \"easy\""
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I am coding the solution in Java and I have an issue for the test 92 : \n\ni have an \"Output Limit Exceeded\" for this case. In this last test the input is : \"s=\" . Thus, there is no intput and i don't know why i have nothing returned.\n\nMoreover, this test doesn't have to exist because in the description it's said that s.length >= 1 . And in this test it's not the case, i would like to know if anybody had the same issue. \n\nI tried to add the case were s is blank, or null, or empty and it deosn't change anything, it looks like my code doesn't even run."
                    },
                    {
                        "username": "demitsuria",
                        "content": "I have the same"
                    },
                    {
                        "username": "idris0himeur",
                        "content": "in the test 68 with s= \"([)]\" , according to the description, the expected result is true, but the actual result is returning false.  ? can someone explain this ?   it seems from the discription that nested parentheses are accepted !"
                    },
                    {
                        "username": "robin_wadekar30",
                        "content": "Okay, but can we use Stack.........??"
                    },
                    {
                        "username": "MoGHenry",
                        "content": "for anyone who are concern about the unclear description of the instruction, the interviewer is expecting you to ask for a clarify. That\\'s a key points for an interview"
                    },
                    {
                        "username": "seraphsword",
                        "content": "The interviewer would be expecting you to know how parentheses work in math more likely."
                    },
                    {
                        "username": "majdfir4s",
                        "content": "the description is trash and not clear .. need to be updated"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Finally .........\\nGraphs week is over...\\uD83D\\uDE0A"
                    },
                    {
                        "username": "jpmorganchase",
                        "content": "recursion is effecitvely a stack.\n\ncan we do with constant space, linear time, and not modify the input?"
                    },
                    {
                        "username": "kelvin2602",
                        "content": "so I try case \"[{](})\"\\nI attempted to evaluate the case \"{\", and indeed, it resulted in a \"false\" outcome. This outcome aligns with the typical expectation that an opening bracket should be followed by a corresponding closing bracket. However, when an opening bracket is placed within another pair of brackets and the closing bracket for the innermost pair is positioned outside, the result is also \"false.\" This discrepancy occurs because the closing bracket, although appearing outside the inner pair, effectively closes the innermost bracket, making it distinct from the opening bracket outside. In such cases, even though the bracket appears outside, it is still considered a different bracket from the one inside, resulting in an unbalanced configuration."
                    },
                    {
                        "username": "CC_Debjyoti",
                        "content": "Was finally able to solve this question after many hrs using 10 lines of else if\\'s GG :)"
                    }
                ]
            },
            {
                "id": 1571858,
                "content": [
                    {
                        "username": "Alenzy",
                        "content": "This can\\'t be considered \"easy\""
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I am coding the solution in Java and I have an issue for the test 92 : \n\ni have an \"Output Limit Exceeded\" for this case. In this last test the input is : \"s=\" . Thus, there is no intput and i don't know why i have nothing returned.\n\nMoreover, this test doesn't have to exist because in the description it's said that s.length >= 1 . And in this test it's not the case, i would like to know if anybody had the same issue. \n\nI tried to add the case were s is blank, or null, or empty and it deosn't change anything, it looks like my code doesn't even run."
                    },
                    {
                        "username": "demitsuria",
                        "content": "I have the same"
                    },
                    {
                        "username": "idris0himeur",
                        "content": "in the test 68 with s= \"([)]\" , according to the description, the expected result is true, but the actual result is returning false.  ? can someone explain this ?   it seems from the discription that nested parentheses are accepted !"
                    },
                    {
                        "username": "robin_wadekar30",
                        "content": "Okay, but can we use Stack.........??"
                    },
                    {
                        "username": "MoGHenry",
                        "content": "for anyone who are concern about the unclear description of the instruction, the interviewer is expecting you to ask for a clarify. That\\'s a key points for an interview"
                    },
                    {
                        "username": "seraphsword",
                        "content": "The interviewer would be expecting you to know how parentheses work in math more likely."
                    },
                    {
                        "username": "majdfir4s",
                        "content": "the description is trash and not clear .. need to be updated"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Finally .........\\nGraphs week is over...\\uD83D\\uDE0A"
                    },
                    {
                        "username": "jpmorganchase",
                        "content": "recursion is effecitvely a stack.\n\ncan we do with constant space, linear time, and not modify the input?"
                    },
                    {
                        "username": "kelvin2602",
                        "content": "so I try case \"[{](})\"\\nI attempted to evaluate the case \"{\", and indeed, it resulted in a \"false\" outcome. This outcome aligns with the typical expectation that an opening bracket should be followed by a corresponding closing bracket. However, when an opening bracket is placed within another pair of brackets and the closing bracket for the innermost pair is positioned outside, the result is also \"false.\" This discrepancy occurs because the closing bracket, although appearing outside the inner pair, effectively closes the innermost bracket, making it distinct from the opening bracket outside. In such cases, even though the bracket appears outside, it is still considered a different bracket from the one inside, resulting in an unbalanced configuration."
                    },
                    {
                        "username": "CC_Debjyoti",
                        "content": "Was finally able to solve this question after many hrs using 10 lines of else if\\'s GG :)"
                    }
                ]
            },
            {
                "id": 2059687,
                "content": [
                    {
                        "username": "Alenzy",
                        "content": "This can\\'t be considered \"easy\""
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I am coding the solution in Java and I have an issue for the test 92 : \n\ni have an \"Output Limit Exceeded\" for this case. In this last test the input is : \"s=\" . Thus, there is no intput and i don't know why i have nothing returned.\n\nMoreover, this test doesn't have to exist because in the description it's said that s.length >= 1 . And in this test it's not the case, i would like to know if anybody had the same issue. \n\nI tried to add the case were s is blank, or null, or empty and it deosn't change anything, it looks like my code doesn't even run."
                    },
                    {
                        "username": "demitsuria",
                        "content": "I have the same"
                    },
                    {
                        "username": "idris0himeur",
                        "content": "in the test 68 with s= \"([)]\" , according to the description, the expected result is true, but the actual result is returning false.  ? can someone explain this ?   it seems from the discription that nested parentheses are accepted !"
                    },
                    {
                        "username": "robin_wadekar30",
                        "content": "Okay, but can we use Stack.........??"
                    },
                    {
                        "username": "MoGHenry",
                        "content": "for anyone who are concern about the unclear description of the instruction, the interviewer is expecting you to ask for a clarify. That\\'s a key points for an interview"
                    },
                    {
                        "username": "seraphsword",
                        "content": "The interviewer would be expecting you to know how parentheses work in math more likely."
                    },
                    {
                        "username": "majdfir4s",
                        "content": "the description is trash and not clear .. need to be updated"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Finally .........\\nGraphs week is over...\\uD83D\\uDE0A"
                    },
                    {
                        "username": "jpmorganchase",
                        "content": "recursion is effecitvely a stack.\n\ncan we do with constant space, linear time, and not modify the input?"
                    },
                    {
                        "username": "kelvin2602",
                        "content": "so I try case \"[{](})\"\\nI attempted to evaluate the case \"{\", and indeed, it resulted in a \"false\" outcome. This outcome aligns with the typical expectation that an opening bracket should be followed by a corresponding closing bracket. However, when an opening bracket is placed within another pair of brackets and the closing bracket for the innermost pair is positioned outside, the result is also \"false.\" This discrepancy occurs because the closing bracket, although appearing outside the inner pair, effectively closes the innermost bracket, making it distinct from the opening bracket outside. In such cases, even though the bracket appears outside, it is still considered a different bracket from the one inside, resulting in an unbalanced configuration."
                    },
                    {
                        "username": "CC_Debjyoti",
                        "content": "Was finally able to solve this question after many hrs using 10 lines of else if\\'s GG :)"
                    }
                ]
            },
            {
                "id": 2030527,
                "content": [
                    {
                        "username": "Alenzy",
                        "content": "This can\\'t be considered \"easy\""
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I am coding the solution in Java and I have an issue for the test 92 : \n\ni have an \"Output Limit Exceeded\" for this case. In this last test the input is : \"s=\" . Thus, there is no intput and i don't know why i have nothing returned.\n\nMoreover, this test doesn't have to exist because in the description it's said that s.length >= 1 . And in this test it's not the case, i would like to know if anybody had the same issue. \n\nI tried to add the case were s is blank, or null, or empty and it deosn't change anything, it looks like my code doesn't even run."
                    },
                    {
                        "username": "demitsuria",
                        "content": "I have the same"
                    },
                    {
                        "username": "idris0himeur",
                        "content": "in the test 68 with s= \"([)]\" , according to the description, the expected result is true, but the actual result is returning false.  ? can someone explain this ?   it seems from the discription that nested parentheses are accepted !"
                    },
                    {
                        "username": "robin_wadekar30",
                        "content": "Okay, but can we use Stack.........??"
                    },
                    {
                        "username": "MoGHenry",
                        "content": "for anyone who are concern about the unclear description of the instruction, the interviewer is expecting you to ask for a clarify. That\\'s a key points for an interview"
                    },
                    {
                        "username": "seraphsword",
                        "content": "The interviewer would be expecting you to know how parentheses work in math more likely."
                    },
                    {
                        "username": "majdfir4s",
                        "content": "the description is trash and not clear .. need to be updated"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Finally .........\\nGraphs week is over...\\uD83D\\uDE0A"
                    },
                    {
                        "username": "jpmorganchase",
                        "content": "recursion is effecitvely a stack.\n\ncan we do with constant space, linear time, and not modify the input?"
                    },
                    {
                        "username": "kelvin2602",
                        "content": "so I try case \"[{](})\"\\nI attempted to evaluate the case \"{\", and indeed, it resulted in a \"false\" outcome. This outcome aligns with the typical expectation that an opening bracket should be followed by a corresponding closing bracket. However, when an opening bracket is placed within another pair of brackets and the closing bracket for the innermost pair is positioned outside, the result is also \"false.\" This discrepancy occurs because the closing bracket, although appearing outside the inner pair, effectively closes the innermost bracket, making it distinct from the opening bracket outside. In such cases, even though the bracket appears outside, it is still considered a different bracket from the one inside, resulting in an unbalanced configuration."
                    },
                    {
                        "username": "CC_Debjyoti",
                        "content": "Was finally able to solve this question after many hrs using 10 lines of else if\\'s GG :)"
                    }
                ]
            },
            {
                "id": 1974192,
                "content": [
                    {
                        "username": "pawarsach_n",
                        "content": "how is it wrong ?\\n \\n\"( [ ) ]\"\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "pawarsach_n",
                        "content": "[@joshczipo](/joshczipo) i thought there should be a pair anyhow \\nthanks for support brother "
                    },
                    {
                        "username": "joshczipo",
                        "content": "\"( [ ) ]\" are not valid brackets. The parentheses is being closed by the square bracket. "
                    },
                    {
                        "username": "shivankitsss",
                        "content": "lol. exact same thing im stuck on. "
                    },
                    {
                        "username": "andresmancillavaldez2",
                        "content": "The problem description is very very vague for what it\\'s asking for. "
                    },
                    {
                        "username": "shahvandan19",
                        "content": "would a \"((()))\" string be valid?"
                    },
                    {
                        "username": "tauqeer_04",
                        "content": "yes it will be valid\\n"
                    },
                    {
                        "username": "supahtrupahgames",
                        "content": "It would have been nice to know that nesting is valid. Examples make it seem like every bracket needs to be closed immediately after. "
                    },
                    {
                        "username": "yadavharsha50",
                        "content": " Shortest java code\n   \n    public boolean isValid(String s) {\n        if(s.length()%2!=0) return false;\n        Stack<Character> st=new Stack<Character>();\n        for(int i=0;i<s.length();i++){\n            if(s.charAt(i)==')' || s.charAt(i)=='}' || s.charAt(i)==']'){\n                char c='(';\n                if(s.charAt(i)=='}') c='{';\n                if(s.charAt(i)==']')c='[';\n                if(st.isEmpty() || st.pop()!=c ) return false;\n            }\n            else st.push(s.charAt(i));\n        }\n        return st.isEmpty();\n\n    }"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "This may be an easy category question but it has got good edge testcases."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def isValid(self, s):\\n        for i in range(len(s)):\\n            s = s.replace(\\'{}\\', \\'\\').replace(\\'[]\\', \\'\\').replace(\\'()\\', \\'\\')\\n        return s == \\'\\'\\n```\\nToo easy\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "Navraj88",
                        "content": "Line 61: Char 28: error: expected \\'}\\'\\n#pragma GCC optimize (\"O2\")\\n                           ^\\nLine 1: Char 16: note: to match this \\'{\\'\\nclass Solution {\\n               ^\\n\\ni am getting this error can anybody help"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Can you show me your code?"
                    },
                    {
                        "username": "rohit-1802",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n\\n        if(s.length()%2 != 0) return false;\\n        \\n        Stack<Character> stack = new Stack<>();\\n\\n        for(int i = 0; i < s.length(); i++){\\n            char c = s.charAt(i);\\n\\n            if(c == \\'{\\' || c == \\'(\\' || c == \\'[\\')\\n                stack.push(c);\\n\\n            else if(!stack.empty()){\\n                 if((c == \\']\\' && stack.peek() == \\'[\\') ||(c == \\'}\\' && stack.peek() == \\'{\\') || (c == \\')\\' && stack.peek() == \\'(\\'))\\n                    stack.pop();\\n                else\\n                    stack.push(c);\\n            } \\n            else stack.push(c);\\n        }\\n\\n        if(stack.empty()) return true;\\n        else return false;\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    }
                ]
            },
            {
                "id": 1918399,
                "content": [
                    {
                        "username": "pawarsach_n",
                        "content": "how is it wrong ?\\n \\n\"( [ ) ]\"\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "pawarsach_n",
                        "content": "[@joshczipo](/joshczipo) i thought there should be a pair anyhow \\nthanks for support brother "
                    },
                    {
                        "username": "joshczipo",
                        "content": "\"( [ ) ]\" are not valid brackets. The parentheses is being closed by the square bracket. "
                    },
                    {
                        "username": "shivankitsss",
                        "content": "lol. exact same thing im stuck on. "
                    },
                    {
                        "username": "andresmancillavaldez2",
                        "content": "The problem description is very very vague for what it\\'s asking for. "
                    },
                    {
                        "username": "shahvandan19",
                        "content": "would a \"((()))\" string be valid?"
                    },
                    {
                        "username": "tauqeer_04",
                        "content": "yes it will be valid\\n"
                    },
                    {
                        "username": "supahtrupahgames",
                        "content": "It would have been nice to know that nesting is valid. Examples make it seem like every bracket needs to be closed immediately after. "
                    },
                    {
                        "username": "yadavharsha50",
                        "content": " Shortest java code\n   \n    public boolean isValid(String s) {\n        if(s.length()%2!=0) return false;\n        Stack<Character> st=new Stack<Character>();\n        for(int i=0;i<s.length();i++){\n            if(s.charAt(i)==')' || s.charAt(i)=='}' || s.charAt(i)==']'){\n                char c='(';\n                if(s.charAt(i)=='}') c='{';\n                if(s.charAt(i)==']')c='[';\n                if(st.isEmpty() || st.pop()!=c ) return false;\n            }\n            else st.push(s.charAt(i));\n        }\n        return st.isEmpty();\n\n    }"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "This may be an easy category question but it has got good edge testcases."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def isValid(self, s):\\n        for i in range(len(s)):\\n            s = s.replace(\\'{}\\', \\'\\').replace(\\'[]\\', \\'\\').replace(\\'()\\', \\'\\')\\n        return s == \\'\\'\\n```\\nToo easy\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "Navraj88",
                        "content": "Line 61: Char 28: error: expected \\'}\\'\\n#pragma GCC optimize (\"O2\")\\n                           ^\\nLine 1: Char 16: note: to match this \\'{\\'\\nclass Solution {\\n               ^\\n\\ni am getting this error can anybody help"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Can you show me your code?"
                    },
                    {
                        "username": "rohit-1802",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n\\n        if(s.length()%2 != 0) return false;\\n        \\n        Stack<Character> stack = new Stack<>();\\n\\n        for(int i = 0; i < s.length(); i++){\\n            char c = s.charAt(i);\\n\\n            if(c == \\'{\\' || c == \\'(\\' || c == \\'[\\')\\n                stack.push(c);\\n\\n            else if(!stack.empty()){\\n                 if((c == \\']\\' && stack.peek() == \\'[\\') ||(c == \\'}\\' && stack.peek() == \\'{\\') || (c == \\')\\' && stack.peek() == \\'(\\'))\\n                    stack.pop();\\n                else\\n                    stack.push(c);\\n            } \\n            else stack.push(c);\\n        }\\n\\n        if(stack.empty()) return true;\\n        else return false;\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    }
                ]
            },
            {
                "id": 1880366,
                "content": [
                    {
                        "username": "pawarsach_n",
                        "content": "how is it wrong ?\\n \\n\"( [ ) ]\"\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "pawarsach_n",
                        "content": "[@joshczipo](/joshczipo) i thought there should be a pair anyhow \\nthanks for support brother "
                    },
                    {
                        "username": "joshczipo",
                        "content": "\"( [ ) ]\" are not valid brackets. The parentheses is being closed by the square bracket. "
                    },
                    {
                        "username": "shivankitsss",
                        "content": "lol. exact same thing im stuck on. "
                    },
                    {
                        "username": "andresmancillavaldez2",
                        "content": "The problem description is very very vague for what it\\'s asking for. "
                    },
                    {
                        "username": "shahvandan19",
                        "content": "would a \"((()))\" string be valid?"
                    },
                    {
                        "username": "tauqeer_04",
                        "content": "yes it will be valid\\n"
                    },
                    {
                        "username": "supahtrupahgames",
                        "content": "It would have been nice to know that nesting is valid. Examples make it seem like every bracket needs to be closed immediately after. "
                    },
                    {
                        "username": "yadavharsha50",
                        "content": " Shortest java code\n   \n    public boolean isValid(String s) {\n        if(s.length()%2!=0) return false;\n        Stack<Character> st=new Stack<Character>();\n        for(int i=0;i<s.length();i++){\n            if(s.charAt(i)==')' || s.charAt(i)=='}' || s.charAt(i)==']'){\n                char c='(';\n                if(s.charAt(i)=='}') c='{';\n                if(s.charAt(i)==']')c='[';\n                if(st.isEmpty() || st.pop()!=c ) return false;\n            }\n            else st.push(s.charAt(i));\n        }\n        return st.isEmpty();\n\n    }"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "This may be an easy category question but it has got good edge testcases."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def isValid(self, s):\\n        for i in range(len(s)):\\n            s = s.replace(\\'{}\\', \\'\\').replace(\\'[]\\', \\'\\').replace(\\'()\\', \\'\\')\\n        return s == \\'\\'\\n```\\nToo easy\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "Navraj88",
                        "content": "Line 61: Char 28: error: expected \\'}\\'\\n#pragma GCC optimize (\"O2\")\\n                           ^\\nLine 1: Char 16: note: to match this \\'{\\'\\nclass Solution {\\n               ^\\n\\ni am getting this error can anybody help"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Can you show me your code?"
                    },
                    {
                        "username": "rohit-1802",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n\\n        if(s.length()%2 != 0) return false;\\n        \\n        Stack<Character> stack = new Stack<>();\\n\\n        for(int i = 0; i < s.length(); i++){\\n            char c = s.charAt(i);\\n\\n            if(c == \\'{\\' || c == \\'(\\' || c == \\'[\\')\\n                stack.push(c);\\n\\n            else if(!stack.empty()){\\n                 if((c == \\']\\' && stack.peek() == \\'[\\') ||(c == \\'}\\' && stack.peek() == \\'{\\') || (c == \\')\\' && stack.peek() == \\'(\\'))\\n                    stack.pop();\\n                else\\n                    stack.push(c);\\n            } \\n            else stack.push(c);\\n        }\\n\\n        if(stack.empty()) return true;\\n        else return false;\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    }
                ]
            },
            {
                "id": 1867633,
                "content": [
                    {
                        "username": "pawarsach_n",
                        "content": "how is it wrong ?\\n \\n\"( [ ) ]\"\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "pawarsach_n",
                        "content": "[@joshczipo](/joshczipo) i thought there should be a pair anyhow \\nthanks for support brother "
                    },
                    {
                        "username": "joshczipo",
                        "content": "\"( [ ) ]\" are not valid brackets. The parentheses is being closed by the square bracket. "
                    },
                    {
                        "username": "shivankitsss",
                        "content": "lol. exact same thing im stuck on. "
                    },
                    {
                        "username": "andresmancillavaldez2",
                        "content": "The problem description is very very vague for what it\\'s asking for. "
                    },
                    {
                        "username": "shahvandan19",
                        "content": "would a \"((()))\" string be valid?"
                    },
                    {
                        "username": "tauqeer_04",
                        "content": "yes it will be valid\\n"
                    },
                    {
                        "username": "supahtrupahgames",
                        "content": "It would have been nice to know that nesting is valid. Examples make it seem like every bracket needs to be closed immediately after. "
                    },
                    {
                        "username": "yadavharsha50",
                        "content": " Shortest java code\n   \n    public boolean isValid(String s) {\n        if(s.length()%2!=0) return false;\n        Stack<Character> st=new Stack<Character>();\n        for(int i=0;i<s.length();i++){\n            if(s.charAt(i)==')' || s.charAt(i)=='}' || s.charAt(i)==']'){\n                char c='(';\n                if(s.charAt(i)=='}') c='{';\n                if(s.charAt(i)==']')c='[';\n                if(st.isEmpty() || st.pop()!=c ) return false;\n            }\n            else st.push(s.charAt(i));\n        }\n        return st.isEmpty();\n\n    }"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "This may be an easy category question but it has got good edge testcases."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def isValid(self, s):\\n        for i in range(len(s)):\\n            s = s.replace(\\'{}\\', \\'\\').replace(\\'[]\\', \\'\\').replace(\\'()\\', \\'\\')\\n        return s == \\'\\'\\n```\\nToo easy\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "Navraj88",
                        "content": "Line 61: Char 28: error: expected \\'}\\'\\n#pragma GCC optimize (\"O2\")\\n                           ^\\nLine 1: Char 16: note: to match this \\'{\\'\\nclass Solution {\\n               ^\\n\\ni am getting this error can anybody help"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Can you show me your code?"
                    },
                    {
                        "username": "rohit-1802",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n\\n        if(s.length()%2 != 0) return false;\\n        \\n        Stack<Character> stack = new Stack<>();\\n\\n        for(int i = 0; i < s.length(); i++){\\n            char c = s.charAt(i);\\n\\n            if(c == \\'{\\' || c == \\'(\\' || c == \\'[\\')\\n                stack.push(c);\\n\\n            else if(!stack.empty()){\\n                 if((c == \\']\\' && stack.peek() == \\'[\\') ||(c == \\'}\\' && stack.peek() == \\'{\\') || (c == \\')\\' && stack.peek() == \\'(\\'))\\n                    stack.pop();\\n                else\\n                    stack.push(c);\\n            } \\n            else stack.push(c);\\n        }\\n\\n        if(stack.empty()) return true;\\n        else return false;\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    }
                ]
            },
            {
                "id": 1859135,
                "content": [
                    {
                        "username": "pawarsach_n",
                        "content": "how is it wrong ?\\n \\n\"( [ ) ]\"\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "pawarsach_n",
                        "content": "[@joshczipo](/joshczipo) i thought there should be a pair anyhow \\nthanks for support brother "
                    },
                    {
                        "username": "joshczipo",
                        "content": "\"( [ ) ]\" are not valid brackets. The parentheses is being closed by the square bracket. "
                    },
                    {
                        "username": "shivankitsss",
                        "content": "lol. exact same thing im stuck on. "
                    },
                    {
                        "username": "andresmancillavaldez2",
                        "content": "The problem description is very very vague for what it\\'s asking for. "
                    },
                    {
                        "username": "shahvandan19",
                        "content": "would a \"((()))\" string be valid?"
                    },
                    {
                        "username": "tauqeer_04",
                        "content": "yes it will be valid\\n"
                    },
                    {
                        "username": "supahtrupahgames",
                        "content": "It would have been nice to know that nesting is valid. Examples make it seem like every bracket needs to be closed immediately after. "
                    },
                    {
                        "username": "yadavharsha50",
                        "content": " Shortest java code\n   \n    public boolean isValid(String s) {\n        if(s.length()%2!=0) return false;\n        Stack<Character> st=new Stack<Character>();\n        for(int i=0;i<s.length();i++){\n            if(s.charAt(i)==')' || s.charAt(i)=='}' || s.charAt(i)==']'){\n                char c='(';\n                if(s.charAt(i)=='}') c='{';\n                if(s.charAt(i)==']')c='[';\n                if(st.isEmpty() || st.pop()!=c ) return false;\n            }\n            else st.push(s.charAt(i));\n        }\n        return st.isEmpty();\n\n    }"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "This may be an easy category question but it has got good edge testcases."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def isValid(self, s):\\n        for i in range(len(s)):\\n            s = s.replace(\\'{}\\', \\'\\').replace(\\'[]\\', \\'\\').replace(\\'()\\', \\'\\')\\n        return s == \\'\\'\\n```\\nToo easy\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "Navraj88",
                        "content": "Line 61: Char 28: error: expected \\'}\\'\\n#pragma GCC optimize (\"O2\")\\n                           ^\\nLine 1: Char 16: note: to match this \\'{\\'\\nclass Solution {\\n               ^\\n\\ni am getting this error can anybody help"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Can you show me your code?"
                    },
                    {
                        "username": "rohit-1802",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n\\n        if(s.length()%2 != 0) return false;\\n        \\n        Stack<Character> stack = new Stack<>();\\n\\n        for(int i = 0; i < s.length(); i++){\\n            char c = s.charAt(i);\\n\\n            if(c == \\'{\\' || c == \\'(\\' || c == \\'[\\')\\n                stack.push(c);\\n\\n            else if(!stack.empty()){\\n                 if((c == \\']\\' && stack.peek() == \\'[\\') ||(c == \\'}\\' && stack.peek() == \\'{\\') || (c == \\')\\' && stack.peek() == \\'(\\'))\\n                    stack.pop();\\n                else\\n                    stack.push(c);\\n            } \\n            else stack.push(c);\\n        }\\n\\n        if(stack.empty()) return true;\\n        else return false;\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    }
                ]
            },
            {
                "id": 1858908,
                "content": [
                    {
                        "username": "pawarsach_n",
                        "content": "how is it wrong ?\\n \\n\"( [ ) ]\"\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "pawarsach_n",
                        "content": "[@joshczipo](/joshczipo) i thought there should be a pair anyhow \\nthanks for support brother "
                    },
                    {
                        "username": "joshczipo",
                        "content": "\"( [ ) ]\" are not valid brackets. The parentheses is being closed by the square bracket. "
                    },
                    {
                        "username": "shivankitsss",
                        "content": "lol. exact same thing im stuck on. "
                    },
                    {
                        "username": "andresmancillavaldez2",
                        "content": "The problem description is very very vague for what it\\'s asking for. "
                    },
                    {
                        "username": "shahvandan19",
                        "content": "would a \"((()))\" string be valid?"
                    },
                    {
                        "username": "tauqeer_04",
                        "content": "yes it will be valid\\n"
                    },
                    {
                        "username": "supahtrupahgames",
                        "content": "It would have been nice to know that nesting is valid. Examples make it seem like every bracket needs to be closed immediately after. "
                    },
                    {
                        "username": "yadavharsha50",
                        "content": " Shortest java code\n   \n    public boolean isValid(String s) {\n        if(s.length()%2!=0) return false;\n        Stack<Character> st=new Stack<Character>();\n        for(int i=0;i<s.length();i++){\n            if(s.charAt(i)==')' || s.charAt(i)=='}' || s.charAt(i)==']'){\n                char c='(';\n                if(s.charAt(i)=='}') c='{';\n                if(s.charAt(i)==']')c='[';\n                if(st.isEmpty() || st.pop()!=c ) return false;\n            }\n            else st.push(s.charAt(i));\n        }\n        return st.isEmpty();\n\n    }"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "This may be an easy category question but it has got good edge testcases."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def isValid(self, s):\\n        for i in range(len(s)):\\n            s = s.replace(\\'{}\\', \\'\\').replace(\\'[]\\', \\'\\').replace(\\'()\\', \\'\\')\\n        return s == \\'\\'\\n```\\nToo easy\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "Navraj88",
                        "content": "Line 61: Char 28: error: expected \\'}\\'\\n#pragma GCC optimize (\"O2\")\\n                           ^\\nLine 1: Char 16: note: to match this \\'{\\'\\nclass Solution {\\n               ^\\n\\ni am getting this error can anybody help"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Can you show me your code?"
                    },
                    {
                        "username": "rohit-1802",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n\\n        if(s.length()%2 != 0) return false;\\n        \\n        Stack<Character> stack = new Stack<>();\\n\\n        for(int i = 0; i < s.length(); i++){\\n            char c = s.charAt(i);\\n\\n            if(c == \\'{\\' || c == \\'(\\' || c == \\'[\\')\\n                stack.push(c);\\n\\n            else if(!stack.empty()){\\n                 if((c == \\']\\' && stack.peek() == \\'[\\') ||(c == \\'}\\' && stack.peek() == \\'{\\') || (c == \\')\\' && stack.peek() == \\'(\\'))\\n                    stack.pop();\\n                else\\n                    stack.push(c);\\n            } \\n            else stack.push(c);\\n        }\\n\\n        if(stack.empty()) return true;\\n        else return false;\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    }
                ]
            },
            {
                "id": 1857633,
                "content": [
                    {
                        "username": "pawarsach_n",
                        "content": "how is it wrong ?\\n \\n\"( [ ) ]\"\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "pawarsach_n",
                        "content": "[@joshczipo](/joshczipo) i thought there should be a pair anyhow \\nthanks for support brother "
                    },
                    {
                        "username": "joshczipo",
                        "content": "\"( [ ) ]\" are not valid brackets. The parentheses is being closed by the square bracket. "
                    },
                    {
                        "username": "shivankitsss",
                        "content": "lol. exact same thing im stuck on. "
                    },
                    {
                        "username": "andresmancillavaldez2",
                        "content": "The problem description is very very vague for what it\\'s asking for. "
                    },
                    {
                        "username": "shahvandan19",
                        "content": "would a \"((()))\" string be valid?"
                    },
                    {
                        "username": "tauqeer_04",
                        "content": "yes it will be valid\\n"
                    },
                    {
                        "username": "supahtrupahgames",
                        "content": "It would have been nice to know that nesting is valid. Examples make it seem like every bracket needs to be closed immediately after. "
                    },
                    {
                        "username": "yadavharsha50",
                        "content": " Shortest java code\n   \n    public boolean isValid(String s) {\n        if(s.length()%2!=0) return false;\n        Stack<Character> st=new Stack<Character>();\n        for(int i=0;i<s.length();i++){\n            if(s.charAt(i)==')' || s.charAt(i)=='}' || s.charAt(i)==']'){\n                char c='(';\n                if(s.charAt(i)=='}') c='{';\n                if(s.charAt(i)==']')c='[';\n                if(st.isEmpty() || st.pop()!=c ) return false;\n            }\n            else st.push(s.charAt(i));\n        }\n        return st.isEmpty();\n\n    }"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "This may be an easy category question but it has got good edge testcases."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def isValid(self, s):\\n        for i in range(len(s)):\\n            s = s.replace(\\'{}\\', \\'\\').replace(\\'[]\\', \\'\\').replace(\\'()\\', \\'\\')\\n        return s == \\'\\'\\n```\\nToo easy\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "Navraj88",
                        "content": "Line 61: Char 28: error: expected \\'}\\'\\n#pragma GCC optimize (\"O2\")\\n                           ^\\nLine 1: Char 16: note: to match this \\'{\\'\\nclass Solution {\\n               ^\\n\\ni am getting this error can anybody help"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Can you show me your code?"
                    },
                    {
                        "username": "rohit-1802",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n\\n        if(s.length()%2 != 0) return false;\\n        \\n        Stack<Character> stack = new Stack<>();\\n\\n        for(int i = 0; i < s.length(); i++){\\n            char c = s.charAt(i);\\n\\n            if(c == \\'{\\' || c == \\'(\\' || c == \\'[\\')\\n                stack.push(c);\\n\\n            else if(!stack.empty()){\\n                 if((c == \\']\\' && stack.peek() == \\'[\\') ||(c == \\'}\\' && stack.peek() == \\'{\\') || (c == \\')\\' && stack.peek() == \\'(\\'))\\n                    stack.pop();\\n                else\\n                    stack.push(c);\\n            } \\n            else stack.push(c);\\n        }\\n\\n        if(stack.empty()) return true;\\n        else return false;\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    }
                ]
            },
            {
                "id": 1781992,
                "content": [
                    {
                        "username": "pawarsach_n",
                        "content": "how is it wrong ?\\n \\n\"( [ ) ]\"\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "pawarsach_n",
                        "content": "[@joshczipo](/joshczipo) i thought there should be a pair anyhow \\nthanks for support brother "
                    },
                    {
                        "username": "joshczipo",
                        "content": "\"( [ ) ]\" are not valid brackets. The parentheses is being closed by the square bracket. "
                    },
                    {
                        "username": "shivankitsss",
                        "content": "lol. exact same thing im stuck on. "
                    },
                    {
                        "username": "andresmancillavaldez2",
                        "content": "The problem description is very very vague for what it\\'s asking for. "
                    },
                    {
                        "username": "shahvandan19",
                        "content": "would a \"((()))\" string be valid?"
                    },
                    {
                        "username": "tauqeer_04",
                        "content": "yes it will be valid\\n"
                    },
                    {
                        "username": "supahtrupahgames",
                        "content": "It would have been nice to know that nesting is valid. Examples make it seem like every bracket needs to be closed immediately after. "
                    },
                    {
                        "username": "yadavharsha50",
                        "content": " Shortest java code\n   \n    public boolean isValid(String s) {\n        if(s.length()%2!=0) return false;\n        Stack<Character> st=new Stack<Character>();\n        for(int i=0;i<s.length();i++){\n            if(s.charAt(i)==')' || s.charAt(i)=='}' || s.charAt(i)==']'){\n                char c='(';\n                if(s.charAt(i)=='}') c='{';\n                if(s.charAt(i)==']')c='[';\n                if(st.isEmpty() || st.pop()!=c ) return false;\n            }\n            else st.push(s.charAt(i));\n        }\n        return st.isEmpty();\n\n    }"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "This may be an easy category question but it has got good edge testcases."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def isValid(self, s):\\n        for i in range(len(s)):\\n            s = s.replace(\\'{}\\', \\'\\').replace(\\'[]\\', \\'\\').replace(\\'()\\', \\'\\')\\n        return s == \\'\\'\\n```\\nToo easy\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "Navraj88",
                        "content": "Line 61: Char 28: error: expected \\'}\\'\\n#pragma GCC optimize (\"O2\")\\n                           ^\\nLine 1: Char 16: note: to match this \\'{\\'\\nclass Solution {\\n               ^\\n\\ni am getting this error can anybody help"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Can you show me your code?"
                    },
                    {
                        "username": "rohit-1802",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n\\n        if(s.length()%2 != 0) return false;\\n        \\n        Stack<Character> stack = new Stack<>();\\n\\n        for(int i = 0; i < s.length(); i++){\\n            char c = s.charAt(i);\\n\\n            if(c == \\'{\\' || c == \\'(\\' || c == \\'[\\')\\n                stack.push(c);\\n\\n            else if(!stack.empty()){\\n                 if((c == \\']\\' && stack.peek() == \\'[\\') ||(c == \\'}\\' && stack.peek() == \\'{\\') || (c == \\')\\' && stack.peek() == \\'(\\'))\\n                    stack.pop();\\n                else\\n                    stack.push(c);\\n            } \\n            else stack.push(c);\\n        }\\n\\n        if(stack.empty()) return true;\\n        else return false;\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    }
                ]
            },
            {
                "id": 1766861,
                "content": [
                    {
                        "username": "pawarsach_n",
                        "content": "how is it wrong ?\\n \\n\"( [ ) ]\"\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "pawarsach_n",
                        "content": "[@joshczipo](/joshczipo) i thought there should be a pair anyhow \\nthanks for support brother "
                    },
                    {
                        "username": "joshczipo",
                        "content": "\"( [ ) ]\" are not valid brackets. The parentheses is being closed by the square bracket. "
                    },
                    {
                        "username": "shivankitsss",
                        "content": "lol. exact same thing im stuck on. "
                    },
                    {
                        "username": "andresmancillavaldez2",
                        "content": "The problem description is very very vague for what it\\'s asking for. "
                    },
                    {
                        "username": "shahvandan19",
                        "content": "would a \"((()))\" string be valid?"
                    },
                    {
                        "username": "tauqeer_04",
                        "content": "yes it will be valid\\n"
                    },
                    {
                        "username": "supahtrupahgames",
                        "content": "It would have been nice to know that nesting is valid. Examples make it seem like every bracket needs to be closed immediately after. "
                    },
                    {
                        "username": "yadavharsha50",
                        "content": " Shortest java code\n   \n    public boolean isValid(String s) {\n        if(s.length()%2!=0) return false;\n        Stack<Character> st=new Stack<Character>();\n        for(int i=0;i<s.length();i++){\n            if(s.charAt(i)==')' || s.charAt(i)=='}' || s.charAt(i)==']'){\n                char c='(';\n                if(s.charAt(i)=='}') c='{';\n                if(s.charAt(i)==']')c='[';\n                if(st.isEmpty() || st.pop()!=c ) return false;\n            }\n            else st.push(s.charAt(i));\n        }\n        return st.isEmpty();\n\n    }"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "This may be an easy category question but it has got good edge testcases."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def isValid(self, s):\\n        for i in range(len(s)):\\n            s = s.replace(\\'{}\\', \\'\\').replace(\\'[]\\', \\'\\').replace(\\'()\\', \\'\\')\\n        return s == \\'\\'\\n```\\nToo easy\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "Navraj88",
                        "content": "Line 61: Char 28: error: expected \\'}\\'\\n#pragma GCC optimize (\"O2\")\\n                           ^\\nLine 1: Char 16: note: to match this \\'{\\'\\nclass Solution {\\n               ^\\n\\ni am getting this error can anybody help"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Can you show me your code?"
                    },
                    {
                        "username": "rohit-1802",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n\\n        if(s.length()%2 != 0) return false;\\n        \\n        Stack<Character> stack = new Stack<>();\\n\\n        for(int i = 0; i < s.length(); i++){\\n            char c = s.charAt(i);\\n\\n            if(c == \\'{\\' || c == \\'(\\' || c == \\'[\\')\\n                stack.push(c);\\n\\n            else if(!stack.empty()){\\n                 if((c == \\']\\' && stack.peek() == \\'[\\') ||(c == \\'}\\' && stack.peek() == \\'{\\') || (c == \\')\\' && stack.peek() == \\'(\\'))\\n                    stack.pop();\\n                else\\n                    stack.push(c);\\n            } \\n            else stack.push(c);\\n        }\\n\\n        if(stack.empty()) return true;\\n        else return false;\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    }
                ]
            },
            {
                "id": 1716134,
                "content": [
                    {
                        "username": "pawarsach_n",
                        "content": "how is it wrong ?\\n \\n\"( [ ) ]\"\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "pawarsach_n",
                        "content": "[@joshczipo](/joshczipo) i thought there should be a pair anyhow \\nthanks for support brother "
                    },
                    {
                        "username": "joshczipo",
                        "content": "\"( [ ) ]\" are not valid brackets. The parentheses is being closed by the square bracket. "
                    },
                    {
                        "username": "shivankitsss",
                        "content": "lol. exact same thing im stuck on. "
                    },
                    {
                        "username": "andresmancillavaldez2",
                        "content": "The problem description is very very vague for what it\\'s asking for. "
                    },
                    {
                        "username": "shahvandan19",
                        "content": "would a \"((()))\" string be valid?"
                    },
                    {
                        "username": "tauqeer_04",
                        "content": "yes it will be valid\\n"
                    },
                    {
                        "username": "supahtrupahgames",
                        "content": "It would have been nice to know that nesting is valid. Examples make it seem like every bracket needs to be closed immediately after. "
                    },
                    {
                        "username": "yadavharsha50",
                        "content": " Shortest java code\n   \n    public boolean isValid(String s) {\n        if(s.length()%2!=0) return false;\n        Stack<Character> st=new Stack<Character>();\n        for(int i=0;i<s.length();i++){\n            if(s.charAt(i)==')' || s.charAt(i)=='}' || s.charAt(i)==']'){\n                char c='(';\n                if(s.charAt(i)=='}') c='{';\n                if(s.charAt(i)==']')c='[';\n                if(st.isEmpty() || st.pop()!=c ) return false;\n            }\n            else st.push(s.charAt(i));\n        }\n        return st.isEmpty();\n\n    }"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "This may be an easy category question but it has got good edge testcases."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def isValid(self, s):\\n        for i in range(len(s)):\\n            s = s.replace(\\'{}\\', \\'\\').replace(\\'[]\\', \\'\\').replace(\\'()\\', \\'\\')\\n        return s == \\'\\'\\n```\\nToo easy\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "Navraj88",
                        "content": "Line 61: Char 28: error: expected \\'}\\'\\n#pragma GCC optimize (\"O2\")\\n                           ^\\nLine 1: Char 16: note: to match this \\'{\\'\\nclass Solution {\\n               ^\\n\\ni am getting this error can anybody help"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Can you show me your code?"
                    },
                    {
                        "username": "rohit-1802",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n\\n        if(s.length()%2 != 0) return false;\\n        \\n        Stack<Character> stack = new Stack<>();\\n\\n        for(int i = 0; i < s.length(); i++){\\n            char c = s.charAt(i);\\n\\n            if(c == \\'{\\' || c == \\'(\\' || c == \\'[\\')\\n                stack.push(c);\\n\\n            else if(!stack.empty()){\\n                 if((c == \\']\\' && stack.peek() == \\'[\\') ||(c == \\'}\\' && stack.peek() == \\'{\\') || (c == \\')\\' && stack.peek() == \\'(\\'))\\n                    stack.pop();\\n                else\\n                    stack.push(c);\\n            } \\n            else stack.push(c);\\n        }\\n\\n        if(stack.empty()) return true;\\n        else return false;\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDF55Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/valid-parentheses/solutions/2910499/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    }
                ]
            },
            {
                "id": 1576978,
                "content": [
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-parentheses-leet-code-20/"
                    },
                    {
                        "username": "mrmitty",
                        "content": "I\\'ve read that JP Morgan uses `standard input` in their coding challenges. I previously have not any experience with this as I\\'ve only used `input()` while working in Jupyter Notebook. Also, here on LeetCode and on HackerRank, when we\\'re given inputs, they\\'re already in the correct format, i.e, a string is already a string and a list is already a list. \\n\\nSo, for this particular problem: \\nhttps://leetcode.com/problems/valid-parentheses/ \\n\\nWould the input be delivered on a line like so:\\n`\\'{\\', \\'[\\', \\'(\\', \\')\\', \\']\\', \\'}\\'`\\n\\nAnd then we would have to manipulate this input and hold it in a string? \\n\\n`s = {[()]}`\\n\\nOr would it actually be given to us a string?"
                    },
                    {
                        "username": "Sebasking",
                        "content": "![image](https://assets.leetcode.com/users/images/101a101f-8a9d-4b38-a2c8-52af7cfe1cae_1597707420.5028722.png)\\n\\nPasses test case but fails same case on submission"
                    },
                    {
                        "username": "mokod",
                        "content": "Re: [0ms C language solution with a simple stack](/topic/14505/0ms-c-language-solution-with-a-simple-stack)"
                    },
                    {
                        "username": "ayuanx",
                        "content": "You either have to use some extra O(n) space like a stack, or have to use the space originally occupied by the string itself, which is also O(n).\\nIn the latter method, the string itself is destroyed in the process though.\\n\\nI can use crypto hash to mimic O(1) space complexity, but there will always be collisions (even though rarely, and needs careful construction) that can give out incorrect result."
                    },
                    {
                        "username": "eggMan282",
                        "content": "// this is a basic solution that everyone could understand"
                    },
                    {
                        "username": "ggzd",
                        "content": "good problem"
                    },
                    {
                        "username": "Aadrika_Srivastava",
                        "content": "my test cases are passed but its giving  runtime error during the submission"
                    },
                    {
                        "username": "donggyun",
                        "content": "The description should add one rule, \\'the brackets should be closed right after they are open. For example, when the input is \\'[{}]\\', then the output should be False\\'"
                    },
                    {
                        "username": "WaqasAhmed123",
                        "content": "In simplest words:\\nit says that what comes in last must removes first."
                    }
                ]
            },
            {
                "id": 1574679,
                "content": [
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-parentheses-leet-code-20/"
                    },
                    {
                        "username": "mrmitty",
                        "content": "I\\'ve read that JP Morgan uses `standard input` in their coding challenges. I previously have not any experience with this as I\\'ve only used `input()` while working in Jupyter Notebook. Also, here on LeetCode and on HackerRank, when we\\'re given inputs, they\\'re already in the correct format, i.e, a string is already a string and a list is already a list. \\n\\nSo, for this particular problem: \\nhttps://leetcode.com/problems/valid-parentheses/ \\n\\nWould the input be delivered on a line like so:\\n`\\'{\\', \\'[\\', \\'(\\', \\')\\', \\']\\', \\'}\\'`\\n\\nAnd then we would have to manipulate this input and hold it in a string? \\n\\n`s = {[()]}`\\n\\nOr would it actually be given to us a string?"
                    },
                    {
                        "username": "Sebasking",
                        "content": "![image](https://assets.leetcode.com/users/images/101a101f-8a9d-4b38-a2c8-52af7cfe1cae_1597707420.5028722.png)\\n\\nPasses test case but fails same case on submission"
                    },
                    {
                        "username": "mokod",
                        "content": "Re: [0ms C language solution with a simple stack](/topic/14505/0ms-c-language-solution-with-a-simple-stack)"
                    },
                    {
                        "username": "ayuanx",
                        "content": "You either have to use some extra O(n) space like a stack, or have to use the space originally occupied by the string itself, which is also O(n).\\nIn the latter method, the string itself is destroyed in the process though.\\n\\nI can use crypto hash to mimic O(1) space complexity, but there will always be collisions (even though rarely, and needs careful construction) that can give out incorrect result."
                    },
                    {
                        "username": "eggMan282",
                        "content": "// this is a basic solution that everyone could understand"
                    },
                    {
                        "username": "ggzd",
                        "content": "good problem"
                    },
                    {
                        "username": "Aadrika_Srivastava",
                        "content": "my test cases are passed but its giving  runtime error during the submission"
                    },
                    {
                        "username": "donggyun",
                        "content": "The description should add one rule, \\'the brackets should be closed right after they are open. For example, when the input is \\'[{}]\\', then the output should be False\\'"
                    },
                    {
                        "username": "WaqasAhmed123",
                        "content": "In simplest words:\\nit says that what comes in last must removes first."
                    }
                ]
            },
            {
                "id": 1574234,
                "content": [
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-parentheses-leet-code-20/"
                    },
                    {
                        "username": "mrmitty",
                        "content": "I\\'ve read that JP Morgan uses `standard input` in their coding challenges. I previously have not any experience with this as I\\'ve only used `input()` while working in Jupyter Notebook. Also, here on LeetCode and on HackerRank, when we\\'re given inputs, they\\'re already in the correct format, i.e, a string is already a string and a list is already a list. \\n\\nSo, for this particular problem: \\nhttps://leetcode.com/problems/valid-parentheses/ \\n\\nWould the input be delivered on a line like so:\\n`\\'{\\', \\'[\\', \\'(\\', \\')\\', \\']\\', \\'}\\'`\\n\\nAnd then we would have to manipulate this input and hold it in a string? \\n\\n`s = {[()]}`\\n\\nOr would it actually be given to us a string?"
                    },
                    {
                        "username": "Sebasking",
                        "content": "![image](https://assets.leetcode.com/users/images/101a101f-8a9d-4b38-a2c8-52af7cfe1cae_1597707420.5028722.png)\\n\\nPasses test case but fails same case on submission"
                    },
                    {
                        "username": "mokod",
                        "content": "Re: [0ms C language solution with a simple stack](/topic/14505/0ms-c-language-solution-with-a-simple-stack)"
                    },
                    {
                        "username": "ayuanx",
                        "content": "You either have to use some extra O(n) space like a stack, or have to use the space originally occupied by the string itself, which is also O(n).\\nIn the latter method, the string itself is destroyed in the process though.\\n\\nI can use crypto hash to mimic O(1) space complexity, but there will always be collisions (even though rarely, and needs careful construction) that can give out incorrect result."
                    },
                    {
                        "username": "eggMan282",
                        "content": "// this is a basic solution that everyone could understand"
                    },
                    {
                        "username": "ggzd",
                        "content": "good problem"
                    },
                    {
                        "username": "Aadrika_Srivastava",
                        "content": "my test cases are passed but its giving  runtime error during the submission"
                    },
                    {
                        "username": "donggyun",
                        "content": "The description should add one rule, \\'the brackets should be closed right after they are open. For example, when the input is \\'[{}]\\', then the output should be False\\'"
                    },
                    {
                        "username": "WaqasAhmed123",
                        "content": "In simplest words:\\nit says that what comes in last must removes first."
                    }
                ]
            },
            {
                "id": 1571050,
                "content": [
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-parentheses-leet-code-20/"
                    },
                    {
                        "username": "mrmitty",
                        "content": "I\\'ve read that JP Morgan uses `standard input` in their coding challenges. I previously have not any experience with this as I\\'ve only used `input()` while working in Jupyter Notebook. Also, here on LeetCode and on HackerRank, when we\\'re given inputs, they\\'re already in the correct format, i.e, a string is already a string and a list is already a list. \\n\\nSo, for this particular problem: \\nhttps://leetcode.com/problems/valid-parentheses/ \\n\\nWould the input be delivered on a line like so:\\n`\\'{\\', \\'[\\', \\'(\\', \\')\\', \\']\\', \\'}\\'`\\n\\nAnd then we would have to manipulate this input and hold it in a string? \\n\\n`s = {[()]}`\\n\\nOr would it actually be given to us a string?"
                    },
                    {
                        "username": "Sebasking",
                        "content": "![image](https://assets.leetcode.com/users/images/101a101f-8a9d-4b38-a2c8-52af7cfe1cae_1597707420.5028722.png)\\n\\nPasses test case but fails same case on submission"
                    },
                    {
                        "username": "mokod",
                        "content": "Re: [0ms C language solution with a simple stack](/topic/14505/0ms-c-language-solution-with-a-simple-stack)"
                    },
                    {
                        "username": "ayuanx",
                        "content": "You either have to use some extra O(n) space like a stack, or have to use the space originally occupied by the string itself, which is also O(n).\\nIn the latter method, the string itself is destroyed in the process though.\\n\\nI can use crypto hash to mimic O(1) space complexity, but there will always be collisions (even though rarely, and needs careful construction) that can give out incorrect result."
                    },
                    {
                        "username": "eggMan282",
                        "content": "// this is a basic solution that everyone could understand"
                    },
                    {
                        "username": "ggzd",
                        "content": "good problem"
                    },
                    {
                        "username": "Aadrika_Srivastava",
                        "content": "my test cases are passed but its giving  runtime error during the submission"
                    },
                    {
                        "username": "donggyun",
                        "content": "The description should add one rule, \\'the brackets should be closed right after they are open. For example, when the input is \\'[{}]\\', then the output should be False\\'"
                    },
                    {
                        "username": "WaqasAhmed123",
                        "content": "In simplest words:\\nit says that what comes in last must removes first."
                    }
                ]
            },
            {
                "id": 1571053,
                "content": [
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-parentheses-leet-code-20/"
                    },
                    {
                        "username": "mrmitty",
                        "content": "I\\'ve read that JP Morgan uses `standard input` in their coding challenges. I previously have not any experience with this as I\\'ve only used `input()` while working in Jupyter Notebook. Also, here on LeetCode and on HackerRank, when we\\'re given inputs, they\\'re already in the correct format, i.e, a string is already a string and a list is already a list. \\n\\nSo, for this particular problem: \\nhttps://leetcode.com/problems/valid-parentheses/ \\n\\nWould the input be delivered on a line like so:\\n`\\'{\\', \\'[\\', \\'(\\', \\')\\', \\']\\', \\'}\\'`\\n\\nAnd then we would have to manipulate this input and hold it in a string? \\n\\n`s = {[()]}`\\n\\nOr would it actually be given to us a string?"
                    },
                    {
                        "username": "Sebasking",
                        "content": "![image](https://assets.leetcode.com/users/images/101a101f-8a9d-4b38-a2c8-52af7cfe1cae_1597707420.5028722.png)\\n\\nPasses test case but fails same case on submission"
                    },
                    {
                        "username": "mokod",
                        "content": "Re: [0ms C language solution with a simple stack](/topic/14505/0ms-c-language-solution-with-a-simple-stack)"
                    },
                    {
                        "username": "ayuanx",
                        "content": "You either have to use some extra O(n) space like a stack, or have to use the space originally occupied by the string itself, which is also O(n).\\nIn the latter method, the string itself is destroyed in the process though.\\n\\nI can use crypto hash to mimic O(1) space complexity, but there will always be collisions (even though rarely, and needs careful construction) that can give out incorrect result."
                    },
                    {
                        "username": "eggMan282",
                        "content": "// this is a basic solution that everyone could understand"
                    },
                    {
                        "username": "ggzd",
                        "content": "good problem"
                    },
                    {
                        "username": "Aadrika_Srivastava",
                        "content": "my test cases are passed but its giving  runtime error during the submission"
                    },
                    {
                        "username": "donggyun",
                        "content": "The description should add one rule, \\'the brackets should be closed right after they are open. For example, when the input is \\'[{}]\\', then the output should be False\\'"
                    },
                    {
                        "username": "WaqasAhmed123",
                        "content": "In simplest words:\\nit says that what comes in last must removes first."
                    }
                ]
            },
            {
                "id": 1567630,
                "content": [
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-parentheses-leet-code-20/"
                    },
                    {
                        "username": "mrmitty",
                        "content": "I\\'ve read that JP Morgan uses `standard input` in their coding challenges. I previously have not any experience with this as I\\'ve only used `input()` while working in Jupyter Notebook. Also, here on LeetCode and on HackerRank, when we\\'re given inputs, they\\'re already in the correct format, i.e, a string is already a string and a list is already a list. \\n\\nSo, for this particular problem: \\nhttps://leetcode.com/problems/valid-parentheses/ \\n\\nWould the input be delivered on a line like so:\\n`\\'{\\', \\'[\\', \\'(\\', \\')\\', \\']\\', \\'}\\'`\\n\\nAnd then we would have to manipulate this input and hold it in a string? \\n\\n`s = {[()]}`\\n\\nOr would it actually be given to us a string?"
                    },
                    {
                        "username": "Sebasking",
                        "content": "![image](https://assets.leetcode.com/users/images/101a101f-8a9d-4b38-a2c8-52af7cfe1cae_1597707420.5028722.png)\\n\\nPasses test case but fails same case on submission"
                    },
                    {
                        "username": "mokod",
                        "content": "Re: [0ms C language solution with a simple stack](/topic/14505/0ms-c-language-solution-with-a-simple-stack)"
                    },
                    {
                        "username": "ayuanx",
                        "content": "You either have to use some extra O(n) space like a stack, or have to use the space originally occupied by the string itself, which is also O(n).\\nIn the latter method, the string itself is destroyed in the process though.\\n\\nI can use crypto hash to mimic O(1) space complexity, but there will always be collisions (even though rarely, and needs careful construction) that can give out incorrect result."
                    },
                    {
                        "username": "eggMan282",
                        "content": "// this is a basic solution that everyone could understand"
                    },
                    {
                        "username": "ggzd",
                        "content": "good problem"
                    },
                    {
                        "username": "Aadrika_Srivastava",
                        "content": "my test cases are passed but its giving  runtime error during the submission"
                    },
                    {
                        "username": "donggyun",
                        "content": "The description should add one rule, \\'the brackets should be closed right after they are open. For example, when the input is \\'[{}]\\', then the output should be False\\'"
                    },
                    {
                        "username": "WaqasAhmed123",
                        "content": "In simplest words:\\nit says that what comes in last must removes first."
                    }
                ]
            },
            {
                "id": 1571947,
                "content": [
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-parentheses-leet-code-20/"
                    },
                    {
                        "username": "mrmitty",
                        "content": "I\\'ve read that JP Morgan uses `standard input` in their coding challenges. I previously have not any experience with this as I\\'ve only used `input()` while working in Jupyter Notebook. Also, here on LeetCode and on HackerRank, when we\\'re given inputs, they\\'re already in the correct format, i.e, a string is already a string and a list is already a list. \\n\\nSo, for this particular problem: \\nhttps://leetcode.com/problems/valid-parentheses/ \\n\\nWould the input be delivered on a line like so:\\n`\\'{\\', \\'[\\', \\'(\\', \\')\\', \\']\\', \\'}\\'`\\n\\nAnd then we would have to manipulate this input and hold it in a string? \\n\\n`s = {[()]}`\\n\\nOr would it actually be given to us a string?"
                    },
                    {
                        "username": "Sebasking",
                        "content": "![image](https://assets.leetcode.com/users/images/101a101f-8a9d-4b38-a2c8-52af7cfe1cae_1597707420.5028722.png)\\n\\nPasses test case but fails same case on submission"
                    },
                    {
                        "username": "mokod",
                        "content": "Re: [0ms C language solution with a simple stack](/topic/14505/0ms-c-language-solution-with-a-simple-stack)"
                    },
                    {
                        "username": "ayuanx",
                        "content": "You either have to use some extra O(n) space like a stack, or have to use the space originally occupied by the string itself, which is also O(n).\\nIn the latter method, the string itself is destroyed in the process though.\\n\\nI can use crypto hash to mimic O(1) space complexity, but there will always be collisions (even though rarely, and needs careful construction) that can give out incorrect result."
                    },
                    {
                        "username": "eggMan282",
                        "content": "// this is a basic solution that everyone could understand"
                    },
                    {
                        "username": "ggzd",
                        "content": "good problem"
                    },
                    {
                        "username": "Aadrika_Srivastava",
                        "content": "my test cases are passed but its giving  runtime error during the submission"
                    },
                    {
                        "username": "donggyun",
                        "content": "The description should add one rule, \\'the brackets should be closed right after they are open. For example, when the input is \\'[{}]\\', then the output should be False\\'"
                    },
                    {
                        "username": "WaqasAhmed123",
                        "content": "In simplest words:\\nit says that what comes in last must removes first."
                    }
                ]
            },
            {
                "id": 2077432,
                "content": [
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-parentheses-leet-code-20/"
                    },
                    {
                        "username": "mrmitty",
                        "content": "I\\'ve read that JP Morgan uses `standard input` in their coding challenges. I previously have not any experience with this as I\\'ve only used `input()` while working in Jupyter Notebook. Also, here on LeetCode and on HackerRank, when we\\'re given inputs, they\\'re already in the correct format, i.e, a string is already a string and a list is already a list. \\n\\nSo, for this particular problem: \\nhttps://leetcode.com/problems/valid-parentheses/ \\n\\nWould the input be delivered on a line like so:\\n`\\'{\\', \\'[\\', \\'(\\', \\')\\', \\']\\', \\'}\\'`\\n\\nAnd then we would have to manipulate this input and hold it in a string? \\n\\n`s = {[()]}`\\n\\nOr would it actually be given to us a string?"
                    },
                    {
                        "username": "Sebasking",
                        "content": "![image](https://assets.leetcode.com/users/images/101a101f-8a9d-4b38-a2c8-52af7cfe1cae_1597707420.5028722.png)\\n\\nPasses test case but fails same case on submission"
                    },
                    {
                        "username": "mokod",
                        "content": "Re: [0ms C language solution with a simple stack](/topic/14505/0ms-c-language-solution-with-a-simple-stack)"
                    },
                    {
                        "username": "ayuanx",
                        "content": "You either have to use some extra O(n) space like a stack, or have to use the space originally occupied by the string itself, which is also O(n).\\nIn the latter method, the string itself is destroyed in the process though.\\n\\nI can use crypto hash to mimic O(1) space complexity, but there will always be collisions (even though rarely, and needs careful construction) that can give out incorrect result."
                    },
                    {
                        "username": "eggMan282",
                        "content": "// this is a basic solution that everyone could understand"
                    },
                    {
                        "username": "ggzd",
                        "content": "good problem"
                    },
                    {
                        "username": "Aadrika_Srivastava",
                        "content": "my test cases are passed but its giving  runtime error during the submission"
                    },
                    {
                        "username": "donggyun",
                        "content": "The description should add one rule, \\'the brackets should be closed right after they are open. For example, when the input is \\'[{}]\\', then the output should be False\\'"
                    },
                    {
                        "username": "WaqasAhmed123",
                        "content": "In simplest words:\\nit says that what comes in last must removes first."
                    }
                ]
            },
            {
                "id": 2075978,
                "content": [
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-parentheses-leet-code-20/"
                    },
                    {
                        "username": "mrmitty",
                        "content": "I\\'ve read that JP Morgan uses `standard input` in their coding challenges. I previously have not any experience with this as I\\'ve only used `input()` while working in Jupyter Notebook. Also, here on LeetCode and on HackerRank, when we\\'re given inputs, they\\'re already in the correct format, i.e, a string is already a string and a list is already a list. \\n\\nSo, for this particular problem: \\nhttps://leetcode.com/problems/valid-parentheses/ \\n\\nWould the input be delivered on a line like so:\\n`\\'{\\', \\'[\\', \\'(\\', \\')\\', \\']\\', \\'}\\'`\\n\\nAnd then we would have to manipulate this input and hold it in a string? \\n\\n`s = {[()]}`\\n\\nOr would it actually be given to us a string?"
                    },
                    {
                        "username": "Sebasking",
                        "content": "![image](https://assets.leetcode.com/users/images/101a101f-8a9d-4b38-a2c8-52af7cfe1cae_1597707420.5028722.png)\\n\\nPasses test case but fails same case on submission"
                    },
                    {
                        "username": "mokod",
                        "content": "Re: [0ms C language solution with a simple stack](/topic/14505/0ms-c-language-solution-with-a-simple-stack)"
                    },
                    {
                        "username": "ayuanx",
                        "content": "You either have to use some extra O(n) space like a stack, or have to use the space originally occupied by the string itself, which is also O(n).\\nIn the latter method, the string itself is destroyed in the process though.\\n\\nI can use crypto hash to mimic O(1) space complexity, but there will always be collisions (even though rarely, and needs careful construction) that can give out incorrect result."
                    },
                    {
                        "username": "eggMan282",
                        "content": "// this is a basic solution that everyone could understand"
                    },
                    {
                        "username": "ggzd",
                        "content": "good problem"
                    },
                    {
                        "username": "Aadrika_Srivastava",
                        "content": "my test cases are passed but its giving  runtime error during the submission"
                    },
                    {
                        "username": "donggyun",
                        "content": "The description should add one rule, \\'the brackets should be closed right after they are open. For example, when the input is \\'[{}]\\', then the output should be False\\'"
                    },
                    {
                        "username": "WaqasAhmed123",
                        "content": "In simplest words:\\nit says that what comes in last must removes first."
                    }
                ]
            },
            {
                "id": 2075465,
                "content": [
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-parentheses-leet-code-20/"
                    },
                    {
                        "username": "mrmitty",
                        "content": "I\\'ve read that JP Morgan uses `standard input` in their coding challenges. I previously have not any experience with this as I\\'ve only used `input()` while working in Jupyter Notebook. Also, here on LeetCode and on HackerRank, when we\\'re given inputs, they\\'re already in the correct format, i.e, a string is already a string and a list is already a list. \\n\\nSo, for this particular problem: \\nhttps://leetcode.com/problems/valid-parentheses/ \\n\\nWould the input be delivered on a line like so:\\n`\\'{\\', \\'[\\', \\'(\\', \\')\\', \\']\\', \\'}\\'`\\n\\nAnd then we would have to manipulate this input and hold it in a string? \\n\\n`s = {[()]}`\\n\\nOr would it actually be given to us a string?"
                    },
                    {
                        "username": "Sebasking",
                        "content": "![image](https://assets.leetcode.com/users/images/101a101f-8a9d-4b38-a2c8-52af7cfe1cae_1597707420.5028722.png)\\n\\nPasses test case but fails same case on submission"
                    },
                    {
                        "username": "mokod",
                        "content": "Re: [0ms C language solution with a simple stack](/topic/14505/0ms-c-language-solution-with-a-simple-stack)"
                    },
                    {
                        "username": "ayuanx",
                        "content": "You either have to use some extra O(n) space like a stack, or have to use the space originally occupied by the string itself, which is also O(n).\\nIn the latter method, the string itself is destroyed in the process though.\\n\\nI can use crypto hash to mimic O(1) space complexity, but there will always be collisions (even though rarely, and needs careful construction) that can give out incorrect result."
                    },
                    {
                        "username": "eggMan282",
                        "content": "// this is a basic solution that everyone could understand"
                    },
                    {
                        "username": "ggzd",
                        "content": "good problem"
                    },
                    {
                        "username": "Aadrika_Srivastava",
                        "content": "my test cases are passed but its giving  runtime error during the submission"
                    },
                    {
                        "username": "donggyun",
                        "content": "The description should add one rule, \\'the brackets should be closed right after they are open. For example, when the input is \\'[{}]\\', then the output should be False\\'"
                    },
                    {
                        "username": "WaqasAhmed123",
                        "content": "In simplest words:\\nit says that what comes in last must removes first."
                    }
                ]
            },
            {
                "id": 2075261,
                "content": [
                    {
                        "username": "azatgainola026",
                        "content": "public boolean isValid(String s) {\\n        if (s.equals(\"()\")) {\\n            return true;\\n        } else if (s.equals(\"()[]{}\"))\\n            return true;\\n    else if(s.equals(\"(]\")){\\n        return false;\\n\\n    }\\n    return false;\\n    }}"
                    },
                    {
                        "username": "faizan0409",
                        "content": "I have faced similar question in codding round of Darwin Box."
                    },
                    {
                        "username": "ongjaz",
                        "content": "`\"({[})]\"` How about this one, should this be valid?"
                    },
                    {
                        "username": "hyoilgoodboy",
                        "content": "This got me wondering what makes a great leet coder. \\nLike do I have to make a code and be hopeful it would pass all exceptions? If it doesn\\'t, then just build a slightly different code that solves that certain exception and do the same thing until it solves all exceptions?"
                    },
                    {
                        "username": "Irfan_S",
                        "content": "I think this a not a proper question suppose for ex:- \"{[]}\" here what should be the output True or false because it satisfies conditions for being True as well as conditions for being False"
                    },
                    {
                        "username": "lyns-data-notes",
                        "content": "in one of the testcases, s = \"([)]\", the expected answer is  False, but I don\\'t think the description can lead to the same expection."
                    },
                    {
                        "username": "shubhkhurad7774",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n         Stack<Character> stk = new Stack<>();\\n\\n        for(int i=0;i<s.length();i++){\\n             char ch =s.charAt(i);\\n             if(ch==\\'(\\'||ch==\\'[\\'|| ch==\\'{\\'){\\n                 stk.push(ch);\\n             }else if(ch==\\')\\'){\\n                 if(stk.size()==0||stk.peek()!=\\'(\\'){\\n                     return false;\\n                 }else {\\n                     stk.pop();\\n                 }\\n             }else if(ch==\\'}\\'){\\n                 if(stk.size()==0||stk.peek()!=\\'{\\'){\\n                     return false;\\n                 }else {\\n                     stk.pop();\\n                 }\\n             }else if(ch==\\']\\'){\\n                 if(stk.size()==0||stk.peek()!=\\'[\\'){\\n                     return false;\\n                 }else {\\n                     stk.pop();\\n                 }\\n             }\\n             stk.push(ch);\\n        }\\n        if(stk.size()==0)return true;\\n        return true;\\n        \\n    }\\n}\\n\\ncan someone tell me What i m missing in the code"
                    },
                    {
                        "username": "kelvin2602",
                        "content": "[@shubhkhurad7774](/shubhkhurad7774) so use string iteration ahh, still can archieve the desired result\\n\\nfor (int i....) {\\n    char ch = s.charAt(i);\\n    if (.....) {\\n        stack.push(ch);\\n    } else {\\n        if (stack.isEmpty()) {\\n            return false; \\n        }\\n        char top = stack.pop();\\n        if ((ch == \\')\\' && top != \\'(\\') || (ch == \\']\\' && top != \\'[\\') || (ch == \\'}\\' && top != \\'{\\')) {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "shubhkhurad7774",
                        "content": "[@kelvin2602](/kelvin2602)  i dont want to use the char array ..it is not possible to do with the itration only\\nplese reply"
                    },
                    {
                        "username": "kelvin2602",
                        "content": "you pushing every character onto a stack include oopen brakets and then pop them them immediately, this will push opening brackets onto stack multiple time and its causing incorrect result\\n\\nso you should only push the opening brackets onto a stack and pop when encounter the corresponding close bracket\\nI try to change a gain the code by the following way\\n\\nStack<Character> stack = new Stack<>();\\n    for (char ch : s.toCharArray()) {\\n        if (ch == \\'(\\' || ch == \\'[\\' || ch == \\'{\\') {\\n            stack.push(ch);\\n        } else {\\n            if (stack.isEmpty()) {\\n                return false;\\n            }\\n            char top = stack.pop();\\n            if ((ch == \\')\\' && top != \\'(\\') || (ch == \\']\\' && top != \\'[\\') || (ch == \\'}\\' && top != \\'{\\')) {\\n                return false;\\n            }\\n        }\\n    }\\n    return stack.isEmpty();"
                    },
                    {
                        "username": "Amritesh_20",
                        "content": "Though being easy using inbuild method/functions but the testcases that is the examples r extremally poor and does not justify\\nthe solution. We are forced to see the hint to know what method we have to use\\nEther the nested cases are valid or not ??    [{()}]?\\nor only bracket has to be followed by a closing bracket . \\nPlease update the solution  i don\\'t want others to waste time on a faulty problem description "
                    },
                    {
                        "username": "Yamin479",
                        "content": "guys use regex. with regex it will be very easy to do. you don't have to write nested loop or conditionals."
                    },
                    {
                        "username": "brianhdz885",
                        "content": "When I submit it, it says its wrong for {[]}, but when I use it as a testcase, it says its correct. This problem is broken."
                    }
                ]
            },
            {
                "id": 2073567,
                "content": [
                    {
                        "username": "azatgainola026",
                        "content": "public boolean isValid(String s) {\\n        if (s.equals(\"()\")) {\\n            return true;\\n        } else if (s.equals(\"()[]{}\"))\\n            return true;\\n    else if(s.equals(\"(]\")){\\n        return false;\\n\\n    }\\n    return false;\\n    }}"
                    },
                    {
                        "username": "faizan0409",
                        "content": "I have faced similar question in codding round of Darwin Box."
                    },
                    {
                        "username": "ongjaz",
                        "content": "`\"({[})]\"` How about this one, should this be valid?"
                    },
                    {
                        "username": "hyoilgoodboy",
                        "content": "This got me wondering what makes a great leet coder. \\nLike do I have to make a code and be hopeful it would pass all exceptions? If it doesn\\'t, then just build a slightly different code that solves that certain exception and do the same thing until it solves all exceptions?"
                    },
                    {
                        "username": "Irfan_S",
                        "content": "I think this a not a proper question suppose for ex:- \"{[]}\" here what should be the output True or false because it satisfies conditions for being True as well as conditions for being False"
                    },
                    {
                        "username": "lyns-data-notes",
                        "content": "in one of the testcases, s = \"([)]\", the expected answer is  False, but I don\\'t think the description can lead to the same expection."
                    },
                    {
                        "username": "shubhkhurad7774",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n         Stack<Character> stk = new Stack<>();\\n\\n        for(int i=0;i<s.length();i++){\\n             char ch =s.charAt(i);\\n             if(ch==\\'(\\'||ch==\\'[\\'|| ch==\\'{\\'){\\n                 stk.push(ch);\\n             }else if(ch==\\')\\'){\\n                 if(stk.size()==0||stk.peek()!=\\'(\\'){\\n                     return false;\\n                 }else {\\n                     stk.pop();\\n                 }\\n             }else if(ch==\\'}\\'){\\n                 if(stk.size()==0||stk.peek()!=\\'{\\'){\\n                     return false;\\n                 }else {\\n                     stk.pop();\\n                 }\\n             }else if(ch==\\']\\'){\\n                 if(stk.size()==0||stk.peek()!=\\'[\\'){\\n                     return false;\\n                 }else {\\n                     stk.pop();\\n                 }\\n             }\\n             stk.push(ch);\\n        }\\n        if(stk.size()==0)return true;\\n        return true;\\n        \\n    }\\n}\\n\\ncan someone tell me What i m missing in the code"
                    },
                    {
                        "username": "kelvin2602",
                        "content": "[@shubhkhurad7774](/shubhkhurad7774) so use string iteration ahh, still can archieve the desired result\\n\\nfor (int i....) {\\n    char ch = s.charAt(i);\\n    if (.....) {\\n        stack.push(ch);\\n    } else {\\n        if (stack.isEmpty()) {\\n            return false; \\n        }\\n        char top = stack.pop();\\n        if ((ch == \\')\\' && top != \\'(\\') || (ch == \\']\\' && top != \\'[\\') || (ch == \\'}\\' && top != \\'{\\')) {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "shubhkhurad7774",
                        "content": "[@kelvin2602](/kelvin2602)  i dont want to use the char array ..it is not possible to do with the itration only\\nplese reply"
                    },
                    {
                        "username": "kelvin2602",
                        "content": "you pushing every character onto a stack include oopen brakets and then pop them them immediately, this will push opening brackets onto stack multiple time and its causing incorrect result\\n\\nso you should only push the opening brackets onto a stack and pop when encounter the corresponding close bracket\\nI try to change a gain the code by the following way\\n\\nStack<Character> stack = new Stack<>();\\n    for (char ch : s.toCharArray()) {\\n        if (ch == \\'(\\' || ch == \\'[\\' || ch == \\'{\\') {\\n            stack.push(ch);\\n        } else {\\n            if (stack.isEmpty()) {\\n                return false;\\n            }\\n            char top = stack.pop();\\n            if ((ch == \\')\\' && top != \\'(\\') || (ch == \\']\\' && top != \\'[\\') || (ch == \\'}\\' && top != \\'{\\')) {\\n                return false;\\n            }\\n        }\\n    }\\n    return stack.isEmpty();"
                    },
                    {
                        "username": "Amritesh_20",
                        "content": "Though being easy using inbuild method/functions but the testcases that is the examples r extremally poor and does not justify\\nthe solution. We are forced to see the hint to know what method we have to use\\nEther the nested cases are valid or not ??    [{()}]?\\nor only bracket has to be followed by a closing bracket . \\nPlease update the solution  i don\\'t want others to waste time on a faulty problem description "
                    },
                    {
                        "username": "Yamin479",
                        "content": "guys use regex. with regex it will be very easy to do. you don't have to write nested loop or conditionals."
                    },
                    {
                        "username": "brianhdz885",
                        "content": "When I submit it, it says its wrong for {[]}, but when I use it as a testcase, it says its correct. This problem is broken."
                    }
                ]
            },
            {
                "id": 2072910,
                "content": [
                    {
                        "username": "azatgainola026",
                        "content": "public boolean isValid(String s) {\\n        if (s.equals(\"()\")) {\\n            return true;\\n        } else if (s.equals(\"()[]{}\"))\\n            return true;\\n    else if(s.equals(\"(]\")){\\n        return false;\\n\\n    }\\n    return false;\\n    }}"
                    },
                    {
                        "username": "faizan0409",
                        "content": "I have faced similar question in codding round of Darwin Box."
                    },
                    {
                        "username": "ongjaz",
                        "content": "`\"({[})]\"` How about this one, should this be valid?"
                    },
                    {
                        "username": "hyoilgoodboy",
                        "content": "This got me wondering what makes a great leet coder. \\nLike do I have to make a code and be hopeful it would pass all exceptions? If it doesn\\'t, then just build a slightly different code that solves that certain exception and do the same thing until it solves all exceptions?"
                    },
                    {
                        "username": "Irfan_S",
                        "content": "I think this a not a proper question suppose for ex:- \"{[]}\" here what should be the output True or false because it satisfies conditions for being True as well as conditions for being False"
                    },
                    {
                        "username": "lyns-data-notes",
                        "content": "in one of the testcases, s = \"([)]\", the expected answer is  False, but I don\\'t think the description can lead to the same expection."
                    },
                    {
                        "username": "shubhkhurad7774",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n         Stack<Character> stk = new Stack<>();\\n\\n        for(int i=0;i<s.length();i++){\\n             char ch =s.charAt(i);\\n             if(ch==\\'(\\'||ch==\\'[\\'|| ch==\\'{\\'){\\n                 stk.push(ch);\\n             }else if(ch==\\')\\'){\\n                 if(stk.size()==0||stk.peek()!=\\'(\\'){\\n                     return false;\\n                 }else {\\n                     stk.pop();\\n                 }\\n             }else if(ch==\\'}\\'){\\n                 if(stk.size()==0||stk.peek()!=\\'{\\'){\\n                     return false;\\n                 }else {\\n                     stk.pop();\\n                 }\\n             }else if(ch==\\']\\'){\\n                 if(stk.size()==0||stk.peek()!=\\'[\\'){\\n                     return false;\\n                 }else {\\n                     stk.pop();\\n                 }\\n             }\\n             stk.push(ch);\\n        }\\n        if(stk.size()==0)return true;\\n        return true;\\n        \\n    }\\n}\\n\\ncan someone tell me What i m missing in the code"
                    },
                    {
                        "username": "kelvin2602",
                        "content": "[@shubhkhurad7774](/shubhkhurad7774) so use string iteration ahh, still can archieve the desired result\\n\\nfor (int i....) {\\n    char ch = s.charAt(i);\\n    if (.....) {\\n        stack.push(ch);\\n    } else {\\n        if (stack.isEmpty()) {\\n            return false; \\n        }\\n        char top = stack.pop();\\n        if ((ch == \\')\\' && top != \\'(\\') || (ch == \\']\\' && top != \\'[\\') || (ch == \\'}\\' && top != \\'{\\')) {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "shubhkhurad7774",
                        "content": "[@kelvin2602](/kelvin2602)  i dont want to use the char array ..it is not possible to do with the itration only\\nplese reply"
                    },
                    {
                        "username": "kelvin2602",
                        "content": "you pushing every character onto a stack include oopen brakets and then pop them them immediately, this will push opening brackets onto stack multiple time and its causing incorrect result\\n\\nso you should only push the opening brackets onto a stack and pop when encounter the corresponding close bracket\\nI try to change a gain the code by the following way\\n\\nStack<Character> stack = new Stack<>();\\n    for (char ch : s.toCharArray()) {\\n        if (ch == \\'(\\' || ch == \\'[\\' || ch == \\'{\\') {\\n            stack.push(ch);\\n        } else {\\n            if (stack.isEmpty()) {\\n                return false;\\n            }\\n            char top = stack.pop();\\n            if ((ch == \\')\\' && top != \\'(\\') || (ch == \\']\\' && top != \\'[\\') || (ch == \\'}\\' && top != \\'{\\')) {\\n                return false;\\n            }\\n        }\\n    }\\n    return stack.isEmpty();"
                    },
                    {
                        "username": "Amritesh_20",
                        "content": "Though being easy using inbuild method/functions but the testcases that is the examples r extremally poor and does not justify\\nthe solution. We are forced to see the hint to know what method we have to use\\nEther the nested cases are valid or not ??    [{()}]?\\nor only bracket has to be followed by a closing bracket . \\nPlease update the solution  i don\\'t want others to waste time on a faulty problem description "
                    },
                    {
                        "username": "Yamin479",
                        "content": "guys use regex. with regex it will be very easy to do. you don't have to write nested loop or conditionals."
                    },
                    {
                        "username": "brianhdz885",
                        "content": "When I submit it, it says its wrong for {[]}, but when I use it as a testcase, it says its correct. This problem is broken."
                    }
                ]
            },
            {
                "id": 2070824,
                "content": [
                    {
                        "username": "azatgainola026",
                        "content": "public boolean isValid(String s) {\\n        if (s.equals(\"()\")) {\\n            return true;\\n        } else if (s.equals(\"()[]{}\"))\\n            return true;\\n    else if(s.equals(\"(]\")){\\n        return false;\\n\\n    }\\n    return false;\\n    }}"
                    },
                    {
                        "username": "faizan0409",
                        "content": "I have faced similar question in codding round of Darwin Box."
                    },
                    {
                        "username": "ongjaz",
                        "content": "`\"({[})]\"` How about this one, should this be valid?"
                    },
                    {
                        "username": "hyoilgoodboy",
                        "content": "This got me wondering what makes a great leet coder. \\nLike do I have to make a code and be hopeful it would pass all exceptions? If it doesn\\'t, then just build a slightly different code that solves that certain exception and do the same thing until it solves all exceptions?"
                    },
                    {
                        "username": "Irfan_S",
                        "content": "I think this a not a proper question suppose for ex:- \"{[]}\" here what should be the output True or false because it satisfies conditions for being True as well as conditions for being False"
                    },
                    {
                        "username": "lyns-data-notes",
                        "content": "in one of the testcases, s = \"([)]\", the expected answer is  False, but I don\\'t think the description can lead to the same expection."
                    },
                    {
                        "username": "shubhkhurad7774",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n         Stack<Character> stk = new Stack<>();\\n\\n        for(int i=0;i<s.length();i++){\\n             char ch =s.charAt(i);\\n             if(ch==\\'(\\'||ch==\\'[\\'|| ch==\\'{\\'){\\n                 stk.push(ch);\\n             }else if(ch==\\')\\'){\\n                 if(stk.size()==0||stk.peek()!=\\'(\\'){\\n                     return false;\\n                 }else {\\n                     stk.pop();\\n                 }\\n             }else if(ch==\\'}\\'){\\n                 if(stk.size()==0||stk.peek()!=\\'{\\'){\\n                     return false;\\n                 }else {\\n                     stk.pop();\\n                 }\\n             }else if(ch==\\']\\'){\\n                 if(stk.size()==0||stk.peek()!=\\'[\\'){\\n                     return false;\\n                 }else {\\n                     stk.pop();\\n                 }\\n             }\\n             stk.push(ch);\\n        }\\n        if(stk.size()==0)return true;\\n        return true;\\n        \\n    }\\n}\\n\\ncan someone tell me What i m missing in the code"
                    },
                    {
                        "username": "kelvin2602",
                        "content": "[@shubhkhurad7774](/shubhkhurad7774) so use string iteration ahh, still can archieve the desired result\\n\\nfor (int i....) {\\n    char ch = s.charAt(i);\\n    if (.....) {\\n        stack.push(ch);\\n    } else {\\n        if (stack.isEmpty()) {\\n            return false; \\n        }\\n        char top = stack.pop();\\n        if ((ch == \\')\\' && top != \\'(\\') || (ch == \\']\\' && top != \\'[\\') || (ch == \\'}\\' && top != \\'{\\')) {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "shubhkhurad7774",
                        "content": "[@kelvin2602](/kelvin2602)  i dont want to use the char array ..it is not possible to do with the itration only\\nplese reply"
                    },
                    {
                        "username": "kelvin2602",
                        "content": "you pushing every character onto a stack include oopen brakets and then pop them them immediately, this will push opening brackets onto stack multiple time and its causing incorrect result\\n\\nso you should only push the opening brackets onto a stack and pop when encounter the corresponding close bracket\\nI try to change a gain the code by the following way\\n\\nStack<Character> stack = new Stack<>();\\n    for (char ch : s.toCharArray()) {\\n        if (ch == \\'(\\' || ch == \\'[\\' || ch == \\'{\\') {\\n            stack.push(ch);\\n        } else {\\n            if (stack.isEmpty()) {\\n                return false;\\n            }\\n            char top = stack.pop();\\n            if ((ch == \\')\\' && top != \\'(\\') || (ch == \\']\\' && top != \\'[\\') || (ch == \\'}\\' && top != \\'{\\')) {\\n                return false;\\n            }\\n        }\\n    }\\n    return stack.isEmpty();"
                    },
                    {
                        "username": "Amritesh_20",
                        "content": "Though being easy using inbuild method/functions but the testcases that is the examples r extremally poor and does not justify\\nthe solution. We are forced to see the hint to know what method we have to use\\nEther the nested cases are valid or not ??    [{()}]?\\nor only bracket has to be followed by a closing bracket . \\nPlease update the solution  i don\\'t want others to waste time on a faulty problem description "
                    },
                    {
                        "username": "Yamin479",
                        "content": "guys use regex. with regex it will be very easy to do. you don't have to write nested loop or conditionals."
                    },
                    {
                        "username": "brianhdz885",
                        "content": "When I submit it, it says its wrong for {[]}, but when I use it as a testcase, it says its correct. This problem is broken."
                    }
                ]
            },
            {
                "id": 2070814,
                "content": [
                    {
                        "username": "azatgainola026",
                        "content": "public boolean isValid(String s) {\\n        if (s.equals(\"()\")) {\\n            return true;\\n        } else if (s.equals(\"()[]{}\"))\\n            return true;\\n    else if(s.equals(\"(]\")){\\n        return false;\\n\\n    }\\n    return false;\\n    }}"
                    },
                    {
                        "username": "faizan0409",
                        "content": "I have faced similar question in codding round of Darwin Box."
                    },
                    {
                        "username": "ongjaz",
                        "content": "`\"({[})]\"` How about this one, should this be valid?"
                    },
                    {
                        "username": "hyoilgoodboy",
                        "content": "This got me wondering what makes a great leet coder. \\nLike do I have to make a code and be hopeful it would pass all exceptions? If it doesn\\'t, then just build a slightly different code that solves that certain exception and do the same thing until it solves all exceptions?"
                    },
                    {
                        "username": "Irfan_S",
                        "content": "I think this a not a proper question suppose for ex:- \"{[]}\" here what should be the output True or false because it satisfies conditions for being True as well as conditions for being False"
                    },
                    {
                        "username": "lyns-data-notes",
                        "content": "in one of the testcases, s = \"([)]\", the expected answer is  False, but I don\\'t think the description can lead to the same expection."
                    },
                    {
                        "username": "shubhkhurad7774",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n         Stack<Character> stk = new Stack<>();\\n\\n        for(int i=0;i<s.length();i++){\\n             char ch =s.charAt(i);\\n             if(ch==\\'(\\'||ch==\\'[\\'|| ch==\\'{\\'){\\n                 stk.push(ch);\\n             }else if(ch==\\')\\'){\\n                 if(stk.size()==0||stk.peek()!=\\'(\\'){\\n                     return false;\\n                 }else {\\n                     stk.pop();\\n                 }\\n             }else if(ch==\\'}\\'){\\n                 if(stk.size()==0||stk.peek()!=\\'{\\'){\\n                     return false;\\n                 }else {\\n                     stk.pop();\\n                 }\\n             }else if(ch==\\']\\'){\\n                 if(stk.size()==0||stk.peek()!=\\'[\\'){\\n                     return false;\\n                 }else {\\n                     stk.pop();\\n                 }\\n             }\\n             stk.push(ch);\\n        }\\n        if(stk.size()==0)return true;\\n        return true;\\n        \\n    }\\n}\\n\\ncan someone tell me What i m missing in the code"
                    },
                    {
                        "username": "kelvin2602",
                        "content": "[@shubhkhurad7774](/shubhkhurad7774) so use string iteration ahh, still can archieve the desired result\\n\\nfor (int i....) {\\n    char ch = s.charAt(i);\\n    if (.....) {\\n        stack.push(ch);\\n    } else {\\n        if (stack.isEmpty()) {\\n            return false; \\n        }\\n        char top = stack.pop();\\n        if ((ch == \\')\\' && top != \\'(\\') || (ch == \\']\\' && top != \\'[\\') || (ch == \\'}\\' && top != \\'{\\')) {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "shubhkhurad7774",
                        "content": "[@kelvin2602](/kelvin2602)  i dont want to use the char array ..it is not possible to do with the itration only\\nplese reply"
                    },
                    {
                        "username": "kelvin2602",
                        "content": "you pushing every character onto a stack include oopen brakets and then pop them them immediately, this will push opening brackets onto stack multiple time and its causing incorrect result\\n\\nso you should only push the opening brackets onto a stack and pop when encounter the corresponding close bracket\\nI try to change a gain the code by the following way\\n\\nStack<Character> stack = new Stack<>();\\n    for (char ch : s.toCharArray()) {\\n        if (ch == \\'(\\' || ch == \\'[\\' || ch == \\'{\\') {\\n            stack.push(ch);\\n        } else {\\n            if (stack.isEmpty()) {\\n                return false;\\n            }\\n            char top = stack.pop();\\n            if ((ch == \\')\\' && top != \\'(\\') || (ch == \\']\\' && top != \\'[\\') || (ch == \\'}\\' && top != \\'{\\')) {\\n                return false;\\n            }\\n        }\\n    }\\n    return stack.isEmpty();"
                    },
                    {
                        "username": "Amritesh_20",
                        "content": "Though being easy using inbuild method/functions but the testcases that is the examples r extremally poor and does not justify\\nthe solution. We are forced to see the hint to know what method we have to use\\nEther the nested cases are valid or not ??    [{()}]?\\nor only bracket has to be followed by a closing bracket . \\nPlease update the solution  i don\\'t want others to waste time on a faulty problem description "
                    },
                    {
                        "username": "Yamin479",
                        "content": "guys use regex. with regex it will be very easy to do. you don't have to write nested loop or conditionals."
                    },
                    {
                        "username": "brianhdz885",
                        "content": "When I submit it, it says its wrong for {[]}, but when I use it as a testcase, it says its correct. This problem is broken."
                    }
                ]
            },
            {
                "id": 2069329,
                "content": [
                    {
                        "username": "azatgainola026",
                        "content": "public boolean isValid(String s) {\\n        if (s.equals(\"()\")) {\\n            return true;\\n        } else if (s.equals(\"()[]{}\"))\\n            return true;\\n    else if(s.equals(\"(]\")){\\n        return false;\\n\\n    }\\n    return false;\\n    }}"
                    },
                    {
                        "username": "faizan0409",
                        "content": "I have faced similar question in codding round of Darwin Box."
                    },
                    {
                        "username": "ongjaz",
                        "content": "`\"({[})]\"` How about this one, should this be valid?"
                    },
                    {
                        "username": "hyoilgoodboy",
                        "content": "This got me wondering what makes a great leet coder. \\nLike do I have to make a code and be hopeful it would pass all exceptions? If it doesn\\'t, then just build a slightly different code that solves that certain exception and do the same thing until it solves all exceptions?"
                    },
                    {
                        "username": "Irfan_S",
                        "content": "I think this a not a proper question suppose for ex:- \"{[]}\" here what should be the output True or false because it satisfies conditions for being True as well as conditions for being False"
                    },
                    {
                        "username": "lyns-data-notes",
                        "content": "in one of the testcases, s = \"([)]\", the expected answer is  False, but I don\\'t think the description can lead to the same expection."
                    },
                    {
                        "username": "shubhkhurad7774",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n         Stack<Character> stk = new Stack<>();\\n\\n        for(int i=0;i<s.length();i++){\\n             char ch =s.charAt(i);\\n             if(ch==\\'(\\'||ch==\\'[\\'|| ch==\\'{\\'){\\n                 stk.push(ch);\\n             }else if(ch==\\')\\'){\\n                 if(stk.size()==0||stk.peek()!=\\'(\\'){\\n                     return false;\\n                 }else {\\n                     stk.pop();\\n                 }\\n             }else if(ch==\\'}\\'){\\n                 if(stk.size()==0||stk.peek()!=\\'{\\'){\\n                     return false;\\n                 }else {\\n                     stk.pop();\\n                 }\\n             }else if(ch==\\']\\'){\\n                 if(stk.size()==0||stk.peek()!=\\'[\\'){\\n                     return false;\\n                 }else {\\n                     stk.pop();\\n                 }\\n             }\\n             stk.push(ch);\\n        }\\n        if(stk.size()==0)return true;\\n        return true;\\n        \\n    }\\n}\\n\\ncan someone tell me What i m missing in the code"
                    },
                    {
                        "username": "kelvin2602",
                        "content": "[@shubhkhurad7774](/shubhkhurad7774) so use string iteration ahh, still can archieve the desired result\\n\\nfor (int i....) {\\n    char ch = s.charAt(i);\\n    if (.....) {\\n        stack.push(ch);\\n    } else {\\n        if (stack.isEmpty()) {\\n            return false; \\n        }\\n        char top = stack.pop();\\n        if ((ch == \\')\\' && top != \\'(\\') || (ch == \\']\\' && top != \\'[\\') || (ch == \\'}\\' && top != \\'{\\')) {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "shubhkhurad7774",
                        "content": "[@kelvin2602](/kelvin2602)  i dont want to use the char array ..it is not possible to do with the itration only\\nplese reply"
                    },
                    {
                        "username": "kelvin2602",
                        "content": "you pushing every character onto a stack include oopen brakets and then pop them them immediately, this will push opening brackets onto stack multiple time and its causing incorrect result\\n\\nso you should only push the opening brackets onto a stack and pop when encounter the corresponding close bracket\\nI try to change a gain the code by the following way\\n\\nStack<Character> stack = new Stack<>();\\n    for (char ch : s.toCharArray()) {\\n        if (ch == \\'(\\' || ch == \\'[\\' || ch == \\'{\\') {\\n            stack.push(ch);\\n        } else {\\n            if (stack.isEmpty()) {\\n                return false;\\n            }\\n            char top = stack.pop();\\n            if ((ch == \\')\\' && top != \\'(\\') || (ch == \\']\\' && top != \\'[\\') || (ch == \\'}\\' && top != \\'{\\')) {\\n                return false;\\n            }\\n        }\\n    }\\n    return stack.isEmpty();"
                    },
                    {
                        "username": "Amritesh_20",
                        "content": "Though being easy using inbuild method/functions but the testcases that is the examples r extremally poor and does not justify\\nthe solution. We are forced to see the hint to know what method we have to use\\nEther the nested cases are valid or not ??    [{()}]?\\nor only bracket has to be followed by a closing bracket . \\nPlease update the solution  i don\\'t want others to waste time on a faulty problem description "
                    },
                    {
                        "username": "Yamin479",
                        "content": "guys use regex. with regex it will be very easy to do. you don't have to write nested loop or conditionals."
                    },
                    {
                        "username": "brianhdz885",
                        "content": "When I submit it, it says its wrong for {[]}, but when I use it as a testcase, it says its correct. This problem is broken."
                    }
                ]
            },
            {
                "id": 2068896,
                "content": [
                    {
                        "username": "azatgainola026",
                        "content": "public boolean isValid(String s) {\\n        if (s.equals(\"()\")) {\\n            return true;\\n        } else if (s.equals(\"()[]{}\"))\\n            return true;\\n    else if(s.equals(\"(]\")){\\n        return false;\\n\\n    }\\n    return false;\\n    }}"
                    },
                    {
                        "username": "faizan0409",
                        "content": "I have faced similar question in codding round of Darwin Box."
                    },
                    {
                        "username": "ongjaz",
                        "content": "`\"({[})]\"` How about this one, should this be valid?"
                    },
                    {
                        "username": "hyoilgoodboy",
                        "content": "This got me wondering what makes a great leet coder. \\nLike do I have to make a code and be hopeful it would pass all exceptions? If it doesn\\'t, then just build a slightly different code that solves that certain exception and do the same thing until it solves all exceptions?"
                    },
                    {
                        "username": "Irfan_S",
                        "content": "I think this a not a proper question suppose for ex:- \"{[]}\" here what should be the output True or false because it satisfies conditions for being True as well as conditions for being False"
                    },
                    {
                        "username": "lyns-data-notes",
                        "content": "in one of the testcases, s = \"([)]\", the expected answer is  False, but I don\\'t think the description can lead to the same expection."
                    },
                    {
                        "username": "shubhkhurad7774",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n         Stack<Character> stk = new Stack<>();\\n\\n        for(int i=0;i<s.length();i++){\\n             char ch =s.charAt(i);\\n             if(ch==\\'(\\'||ch==\\'[\\'|| ch==\\'{\\'){\\n                 stk.push(ch);\\n             }else if(ch==\\')\\'){\\n                 if(stk.size()==0||stk.peek()!=\\'(\\'){\\n                     return false;\\n                 }else {\\n                     stk.pop();\\n                 }\\n             }else if(ch==\\'}\\'){\\n                 if(stk.size()==0||stk.peek()!=\\'{\\'){\\n                     return false;\\n                 }else {\\n                     stk.pop();\\n                 }\\n             }else if(ch==\\']\\'){\\n                 if(stk.size()==0||stk.peek()!=\\'[\\'){\\n                     return false;\\n                 }else {\\n                     stk.pop();\\n                 }\\n             }\\n             stk.push(ch);\\n        }\\n        if(stk.size()==0)return true;\\n        return true;\\n        \\n    }\\n}\\n\\ncan someone tell me What i m missing in the code"
                    },
                    {
                        "username": "kelvin2602",
                        "content": "[@shubhkhurad7774](/shubhkhurad7774) so use string iteration ahh, still can archieve the desired result\\n\\nfor (int i....) {\\n    char ch = s.charAt(i);\\n    if (.....) {\\n        stack.push(ch);\\n    } else {\\n        if (stack.isEmpty()) {\\n            return false; \\n        }\\n        char top = stack.pop();\\n        if ((ch == \\')\\' && top != \\'(\\') || (ch == \\']\\' && top != \\'[\\') || (ch == \\'}\\' && top != \\'{\\')) {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "shubhkhurad7774",
                        "content": "[@kelvin2602](/kelvin2602)  i dont want to use the char array ..it is not possible to do with the itration only\\nplese reply"
                    },
                    {
                        "username": "kelvin2602",
                        "content": "you pushing every character onto a stack include oopen brakets and then pop them them immediately, this will push opening brackets onto stack multiple time and its causing incorrect result\\n\\nso you should only push the opening brackets onto a stack and pop when encounter the corresponding close bracket\\nI try to change a gain the code by the following way\\n\\nStack<Character> stack = new Stack<>();\\n    for (char ch : s.toCharArray()) {\\n        if (ch == \\'(\\' || ch == \\'[\\' || ch == \\'{\\') {\\n            stack.push(ch);\\n        } else {\\n            if (stack.isEmpty()) {\\n                return false;\\n            }\\n            char top = stack.pop();\\n            if ((ch == \\')\\' && top != \\'(\\') || (ch == \\']\\' && top != \\'[\\') || (ch == \\'}\\' && top != \\'{\\')) {\\n                return false;\\n            }\\n        }\\n    }\\n    return stack.isEmpty();"
                    },
                    {
                        "username": "Amritesh_20",
                        "content": "Though being easy using inbuild method/functions but the testcases that is the examples r extremally poor and does not justify\\nthe solution. We are forced to see the hint to know what method we have to use\\nEther the nested cases are valid or not ??    [{()}]?\\nor only bracket has to be followed by a closing bracket . \\nPlease update the solution  i don\\'t want others to waste time on a faulty problem description "
                    },
                    {
                        "username": "Yamin479",
                        "content": "guys use regex. with regex it will be very easy to do. you don't have to write nested loop or conditionals."
                    },
                    {
                        "username": "brianhdz885",
                        "content": "When I submit it, it says its wrong for {[]}, but when I use it as a testcase, it says its correct. This problem is broken."
                    }
                ]
            },
            {
                "id": 2064039,
                "content": [
                    {
                        "username": "azatgainola026",
                        "content": "public boolean isValid(String s) {\\n        if (s.equals(\"()\")) {\\n            return true;\\n        } else if (s.equals(\"()[]{}\"))\\n            return true;\\n    else if(s.equals(\"(]\")){\\n        return false;\\n\\n    }\\n    return false;\\n    }}"
                    },
                    {
                        "username": "faizan0409",
                        "content": "I have faced similar question in codding round of Darwin Box."
                    },
                    {
                        "username": "ongjaz",
                        "content": "`\"({[})]\"` How about this one, should this be valid?"
                    },
                    {
                        "username": "hyoilgoodboy",
                        "content": "This got me wondering what makes a great leet coder. \\nLike do I have to make a code and be hopeful it would pass all exceptions? If it doesn\\'t, then just build a slightly different code that solves that certain exception and do the same thing until it solves all exceptions?"
                    },
                    {
                        "username": "Irfan_S",
                        "content": "I think this a not a proper question suppose for ex:- \"{[]}\" here what should be the output True or false because it satisfies conditions for being True as well as conditions for being False"
                    },
                    {
                        "username": "lyns-data-notes",
                        "content": "in one of the testcases, s = \"([)]\", the expected answer is  False, but I don\\'t think the description can lead to the same expection."
                    },
                    {
                        "username": "shubhkhurad7774",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n         Stack<Character> stk = new Stack<>();\\n\\n        for(int i=0;i<s.length();i++){\\n             char ch =s.charAt(i);\\n             if(ch==\\'(\\'||ch==\\'[\\'|| ch==\\'{\\'){\\n                 stk.push(ch);\\n             }else if(ch==\\')\\'){\\n                 if(stk.size()==0||stk.peek()!=\\'(\\'){\\n                     return false;\\n                 }else {\\n                     stk.pop();\\n                 }\\n             }else if(ch==\\'}\\'){\\n                 if(stk.size()==0||stk.peek()!=\\'{\\'){\\n                     return false;\\n                 }else {\\n                     stk.pop();\\n                 }\\n             }else if(ch==\\']\\'){\\n                 if(stk.size()==0||stk.peek()!=\\'[\\'){\\n                     return false;\\n                 }else {\\n                     stk.pop();\\n                 }\\n             }\\n             stk.push(ch);\\n        }\\n        if(stk.size()==0)return true;\\n        return true;\\n        \\n    }\\n}\\n\\ncan someone tell me What i m missing in the code"
                    },
                    {
                        "username": "kelvin2602",
                        "content": "[@shubhkhurad7774](/shubhkhurad7774) so use string iteration ahh, still can archieve the desired result\\n\\nfor (int i....) {\\n    char ch = s.charAt(i);\\n    if (.....) {\\n        stack.push(ch);\\n    } else {\\n        if (stack.isEmpty()) {\\n            return false; \\n        }\\n        char top = stack.pop();\\n        if ((ch == \\')\\' && top != \\'(\\') || (ch == \\']\\' && top != \\'[\\') || (ch == \\'}\\' && top != \\'{\\')) {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "shubhkhurad7774",
                        "content": "[@kelvin2602](/kelvin2602)  i dont want to use the char array ..it is not possible to do with the itration only\\nplese reply"
                    },
                    {
                        "username": "kelvin2602",
                        "content": "you pushing every character onto a stack include oopen brakets and then pop them them immediately, this will push opening brackets onto stack multiple time and its causing incorrect result\\n\\nso you should only push the opening brackets onto a stack and pop when encounter the corresponding close bracket\\nI try to change a gain the code by the following way\\n\\nStack<Character> stack = new Stack<>();\\n    for (char ch : s.toCharArray()) {\\n        if (ch == \\'(\\' || ch == \\'[\\' || ch == \\'{\\') {\\n            stack.push(ch);\\n        } else {\\n            if (stack.isEmpty()) {\\n                return false;\\n            }\\n            char top = stack.pop();\\n            if ((ch == \\')\\' && top != \\'(\\') || (ch == \\']\\' && top != \\'[\\') || (ch == \\'}\\' && top != \\'{\\')) {\\n                return false;\\n            }\\n        }\\n    }\\n    return stack.isEmpty();"
                    },
                    {
                        "username": "Amritesh_20",
                        "content": "Though being easy using inbuild method/functions but the testcases that is the examples r extremally poor and does not justify\\nthe solution. We are forced to see the hint to know what method we have to use\\nEther the nested cases are valid or not ??    [{()}]?\\nor only bracket has to be followed by a closing bracket . \\nPlease update the solution  i don\\'t want others to waste time on a faulty problem description "
                    },
                    {
                        "username": "Yamin479",
                        "content": "guys use regex. with regex it will be very easy to do. you don't have to write nested loop or conditionals."
                    },
                    {
                        "username": "brianhdz885",
                        "content": "When I submit it, it says its wrong for {[]}, but when I use it as a testcase, it says its correct. This problem is broken."
                    }
                ]
            },
            {
                "id": 2063979,
                "content": [
                    {
                        "username": "azatgainola026",
                        "content": "public boolean isValid(String s) {\\n        if (s.equals(\"()\")) {\\n            return true;\\n        } else if (s.equals(\"()[]{}\"))\\n            return true;\\n    else if(s.equals(\"(]\")){\\n        return false;\\n\\n    }\\n    return false;\\n    }}"
                    },
                    {
                        "username": "faizan0409",
                        "content": "I have faced similar question in codding round of Darwin Box."
                    },
                    {
                        "username": "ongjaz",
                        "content": "`\"({[})]\"` How about this one, should this be valid?"
                    },
                    {
                        "username": "hyoilgoodboy",
                        "content": "This got me wondering what makes a great leet coder. \\nLike do I have to make a code and be hopeful it would pass all exceptions? If it doesn\\'t, then just build a slightly different code that solves that certain exception and do the same thing until it solves all exceptions?"
                    },
                    {
                        "username": "Irfan_S",
                        "content": "I think this a not a proper question suppose for ex:- \"{[]}\" here what should be the output True or false because it satisfies conditions for being True as well as conditions for being False"
                    },
                    {
                        "username": "lyns-data-notes",
                        "content": "in one of the testcases, s = \"([)]\", the expected answer is  False, but I don\\'t think the description can lead to the same expection."
                    },
                    {
                        "username": "shubhkhurad7774",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n         Stack<Character> stk = new Stack<>();\\n\\n        for(int i=0;i<s.length();i++){\\n             char ch =s.charAt(i);\\n             if(ch==\\'(\\'||ch==\\'[\\'|| ch==\\'{\\'){\\n                 stk.push(ch);\\n             }else if(ch==\\')\\'){\\n                 if(stk.size()==0||stk.peek()!=\\'(\\'){\\n                     return false;\\n                 }else {\\n                     stk.pop();\\n                 }\\n             }else if(ch==\\'}\\'){\\n                 if(stk.size()==0||stk.peek()!=\\'{\\'){\\n                     return false;\\n                 }else {\\n                     stk.pop();\\n                 }\\n             }else if(ch==\\']\\'){\\n                 if(stk.size()==0||stk.peek()!=\\'[\\'){\\n                     return false;\\n                 }else {\\n                     stk.pop();\\n                 }\\n             }\\n             stk.push(ch);\\n        }\\n        if(stk.size()==0)return true;\\n        return true;\\n        \\n    }\\n}\\n\\ncan someone tell me What i m missing in the code"
                    },
                    {
                        "username": "kelvin2602",
                        "content": "[@shubhkhurad7774](/shubhkhurad7774) so use string iteration ahh, still can archieve the desired result\\n\\nfor (int i....) {\\n    char ch = s.charAt(i);\\n    if (.....) {\\n        stack.push(ch);\\n    } else {\\n        if (stack.isEmpty()) {\\n            return false; \\n        }\\n        char top = stack.pop();\\n        if ((ch == \\')\\' && top != \\'(\\') || (ch == \\']\\' && top != \\'[\\') || (ch == \\'}\\' && top != \\'{\\')) {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "shubhkhurad7774",
                        "content": "[@kelvin2602](/kelvin2602)  i dont want to use the char array ..it is not possible to do with the itration only\\nplese reply"
                    },
                    {
                        "username": "kelvin2602",
                        "content": "you pushing every character onto a stack include oopen brakets and then pop them them immediately, this will push opening brackets onto stack multiple time and its causing incorrect result\\n\\nso you should only push the opening brackets onto a stack and pop when encounter the corresponding close bracket\\nI try to change a gain the code by the following way\\n\\nStack<Character> stack = new Stack<>();\\n    for (char ch : s.toCharArray()) {\\n        if (ch == \\'(\\' || ch == \\'[\\' || ch == \\'{\\') {\\n            stack.push(ch);\\n        } else {\\n            if (stack.isEmpty()) {\\n                return false;\\n            }\\n            char top = stack.pop();\\n            if ((ch == \\')\\' && top != \\'(\\') || (ch == \\']\\' && top != \\'[\\') || (ch == \\'}\\' && top != \\'{\\')) {\\n                return false;\\n            }\\n        }\\n    }\\n    return stack.isEmpty();"
                    },
                    {
                        "username": "Amritesh_20",
                        "content": "Though being easy using inbuild method/functions but the testcases that is the examples r extremally poor and does not justify\\nthe solution. We are forced to see the hint to know what method we have to use\\nEther the nested cases are valid or not ??    [{()}]?\\nor only bracket has to be followed by a closing bracket . \\nPlease update the solution  i don\\'t want others to waste time on a faulty problem description "
                    },
                    {
                        "username": "Yamin479",
                        "content": "guys use regex. with regex it will be very easy to do. you don't have to write nested loop or conditionals."
                    },
                    {
                        "username": "brianhdz885",
                        "content": "When I submit it, it says its wrong for {[]}, but when I use it as a testcase, it says its correct. This problem is broken."
                    }
                ]
            },
            {
                "id": 2063613,
                "content": [
                    {
                        "username": "azatgainola026",
                        "content": "public boolean isValid(String s) {\\n        if (s.equals(\"()\")) {\\n            return true;\\n        } else if (s.equals(\"()[]{}\"))\\n            return true;\\n    else if(s.equals(\"(]\")){\\n        return false;\\n\\n    }\\n    return false;\\n    }}"
                    },
                    {
                        "username": "faizan0409",
                        "content": "I have faced similar question in codding round of Darwin Box."
                    },
                    {
                        "username": "ongjaz",
                        "content": "`\"({[})]\"` How about this one, should this be valid?"
                    },
                    {
                        "username": "hyoilgoodboy",
                        "content": "This got me wondering what makes a great leet coder. \\nLike do I have to make a code and be hopeful it would pass all exceptions? If it doesn\\'t, then just build a slightly different code that solves that certain exception and do the same thing until it solves all exceptions?"
                    },
                    {
                        "username": "Irfan_S",
                        "content": "I think this a not a proper question suppose for ex:- \"{[]}\" here what should be the output True or false because it satisfies conditions for being True as well as conditions for being False"
                    },
                    {
                        "username": "lyns-data-notes",
                        "content": "in one of the testcases, s = \"([)]\", the expected answer is  False, but I don\\'t think the description can lead to the same expection."
                    },
                    {
                        "username": "shubhkhurad7774",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n         Stack<Character> stk = new Stack<>();\\n\\n        for(int i=0;i<s.length();i++){\\n             char ch =s.charAt(i);\\n             if(ch==\\'(\\'||ch==\\'[\\'|| ch==\\'{\\'){\\n                 stk.push(ch);\\n             }else if(ch==\\')\\'){\\n                 if(stk.size()==0||stk.peek()!=\\'(\\'){\\n                     return false;\\n                 }else {\\n                     stk.pop();\\n                 }\\n             }else if(ch==\\'}\\'){\\n                 if(stk.size()==0||stk.peek()!=\\'{\\'){\\n                     return false;\\n                 }else {\\n                     stk.pop();\\n                 }\\n             }else if(ch==\\']\\'){\\n                 if(stk.size()==0||stk.peek()!=\\'[\\'){\\n                     return false;\\n                 }else {\\n                     stk.pop();\\n                 }\\n             }\\n             stk.push(ch);\\n        }\\n        if(stk.size()==0)return true;\\n        return true;\\n        \\n    }\\n}\\n\\ncan someone tell me What i m missing in the code"
                    },
                    {
                        "username": "kelvin2602",
                        "content": "[@shubhkhurad7774](/shubhkhurad7774) so use string iteration ahh, still can archieve the desired result\\n\\nfor (int i....) {\\n    char ch = s.charAt(i);\\n    if (.....) {\\n        stack.push(ch);\\n    } else {\\n        if (stack.isEmpty()) {\\n            return false; \\n        }\\n        char top = stack.pop();\\n        if ((ch == \\')\\' && top != \\'(\\') || (ch == \\']\\' && top != \\'[\\') || (ch == \\'}\\' && top != \\'{\\')) {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "shubhkhurad7774",
                        "content": "[@kelvin2602](/kelvin2602)  i dont want to use the char array ..it is not possible to do with the itration only\\nplese reply"
                    },
                    {
                        "username": "kelvin2602",
                        "content": "you pushing every character onto a stack include oopen brakets and then pop them them immediately, this will push opening brackets onto stack multiple time and its causing incorrect result\\n\\nso you should only push the opening brackets onto a stack and pop when encounter the corresponding close bracket\\nI try to change a gain the code by the following way\\n\\nStack<Character> stack = new Stack<>();\\n    for (char ch : s.toCharArray()) {\\n        if (ch == \\'(\\' || ch == \\'[\\' || ch == \\'{\\') {\\n            stack.push(ch);\\n        } else {\\n            if (stack.isEmpty()) {\\n                return false;\\n            }\\n            char top = stack.pop();\\n            if ((ch == \\')\\' && top != \\'(\\') || (ch == \\']\\' && top != \\'[\\') || (ch == \\'}\\' && top != \\'{\\')) {\\n                return false;\\n            }\\n        }\\n    }\\n    return stack.isEmpty();"
                    },
                    {
                        "username": "Amritesh_20",
                        "content": "Though being easy using inbuild method/functions but the testcases that is the examples r extremally poor and does not justify\\nthe solution. We are forced to see the hint to know what method we have to use\\nEther the nested cases are valid or not ??    [{()}]?\\nor only bracket has to be followed by a closing bracket . \\nPlease update the solution  i don\\'t want others to waste time on a faulty problem description "
                    },
                    {
                        "username": "Yamin479",
                        "content": "guys use regex. with regex it will be very easy to do. you don't have to write nested loop or conditionals."
                    },
                    {
                        "username": "brianhdz885",
                        "content": "When I submit it, it says its wrong for {[]}, but when I use it as a testcase, it says its correct. This problem is broken."
                    }
                ]
            },
            {
                "id": 2060011,
                "content": [
                    {
                        "username": "Aayushyu",
                        "content": "I really don\\'t think this question should be in easy category just because of nested parenthesis."
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "the basic step will be first push the opening brackets and check the next brackets is same and closing then pop\\nat the end is size==0 return true"
                    },
                    {
                        "username": "gauravpaatni123",
                        "content": "what if we pass non parenthesis character , do we need to validate ?"
                    },
                    {
                        "username": "shukurillo0516",
                        "content": "For me it seemed like problem does not belong to the easy category. I pondered for an hour or more. Eventually it clicked, so the click word is stack. Look carefully at stack properties."
                    },
                    {
                        "username": "Awesome_7",
                        "content": "Can any one tell whats wrong in the 70th test case \\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        string opening=\"\";\\n        string closing=\"\";\\n\\n        for(auto i:s){\\n            if(i==\\'(\\' || i==\\'{\\' || i==\\'[\\' ){\\n                opening.push_back(i);\\n            }else{\\n                closing.push_back(i);\\n            }\\n        }\\n\\n        if(opening.length()!=closing.length()){\\n            return false;\\n        }\\n\\n        for(int i=0;i<opening.length();i++){\\n            if(opening[i]==\\'(\\'&& closing[i]!=\\')\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'{\\'&& closing[i]!=\\'}\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'[\\'&& closing[i]!=\\']\\'){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "egbeliaev",
                        "content": "To everyone who has problems with wrong output during submission: seems like you should have all your variables declared and used inside your function, do not put anything to the class. "
                    },
                    {
                        "username": "0bro",
                        "content": "Something that helps with saving memory, time and complexity is to check initial wrong solutions. Before we declare variables (and consume memory) we should validate the input to be valid. I don\\'t like to give answers so here\\'s something you can think about...\\n\\n```javascript\\nif (s.length === 0 || ...) // What other conclusions can we make?\\n       return false;\\n```"
                    },
                    {
                        "username": "mmdmzfri",
                        "content": "how is this easy?\\ntook me 3hrs"
                    },
                    {
                        "username": "bitgeek47",
                        "content": "EXPLAIN HOW TO DO THIS IN O(1) SPACE COMPLEXITY and O(N) TIME ?"
                    },
                    {
                        "username": "HughKevner",
                        "content": "Would \"()[()]{}\" true"
                    },
                    {
                        "username": "natan20200679",
                        "content": "I just ran two solutions in Netbeans that meets the problem, and it turned out True."
                    }
                ]
            },
            {
                "id": 2059405,
                "content": [
                    {
                        "username": "Aayushyu",
                        "content": "I really don\\'t think this question should be in easy category just because of nested parenthesis."
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "the basic step will be first push the opening brackets and check the next brackets is same and closing then pop\\nat the end is size==0 return true"
                    },
                    {
                        "username": "gauravpaatni123",
                        "content": "what if we pass non parenthesis character , do we need to validate ?"
                    },
                    {
                        "username": "shukurillo0516",
                        "content": "For me it seemed like problem does not belong to the easy category. I pondered for an hour or more. Eventually it clicked, so the click word is stack. Look carefully at stack properties."
                    },
                    {
                        "username": "Awesome_7",
                        "content": "Can any one tell whats wrong in the 70th test case \\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        string opening=\"\";\\n        string closing=\"\";\\n\\n        for(auto i:s){\\n            if(i==\\'(\\' || i==\\'{\\' || i==\\'[\\' ){\\n                opening.push_back(i);\\n            }else{\\n                closing.push_back(i);\\n            }\\n        }\\n\\n        if(opening.length()!=closing.length()){\\n            return false;\\n        }\\n\\n        for(int i=0;i<opening.length();i++){\\n            if(opening[i]==\\'(\\'&& closing[i]!=\\')\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'{\\'&& closing[i]!=\\'}\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'[\\'&& closing[i]!=\\']\\'){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "egbeliaev",
                        "content": "To everyone who has problems with wrong output during submission: seems like you should have all your variables declared and used inside your function, do not put anything to the class. "
                    },
                    {
                        "username": "0bro",
                        "content": "Something that helps with saving memory, time and complexity is to check initial wrong solutions. Before we declare variables (and consume memory) we should validate the input to be valid. I don\\'t like to give answers so here\\'s something you can think about...\\n\\n```javascript\\nif (s.length === 0 || ...) // What other conclusions can we make?\\n       return false;\\n```"
                    },
                    {
                        "username": "mmdmzfri",
                        "content": "how is this easy?\\ntook me 3hrs"
                    },
                    {
                        "username": "bitgeek47",
                        "content": "EXPLAIN HOW TO DO THIS IN O(1) SPACE COMPLEXITY and O(N) TIME ?"
                    },
                    {
                        "username": "HughKevner",
                        "content": "Would \"()[()]{}\" true"
                    },
                    {
                        "username": "natan20200679",
                        "content": "I just ran two solutions in Netbeans that meets the problem, and it turned out True."
                    }
                ]
            },
            {
                "id": 2058705,
                "content": [
                    {
                        "username": "Aayushyu",
                        "content": "I really don\\'t think this question should be in easy category just because of nested parenthesis."
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "the basic step will be first push the opening brackets and check the next brackets is same and closing then pop\\nat the end is size==0 return true"
                    },
                    {
                        "username": "gauravpaatni123",
                        "content": "what if we pass non parenthesis character , do we need to validate ?"
                    },
                    {
                        "username": "shukurillo0516",
                        "content": "For me it seemed like problem does not belong to the easy category. I pondered for an hour or more. Eventually it clicked, so the click word is stack. Look carefully at stack properties."
                    },
                    {
                        "username": "Awesome_7",
                        "content": "Can any one tell whats wrong in the 70th test case \\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        string opening=\"\";\\n        string closing=\"\";\\n\\n        for(auto i:s){\\n            if(i==\\'(\\' || i==\\'{\\' || i==\\'[\\' ){\\n                opening.push_back(i);\\n            }else{\\n                closing.push_back(i);\\n            }\\n        }\\n\\n        if(opening.length()!=closing.length()){\\n            return false;\\n        }\\n\\n        for(int i=0;i<opening.length();i++){\\n            if(opening[i]==\\'(\\'&& closing[i]!=\\')\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'{\\'&& closing[i]!=\\'}\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'[\\'&& closing[i]!=\\']\\'){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "egbeliaev",
                        "content": "To everyone who has problems with wrong output during submission: seems like you should have all your variables declared and used inside your function, do not put anything to the class. "
                    },
                    {
                        "username": "0bro",
                        "content": "Something that helps with saving memory, time and complexity is to check initial wrong solutions. Before we declare variables (and consume memory) we should validate the input to be valid. I don\\'t like to give answers so here\\'s something you can think about...\\n\\n```javascript\\nif (s.length === 0 || ...) // What other conclusions can we make?\\n       return false;\\n```"
                    },
                    {
                        "username": "mmdmzfri",
                        "content": "how is this easy?\\ntook me 3hrs"
                    },
                    {
                        "username": "bitgeek47",
                        "content": "EXPLAIN HOW TO DO THIS IN O(1) SPACE COMPLEXITY and O(N) TIME ?"
                    },
                    {
                        "username": "HughKevner",
                        "content": "Would \"()[()]{}\" true"
                    },
                    {
                        "username": "natan20200679",
                        "content": "I just ran two solutions in Netbeans that meets the problem, and it turned out True."
                    }
                ]
            },
            {
                "id": 2057186,
                "content": [
                    {
                        "username": "Aayushyu",
                        "content": "I really don\\'t think this question should be in easy category just because of nested parenthesis."
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "the basic step will be first push the opening brackets and check the next brackets is same and closing then pop\\nat the end is size==0 return true"
                    },
                    {
                        "username": "gauravpaatni123",
                        "content": "what if we pass non parenthesis character , do we need to validate ?"
                    },
                    {
                        "username": "shukurillo0516",
                        "content": "For me it seemed like problem does not belong to the easy category. I pondered for an hour or more. Eventually it clicked, so the click word is stack. Look carefully at stack properties."
                    },
                    {
                        "username": "Awesome_7",
                        "content": "Can any one tell whats wrong in the 70th test case \\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        string opening=\"\";\\n        string closing=\"\";\\n\\n        for(auto i:s){\\n            if(i==\\'(\\' || i==\\'{\\' || i==\\'[\\' ){\\n                opening.push_back(i);\\n            }else{\\n                closing.push_back(i);\\n            }\\n        }\\n\\n        if(opening.length()!=closing.length()){\\n            return false;\\n        }\\n\\n        for(int i=0;i<opening.length();i++){\\n            if(opening[i]==\\'(\\'&& closing[i]!=\\')\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'{\\'&& closing[i]!=\\'}\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'[\\'&& closing[i]!=\\']\\'){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "egbeliaev",
                        "content": "To everyone who has problems with wrong output during submission: seems like you should have all your variables declared and used inside your function, do not put anything to the class. "
                    },
                    {
                        "username": "0bro",
                        "content": "Something that helps with saving memory, time and complexity is to check initial wrong solutions. Before we declare variables (and consume memory) we should validate the input to be valid. I don\\'t like to give answers so here\\'s something you can think about...\\n\\n```javascript\\nif (s.length === 0 || ...) // What other conclusions can we make?\\n       return false;\\n```"
                    },
                    {
                        "username": "mmdmzfri",
                        "content": "how is this easy?\\ntook me 3hrs"
                    },
                    {
                        "username": "bitgeek47",
                        "content": "EXPLAIN HOW TO DO THIS IN O(1) SPACE COMPLEXITY and O(N) TIME ?"
                    },
                    {
                        "username": "HughKevner",
                        "content": "Would \"()[()]{}\" true"
                    },
                    {
                        "username": "natan20200679",
                        "content": "I just ran two solutions in Netbeans that meets the problem, and it turned out True."
                    }
                ]
            },
            {
                "id": 2050453,
                "content": [
                    {
                        "username": "Aayushyu",
                        "content": "I really don\\'t think this question should be in easy category just because of nested parenthesis."
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "the basic step will be first push the opening brackets and check the next brackets is same and closing then pop\\nat the end is size==0 return true"
                    },
                    {
                        "username": "gauravpaatni123",
                        "content": "what if we pass non parenthesis character , do we need to validate ?"
                    },
                    {
                        "username": "shukurillo0516",
                        "content": "For me it seemed like problem does not belong to the easy category. I pondered for an hour or more. Eventually it clicked, so the click word is stack. Look carefully at stack properties."
                    },
                    {
                        "username": "Awesome_7",
                        "content": "Can any one tell whats wrong in the 70th test case \\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        string opening=\"\";\\n        string closing=\"\";\\n\\n        for(auto i:s){\\n            if(i==\\'(\\' || i==\\'{\\' || i==\\'[\\' ){\\n                opening.push_back(i);\\n            }else{\\n                closing.push_back(i);\\n            }\\n        }\\n\\n        if(opening.length()!=closing.length()){\\n            return false;\\n        }\\n\\n        for(int i=0;i<opening.length();i++){\\n            if(opening[i]==\\'(\\'&& closing[i]!=\\')\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'{\\'&& closing[i]!=\\'}\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'[\\'&& closing[i]!=\\']\\'){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "egbeliaev",
                        "content": "To everyone who has problems with wrong output during submission: seems like you should have all your variables declared and used inside your function, do not put anything to the class. "
                    },
                    {
                        "username": "0bro",
                        "content": "Something that helps with saving memory, time and complexity is to check initial wrong solutions. Before we declare variables (and consume memory) we should validate the input to be valid. I don\\'t like to give answers so here\\'s something you can think about...\\n\\n```javascript\\nif (s.length === 0 || ...) // What other conclusions can we make?\\n       return false;\\n```"
                    },
                    {
                        "username": "mmdmzfri",
                        "content": "how is this easy?\\ntook me 3hrs"
                    },
                    {
                        "username": "bitgeek47",
                        "content": "EXPLAIN HOW TO DO THIS IN O(1) SPACE COMPLEXITY and O(N) TIME ?"
                    },
                    {
                        "username": "HughKevner",
                        "content": "Would \"()[()]{}\" true"
                    },
                    {
                        "username": "natan20200679",
                        "content": "I just ran two solutions in Netbeans that meets the problem, and it turned out True."
                    }
                ]
            },
            {
                "id": 2049034,
                "content": [
                    {
                        "username": "Aayushyu",
                        "content": "I really don\\'t think this question should be in easy category just because of nested parenthesis."
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "the basic step will be first push the opening brackets and check the next brackets is same and closing then pop\\nat the end is size==0 return true"
                    },
                    {
                        "username": "gauravpaatni123",
                        "content": "what if we pass non parenthesis character , do we need to validate ?"
                    },
                    {
                        "username": "shukurillo0516",
                        "content": "For me it seemed like problem does not belong to the easy category. I pondered for an hour or more. Eventually it clicked, so the click word is stack. Look carefully at stack properties."
                    },
                    {
                        "username": "Awesome_7",
                        "content": "Can any one tell whats wrong in the 70th test case \\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        string opening=\"\";\\n        string closing=\"\";\\n\\n        for(auto i:s){\\n            if(i==\\'(\\' || i==\\'{\\' || i==\\'[\\' ){\\n                opening.push_back(i);\\n            }else{\\n                closing.push_back(i);\\n            }\\n        }\\n\\n        if(opening.length()!=closing.length()){\\n            return false;\\n        }\\n\\n        for(int i=0;i<opening.length();i++){\\n            if(opening[i]==\\'(\\'&& closing[i]!=\\')\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'{\\'&& closing[i]!=\\'}\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'[\\'&& closing[i]!=\\']\\'){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "egbeliaev",
                        "content": "To everyone who has problems with wrong output during submission: seems like you should have all your variables declared and used inside your function, do not put anything to the class. "
                    },
                    {
                        "username": "0bro",
                        "content": "Something that helps with saving memory, time and complexity is to check initial wrong solutions. Before we declare variables (and consume memory) we should validate the input to be valid. I don\\'t like to give answers so here\\'s something you can think about...\\n\\n```javascript\\nif (s.length === 0 || ...) // What other conclusions can we make?\\n       return false;\\n```"
                    },
                    {
                        "username": "mmdmzfri",
                        "content": "how is this easy?\\ntook me 3hrs"
                    },
                    {
                        "username": "bitgeek47",
                        "content": "EXPLAIN HOW TO DO THIS IN O(1) SPACE COMPLEXITY and O(N) TIME ?"
                    },
                    {
                        "username": "HughKevner",
                        "content": "Would \"()[()]{}\" true"
                    },
                    {
                        "username": "natan20200679",
                        "content": "I just ran two solutions in Netbeans that meets the problem, and it turned out True."
                    }
                ]
            },
            {
                "id": 2046534,
                "content": [
                    {
                        "username": "Aayushyu",
                        "content": "I really don\\'t think this question should be in easy category just because of nested parenthesis."
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "the basic step will be first push the opening brackets and check the next brackets is same and closing then pop\\nat the end is size==0 return true"
                    },
                    {
                        "username": "gauravpaatni123",
                        "content": "what if we pass non parenthesis character , do we need to validate ?"
                    },
                    {
                        "username": "shukurillo0516",
                        "content": "For me it seemed like problem does not belong to the easy category. I pondered for an hour or more. Eventually it clicked, so the click word is stack. Look carefully at stack properties."
                    },
                    {
                        "username": "Awesome_7",
                        "content": "Can any one tell whats wrong in the 70th test case \\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        string opening=\"\";\\n        string closing=\"\";\\n\\n        for(auto i:s){\\n            if(i==\\'(\\' || i==\\'{\\' || i==\\'[\\' ){\\n                opening.push_back(i);\\n            }else{\\n                closing.push_back(i);\\n            }\\n        }\\n\\n        if(opening.length()!=closing.length()){\\n            return false;\\n        }\\n\\n        for(int i=0;i<opening.length();i++){\\n            if(opening[i]==\\'(\\'&& closing[i]!=\\')\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'{\\'&& closing[i]!=\\'}\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'[\\'&& closing[i]!=\\']\\'){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "egbeliaev",
                        "content": "To everyone who has problems with wrong output during submission: seems like you should have all your variables declared and used inside your function, do not put anything to the class. "
                    },
                    {
                        "username": "0bro",
                        "content": "Something that helps with saving memory, time and complexity is to check initial wrong solutions. Before we declare variables (and consume memory) we should validate the input to be valid. I don\\'t like to give answers so here\\'s something you can think about...\\n\\n```javascript\\nif (s.length === 0 || ...) // What other conclusions can we make?\\n       return false;\\n```"
                    },
                    {
                        "username": "mmdmzfri",
                        "content": "how is this easy?\\ntook me 3hrs"
                    },
                    {
                        "username": "bitgeek47",
                        "content": "EXPLAIN HOW TO DO THIS IN O(1) SPACE COMPLEXITY and O(N) TIME ?"
                    },
                    {
                        "username": "HughKevner",
                        "content": "Would \"()[()]{}\" true"
                    },
                    {
                        "username": "natan20200679",
                        "content": "I just ran two solutions in Netbeans that meets the problem, and it turned out True."
                    }
                ]
            },
            {
                "id": 2042531,
                "content": [
                    {
                        "username": "Aayushyu",
                        "content": "I really don\\'t think this question should be in easy category just because of nested parenthesis."
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "the basic step will be first push the opening brackets and check the next brackets is same and closing then pop\\nat the end is size==0 return true"
                    },
                    {
                        "username": "gauravpaatni123",
                        "content": "what if we pass non parenthesis character , do we need to validate ?"
                    },
                    {
                        "username": "shukurillo0516",
                        "content": "For me it seemed like problem does not belong to the easy category. I pondered for an hour or more. Eventually it clicked, so the click word is stack. Look carefully at stack properties."
                    },
                    {
                        "username": "Awesome_7",
                        "content": "Can any one tell whats wrong in the 70th test case \\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        string opening=\"\";\\n        string closing=\"\";\\n\\n        for(auto i:s){\\n            if(i==\\'(\\' || i==\\'{\\' || i==\\'[\\' ){\\n                opening.push_back(i);\\n            }else{\\n                closing.push_back(i);\\n            }\\n        }\\n\\n        if(opening.length()!=closing.length()){\\n            return false;\\n        }\\n\\n        for(int i=0;i<opening.length();i++){\\n            if(opening[i]==\\'(\\'&& closing[i]!=\\')\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'{\\'&& closing[i]!=\\'}\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'[\\'&& closing[i]!=\\']\\'){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "egbeliaev",
                        "content": "To everyone who has problems with wrong output during submission: seems like you should have all your variables declared and used inside your function, do not put anything to the class. "
                    },
                    {
                        "username": "0bro",
                        "content": "Something that helps with saving memory, time and complexity is to check initial wrong solutions. Before we declare variables (and consume memory) we should validate the input to be valid. I don\\'t like to give answers so here\\'s something you can think about...\\n\\n```javascript\\nif (s.length === 0 || ...) // What other conclusions can we make?\\n       return false;\\n```"
                    },
                    {
                        "username": "mmdmzfri",
                        "content": "how is this easy?\\ntook me 3hrs"
                    },
                    {
                        "username": "bitgeek47",
                        "content": "EXPLAIN HOW TO DO THIS IN O(1) SPACE COMPLEXITY and O(N) TIME ?"
                    },
                    {
                        "username": "HughKevner",
                        "content": "Would \"()[()]{}\" true"
                    },
                    {
                        "username": "natan20200679",
                        "content": "I just ran two solutions in Netbeans that meets the problem, and it turned out True."
                    }
                ]
            },
            {
                "id": 2040389,
                "content": [
                    {
                        "username": "Aayushyu",
                        "content": "I really don\\'t think this question should be in easy category just because of nested parenthesis."
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "the basic step will be first push the opening brackets and check the next brackets is same and closing then pop\\nat the end is size==0 return true"
                    },
                    {
                        "username": "gauravpaatni123",
                        "content": "what if we pass non parenthesis character , do we need to validate ?"
                    },
                    {
                        "username": "shukurillo0516",
                        "content": "For me it seemed like problem does not belong to the easy category. I pondered for an hour or more. Eventually it clicked, so the click word is stack. Look carefully at stack properties."
                    },
                    {
                        "username": "Awesome_7",
                        "content": "Can any one tell whats wrong in the 70th test case \\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        string opening=\"\";\\n        string closing=\"\";\\n\\n        for(auto i:s){\\n            if(i==\\'(\\' || i==\\'{\\' || i==\\'[\\' ){\\n                opening.push_back(i);\\n            }else{\\n                closing.push_back(i);\\n            }\\n        }\\n\\n        if(opening.length()!=closing.length()){\\n            return false;\\n        }\\n\\n        for(int i=0;i<opening.length();i++){\\n            if(opening[i]==\\'(\\'&& closing[i]!=\\')\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'{\\'&& closing[i]!=\\'}\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'[\\'&& closing[i]!=\\']\\'){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "egbeliaev",
                        "content": "To everyone who has problems with wrong output during submission: seems like you should have all your variables declared and used inside your function, do not put anything to the class. "
                    },
                    {
                        "username": "0bro",
                        "content": "Something that helps with saving memory, time and complexity is to check initial wrong solutions. Before we declare variables (and consume memory) we should validate the input to be valid. I don\\'t like to give answers so here\\'s something you can think about...\\n\\n```javascript\\nif (s.length === 0 || ...) // What other conclusions can we make?\\n       return false;\\n```"
                    },
                    {
                        "username": "mmdmzfri",
                        "content": "how is this easy?\\ntook me 3hrs"
                    },
                    {
                        "username": "bitgeek47",
                        "content": "EXPLAIN HOW TO DO THIS IN O(1) SPACE COMPLEXITY and O(N) TIME ?"
                    },
                    {
                        "username": "HughKevner",
                        "content": "Would \"()[()]{}\" true"
                    },
                    {
                        "username": "natan20200679",
                        "content": "I just ran two solutions in Netbeans that meets the problem, and it turned out True."
                    }
                ]
            },
            {
                "id": 2034788,
                "content": [
                    {
                        "username": "Aayushyu",
                        "content": "I really don\\'t think this question should be in easy category just because of nested parenthesis."
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "the basic step will be first push the opening brackets and check the next brackets is same and closing then pop\\nat the end is size==0 return true"
                    },
                    {
                        "username": "gauravpaatni123",
                        "content": "what if we pass non parenthesis character , do we need to validate ?"
                    },
                    {
                        "username": "shukurillo0516",
                        "content": "For me it seemed like problem does not belong to the easy category. I pondered for an hour or more. Eventually it clicked, so the click word is stack. Look carefully at stack properties."
                    },
                    {
                        "username": "Awesome_7",
                        "content": "Can any one tell whats wrong in the 70th test case \\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        string opening=\"\";\\n        string closing=\"\";\\n\\n        for(auto i:s){\\n            if(i==\\'(\\' || i==\\'{\\' || i==\\'[\\' ){\\n                opening.push_back(i);\\n            }else{\\n                closing.push_back(i);\\n            }\\n        }\\n\\n        if(opening.length()!=closing.length()){\\n            return false;\\n        }\\n\\n        for(int i=0;i<opening.length();i++){\\n            if(opening[i]==\\'(\\'&& closing[i]!=\\')\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'{\\'&& closing[i]!=\\'}\\'){\\n                return false;\\n            }\\n            else if(opening[i]==\\'[\\'&& closing[i]!=\\']\\'){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "egbeliaev",
                        "content": "To everyone who has problems with wrong output during submission: seems like you should have all your variables declared and used inside your function, do not put anything to the class. "
                    },
                    {
                        "username": "0bro",
                        "content": "Something that helps with saving memory, time and complexity is to check initial wrong solutions. Before we declare variables (and consume memory) we should validate the input to be valid. I don\\'t like to give answers so here\\'s something you can think about...\\n\\n```javascript\\nif (s.length === 0 || ...) // What other conclusions can we make?\\n       return false;\\n```"
                    },
                    {
                        "username": "mmdmzfri",
                        "content": "how is this easy?\\ntook me 3hrs"
                    },
                    {
                        "username": "bitgeek47",
                        "content": "EXPLAIN HOW TO DO THIS IN O(1) SPACE COMPLEXITY and O(N) TIME ?"
                    },
                    {
                        "username": "HughKevner",
                        "content": "Would \"()[()]{}\" true"
                    },
                    {
                        "username": "natan20200679",
                        "content": "I just ran two solutions in Netbeans that meets the problem, and it turned out True."
                    }
                ]
            },
            {
                "id": 2033827,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Stolen from Codewars"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Bring it back to Codewars"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Does anyone know how to do it with space complexity O(1). "
                    },
                    {
                        "username": "brucenguyen1852",
                        "content": "\\'import java.util.Scanner;\\n\\npublic class ValidParentheses {\\n    // Given a string s containing just the characters \\'(\\', \\')\\', \\'{\\', \\'}\\', \\'[\\' and\\n    // \\']\\', determine if the input string is valid.\\n\\n    // An input string is valid if:\\n\\n    // Open brackets must be closed by the same type of brackets.\\n    // Open brackets must be closed in the correct order.\\n    // Every close bracket has a corresponding open bracket of the same type.\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n\\n        System.out.print(\"Enter a string of parentheses: \");\\n        String input = scanner.nextLine();\\n\\n        scanner.close();\\n\\n        boolean result = isValid(input);\\n        System.out.println(\"Is valid: \" + result);\\n    }\\n    public static boolean isValid(String s) {\\n        int count = 0;\\n    \\n        for (int i = 0; i < s.length(); i++) {\\n            char bracket = s.charAt(i);\\n    \\n            if (bracket == \\'(\\' || bracket == \\'[\\' || bracket == \\'{\\') {\\n                count++;\\n            } else if (bracket == \\')\\' || bracket == \\']\\' || bracket == \\'}\\') {\\n                count--;\\n                if (count < 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return count == 0;\\n    }\\n}\\'\\nthis is my code without use Stack library "
                    },
                    {
                        "username": "natan20200679",
                        "content": "Congratulations! I really liked of your solution, which is simply conditional."
                    },
                    {
                        "username": "_hunt",
                        "content": "try using stack to push & pop then compare"
                    },
                    {
                        "username": "mishanin",
                        "content": "I saw the hint. General idea is loop through the string and if you see opening brackets  - place CLOSING brackets into stack(array push) and if you see closing brackets - compare them with the last in the stack..."
                    },
                    {
                        "username": "fatimaArshad10",
                        "content": "I started by using simple \"if\" statements, without using nested conditions. Afterward, I set up an empty container to hold characters for later condition evaluation. "
                    },
                    {
                        "username": "AatmanMantri",
                        "content": "How is  `s = \"(){}}{\"` a valid string?"
                    },
                    {
                        "username": "natan20200679",
                        "content": "[@AatmanMantri](/AatmanMantri) That! I will modify the code according to the solution of one of you to fix it."
                    },
                    {
                        "username": "AatmanMantri",
                        "content": "[@natan20200679](/natan20200679) but why is this a valid case? `}` (closing bracket) is before `{` (open bracket). which shouldn\\'t be allowed, right? or am i missing something?"
                    },
                    {
                        "username": "natan20200679",
                        "content": "I confess that I did not consider adding case tests. Thank you friend."
                    },
                    {
                        "username": "natan20200679",
                        "content": "The problem runs correctly in the IDE and here, but it always throws a runtime error here, in the line 8. I would like some help to fix this. "
                    },
                    {
                        "username": "Launchpad",
                        "content": "take \\'([)]\\' as a case, the brackets close in the correct order but for this problem it\\'s invalid. I think the question is unclear, because if this case is false then the question should be something like \"the opening and closing brackets have to be consecutive\"?"
                    },
                    {
                        "username": "s8900830",
                        "content": "        dict={\"(\":\")\",\"[\":\"]\",\"{\":\"}\"}\\n        for name,key in dict.items():\\n            if name in s:\\n                if key in s:\\n                    return \\'true\\'\\n                else:\\n                    return \\'false\\'\\n\\nIn Case3 is Wrong Answer \\uFF0C Why\\uFF1F "
                    }
                ]
            },
            {
                "id": 2030618,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Stolen from Codewars"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Bring it back to Codewars"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Does anyone know how to do it with space complexity O(1). "
                    },
                    {
                        "username": "brucenguyen1852",
                        "content": "\\'import java.util.Scanner;\\n\\npublic class ValidParentheses {\\n    // Given a string s containing just the characters \\'(\\', \\')\\', \\'{\\', \\'}\\', \\'[\\' and\\n    // \\']\\', determine if the input string is valid.\\n\\n    // An input string is valid if:\\n\\n    // Open brackets must be closed by the same type of brackets.\\n    // Open brackets must be closed in the correct order.\\n    // Every close bracket has a corresponding open bracket of the same type.\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n\\n        System.out.print(\"Enter a string of parentheses: \");\\n        String input = scanner.nextLine();\\n\\n        scanner.close();\\n\\n        boolean result = isValid(input);\\n        System.out.println(\"Is valid: \" + result);\\n    }\\n    public static boolean isValid(String s) {\\n        int count = 0;\\n    \\n        for (int i = 0; i < s.length(); i++) {\\n            char bracket = s.charAt(i);\\n    \\n            if (bracket == \\'(\\' || bracket == \\'[\\' || bracket == \\'{\\') {\\n                count++;\\n            } else if (bracket == \\')\\' || bracket == \\']\\' || bracket == \\'}\\') {\\n                count--;\\n                if (count < 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return count == 0;\\n    }\\n}\\'\\nthis is my code without use Stack library "
                    },
                    {
                        "username": "natan20200679",
                        "content": "Congratulations! I really liked of your solution, which is simply conditional."
                    },
                    {
                        "username": "_hunt",
                        "content": "try using stack to push & pop then compare"
                    },
                    {
                        "username": "mishanin",
                        "content": "I saw the hint. General idea is loop through the string and if you see opening brackets  - place CLOSING brackets into stack(array push) and if you see closing brackets - compare them with the last in the stack..."
                    },
                    {
                        "username": "fatimaArshad10",
                        "content": "I started by using simple \"if\" statements, without using nested conditions. Afterward, I set up an empty container to hold characters for later condition evaluation. "
                    },
                    {
                        "username": "AatmanMantri",
                        "content": "How is  `s = \"(){}}{\"` a valid string?"
                    },
                    {
                        "username": "natan20200679",
                        "content": "[@AatmanMantri](/AatmanMantri) That! I will modify the code according to the solution of one of you to fix it."
                    },
                    {
                        "username": "AatmanMantri",
                        "content": "[@natan20200679](/natan20200679) but why is this a valid case? `}` (closing bracket) is before `{` (open bracket). which shouldn\\'t be allowed, right? or am i missing something?"
                    },
                    {
                        "username": "natan20200679",
                        "content": "I confess that I did not consider adding case tests. Thank you friend."
                    },
                    {
                        "username": "natan20200679",
                        "content": "The problem runs correctly in the IDE and here, but it always throws a runtime error here, in the line 8. I would like some help to fix this. "
                    },
                    {
                        "username": "Launchpad",
                        "content": "take \\'([)]\\' as a case, the brackets close in the correct order but for this problem it\\'s invalid. I think the question is unclear, because if this case is false then the question should be something like \"the opening and closing brackets have to be consecutive\"?"
                    },
                    {
                        "username": "s8900830",
                        "content": "        dict={\"(\":\")\",\"[\":\"]\",\"{\":\"}\"}\\n        for name,key in dict.items():\\n            if name in s:\\n                if key in s:\\n                    return \\'true\\'\\n                else:\\n                    return \\'false\\'\\n\\nIn Case3 is Wrong Answer \\uFF0C Why\\uFF1F "
                    }
                ]
            },
            {
                "id": 2028503,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Stolen from Codewars"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Bring it back to Codewars"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Does anyone know how to do it with space complexity O(1). "
                    },
                    {
                        "username": "brucenguyen1852",
                        "content": "\\'import java.util.Scanner;\\n\\npublic class ValidParentheses {\\n    // Given a string s containing just the characters \\'(\\', \\')\\', \\'{\\', \\'}\\', \\'[\\' and\\n    // \\']\\', determine if the input string is valid.\\n\\n    // An input string is valid if:\\n\\n    // Open brackets must be closed by the same type of brackets.\\n    // Open brackets must be closed in the correct order.\\n    // Every close bracket has a corresponding open bracket of the same type.\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n\\n        System.out.print(\"Enter a string of parentheses: \");\\n        String input = scanner.nextLine();\\n\\n        scanner.close();\\n\\n        boolean result = isValid(input);\\n        System.out.println(\"Is valid: \" + result);\\n    }\\n    public static boolean isValid(String s) {\\n        int count = 0;\\n    \\n        for (int i = 0; i < s.length(); i++) {\\n            char bracket = s.charAt(i);\\n    \\n            if (bracket == \\'(\\' || bracket == \\'[\\' || bracket == \\'{\\') {\\n                count++;\\n            } else if (bracket == \\')\\' || bracket == \\']\\' || bracket == \\'}\\') {\\n                count--;\\n                if (count < 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return count == 0;\\n    }\\n}\\'\\nthis is my code without use Stack library "
                    },
                    {
                        "username": "natan20200679",
                        "content": "Congratulations! I really liked of your solution, which is simply conditional."
                    },
                    {
                        "username": "_hunt",
                        "content": "try using stack to push & pop then compare"
                    },
                    {
                        "username": "mishanin",
                        "content": "I saw the hint. General idea is loop through the string and if you see opening brackets  - place CLOSING brackets into stack(array push) and if you see closing brackets - compare them with the last in the stack..."
                    },
                    {
                        "username": "fatimaArshad10",
                        "content": "I started by using simple \"if\" statements, without using nested conditions. Afterward, I set up an empty container to hold characters for later condition evaluation. "
                    },
                    {
                        "username": "AatmanMantri",
                        "content": "How is  `s = \"(){}}{\"` a valid string?"
                    },
                    {
                        "username": "natan20200679",
                        "content": "[@AatmanMantri](/AatmanMantri) That! I will modify the code according to the solution of one of you to fix it."
                    },
                    {
                        "username": "AatmanMantri",
                        "content": "[@natan20200679](/natan20200679) but why is this a valid case? `}` (closing bracket) is before `{` (open bracket). which shouldn\\'t be allowed, right? or am i missing something?"
                    },
                    {
                        "username": "natan20200679",
                        "content": "I confess that I did not consider adding case tests. Thank you friend."
                    },
                    {
                        "username": "natan20200679",
                        "content": "The problem runs correctly in the IDE and here, but it always throws a runtime error here, in the line 8. I would like some help to fix this. "
                    },
                    {
                        "username": "Launchpad",
                        "content": "take \\'([)]\\' as a case, the brackets close in the correct order but for this problem it\\'s invalid. I think the question is unclear, because if this case is false then the question should be something like \"the opening and closing brackets have to be consecutive\"?"
                    },
                    {
                        "username": "s8900830",
                        "content": "        dict={\"(\":\")\",\"[\":\"]\",\"{\":\"}\"}\\n        for name,key in dict.items():\\n            if name in s:\\n                if key in s:\\n                    return \\'true\\'\\n                else:\\n                    return \\'false\\'\\n\\nIn Case3 is Wrong Answer \\uFF0C Why\\uFF1F "
                    }
                ]
            },
            {
                "id": 2027562,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Stolen from Codewars"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Bring it back to Codewars"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Does anyone know how to do it with space complexity O(1). "
                    },
                    {
                        "username": "brucenguyen1852",
                        "content": "\\'import java.util.Scanner;\\n\\npublic class ValidParentheses {\\n    // Given a string s containing just the characters \\'(\\', \\')\\', \\'{\\', \\'}\\', \\'[\\' and\\n    // \\']\\', determine if the input string is valid.\\n\\n    // An input string is valid if:\\n\\n    // Open brackets must be closed by the same type of brackets.\\n    // Open brackets must be closed in the correct order.\\n    // Every close bracket has a corresponding open bracket of the same type.\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n\\n        System.out.print(\"Enter a string of parentheses: \");\\n        String input = scanner.nextLine();\\n\\n        scanner.close();\\n\\n        boolean result = isValid(input);\\n        System.out.println(\"Is valid: \" + result);\\n    }\\n    public static boolean isValid(String s) {\\n        int count = 0;\\n    \\n        for (int i = 0; i < s.length(); i++) {\\n            char bracket = s.charAt(i);\\n    \\n            if (bracket == \\'(\\' || bracket == \\'[\\' || bracket == \\'{\\') {\\n                count++;\\n            } else if (bracket == \\')\\' || bracket == \\']\\' || bracket == \\'}\\') {\\n                count--;\\n                if (count < 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return count == 0;\\n    }\\n}\\'\\nthis is my code without use Stack library "
                    },
                    {
                        "username": "natan20200679",
                        "content": "Congratulations! I really liked of your solution, which is simply conditional."
                    },
                    {
                        "username": "_hunt",
                        "content": "try using stack to push & pop then compare"
                    },
                    {
                        "username": "mishanin",
                        "content": "I saw the hint. General idea is loop through the string and if you see opening brackets  - place CLOSING brackets into stack(array push) and if you see closing brackets - compare them with the last in the stack..."
                    },
                    {
                        "username": "fatimaArshad10",
                        "content": "I started by using simple \"if\" statements, without using nested conditions. Afterward, I set up an empty container to hold characters for later condition evaluation. "
                    },
                    {
                        "username": "AatmanMantri",
                        "content": "How is  `s = \"(){}}{\"` a valid string?"
                    },
                    {
                        "username": "natan20200679",
                        "content": "[@AatmanMantri](/AatmanMantri) That! I will modify the code according to the solution of one of you to fix it."
                    },
                    {
                        "username": "AatmanMantri",
                        "content": "[@natan20200679](/natan20200679) but why is this a valid case? `}` (closing bracket) is before `{` (open bracket). which shouldn\\'t be allowed, right? or am i missing something?"
                    },
                    {
                        "username": "natan20200679",
                        "content": "I confess that I did not consider adding case tests. Thank you friend."
                    },
                    {
                        "username": "natan20200679",
                        "content": "The problem runs correctly in the IDE and here, but it always throws a runtime error here, in the line 8. I would like some help to fix this. "
                    },
                    {
                        "username": "Launchpad",
                        "content": "take \\'([)]\\' as a case, the brackets close in the correct order but for this problem it\\'s invalid. I think the question is unclear, because if this case is false then the question should be something like \"the opening and closing brackets have to be consecutive\"?"
                    },
                    {
                        "username": "s8900830",
                        "content": "        dict={\"(\":\")\",\"[\":\"]\",\"{\":\"}\"}\\n        for name,key in dict.items():\\n            if name in s:\\n                if key in s:\\n                    return \\'true\\'\\n                else:\\n                    return \\'false\\'\\n\\nIn Case3 is Wrong Answer \\uFF0C Why\\uFF1F "
                    }
                ]
            },
            {
                "id": 2027403,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Stolen from Codewars"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Bring it back to Codewars"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Does anyone know how to do it with space complexity O(1). "
                    },
                    {
                        "username": "brucenguyen1852",
                        "content": "\\'import java.util.Scanner;\\n\\npublic class ValidParentheses {\\n    // Given a string s containing just the characters \\'(\\', \\')\\', \\'{\\', \\'}\\', \\'[\\' and\\n    // \\']\\', determine if the input string is valid.\\n\\n    // An input string is valid if:\\n\\n    // Open brackets must be closed by the same type of brackets.\\n    // Open brackets must be closed in the correct order.\\n    // Every close bracket has a corresponding open bracket of the same type.\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n\\n        System.out.print(\"Enter a string of parentheses: \");\\n        String input = scanner.nextLine();\\n\\n        scanner.close();\\n\\n        boolean result = isValid(input);\\n        System.out.println(\"Is valid: \" + result);\\n    }\\n    public static boolean isValid(String s) {\\n        int count = 0;\\n    \\n        for (int i = 0; i < s.length(); i++) {\\n            char bracket = s.charAt(i);\\n    \\n            if (bracket == \\'(\\' || bracket == \\'[\\' || bracket == \\'{\\') {\\n                count++;\\n            } else if (bracket == \\')\\' || bracket == \\']\\' || bracket == \\'}\\') {\\n                count--;\\n                if (count < 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return count == 0;\\n    }\\n}\\'\\nthis is my code without use Stack library "
                    },
                    {
                        "username": "natan20200679",
                        "content": "Congratulations! I really liked of your solution, which is simply conditional."
                    },
                    {
                        "username": "_hunt",
                        "content": "try using stack to push & pop then compare"
                    },
                    {
                        "username": "mishanin",
                        "content": "I saw the hint. General idea is loop through the string and if you see opening brackets  - place CLOSING brackets into stack(array push) and if you see closing brackets - compare them with the last in the stack..."
                    },
                    {
                        "username": "fatimaArshad10",
                        "content": "I started by using simple \"if\" statements, without using nested conditions. Afterward, I set up an empty container to hold characters for later condition evaluation. "
                    },
                    {
                        "username": "AatmanMantri",
                        "content": "How is  `s = \"(){}}{\"` a valid string?"
                    },
                    {
                        "username": "natan20200679",
                        "content": "[@AatmanMantri](/AatmanMantri) That! I will modify the code according to the solution of one of you to fix it."
                    },
                    {
                        "username": "AatmanMantri",
                        "content": "[@natan20200679](/natan20200679) but why is this a valid case? `}` (closing bracket) is before `{` (open bracket). which shouldn\\'t be allowed, right? or am i missing something?"
                    },
                    {
                        "username": "natan20200679",
                        "content": "I confess that I did not consider adding case tests. Thank you friend."
                    },
                    {
                        "username": "natan20200679",
                        "content": "The problem runs correctly in the IDE and here, but it always throws a runtime error here, in the line 8. I would like some help to fix this. "
                    },
                    {
                        "username": "Launchpad",
                        "content": "take \\'([)]\\' as a case, the brackets close in the correct order but for this problem it\\'s invalid. I think the question is unclear, because if this case is false then the question should be something like \"the opening and closing brackets have to be consecutive\"?"
                    },
                    {
                        "username": "s8900830",
                        "content": "        dict={\"(\":\")\",\"[\":\"]\",\"{\":\"}\"}\\n        for name,key in dict.items():\\n            if name in s:\\n                if key in s:\\n                    return \\'true\\'\\n                else:\\n                    return \\'false\\'\\n\\nIn Case3 is Wrong Answer \\uFF0C Why\\uFF1F "
                    }
                ]
            },
            {
                "id": 2027374,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Stolen from Codewars"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Bring it back to Codewars"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Does anyone know how to do it with space complexity O(1). "
                    },
                    {
                        "username": "brucenguyen1852",
                        "content": "\\'import java.util.Scanner;\\n\\npublic class ValidParentheses {\\n    // Given a string s containing just the characters \\'(\\', \\')\\', \\'{\\', \\'}\\', \\'[\\' and\\n    // \\']\\', determine if the input string is valid.\\n\\n    // An input string is valid if:\\n\\n    // Open brackets must be closed by the same type of brackets.\\n    // Open brackets must be closed in the correct order.\\n    // Every close bracket has a corresponding open bracket of the same type.\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n\\n        System.out.print(\"Enter a string of parentheses: \");\\n        String input = scanner.nextLine();\\n\\n        scanner.close();\\n\\n        boolean result = isValid(input);\\n        System.out.println(\"Is valid: \" + result);\\n    }\\n    public static boolean isValid(String s) {\\n        int count = 0;\\n    \\n        for (int i = 0; i < s.length(); i++) {\\n            char bracket = s.charAt(i);\\n    \\n            if (bracket == \\'(\\' || bracket == \\'[\\' || bracket == \\'{\\') {\\n                count++;\\n            } else if (bracket == \\')\\' || bracket == \\']\\' || bracket == \\'}\\') {\\n                count--;\\n                if (count < 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return count == 0;\\n    }\\n}\\'\\nthis is my code without use Stack library "
                    },
                    {
                        "username": "natan20200679",
                        "content": "Congratulations! I really liked of your solution, which is simply conditional."
                    },
                    {
                        "username": "_hunt",
                        "content": "try using stack to push & pop then compare"
                    },
                    {
                        "username": "mishanin",
                        "content": "I saw the hint. General idea is loop through the string and if you see opening brackets  - place CLOSING brackets into stack(array push) and if you see closing brackets - compare them with the last in the stack..."
                    },
                    {
                        "username": "fatimaArshad10",
                        "content": "I started by using simple \"if\" statements, without using nested conditions. Afterward, I set up an empty container to hold characters for later condition evaluation. "
                    },
                    {
                        "username": "AatmanMantri",
                        "content": "How is  `s = \"(){}}{\"` a valid string?"
                    },
                    {
                        "username": "natan20200679",
                        "content": "[@AatmanMantri](/AatmanMantri) That! I will modify the code according to the solution of one of you to fix it."
                    },
                    {
                        "username": "AatmanMantri",
                        "content": "[@natan20200679](/natan20200679) but why is this a valid case? `}` (closing bracket) is before `{` (open bracket). which shouldn\\'t be allowed, right? or am i missing something?"
                    },
                    {
                        "username": "natan20200679",
                        "content": "I confess that I did not consider adding case tests. Thank you friend."
                    },
                    {
                        "username": "natan20200679",
                        "content": "The problem runs correctly in the IDE and here, but it always throws a runtime error here, in the line 8. I would like some help to fix this. "
                    },
                    {
                        "username": "Launchpad",
                        "content": "take \\'([)]\\' as a case, the brackets close in the correct order but for this problem it\\'s invalid. I think the question is unclear, because if this case is false then the question should be something like \"the opening and closing brackets have to be consecutive\"?"
                    },
                    {
                        "username": "s8900830",
                        "content": "        dict={\"(\":\")\",\"[\":\"]\",\"{\":\"}\"}\\n        for name,key in dict.items():\\n            if name in s:\\n                if key in s:\\n                    return \\'true\\'\\n                else:\\n                    return \\'false\\'\\n\\nIn Case3 is Wrong Answer \\uFF0C Why\\uFF1F "
                    }
                ]
            },
            {
                "id": 2026666,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Stolen from Codewars"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Bring it back to Codewars"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Does anyone know how to do it with space complexity O(1). "
                    },
                    {
                        "username": "brucenguyen1852",
                        "content": "\\'import java.util.Scanner;\\n\\npublic class ValidParentheses {\\n    // Given a string s containing just the characters \\'(\\', \\')\\', \\'{\\', \\'}\\', \\'[\\' and\\n    // \\']\\', determine if the input string is valid.\\n\\n    // An input string is valid if:\\n\\n    // Open brackets must be closed by the same type of brackets.\\n    // Open brackets must be closed in the correct order.\\n    // Every close bracket has a corresponding open bracket of the same type.\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n\\n        System.out.print(\"Enter a string of parentheses: \");\\n        String input = scanner.nextLine();\\n\\n        scanner.close();\\n\\n        boolean result = isValid(input);\\n        System.out.println(\"Is valid: \" + result);\\n    }\\n    public static boolean isValid(String s) {\\n        int count = 0;\\n    \\n        for (int i = 0; i < s.length(); i++) {\\n            char bracket = s.charAt(i);\\n    \\n            if (bracket == \\'(\\' || bracket == \\'[\\' || bracket == \\'{\\') {\\n                count++;\\n            } else if (bracket == \\')\\' || bracket == \\']\\' || bracket == \\'}\\') {\\n                count--;\\n                if (count < 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return count == 0;\\n    }\\n}\\'\\nthis is my code without use Stack library "
                    },
                    {
                        "username": "natan20200679",
                        "content": "Congratulations! I really liked of your solution, which is simply conditional."
                    },
                    {
                        "username": "_hunt",
                        "content": "try using stack to push & pop then compare"
                    },
                    {
                        "username": "mishanin",
                        "content": "I saw the hint. General idea is loop through the string and if you see opening brackets  - place CLOSING brackets into stack(array push) and if you see closing brackets - compare them with the last in the stack..."
                    },
                    {
                        "username": "fatimaArshad10",
                        "content": "I started by using simple \"if\" statements, without using nested conditions. Afterward, I set up an empty container to hold characters for later condition evaluation. "
                    },
                    {
                        "username": "AatmanMantri",
                        "content": "How is  `s = \"(){}}{\"` a valid string?"
                    },
                    {
                        "username": "natan20200679",
                        "content": "[@AatmanMantri](/AatmanMantri) That! I will modify the code according to the solution of one of you to fix it."
                    },
                    {
                        "username": "AatmanMantri",
                        "content": "[@natan20200679](/natan20200679) but why is this a valid case? `}` (closing bracket) is before `{` (open bracket). which shouldn\\'t be allowed, right? or am i missing something?"
                    },
                    {
                        "username": "natan20200679",
                        "content": "I confess that I did not consider adding case tests. Thank you friend."
                    },
                    {
                        "username": "natan20200679",
                        "content": "The problem runs correctly in the IDE and here, but it always throws a runtime error here, in the line 8. I would like some help to fix this. "
                    },
                    {
                        "username": "Launchpad",
                        "content": "take \\'([)]\\' as a case, the brackets close in the correct order but for this problem it\\'s invalid. I think the question is unclear, because if this case is false then the question should be something like \"the opening and closing brackets have to be consecutive\"?"
                    },
                    {
                        "username": "s8900830",
                        "content": "        dict={\"(\":\")\",\"[\":\"]\",\"{\":\"}\"}\\n        for name,key in dict.items():\\n            if name in s:\\n                if key in s:\\n                    return \\'true\\'\\n                else:\\n                    return \\'false\\'\\n\\nIn Case3 is Wrong Answer \\uFF0C Why\\uFF1F "
                    }
                ]
            },
            {
                "id": 2025838,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Stolen from Codewars"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Bring it back to Codewars"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Does anyone know how to do it with space complexity O(1). "
                    },
                    {
                        "username": "brucenguyen1852",
                        "content": "\\'import java.util.Scanner;\\n\\npublic class ValidParentheses {\\n    // Given a string s containing just the characters \\'(\\', \\')\\', \\'{\\', \\'}\\', \\'[\\' and\\n    // \\']\\', determine if the input string is valid.\\n\\n    // An input string is valid if:\\n\\n    // Open brackets must be closed by the same type of brackets.\\n    // Open brackets must be closed in the correct order.\\n    // Every close bracket has a corresponding open bracket of the same type.\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n\\n        System.out.print(\"Enter a string of parentheses: \");\\n        String input = scanner.nextLine();\\n\\n        scanner.close();\\n\\n        boolean result = isValid(input);\\n        System.out.println(\"Is valid: \" + result);\\n    }\\n    public static boolean isValid(String s) {\\n        int count = 0;\\n    \\n        for (int i = 0; i < s.length(); i++) {\\n            char bracket = s.charAt(i);\\n    \\n            if (bracket == \\'(\\' || bracket == \\'[\\' || bracket == \\'{\\') {\\n                count++;\\n            } else if (bracket == \\')\\' || bracket == \\']\\' || bracket == \\'}\\') {\\n                count--;\\n                if (count < 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return count == 0;\\n    }\\n}\\'\\nthis is my code without use Stack library "
                    },
                    {
                        "username": "natan20200679",
                        "content": "Congratulations! I really liked of your solution, which is simply conditional."
                    },
                    {
                        "username": "_hunt",
                        "content": "try using stack to push & pop then compare"
                    },
                    {
                        "username": "mishanin",
                        "content": "I saw the hint. General idea is loop through the string and if you see opening brackets  - place CLOSING brackets into stack(array push) and if you see closing brackets - compare them with the last in the stack..."
                    },
                    {
                        "username": "fatimaArshad10",
                        "content": "I started by using simple \"if\" statements, without using nested conditions. Afterward, I set up an empty container to hold characters for later condition evaluation. "
                    },
                    {
                        "username": "AatmanMantri",
                        "content": "How is  `s = \"(){}}{\"` a valid string?"
                    },
                    {
                        "username": "natan20200679",
                        "content": "[@AatmanMantri](/AatmanMantri) That! I will modify the code according to the solution of one of you to fix it."
                    },
                    {
                        "username": "AatmanMantri",
                        "content": "[@natan20200679](/natan20200679) but why is this a valid case? `}` (closing bracket) is before `{` (open bracket). which shouldn\\'t be allowed, right? or am i missing something?"
                    },
                    {
                        "username": "natan20200679",
                        "content": "I confess that I did not consider adding case tests. Thank you friend."
                    },
                    {
                        "username": "natan20200679",
                        "content": "The problem runs correctly in the IDE and here, but it always throws a runtime error here, in the line 8. I would like some help to fix this. "
                    },
                    {
                        "username": "Launchpad",
                        "content": "take \\'([)]\\' as a case, the brackets close in the correct order but for this problem it\\'s invalid. I think the question is unclear, because if this case is false then the question should be something like \"the opening and closing brackets have to be consecutive\"?"
                    },
                    {
                        "username": "s8900830",
                        "content": "        dict={\"(\":\")\",\"[\":\"]\",\"{\":\"}\"}\\n        for name,key in dict.items():\\n            if name in s:\\n                if key in s:\\n                    return \\'true\\'\\n                else:\\n                    return \\'false\\'\\n\\nIn Case3 is Wrong Answer \\uFF0C Why\\uFF1F "
                    }
                ]
            },
            {
                "id": 2019417,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Stolen from Codewars"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Bring it back to Codewars"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Does anyone know how to do it with space complexity O(1). "
                    },
                    {
                        "username": "brucenguyen1852",
                        "content": "\\'import java.util.Scanner;\\n\\npublic class ValidParentheses {\\n    // Given a string s containing just the characters \\'(\\', \\')\\', \\'{\\', \\'}\\', \\'[\\' and\\n    // \\']\\', determine if the input string is valid.\\n\\n    // An input string is valid if:\\n\\n    // Open brackets must be closed by the same type of brackets.\\n    // Open brackets must be closed in the correct order.\\n    // Every close bracket has a corresponding open bracket of the same type.\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n\\n        System.out.print(\"Enter a string of parentheses: \");\\n        String input = scanner.nextLine();\\n\\n        scanner.close();\\n\\n        boolean result = isValid(input);\\n        System.out.println(\"Is valid: \" + result);\\n    }\\n    public static boolean isValid(String s) {\\n        int count = 0;\\n    \\n        for (int i = 0; i < s.length(); i++) {\\n            char bracket = s.charAt(i);\\n    \\n            if (bracket == \\'(\\' || bracket == \\'[\\' || bracket == \\'{\\') {\\n                count++;\\n            } else if (bracket == \\')\\' || bracket == \\']\\' || bracket == \\'}\\') {\\n                count--;\\n                if (count < 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return count == 0;\\n    }\\n}\\'\\nthis is my code without use Stack library "
                    },
                    {
                        "username": "natan20200679",
                        "content": "Congratulations! I really liked of your solution, which is simply conditional."
                    },
                    {
                        "username": "_hunt",
                        "content": "try using stack to push & pop then compare"
                    },
                    {
                        "username": "mishanin",
                        "content": "I saw the hint. General idea is loop through the string and if you see opening brackets  - place CLOSING brackets into stack(array push) and if you see closing brackets - compare them with the last in the stack..."
                    },
                    {
                        "username": "fatimaArshad10",
                        "content": "I started by using simple \"if\" statements, without using nested conditions. Afterward, I set up an empty container to hold characters for later condition evaluation. "
                    },
                    {
                        "username": "AatmanMantri",
                        "content": "How is  `s = \"(){}}{\"` a valid string?"
                    },
                    {
                        "username": "natan20200679",
                        "content": "[@AatmanMantri](/AatmanMantri) That! I will modify the code according to the solution of one of you to fix it."
                    },
                    {
                        "username": "AatmanMantri",
                        "content": "[@natan20200679](/natan20200679) but why is this a valid case? `}` (closing bracket) is before `{` (open bracket). which shouldn\\'t be allowed, right? or am i missing something?"
                    },
                    {
                        "username": "natan20200679",
                        "content": "I confess that I did not consider adding case tests. Thank you friend."
                    },
                    {
                        "username": "natan20200679",
                        "content": "The problem runs correctly in the IDE and here, but it always throws a runtime error here, in the line 8. I would like some help to fix this. "
                    },
                    {
                        "username": "Launchpad",
                        "content": "take \\'([)]\\' as a case, the brackets close in the correct order but for this problem it\\'s invalid. I think the question is unclear, because if this case is false then the question should be something like \"the opening and closing brackets have to be consecutive\"?"
                    },
                    {
                        "username": "s8900830",
                        "content": "        dict={\"(\":\")\",\"[\":\"]\",\"{\":\"}\"}\\n        for name,key in dict.items():\\n            if name in s:\\n                if key in s:\\n                    return \\'true\\'\\n                else:\\n                    return \\'false\\'\\n\\nIn Case3 is Wrong Answer \\uFF0C Why\\uFF1F "
                    }
                ]
            },
            {
                "id": 2017472,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Stolen from Codewars"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Bring it back to Codewars"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Does anyone know how to do it with space complexity O(1). "
                    },
                    {
                        "username": "brucenguyen1852",
                        "content": "\\'import java.util.Scanner;\\n\\npublic class ValidParentheses {\\n    // Given a string s containing just the characters \\'(\\', \\')\\', \\'{\\', \\'}\\', \\'[\\' and\\n    // \\']\\', determine if the input string is valid.\\n\\n    // An input string is valid if:\\n\\n    // Open brackets must be closed by the same type of brackets.\\n    // Open brackets must be closed in the correct order.\\n    // Every close bracket has a corresponding open bracket of the same type.\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n\\n        System.out.print(\"Enter a string of parentheses: \");\\n        String input = scanner.nextLine();\\n\\n        scanner.close();\\n\\n        boolean result = isValid(input);\\n        System.out.println(\"Is valid: \" + result);\\n    }\\n    public static boolean isValid(String s) {\\n        int count = 0;\\n    \\n        for (int i = 0; i < s.length(); i++) {\\n            char bracket = s.charAt(i);\\n    \\n            if (bracket == \\'(\\' || bracket == \\'[\\' || bracket == \\'{\\') {\\n                count++;\\n            } else if (bracket == \\')\\' || bracket == \\']\\' || bracket == \\'}\\') {\\n                count--;\\n                if (count < 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return count == 0;\\n    }\\n}\\'\\nthis is my code without use Stack library "
                    },
                    {
                        "username": "natan20200679",
                        "content": "Congratulations! I really liked of your solution, which is simply conditional."
                    },
                    {
                        "username": "_hunt",
                        "content": "try using stack to push & pop then compare"
                    },
                    {
                        "username": "mishanin",
                        "content": "I saw the hint. General idea is loop through the string and if you see opening brackets  - place CLOSING brackets into stack(array push) and if you see closing brackets - compare them with the last in the stack..."
                    },
                    {
                        "username": "fatimaArshad10",
                        "content": "I started by using simple \"if\" statements, without using nested conditions. Afterward, I set up an empty container to hold characters for later condition evaluation. "
                    },
                    {
                        "username": "AatmanMantri",
                        "content": "How is  `s = \"(){}}{\"` a valid string?"
                    },
                    {
                        "username": "natan20200679",
                        "content": "[@AatmanMantri](/AatmanMantri) That! I will modify the code according to the solution of one of you to fix it."
                    },
                    {
                        "username": "AatmanMantri",
                        "content": "[@natan20200679](/natan20200679) but why is this a valid case? `}` (closing bracket) is before `{` (open bracket). which shouldn\\'t be allowed, right? or am i missing something?"
                    },
                    {
                        "username": "natan20200679",
                        "content": "I confess that I did not consider adding case tests. Thank you friend."
                    },
                    {
                        "username": "natan20200679",
                        "content": "The problem runs correctly in the IDE and here, but it always throws a runtime error here, in the line 8. I would like some help to fix this. "
                    },
                    {
                        "username": "Launchpad",
                        "content": "take \\'([)]\\' as a case, the brackets close in the correct order but for this problem it\\'s invalid. I think the question is unclear, because if this case is false then the question should be something like \"the opening and closing brackets have to be consecutive\"?"
                    },
                    {
                        "username": "s8900830",
                        "content": "        dict={\"(\":\")\",\"[\":\"]\",\"{\":\"}\"}\\n        for name,key in dict.items():\\n            if name in s:\\n                if key in s:\\n                    return \\'true\\'\\n                else:\\n                    return \\'false\\'\\n\\nIn Case3 is Wrong Answer \\uFF0C Why\\uFF1F "
                    }
                ]
            },
            {
                "id": 2017077,
                "content": [
                    {
                        "username": "rcon9494",
                        "content": "For best results when you submit, I recommend adding test cases:\\n `\"([)]\"`, `\"({}[])\"`, `\")\"`, `\"[\"`\\nGood luck!"
                    },
                    {
                        "username": "Shivani_Miryala",
                        "content": "Could someone help me all the testcases are not passing for my code(in Python3)::\\n\\nTest Case Type(which it is failing):\\nEx: \\ns = \"{[]}\"\\n\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n      \\n        s1 = list(str(s))\\n        i =0\\n        n = len(s1)\\n        count = 0\\n        while(i<n):\\n            if(s1[i] == \\'(\\' and s1[i + 1] == \\')\\' or s1[i] == \\'[\\' and s1[i+1] == \\']\\' or s1[i]  == \\'{\\' and s1[i+1] == \\'}\\'):\\n                i += 2\\n                count += 2\\n            \\n    \\n            else:\\n                return False\\n                break\\n        if count == n:\\n            return True\\n\\n\\n"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "It doesn\\'t clarify if the brackets in the input string that come first are guaranteed to be opening brackets. For example, by the constraints of the question, )( is a valid input string, but not sure if I needed to code my answer around that or not."
                    },
                    {
                        "username": "user2940mt",
                        "content": "what is up with the last test case(93), they have not given any input\\uD83D\\uDE22"
                    },
                    {
                        "username": "haardtripathi",
                        "content": "can someone tell me what is the issue with my solution\\n\\n\\n\\n\\n\\n\\nclass Solution(object):\\n    \\n    def isValid(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        \\n        self.open=[\"(\",\\'[\\',\\'{\\']\\n        self.close=[\")\",\\']\\',\\'}\\']\\n        self.stack=[]\\n        for par in s:\\n            if(par in self.open):\\n                self.stack.append(par)\\n            if(len(self.stack)==1 or len(self.stack)==0):\\n                a=0\\n            else:\\n                a=len(self.stack)-1\\n            if par in self.close:\\n                if self.stack!=[]:\\n                    if self.close.index(par)==self.open.index(self.stack[a]):\\n                        self.stack.remove(self.stack[a])\\n\\n                else:\\n                    self.stack.append(par)\\n    \\n        if(self.stack==[]):\\n            return \\'true\\'\\n        else:\\n            return \\'false\\'\\ns=Solution()\\n\\n"
                    },
                    {
                        "username": "00sayan00",
                        "content": "int k=s.length();\\n        if(k!=s.length()){\\n             return false; \\n            }\\n            else{\\n                return true;\\n            }\\n    }\\n\\nanyone  plz correct the code and highlight what is wrong "
                    },
                    {
                        "username": "seraphsword",
                        "content": "Your program, unless I\\'m missing something, says \"set k equal to the length of s. Then, if k isn\\'t equal to the length of s, return false.\" It\\'s literally impossible for you to set them as equal on one line, then expect them to not be equal the very next line.\\nWhat you need to check is if the parentheses are in the correct order. Starting out with a check if the length of s is an even number is a good idea, since if it isn\\'t there can\\'t possibly be the proper number of opening and closing brackets. Then you have to figure out how to check that each \\'(\\' comes before a \\')\\' and so on, without ever breaking the order of operations. So \\'([)]\\' would be wrong, because you can\\'t have an opening bracket inside the parentheses without closing it first."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |  BEATS 100%\nI used stack and a map both.\n1. make an empty stack.\n2. keep pushing paranthesis of different type i.e '{' and '[' are different.\n3. if same paranthesis is at top of stack then pop, i.e if current paranthesis is ')' and top of stack is '(' then pop . HERE's a catch , we are considering that ( == ) , { == } and [ == ] , to make them equal we used 'map'. \n4. using this in loop if the string is valid then our stack will become empty till last iteration else if the string is not valid .\n\nI know its hard to get but use pen paper and go through this using stack approach, rest you will be able to do it by yourself.   LEAVE A LIKE PLZ."
                    },
                    {
                        "username": "pardhu333",
                        "content": "Below testcase is failing for me.\\nInput: \"([)]\"\\nExpected: false\\nActual Output: true\\nI don\\'t understand how the expected is false."
                    },
                    {
                        "username": "bautistaaa",
                        "content": "asdsad"
                    },
                    {
                        "username": "cmokbel1",
                        "content": "whoever made this knows that a parentheses is actually just \\'(\\' and \\')\\' right ?"
                    }
                ]
            },
            {
                "id": 2016870,
                "content": [
                    {
                        "username": "rcon9494",
                        "content": "For best results when you submit, I recommend adding test cases:\\n `\"([)]\"`, `\"({}[])\"`, `\")\"`, `\"[\"`\\nGood luck!"
                    },
                    {
                        "username": "Shivani_Miryala",
                        "content": "Could someone help me all the testcases are not passing for my code(in Python3)::\\n\\nTest Case Type(which it is failing):\\nEx: \\ns = \"{[]}\"\\n\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n      \\n        s1 = list(str(s))\\n        i =0\\n        n = len(s1)\\n        count = 0\\n        while(i<n):\\n            if(s1[i] == \\'(\\' and s1[i + 1] == \\')\\' or s1[i] == \\'[\\' and s1[i+1] == \\']\\' or s1[i]  == \\'{\\' and s1[i+1] == \\'}\\'):\\n                i += 2\\n                count += 2\\n            \\n    \\n            else:\\n                return False\\n                break\\n        if count == n:\\n            return True\\n\\n\\n"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "It doesn\\'t clarify if the brackets in the input string that come first are guaranteed to be opening brackets. For example, by the constraints of the question, )( is a valid input string, but not sure if I needed to code my answer around that or not."
                    },
                    {
                        "username": "user2940mt",
                        "content": "what is up with the last test case(93), they have not given any input\\uD83D\\uDE22"
                    },
                    {
                        "username": "haardtripathi",
                        "content": "can someone tell me what is the issue with my solution\\n\\n\\n\\n\\n\\n\\nclass Solution(object):\\n    \\n    def isValid(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        \\n        self.open=[\"(\",\\'[\\',\\'{\\']\\n        self.close=[\")\",\\']\\',\\'}\\']\\n        self.stack=[]\\n        for par in s:\\n            if(par in self.open):\\n                self.stack.append(par)\\n            if(len(self.stack)==1 or len(self.stack)==0):\\n                a=0\\n            else:\\n                a=len(self.stack)-1\\n            if par in self.close:\\n                if self.stack!=[]:\\n                    if self.close.index(par)==self.open.index(self.stack[a]):\\n                        self.stack.remove(self.stack[a])\\n\\n                else:\\n                    self.stack.append(par)\\n    \\n        if(self.stack==[]):\\n            return \\'true\\'\\n        else:\\n            return \\'false\\'\\ns=Solution()\\n\\n"
                    },
                    {
                        "username": "00sayan00",
                        "content": "int k=s.length();\\n        if(k!=s.length()){\\n             return false; \\n            }\\n            else{\\n                return true;\\n            }\\n    }\\n\\nanyone  plz correct the code and highlight what is wrong "
                    },
                    {
                        "username": "seraphsword",
                        "content": "Your program, unless I\\'m missing something, says \"set k equal to the length of s. Then, if k isn\\'t equal to the length of s, return false.\" It\\'s literally impossible for you to set them as equal on one line, then expect them to not be equal the very next line.\\nWhat you need to check is if the parentheses are in the correct order. Starting out with a check if the length of s is an even number is a good idea, since if it isn\\'t there can\\'t possibly be the proper number of opening and closing brackets. Then you have to figure out how to check that each \\'(\\' comes before a \\')\\' and so on, without ever breaking the order of operations. So \\'([)]\\' would be wrong, because you can\\'t have an opening bracket inside the parentheses without closing it first."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |  BEATS 100%\nI used stack and a map both.\n1. make an empty stack.\n2. keep pushing paranthesis of different type i.e '{' and '[' are different.\n3. if same paranthesis is at top of stack then pop, i.e if current paranthesis is ')' and top of stack is '(' then pop . HERE's a catch , we are considering that ( == ) , { == } and [ == ] , to make them equal we used 'map'. \n4. using this in loop if the string is valid then our stack will become empty till last iteration else if the string is not valid .\n\nI know its hard to get but use pen paper and go through this using stack approach, rest you will be able to do it by yourself.   LEAVE A LIKE PLZ."
                    },
                    {
                        "username": "pardhu333",
                        "content": "Below testcase is failing for me.\\nInput: \"([)]\"\\nExpected: false\\nActual Output: true\\nI don\\'t understand how the expected is false."
                    },
                    {
                        "username": "bautistaaa",
                        "content": "asdsad"
                    },
                    {
                        "username": "cmokbel1",
                        "content": "whoever made this knows that a parentheses is actually just \\'(\\' and \\')\\' right ?"
                    }
                ]
            },
            {
                "id": 2014990,
                "content": [
                    {
                        "username": "rcon9494",
                        "content": "For best results when you submit, I recommend adding test cases:\\n `\"([)]\"`, `\"({}[])\"`, `\")\"`, `\"[\"`\\nGood luck!"
                    },
                    {
                        "username": "Shivani_Miryala",
                        "content": "Could someone help me all the testcases are not passing for my code(in Python3)::\\n\\nTest Case Type(which it is failing):\\nEx: \\ns = \"{[]}\"\\n\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n      \\n        s1 = list(str(s))\\n        i =0\\n        n = len(s1)\\n        count = 0\\n        while(i<n):\\n            if(s1[i] == \\'(\\' and s1[i + 1] == \\')\\' or s1[i] == \\'[\\' and s1[i+1] == \\']\\' or s1[i]  == \\'{\\' and s1[i+1] == \\'}\\'):\\n                i += 2\\n                count += 2\\n            \\n    \\n            else:\\n                return False\\n                break\\n        if count == n:\\n            return True\\n\\n\\n"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "It doesn\\'t clarify if the brackets in the input string that come first are guaranteed to be opening brackets. For example, by the constraints of the question, )( is a valid input string, but not sure if I needed to code my answer around that or not."
                    },
                    {
                        "username": "user2940mt",
                        "content": "what is up with the last test case(93), they have not given any input\\uD83D\\uDE22"
                    },
                    {
                        "username": "haardtripathi",
                        "content": "can someone tell me what is the issue with my solution\\n\\n\\n\\n\\n\\n\\nclass Solution(object):\\n    \\n    def isValid(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        \\n        self.open=[\"(\",\\'[\\',\\'{\\']\\n        self.close=[\")\",\\']\\',\\'}\\']\\n        self.stack=[]\\n        for par in s:\\n            if(par in self.open):\\n                self.stack.append(par)\\n            if(len(self.stack)==1 or len(self.stack)==0):\\n                a=0\\n            else:\\n                a=len(self.stack)-1\\n            if par in self.close:\\n                if self.stack!=[]:\\n                    if self.close.index(par)==self.open.index(self.stack[a]):\\n                        self.stack.remove(self.stack[a])\\n\\n                else:\\n                    self.stack.append(par)\\n    \\n        if(self.stack==[]):\\n            return \\'true\\'\\n        else:\\n            return \\'false\\'\\ns=Solution()\\n\\n"
                    },
                    {
                        "username": "00sayan00",
                        "content": "int k=s.length();\\n        if(k!=s.length()){\\n             return false; \\n            }\\n            else{\\n                return true;\\n            }\\n    }\\n\\nanyone  plz correct the code and highlight what is wrong "
                    },
                    {
                        "username": "seraphsword",
                        "content": "Your program, unless I\\'m missing something, says \"set k equal to the length of s. Then, if k isn\\'t equal to the length of s, return false.\" It\\'s literally impossible for you to set them as equal on one line, then expect them to not be equal the very next line.\\nWhat you need to check is if the parentheses are in the correct order. Starting out with a check if the length of s is an even number is a good idea, since if it isn\\'t there can\\'t possibly be the proper number of opening and closing brackets. Then you have to figure out how to check that each \\'(\\' comes before a \\')\\' and so on, without ever breaking the order of operations. So \\'([)]\\' would be wrong, because you can\\'t have an opening bracket inside the parentheses without closing it first."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |  BEATS 100%\nI used stack and a map both.\n1. make an empty stack.\n2. keep pushing paranthesis of different type i.e '{' and '[' are different.\n3. if same paranthesis is at top of stack then pop, i.e if current paranthesis is ')' and top of stack is '(' then pop . HERE's a catch , we are considering that ( == ) , { == } and [ == ] , to make them equal we used 'map'. \n4. using this in loop if the string is valid then our stack will become empty till last iteration else if the string is not valid .\n\nI know its hard to get but use pen paper and go through this using stack approach, rest you will be able to do it by yourself.   LEAVE A LIKE PLZ."
                    },
                    {
                        "username": "pardhu333",
                        "content": "Below testcase is failing for me.\\nInput: \"([)]\"\\nExpected: false\\nActual Output: true\\nI don\\'t understand how the expected is false."
                    },
                    {
                        "username": "bautistaaa",
                        "content": "asdsad"
                    },
                    {
                        "username": "cmokbel1",
                        "content": "whoever made this knows that a parentheses is actually just \\'(\\' and \\')\\' right ?"
                    }
                ]
            },
            {
                "id": 2009844,
                "content": [
                    {
                        "username": "rcon9494",
                        "content": "For best results when you submit, I recommend adding test cases:\\n `\"([)]\"`, `\"({}[])\"`, `\")\"`, `\"[\"`\\nGood luck!"
                    },
                    {
                        "username": "Shivani_Miryala",
                        "content": "Could someone help me all the testcases are not passing for my code(in Python3)::\\n\\nTest Case Type(which it is failing):\\nEx: \\ns = \"{[]}\"\\n\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n      \\n        s1 = list(str(s))\\n        i =0\\n        n = len(s1)\\n        count = 0\\n        while(i<n):\\n            if(s1[i] == \\'(\\' and s1[i + 1] == \\')\\' or s1[i] == \\'[\\' and s1[i+1] == \\']\\' or s1[i]  == \\'{\\' and s1[i+1] == \\'}\\'):\\n                i += 2\\n                count += 2\\n            \\n    \\n            else:\\n                return False\\n                break\\n        if count == n:\\n            return True\\n\\n\\n"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "It doesn\\'t clarify if the brackets in the input string that come first are guaranteed to be opening brackets. For example, by the constraints of the question, )( is a valid input string, but not sure if I needed to code my answer around that or not."
                    },
                    {
                        "username": "user2940mt",
                        "content": "what is up with the last test case(93), they have not given any input\\uD83D\\uDE22"
                    },
                    {
                        "username": "haardtripathi",
                        "content": "can someone tell me what is the issue with my solution\\n\\n\\n\\n\\n\\n\\nclass Solution(object):\\n    \\n    def isValid(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        \\n        self.open=[\"(\",\\'[\\',\\'{\\']\\n        self.close=[\")\",\\']\\',\\'}\\']\\n        self.stack=[]\\n        for par in s:\\n            if(par in self.open):\\n                self.stack.append(par)\\n            if(len(self.stack)==1 or len(self.stack)==0):\\n                a=0\\n            else:\\n                a=len(self.stack)-1\\n            if par in self.close:\\n                if self.stack!=[]:\\n                    if self.close.index(par)==self.open.index(self.stack[a]):\\n                        self.stack.remove(self.stack[a])\\n\\n                else:\\n                    self.stack.append(par)\\n    \\n        if(self.stack==[]):\\n            return \\'true\\'\\n        else:\\n            return \\'false\\'\\ns=Solution()\\n\\n"
                    },
                    {
                        "username": "00sayan00",
                        "content": "int k=s.length();\\n        if(k!=s.length()){\\n             return false; \\n            }\\n            else{\\n                return true;\\n            }\\n    }\\n\\nanyone  plz correct the code and highlight what is wrong "
                    },
                    {
                        "username": "seraphsword",
                        "content": "Your program, unless I\\'m missing something, says \"set k equal to the length of s. Then, if k isn\\'t equal to the length of s, return false.\" It\\'s literally impossible for you to set them as equal on one line, then expect them to not be equal the very next line.\\nWhat you need to check is if the parentheses are in the correct order. Starting out with a check if the length of s is an even number is a good idea, since if it isn\\'t there can\\'t possibly be the proper number of opening and closing brackets. Then you have to figure out how to check that each \\'(\\' comes before a \\')\\' and so on, without ever breaking the order of operations. So \\'([)]\\' would be wrong, because you can\\'t have an opening bracket inside the parentheses without closing it first."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |  BEATS 100%\nI used stack and a map both.\n1. make an empty stack.\n2. keep pushing paranthesis of different type i.e '{' and '[' are different.\n3. if same paranthesis is at top of stack then pop, i.e if current paranthesis is ')' and top of stack is '(' then pop . HERE's a catch , we are considering that ( == ) , { == } and [ == ] , to make them equal we used 'map'. \n4. using this in loop if the string is valid then our stack will become empty till last iteration else if the string is not valid .\n\nI know its hard to get but use pen paper and go through this using stack approach, rest you will be able to do it by yourself.   LEAVE A LIKE PLZ."
                    },
                    {
                        "username": "pardhu333",
                        "content": "Below testcase is failing for me.\\nInput: \"([)]\"\\nExpected: false\\nActual Output: true\\nI don\\'t understand how the expected is false."
                    },
                    {
                        "username": "bautistaaa",
                        "content": "asdsad"
                    },
                    {
                        "username": "cmokbel1",
                        "content": "whoever made this knows that a parentheses is actually just \\'(\\' and \\')\\' right ?"
                    }
                ]
            },
            {
                "id": 2009648,
                "content": [
                    {
                        "username": "rcon9494",
                        "content": "For best results when you submit, I recommend adding test cases:\\n `\"([)]\"`, `\"({}[])\"`, `\")\"`, `\"[\"`\\nGood luck!"
                    },
                    {
                        "username": "Shivani_Miryala",
                        "content": "Could someone help me all the testcases are not passing for my code(in Python3)::\\n\\nTest Case Type(which it is failing):\\nEx: \\ns = \"{[]}\"\\n\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n      \\n        s1 = list(str(s))\\n        i =0\\n        n = len(s1)\\n        count = 0\\n        while(i<n):\\n            if(s1[i] == \\'(\\' and s1[i + 1] == \\')\\' or s1[i] == \\'[\\' and s1[i+1] == \\']\\' or s1[i]  == \\'{\\' and s1[i+1] == \\'}\\'):\\n                i += 2\\n                count += 2\\n            \\n    \\n            else:\\n                return False\\n                break\\n        if count == n:\\n            return True\\n\\n\\n"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "It doesn\\'t clarify if the brackets in the input string that come first are guaranteed to be opening brackets. For example, by the constraints of the question, )( is a valid input string, but not sure if I needed to code my answer around that or not."
                    },
                    {
                        "username": "user2940mt",
                        "content": "what is up with the last test case(93), they have not given any input\\uD83D\\uDE22"
                    },
                    {
                        "username": "haardtripathi",
                        "content": "can someone tell me what is the issue with my solution\\n\\n\\n\\n\\n\\n\\nclass Solution(object):\\n    \\n    def isValid(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        \\n        self.open=[\"(\",\\'[\\',\\'{\\']\\n        self.close=[\")\",\\']\\',\\'}\\']\\n        self.stack=[]\\n        for par in s:\\n            if(par in self.open):\\n                self.stack.append(par)\\n            if(len(self.stack)==1 or len(self.stack)==0):\\n                a=0\\n            else:\\n                a=len(self.stack)-1\\n            if par in self.close:\\n                if self.stack!=[]:\\n                    if self.close.index(par)==self.open.index(self.stack[a]):\\n                        self.stack.remove(self.stack[a])\\n\\n                else:\\n                    self.stack.append(par)\\n    \\n        if(self.stack==[]):\\n            return \\'true\\'\\n        else:\\n            return \\'false\\'\\ns=Solution()\\n\\n"
                    },
                    {
                        "username": "00sayan00",
                        "content": "int k=s.length();\\n        if(k!=s.length()){\\n             return false; \\n            }\\n            else{\\n                return true;\\n            }\\n    }\\n\\nanyone  plz correct the code and highlight what is wrong "
                    },
                    {
                        "username": "seraphsword",
                        "content": "Your program, unless I\\'m missing something, says \"set k equal to the length of s. Then, if k isn\\'t equal to the length of s, return false.\" It\\'s literally impossible for you to set them as equal on one line, then expect them to not be equal the very next line.\\nWhat you need to check is if the parentheses are in the correct order. Starting out with a check if the length of s is an even number is a good idea, since if it isn\\'t there can\\'t possibly be the proper number of opening and closing brackets. Then you have to figure out how to check that each \\'(\\' comes before a \\')\\' and so on, without ever breaking the order of operations. So \\'([)]\\' would be wrong, because you can\\'t have an opening bracket inside the parentheses without closing it first."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |  BEATS 100%\nI used stack and a map both.\n1. make an empty stack.\n2. keep pushing paranthesis of different type i.e '{' and '[' are different.\n3. if same paranthesis is at top of stack then pop, i.e if current paranthesis is ')' and top of stack is '(' then pop . HERE's a catch , we are considering that ( == ) , { == } and [ == ] , to make them equal we used 'map'. \n4. using this in loop if the string is valid then our stack will become empty till last iteration else if the string is not valid .\n\nI know its hard to get but use pen paper and go through this using stack approach, rest you will be able to do it by yourself.   LEAVE A LIKE PLZ."
                    },
                    {
                        "username": "pardhu333",
                        "content": "Below testcase is failing for me.\\nInput: \"([)]\"\\nExpected: false\\nActual Output: true\\nI don\\'t understand how the expected is false."
                    },
                    {
                        "username": "bautistaaa",
                        "content": "asdsad"
                    },
                    {
                        "username": "cmokbel1",
                        "content": "whoever made this knows that a parentheses is actually just \\'(\\' and \\')\\' right ?"
                    }
                ]
            },
            {
                "id": 2006037,
                "content": [
                    {
                        "username": "rcon9494",
                        "content": "For best results when you submit, I recommend adding test cases:\\n `\"([)]\"`, `\"({}[])\"`, `\")\"`, `\"[\"`\\nGood luck!"
                    },
                    {
                        "username": "Shivani_Miryala",
                        "content": "Could someone help me all the testcases are not passing for my code(in Python3)::\\n\\nTest Case Type(which it is failing):\\nEx: \\ns = \"{[]}\"\\n\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n      \\n        s1 = list(str(s))\\n        i =0\\n        n = len(s1)\\n        count = 0\\n        while(i<n):\\n            if(s1[i] == \\'(\\' and s1[i + 1] == \\')\\' or s1[i] == \\'[\\' and s1[i+1] == \\']\\' or s1[i]  == \\'{\\' and s1[i+1] == \\'}\\'):\\n                i += 2\\n                count += 2\\n            \\n    \\n            else:\\n                return False\\n                break\\n        if count == n:\\n            return True\\n\\n\\n"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "It doesn\\'t clarify if the brackets in the input string that come first are guaranteed to be opening brackets. For example, by the constraints of the question, )( is a valid input string, but not sure if I needed to code my answer around that or not."
                    },
                    {
                        "username": "user2940mt",
                        "content": "what is up with the last test case(93), they have not given any input\\uD83D\\uDE22"
                    },
                    {
                        "username": "haardtripathi",
                        "content": "can someone tell me what is the issue with my solution\\n\\n\\n\\n\\n\\n\\nclass Solution(object):\\n    \\n    def isValid(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        \\n        self.open=[\"(\",\\'[\\',\\'{\\']\\n        self.close=[\")\",\\']\\',\\'}\\']\\n        self.stack=[]\\n        for par in s:\\n            if(par in self.open):\\n                self.stack.append(par)\\n            if(len(self.stack)==1 or len(self.stack)==0):\\n                a=0\\n            else:\\n                a=len(self.stack)-1\\n            if par in self.close:\\n                if self.stack!=[]:\\n                    if self.close.index(par)==self.open.index(self.stack[a]):\\n                        self.stack.remove(self.stack[a])\\n\\n                else:\\n                    self.stack.append(par)\\n    \\n        if(self.stack==[]):\\n            return \\'true\\'\\n        else:\\n            return \\'false\\'\\ns=Solution()\\n\\n"
                    },
                    {
                        "username": "00sayan00",
                        "content": "int k=s.length();\\n        if(k!=s.length()){\\n             return false; \\n            }\\n            else{\\n                return true;\\n            }\\n    }\\n\\nanyone  plz correct the code and highlight what is wrong "
                    },
                    {
                        "username": "seraphsword",
                        "content": "Your program, unless I\\'m missing something, says \"set k equal to the length of s. Then, if k isn\\'t equal to the length of s, return false.\" It\\'s literally impossible for you to set them as equal on one line, then expect them to not be equal the very next line.\\nWhat you need to check is if the parentheses are in the correct order. Starting out with a check if the length of s is an even number is a good idea, since if it isn\\'t there can\\'t possibly be the proper number of opening and closing brackets. Then you have to figure out how to check that each \\'(\\' comes before a \\')\\' and so on, without ever breaking the order of operations. So \\'([)]\\' would be wrong, because you can\\'t have an opening bracket inside the parentheses without closing it first."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |  BEATS 100%\nI used stack and a map both.\n1. make an empty stack.\n2. keep pushing paranthesis of different type i.e '{' and '[' are different.\n3. if same paranthesis is at top of stack then pop, i.e if current paranthesis is ')' and top of stack is '(' then pop . HERE's a catch , we are considering that ( == ) , { == } and [ == ] , to make them equal we used 'map'. \n4. using this in loop if the string is valid then our stack will become empty till last iteration else if the string is not valid .\n\nI know its hard to get but use pen paper and go through this using stack approach, rest you will be able to do it by yourself.   LEAVE A LIKE PLZ."
                    },
                    {
                        "username": "pardhu333",
                        "content": "Below testcase is failing for me.\\nInput: \"([)]\"\\nExpected: false\\nActual Output: true\\nI don\\'t understand how the expected is false."
                    },
                    {
                        "username": "bautistaaa",
                        "content": "asdsad"
                    },
                    {
                        "username": "cmokbel1",
                        "content": "whoever made this knows that a parentheses is actually just \\'(\\' and \\')\\' right ?"
                    }
                ]
            },
            {
                "id": 2002960,
                "content": [
                    {
                        "username": "rcon9494",
                        "content": "For best results when you submit, I recommend adding test cases:\\n `\"([)]\"`, `\"({}[])\"`, `\")\"`, `\"[\"`\\nGood luck!"
                    },
                    {
                        "username": "Shivani_Miryala",
                        "content": "Could someone help me all the testcases are not passing for my code(in Python3)::\\n\\nTest Case Type(which it is failing):\\nEx: \\ns = \"{[]}\"\\n\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n      \\n        s1 = list(str(s))\\n        i =0\\n        n = len(s1)\\n        count = 0\\n        while(i<n):\\n            if(s1[i] == \\'(\\' and s1[i + 1] == \\')\\' or s1[i] == \\'[\\' and s1[i+1] == \\']\\' or s1[i]  == \\'{\\' and s1[i+1] == \\'}\\'):\\n                i += 2\\n                count += 2\\n            \\n    \\n            else:\\n                return False\\n                break\\n        if count == n:\\n            return True\\n\\n\\n"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "It doesn\\'t clarify if the brackets in the input string that come first are guaranteed to be opening brackets. For example, by the constraints of the question, )( is a valid input string, but not sure if I needed to code my answer around that or not."
                    },
                    {
                        "username": "user2940mt",
                        "content": "what is up with the last test case(93), they have not given any input\\uD83D\\uDE22"
                    },
                    {
                        "username": "haardtripathi",
                        "content": "can someone tell me what is the issue with my solution\\n\\n\\n\\n\\n\\n\\nclass Solution(object):\\n    \\n    def isValid(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        \\n        self.open=[\"(\",\\'[\\',\\'{\\']\\n        self.close=[\")\",\\']\\',\\'}\\']\\n        self.stack=[]\\n        for par in s:\\n            if(par in self.open):\\n                self.stack.append(par)\\n            if(len(self.stack)==1 or len(self.stack)==0):\\n                a=0\\n            else:\\n                a=len(self.stack)-1\\n            if par in self.close:\\n                if self.stack!=[]:\\n                    if self.close.index(par)==self.open.index(self.stack[a]):\\n                        self.stack.remove(self.stack[a])\\n\\n                else:\\n                    self.stack.append(par)\\n    \\n        if(self.stack==[]):\\n            return \\'true\\'\\n        else:\\n            return \\'false\\'\\ns=Solution()\\n\\n"
                    },
                    {
                        "username": "00sayan00",
                        "content": "int k=s.length();\\n        if(k!=s.length()){\\n             return false; \\n            }\\n            else{\\n                return true;\\n            }\\n    }\\n\\nanyone  plz correct the code and highlight what is wrong "
                    },
                    {
                        "username": "seraphsword",
                        "content": "Your program, unless I\\'m missing something, says \"set k equal to the length of s. Then, if k isn\\'t equal to the length of s, return false.\" It\\'s literally impossible for you to set them as equal on one line, then expect them to not be equal the very next line.\\nWhat you need to check is if the parentheses are in the correct order. Starting out with a check if the length of s is an even number is a good idea, since if it isn\\'t there can\\'t possibly be the proper number of opening and closing brackets. Then you have to figure out how to check that each \\'(\\' comes before a \\')\\' and so on, without ever breaking the order of operations. So \\'([)]\\' would be wrong, because you can\\'t have an opening bracket inside the parentheses without closing it first."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |  BEATS 100%\nI used stack and a map both.\n1. make an empty stack.\n2. keep pushing paranthesis of different type i.e '{' and '[' are different.\n3. if same paranthesis is at top of stack then pop, i.e if current paranthesis is ')' and top of stack is '(' then pop . HERE's a catch , we are considering that ( == ) , { == } and [ == ] , to make them equal we used 'map'. \n4. using this in loop if the string is valid then our stack will become empty till last iteration else if the string is not valid .\n\nI know its hard to get but use pen paper and go through this using stack approach, rest you will be able to do it by yourself.   LEAVE A LIKE PLZ."
                    },
                    {
                        "username": "pardhu333",
                        "content": "Below testcase is failing for me.\\nInput: \"([)]\"\\nExpected: false\\nActual Output: true\\nI don\\'t understand how the expected is false."
                    },
                    {
                        "username": "bautistaaa",
                        "content": "asdsad"
                    },
                    {
                        "username": "cmokbel1",
                        "content": "whoever made this knows that a parentheses is actually just \\'(\\' and \\')\\' right ?"
                    }
                ]
            },
            {
                "id": 1996591,
                "content": [
                    {
                        "username": "rcon9494",
                        "content": "For best results when you submit, I recommend adding test cases:\\n `\"([)]\"`, `\"({}[])\"`, `\")\"`, `\"[\"`\\nGood luck!"
                    },
                    {
                        "username": "Shivani_Miryala",
                        "content": "Could someone help me all the testcases are not passing for my code(in Python3)::\\n\\nTest Case Type(which it is failing):\\nEx: \\ns = \"{[]}\"\\n\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n      \\n        s1 = list(str(s))\\n        i =0\\n        n = len(s1)\\n        count = 0\\n        while(i<n):\\n            if(s1[i] == \\'(\\' and s1[i + 1] == \\')\\' or s1[i] == \\'[\\' and s1[i+1] == \\']\\' or s1[i]  == \\'{\\' and s1[i+1] == \\'}\\'):\\n                i += 2\\n                count += 2\\n            \\n    \\n            else:\\n                return False\\n                break\\n        if count == n:\\n            return True\\n\\n\\n"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "It doesn\\'t clarify if the brackets in the input string that come first are guaranteed to be opening brackets. For example, by the constraints of the question, )( is a valid input string, but not sure if I needed to code my answer around that or not."
                    },
                    {
                        "username": "user2940mt",
                        "content": "what is up with the last test case(93), they have not given any input\\uD83D\\uDE22"
                    },
                    {
                        "username": "haardtripathi",
                        "content": "can someone tell me what is the issue with my solution\\n\\n\\n\\n\\n\\n\\nclass Solution(object):\\n    \\n    def isValid(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        \\n        self.open=[\"(\",\\'[\\',\\'{\\']\\n        self.close=[\")\",\\']\\',\\'}\\']\\n        self.stack=[]\\n        for par in s:\\n            if(par in self.open):\\n                self.stack.append(par)\\n            if(len(self.stack)==1 or len(self.stack)==0):\\n                a=0\\n            else:\\n                a=len(self.stack)-1\\n            if par in self.close:\\n                if self.stack!=[]:\\n                    if self.close.index(par)==self.open.index(self.stack[a]):\\n                        self.stack.remove(self.stack[a])\\n\\n                else:\\n                    self.stack.append(par)\\n    \\n        if(self.stack==[]):\\n            return \\'true\\'\\n        else:\\n            return \\'false\\'\\ns=Solution()\\n\\n"
                    },
                    {
                        "username": "00sayan00",
                        "content": "int k=s.length();\\n        if(k!=s.length()){\\n             return false; \\n            }\\n            else{\\n                return true;\\n            }\\n    }\\n\\nanyone  plz correct the code and highlight what is wrong "
                    },
                    {
                        "username": "seraphsword",
                        "content": "Your program, unless I\\'m missing something, says \"set k equal to the length of s. Then, if k isn\\'t equal to the length of s, return false.\" It\\'s literally impossible for you to set them as equal on one line, then expect them to not be equal the very next line.\\nWhat you need to check is if the parentheses are in the correct order. Starting out with a check if the length of s is an even number is a good idea, since if it isn\\'t there can\\'t possibly be the proper number of opening and closing brackets. Then you have to figure out how to check that each \\'(\\' comes before a \\')\\' and so on, without ever breaking the order of operations. So \\'([)]\\' would be wrong, because you can\\'t have an opening bracket inside the parentheses without closing it first."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |  BEATS 100%\nI used stack and a map both.\n1. make an empty stack.\n2. keep pushing paranthesis of different type i.e '{' and '[' are different.\n3. if same paranthesis is at top of stack then pop, i.e if current paranthesis is ')' and top of stack is '(' then pop . HERE's a catch , we are considering that ( == ) , { == } and [ == ] , to make them equal we used 'map'. \n4. using this in loop if the string is valid then our stack will become empty till last iteration else if the string is not valid .\n\nI know its hard to get but use pen paper and go through this using stack approach, rest you will be able to do it by yourself.   LEAVE A LIKE PLZ."
                    },
                    {
                        "username": "pardhu333",
                        "content": "Below testcase is failing for me.\\nInput: \"([)]\"\\nExpected: false\\nActual Output: true\\nI don\\'t understand how the expected is false."
                    },
                    {
                        "username": "bautistaaa",
                        "content": "asdsad"
                    },
                    {
                        "username": "cmokbel1",
                        "content": "whoever made this knows that a parentheses is actually just \\'(\\' and \\')\\' right ?"
                    }
                ]
            },
            {
                "id": 1996416,
                "content": [
                    {
                        "username": "rcon9494",
                        "content": "For best results when you submit, I recommend adding test cases:\\n `\"([)]\"`, `\"({}[])\"`, `\")\"`, `\"[\"`\\nGood luck!"
                    },
                    {
                        "username": "Shivani_Miryala",
                        "content": "Could someone help me all the testcases are not passing for my code(in Python3)::\\n\\nTest Case Type(which it is failing):\\nEx: \\ns = \"{[]}\"\\n\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n      \\n        s1 = list(str(s))\\n        i =0\\n        n = len(s1)\\n        count = 0\\n        while(i<n):\\n            if(s1[i] == \\'(\\' and s1[i + 1] == \\')\\' or s1[i] == \\'[\\' and s1[i+1] == \\']\\' or s1[i]  == \\'{\\' and s1[i+1] == \\'}\\'):\\n                i += 2\\n                count += 2\\n            \\n    \\n            else:\\n                return False\\n                break\\n        if count == n:\\n            return True\\n\\n\\n"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "It doesn\\'t clarify if the brackets in the input string that come first are guaranteed to be opening brackets. For example, by the constraints of the question, )( is a valid input string, but not sure if I needed to code my answer around that or not."
                    },
                    {
                        "username": "user2940mt",
                        "content": "what is up with the last test case(93), they have not given any input\\uD83D\\uDE22"
                    },
                    {
                        "username": "haardtripathi",
                        "content": "can someone tell me what is the issue with my solution\\n\\n\\n\\n\\n\\n\\nclass Solution(object):\\n    \\n    def isValid(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        \\n        self.open=[\"(\",\\'[\\',\\'{\\']\\n        self.close=[\")\",\\']\\',\\'}\\']\\n        self.stack=[]\\n        for par in s:\\n            if(par in self.open):\\n                self.stack.append(par)\\n            if(len(self.stack)==1 or len(self.stack)==0):\\n                a=0\\n            else:\\n                a=len(self.stack)-1\\n            if par in self.close:\\n                if self.stack!=[]:\\n                    if self.close.index(par)==self.open.index(self.stack[a]):\\n                        self.stack.remove(self.stack[a])\\n\\n                else:\\n                    self.stack.append(par)\\n    \\n        if(self.stack==[]):\\n            return \\'true\\'\\n        else:\\n            return \\'false\\'\\ns=Solution()\\n\\n"
                    },
                    {
                        "username": "00sayan00",
                        "content": "int k=s.length();\\n        if(k!=s.length()){\\n             return false; \\n            }\\n            else{\\n                return true;\\n            }\\n    }\\n\\nanyone  plz correct the code and highlight what is wrong "
                    },
                    {
                        "username": "seraphsword",
                        "content": "Your program, unless I\\'m missing something, says \"set k equal to the length of s. Then, if k isn\\'t equal to the length of s, return false.\" It\\'s literally impossible for you to set them as equal on one line, then expect them to not be equal the very next line.\\nWhat you need to check is if the parentheses are in the correct order. Starting out with a check if the length of s is an even number is a good idea, since if it isn\\'t there can\\'t possibly be the proper number of opening and closing brackets. Then you have to figure out how to check that each \\'(\\' comes before a \\')\\' and so on, without ever breaking the order of operations. So \\'([)]\\' would be wrong, because you can\\'t have an opening bracket inside the parentheses without closing it first."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |  BEATS 100%\nI used stack and a map both.\n1. make an empty stack.\n2. keep pushing paranthesis of different type i.e '{' and '[' are different.\n3. if same paranthesis is at top of stack then pop, i.e if current paranthesis is ')' and top of stack is '(' then pop . HERE's a catch , we are considering that ( == ) , { == } and [ == ] , to make them equal we used 'map'. \n4. using this in loop if the string is valid then our stack will become empty till last iteration else if the string is not valid .\n\nI know its hard to get but use pen paper and go through this using stack approach, rest you will be able to do it by yourself.   LEAVE A LIKE PLZ."
                    },
                    {
                        "username": "pardhu333",
                        "content": "Below testcase is failing for me.\\nInput: \"([)]\"\\nExpected: false\\nActual Output: true\\nI don\\'t understand how the expected is false."
                    },
                    {
                        "username": "bautistaaa",
                        "content": "asdsad"
                    },
                    {
                        "username": "cmokbel1",
                        "content": "whoever made this knows that a parentheses is actually just \\'(\\' and \\')\\' right ?"
                    }
                ]
            },
            {
                "id": 1993647,
                "content": [
                    {
                        "username": "rcon9494",
                        "content": "For best results when you submit, I recommend adding test cases:\\n `\"([)]\"`, `\"({}[])\"`, `\")\"`, `\"[\"`\\nGood luck!"
                    },
                    {
                        "username": "Shivani_Miryala",
                        "content": "Could someone help me all the testcases are not passing for my code(in Python3)::\\n\\nTest Case Type(which it is failing):\\nEx: \\ns = \"{[]}\"\\n\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n      \\n        s1 = list(str(s))\\n        i =0\\n        n = len(s1)\\n        count = 0\\n        while(i<n):\\n            if(s1[i] == \\'(\\' and s1[i + 1] == \\')\\' or s1[i] == \\'[\\' and s1[i+1] == \\']\\' or s1[i]  == \\'{\\' and s1[i+1] == \\'}\\'):\\n                i += 2\\n                count += 2\\n            \\n    \\n            else:\\n                return False\\n                break\\n        if count == n:\\n            return True\\n\\n\\n"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "It doesn\\'t clarify if the brackets in the input string that come first are guaranteed to be opening brackets. For example, by the constraints of the question, )( is a valid input string, but not sure if I needed to code my answer around that or not."
                    },
                    {
                        "username": "user2940mt",
                        "content": "what is up with the last test case(93), they have not given any input\\uD83D\\uDE22"
                    },
                    {
                        "username": "haardtripathi",
                        "content": "can someone tell me what is the issue with my solution\\n\\n\\n\\n\\n\\n\\nclass Solution(object):\\n    \\n    def isValid(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        \\n        self.open=[\"(\",\\'[\\',\\'{\\']\\n        self.close=[\")\",\\']\\',\\'}\\']\\n        self.stack=[]\\n        for par in s:\\n            if(par in self.open):\\n                self.stack.append(par)\\n            if(len(self.stack)==1 or len(self.stack)==0):\\n                a=0\\n            else:\\n                a=len(self.stack)-1\\n            if par in self.close:\\n                if self.stack!=[]:\\n                    if self.close.index(par)==self.open.index(self.stack[a]):\\n                        self.stack.remove(self.stack[a])\\n\\n                else:\\n                    self.stack.append(par)\\n    \\n        if(self.stack==[]):\\n            return \\'true\\'\\n        else:\\n            return \\'false\\'\\ns=Solution()\\n\\n"
                    },
                    {
                        "username": "00sayan00",
                        "content": "int k=s.length();\\n        if(k!=s.length()){\\n             return false; \\n            }\\n            else{\\n                return true;\\n            }\\n    }\\n\\nanyone  plz correct the code and highlight what is wrong "
                    },
                    {
                        "username": "seraphsword",
                        "content": "Your program, unless I\\'m missing something, says \"set k equal to the length of s. Then, if k isn\\'t equal to the length of s, return false.\" It\\'s literally impossible for you to set them as equal on one line, then expect them to not be equal the very next line.\\nWhat you need to check is if the parentheses are in the correct order. Starting out with a check if the length of s is an even number is a good idea, since if it isn\\'t there can\\'t possibly be the proper number of opening and closing brackets. Then you have to figure out how to check that each \\'(\\' comes before a \\')\\' and so on, without ever breaking the order of operations. So \\'([)]\\' would be wrong, because you can\\'t have an opening bracket inside the parentheses without closing it first."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |  BEATS 100%\nI used stack and a map both.\n1. make an empty stack.\n2. keep pushing paranthesis of different type i.e '{' and '[' are different.\n3. if same paranthesis is at top of stack then pop, i.e if current paranthesis is ')' and top of stack is '(' then pop . HERE's a catch , we are considering that ( == ) , { == } and [ == ] , to make them equal we used 'map'. \n4. using this in loop if the string is valid then our stack will become empty till last iteration else if the string is not valid .\n\nI know its hard to get but use pen paper and go through this using stack approach, rest you will be able to do it by yourself.   LEAVE A LIKE PLZ."
                    },
                    {
                        "username": "pardhu333",
                        "content": "Below testcase is failing for me.\\nInput: \"([)]\"\\nExpected: false\\nActual Output: true\\nI don\\'t understand how the expected is false."
                    },
                    {
                        "username": "bautistaaa",
                        "content": "asdsad"
                    },
                    {
                        "username": "cmokbel1",
                        "content": "whoever made this knows that a parentheses is actually just \\'(\\' and \\')\\' right ?"
                    }
                ]
            },
            {
                "id": 1993457,
                "content": [
                    {
                        "username": "Hitesh-720_566",
                        "content": "class Solution {\\n    public boolean isValid(String str) {\\n        Stack<Character> s=new Stack<>();\\n        for(int i=0;i<str.length();i++){\\n            char cur=s.charAt(i);\\n            if(isOpening(cur)){\\n                s.push(cur);\\n            }else{\\n                if(s.isEmpty()){\\n                    retutn false;\\n                }else-if(!isMatching(s.peek(),cur)){\\n                    return false;\\n                }else{\\n                    s.pop();\\n                }\\n            }\\n        }\\n        return isEmpty();\\n    }\\n    static boolean isOpening(char c){\\n        return c=\\'(\\' || \\'{\\' || \\'[\\';\\n    }\\n    static boolean isMatching(char a, char b){\\n     return  (a=\\'()\\' && b=\\')\\') || (a=\\'{\\' || b=\\'}\\') || (a=\\'[\\' || b=\\']\\');\\n    }\\n}\\n\\nWHY IS IT SHOWING ERROR ?? Please anyone help"
                    },
                    {
                        "username": "mhou2009",
                        "content": "first of all you wrote \\u201Cretutn false;\\u201D :D"
                    },
                    {
                        "username": "Ahrorooney",
                        "content": "Good tricky question)"
                    },
                    {
                        "username": "Saurabhsingh635366",
                        "content": "class Solution {\npublic:\n\n  unordered_map<char, int> symbols={{'[', -1},{'{', -2},{'(', -3},{']', 1},{'}', 2},{')', 3}};\n    bool isValid(string s) {\n       stack<char> st;\n    \n    for(char bracket: s){\n        if(symbols[bracket]<0){\n            st.push(bracket);\n        }\n        else {\n              \n              if(st.empty()) return  false;\n              \n              char top= st.top();\n              st.pop();\n              if(symbols[bracket]+symbols[top]!=0){\n                  return false;\n              }\n        }\n    }\n    \n    if(st.empty()) return  true;\n    return  false;\n    \n    }\n};\n\nsee my approch guys this is proper working code.\n\n"
                    },
                    {
                        "username": "alice0217",
                        "content": "my advice for people who want to use stack is decide what to push to the stack."
                    },
                    {
                        "username": "MrxNoobie",
                        "content": "Someone please explain the fact that ([]{}) is valid but ([)] is not? How does this makes sense? They need to be more descriptive in their description and if someone have an explanation to this, Please do so. I have been stuck on this God damn problem for the past 3 HOURS. THIS IS DRIVING ME CRAZY."
                    },
                    {
                        "username": "seraphsword",
                        "content": "You have to think of it like an equation or a function. Every pair of opening and closing brackets has to be entirely enclosed by another pair, or entirely enclose another pair, or be empty. A pair can't be half-enclosed and half-not.\n`a = 2 * (x + 1 [y / 3] - {z^4 / 2})` would be an example of the valid string. \n`a = 2 * (x + 1 [y / 3)]` would be an example of the invalid string. The closing parentheses breaks the brackets.\n`result = 2 * (4 / bArray[3 + i)]` is another version of the invalid string. "
                    },
                    {
                        "username": "MrxNoobie",
                        "content": "[@Saurabhsingh635366](/Saurabhsingh635366) Thank you for the response but the thing is, I am aware how to stack works, and also thank you for bringing the light on it,  but here\\'s the thing, I don\\'t know how to implement that into the code. Can you please give me a hint on it? Thank you!"
                    },
                    {
                        "username": "Saurabhsingh635366",
                        "content": "first u push the open parenthesis \\'(\\' then \\'[\\' and u can see top element of the stack not match to the third bracket because nature of the bracket is not same that\\'s why are not able to pop the top element of the stack by rest of close parenthesis."
                    },
                    {
                        "username": "cennav",
                        "content": "Description problem says open brackets must be closed in the correct order\\nBut this test case \"( ( [ ] ) { } )\" is valid\\n\\nThe problem it\\'s not clear"
                    },
                    {
                        "username": "taronjimark",
                        "content": "Description of the problem is vague and needs more clarification. Nested parenthesis are another requirement. "
                    },
                    {
                        "username": "HDJCat",
                        "content": "Why is expected output for \"([)]\" False,\\nbut expected output for \"{[]}\" True?"
                    },
                    {
                        "username": "seraphsword",
                        "content": "The problem assumes you\\'ve taken algebra or some kind of programming. Proper nesting of parentheses is a requirement for either. So each bracket type has to be empty, completely enclosed, or completely enclosing another pair.\\n`result = a * (2 + arr[3 + x)]` wouldn\\'t be valid right? Because the closing parentheses is cutting off the square bracket."
                    },
                    {
                        "username": "fOOl_404",
                        "content": "Poor description !!"
                    },
                    {
                        "username": "mindgspl",
                        "content": "I looked later in some good runtime solutions but those didn\\'t PASS some of my test cases, for exemple those: \\n\"() [{ [  ] } ([]) ] [] ()\" \\nand\\n\"() [{}] ()\""
                    }
                ]
            },
            {
                "id": 1990213,
                "content": [
                    {
                        "username": "Hitesh-720_566",
                        "content": "class Solution {\\n    public boolean isValid(String str) {\\n        Stack<Character> s=new Stack<>();\\n        for(int i=0;i<str.length();i++){\\n            char cur=s.charAt(i);\\n            if(isOpening(cur)){\\n                s.push(cur);\\n            }else{\\n                if(s.isEmpty()){\\n                    retutn false;\\n                }else-if(!isMatching(s.peek(),cur)){\\n                    return false;\\n                }else{\\n                    s.pop();\\n                }\\n            }\\n        }\\n        return isEmpty();\\n    }\\n    static boolean isOpening(char c){\\n        return c=\\'(\\' || \\'{\\' || \\'[\\';\\n    }\\n    static boolean isMatching(char a, char b){\\n     return  (a=\\'()\\' && b=\\')\\') || (a=\\'{\\' || b=\\'}\\') || (a=\\'[\\' || b=\\']\\');\\n    }\\n}\\n\\nWHY IS IT SHOWING ERROR ?? Please anyone help"
                    },
                    {
                        "username": "mhou2009",
                        "content": "first of all you wrote \\u201Cretutn false;\\u201D :D"
                    },
                    {
                        "username": "Ahrorooney",
                        "content": "Good tricky question)"
                    },
                    {
                        "username": "Saurabhsingh635366",
                        "content": "class Solution {\npublic:\n\n  unordered_map<char, int> symbols={{'[', -1},{'{', -2},{'(', -3},{']', 1},{'}', 2},{')', 3}};\n    bool isValid(string s) {\n       stack<char> st;\n    \n    for(char bracket: s){\n        if(symbols[bracket]<0){\n            st.push(bracket);\n        }\n        else {\n              \n              if(st.empty()) return  false;\n              \n              char top= st.top();\n              st.pop();\n              if(symbols[bracket]+symbols[top]!=0){\n                  return false;\n              }\n        }\n    }\n    \n    if(st.empty()) return  true;\n    return  false;\n    \n    }\n};\n\nsee my approch guys this is proper working code.\n\n"
                    },
                    {
                        "username": "alice0217",
                        "content": "my advice for people who want to use stack is decide what to push to the stack."
                    },
                    {
                        "username": "MrxNoobie",
                        "content": "Someone please explain the fact that ([]{}) is valid but ([)] is not? How does this makes sense? They need to be more descriptive in their description and if someone have an explanation to this, Please do so. I have been stuck on this God damn problem for the past 3 HOURS. THIS IS DRIVING ME CRAZY."
                    },
                    {
                        "username": "seraphsword",
                        "content": "You have to think of it like an equation or a function. Every pair of opening and closing brackets has to be entirely enclosed by another pair, or entirely enclose another pair, or be empty. A pair can't be half-enclosed and half-not.\n`a = 2 * (x + 1 [y / 3] - {z^4 / 2})` would be an example of the valid string. \n`a = 2 * (x + 1 [y / 3)]` would be an example of the invalid string. The closing parentheses breaks the brackets.\n`result = 2 * (4 / bArray[3 + i)]` is another version of the invalid string. "
                    },
                    {
                        "username": "MrxNoobie",
                        "content": "[@Saurabhsingh635366](/Saurabhsingh635366) Thank you for the response but the thing is, I am aware how to stack works, and also thank you for bringing the light on it,  but here\\'s the thing, I don\\'t know how to implement that into the code. Can you please give me a hint on it? Thank you!"
                    },
                    {
                        "username": "Saurabhsingh635366",
                        "content": "first u push the open parenthesis \\'(\\' then \\'[\\' and u can see top element of the stack not match to the third bracket because nature of the bracket is not same that\\'s why are not able to pop the top element of the stack by rest of close parenthesis."
                    },
                    {
                        "username": "cennav",
                        "content": "Description problem says open brackets must be closed in the correct order\\nBut this test case \"( ( [ ] ) { } )\" is valid\\n\\nThe problem it\\'s not clear"
                    },
                    {
                        "username": "taronjimark",
                        "content": "Description of the problem is vague and needs more clarification. Nested parenthesis are another requirement. "
                    },
                    {
                        "username": "HDJCat",
                        "content": "Why is expected output for \"([)]\" False,\\nbut expected output for \"{[]}\" True?"
                    },
                    {
                        "username": "seraphsword",
                        "content": "The problem assumes you\\'ve taken algebra or some kind of programming. Proper nesting of parentheses is a requirement for either. So each bracket type has to be empty, completely enclosed, or completely enclosing another pair.\\n`result = a * (2 + arr[3 + x)]` wouldn\\'t be valid right? Because the closing parentheses is cutting off the square bracket."
                    },
                    {
                        "username": "fOOl_404",
                        "content": "Poor description !!"
                    },
                    {
                        "username": "mindgspl",
                        "content": "I looked later in some good runtime solutions but those didn\\'t PASS some of my test cases, for exemple those: \\n\"() [{ [  ] } ([]) ] [] ()\" \\nand\\n\"() [{}] ()\""
                    }
                ]
            },
            {
                "id": 1988947,
                "content": [
                    {
                        "username": "Hitesh-720_566",
                        "content": "class Solution {\\n    public boolean isValid(String str) {\\n        Stack<Character> s=new Stack<>();\\n        for(int i=0;i<str.length();i++){\\n            char cur=s.charAt(i);\\n            if(isOpening(cur)){\\n                s.push(cur);\\n            }else{\\n                if(s.isEmpty()){\\n                    retutn false;\\n                }else-if(!isMatching(s.peek(),cur)){\\n                    return false;\\n                }else{\\n                    s.pop();\\n                }\\n            }\\n        }\\n        return isEmpty();\\n    }\\n    static boolean isOpening(char c){\\n        return c=\\'(\\' || \\'{\\' || \\'[\\';\\n    }\\n    static boolean isMatching(char a, char b){\\n     return  (a=\\'()\\' && b=\\')\\') || (a=\\'{\\' || b=\\'}\\') || (a=\\'[\\' || b=\\']\\');\\n    }\\n}\\n\\nWHY IS IT SHOWING ERROR ?? Please anyone help"
                    },
                    {
                        "username": "mhou2009",
                        "content": "first of all you wrote \\u201Cretutn false;\\u201D :D"
                    },
                    {
                        "username": "Ahrorooney",
                        "content": "Good tricky question)"
                    },
                    {
                        "username": "Saurabhsingh635366",
                        "content": "class Solution {\npublic:\n\n  unordered_map<char, int> symbols={{'[', -1},{'{', -2},{'(', -3},{']', 1},{'}', 2},{')', 3}};\n    bool isValid(string s) {\n       stack<char> st;\n    \n    for(char bracket: s){\n        if(symbols[bracket]<0){\n            st.push(bracket);\n        }\n        else {\n              \n              if(st.empty()) return  false;\n              \n              char top= st.top();\n              st.pop();\n              if(symbols[bracket]+symbols[top]!=0){\n                  return false;\n              }\n        }\n    }\n    \n    if(st.empty()) return  true;\n    return  false;\n    \n    }\n};\n\nsee my approch guys this is proper working code.\n\n"
                    },
                    {
                        "username": "alice0217",
                        "content": "my advice for people who want to use stack is decide what to push to the stack."
                    },
                    {
                        "username": "MrxNoobie",
                        "content": "Someone please explain the fact that ([]{}) is valid but ([)] is not? How does this makes sense? They need to be more descriptive in their description and if someone have an explanation to this, Please do so. I have been stuck on this God damn problem for the past 3 HOURS. THIS IS DRIVING ME CRAZY."
                    },
                    {
                        "username": "seraphsword",
                        "content": "You have to think of it like an equation or a function. Every pair of opening and closing brackets has to be entirely enclosed by another pair, or entirely enclose another pair, or be empty. A pair can't be half-enclosed and half-not.\n`a = 2 * (x + 1 [y / 3] - {z^4 / 2})` would be an example of the valid string. \n`a = 2 * (x + 1 [y / 3)]` would be an example of the invalid string. The closing parentheses breaks the brackets.\n`result = 2 * (4 / bArray[3 + i)]` is another version of the invalid string. "
                    },
                    {
                        "username": "MrxNoobie",
                        "content": "[@Saurabhsingh635366](/Saurabhsingh635366) Thank you for the response but the thing is, I am aware how to stack works, and also thank you for bringing the light on it,  but here\\'s the thing, I don\\'t know how to implement that into the code. Can you please give me a hint on it? Thank you!"
                    },
                    {
                        "username": "Saurabhsingh635366",
                        "content": "first u push the open parenthesis \\'(\\' then \\'[\\' and u can see top element of the stack not match to the third bracket because nature of the bracket is not same that\\'s why are not able to pop the top element of the stack by rest of close parenthesis."
                    },
                    {
                        "username": "cennav",
                        "content": "Description problem says open brackets must be closed in the correct order\\nBut this test case \"( ( [ ] ) { } )\" is valid\\n\\nThe problem it\\'s not clear"
                    },
                    {
                        "username": "taronjimark",
                        "content": "Description of the problem is vague and needs more clarification. Nested parenthesis are another requirement. "
                    },
                    {
                        "username": "HDJCat",
                        "content": "Why is expected output for \"([)]\" False,\\nbut expected output for \"{[]}\" True?"
                    },
                    {
                        "username": "seraphsword",
                        "content": "The problem assumes you\\'ve taken algebra or some kind of programming. Proper nesting of parentheses is a requirement for either. So each bracket type has to be empty, completely enclosed, or completely enclosing another pair.\\n`result = a * (2 + arr[3 + x)]` wouldn\\'t be valid right? Because the closing parentheses is cutting off the square bracket."
                    },
                    {
                        "username": "fOOl_404",
                        "content": "Poor description !!"
                    },
                    {
                        "username": "mindgspl",
                        "content": "I looked later in some good runtime solutions but those didn\\'t PASS some of my test cases, for exemple those: \\n\"() [{ [  ] } ([]) ] [] ()\" \\nand\\n\"() [{}] ()\""
                    }
                ]
            },
            {
                "id": 1988529,
                "content": [
                    {
                        "username": "Hitesh-720_566",
                        "content": "class Solution {\\n    public boolean isValid(String str) {\\n        Stack<Character> s=new Stack<>();\\n        for(int i=0;i<str.length();i++){\\n            char cur=s.charAt(i);\\n            if(isOpening(cur)){\\n                s.push(cur);\\n            }else{\\n                if(s.isEmpty()){\\n                    retutn false;\\n                }else-if(!isMatching(s.peek(),cur)){\\n                    return false;\\n                }else{\\n                    s.pop();\\n                }\\n            }\\n        }\\n        return isEmpty();\\n    }\\n    static boolean isOpening(char c){\\n        return c=\\'(\\' || \\'{\\' || \\'[\\';\\n    }\\n    static boolean isMatching(char a, char b){\\n     return  (a=\\'()\\' && b=\\')\\') || (a=\\'{\\' || b=\\'}\\') || (a=\\'[\\' || b=\\']\\');\\n    }\\n}\\n\\nWHY IS IT SHOWING ERROR ?? Please anyone help"
                    },
                    {
                        "username": "mhou2009",
                        "content": "first of all you wrote \\u201Cretutn false;\\u201D :D"
                    },
                    {
                        "username": "Ahrorooney",
                        "content": "Good tricky question)"
                    },
                    {
                        "username": "Saurabhsingh635366",
                        "content": "class Solution {\npublic:\n\n  unordered_map<char, int> symbols={{'[', -1},{'{', -2},{'(', -3},{']', 1},{'}', 2},{')', 3}};\n    bool isValid(string s) {\n       stack<char> st;\n    \n    for(char bracket: s){\n        if(symbols[bracket]<0){\n            st.push(bracket);\n        }\n        else {\n              \n              if(st.empty()) return  false;\n              \n              char top= st.top();\n              st.pop();\n              if(symbols[bracket]+symbols[top]!=0){\n                  return false;\n              }\n        }\n    }\n    \n    if(st.empty()) return  true;\n    return  false;\n    \n    }\n};\n\nsee my approch guys this is proper working code.\n\n"
                    },
                    {
                        "username": "alice0217",
                        "content": "my advice for people who want to use stack is decide what to push to the stack."
                    },
                    {
                        "username": "MrxNoobie",
                        "content": "Someone please explain the fact that ([]{}) is valid but ([)] is not? How does this makes sense? They need to be more descriptive in their description and if someone have an explanation to this, Please do so. I have been stuck on this God damn problem for the past 3 HOURS. THIS IS DRIVING ME CRAZY."
                    },
                    {
                        "username": "seraphsword",
                        "content": "You have to think of it like an equation or a function. Every pair of opening and closing brackets has to be entirely enclosed by another pair, or entirely enclose another pair, or be empty. A pair can't be half-enclosed and half-not.\n`a = 2 * (x + 1 [y / 3] - {z^4 / 2})` would be an example of the valid string. \n`a = 2 * (x + 1 [y / 3)]` would be an example of the invalid string. The closing parentheses breaks the brackets.\n`result = 2 * (4 / bArray[3 + i)]` is another version of the invalid string. "
                    },
                    {
                        "username": "MrxNoobie",
                        "content": "[@Saurabhsingh635366](/Saurabhsingh635366) Thank you for the response but the thing is, I am aware how to stack works, and also thank you for bringing the light on it,  but here\\'s the thing, I don\\'t know how to implement that into the code. Can you please give me a hint on it? Thank you!"
                    },
                    {
                        "username": "Saurabhsingh635366",
                        "content": "first u push the open parenthesis \\'(\\' then \\'[\\' and u can see top element of the stack not match to the third bracket because nature of the bracket is not same that\\'s why are not able to pop the top element of the stack by rest of close parenthesis."
                    },
                    {
                        "username": "cennav",
                        "content": "Description problem says open brackets must be closed in the correct order\\nBut this test case \"( ( [ ] ) { } )\" is valid\\n\\nThe problem it\\'s not clear"
                    },
                    {
                        "username": "taronjimark",
                        "content": "Description of the problem is vague and needs more clarification. Nested parenthesis are another requirement. "
                    },
                    {
                        "username": "HDJCat",
                        "content": "Why is expected output for \"([)]\" False,\\nbut expected output for \"{[]}\" True?"
                    },
                    {
                        "username": "seraphsword",
                        "content": "The problem assumes you\\'ve taken algebra or some kind of programming. Proper nesting of parentheses is a requirement for either. So each bracket type has to be empty, completely enclosed, or completely enclosing another pair.\\n`result = a * (2 + arr[3 + x)]` wouldn\\'t be valid right? Because the closing parentheses is cutting off the square bracket."
                    },
                    {
                        "username": "fOOl_404",
                        "content": "Poor description !!"
                    },
                    {
                        "username": "mindgspl",
                        "content": "I looked later in some good runtime solutions but those didn\\'t PASS some of my test cases, for exemple those: \\n\"() [{ [  ] } ([]) ] [] ()\" \\nand\\n\"() [{}] ()\""
                    }
                ]
            },
            {
                "id": 1988104,
                "content": [
                    {
                        "username": "Hitesh-720_566",
                        "content": "class Solution {\\n    public boolean isValid(String str) {\\n        Stack<Character> s=new Stack<>();\\n        for(int i=0;i<str.length();i++){\\n            char cur=s.charAt(i);\\n            if(isOpening(cur)){\\n                s.push(cur);\\n            }else{\\n                if(s.isEmpty()){\\n                    retutn false;\\n                }else-if(!isMatching(s.peek(),cur)){\\n                    return false;\\n                }else{\\n                    s.pop();\\n                }\\n            }\\n        }\\n        return isEmpty();\\n    }\\n    static boolean isOpening(char c){\\n        return c=\\'(\\' || \\'{\\' || \\'[\\';\\n    }\\n    static boolean isMatching(char a, char b){\\n     return  (a=\\'()\\' && b=\\')\\') || (a=\\'{\\' || b=\\'}\\') || (a=\\'[\\' || b=\\']\\');\\n    }\\n}\\n\\nWHY IS IT SHOWING ERROR ?? Please anyone help"
                    },
                    {
                        "username": "mhou2009",
                        "content": "first of all you wrote \\u201Cretutn false;\\u201D :D"
                    },
                    {
                        "username": "Ahrorooney",
                        "content": "Good tricky question)"
                    },
                    {
                        "username": "Saurabhsingh635366",
                        "content": "class Solution {\npublic:\n\n  unordered_map<char, int> symbols={{'[', -1},{'{', -2},{'(', -3},{']', 1},{'}', 2},{')', 3}};\n    bool isValid(string s) {\n       stack<char> st;\n    \n    for(char bracket: s){\n        if(symbols[bracket]<0){\n            st.push(bracket);\n        }\n        else {\n              \n              if(st.empty()) return  false;\n              \n              char top= st.top();\n              st.pop();\n              if(symbols[bracket]+symbols[top]!=0){\n                  return false;\n              }\n        }\n    }\n    \n    if(st.empty()) return  true;\n    return  false;\n    \n    }\n};\n\nsee my approch guys this is proper working code.\n\n"
                    },
                    {
                        "username": "alice0217",
                        "content": "my advice for people who want to use stack is decide what to push to the stack."
                    },
                    {
                        "username": "MrxNoobie",
                        "content": "Someone please explain the fact that ([]{}) is valid but ([)] is not? How does this makes sense? They need to be more descriptive in their description and if someone have an explanation to this, Please do so. I have been stuck on this God damn problem for the past 3 HOURS. THIS IS DRIVING ME CRAZY."
                    },
                    {
                        "username": "seraphsword",
                        "content": "You have to think of it like an equation or a function. Every pair of opening and closing brackets has to be entirely enclosed by another pair, or entirely enclose another pair, or be empty. A pair can't be half-enclosed and half-not.\n`a = 2 * (x + 1 [y / 3] - {z^4 / 2})` would be an example of the valid string. \n`a = 2 * (x + 1 [y / 3)]` would be an example of the invalid string. The closing parentheses breaks the brackets.\n`result = 2 * (4 / bArray[3 + i)]` is another version of the invalid string. "
                    },
                    {
                        "username": "MrxNoobie",
                        "content": "[@Saurabhsingh635366](/Saurabhsingh635366) Thank you for the response but the thing is, I am aware how to stack works, and also thank you for bringing the light on it,  but here\\'s the thing, I don\\'t know how to implement that into the code. Can you please give me a hint on it? Thank you!"
                    },
                    {
                        "username": "Saurabhsingh635366",
                        "content": "first u push the open parenthesis \\'(\\' then \\'[\\' and u can see top element of the stack not match to the third bracket because nature of the bracket is not same that\\'s why are not able to pop the top element of the stack by rest of close parenthesis."
                    },
                    {
                        "username": "cennav",
                        "content": "Description problem says open brackets must be closed in the correct order\\nBut this test case \"( ( [ ] ) { } )\" is valid\\n\\nThe problem it\\'s not clear"
                    },
                    {
                        "username": "taronjimark",
                        "content": "Description of the problem is vague and needs more clarification. Nested parenthesis are another requirement. "
                    },
                    {
                        "username": "HDJCat",
                        "content": "Why is expected output for \"([)]\" False,\\nbut expected output for \"{[]}\" True?"
                    },
                    {
                        "username": "seraphsword",
                        "content": "The problem assumes you\\'ve taken algebra or some kind of programming. Proper nesting of parentheses is a requirement for either. So each bracket type has to be empty, completely enclosed, or completely enclosing another pair.\\n`result = a * (2 + arr[3 + x)]` wouldn\\'t be valid right? Because the closing parentheses is cutting off the square bracket."
                    },
                    {
                        "username": "fOOl_404",
                        "content": "Poor description !!"
                    },
                    {
                        "username": "mindgspl",
                        "content": "I looked later in some good runtime solutions but those didn\\'t PASS some of my test cases, for exemple those: \\n\"() [{ [  ] } ([]) ] [] ()\" \\nand\\n\"() [{}] ()\""
                    }
                ]
            },
            {
                "id": 1983706,
                "content": [
                    {
                        "username": "Hitesh-720_566",
                        "content": "class Solution {\\n    public boolean isValid(String str) {\\n        Stack<Character> s=new Stack<>();\\n        for(int i=0;i<str.length();i++){\\n            char cur=s.charAt(i);\\n            if(isOpening(cur)){\\n                s.push(cur);\\n            }else{\\n                if(s.isEmpty()){\\n                    retutn false;\\n                }else-if(!isMatching(s.peek(),cur)){\\n                    return false;\\n                }else{\\n                    s.pop();\\n                }\\n            }\\n        }\\n        return isEmpty();\\n    }\\n    static boolean isOpening(char c){\\n        return c=\\'(\\' || \\'{\\' || \\'[\\';\\n    }\\n    static boolean isMatching(char a, char b){\\n     return  (a=\\'()\\' && b=\\')\\') || (a=\\'{\\' || b=\\'}\\') || (a=\\'[\\' || b=\\']\\');\\n    }\\n}\\n\\nWHY IS IT SHOWING ERROR ?? Please anyone help"
                    },
                    {
                        "username": "mhou2009",
                        "content": "first of all you wrote \\u201Cretutn false;\\u201D :D"
                    },
                    {
                        "username": "Ahrorooney",
                        "content": "Good tricky question)"
                    },
                    {
                        "username": "Saurabhsingh635366",
                        "content": "class Solution {\npublic:\n\n  unordered_map<char, int> symbols={{'[', -1},{'{', -2},{'(', -3},{']', 1},{'}', 2},{')', 3}};\n    bool isValid(string s) {\n       stack<char> st;\n    \n    for(char bracket: s){\n        if(symbols[bracket]<0){\n            st.push(bracket);\n        }\n        else {\n              \n              if(st.empty()) return  false;\n              \n              char top= st.top();\n              st.pop();\n              if(symbols[bracket]+symbols[top]!=0){\n                  return false;\n              }\n        }\n    }\n    \n    if(st.empty()) return  true;\n    return  false;\n    \n    }\n};\n\nsee my approch guys this is proper working code.\n\n"
                    },
                    {
                        "username": "alice0217",
                        "content": "my advice for people who want to use stack is decide what to push to the stack."
                    },
                    {
                        "username": "MrxNoobie",
                        "content": "Someone please explain the fact that ([]{}) is valid but ([)] is not? How does this makes sense? They need to be more descriptive in their description and if someone have an explanation to this, Please do so. I have been stuck on this God damn problem for the past 3 HOURS. THIS IS DRIVING ME CRAZY."
                    },
                    {
                        "username": "seraphsword",
                        "content": "You have to think of it like an equation or a function. Every pair of opening and closing brackets has to be entirely enclosed by another pair, or entirely enclose another pair, or be empty. A pair can't be half-enclosed and half-not.\n`a = 2 * (x + 1 [y / 3] - {z^4 / 2})` would be an example of the valid string. \n`a = 2 * (x + 1 [y / 3)]` would be an example of the invalid string. The closing parentheses breaks the brackets.\n`result = 2 * (4 / bArray[3 + i)]` is another version of the invalid string. "
                    },
                    {
                        "username": "MrxNoobie",
                        "content": "[@Saurabhsingh635366](/Saurabhsingh635366) Thank you for the response but the thing is, I am aware how to stack works, and also thank you for bringing the light on it,  but here\\'s the thing, I don\\'t know how to implement that into the code. Can you please give me a hint on it? Thank you!"
                    },
                    {
                        "username": "Saurabhsingh635366",
                        "content": "first u push the open parenthesis \\'(\\' then \\'[\\' and u can see top element of the stack not match to the third bracket because nature of the bracket is not same that\\'s why are not able to pop the top element of the stack by rest of close parenthesis."
                    },
                    {
                        "username": "cennav",
                        "content": "Description problem says open brackets must be closed in the correct order\\nBut this test case \"( ( [ ] ) { } )\" is valid\\n\\nThe problem it\\'s not clear"
                    },
                    {
                        "username": "taronjimark",
                        "content": "Description of the problem is vague and needs more clarification. Nested parenthesis are another requirement. "
                    },
                    {
                        "username": "HDJCat",
                        "content": "Why is expected output for \"([)]\" False,\\nbut expected output for \"{[]}\" True?"
                    },
                    {
                        "username": "seraphsword",
                        "content": "The problem assumes you\\'ve taken algebra or some kind of programming. Proper nesting of parentheses is a requirement for either. So each bracket type has to be empty, completely enclosed, or completely enclosing another pair.\\n`result = a * (2 + arr[3 + x)]` wouldn\\'t be valid right? Because the closing parentheses is cutting off the square bracket."
                    },
                    {
                        "username": "fOOl_404",
                        "content": "Poor description !!"
                    },
                    {
                        "username": "mindgspl",
                        "content": "I looked later in some good runtime solutions but those didn\\'t PASS some of my test cases, for exemple those: \\n\"() [{ [  ] } ([]) ] [] ()\" \\nand\\n\"() [{}] ()\""
                    }
                ]
            },
            {
                "id": 1983050,
                "content": [
                    {
                        "username": "Hitesh-720_566",
                        "content": "class Solution {\\n    public boolean isValid(String str) {\\n        Stack<Character> s=new Stack<>();\\n        for(int i=0;i<str.length();i++){\\n            char cur=s.charAt(i);\\n            if(isOpening(cur)){\\n                s.push(cur);\\n            }else{\\n                if(s.isEmpty()){\\n                    retutn false;\\n                }else-if(!isMatching(s.peek(),cur)){\\n                    return false;\\n                }else{\\n                    s.pop();\\n                }\\n            }\\n        }\\n        return isEmpty();\\n    }\\n    static boolean isOpening(char c){\\n        return c=\\'(\\' || \\'{\\' || \\'[\\';\\n    }\\n    static boolean isMatching(char a, char b){\\n     return  (a=\\'()\\' && b=\\')\\') || (a=\\'{\\' || b=\\'}\\') || (a=\\'[\\' || b=\\']\\');\\n    }\\n}\\n\\nWHY IS IT SHOWING ERROR ?? Please anyone help"
                    },
                    {
                        "username": "mhou2009",
                        "content": "first of all you wrote \\u201Cretutn false;\\u201D :D"
                    },
                    {
                        "username": "Ahrorooney",
                        "content": "Good tricky question)"
                    },
                    {
                        "username": "Saurabhsingh635366",
                        "content": "class Solution {\npublic:\n\n  unordered_map<char, int> symbols={{'[', -1},{'{', -2},{'(', -3},{']', 1},{'}', 2},{')', 3}};\n    bool isValid(string s) {\n       stack<char> st;\n    \n    for(char bracket: s){\n        if(symbols[bracket]<0){\n            st.push(bracket);\n        }\n        else {\n              \n              if(st.empty()) return  false;\n              \n              char top= st.top();\n              st.pop();\n              if(symbols[bracket]+symbols[top]!=0){\n                  return false;\n              }\n        }\n    }\n    \n    if(st.empty()) return  true;\n    return  false;\n    \n    }\n};\n\nsee my approch guys this is proper working code.\n\n"
                    },
                    {
                        "username": "alice0217",
                        "content": "my advice for people who want to use stack is decide what to push to the stack."
                    },
                    {
                        "username": "MrxNoobie",
                        "content": "Someone please explain the fact that ([]{}) is valid but ([)] is not? How does this makes sense? They need to be more descriptive in their description and if someone have an explanation to this, Please do so. I have been stuck on this God damn problem for the past 3 HOURS. THIS IS DRIVING ME CRAZY."
                    },
                    {
                        "username": "seraphsword",
                        "content": "You have to think of it like an equation or a function. Every pair of opening and closing brackets has to be entirely enclosed by another pair, or entirely enclose another pair, or be empty. A pair can't be half-enclosed and half-not.\n`a = 2 * (x + 1 [y / 3] - {z^4 / 2})` would be an example of the valid string. \n`a = 2 * (x + 1 [y / 3)]` would be an example of the invalid string. The closing parentheses breaks the brackets.\n`result = 2 * (4 / bArray[3 + i)]` is another version of the invalid string. "
                    },
                    {
                        "username": "MrxNoobie",
                        "content": "[@Saurabhsingh635366](/Saurabhsingh635366) Thank you for the response but the thing is, I am aware how to stack works, and also thank you for bringing the light on it,  but here\\'s the thing, I don\\'t know how to implement that into the code. Can you please give me a hint on it? Thank you!"
                    },
                    {
                        "username": "Saurabhsingh635366",
                        "content": "first u push the open parenthesis \\'(\\' then \\'[\\' and u can see top element of the stack not match to the third bracket because nature of the bracket is not same that\\'s why are not able to pop the top element of the stack by rest of close parenthesis."
                    },
                    {
                        "username": "cennav",
                        "content": "Description problem says open brackets must be closed in the correct order\\nBut this test case \"( ( [ ] ) { } )\" is valid\\n\\nThe problem it\\'s not clear"
                    },
                    {
                        "username": "taronjimark",
                        "content": "Description of the problem is vague and needs more clarification. Nested parenthesis are another requirement. "
                    },
                    {
                        "username": "HDJCat",
                        "content": "Why is expected output for \"([)]\" False,\\nbut expected output for \"{[]}\" True?"
                    },
                    {
                        "username": "seraphsword",
                        "content": "The problem assumes you\\'ve taken algebra or some kind of programming. Proper nesting of parentheses is a requirement for either. So each bracket type has to be empty, completely enclosed, or completely enclosing another pair.\\n`result = a * (2 + arr[3 + x)]` wouldn\\'t be valid right? Because the closing parentheses is cutting off the square bracket."
                    },
                    {
                        "username": "fOOl_404",
                        "content": "Poor description !!"
                    },
                    {
                        "username": "mindgspl",
                        "content": "I looked later in some good runtime solutions but those didn\\'t PASS some of my test cases, for exemple those: \\n\"() [{ [  ] } ([]) ] [] ()\" \\nand\\n\"() [{}] ()\""
                    }
                ]
            },
            {
                "id": 1980516,
                "content": [
                    {
                        "username": "Hitesh-720_566",
                        "content": "class Solution {\\n    public boolean isValid(String str) {\\n        Stack<Character> s=new Stack<>();\\n        for(int i=0;i<str.length();i++){\\n            char cur=s.charAt(i);\\n            if(isOpening(cur)){\\n                s.push(cur);\\n            }else{\\n                if(s.isEmpty()){\\n                    retutn false;\\n                }else-if(!isMatching(s.peek(),cur)){\\n                    return false;\\n                }else{\\n                    s.pop();\\n                }\\n            }\\n        }\\n        return isEmpty();\\n    }\\n    static boolean isOpening(char c){\\n        return c=\\'(\\' || \\'{\\' || \\'[\\';\\n    }\\n    static boolean isMatching(char a, char b){\\n     return  (a=\\'()\\' && b=\\')\\') || (a=\\'{\\' || b=\\'}\\') || (a=\\'[\\' || b=\\']\\');\\n    }\\n}\\n\\nWHY IS IT SHOWING ERROR ?? Please anyone help"
                    },
                    {
                        "username": "mhou2009",
                        "content": "first of all you wrote \\u201Cretutn false;\\u201D :D"
                    },
                    {
                        "username": "Ahrorooney",
                        "content": "Good tricky question)"
                    },
                    {
                        "username": "Saurabhsingh635366",
                        "content": "class Solution {\npublic:\n\n  unordered_map<char, int> symbols={{'[', -1},{'{', -2},{'(', -3},{']', 1},{'}', 2},{')', 3}};\n    bool isValid(string s) {\n       stack<char> st;\n    \n    for(char bracket: s){\n        if(symbols[bracket]<0){\n            st.push(bracket);\n        }\n        else {\n              \n              if(st.empty()) return  false;\n              \n              char top= st.top();\n              st.pop();\n              if(symbols[bracket]+symbols[top]!=0){\n                  return false;\n              }\n        }\n    }\n    \n    if(st.empty()) return  true;\n    return  false;\n    \n    }\n};\n\nsee my approch guys this is proper working code.\n\n"
                    },
                    {
                        "username": "alice0217",
                        "content": "my advice for people who want to use stack is decide what to push to the stack."
                    },
                    {
                        "username": "MrxNoobie",
                        "content": "Someone please explain the fact that ([]{}) is valid but ([)] is not? How does this makes sense? They need to be more descriptive in their description and if someone have an explanation to this, Please do so. I have been stuck on this God damn problem for the past 3 HOURS. THIS IS DRIVING ME CRAZY."
                    },
                    {
                        "username": "seraphsword",
                        "content": "You have to think of it like an equation or a function. Every pair of opening and closing brackets has to be entirely enclosed by another pair, or entirely enclose another pair, or be empty. A pair can't be half-enclosed and half-not.\n`a = 2 * (x + 1 [y / 3] - {z^4 / 2})` would be an example of the valid string. \n`a = 2 * (x + 1 [y / 3)]` would be an example of the invalid string. The closing parentheses breaks the brackets.\n`result = 2 * (4 / bArray[3 + i)]` is another version of the invalid string. "
                    },
                    {
                        "username": "MrxNoobie",
                        "content": "[@Saurabhsingh635366](/Saurabhsingh635366) Thank you for the response but the thing is, I am aware how to stack works, and also thank you for bringing the light on it,  but here\\'s the thing, I don\\'t know how to implement that into the code. Can you please give me a hint on it? Thank you!"
                    },
                    {
                        "username": "Saurabhsingh635366",
                        "content": "first u push the open parenthesis \\'(\\' then \\'[\\' and u can see top element of the stack not match to the third bracket because nature of the bracket is not same that\\'s why are not able to pop the top element of the stack by rest of close parenthesis."
                    },
                    {
                        "username": "cennav",
                        "content": "Description problem says open brackets must be closed in the correct order\\nBut this test case \"( ( [ ] ) { } )\" is valid\\n\\nThe problem it\\'s not clear"
                    },
                    {
                        "username": "taronjimark",
                        "content": "Description of the problem is vague and needs more clarification. Nested parenthesis are another requirement. "
                    },
                    {
                        "username": "HDJCat",
                        "content": "Why is expected output for \"([)]\" False,\\nbut expected output for \"{[]}\" True?"
                    },
                    {
                        "username": "seraphsword",
                        "content": "The problem assumes you\\'ve taken algebra or some kind of programming. Proper nesting of parentheses is a requirement for either. So each bracket type has to be empty, completely enclosed, or completely enclosing another pair.\\n`result = a * (2 + arr[3 + x)]` wouldn\\'t be valid right? Because the closing parentheses is cutting off the square bracket."
                    },
                    {
                        "username": "fOOl_404",
                        "content": "Poor description !!"
                    },
                    {
                        "username": "mindgspl",
                        "content": "I looked later in some good runtime solutions but those didn\\'t PASS some of my test cases, for exemple those: \\n\"() [{ [  ] } ([]) ] [] ()\" \\nand\\n\"() [{}] ()\""
                    }
                ]
            },
            {
                "id": 1980336,
                "content": [
                    {
                        "username": "Hitesh-720_566",
                        "content": "class Solution {\\n    public boolean isValid(String str) {\\n        Stack<Character> s=new Stack<>();\\n        for(int i=0;i<str.length();i++){\\n            char cur=s.charAt(i);\\n            if(isOpening(cur)){\\n                s.push(cur);\\n            }else{\\n                if(s.isEmpty()){\\n                    retutn false;\\n                }else-if(!isMatching(s.peek(),cur)){\\n                    return false;\\n                }else{\\n                    s.pop();\\n                }\\n            }\\n        }\\n        return isEmpty();\\n    }\\n    static boolean isOpening(char c){\\n        return c=\\'(\\' || \\'{\\' || \\'[\\';\\n    }\\n    static boolean isMatching(char a, char b){\\n     return  (a=\\'()\\' && b=\\')\\') || (a=\\'{\\' || b=\\'}\\') || (a=\\'[\\' || b=\\']\\');\\n    }\\n}\\n\\nWHY IS IT SHOWING ERROR ?? Please anyone help"
                    },
                    {
                        "username": "mhou2009",
                        "content": "first of all you wrote \\u201Cretutn false;\\u201D :D"
                    },
                    {
                        "username": "Ahrorooney",
                        "content": "Good tricky question)"
                    },
                    {
                        "username": "Saurabhsingh635366",
                        "content": "class Solution {\npublic:\n\n  unordered_map<char, int> symbols={{'[', -1},{'{', -2},{'(', -3},{']', 1},{'}', 2},{')', 3}};\n    bool isValid(string s) {\n       stack<char> st;\n    \n    for(char bracket: s){\n        if(symbols[bracket]<0){\n            st.push(bracket);\n        }\n        else {\n              \n              if(st.empty()) return  false;\n              \n              char top= st.top();\n              st.pop();\n              if(symbols[bracket]+symbols[top]!=0){\n                  return false;\n              }\n        }\n    }\n    \n    if(st.empty()) return  true;\n    return  false;\n    \n    }\n};\n\nsee my approch guys this is proper working code.\n\n"
                    },
                    {
                        "username": "alice0217",
                        "content": "my advice for people who want to use stack is decide what to push to the stack."
                    },
                    {
                        "username": "MrxNoobie",
                        "content": "Someone please explain the fact that ([]{}) is valid but ([)] is not? How does this makes sense? They need to be more descriptive in their description and if someone have an explanation to this, Please do so. I have been stuck on this God damn problem for the past 3 HOURS. THIS IS DRIVING ME CRAZY."
                    },
                    {
                        "username": "seraphsword",
                        "content": "You have to think of it like an equation or a function. Every pair of opening and closing brackets has to be entirely enclosed by another pair, or entirely enclose another pair, or be empty. A pair can't be half-enclosed and half-not.\n`a = 2 * (x + 1 [y / 3] - {z^4 / 2})` would be an example of the valid string. \n`a = 2 * (x + 1 [y / 3)]` would be an example of the invalid string. The closing parentheses breaks the brackets.\n`result = 2 * (4 / bArray[3 + i)]` is another version of the invalid string. "
                    },
                    {
                        "username": "MrxNoobie",
                        "content": "[@Saurabhsingh635366](/Saurabhsingh635366) Thank you for the response but the thing is, I am aware how to stack works, and also thank you for bringing the light on it,  but here\\'s the thing, I don\\'t know how to implement that into the code. Can you please give me a hint on it? Thank you!"
                    },
                    {
                        "username": "Saurabhsingh635366",
                        "content": "first u push the open parenthesis \\'(\\' then \\'[\\' and u can see top element of the stack not match to the third bracket because nature of the bracket is not same that\\'s why are not able to pop the top element of the stack by rest of close parenthesis."
                    },
                    {
                        "username": "cennav",
                        "content": "Description problem says open brackets must be closed in the correct order\\nBut this test case \"( ( [ ] ) { } )\" is valid\\n\\nThe problem it\\'s not clear"
                    },
                    {
                        "username": "taronjimark",
                        "content": "Description of the problem is vague and needs more clarification. Nested parenthesis are another requirement. "
                    },
                    {
                        "username": "HDJCat",
                        "content": "Why is expected output for \"([)]\" False,\\nbut expected output for \"{[]}\" True?"
                    },
                    {
                        "username": "seraphsword",
                        "content": "The problem assumes you\\'ve taken algebra or some kind of programming. Proper nesting of parentheses is a requirement for either. So each bracket type has to be empty, completely enclosed, or completely enclosing another pair.\\n`result = a * (2 + arr[3 + x)]` wouldn\\'t be valid right? Because the closing parentheses is cutting off the square bracket."
                    },
                    {
                        "username": "fOOl_404",
                        "content": "Poor description !!"
                    },
                    {
                        "username": "mindgspl",
                        "content": "I looked later in some good runtime solutions but those didn\\'t PASS some of my test cases, for exemple those: \\n\"() [{ [  ] } ([]) ] [] ()\" \\nand\\n\"() [{}] ()\""
                    }
                ]
            },
            {
                "id": 1977866,
                "content": [
                    {
                        "username": "Hitesh-720_566",
                        "content": "class Solution {\\n    public boolean isValid(String str) {\\n        Stack<Character> s=new Stack<>();\\n        for(int i=0;i<str.length();i++){\\n            char cur=s.charAt(i);\\n            if(isOpening(cur)){\\n                s.push(cur);\\n            }else{\\n                if(s.isEmpty()){\\n                    retutn false;\\n                }else-if(!isMatching(s.peek(),cur)){\\n                    return false;\\n                }else{\\n                    s.pop();\\n                }\\n            }\\n        }\\n        return isEmpty();\\n    }\\n    static boolean isOpening(char c){\\n        return c=\\'(\\' || \\'{\\' || \\'[\\';\\n    }\\n    static boolean isMatching(char a, char b){\\n     return  (a=\\'()\\' && b=\\')\\') || (a=\\'{\\' || b=\\'}\\') || (a=\\'[\\' || b=\\']\\');\\n    }\\n}\\n\\nWHY IS IT SHOWING ERROR ?? Please anyone help"
                    },
                    {
                        "username": "mhou2009",
                        "content": "first of all you wrote \\u201Cretutn false;\\u201D :D"
                    },
                    {
                        "username": "Ahrorooney",
                        "content": "Good tricky question)"
                    },
                    {
                        "username": "Saurabhsingh635366",
                        "content": "class Solution {\npublic:\n\n  unordered_map<char, int> symbols={{'[', -1},{'{', -2},{'(', -3},{']', 1},{'}', 2},{')', 3}};\n    bool isValid(string s) {\n       stack<char> st;\n    \n    for(char bracket: s){\n        if(symbols[bracket]<0){\n            st.push(bracket);\n        }\n        else {\n              \n              if(st.empty()) return  false;\n              \n              char top= st.top();\n              st.pop();\n              if(symbols[bracket]+symbols[top]!=0){\n                  return false;\n              }\n        }\n    }\n    \n    if(st.empty()) return  true;\n    return  false;\n    \n    }\n};\n\nsee my approch guys this is proper working code.\n\n"
                    },
                    {
                        "username": "alice0217",
                        "content": "my advice for people who want to use stack is decide what to push to the stack."
                    },
                    {
                        "username": "MrxNoobie",
                        "content": "Someone please explain the fact that ([]{}) is valid but ([)] is not? How does this makes sense? They need to be more descriptive in their description and if someone have an explanation to this, Please do so. I have been stuck on this God damn problem for the past 3 HOURS. THIS IS DRIVING ME CRAZY."
                    },
                    {
                        "username": "seraphsword",
                        "content": "You have to think of it like an equation or a function. Every pair of opening and closing brackets has to be entirely enclosed by another pair, or entirely enclose another pair, or be empty. A pair can't be half-enclosed and half-not.\n`a = 2 * (x + 1 [y / 3] - {z^4 / 2})` would be an example of the valid string. \n`a = 2 * (x + 1 [y / 3)]` would be an example of the invalid string. The closing parentheses breaks the brackets.\n`result = 2 * (4 / bArray[3 + i)]` is another version of the invalid string. "
                    },
                    {
                        "username": "MrxNoobie",
                        "content": "[@Saurabhsingh635366](/Saurabhsingh635366) Thank you for the response but the thing is, I am aware how to stack works, and also thank you for bringing the light on it,  but here\\'s the thing, I don\\'t know how to implement that into the code. Can you please give me a hint on it? Thank you!"
                    },
                    {
                        "username": "Saurabhsingh635366",
                        "content": "first u push the open parenthesis \\'(\\' then \\'[\\' and u can see top element of the stack not match to the third bracket because nature of the bracket is not same that\\'s why are not able to pop the top element of the stack by rest of close parenthesis."
                    },
                    {
                        "username": "cennav",
                        "content": "Description problem says open brackets must be closed in the correct order\\nBut this test case \"( ( [ ] ) { } )\" is valid\\n\\nThe problem it\\'s not clear"
                    },
                    {
                        "username": "taronjimark",
                        "content": "Description of the problem is vague and needs more clarification. Nested parenthesis are another requirement. "
                    },
                    {
                        "username": "HDJCat",
                        "content": "Why is expected output for \"([)]\" False,\\nbut expected output for \"{[]}\" True?"
                    },
                    {
                        "username": "seraphsword",
                        "content": "The problem assumes you\\'ve taken algebra or some kind of programming. Proper nesting of parentheses is a requirement for either. So each bracket type has to be empty, completely enclosed, or completely enclosing another pair.\\n`result = a * (2 + arr[3 + x)]` wouldn\\'t be valid right? Because the closing parentheses is cutting off the square bracket."
                    },
                    {
                        "username": "fOOl_404",
                        "content": "Poor description !!"
                    },
                    {
                        "username": "mindgspl",
                        "content": "I looked later in some good runtime solutions but those didn\\'t PASS some of my test cases, for exemple those: \\n\"() [{ [  ] } ([]) ] [] ()\" \\nand\\n\"() [{}] ()\""
                    }
                ]
            },
            {
                "id": 1975294,
                "content": [
                    {
                        "username": "minhphamduy",
                        "content": "class Solution {\\n      private static boolean isMatchingPair(char c1, char c2) {\\n    return (c1 == \\'(\\' && c2 == \\')\\') || (c1 == \\'{\\' && c2 == \\'}\\') || (c1 == \\'[\\' && c2 == \\']\\');\\n  }\\n    public boolean isValid(String s) {\\n    Stack<Character> stack = new Stack<Character>();\\n    int n = s.length() - 1;\\n    for (int i = 0; i <= n; i++) {\\n      if (s.charAt(i) == \\'(\\' || s.charAt(i) == \\'{\\' || s.charAt(i) == \\'[\\') {\\n        stack.push(s.charAt((i)));\\n      } else if (s.charAt(i) == \\')\\' || s.charAt(i) == \\'}\\' || s.charAt(i) == \\']\\') {\\n        if (stack.isEmpty() || !isMatchingPair(stack.pop(), s.charAt(i))) {\\n          return false;\\n        }\\n      }\\n    }\\n    if(!stack.isEmpty()) {\\n        return false;\\n    }\\n    \\n    return true;\\n\\n  }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "azamuzapbar",
                        "content": "\"(){}}{\" why is it True?"
                    },
                    {
                        "username": "vikash_singh_vogel",
                        "content": "it can be achieved by simple if else "
                    },
                    {
                        "username": "klu_2000032013",
                        "content": "class Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        if(s[0]==\\']\\' || s[0]==\\'}\\' || s[0]==\\')\\'){\\n            return false;\\n        }\\n        for(int i=0;s[i]!=\\'\\\\0\\';i++){\\n            if(s[i]==\\'(\\' || s[i]==\\'{\\' || s[i]==\\'[\\'){\\n                      st.push(s[i]);\\n            }\\n            else if(st.empty()){\\n                return false;\\n            }\\n            else if(st.top()==\\'(\\' && s[i]==\\')\\' || st.top()==\\'{\\' && s[i]==\\'}\\' || st.top()==\\'[\\' && s[i]==\\']\\'){\\n                            st.pop();\\n            }\\n            else\\n               return false;\\n            \\n                \\n        }\\n              \\n        if(st.empty())\\n            return true;\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "anubhavsrivastava30",
                        "content": "My code in my local editor shows false as output for this input \"(]\" while the output is true in leetcode editor. \\nnot sure if its on purpose or some bug."
                    },
                    {
                        "username": "Goran5",
                        "content": "I haven\\'t looked at any solutions for this yet and I\\'m still trying to solve it. I was wondering, is there a O(n) time complexity solution for this?"
                    },
                    {
                        "username": "precelek211",
                        "content": "\"{ [ ] }\" this is true but this \"( [  ) ]\" false?\\nwhere is consistency? in this case every test can be independently threaded\\nalso map doesn\\'t contains \"contains\" feature in C++? \\n"
                    },
                    {
                        "username": "data-stack",
                        "content": "There is consistency in this: The brackets have to be in the correct order in a mathematical sense. You cannot close an outer bracket in a formula before you closed all inner brackets.  \"( [ ) ]\" dies exactly that - it closes the outer bracket before closing the inner \"[ ]\"."
                    },
                    {
                        "username": "kaxagvimraze",
                        "content": "why this is not valid? ([)] ?\\n"
                    },
                    {
                        "username": "susan_m_2022",
                        "content": "Brackets must be closed in the correct order. These are out of order."
                    },
                    {
                        "username": "user2809sJ",
                        "content": "([)]   why the result of this should be expected false , i dnt have any idea , brackets are opened and closed in correct order"
                    },
                    {
                        "username": "susan_m_2022",
                        "content": "Correct order would be ()[] or []() not ([)]"
                    },
                    {
                        "username": "RealUbaid",
                        "content": "No every bracket set should have either nothing in it, or a complete set of brackets in it. One single bracket is false."
                    },
                    {
                        "username": "Rohan1505",
                        "content": "The brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\\n\\nFrom this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid.\\nThen I think the problem description should be updated."
                    }
                ]
            },
            {
                "id": 1968341,
                "content": [
                    {
                        "username": "minhphamduy",
                        "content": "class Solution {\\n      private static boolean isMatchingPair(char c1, char c2) {\\n    return (c1 == \\'(\\' && c2 == \\')\\') || (c1 == \\'{\\' && c2 == \\'}\\') || (c1 == \\'[\\' && c2 == \\']\\');\\n  }\\n    public boolean isValid(String s) {\\n    Stack<Character> stack = new Stack<Character>();\\n    int n = s.length() - 1;\\n    for (int i = 0; i <= n; i++) {\\n      if (s.charAt(i) == \\'(\\' || s.charAt(i) == \\'{\\' || s.charAt(i) == \\'[\\') {\\n        stack.push(s.charAt((i)));\\n      } else if (s.charAt(i) == \\')\\' || s.charAt(i) == \\'}\\' || s.charAt(i) == \\']\\') {\\n        if (stack.isEmpty() || !isMatchingPair(stack.pop(), s.charAt(i))) {\\n          return false;\\n        }\\n      }\\n    }\\n    if(!stack.isEmpty()) {\\n        return false;\\n    }\\n    \\n    return true;\\n\\n  }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "azamuzapbar",
                        "content": "\"(){}}{\" why is it True?"
                    },
                    {
                        "username": "vikash_singh_vogel",
                        "content": "it can be achieved by simple if else "
                    },
                    {
                        "username": "klu_2000032013",
                        "content": "class Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        if(s[0]==\\']\\' || s[0]==\\'}\\' || s[0]==\\')\\'){\\n            return false;\\n        }\\n        for(int i=0;s[i]!=\\'\\\\0\\';i++){\\n            if(s[i]==\\'(\\' || s[i]==\\'{\\' || s[i]==\\'[\\'){\\n                      st.push(s[i]);\\n            }\\n            else if(st.empty()){\\n                return false;\\n            }\\n            else if(st.top()==\\'(\\' && s[i]==\\')\\' || st.top()==\\'{\\' && s[i]==\\'}\\' || st.top()==\\'[\\' && s[i]==\\']\\'){\\n                            st.pop();\\n            }\\n            else\\n               return false;\\n            \\n                \\n        }\\n              \\n        if(st.empty())\\n            return true;\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "anubhavsrivastava30",
                        "content": "My code in my local editor shows false as output for this input \"(]\" while the output is true in leetcode editor. \\nnot sure if its on purpose or some bug."
                    },
                    {
                        "username": "Goran5",
                        "content": "I haven\\'t looked at any solutions for this yet and I\\'m still trying to solve it. I was wondering, is there a O(n) time complexity solution for this?"
                    },
                    {
                        "username": "precelek211",
                        "content": "\"{ [ ] }\" this is true but this \"( [  ) ]\" false?\\nwhere is consistency? in this case every test can be independently threaded\\nalso map doesn\\'t contains \"contains\" feature in C++? \\n"
                    },
                    {
                        "username": "data-stack",
                        "content": "There is consistency in this: The brackets have to be in the correct order in a mathematical sense. You cannot close an outer bracket in a formula before you closed all inner brackets.  \"( [ ) ]\" dies exactly that - it closes the outer bracket before closing the inner \"[ ]\"."
                    },
                    {
                        "username": "kaxagvimraze",
                        "content": "why this is not valid? ([)] ?\\n"
                    },
                    {
                        "username": "susan_m_2022",
                        "content": "Brackets must be closed in the correct order. These are out of order."
                    },
                    {
                        "username": "user2809sJ",
                        "content": "([)]   why the result of this should be expected false , i dnt have any idea , brackets are opened and closed in correct order"
                    },
                    {
                        "username": "susan_m_2022",
                        "content": "Correct order would be ()[] or []() not ([)]"
                    },
                    {
                        "username": "RealUbaid",
                        "content": "No every bracket set should have either nothing in it, or a complete set of brackets in it. One single bracket is false."
                    },
                    {
                        "username": "Rohan1505",
                        "content": "The brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\\n\\nFrom this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid.\\nThen I think the problem description should be updated."
                    }
                ]
            },
            {
                "id": 1967773,
                "content": [
                    {
                        "username": "minhphamduy",
                        "content": "class Solution {\\n      private static boolean isMatchingPair(char c1, char c2) {\\n    return (c1 == \\'(\\' && c2 == \\')\\') || (c1 == \\'{\\' && c2 == \\'}\\') || (c1 == \\'[\\' && c2 == \\']\\');\\n  }\\n    public boolean isValid(String s) {\\n    Stack<Character> stack = new Stack<Character>();\\n    int n = s.length() - 1;\\n    for (int i = 0; i <= n; i++) {\\n      if (s.charAt(i) == \\'(\\' || s.charAt(i) == \\'{\\' || s.charAt(i) == \\'[\\') {\\n        stack.push(s.charAt((i)));\\n      } else if (s.charAt(i) == \\')\\' || s.charAt(i) == \\'}\\' || s.charAt(i) == \\']\\') {\\n        if (stack.isEmpty() || !isMatchingPair(stack.pop(), s.charAt(i))) {\\n          return false;\\n        }\\n      }\\n    }\\n    if(!stack.isEmpty()) {\\n        return false;\\n    }\\n    \\n    return true;\\n\\n  }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "azamuzapbar",
                        "content": "\"(){}}{\" why is it True?"
                    },
                    {
                        "username": "vikash_singh_vogel",
                        "content": "it can be achieved by simple if else "
                    },
                    {
                        "username": "klu_2000032013",
                        "content": "class Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        if(s[0]==\\']\\' || s[0]==\\'}\\' || s[0]==\\')\\'){\\n            return false;\\n        }\\n        for(int i=0;s[i]!=\\'\\\\0\\';i++){\\n            if(s[i]==\\'(\\' || s[i]==\\'{\\' || s[i]==\\'[\\'){\\n                      st.push(s[i]);\\n            }\\n            else if(st.empty()){\\n                return false;\\n            }\\n            else if(st.top()==\\'(\\' && s[i]==\\')\\' || st.top()==\\'{\\' && s[i]==\\'}\\' || st.top()==\\'[\\' && s[i]==\\']\\'){\\n                            st.pop();\\n            }\\n            else\\n               return false;\\n            \\n                \\n        }\\n              \\n        if(st.empty())\\n            return true;\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "anubhavsrivastava30",
                        "content": "My code in my local editor shows false as output for this input \"(]\" while the output is true in leetcode editor. \\nnot sure if its on purpose or some bug."
                    },
                    {
                        "username": "Goran5",
                        "content": "I haven\\'t looked at any solutions for this yet and I\\'m still trying to solve it. I was wondering, is there a O(n) time complexity solution for this?"
                    },
                    {
                        "username": "precelek211",
                        "content": "\"{ [ ] }\" this is true but this \"( [  ) ]\" false?\\nwhere is consistency? in this case every test can be independently threaded\\nalso map doesn\\'t contains \"contains\" feature in C++? \\n"
                    },
                    {
                        "username": "data-stack",
                        "content": "There is consistency in this: The brackets have to be in the correct order in a mathematical sense. You cannot close an outer bracket in a formula before you closed all inner brackets.  \"( [ ) ]\" dies exactly that - it closes the outer bracket before closing the inner \"[ ]\"."
                    },
                    {
                        "username": "kaxagvimraze",
                        "content": "why this is not valid? ([)] ?\\n"
                    },
                    {
                        "username": "susan_m_2022",
                        "content": "Brackets must be closed in the correct order. These are out of order."
                    },
                    {
                        "username": "user2809sJ",
                        "content": "([)]   why the result of this should be expected false , i dnt have any idea , brackets are opened and closed in correct order"
                    },
                    {
                        "username": "susan_m_2022",
                        "content": "Correct order would be ()[] or []() not ([)]"
                    },
                    {
                        "username": "RealUbaid",
                        "content": "No every bracket set should have either nothing in it, or a complete set of brackets in it. One single bracket is false."
                    },
                    {
                        "username": "Rohan1505",
                        "content": "The brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\\n\\nFrom this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid.\\nThen I think the problem description should be updated."
                    }
                ]
            },
            {
                "id": 1966487,
                "content": [
                    {
                        "username": "minhphamduy",
                        "content": "class Solution {\\n      private static boolean isMatchingPair(char c1, char c2) {\\n    return (c1 == \\'(\\' && c2 == \\')\\') || (c1 == \\'{\\' && c2 == \\'}\\') || (c1 == \\'[\\' && c2 == \\']\\');\\n  }\\n    public boolean isValid(String s) {\\n    Stack<Character> stack = new Stack<Character>();\\n    int n = s.length() - 1;\\n    for (int i = 0; i <= n; i++) {\\n      if (s.charAt(i) == \\'(\\' || s.charAt(i) == \\'{\\' || s.charAt(i) == \\'[\\') {\\n        stack.push(s.charAt((i)));\\n      } else if (s.charAt(i) == \\')\\' || s.charAt(i) == \\'}\\' || s.charAt(i) == \\']\\') {\\n        if (stack.isEmpty() || !isMatchingPair(stack.pop(), s.charAt(i))) {\\n          return false;\\n        }\\n      }\\n    }\\n    if(!stack.isEmpty()) {\\n        return false;\\n    }\\n    \\n    return true;\\n\\n  }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "azamuzapbar",
                        "content": "\"(){}}{\" why is it True?"
                    },
                    {
                        "username": "vikash_singh_vogel",
                        "content": "it can be achieved by simple if else "
                    },
                    {
                        "username": "klu_2000032013",
                        "content": "class Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        if(s[0]==\\']\\' || s[0]==\\'}\\' || s[0]==\\')\\'){\\n            return false;\\n        }\\n        for(int i=0;s[i]!=\\'\\\\0\\';i++){\\n            if(s[i]==\\'(\\' || s[i]==\\'{\\' || s[i]==\\'[\\'){\\n                      st.push(s[i]);\\n            }\\n            else if(st.empty()){\\n                return false;\\n            }\\n            else if(st.top()==\\'(\\' && s[i]==\\')\\' || st.top()==\\'{\\' && s[i]==\\'}\\' || st.top()==\\'[\\' && s[i]==\\']\\'){\\n                            st.pop();\\n            }\\n            else\\n               return false;\\n            \\n                \\n        }\\n              \\n        if(st.empty())\\n            return true;\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "anubhavsrivastava30",
                        "content": "My code in my local editor shows false as output for this input \"(]\" while the output is true in leetcode editor. \\nnot sure if its on purpose or some bug."
                    },
                    {
                        "username": "Goran5",
                        "content": "I haven\\'t looked at any solutions for this yet and I\\'m still trying to solve it. I was wondering, is there a O(n) time complexity solution for this?"
                    },
                    {
                        "username": "precelek211",
                        "content": "\"{ [ ] }\" this is true but this \"( [  ) ]\" false?\\nwhere is consistency? in this case every test can be independently threaded\\nalso map doesn\\'t contains \"contains\" feature in C++? \\n"
                    },
                    {
                        "username": "data-stack",
                        "content": "There is consistency in this: The brackets have to be in the correct order in a mathematical sense. You cannot close an outer bracket in a formula before you closed all inner brackets.  \"( [ ) ]\" dies exactly that - it closes the outer bracket before closing the inner \"[ ]\"."
                    },
                    {
                        "username": "kaxagvimraze",
                        "content": "why this is not valid? ([)] ?\\n"
                    },
                    {
                        "username": "susan_m_2022",
                        "content": "Brackets must be closed in the correct order. These are out of order."
                    },
                    {
                        "username": "user2809sJ",
                        "content": "([)]   why the result of this should be expected false , i dnt have any idea , brackets are opened and closed in correct order"
                    },
                    {
                        "username": "susan_m_2022",
                        "content": "Correct order would be ()[] or []() not ([)]"
                    },
                    {
                        "username": "RealUbaid",
                        "content": "No every bracket set should have either nothing in it, or a complete set of brackets in it. One single bracket is false."
                    },
                    {
                        "username": "Rohan1505",
                        "content": "The brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\\n\\nFrom this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid.\\nThen I think the problem description should be updated."
                    }
                ]
            },
            {
                "id": 1963472,
                "content": [
                    {
                        "username": "minhphamduy",
                        "content": "class Solution {\\n      private static boolean isMatchingPair(char c1, char c2) {\\n    return (c1 == \\'(\\' && c2 == \\')\\') || (c1 == \\'{\\' && c2 == \\'}\\') || (c1 == \\'[\\' && c2 == \\']\\');\\n  }\\n    public boolean isValid(String s) {\\n    Stack<Character> stack = new Stack<Character>();\\n    int n = s.length() - 1;\\n    for (int i = 0; i <= n; i++) {\\n      if (s.charAt(i) == \\'(\\' || s.charAt(i) == \\'{\\' || s.charAt(i) == \\'[\\') {\\n        stack.push(s.charAt((i)));\\n      } else if (s.charAt(i) == \\')\\' || s.charAt(i) == \\'}\\' || s.charAt(i) == \\']\\') {\\n        if (stack.isEmpty() || !isMatchingPair(stack.pop(), s.charAt(i))) {\\n          return false;\\n        }\\n      }\\n    }\\n    if(!stack.isEmpty()) {\\n        return false;\\n    }\\n    \\n    return true;\\n\\n  }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "azamuzapbar",
                        "content": "\"(){}}{\" why is it True?"
                    },
                    {
                        "username": "vikash_singh_vogel",
                        "content": "it can be achieved by simple if else "
                    },
                    {
                        "username": "klu_2000032013",
                        "content": "class Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        if(s[0]==\\']\\' || s[0]==\\'}\\' || s[0]==\\')\\'){\\n            return false;\\n        }\\n        for(int i=0;s[i]!=\\'\\\\0\\';i++){\\n            if(s[i]==\\'(\\' || s[i]==\\'{\\' || s[i]==\\'[\\'){\\n                      st.push(s[i]);\\n            }\\n            else if(st.empty()){\\n                return false;\\n            }\\n            else if(st.top()==\\'(\\' && s[i]==\\')\\' || st.top()==\\'{\\' && s[i]==\\'}\\' || st.top()==\\'[\\' && s[i]==\\']\\'){\\n                            st.pop();\\n            }\\n            else\\n               return false;\\n            \\n                \\n        }\\n              \\n        if(st.empty())\\n            return true;\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "anubhavsrivastava30",
                        "content": "My code in my local editor shows false as output for this input \"(]\" while the output is true in leetcode editor. \\nnot sure if its on purpose or some bug."
                    },
                    {
                        "username": "Goran5",
                        "content": "I haven\\'t looked at any solutions for this yet and I\\'m still trying to solve it. I was wondering, is there a O(n) time complexity solution for this?"
                    },
                    {
                        "username": "precelek211",
                        "content": "\"{ [ ] }\" this is true but this \"( [  ) ]\" false?\\nwhere is consistency? in this case every test can be independently threaded\\nalso map doesn\\'t contains \"contains\" feature in C++? \\n"
                    },
                    {
                        "username": "data-stack",
                        "content": "There is consistency in this: The brackets have to be in the correct order in a mathematical sense. You cannot close an outer bracket in a formula before you closed all inner brackets.  \"( [ ) ]\" dies exactly that - it closes the outer bracket before closing the inner \"[ ]\"."
                    },
                    {
                        "username": "kaxagvimraze",
                        "content": "why this is not valid? ([)] ?\\n"
                    },
                    {
                        "username": "susan_m_2022",
                        "content": "Brackets must be closed in the correct order. These are out of order."
                    },
                    {
                        "username": "user2809sJ",
                        "content": "([)]   why the result of this should be expected false , i dnt have any idea , brackets are opened and closed in correct order"
                    },
                    {
                        "username": "susan_m_2022",
                        "content": "Correct order would be ()[] or []() not ([)]"
                    },
                    {
                        "username": "RealUbaid",
                        "content": "No every bracket set should have either nothing in it, or a complete set of brackets in it. One single bracket is false."
                    },
                    {
                        "username": "Rohan1505",
                        "content": "The brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\\n\\nFrom this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid.\\nThen I think the problem description should be updated."
                    }
                ]
            },
            {
                "id": 1957286,
                "content": [
                    {
                        "username": "minhphamduy",
                        "content": "class Solution {\\n      private static boolean isMatchingPair(char c1, char c2) {\\n    return (c1 == \\'(\\' && c2 == \\')\\') || (c1 == \\'{\\' && c2 == \\'}\\') || (c1 == \\'[\\' && c2 == \\']\\');\\n  }\\n    public boolean isValid(String s) {\\n    Stack<Character> stack = new Stack<Character>();\\n    int n = s.length() - 1;\\n    for (int i = 0; i <= n; i++) {\\n      if (s.charAt(i) == \\'(\\' || s.charAt(i) == \\'{\\' || s.charAt(i) == \\'[\\') {\\n        stack.push(s.charAt((i)));\\n      } else if (s.charAt(i) == \\')\\' || s.charAt(i) == \\'}\\' || s.charAt(i) == \\']\\') {\\n        if (stack.isEmpty() || !isMatchingPair(stack.pop(), s.charAt(i))) {\\n          return false;\\n        }\\n      }\\n    }\\n    if(!stack.isEmpty()) {\\n        return false;\\n    }\\n    \\n    return true;\\n\\n  }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "azamuzapbar",
                        "content": "\"(){}}{\" why is it True?"
                    },
                    {
                        "username": "vikash_singh_vogel",
                        "content": "it can be achieved by simple if else "
                    },
                    {
                        "username": "klu_2000032013",
                        "content": "class Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        if(s[0]==\\']\\' || s[0]==\\'}\\' || s[0]==\\')\\'){\\n            return false;\\n        }\\n        for(int i=0;s[i]!=\\'\\\\0\\';i++){\\n            if(s[i]==\\'(\\' || s[i]==\\'{\\' || s[i]==\\'[\\'){\\n                      st.push(s[i]);\\n            }\\n            else if(st.empty()){\\n                return false;\\n            }\\n            else if(st.top()==\\'(\\' && s[i]==\\')\\' || st.top()==\\'{\\' && s[i]==\\'}\\' || st.top()==\\'[\\' && s[i]==\\']\\'){\\n                            st.pop();\\n            }\\n            else\\n               return false;\\n            \\n                \\n        }\\n              \\n        if(st.empty())\\n            return true;\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "anubhavsrivastava30",
                        "content": "My code in my local editor shows false as output for this input \"(]\" while the output is true in leetcode editor. \\nnot sure if its on purpose or some bug."
                    },
                    {
                        "username": "Goran5",
                        "content": "I haven\\'t looked at any solutions for this yet and I\\'m still trying to solve it. I was wondering, is there a O(n) time complexity solution for this?"
                    },
                    {
                        "username": "precelek211",
                        "content": "\"{ [ ] }\" this is true but this \"( [  ) ]\" false?\\nwhere is consistency? in this case every test can be independently threaded\\nalso map doesn\\'t contains \"contains\" feature in C++? \\n"
                    },
                    {
                        "username": "data-stack",
                        "content": "There is consistency in this: The brackets have to be in the correct order in a mathematical sense. You cannot close an outer bracket in a formula before you closed all inner brackets.  \"( [ ) ]\" dies exactly that - it closes the outer bracket before closing the inner \"[ ]\"."
                    },
                    {
                        "username": "kaxagvimraze",
                        "content": "why this is not valid? ([)] ?\\n"
                    },
                    {
                        "username": "susan_m_2022",
                        "content": "Brackets must be closed in the correct order. These are out of order."
                    },
                    {
                        "username": "user2809sJ",
                        "content": "([)]   why the result of this should be expected false , i dnt have any idea , brackets are opened and closed in correct order"
                    },
                    {
                        "username": "susan_m_2022",
                        "content": "Correct order would be ()[] or []() not ([)]"
                    },
                    {
                        "username": "RealUbaid",
                        "content": "No every bracket set should have either nothing in it, or a complete set of brackets in it. One single bracket is false."
                    },
                    {
                        "username": "Rohan1505",
                        "content": "The brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\\n\\nFrom this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid.\\nThen I think the problem description should be updated."
                    }
                ]
            },
            {
                "id": 1957114,
                "content": [
                    {
                        "username": "minhphamduy",
                        "content": "class Solution {\\n      private static boolean isMatchingPair(char c1, char c2) {\\n    return (c1 == \\'(\\' && c2 == \\')\\') || (c1 == \\'{\\' && c2 == \\'}\\') || (c1 == \\'[\\' && c2 == \\']\\');\\n  }\\n    public boolean isValid(String s) {\\n    Stack<Character> stack = new Stack<Character>();\\n    int n = s.length() - 1;\\n    for (int i = 0; i <= n; i++) {\\n      if (s.charAt(i) == \\'(\\' || s.charAt(i) == \\'{\\' || s.charAt(i) == \\'[\\') {\\n        stack.push(s.charAt((i)));\\n      } else if (s.charAt(i) == \\')\\' || s.charAt(i) == \\'}\\' || s.charAt(i) == \\']\\') {\\n        if (stack.isEmpty() || !isMatchingPair(stack.pop(), s.charAt(i))) {\\n          return false;\\n        }\\n      }\\n    }\\n    if(!stack.isEmpty()) {\\n        return false;\\n    }\\n    \\n    return true;\\n\\n  }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "azamuzapbar",
                        "content": "\"(){}}{\" why is it True?"
                    },
                    {
                        "username": "vikash_singh_vogel",
                        "content": "it can be achieved by simple if else "
                    },
                    {
                        "username": "klu_2000032013",
                        "content": "class Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        if(s[0]==\\']\\' || s[0]==\\'}\\' || s[0]==\\')\\'){\\n            return false;\\n        }\\n        for(int i=0;s[i]!=\\'\\\\0\\';i++){\\n            if(s[i]==\\'(\\' || s[i]==\\'{\\' || s[i]==\\'[\\'){\\n                      st.push(s[i]);\\n            }\\n            else if(st.empty()){\\n                return false;\\n            }\\n            else if(st.top()==\\'(\\' && s[i]==\\')\\' || st.top()==\\'{\\' && s[i]==\\'}\\' || st.top()==\\'[\\' && s[i]==\\']\\'){\\n                            st.pop();\\n            }\\n            else\\n               return false;\\n            \\n                \\n        }\\n              \\n        if(st.empty())\\n            return true;\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "anubhavsrivastava30",
                        "content": "My code in my local editor shows false as output for this input \"(]\" while the output is true in leetcode editor. \\nnot sure if its on purpose or some bug."
                    },
                    {
                        "username": "Goran5",
                        "content": "I haven\\'t looked at any solutions for this yet and I\\'m still trying to solve it. I was wondering, is there a O(n) time complexity solution for this?"
                    },
                    {
                        "username": "precelek211",
                        "content": "\"{ [ ] }\" this is true but this \"( [  ) ]\" false?\\nwhere is consistency? in this case every test can be independently threaded\\nalso map doesn\\'t contains \"contains\" feature in C++? \\n"
                    },
                    {
                        "username": "data-stack",
                        "content": "There is consistency in this: The brackets have to be in the correct order in a mathematical sense. You cannot close an outer bracket in a formula before you closed all inner brackets.  \"( [ ) ]\" dies exactly that - it closes the outer bracket before closing the inner \"[ ]\"."
                    },
                    {
                        "username": "kaxagvimraze",
                        "content": "why this is not valid? ([)] ?\\n"
                    },
                    {
                        "username": "susan_m_2022",
                        "content": "Brackets must be closed in the correct order. These are out of order."
                    },
                    {
                        "username": "user2809sJ",
                        "content": "([)]   why the result of this should be expected false , i dnt have any idea , brackets are opened and closed in correct order"
                    },
                    {
                        "username": "susan_m_2022",
                        "content": "Correct order would be ()[] or []() not ([)]"
                    },
                    {
                        "username": "RealUbaid",
                        "content": "No every bracket set should have either nothing in it, or a complete set of brackets in it. One single bracket is false."
                    },
                    {
                        "username": "Rohan1505",
                        "content": "The brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\\n\\nFrom this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid.\\nThen I think the problem description should be updated."
                    }
                ]
            },
            {
                "id": 1950885,
                "content": [
                    {
                        "username": "minhphamduy",
                        "content": "class Solution {\\n      private static boolean isMatchingPair(char c1, char c2) {\\n    return (c1 == \\'(\\' && c2 == \\')\\') || (c1 == \\'{\\' && c2 == \\'}\\') || (c1 == \\'[\\' && c2 == \\']\\');\\n  }\\n    public boolean isValid(String s) {\\n    Stack<Character> stack = new Stack<Character>();\\n    int n = s.length() - 1;\\n    for (int i = 0; i <= n; i++) {\\n      if (s.charAt(i) == \\'(\\' || s.charAt(i) == \\'{\\' || s.charAt(i) == \\'[\\') {\\n        stack.push(s.charAt((i)));\\n      } else if (s.charAt(i) == \\')\\' || s.charAt(i) == \\'}\\' || s.charAt(i) == \\']\\') {\\n        if (stack.isEmpty() || !isMatchingPair(stack.pop(), s.charAt(i))) {\\n          return false;\\n        }\\n      }\\n    }\\n    if(!stack.isEmpty()) {\\n        return false;\\n    }\\n    \\n    return true;\\n\\n  }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "azamuzapbar",
                        "content": "\"(){}}{\" why is it True?"
                    },
                    {
                        "username": "vikash_singh_vogel",
                        "content": "it can be achieved by simple if else "
                    },
                    {
                        "username": "klu_2000032013",
                        "content": "class Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        if(s[0]==\\']\\' || s[0]==\\'}\\' || s[0]==\\')\\'){\\n            return false;\\n        }\\n        for(int i=0;s[i]!=\\'\\\\0\\';i++){\\n            if(s[i]==\\'(\\' || s[i]==\\'{\\' || s[i]==\\'[\\'){\\n                      st.push(s[i]);\\n            }\\n            else if(st.empty()){\\n                return false;\\n            }\\n            else if(st.top()==\\'(\\' && s[i]==\\')\\' || st.top()==\\'{\\' && s[i]==\\'}\\' || st.top()==\\'[\\' && s[i]==\\']\\'){\\n                            st.pop();\\n            }\\n            else\\n               return false;\\n            \\n                \\n        }\\n              \\n        if(st.empty())\\n            return true;\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "anubhavsrivastava30",
                        "content": "My code in my local editor shows false as output for this input \"(]\" while the output is true in leetcode editor. \\nnot sure if its on purpose or some bug."
                    },
                    {
                        "username": "Goran5",
                        "content": "I haven\\'t looked at any solutions for this yet and I\\'m still trying to solve it. I was wondering, is there a O(n) time complexity solution for this?"
                    },
                    {
                        "username": "precelek211",
                        "content": "\"{ [ ] }\" this is true but this \"( [  ) ]\" false?\\nwhere is consistency? in this case every test can be independently threaded\\nalso map doesn\\'t contains \"contains\" feature in C++? \\n"
                    },
                    {
                        "username": "data-stack",
                        "content": "There is consistency in this: The brackets have to be in the correct order in a mathematical sense. You cannot close an outer bracket in a formula before you closed all inner brackets.  \"( [ ) ]\" dies exactly that - it closes the outer bracket before closing the inner \"[ ]\"."
                    },
                    {
                        "username": "kaxagvimraze",
                        "content": "why this is not valid? ([)] ?\\n"
                    },
                    {
                        "username": "susan_m_2022",
                        "content": "Brackets must be closed in the correct order. These are out of order."
                    },
                    {
                        "username": "user2809sJ",
                        "content": "([)]   why the result of this should be expected false , i dnt have any idea , brackets are opened and closed in correct order"
                    },
                    {
                        "username": "susan_m_2022",
                        "content": "Correct order would be ()[] or []() not ([)]"
                    },
                    {
                        "username": "RealUbaid",
                        "content": "No every bracket set should have either nothing in it, or a complete set of brackets in it. One single bracket is false."
                    },
                    {
                        "username": "Rohan1505",
                        "content": "The brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\\n\\nFrom this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid.\\nThen I think the problem description should be updated."
                    }
                ]
            },
            {
                "id": 1942215,
                "content": [
                    {
                        "username": "minhphamduy",
                        "content": "class Solution {\\n      private static boolean isMatchingPair(char c1, char c2) {\\n    return (c1 == \\'(\\' && c2 == \\')\\') || (c1 == \\'{\\' && c2 == \\'}\\') || (c1 == \\'[\\' && c2 == \\']\\');\\n  }\\n    public boolean isValid(String s) {\\n    Stack<Character> stack = new Stack<Character>();\\n    int n = s.length() - 1;\\n    for (int i = 0; i <= n; i++) {\\n      if (s.charAt(i) == \\'(\\' || s.charAt(i) == \\'{\\' || s.charAt(i) == \\'[\\') {\\n        stack.push(s.charAt((i)));\\n      } else if (s.charAt(i) == \\')\\' || s.charAt(i) == \\'}\\' || s.charAt(i) == \\']\\') {\\n        if (stack.isEmpty() || !isMatchingPair(stack.pop(), s.charAt(i))) {\\n          return false;\\n        }\\n      }\\n    }\\n    if(!stack.isEmpty()) {\\n        return false;\\n    }\\n    \\n    return true;\\n\\n  }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "azamuzapbar",
                        "content": "\"(){}}{\" why is it True?"
                    },
                    {
                        "username": "vikash_singh_vogel",
                        "content": "it can be achieved by simple if else "
                    },
                    {
                        "username": "klu_2000032013",
                        "content": "class Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        if(s[0]==\\']\\' || s[0]==\\'}\\' || s[0]==\\')\\'){\\n            return false;\\n        }\\n        for(int i=0;s[i]!=\\'\\\\0\\';i++){\\n            if(s[i]==\\'(\\' || s[i]==\\'{\\' || s[i]==\\'[\\'){\\n                      st.push(s[i]);\\n            }\\n            else if(st.empty()){\\n                return false;\\n            }\\n            else if(st.top()==\\'(\\' && s[i]==\\')\\' || st.top()==\\'{\\' && s[i]==\\'}\\' || st.top()==\\'[\\' && s[i]==\\']\\'){\\n                            st.pop();\\n            }\\n            else\\n               return false;\\n            \\n                \\n        }\\n              \\n        if(st.empty())\\n            return true;\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "anubhavsrivastava30",
                        "content": "My code in my local editor shows false as output for this input \"(]\" while the output is true in leetcode editor. \\nnot sure if its on purpose or some bug."
                    },
                    {
                        "username": "Goran5",
                        "content": "I haven\\'t looked at any solutions for this yet and I\\'m still trying to solve it. I was wondering, is there a O(n) time complexity solution for this?"
                    },
                    {
                        "username": "precelek211",
                        "content": "\"{ [ ] }\" this is true but this \"( [  ) ]\" false?\\nwhere is consistency? in this case every test can be independently threaded\\nalso map doesn\\'t contains \"contains\" feature in C++? \\n"
                    },
                    {
                        "username": "data-stack",
                        "content": "There is consistency in this: The brackets have to be in the correct order in a mathematical sense. You cannot close an outer bracket in a formula before you closed all inner brackets.  \"( [ ) ]\" dies exactly that - it closes the outer bracket before closing the inner \"[ ]\"."
                    },
                    {
                        "username": "kaxagvimraze",
                        "content": "why this is not valid? ([)] ?\\n"
                    },
                    {
                        "username": "susan_m_2022",
                        "content": "Brackets must be closed in the correct order. These are out of order."
                    },
                    {
                        "username": "user2809sJ",
                        "content": "([)]   why the result of this should be expected false , i dnt have any idea , brackets are opened and closed in correct order"
                    },
                    {
                        "username": "susan_m_2022",
                        "content": "Correct order would be ()[] or []() not ([)]"
                    },
                    {
                        "username": "RealUbaid",
                        "content": "No every bracket set should have either nothing in it, or a complete set of brackets in it. One single bracket is false."
                    },
                    {
                        "username": "Rohan1505",
                        "content": "The brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\\n\\nFrom this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid.\\nThen I think the problem description should be updated."
                    }
                ]
            },
            {
                "id": 1940922,
                "content": [
                    {
                        "username": "minhphamduy",
                        "content": "class Solution {\\n      private static boolean isMatchingPair(char c1, char c2) {\\n    return (c1 == \\'(\\' && c2 == \\')\\') || (c1 == \\'{\\' && c2 == \\'}\\') || (c1 == \\'[\\' && c2 == \\']\\');\\n  }\\n    public boolean isValid(String s) {\\n    Stack<Character> stack = new Stack<Character>();\\n    int n = s.length() - 1;\\n    for (int i = 0; i <= n; i++) {\\n      if (s.charAt(i) == \\'(\\' || s.charAt(i) == \\'{\\' || s.charAt(i) == \\'[\\') {\\n        stack.push(s.charAt((i)));\\n      } else if (s.charAt(i) == \\')\\' || s.charAt(i) == \\'}\\' || s.charAt(i) == \\']\\') {\\n        if (stack.isEmpty() || !isMatchingPair(stack.pop(), s.charAt(i))) {\\n          return false;\\n        }\\n      }\\n    }\\n    if(!stack.isEmpty()) {\\n        return false;\\n    }\\n    \\n    return true;\\n\\n  }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "azamuzapbar",
                        "content": "\"(){}}{\" why is it True?"
                    },
                    {
                        "username": "vikash_singh_vogel",
                        "content": "it can be achieved by simple if else "
                    },
                    {
                        "username": "klu_2000032013",
                        "content": "class Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        if(s[0]==\\']\\' || s[0]==\\'}\\' || s[0]==\\')\\'){\\n            return false;\\n        }\\n        for(int i=0;s[i]!=\\'\\\\0\\';i++){\\n            if(s[i]==\\'(\\' || s[i]==\\'{\\' || s[i]==\\'[\\'){\\n                      st.push(s[i]);\\n            }\\n            else if(st.empty()){\\n                return false;\\n            }\\n            else if(st.top()==\\'(\\' && s[i]==\\')\\' || st.top()==\\'{\\' && s[i]==\\'}\\' || st.top()==\\'[\\' && s[i]==\\']\\'){\\n                            st.pop();\\n            }\\n            else\\n               return false;\\n            \\n                \\n        }\\n              \\n        if(st.empty())\\n            return true;\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "anubhavsrivastava30",
                        "content": "My code in my local editor shows false as output for this input \"(]\" while the output is true in leetcode editor. \\nnot sure if its on purpose or some bug."
                    },
                    {
                        "username": "Goran5",
                        "content": "I haven\\'t looked at any solutions for this yet and I\\'m still trying to solve it. I was wondering, is there a O(n) time complexity solution for this?"
                    },
                    {
                        "username": "precelek211",
                        "content": "\"{ [ ] }\" this is true but this \"( [  ) ]\" false?\\nwhere is consistency? in this case every test can be independently threaded\\nalso map doesn\\'t contains \"contains\" feature in C++? \\n"
                    },
                    {
                        "username": "data-stack",
                        "content": "There is consistency in this: The brackets have to be in the correct order in a mathematical sense. You cannot close an outer bracket in a formula before you closed all inner brackets.  \"( [ ) ]\" dies exactly that - it closes the outer bracket before closing the inner \"[ ]\"."
                    },
                    {
                        "username": "kaxagvimraze",
                        "content": "why this is not valid? ([)] ?\\n"
                    },
                    {
                        "username": "susan_m_2022",
                        "content": "Brackets must be closed in the correct order. These are out of order."
                    },
                    {
                        "username": "user2809sJ",
                        "content": "([)]   why the result of this should be expected false , i dnt have any idea , brackets are opened and closed in correct order"
                    },
                    {
                        "username": "susan_m_2022",
                        "content": "Correct order would be ()[] or []() not ([)]"
                    },
                    {
                        "username": "RealUbaid",
                        "content": "No every bracket set should have either nothing in it, or a complete set of brackets in it. One single bracket is false."
                    },
                    {
                        "username": "Rohan1505",
                        "content": "The brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\\n\\nFrom this problem description I cannot guess if [()]{} is valid or not.\\nBut clearly from the answer it is valid.\\nThen I think the problem description should be updated."
                    }
                ]
            },
            {
                "id": 1940323,
                "content": [
                    {
                        "username": "TrippingLettuce",
                        "content": "You will need to add 1 or 2 custom run cases for this problem if solving with a stack."
                    },
                    {
                        "username": "TrippingLettuce",
                        "content": "For anyone overthinking it remember\\n[()]{} IS VALID and ([)] IS NOT VALID "
                    },
                    {
                        "username": "RealUbaid",
                        "content": "\"[({(())}[()])]\"\nYea not happening."
                    },
                    {
                        "username": "jhoonbey",
                        "content": "Test cases should be more complex: \\n[()]{} is valid. I should rethink about the solution for this cases ;("
                    },
                    {
                        "username": "hp210693",
                        "content": "Solution:\\n for(int i = 0; i < s.size(); i++)\\n        {\\n            string temp(s.begin() + i, s.begin() + i + 2);\\n            if(temp == \"()\" || temp == \"[]\" || temp == \"{}\")\\n            {\\n                s.erase(s.begin() + i, s.begin() + i + 2);\\n                if(i == 0)\\n                    i = 0 - 1;\\n                else\\n                    i = i - 2;\\n            }  \\n        }\\n        return s.empty() ? true : false;"
                    },
                    {
                        "username": "tarun_gurjar11",
                        "content": "Input\\ns =\"([)]\"\\n\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "nvictoreze",
                        "content": "No entiendo por que en produccion ( \"( ) { } } {\" ) me sale \"VERDADERO\"  si en visual studio code me sale \"FALSO\""
                    },
                    {
                        "username": "Ian-Hennessy",
                        "content": "I am experiencing an issue when I submit my solution. The testcase s = \"( [ ) ]\" is expected to return false. This seems like an error with the test itself, as this string contains valid parentheses, and my code is returning true."
                    },
                    {
                        "username": "Philosopher-G33k",
                        "content": "Output Limit Exceeded\\n91st test case is failing for the input:\\n\"[([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([()])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])]\"\\n\\n\\nAnyone else faced same problem, it is working for the same test case on Xcode, swift playground "
                    },
                    {
                        "username": "luibee1019",
                        "content": "I dont understand why my answer is failed with the first 2 test cases while it returned the correct answers on my computer. :(\nI am using only simple if else code, it covers 6 examples of\ns1 = \"()\"  - true\ns2 = \"()[]{}\" - true\ns3 = \"(]\" - false\ns4 = \"([{}])\" - true\ns5 = \"[()]{}\" - true\ns6 = \"[(][)]{}\" - false"
                    }
                ]
            },
            {
                "id": 1940321,
                "content": [
                    {
                        "username": "TrippingLettuce",
                        "content": "You will need to add 1 or 2 custom run cases for this problem if solving with a stack."
                    },
                    {
                        "username": "TrippingLettuce",
                        "content": "For anyone overthinking it remember\\n[()]{} IS VALID and ([)] IS NOT VALID "
                    },
                    {
                        "username": "RealUbaid",
                        "content": "\"[({(())}[()])]\"\nYea not happening."
                    },
                    {
                        "username": "jhoonbey",
                        "content": "Test cases should be more complex: \\n[()]{} is valid. I should rethink about the solution for this cases ;("
                    },
                    {
                        "username": "hp210693",
                        "content": "Solution:\\n for(int i = 0; i < s.size(); i++)\\n        {\\n            string temp(s.begin() + i, s.begin() + i + 2);\\n            if(temp == \"()\" || temp == \"[]\" || temp == \"{}\")\\n            {\\n                s.erase(s.begin() + i, s.begin() + i + 2);\\n                if(i == 0)\\n                    i = 0 - 1;\\n                else\\n                    i = i - 2;\\n            }  \\n        }\\n        return s.empty() ? true : false;"
                    },
                    {
                        "username": "tarun_gurjar11",
                        "content": "Input\\ns =\"([)]\"\\n\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "nvictoreze",
                        "content": "No entiendo por que en produccion ( \"( ) { } } {\" ) me sale \"VERDADERO\"  si en visual studio code me sale \"FALSO\""
                    },
                    {
                        "username": "Ian-Hennessy",
                        "content": "I am experiencing an issue when I submit my solution. The testcase s = \"( [ ) ]\" is expected to return false. This seems like an error with the test itself, as this string contains valid parentheses, and my code is returning true."
                    },
                    {
                        "username": "Philosopher-G33k",
                        "content": "Output Limit Exceeded\\n91st test case is failing for the input:\\n\"[([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([()])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])]\"\\n\\n\\nAnyone else faced same problem, it is working for the same test case on Xcode, swift playground "
                    },
                    {
                        "username": "luibee1019",
                        "content": "I dont understand why my answer is failed with the first 2 test cases while it returned the correct answers on my computer. :(\nI am using only simple if else code, it covers 6 examples of\ns1 = \"()\"  - true\ns2 = \"()[]{}\" - true\ns3 = \"(]\" - false\ns4 = \"([{}])\" - true\ns5 = \"[()]{}\" - true\ns6 = \"[(][)]{}\" - false"
                    }
                ]
            },
            {
                "id": 1939047,
                "content": [
                    {
                        "username": "TrippingLettuce",
                        "content": "You will need to add 1 or 2 custom run cases for this problem if solving with a stack."
                    },
                    {
                        "username": "TrippingLettuce",
                        "content": "For anyone overthinking it remember\\n[()]{} IS VALID and ([)] IS NOT VALID "
                    },
                    {
                        "username": "RealUbaid",
                        "content": "\"[({(())}[()])]\"\nYea not happening."
                    },
                    {
                        "username": "jhoonbey",
                        "content": "Test cases should be more complex: \\n[()]{} is valid. I should rethink about the solution for this cases ;("
                    },
                    {
                        "username": "hp210693",
                        "content": "Solution:\\n for(int i = 0; i < s.size(); i++)\\n        {\\n            string temp(s.begin() + i, s.begin() + i + 2);\\n            if(temp == \"()\" || temp == \"[]\" || temp == \"{}\")\\n            {\\n                s.erase(s.begin() + i, s.begin() + i + 2);\\n                if(i == 0)\\n                    i = 0 - 1;\\n                else\\n                    i = i - 2;\\n            }  \\n        }\\n        return s.empty() ? true : false;"
                    },
                    {
                        "username": "tarun_gurjar11",
                        "content": "Input\\ns =\"([)]\"\\n\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "nvictoreze",
                        "content": "No entiendo por que en produccion ( \"( ) { } } {\" ) me sale \"VERDADERO\"  si en visual studio code me sale \"FALSO\""
                    },
                    {
                        "username": "Ian-Hennessy",
                        "content": "I am experiencing an issue when I submit my solution. The testcase s = \"( [ ) ]\" is expected to return false. This seems like an error with the test itself, as this string contains valid parentheses, and my code is returning true."
                    },
                    {
                        "username": "Philosopher-G33k",
                        "content": "Output Limit Exceeded\\n91st test case is failing for the input:\\n\"[([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([()])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])]\"\\n\\n\\nAnyone else faced same problem, it is working for the same test case on Xcode, swift playground "
                    },
                    {
                        "username": "luibee1019",
                        "content": "I dont understand why my answer is failed with the first 2 test cases while it returned the correct answers on my computer. :(\nI am using only simple if else code, it covers 6 examples of\ns1 = \"()\"  - true\ns2 = \"()[]{}\" - true\ns3 = \"(]\" - false\ns4 = \"([{}])\" - true\ns5 = \"[()]{}\" - true\ns6 = \"[(][)]{}\" - false"
                    }
                ]
            },
            {
                "id": 1938358,
                "content": [
                    {
                        "username": "TrippingLettuce",
                        "content": "You will need to add 1 or 2 custom run cases for this problem if solving with a stack."
                    },
                    {
                        "username": "TrippingLettuce",
                        "content": "For anyone overthinking it remember\\n[()]{} IS VALID and ([)] IS NOT VALID "
                    },
                    {
                        "username": "RealUbaid",
                        "content": "\"[({(())}[()])]\"\nYea not happening."
                    },
                    {
                        "username": "jhoonbey",
                        "content": "Test cases should be more complex: \\n[()]{} is valid. I should rethink about the solution for this cases ;("
                    },
                    {
                        "username": "hp210693",
                        "content": "Solution:\\n for(int i = 0; i < s.size(); i++)\\n        {\\n            string temp(s.begin() + i, s.begin() + i + 2);\\n            if(temp == \"()\" || temp == \"[]\" || temp == \"{}\")\\n            {\\n                s.erase(s.begin() + i, s.begin() + i + 2);\\n                if(i == 0)\\n                    i = 0 - 1;\\n                else\\n                    i = i - 2;\\n            }  \\n        }\\n        return s.empty() ? true : false;"
                    },
                    {
                        "username": "tarun_gurjar11",
                        "content": "Input\\ns =\"([)]\"\\n\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "nvictoreze",
                        "content": "No entiendo por que en produccion ( \"( ) { } } {\" ) me sale \"VERDADERO\"  si en visual studio code me sale \"FALSO\""
                    },
                    {
                        "username": "Ian-Hennessy",
                        "content": "I am experiencing an issue when I submit my solution. The testcase s = \"( [ ) ]\" is expected to return false. This seems like an error with the test itself, as this string contains valid parentheses, and my code is returning true."
                    },
                    {
                        "username": "Philosopher-G33k",
                        "content": "Output Limit Exceeded\\n91st test case is failing for the input:\\n\"[([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([()])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])]\"\\n\\n\\nAnyone else faced same problem, it is working for the same test case on Xcode, swift playground "
                    },
                    {
                        "username": "luibee1019",
                        "content": "I dont understand why my answer is failed with the first 2 test cases while it returned the correct answers on my computer. :(\nI am using only simple if else code, it covers 6 examples of\ns1 = \"()\"  - true\ns2 = \"()[]{}\" - true\ns3 = \"(]\" - false\ns4 = \"([{}])\" - true\ns5 = \"[()]{}\" - true\ns6 = \"[(][)]{}\" - false"
                    }
                ]
            },
            {
                "id": 1938326,
                "content": [
                    {
                        "username": "TrippingLettuce",
                        "content": "You will need to add 1 or 2 custom run cases for this problem if solving with a stack."
                    },
                    {
                        "username": "TrippingLettuce",
                        "content": "For anyone overthinking it remember\\n[()]{} IS VALID and ([)] IS NOT VALID "
                    },
                    {
                        "username": "RealUbaid",
                        "content": "\"[({(())}[()])]\"\nYea not happening."
                    },
                    {
                        "username": "jhoonbey",
                        "content": "Test cases should be more complex: \\n[()]{} is valid. I should rethink about the solution for this cases ;("
                    },
                    {
                        "username": "hp210693",
                        "content": "Solution:\\n for(int i = 0; i < s.size(); i++)\\n        {\\n            string temp(s.begin() + i, s.begin() + i + 2);\\n            if(temp == \"()\" || temp == \"[]\" || temp == \"{}\")\\n            {\\n                s.erase(s.begin() + i, s.begin() + i + 2);\\n                if(i == 0)\\n                    i = 0 - 1;\\n                else\\n                    i = i - 2;\\n            }  \\n        }\\n        return s.empty() ? true : false;"
                    },
                    {
                        "username": "tarun_gurjar11",
                        "content": "Input\\ns =\"([)]\"\\n\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "nvictoreze",
                        "content": "No entiendo por que en produccion ( \"( ) { } } {\" ) me sale \"VERDADERO\"  si en visual studio code me sale \"FALSO\""
                    },
                    {
                        "username": "Ian-Hennessy",
                        "content": "I am experiencing an issue when I submit my solution. The testcase s = \"( [ ) ]\" is expected to return false. This seems like an error with the test itself, as this string contains valid parentheses, and my code is returning true."
                    },
                    {
                        "username": "Philosopher-G33k",
                        "content": "Output Limit Exceeded\\n91st test case is failing for the input:\\n\"[([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([()])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])]\"\\n\\n\\nAnyone else faced same problem, it is working for the same test case on Xcode, swift playground "
                    },
                    {
                        "username": "luibee1019",
                        "content": "I dont understand why my answer is failed with the first 2 test cases while it returned the correct answers on my computer. :(\nI am using only simple if else code, it covers 6 examples of\ns1 = \"()\"  - true\ns2 = \"()[]{}\" - true\ns3 = \"(]\" - false\ns4 = \"([{}])\" - true\ns5 = \"[()]{}\" - true\ns6 = \"[(][)]{}\" - false"
                    }
                ]
            },
            {
                "id": 1933167,
                "content": [
                    {
                        "username": "TrippingLettuce",
                        "content": "You will need to add 1 or 2 custom run cases for this problem if solving with a stack."
                    },
                    {
                        "username": "TrippingLettuce",
                        "content": "For anyone overthinking it remember\\n[()]{} IS VALID and ([)] IS NOT VALID "
                    },
                    {
                        "username": "RealUbaid",
                        "content": "\"[({(())}[()])]\"\nYea not happening."
                    },
                    {
                        "username": "jhoonbey",
                        "content": "Test cases should be more complex: \\n[()]{} is valid. I should rethink about the solution for this cases ;("
                    },
                    {
                        "username": "hp210693",
                        "content": "Solution:\\n for(int i = 0; i < s.size(); i++)\\n        {\\n            string temp(s.begin() + i, s.begin() + i + 2);\\n            if(temp == \"()\" || temp == \"[]\" || temp == \"{}\")\\n            {\\n                s.erase(s.begin() + i, s.begin() + i + 2);\\n                if(i == 0)\\n                    i = 0 - 1;\\n                else\\n                    i = i - 2;\\n            }  \\n        }\\n        return s.empty() ? true : false;"
                    },
                    {
                        "username": "tarun_gurjar11",
                        "content": "Input\\ns =\"([)]\"\\n\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "nvictoreze",
                        "content": "No entiendo por que en produccion ( \"( ) { } } {\" ) me sale \"VERDADERO\"  si en visual studio code me sale \"FALSO\""
                    },
                    {
                        "username": "Ian-Hennessy",
                        "content": "I am experiencing an issue when I submit my solution. The testcase s = \"( [ ) ]\" is expected to return false. This seems like an error with the test itself, as this string contains valid parentheses, and my code is returning true."
                    },
                    {
                        "username": "Philosopher-G33k",
                        "content": "Output Limit Exceeded\\n91st test case is failing for the input:\\n\"[([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([()])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])]\"\\n\\n\\nAnyone else faced same problem, it is working for the same test case on Xcode, swift playground "
                    },
                    {
                        "username": "luibee1019",
                        "content": "I dont understand why my answer is failed with the first 2 test cases while it returned the correct answers on my computer. :(\nI am using only simple if else code, it covers 6 examples of\ns1 = \"()\"  - true\ns2 = \"()[]{}\" - true\ns3 = \"(]\" - false\ns4 = \"([{}])\" - true\ns5 = \"[()]{}\" - true\ns6 = \"[(][)]{}\" - false"
                    }
                ]
            },
            {
                "id": 1932554,
                "content": [
                    {
                        "username": "TrippingLettuce",
                        "content": "You will need to add 1 or 2 custom run cases for this problem if solving with a stack."
                    },
                    {
                        "username": "TrippingLettuce",
                        "content": "For anyone overthinking it remember\\n[()]{} IS VALID and ([)] IS NOT VALID "
                    },
                    {
                        "username": "RealUbaid",
                        "content": "\"[({(())}[()])]\"\nYea not happening."
                    },
                    {
                        "username": "jhoonbey",
                        "content": "Test cases should be more complex: \\n[()]{} is valid. I should rethink about the solution for this cases ;("
                    },
                    {
                        "username": "hp210693",
                        "content": "Solution:\\n for(int i = 0; i < s.size(); i++)\\n        {\\n            string temp(s.begin() + i, s.begin() + i + 2);\\n            if(temp == \"()\" || temp == \"[]\" || temp == \"{}\")\\n            {\\n                s.erase(s.begin() + i, s.begin() + i + 2);\\n                if(i == 0)\\n                    i = 0 - 1;\\n                else\\n                    i = i - 2;\\n            }  \\n        }\\n        return s.empty() ? true : false;"
                    },
                    {
                        "username": "tarun_gurjar11",
                        "content": "Input\\ns =\"([)]\"\\n\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "nvictoreze",
                        "content": "No entiendo por que en produccion ( \"( ) { } } {\" ) me sale \"VERDADERO\"  si en visual studio code me sale \"FALSO\""
                    },
                    {
                        "username": "Ian-Hennessy",
                        "content": "I am experiencing an issue when I submit my solution. The testcase s = \"( [ ) ]\" is expected to return false. This seems like an error with the test itself, as this string contains valid parentheses, and my code is returning true."
                    },
                    {
                        "username": "Philosopher-G33k",
                        "content": "Output Limit Exceeded\\n91st test case is failing for the input:\\n\"[([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([()])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])]\"\\n\\n\\nAnyone else faced same problem, it is working for the same test case on Xcode, swift playground "
                    },
                    {
                        "username": "luibee1019",
                        "content": "I dont understand why my answer is failed with the first 2 test cases while it returned the correct answers on my computer. :(\nI am using only simple if else code, it covers 6 examples of\ns1 = \"()\"  - true\ns2 = \"()[]{}\" - true\ns3 = \"(]\" - false\ns4 = \"([{}])\" - true\ns5 = \"[()]{}\" - true\ns6 = \"[(][)]{}\" - false"
                    }
                ]
            },
            {
                "id": 1931953,
                "content": [
                    {
                        "username": "TrippingLettuce",
                        "content": "You will need to add 1 or 2 custom run cases for this problem if solving with a stack."
                    },
                    {
                        "username": "TrippingLettuce",
                        "content": "For anyone overthinking it remember\\n[()]{} IS VALID and ([)] IS NOT VALID "
                    },
                    {
                        "username": "RealUbaid",
                        "content": "\"[({(())}[()])]\"\nYea not happening."
                    },
                    {
                        "username": "jhoonbey",
                        "content": "Test cases should be more complex: \\n[()]{} is valid. I should rethink about the solution for this cases ;("
                    },
                    {
                        "username": "hp210693",
                        "content": "Solution:\\n for(int i = 0; i < s.size(); i++)\\n        {\\n            string temp(s.begin() + i, s.begin() + i + 2);\\n            if(temp == \"()\" || temp == \"[]\" || temp == \"{}\")\\n            {\\n                s.erase(s.begin() + i, s.begin() + i + 2);\\n                if(i == 0)\\n                    i = 0 - 1;\\n                else\\n                    i = i - 2;\\n            }  \\n        }\\n        return s.empty() ? true : false;"
                    },
                    {
                        "username": "tarun_gurjar11",
                        "content": "Input\\ns =\"([)]\"\\n\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "nvictoreze",
                        "content": "No entiendo por que en produccion ( \"( ) { } } {\" ) me sale \"VERDADERO\"  si en visual studio code me sale \"FALSO\""
                    },
                    {
                        "username": "Ian-Hennessy",
                        "content": "I am experiencing an issue when I submit my solution. The testcase s = \"( [ ) ]\" is expected to return false. This seems like an error with the test itself, as this string contains valid parentheses, and my code is returning true."
                    },
                    {
                        "username": "Philosopher-G33k",
                        "content": "Output Limit Exceeded\\n91st test case is failing for the input:\\n\"[([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([()])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])]\"\\n\\n\\nAnyone else faced same problem, it is working for the same test case on Xcode, swift playground "
                    },
                    {
                        "username": "luibee1019",
                        "content": "I dont understand why my answer is failed with the first 2 test cases while it returned the correct answers on my computer. :(\nI am using only simple if else code, it covers 6 examples of\ns1 = \"()\"  - true\ns2 = \"()[]{}\" - true\ns3 = \"(]\" - false\ns4 = \"([{}])\" - true\ns5 = \"[()]{}\" - true\ns6 = \"[(][)]{}\" - false"
                    }
                ]
            },
            {
                "id": 1929082,
                "content": [
                    {
                        "username": "TrippingLettuce",
                        "content": "You will need to add 1 or 2 custom run cases for this problem if solving with a stack."
                    },
                    {
                        "username": "TrippingLettuce",
                        "content": "For anyone overthinking it remember\\n[()]{} IS VALID and ([)] IS NOT VALID "
                    },
                    {
                        "username": "RealUbaid",
                        "content": "\"[({(())}[()])]\"\nYea not happening."
                    },
                    {
                        "username": "jhoonbey",
                        "content": "Test cases should be more complex: \\n[()]{} is valid. I should rethink about the solution for this cases ;("
                    },
                    {
                        "username": "hp210693",
                        "content": "Solution:\\n for(int i = 0; i < s.size(); i++)\\n        {\\n            string temp(s.begin() + i, s.begin() + i + 2);\\n            if(temp == \"()\" || temp == \"[]\" || temp == \"{}\")\\n            {\\n                s.erase(s.begin() + i, s.begin() + i + 2);\\n                if(i == 0)\\n                    i = 0 - 1;\\n                else\\n                    i = i - 2;\\n            }  \\n        }\\n        return s.empty() ? true : false;"
                    },
                    {
                        "username": "tarun_gurjar11",
                        "content": "Input\\ns =\"([)]\"\\n\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "nvictoreze",
                        "content": "No entiendo por que en produccion ( \"( ) { } } {\" ) me sale \"VERDADERO\"  si en visual studio code me sale \"FALSO\""
                    },
                    {
                        "username": "Ian-Hennessy",
                        "content": "I am experiencing an issue when I submit my solution. The testcase s = \"( [ ) ]\" is expected to return false. This seems like an error with the test itself, as this string contains valid parentheses, and my code is returning true."
                    },
                    {
                        "username": "Philosopher-G33k",
                        "content": "Output Limit Exceeded\\n91st test case is failing for the input:\\n\"[([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([()])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])]\"\\n\\n\\nAnyone else faced same problem, it is working for the same test case on Xcode, swift playground "
                    },
                    {
                        "username": "luibee1019",
                        "content": "I dont understand why my answer is failed with the first 2 test cases while it returned the correct answers on my computer. :(\nI am using only simple if else code, it covers 6 examples of\ns1 = \"()\"  - true\ns2 = \"()[]{}\" - true\ns3 = \"(]\" - false\ns4 = \"([{}])\" - true\ns5 = \"[()]{}\" - true\ns6 = \"[(][)]{}\" - false"
                    }
                ]
            },
            {
                "id": 1927603,
                "content": [
                    {
                        "username": "TrippingLettuce",
                        "content": "You will need to add 1 or 2 custom run cases for this problem if solving with a stack."
                    },
                    {
                        "username": "TrippingLettuce",
                        "content": "For anyone overthinking it remember\\n[()]{} IS VALID and ([)] IS NOT VALID "
                    },
                    {
                        "username": "RealUbaid",
                        "content": "\"[({(())}[()])]\"\nYea not happening."
                    },
                    {
                        "username": "jhoonbey",
                        "content": "Test cases should be more complex: \\n[()]{} is valid. I should rethink about the solution for this cases ;("
                    },
                    {
                        "username": "hp210693",
                        "content": "Solution:\\n for(int i = 0; i < s.size(); i++)\\n        {\\n            string temp(s.begin() + i, s.begin() + i + 2);\\n            if(temp == \"()\" || temp == \"[]\" || temp == \"{}\")\\n            {\\n                s.erase(s.begin() + i, s.begin() + i + 2);\\n                if(i == 0)\\n                    i = 0 - 1;\\n                else\\n                    i = i - 2;\\n            }  \\n        }\\n        return s.empty() ? true : false;"
                    },
                    {
                        "username": "tarun_gurjar11",
                        "content": "Input\\ns =\"([)]\"\\n\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "nvictoreze",
                        "content": "No entiendo por que en produccion ( \"( ) { } } {\" ) me sale \"VERDADERO\"  si en visual studio code me sale \"FALSO\""
                    },
                    {
                        "username": "Ian-Hennessy",
                        "content": "I am experiencing an issue when I submit my solution. The testcase s = \"( [ ) ]\" is expected to return false. This seems like an error with the test itself, as this string contains valid parentheses, and my code is returning true."
                    },
                    {
                        "username": "Philosopher-G33k",
                        "content": "Output Limit Exceeded\\n91st test case is failing for the input:\\n\"[([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([([()])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])]\"\\n\\n\\nAnyone else faced same problem, it is working for the same test case on Xcode, swift playground "
                    },
                    {
                        "username": "luibee1019",
                        "content": "I dont understand why my answer is failed with the first 2 test cases while it returned the correct answers on my computer. :(\nI am using only simple if else code, it covers 6 examples of\ns1 = \"()\"  - true\ns2 = \"()[]{}\" - true\ns3 = \"(]\" - false\ns4 = \"([{}])\" - true\ns5 = \"[()]{}\" - true\ns6 = \"[(][)]{}\" - false"
                    }
                ]
            },
            {
                "id": 1927456,
                "content": [
                    {
                        "username": "indraw705",
                        "content": "good question though but This problem should be in medium level not in easy."
                    },
                    {
                        "username": "Nags_06",
                        "content": "I wan to know is this valid as per the given description ?\\n\" ( { } [ ( ) ] ) \""
                    },
                    {
                        "username": "knazdawid",
                        "content": "I checked it and it is valid. Remember that you can add test case and run code before submitting answer."
                    },
                    {
                        "username": "knazdawid",
                        "content": "Anyone else noticed that submited answers performance differs each time you submit an answer (even if the same one)? I posted my solution and it beat 80% other answers. Then I submitted the same answer but with little tweak to improve it. The performance beat only 40% so I changed it back but the answer that previously beat 80% beat only 50% of other answers. WTF?! I thought this site really cares about correctly measuring code performance... :( "
                    },
                    {
                        "username": "ronokghosal",
                        "content": "This  is an easy problem if you implement it using stack."
                    },
                    {
                        "username": "Sujal04",
                        "content": "The question was quite difficult than other easy questions. Spent a lot of time un understanding the actual meaning of correct order."
                    },
                    {
                        "username": "ronokghosal",
                        "content": "the output is correct. should be true but its marked as wriong answer\\ns =\\n\"([)]\"\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "dactung93",
                        "content": "I am sure it is False.\\n([ must have ]) rather than (]\\nWrong order"
                    },
                    {
                        "username": "dactung93",
                        "content": "I used to want to skip this one. Luckily, I found the algorithm behind it."
                    },
                    {
                        "username": "zhurin",
                        "content": "At first I wanted to skip the task, but after reading the comments, I was able to solve the problem! Thank you."
                    },
                    {
                        "username": "shahmaitri3299",
                        "content": "Can brackets be nested inside brackets?\n({[()]}), () {[]}, etc  are valid or invalid?\nWhat should the code return if the string is empty?\nProblem description should be updated."
                    },
                    {
                        "username": "yukimora",
                        "content": "What\\'s wrong with the string \"([)]\"?  \" ( [ ) ] \" Each bracket opens and closes. Or if something is opened in a bracket, it should be closed in the same place?"
                    }
                ]
            },
            {
                "id": 1917647,
                "content": [
                    {
                        "username": "indraw705",
                        "content": "good question though but This problem should be in medium level not in easy."
                    },
                    {
                        "username": "Nags_06",
                        "content": "I wan to know is this valid as per the given description ?\\n\" ( { } [ ( ) ] ) \""
                    },
                    {
                        "username": "knazdawid",
                        "content": "I checked it and it is valid. Remember that you can add test case and run code before submitting answer."
                    },
                    {
                        "username": "knazdawid",
                        "content": "Anyone else noticed that submited answers performance differs each time you submit an answer (even if the same one)? I posted my solution and it beat 80% other answers. Then I submitted the same answer but with little tweak to improve it. The performance beat only 40% so I changed it back but the answer that previously beat 80% beat only 50% of other answers. WTF?! I thought this site really cares about correctly measuring code performance... :( "
                    },
                    {
                        "username": "ronokghosal",
                        "content": "This  is an easy problem if you implement it using stack."
                    },
                    {
                        "username": "Sujal04",
                        "content": "The question was quite difficult than other easy questions. Spent a lot of time un understanding the actual meaning of correct order."
                    },
                    {
                        "username": "ronokghosal",
                        "content": "the output is correct. should be true but its marked as wriong answer\\ns =\\n\"([)]\"\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "dactung93",
                        "content": "I am sure it is False.\\n([ must have ]) rather than (]\\nWrong order"
                    },
                    {
                        "username": "dactung93",
                        "content": "I used to want to skip this one. Luckily, I found the algorithm behind it."
                    },
                    {
                        "username": "zhurin",
                        "content": "At first I wanted to skip the task, but after reading the comments, I was able to solve the problem! Thank you."
                    },
                    {
                        "username": "shahmaitri3299",
                        "content": "Can brackets be nested inside brackets?\n({[()]}), () {[]}, etc  are valid or invalid?\nWhat should the code return if the string is empty?\nProblem description should be updated."
                    },
                    {
                        "username": "yukimora",
                        "content": "What\\'s wrong with the string \"([)]\"?  \" ( [ ) ] \" Each bracket opens and closes. Or if something is opened in a bracket, it should be closed in the same place?"
                    }
                ]
            },
            {
                "id": 1916924,
                "content": [
                    {
                        "username": "indraw705",
                        "content": "good question though but This problem should be in medium level not in easy."
                    },
                    {
                        "username": "Nags_06",
                        "content": "I wan to know is this valid as per the given description ?\\n\" ( { } [ ( ) ] ) \""
                    },
                    {
                        "username": "knazdawid",
                        "content": "I checked it and it is valid. Remember that you can add test case and run code before submitting answer."
                    },
                    {
                        "username": "knazdawid",
                        "content": "Anyone else noticed that submited answers performance differs each time you submit an answer (even if the same one)? I posted my solution and it beat 80% other answers. Then I submitted the same answer but with little tweak to improve it. The performance beat only 40% so I changed it back but the answer that previously beat 80% beat only 50% of other answers. WTF?! I thought this site really cares about correctly measuring code performance... :( "
                    },
                    {
                        "username": "ronokghosal",
                        "content": "This  is an easy problem if you implement it using stack."
                    },
                    {
                        "username": "Sujal04",
                        "content": "The question was quite difficult than other easy questions. Spent a lot of time un understanding the actual meaning of correct order."
                    },
                    {
                        "username": "ronokghosal",
                        "content": "the output is correct. should be true but its marked as wriong answer\\ns =\\n\"([)]\"\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "dactung93",
                        "content": "I am sure it is False.\\n([ must have ]) rather than (]\\nWrong order"
                    },
                    {
                        "username": "dactung93",
                        "content": "I used to want to skip this one. Luckily, I found the algorithm behind it."
                    },
                    {
                        "username": "zhurin",
                        "content": "At first I wanted to skip the task, but after reading the comments, I was able to solve the problem! Thank you."
                    },
                    {
                        "username": "shahmaitri3299",
                        "content": "Can brackets be nested inside brackets?\n({[()]}), () {[]}, etc  are valid or invalid?\nWhat should the code return if the string is empty?\nProblem description should be updated."
                    },
                    {
                        "username": "yukimora",
                        "content": "What\\'s wrong with the string \"([)]\"?  \" ( [ ) ] \" Each bracket opens and closes. Or if something is opened in a bracket, it should be closed in the same place?"
                    }
                ]
            },
            {
                "id": 1914625,
                "content": [
                    {
                        "username": "indraw705",
                        "content": "good question though but This problem should be in medium level not in easy."
                    },
                    {
                        "username": "Nags_06",
                        "content": "I wan to know is this valid as per the given description ?\\n\" ( { } [ ( ) ] ) \""
                    },
                    {
                        "username": "knazdawid",
                        "content": "I checked it and it is valid. Remember that you can add test case and run code before submitting answer."
                    },
                    {
                        "username": "knazdawid",
                        "content": "Anyone else noticed that submited answers performance differs each time you submit an answer (even if the same one)? I posted my solution and it beat 80% other answers. Then I submitted the same answer but with little tweak to improve it. The performance beat only 40% so I changed it back but the answer that previously beat 80% beat only 50% of other answers. WTF?! I thought this site really cares about correctly measuring code performance... :( "
                    },
                    {
                        "username": "ronokghosal",
                        "content": "This  is an easy problem if you implement it using stack."
                    },
                    {
                        "username": "Sujal04",
                        "content": "The question was quite difficult than other easy questions. Spent a lot of time un understanding the actual meaning of correct order."
                    },
                    {
                        "username": "ronokghosal",
                        "content": "the output is correct. should be true but its marked as wriong answer\\ns =\\n\"([)]\"\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "dactung93",
                        "content": "I am sure it is False.\\n([ must have ]) rather than (]\\nWrong order"
                    },
                    {
                        "username": "dactung93",
                        "content": "I used to want to skip this one. Luckily, I found the algorithm behind it."
                    },
                    {
                        "username": "zhurin",
                        "content": "At first I wanted to skip the task, but after reading the comments, I was able to solve the problem! Thank you."
                    },
                    {
                        "username": "shahmaitri3299",
                        "content": "Can brackets be nested inside brackets?\n({[()]}), () {[]}, etc  are valid or invalid?\nWhat should the code return if the string is empty?\nProblem description should be updated."
                    },
                    {
                        "username": "yukimora",
                        "content": "What\\'s wrong with the string \"([)]\"?  \" ( [ ) ] \" Each bracket opens and closes. Or if something is opened in a bracket, it should be closed in the same place?"
                    }
                ]
            },
            {
                "id": 1913919,
                "content": [
                    {
                        "username": "indraw705",
                        "content": "good question though but This problem should be in medium level not in easy."
                    },
                    {
                        "username": "Nags_06",
                        "content": "I wan to know is this valid as per the given description ?\\n\" ( { } [ ( ) ] ) \""
                    },
                    {
                        "username": "knazdawid",
                        "content": "I checked it and it is valid. Remember that you can add test case and run code before submitting answer."
                    },
                    {
                        "username": "knazdawid",
                        "content": "Anyone else noticed that submited answers performance differs each time you submit an answer (even if the same one)? I posted my solution and it beat 80% other answers. Then I submitted the same answer but with little tweak to improve it. The performance beat only 40% so I changed it back but the answer that previously beat 80% beat only 50% of other answers. WTF?! I thought this site really cares about correctly measuring code performance... :( "
                    },
                    {
                        "username": "ronokghosal",
                        "content": "This  is an easy problem if you implement it using stack."
                    },
                    {
                        "username": "Sujal04",
                        "content": "The question was quite difficult than other easy questions. Spent a lot of time un understanding the actual meaning of correct order."
                    },
                    {
                        "username": "ronokghosal",
                        "content": "the output is correct. should be true but its marked as wriong answer\\ns =\\n\"([)]\"\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "dactung93",
                        "content": "I am sure it is False.\\n([ must have ]) rather than (]\\nWrong order"
                    },
                    {
                        "username": "dactung93",
                        "content": "I used to want to skip this one. Luckily, I found the algorithm behind it."
                    },
                    {
                        "username": "zhurin",
                        "content": "At first I wanted to skip the task, but after reading the comments, I was able to solve the problem! Thank you."
                    },
                    {
                        "username": "shahmaitri3299",
                        "content": "Can brackets be nested inside brackets?\n({[()]}), () {[]}, etc  are valid or invalid?\nWhat should the code return if the string is empty?\nProblem description should be updated."
                    },
                    {
                        "username": "yukimora",
                        "content": "What\\'s wrong with the string \"([)]\"?  \" ( [ ) ] \" Each bracket opens and closes. Or if something is opened in a bracket, it should be closed in the same place?"
                    }
                ]
            },
            {
                "id": 1913881,
                "content": [
                    {
                        "username": "indraw705",
                        "content": "good question though but This problem should be in medium level not in easy."
                    },
                    {
                        "username": "Nags_06",
                        "content": "I wan to know is this valid as per the given description ?\\n\" ( { } [ ( ) ] ) \""
                    },
                    {
                        "username": "knazdawid",
                        "content": "I checked it and it is valid. Remember that you can add test case and run code before submitting answer."
                    },
                    {
                        "username": "knazdawid",
                        "content": "Anyone else noticed that submited answers performance differs each time you submit an answer (even if the same one)? I posted my solution and it beat 80% other answers. Then I submitted the same answer but with little tweak to improve it. The performance beat only 40% so I changed it back but the answer that previously beat 80% beat only 50% of other answers. WTF?! I thought this site really cares about correctly measuring code performance... :( "
                    },
                    {
                        "username": "ronokghosal",
                        "content": "This  is an easy problem if you implement it using stack."
                    },
                    {
                        "username": "Sujal04",
                        "content": "The question was quite difficult than other easy questions. Spent a lot of time un understanding the actual meaning of correct order."
                    },
                    {
                        "username": "ronokghosal",
                        "content": "the output is correct. should be true but its marked as wriong answer\\ns =\\n\"([)]\"\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "dactung93",
                        "content": "I am sure it is False.\\n([ must have ]) rather than (]\\nWrong order"
                    },
                    {
                        "username": "dactung93",
                        "content": "I used to want to skip this one. Luckily, I found the algorithm behind it."
                    },
                    {
                        "username": "zhurin",
                        "content": "At first I wanted to skip the task, but after reading the comments, I was able to solve the problem! Thank you."
                    },
                    {
                        "username": "shahmaitri3299",
                        "content": "Can brackets be nested inside brackets?\n({[()]}), () {[]}, etc  are valid or invalid?\nWhat should the code return if the string is empty?\nProblem description should be updated."
                    },
                    {
                        "username": "yukimora",
                        "content": "What\\'s wrong with the string \"([)]\"?  \" ( [ ) ] \" Each bracket opens and closes. Or if something is opened in a bracket, it should be closed in the same place?"
                    }
                ]
            },
            {
                "id": 1911845,
                "content": [
                    {
                        "username": "indraw705",
                        "content": "good question though but This problem should be in medium level not in easy."
                    },
                    {
                        "username": "Nags_06",
                        "content": "I wan to know is this valid as per the given description ?\\n\" ( { } [ ( ) ] ) \""
                    },
                    {
                        "username": "knazdawid",
                        "content": "I checked it and it is valid. Remember that you can add test case and run code before submitting answer."
                    },
                    {
                        "username": "knazdawid",
                        "content": "Anyone else noticed that submited answers performance differs each time you submit an answer (even if the same one)? I posted my solution and it beat 80% other answers. Then I submitted the same answer but with little tweak to improve it. The performance beat only 40% so I changed it back but the answer that previously beat 80% beat only 50% of other answers. WTF?! I thought this site really cares about correctly measuring code performance... :( "
                    },
                    {
                        "username": "ronokghosal",
                        "content": "This  is an easy problem if you implement it using stack."
                    },
                    {
                        "username": "Sujal04",
                        "content": "The question was quite difficult than other easy questions. Spent a lot of time un understanding the actual meaning of correct order."
                    },
                    {
                        "username": "ronokghosal",
                        "content": "the output is correct. should be true but its marked as wriong answer\\ns =\\n\"([)]\"\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "dactung93",
                        "content": "I am sure it is False.\\n([ must have ]) rather than (]\\nWrong order"
                    },
                    {
                        "username": "dactung93",
                        "content": "I used to want to skip this one. Luckily, I found the algorithm behind it."
                    },
                    {
                        "username": "zhurin",
                        "content": "At first I wanted to skip the task, but after reading the comments, I was able to solve the problem! Thank you."
                    },
                    {
                        "username": "shahmaitri3299",
                        "content": "Can brackets be nested inside brackets?\n({[()]}), () {[]}, etc  are valid or invalid?\nWhat should the code return if the string is empty?\nProblem description should be updated."
                    },
                    {
                        "username": "yukimora",
                        "content": "What\\'s wrong with the string \"([)]\"?  \" ( [ ) ] \" Each bracket opens and closes. Or if something is opened in a bracket, it should be closed in the same place?"
                    }
                ]
            },
            {
                "id": 1909027,
                "content": [
                    {
                        "username": "indraw705",
                        "content": "good question though but This problem should be in medium level not in easy."
                    },
                    {
                        "username": "Nags_06",
                        "content": "I wan to know is this valid as per the given description ?\\n\" ( { } [ ( ) ] ) \""
                    },
                    {
                        "username": "knazdawid",
                        "content": "I checked it and it is valid. Remember that you can add test case and run code before submitting answer."
                    },
                    {
                        "username": "knazdawid",
                        "content": "Anyone else noticed that submited answers performance differs each time you submit an answer (even if the same one)? I posted my solution and it beat 80% other answers. Then I submitted the same answer but with little tweak to improve it. The performance beat only 40% so I changed it back but the answer that previously beat 80% beat only 50% of other answers. WTF?! I thought this site really cares about correctly measuring code performance... :( "
                    },
                    {
                        "username": "ronokghosal",
                        "content": "This  is an easy problem if you implement it using stack."
                    },
                    {
                        "username": "Sujal04",
                        "content": "The question was quite difficult than other easy questions. Spent a lot of time un understanding the actual meaning of correct order."
                    },
                    {
                        "username": "ronokghosal",
                        "content": "the output is correct. should be true but its marked as wriong answer\\ns =\\n\"([)]\"\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "dactung93",
                        "content": "I am sure it is False.\\n([ must have ]) rather than (]\\nWrong order"
                    },
                    {
                        "username": "dactung93",
                        "content": "I used to want to skip this one. Luckily, I found the algorithm behind it."
                    },
                    {
                        "username": "zhurin",
                        "content": "At first I wanted to skip the task, but after reading the comments, I was able to solve the problem! Thank you."
                    },
                    {
                        "username": "shahmaitri3299",
                        "content": "Can brackets be nested inside brackets?\n({[()]}), () {[]}, etc  are valid or invalid?\nWhat should the code return if the string is empty?\nProblem description should be updated."
                    },
                    {
                        "username": "yukimora",
                        "content": "What\\'s wrong with the string \"([)]\"?  \" ( [ ) ] \" Each bracket opens and closes. Or if something is opened in a bracket, it should be closed in the same place?"
                    }
                ]
            },
            {
                "id": 1907292,
                "content": [
                    {
                        "username": "indraw705",
                        "content": "good question though but This problem should be in medium level not in easy."
                    },
                    {
                        "username": "Nags_06",
                        "content": "I wan to know is this valid as per the given description ?\\n\" ( { } [ ( ) ] ) \""
                    },
                    {
                        "username": "knazdawid",
                        "content": "I checked it and it is valid. Remember that you can add test case and run code before submitting answer."
                    },
                    {
                        "username": "knazdawid",
                        "content": "Anyone else noticed that submited answers performance differs each time you submit an answer (even if the same one)? I posted my solution and it beat 80% other answers. Then I submitted the same answer but with little tweak to improve it. The performance beat only 40% so I changed it back but the answer that previously beat 80% beat only 50% of other answers. WTF?! I thought this site really cares about correctly measuring code performance... :( "
                    },
                    {
                        "username": "ronokghosal",
                        "content": "This  is an easy problem if you implement it using stack."
                    },
                    {
                        "username": "Sujal04",
                        "content": "The question was quite difficult than other easy questions. Spent a lot of time un understanding the actual meaning of correct order."
                    },
                    {
                        "username": "ronokghosal",
                        "content": "the output is correct. should be true but its marked as wriong answer\\ns =\\n\"([)]\"\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "dactung93",
                        "content": "I am sure it is False.\\n([ must have ]) rather than (]\\nWrong order"
                    },
                    {
                        "username": "dactung93",
                        "content": "I used to want to skip this one. Luckily, I found the algorithm behind it."
                    },
                    {
                        "username": "zhurin",
                        "content": "At first I wanted to skip the task, but after reading the comments, I was able to solve the problem! Thank you."
                    },
                    {
                        "username": "shahmaitri3299",
                        "content": "Can brackets be nested inside brackets?\n({[()]}), () {[]}, etc  are valid or invalid?\nWhat should the code return if the string is empty?\nProblem description should be updated."
                    },
                    {
                        "username": "yukimora",
                        "content": "What\\'s wrong with the string \"([)]\"?  \" ( [ ) ] \" Each bracket opens and closes. Or if something is opened in a bracket, it should be closed in the same place?"
                    }
                ]
            },
            {
                "id": 1905230,
                "content": [
                    {
                        "username": "indraw705",
                        "content": "good question though but This problem should be in medium level not in easy."
                    },
                    {
                        "username": "Nags_06",
                        "content": "I wan to know is this valid as per the given description ?\\n\" ( { } [ ( ) ] ) \""
                    },
                    {
                        "username": "knazdawid",
                        "content": "I checked it and it is valid. Remember that you can add test case and run code before submitting answer."
                    },
                    {
                        "username": "knazdawid",
                        "content": "Anyone else noticed that submited answers performance differs each time you submit an answer (even if the same one)? I posted my solution and it beat 80% other answers. Then I submitted the same answer but with little tweak to improve it. The performance beat only 40% so I changed it back but the answer that previously beat 80% beat only 50% of other answers. WTF?! I thought this site really cares about correctly measuring code performance... :( "
                    },
                    {
                        "username": "ronokghosal",
                        "content": "This  is an easy problem if you implement it using stack."
                    },
                    {
                        "username": "Sujal04",
                        "content": "The question was quite difficult than other easy questions. Spent a lot of time un understanding the actual meaning of correct order."
                    },
                    {
                        "username": "ronokghosal",
                        "content": "the output is correct. should be true but its marked as wriong answer\\ns =\\n\"([)]\"\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "dactung93",
                        "content": "I am sure it is False.\\n([ must have ]) rather than (]\\nWrong order"
                    },
                    {
                        "username": "dactung93",
                        "content": "I used to want to skip this one. Luckily, I found the algorithm behind it."
                    },
                    {
                        "username": "zhurin",
                        "content": "At first I wanted to skip the task, but after reading the comments, I was able to solve the problem! Thank you."
                    },
                    {
                        "username": "shahmaitri3299",
                        "content": "Can brackets be nested inside brackets?\n({[()]}), () {[]}, etc  are valid or invalid?\nWhat should the code return if the string is empty?\nProblem description should be updated."
                    },
                    {
                        "username": "yukimora",
                        "content": "What\\'s wrong with the string \"([)]\"?  \" ( [ ) ] \" Each bracket opens and closes. Or if something is opened in a bracket, it should be closed in the same place?"
                    }
                ]
            },
            {
                "id": 1903904,
                "content": [
                    {
                        "username": "atdgp97",
                        "content": " `your inline code...your inline code...`\\'unicode\\' object has no attribute \\'insert\\'\\ngetting this error again and again when using list"
                    },
                    {
                        "username": "Ambadas_Sangoli",
                        "content": "3rd testcase - \"(]\" i am getting error whereas I am getting correct answer on pythontutor and IDE. Dont know whats wrong in my code."
                    },
                    {
                        "username": "Geronimo12",
                        "content": "Why is \"[()]{}\" considered valid, but \"([)]\" considered wrong? I don\\'t understand..."
                    },
                    {
                        "username": "dactung93",
                        "content": "Because [()] is vaid and {} is valid"
                    },
                    {
                        "username": "kevinjolly222",
                        "content": "Can some one help me i tried to submit but its showing error\\nhere is the code:\\n\\nclass Solution \\n{\\n    public boolean isValid(String s) \\n    {\\n        int q=0;\\n        int n=0;\\n        int j=0;\\n        Stack<Character> stk= new Stack<>();  \\n        Stack<Character> st= new Stack<>();  \\n        Stack<Character> suk= new Stack<>();  \\n        char ch[]=s.toCharArray();\\n        for(int i=0;i<ch.length;i++)\\n        {\\n            if(ch[i]==\\'(\\')\\n            {\\n                stk.push(ch[i]);  \\n            }\\n             if(ch[i]==\\'{\\')\\n            {\\n               st.push(ch[i]);  \\n            }\\n             if(ch[i]==\\'[\\')\\n            {\\n               suk.push(ch[i]);  \\n            }\\n            if(ch[i]==\\')\\')\\n            {\\n               stk.pop();  \\n            }\\n              if(ch[i]==\\'}\\')\\n            {\\n               st.pop();  \\n            }\\n            if(ch[i]==\\']\\')\\n            {\\n               suk.pop();  \\n            }\\n            \\n        }\\n    //  for(int i=0;i<ch.length;i++)\\n    //      {\\n           \\n    //     }\\n        if(stk.empty() && st.empty()) && suk.empty())\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }     \\n    }\\n}"
                    },
                    {
                        "username": "Axolet",
                        "content": "Poorly worded Leetcode. \\nMuch time wasted developing algorithms that works perfectly on the example inputs - but doesn\\'t work in actual test cases.\\nWould have saved me time giving us 1-2 more examples. "
                    },
                    {
                        "username": "saro_2003",
                        "content": "```\\nchar stack[2000];\\nint top=-1;\\nvoid push(char a){\\n    stack[++top]=a;\\n}\\nint isempty(){\\n    if(top==-1){\\n        return 1;\\n    }\\n    return 0;\\n}\\nvoid pop(){\\n    --top;\\n}\\nbool isValid(char * s){\\n    \\n    for(int i=0;i<strlen(s);i++){\\n        if(s[i]==\\'(\\' || s[i]==\\'{\\' || s[i]==\\'[\\'){\\n            push(s[i]);\\n        }\\n        else{\\n            if(isempty()==1){\\n                return 0;\\n            }\\n            if(s[i]==\\']\\'){\\n                if(stack[top]==\\'[\\'){\\n                    pop();\\n                    continue;\\n                }\\n                else{\\n                    // return 0;\\n                    break;\\n                }\\n            }\\n            if(s[i]==\\'}\\'){\\n                if(stack[top]==\\'{\\'){\\n                    pop();\\n                    continue;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            if(s[i]==\\')\\'){\\n                if(stack[top]==\\'(\\'){\\n                    pop();\\n                    continue;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    if(isempty()==1){\\n        return 1;\\n    }\\n    return 0;\\n}\\n```\\nfind the mistake in this code . \\n`{[]}` not runs properly"
                    },
                    {
                        "username": "nalinnishant",
                        "content": "can anyone help me to optimize my code?? it is working on O(n) but it only beat the 13% of the leetcoders on submission. \\n\\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> st = new Stack<>();\\n\\n        for(int i = 0; i < s.length(); i++){\\n            if(st.empty()){\\n                st.push(s.charAt(i));\\n            }else if((st.peek()==\\'(\\' && s.charAt(i)==\\')\\') || (st.peek()==\\'{\\' && s.charAt(i)==\\'}\\') || (st.peek()==\\'[\\' && s.charAt(i)==\\']\\') ){\\n                st.pop();\\n            }else{\\n                st.push(s.charAt(i));\\n            }\\n        }\\n\\n        return st.empty();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "alphazwest",
                        "content": "This is a great problem for helping hammer in the importance of defining conditional cases."
                    },
                    {
                        "username": "500lambdaxl9",
                        "content": "My Dumb Ways: use if-else to solve all of it"
                    },
                    {
                        "username": "Alireza_Nikpay",
                        "content": "\"ERROR: AddressSanitizer: heap-buffer-overflow on address\", what does this means? can\\'t really understand. (using std::vector, std::vector::pop_back, std::vector::back, std::push_back)"
                    }
                ]
            },
            {
                "id": 1890126,
                "content": [
                    {
                        "username": "atdgp97",
                        "content": " `your inline code...your inline code...`\\'unicode\\' object has no attribute \\'insert\\'\\ngetting this error again and again when using list"
                    },
                    {
                        "username": "Ambadas_Sangoli",
                        "content": "3rd testcase - \"(]\" i am getting error whereas I am getting correct answer on pythontutor and IDE. Dont know whats wrong in my code."
                    },
                    {
                        "username": "Geronimo12",
                        "content": "Why is \"[()]{}\" considered valid, but \"([)]\" considered wrong? I don\\'t understand..."
                    },
                    {
                        "username": "dactung93",
                        "content": "Because [()] is vaid and {} is valid"
                    },
                    {
                        "username": "kevinjolly222",
                        "content": "Can some one help me i tried to submit but its showing error\\nhere is the code:\\n\\nclass Solution \\n{\\n    public boolean isValid(String s) \\n    {\\n        int q=0;\\n        int n=0;\\n        int j=0;\\n        Stack<Character> stk= new Stack<>();  \\n        Stack<Character> st= new Stack<>();  \\n        Stack<Character> suk= new Stack<>();  \\n        char ch[]=s.toCharArray();\\n        for(int i=0;i<ch.length;i++)\\n        {\\n            if(ch[i]==\\'(\\')\\n            {\\n                stk.push(ch[i]);  \\n            }\\n             if(ch[i]==\\'{\\')\\n            {\\n               st.push(ch[i]);  \\n            }\\n             if(ch[i]==\\'[\\')\\n            {\\n               suk.push(ch[i]);  \\n            }\\n            if(ch[i]==\\')\\')\\n            {\\n               stk.pop();  \\n            }\\n              if(ch[i]==\\'}\\')\\n            {\\n               st.pop();  \\n            }\\n            if(ch[i]==\\']\\')\\n            {\\n               suk.pop();  \\n            }\\n            \\n        }\\n    //  for(int i=0;i<ch.length;i++)\\n    //      {\\n           \\n    //     }\\n        if(stk.empty() && st.empty()) && suk.empty())\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }     \\n    }\\n}"
                    },
                    {
                        "username": "Axolet",
                        "content": "Poorly worded Leetcode. \\nMuch time wasted developing algorithms that works perfectly on the example inputs - but doesn\\'t work in actual test cases.\\nWould have saved me time giving us 1-2 more examples. "
                    },
                    {
                        "username": "saro_2003",
                        "content": "```\\nchar stack[2000];\\nint top=-1;\\nvoid push(char a){\\n    stack[++top]=a;\\n}\\nint isempty(){\\n    if(top==-1){\\n        return 1;\\n    }\\n    return 0;\\n}\\nvoid pop(){\\n    --top;\\n}\\nbool isValid(char * s){\\n    \\n    for(int i=0;i<strlen(s);i++){\\n        if(s[i]==\\'(\\' || s[i]==\\'{\\' || s[i]==\\'[\\'){\\n            push(s[i]);\\n        }\\n        else{\\n            if(isempty()==1){\\n                return 0;\\n            }\\n            if(s[i]==\\']\\'){\\n                if(stack[top]==\\'[\\'){\\n                    pop();\\n                    continue;\\n                }\\n                else{\\n                    // return 0;\\n                    break;\\n                }\\n            }\\n            if(s[i]==\\'}\\'){\\n                if(stack[top]==\\'{\\'){\\n                    pop();\\n                    continue;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            if(s[i]==\\')\\'){\\n                if(stack[top]==\\'(\\'){\\n                    pop();\\n                    continue;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    if(isempty()==1){\\n        return 1;\\n    }\\n    return 0;\\n}\\n```\\nfind the mistake in this code . \\n`{[]}` not runs properly"
                    },
                    {
                        "username": "nalinnishant",
                        "content": "can anyone help me to optimize my code?? it is working on O(n) but it only beat the 13% of the leetcoders on submission. \\n\\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> st = new Stack<>();\\n\\n        for(int i = 0; i < s.length(); i++){\\n            if(st.empty()){\\n                st.push(s.charAt(i));\\n            }else if((st.peek()==\\'(\\' && s.charAt(i)==\\')\\') || (st.peek()==\\'{\\' && s.charAt(i)==\\'}\\') || (st.peek()==\\'[\\' && s.charAt(i)==\\']\\') ){\\n                st.pop();\\n            }else{\\n                st.push(s.charAt(i));\\n            }\\n        }\\n\\n        return st.empty();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "alphazwest",
                        "content": "This is a great problem for helping hammer in the importance of defining conditional cases."
                    },
                    {
                        "username": "500lambdaxl9",
                        "content": "My Dumb Ways: use if-else to solve all of it"
                    },
                    {
                        "username": "Alireza_Nikpay",
                        "content": "\"ERROR: AddressSanitizer: heap-buffer-overflow on address\", what does this means? can\\'t really understand. (using std::vector, std::vector::pop_back, std::vector::back, std::push_back)"
                    }
                ]
            },
            {
                "id": 1879518,
                "content": [
                    {
                        "username": "atdgp97",
                        "content": " `your inline code...your inline code...`\\'unicode\\' object has no attribute \\'insert\\'\\ngetting this error again and again when using list"
                    },
                    {
                        "username": "Ambadas_Sangoli",
                        "content": "3rd testcase - \"(]\" i am getting error whereas I am getting correct answer on pythontutor and IDE. Dont know whats wrong in my code."
                    },
                    {
                        "username": "Geronimo12",
                        "content": "Why is \"[()]{}\" considered valid, but \"([)]\" considered wrong? I don\\'t understand..."
                    },
                    {
                        "username": "dactung93",
                        "content": "Because [()] is vaid and {} is valid"
                    },
                    {
                        "username": "kevinjolly222",
                        "content": "Can some one help me i tried to submit but its showing error\\nhere is the code:\\n\\nclass Solution \\n{\\n    public boolean isValid(String s) \\n    {\\n        int q=0;\\n        int n=0;\\n        int j=0;\\n        Stack<Character> stk= new Stack<>();  \\n        Stack<Character> st= new Stack<>();  \\n        Stack<Character> suk= new Stack<>();  \\n        char ch[]=s.toCharArray();\\n        for(int i=0;i<ch.length;i++)\\n        {\\n            if(ch[i]==\\'(\\')\\n            {\\n                stk.push(ch[i]);  \\n            }\\n             if(ch[i]==\\'{\\')\\n            {\\n               st.push(ch[i]);  \\n            }\\n             if(ch[i]==\\'[\\')\\n            {\\n               suk.push(ch[i]);  \\n            }\\n            if(ch[i]==\\')\\')\\n            {\\n               stk.pop();  \\n            }\\n              if(ch[i]==\\'}\\')\\n            {\\n               st.pop();  \\n            }\\n            if(ch[i]==\\']\\')\\n            {\\n               suk.pop();  \\n            }\\n            \\n        }\\n    //  for(int i=0;i<ch.length;i++)\\n    //      {\\n           \\n    //     }\\n        if(stk.empty() && st.empty()) && suk.empty())\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }     \\n    }\\n}"
                    },
                    {
                        "username": "Axolet",
                        "content": "Poorly worded Leetcode. \\nMuch time wasted developing algorithms that works perfectly on the example inputs - but doesn\\'t work in actual test cases.\\nWould have saved me time giving us 1-2 more examples. "
                    },
                    {
                        "username": "saro_2003",
                        "content": "```\\nchar stack[2000];\\nint top=-1;\\nvoid push(char a){\\n    stack[++top]=a;\\n}\\nint isempty(){\\n    if(top==-1){\\n        return 1;\\n    }\\n    return 0;\\n}\\nvoid pop(){\\n    --top;\\n}\\nbool isValid(char * s){\\n    \\n    for(int i=0;i<strlen(s);i++){\\n        if(s[i]==\\'(\\' || s[i]==\\'{\\' || s[i]==\\'[\\'){\\n            push(s[i]);\\n        }\\n        else{\\n            if(isempty()==1){\\n                return 0;\\n            }\\n            if(s[i]==\\']\\'){\\n                if(stack[top]==\\'[\\'){\\n                    pop();\\n                    continue;\\n                }\\n                else{\\n                    // return 0;\\n                    break;\\n                }\\n            }\\n            if(s[i]==\\'}\\'){\\n                if(stack[top]==\\'{\\'){\\n                    pop();\\n                    continue;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            if(s[i]==\\')\\'){\\n                if(stack[top]==\\'(\\'){\\n                    pop();\\n                    continue;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    if(isempty()==1){\\n        return 1;\\n    }\\n    return 0;\\n}\\n```\\nfind the mistake in this code . \\n`{[]}` not runs properly"
                    },
                    {
                        "username": "nalinnishant",
                        "content": "can anyone help me to optimize my code?? it is working on O(n) but it only beat the 13% of the leetcoders on submission. \\n\\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> st = new Stack<>();\\n\\n        for(int i = 0; i < s.length(); i++){\\n            if(st.empty()){\\n                st.push(s.charAt(i));\\n            }else if((st.peek()==\\'(\\' && s.charAt(i)==\\')\\') || (st.peek()==\\'{\\' && s.charAt(i)==\\'}\\') || (st.peek()==\\'[\\' && s.charAt(i)==\\']\\') ){\\n                st.pop();\\n            }else{\\n                st.push(s.charAt(i));\\n            }\\n        }\\n\\n        return st.empty();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "alphazwest",
                        "content": "This is a great problem for helping hammer in the importance of defining conditional cases."
                    },
                    {
                        "username": "500lambdaxl9",
                        "content": "My Dumb Ways: use if-else to solve all of it"
                    },
                    {
                        "username": "Alireza_Nikpay",
                        "content": "\"ERROR: AddressSanitizer: heap-buffer-overflow on address\", what does this means? can\\'t really understand. (using std::vector, std::vector::pop_back, std::vector::back, std::push_back)"
                    }
                ]
            },
            {
                "id": 1878447,
                "content": [
                    {
                        "username": "atdgp97",
                        "content": " `your inline code...your inline code...`\\'unicode\\' object has no attribute \\'insert\\'\\ngetting this error again and again when using list"
                    },
                    {
                        "username": "Ambadas_Sangoli",
                        "content": "3rd testcase - \"(]\" i am getting error whereas I am getting correct answer on pythontutor and IDE. Dont know whats wrong in my code."
                    },
                    {
                        "username": "Geronimo12",
                        "content": "Why is \"[()]{}\" considered valid, but \"([)]\" considered wrong? I don\\'t understand..."
                    },
                    {
                        "username": "dactung93",
                        "content": "Because [()] is vaid and {} is valid"
                    },
                    {
                        "username": "kevinjolly222",
                        "content": "Can some one help me i tried to submit but its showing error\\nhere is the code:\\n\\nclass Solution \\n{\\n    public boolean isValid(String s) \\n    {\\n        int q=0;\\n        int n=0;\\n        int j=0;\\n        Stack<Character> stk= new Stack<>();  \\n        Stack<Character> st= new Stack<>();  \\n        Stack<Character> suk= new Stack<>();  \\n        char ch[]=s.toCharArray();\\n        for(int i=0;i<ch.length;i++)\\n        {\\n            if(ch[i]==\\'(\\')\\n            {\\n                stk.push(ch[i]);  \\n            }\\n             if(ch[i]==\\'{\\')\\n            {\\n               st.push(ch[i]);  \\n            }\\n             if(ch[i]==\\'[\\')\\n            {\\n               suk.push(ch[i]);  \\n            }\\n            if(ch[i]==\\')\\')\\n            {\\n               stk.pop();  \\n            }\\n              if(ch[i]==\\'}\\')\\n            {\\n               st.pop();  \\n            }\\n            if(ch[i]==\\']\\')\\n            {\\n               suk.pop();  \\n            }\\n            \\n        }\\n    //  for(int i=0;i<ch.length;i++)\\n    //      {\\n           \\n    //     }\\n        if(stk.empty() && st.empty()) && suk.empty())\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }     \\n    }\\n}"
                    },
                    {
                        "username": "Axolet",
                        "content": "Poorly worded Leetcode. \\nMuch time wasted developing algorithms that works perfectly on the example inputs - but doesn\\'t work in actual test cases.\\nWould have saved me time giving us 1-2 more examples. "
                    },
                    {
                        "username": "saro_2003",
                        "content": "```\\nchar stack[2000];\\nint top=-1;\\nvoid push(char a){\\n    stack[++top]=a;\\n}\\nint isempty(){\\n    if(top==-1){\\n        return 1;\\n    }\\n    return 0;\\n}\\nvoid pop(){\\n    --top;\\n}\\nbool isValid(char * s){\\n    \\n    for(int i=0;i<strlen(s);i++){\\n        if(s[i]==\\'(\\' || s[i]==\\'{\\' || s[i]==\\'[\\'){\\n            push(s[i]);\\n        }\\n        else{\\n            if(isempty()==1){\\n                return 0;\\n            }\\n            if(s[i]==\\']\\'){\\n                if(stack[top]==\\'[\\'){\\n                    pop();\\n                    continue;\\n                }\\n                else{\\n                    // return 0;\\n                    break;\\n                }\\n            }\\n            if(s[i]==\\'}\\'){\\n                if(stack[top]==\\'{\\'){\\n                    pop();\\n                    continue;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            if(s[i]==\\')\\'){\\n                if(stack[top]==\\'(\\'){\\n                    pop();\\n                    continue;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    if(isempty()==1){\\n        return 1;\\n    }\\n    return 0;\\n}\\n```\\nfind the mistake in this code . \\n`{[]}` not runs properly"
                    },
                    {
                        "username": "nalinnishant",
                        "content": "can anyone help me to optimize my code?? it is working on O(n) but it only beat the 13% of the leetcoders on submission. \\n\\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> st = new Stack<>();\\n\\n        for(int i = 0; i < s.length(); i++){\\n            if(st.empty()){\\n                st.push(s.charAt(i));\\n            }else if((st.peek()==\\'(\\' && s.charAt(i)==\\')\\') || (st.peek()==\\'{\\' && s.charAt(i)==\\'}\\') || (st.peek()==\\'[\\' && s.charAt(i)==\\']\\') ){\\n                st.pop();\\n            }else{\\n                st.push(s.charAt(i));\\n            }\\n        }\\n\\n        return st.empty();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "alphazwest",
                        "content": "This is a great problem for helping hammer in the importance of defining conditional cases."
                    },
                    {
                        "username": "500lambdaxl9",
                        "content": "My Dumb Ways: use if-else to solve all of it"
                    },
                    {
                        "username": "Alireza_Nikpay",
                        "content": "\"ERROR: AddressSanitizer: heap-buffer-overflow on address\", what does this means? can\\'t really understand. (using std::vector, std::vector::pop_back, std::vector::back, std::push_back)"
                    }
                ]
            },
            {
                "id": 1876321,
                "content": [
                    {
                        "username": "atdgp97",
                        "content": " `your inline code...your inline code...`\\'unicode\\' object has no attribute \\'insert\\'\\ngetting this error again and again when using list"
                    },
                    {
                        "username": "Ambadas_Sangoli",
                        "content": "3rd testcase - \"(]\" i am getting error whereas I am getting correct answer on pythontutor and IDE. Dont know whats wrong in my code."
                    },
                    {
                        "username": "Geronimo12",
                        "content": "Why is \"[()]{}\" considered valid, but \"([)]\" considered wrong? I don\\'t understand..."
                    },
                    {
                        "username": "dactung93",
                        "content": "Because [()] is vaid and {} is valid"
                    },
                    {
                        "username": "kevinjolly222",
                        "content": "Can some one help me i tried to submit but its showing error\\nhere is the code:\\n\\nclass Solution \\n{\\n    public boolean isValid(String s) \\n    {\\n        int q=0;\\n        int n=0;\\n        int j=0;\\n        Stack<Character> stk= new Stack<>();  \\n        Stack<Character> st= new Stack<>();  \\n        Stack<Character> suk= new Stack<>();  \\n        char ch[]=s.toCharArray();\\n        for(int i=0;i<ch.length;i++)\\n        {\\n            if(ch[i]==\\'(\\')\\n            {\\n                stk.push(ch[i]);  \\n            }\\n             if(ch[i]==\\'{\\')\\n            {\\n               st.push(ch[i]);  \\n            }\\n             if(ch[i]==\\'[\\')\\n            {\\n               suk.push(ch[i]);  \\n            }\\n            if(ch[i]==\\')\\')\\n            {\\n               stk.pop();  \\n            }\\n              if(ch[i]==\\'}\\')\\n            {\\n               st.pop();  \\n            }\\n            if(ch[i]==\\']\\')\\n            {\\n               suk.pop();  \\n            }\\n            \\n        }\\n    //  for(int i=0;i<ch.length;i++)\\n    //      {\\n           \\n    //     }\\n        if(stk.empty() && st.empty()) && suk.empty())\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }     \\n    }\\n}"
                    },
                    {
                        "username": "Axolet",
                        "content": "Poorly worded Leetcode. \\nMuch time wasted developing algorithms that works perfectly on the example inputs - but doesn\\'t work in actual test cases.\\nWould have saved me time giving us 1-2 more examples. "
                    },
                    {
                        "username": "saro_2003",
                        "content": "```\\nchar stack[2000];\\nint top=-1;\\nvoid push(char a){\\n    stack[++top]=a;\\n}\\nint isempty(){\\n    if(top==-1){\\n        return 1;\\n    }\\n    return 0;\\n}\\nvoid pop(){\\n    --top;\\n}\\nbool isValid(char * s){\\n    \\n    for(int i=0;i<strlen(s);i++){\\n        if(s[i]==\\'(\\' || s[i]==\\'{\\' || s[i]==\\'[\\'){\\n            push(s[i]);\\n        }\\n        else{\\n            if(isempty()==1){\\n                return 0;\\n            }\\n            if(s[i]==\\']\\'){\\n                if(stack[top]==\\'[\\'){\\n                    pop();\\n                    continue;\\n                }\\n                else{\\n                    // return 0;\\n                    break;\\n                }\\n            }\\n            if(s[i]==\\'}\\'){\\n                if(stack[top]==\\'{\\'){\\n                    pop();\\n                    continue;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            if(s[i]==\\')\\'){\\n                if(stack[top]==\\'(\\'){\\n                    pop();\\n                    continue;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    if(isempty()==1){\\n        return 1;\\n    }\\n    return 0;\\n}\\n```\\nfind the mistake in this code . \\n`{[]}` not runs properly"
                    },
                    {
                        "username": "nalinnishant",
                        "content": "can anyone help me to optimize my code?? it is working on O(n) but it only beat the 13% of the leetcoders on submission. \\n\\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> st = new Stack<>();\\n\\n        for(int i = 0; i < s.length(); i++){\\n            if(st.empty()){\\n                st.push(s.charAt(i));\\n            }else if((st.peek()==\\'(\\' && s.charAt(i)==\\')\\') || (st.peek()==\\'{\\' && s.charAt(i)==\\'}\\') || (st.peek()==\\'[\\' && s.charAt(i)==\\']\\') ){\\n                st.pop();\\n            }else{\\n                st.push(s.charAt(i));\\n            }\\n        }\\n\\n        return st.empty();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "alphazwest",
                        "content": "This is a great problem for helping hammer in the importance of defining conditional cases."
                    },
                    {
                        "username": "500lambdaxl9",
                        "content": "My Dumb Ways: use if-else to solve all of it"
                    },
                    {
                        "username": "Alireza_Nikpay",
                        "content": "\"ERROR: AddressSanitizer: heap-buffer-overflow on address\", what does this means? can\\'t really understand. (using std::vector, std::vector::pop_back, std::vector::back, std::push_back)"
                    }
                ]
            },
            {
                "id": 1875961,
                "content": [
                    {
                        "username": "atdgp97",
                        "content": " `your inline code...your inline code...`\\'unicode\\' object has no attribute \\'insert\\'\\ngetting this error again and again when using list"
                    },
                    {
                        "username": "Ambadas_Sangoli",
                        "content": "3rd testcase - \"(]\" i am getting error whereas I am getting correct answer on pythontutor and IDE. Dont know whats wrong in my code."
                    },
                    {
                        "username": "Geronimo12",
                        "content": "Why is \"[()]{}\" considered valid, but \"([)]\" considered wrong? I don\\'t understand..."
                    },
                    {
                        "username": "dactung93",
                        "content": "Because [()] is vaid and {} is valid"
                    },
                    {
                        "username": "kevinjolly222",
                        "content": "Can some one help me i tried to submit but its showing error\\nhere is the code:\\n\\nclass Solution \\n{\\n    public boolean isValid(String s) \\n    {\\n        int q=0;\\n        int n=0;\\n        int j=0;\\n        Stack<Character> stk= new Stack<>();  \\n        Stack<Character> st= new Stack<>();  \\n        Stack<Character> suk= new Stack<>();  \\n        char ch[]=s.toCharArray();\\n        for(int i=0;i<ch.length;i++)\\n        {\\n            if(ch[i]==\\'(\\')\\n            {\\n                stk.push(ch[i]);  \\n            }\\n             if(ch[i]==\\'{\\')\\n            {\\n               st.push(ch[i]);  \\n            }\\n             if(ch[i]==\\'[\\')\\n            {\\n               suk.push(ch[i]);  \\n            }\\n            if(ch[i]==\\')\\')\\n            {\\n               stk.pop();  \\n            }\\n              if(ch[i]==\\'}\\')\\n            {\\n               st.pop();  \\n            }\\n            if(ch[i]==\\']\\')\\n            {\\n               suk.pop();  \\n            }\\n            \\n        }\\n    //  for(int i=0;i<ch.length;i++)\\n    //      {\\n           \\n    //     }\\n        if(stk.empty() && st.empty()) && suk.empty())\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }     \\n    }\\n}"
                    },
                    {
                        "username": "Axolet",
                        "content": "Poorly worded Leetcode. \\nMuch time wasted developing algorithms that works perfectly on the example inputs - but doesn\\'t work in actual test cases.\\nWould have saved me time giving us 1-2 more examples. "
                    },
                    {
                        "username": "saro_2003",
                        "content": "```\\nchar stack[2000];\\nint top=-1;\\nvoid push(char a){\\n    stack[++top]=a;\\n}\\nint isempty(){\\n    if(top==-1){\\n        return 1;\\n    }\\n    return 0;\\n}\\nvoid pop(){\\n    --top;\\n}\\nbool isValid(char * s){\\n    \\n    for(int i=0;i<strlen(s);i++){\\n        if(s[i]==\\'(\\' || s[i]==\\'{\\' || s[i]==\\'[\\'){\\n            push(s[i]);\\n        }\\n        else{\\n            if(isempty()==1){\\n                return 0;\\n            }\\n            if(s[i]==\\']\\'){\\n                if(stack[top]==\\'[\\'){\\n                    pop();\\n                    continue;\\n                }\\n                else{\\n                    // return 0;\\n                    break;\\n                }\\n            }\\n            if(s[i]==\\'}\\'){\\n                if(stack[top]==\\'{\\'){\\n                    pop();\\n                    continue;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            if(s[i]==\\')\\'){\\n                if(stack[top]==\\'(\\'){\\n                    pop();\\n                    continue;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    if(isempty()==1){\\n        return 1;\\n    }\\n    return 0;\\n}\\n```\\nfind the mistake in this code . \\n`{[]}` not runs properly"
                    },
                    {
                        "username": "nalinnishant",
                        "content": "can anyone help me to optimize my code?? it is working on O(n) but it only beat the 13% of the leetcoders on submission. \\n\\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> st = new Stack<>();\\n\\n        for(int i = 0; i < s.length(); i++){\\n            if(st.empty()){\\n                st.push(s.charAt(i));\\n            }else if((st.peek()==\\'(\\' && s.charAt(i)==\\')\\') || (st.peek()==\\'{\\' && s.charAt(i)==\\'}\\') || (st.peek()==\\'[\\' && s.charAt(i)==\\']\\') ){\\n                st.pop();\\n            }else{\\n                st.push(s.charAt(i));\\n            }\\n        }\\n\\n        return st.empty();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "alphazwest",
                        "content": "This is a great problem for helping hammer in the importance of defining conditional cases."
                    },
                    {
                        "username": "500lambdaxl9",
                        "content": "My Dumb Ways: use if-else to solve all of it"
                    },
                    {
                        "username": "Alireza_Nikpay",
                        "content": "\"ERROR: AddressSanitizer: heap-buffer-overflow on address\", what does this means? can\\'t really understand. (using std::vector, std::vector::pop_back, std::vector::back, std::push_back)"
                    }
                ]
            },
            {
                "id": 1868242,
                "content": [
                    {
                        "username": "atdgp97",
                        "content": " `your inline code...your inline code...`\\'unicode\\' object has no attribute \\'insert\\'\\ngetting this error again and again when using list"
                    },
                    {
                        "username": "Ambadas_Sangoli",
                        "content": "3rd testcase - \"(]\" i am getting error whereas I am getting correct answer on pythontutor and IDE. Dont know whats wrong in my code."
                    },
                    {
                        "username": "Geronimo12",
                        "content": "Why is \"[()]{}\" considered valid, but \"([)]\" considered wrong? I don\\'t understand..."
                    },
                    {
                        "username": "dactung93",
                        "content": "Because [()] is vaid and {} is valid"
                    },
                    {
                        "username": "kevinjolly222",
                        "content": "Can some one help me i tried to submit but its showing error\\nhere is the code:\\n\\nclass Solution \\n{\\n    public boolean isValid(String s) \\n    {\\n        int q=0;\\n        int n=0;\\n        int j=0;\\n        Stack<Character> stk= new Stack<>();  \\n        Stack<Character> st= new Stack<>();  \\n        Stack<Character> suk= new Stack<>();  \\n        char ch[]=s.toCharArray();\\n        for(int i=0;i<ch.length;i++)\\n        {\\n            if(ch[i]==\\'(\\')\\n            {\\n                stk.push(ch[i]);  \\n            }\\n             if(ch[i]==\\'{\\')\\n            {\\n               st.push(ch[i]);  \\n            }\\n             if(ch[i]==\\'[\\')\\n            {\\n               suk.push(ch[i]);  \\n            }\\n            if(ch[i]==\\')\\')\\n            {\\n               stk.pop();  \\n            }\\n              if(ch[i]==\\'}\\')\\n            {\\n               st.pop();  \\n            }\\n            if(ch[i]==\\']\\')\\n            {\\n               suk.pop();  \\n            }\\n            \\n        }\\n    //  for(int i=0;i<ch.length;i++)\\n    //      {\\n           \\n    //     }\\n        if(stk.empty() && st.empty()) && suk.empty())\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }     \\n    }\\n}"
                    },
                    {
                        "username": "Axolet",
                        "content": "Poorly worded Leetcode. \\nMuch time wasted developing algorithms that works perfectly on the example inputs - but doesn\\'t work in actual test cases.\\nWould have saved me time giving us 1-2 more examples. "
                    },
                    {
                        "username": "saro_2003",
                        "content": "```\\nchar stack[2000];\\nint top=-1;\\nvoid push(char a){\\n    stack[++top]=a;\\n}\\nint isempty(){\\n    if(top==-1){\\n        return 1;\\n    }\\n    return 0;\\n}\\nvoid pop(){\\n    --top;\\n}\\nbool isValid(char * s){\\n    \\n    for(int i=0;i<strlen(s);i++){\\n        if(s[i]==\\'(\\' || s[i]==\\'{\\' || s[i]==\\'[\\'){\\n            push(s[i]);\\n        }\\n        else{\\n            if(isempty()==1){\\n                return 0;\\n            }\\n            if(s[i]==\\']\\'){\\n                if(stack[top]==\\'[\\'){\\n                    pop();\\n                    continue;\\n                }\\n                else{\\n                    // return 0;\\n                    break;\\n                }\\n            }\\n            if(s[i]==\\'}\\'){\\n                if(stack[top]==\\'{\\'){\\n                    pop();\\n                    continue;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            if(s[i]==\\')\\'){\\n                if(stack[top]==\\'(\\'){\\n                    pop();\\n                    continue;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    if(isempty()==1){\\n        return 1;\\n    }\\n    return 0;\\n}\\n```\\nfind the mistake in this code . \\n`{[]}` not runs properly"
                    },
                    {
                        "username": "nalinnishant",
                        "content": "can anyone help me to optimize my code?? it is working on O(n) but it only beat the 13% of the leetcoders on submission. \\n\\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> st = new Stack<>();\\n\\n        for(int i = 0; i < s.length(); i++){\\n            if(st.empty()){\\n                st.push(s.charAt(i));\\n            }else if((st.peek()==\\'(\\' && s.charAt(i)==\\')\\') || (st.peek()==\\'{\\' && s.charAt(i)==\\'}\\') || (st.peek()==\\'[\\' && s.charAt(i)==\\']\\') ){\\n                st.pop();\\n            }else{\\n                st.push(s.charAt(i));\\n            }\\n        }\\n\\n        return st.empty();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "alphazwest",
                        "content": "This is a great problem for helping hammer in the importance of defining conditional cases."
                    },
                    {
                        "username": "500lambdaxl9",
                        "content": "My Dumb Ways: use if-else to solve all of it"
                    },
                    {
                        "username": "Alireza_Nikpay",
                        "content": "\"ERROR: AddressSanitizer: heap-buffer-overflow on address\", what does this means? can\\'t really understand. (using std::vector, std::vector::pop_back, std::vector::back, std::push_back)"
                    }
                ]
            },
            {
                "id": 1867731,
                "content": [
                    {
                        "username": "atdgp97",
                        "content": " `your inline code...your inline code...`\\'unicode\\' object has no attribute \\'insert\\'\\ngetting this error again and again when using list"
                    },
                    {
                        "username": "Ambadas_Sangoli",
                        "content": "3rd testcase - \"(]\" i am getting error whereas I am getting correct answer on pythontutor and IDE. Dont know whats wrong in my code."
                    },
                    {
                        "username": "Geronimo12",
                        "content": "Why is \"[()]{}\" considered valid, but \"([)]\" considered wrong? I don\\'t understand..."
                    },
                    {
                        "username": "dactung93",
                        "content": "Because [()] is vaid and {} is valid"
                    },
                    {
                        "username": "kevinjolly222",
                        "content": "Can some one help me i tried to submit but its showing error\\nhere is the code:\\n\\nclass Solution \\n{\\n    public boolean isValid(String s) \\n    {\\n        int q=0;\\n        int n=0;\\n        int j=0;\\n        Stack<Character> stk= new Stack<>();  \\n        Stack<Character> st= new Stack<>();  \\n        Stack<Character> suk= new Stack<>();  \\n        char ch[]=s.toCharArray();\\n        for(int i=0;i<ch.length;i++)\\n        {\\n            if(ch[i]==\\'(\\')\\n            {\\n                stk.push(ch[i]);  \\n            }\\n             if(ch[i]==\\'{\\')\\n            {\\n               st.push(ch[i]);  \\n            }\\n             if(ch[i]==\\'[\\')\\n            {\\n               suk.push(ch[i]);  \\n            }\\n            if(ch[i]==\\')\\')\\n            {\\n               stk.pop();  \\n            }\\n              if(ch[i]==\\'}\\')\\n            {\\n               st.pop();  \\n            }\\n            if(ch[i]==\\']\\')\\n            {\\n               suk.pop();  \\n            }\\n            \\n        }\\n    //  for(int i=0;i<ch.length;i++)\\n    //      {\\n           \\n    //     }\\n        if(stk.empty() && st.empty()) && suk.empty())\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }     \\n    }\\n}"
                    },
                    {
                        "username": "Axolet",
                        "content": "Poorly worded Leetcode. \\nMuch time wasted developing algorithms that works perfectly on the example inputs - but doesn\\'t work in actual test cases.\\nWould have saved me time giving us 1-2 more examples. "
                    },
                    {
                        "username": "saro_2003",
                        "content": "```\\nchar stack[2000];\\nint top=-1;\\nvoid push(char a){\\n    stack[++top]=a;\\n}\\nint isempty(){\\n    if(top==-1){\\n        return 1;\\n    }\\n    return 0;\\n}\\nvoid pop(){\\n    --top;\\n}\\nbool isValid(char * s){\\n    \\n    for(int i=0;i<strlen(s);i++){\\n        if(s[i]==\\'(\\' || s[i]==\\'{\\' || s[i]==\\'[\\'){\\n            push(s[i]);\\n        }\\n        else{\\n            if(isempty()==1){\\n                return 0;\\n            }\\n            if(s[i]==\\']\\'){\\n                if(stack[top]==\\'[\\'){\\n                    pop();\\n                    continue;\\n                }\\n                else{\\n                    // return 0;\\n                    break;\\n                }\\n            }\\n            if(s[i]==\\'}\\'){\\n                if(stack[top]==\\'{\\'){\\n                    pop();\\n                    continue;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            if(s[i]==\\')\\'){\\n                if(stack[top]==\\'(\\'){\\n                    pop();\\n                    continue;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    if(isempty()==1){\\n        return 1;\\n    }\\n    return 0;\\n}\\n```\\nfind the mistake in this code . \\n`{[]}` not runs properly"
                    },
                    {
                        "username": "nalinnishant",
                        "content": "can anyone help me to optimize my code?? it is working on O(n) but it only beat the 13% of the leetcoders on submission. \\n\\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> st = new Stack<>();\\n\\n        for(int i = 0; i < s.length(); i++){\\n            if(st.empty()){\\n                st.push(s.charAt(i));\\n            }else if((st.peek()==\\'(\\' && s.charAt(i)==\\')\\') || (st.peek()==\\'{\\' && s.charAt(i)==\\'}\\') || (st.peek()==\\'[\\' && s.charAt(i)==\\']\\') ){\\n                st.pop();\\n            }else{\\n                st.push(s.charAt(i));\\n            }\\n        }\\n\\n        return st.empty();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "alphazwest",
                        "content": "This is a great problem for helping hammer in the importance of defining conditional cases."
                    },
                    {
                        "username": "500lambdaxl9",
                        "content": "My Dumb Ways: use if-else to solve all of it"
                    },
                    {
                        "username": "Alireza_Nikpay",
                        "content": "\"ERROR: AddressSanitizer: heap-buffer-overflow on address\", what does this means? can\\'t really understand. (using std::vector, std::vector::pop_back, std::vector::back, std::push_back)"
                    }
                ]
            },
            {
                "id": 1864120,
                "content": [
                    {
                        "username": "atdgp97",
                        "content": " `your inline code...your inline code...`\\'unicode\\' object has no attribute \\'insert\\'\\ngetting this error again and again when using list"
                    },
                    {
                        "username": "Ambadas_Sangoli",
                        "content": "3rd testcase - \"(]\" i am getting error whereas I am getting correct answer on pythontutor and IDE. Dont know whats wrong in my code."
                    },
                    {
                        "username": "Geronimo12",
                        "content": "Why is \"[()]{}\" considered valid, but \"([)]\" considered wrong? I don\\'t understand..."
                    },
                    {
                        "username": "dactung93",
                        "content": "Because [()] is vaid and {} is valid"
                    },
                    {
                        "username": "kevinjolly222",
                        "content": "Can some one help me i tried to submit but its showing error\\nhere is the code:\\n\\nclass Solution \\n{\\n    public boolean isValid(String s) \\n    {\\n        int q=0;\\n        int n=0;\\n        int j=0;\\n        Stack<Character> stk= new Stack<>();  \\n        Stack<Character> st= new Stack<>();  \\n        Stack<Character> suk= new Stack<>();  \\n        char ch[]=s.toCharArray();\\n        for(int i=0;i<ch.length;i++)\\n        {\\n            if(ch[i]==\\'(\\')\\n            {\\n                stk.push(ch[i]);  \\n            }\\n             if(ch[i]==\\'{\\')\\n            {\\n               st.push(ch[i]);  \\n            }\\n             if(ch[i]==\\'[\\')\\n            {\\n               suk.push(ch[i]);  \\n            }\\n            if(ch[i]==\\')\\')\\n            {\\n               stk.pop();  \\n            }\\n              if(ch[i]==\\'}\\')\\n            {\\n               st.pop();  \\n            }\\n            if(ch[i]==\\']\\')\\n            {\\n               suk.pop();  \\n            }\\n            \\n        }\\n    //  for(int i=0;i<ch.length;i++)\\n    //      {\\n           \\n    //     }\\n        if(stk.empty() && st.empty()) && suk.empty())\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }     \\n    }\\n}"
                    },
                    {
                        "username": "Axolet",
                        "content": "Poorly worded Leetcode. \\nMuch time wasted developing algorithms that works perfectly on the example inputs - but doesn\\'t work in actual test cases.\\nWould have saved me time giving us 1-2 more examples. "
                    },
                    {
                        "username": "saro_2003",
                        "content": "```\\nchar stack[2000];\\nint top=-1;\\nvoid push(char a){\\n    stack[++top]=a;\\n}\\nint isempty(){\\n    if(top==-1){\\n        return 1;\\n    }\\n    return 0;\\n}\\nvoid pop(){\\n    --top;\\n}\\nbool isValid(char * s){\\n    \\n    for(int i=0;i<strlen(s);i++){\\n        if(s[i]==\\'(\\' || s[i]==\\'{\\' || s[i]==\\'[\\'){\\n            push(s[i]);\\n        }\\n        else{\\n            if(isempty()==1){\\n                return 0;\\n            }\\n            if(s[i]==\\']\\'){\\n                if(stack[top]==\\'[\\'){\\n                    pop();\\n                    continue;\\n                }\\n                else{\\n                    // return 0;\\n                    break;\\n                }\\n            }\\n            if(s[i]==\\'}\\'){\\n                if(stack[top]==\\'{\\'){\\n                    pop();\\n                    continue;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            if(s[i]==\\')\\'){\\n                if(stack[top]==\\'(\\'){\\n                    pop();\\n                    continue;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    if(isempty()==1){\\n        return 1;\\n    }\\n    return 0;\\n}\\n```\\nfind the mistake in this code . \\n`{[]}` not runs properly"
                    },
                    {
                        "username": "nalinnishant",
                        "content": "can anyone help me to optimize my code?? it is working on O(n) but it only beat the 13% of the leetcoders on submission. \\n\\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> st = new Stack<>();\\n\\n        for(int i = 0; i < s.length(); i++){\\n            if(st.empty()){\\n                st.push(s.charAt(i));\\n            }else if((st.peek()==\\'(\\' && s.charAt(i)==\\')\\') || (st.peek()==\\'{\\' && s.charAt(i)==\\'}\\') || (st.peek()==\\'[\\' && s.charAt(i)==\\']\\') ){\\n                st.pop();\\n            }else{\\n                st.push(s.charAt(i));\\n            }\\n        }\\n\\n        return st.empty();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "alphazwest",
                        "content": "This is a great problem for helping hammer in the importance of defining conditional cases."
                    },
                    {
                        "username": "500lambdaxl9",
                        "content": "My Dumb Ways: use if-else to solve all of it"
                    },
                    {
                        "username": "Alireza_Nikpay",
                        "content": "\"ERROR: AddressSanitizer: heap-buffer-overflow on address\", what does this means? can\\'t really understand. (using std::vector, std::vector::pop_back, std::vector::back, std::push_back)"
                    }
                ]
            },
            {
                "id": 1861420,
                "content": [
                    {
                        "username": "atdgp97",
                        "content": " `your inline code...your inline code...`\\'unicode\\' object has no attribute \\'insert\\'\\ngetting this error again and again when using list"
                    },
                    {
                        "username": "Ambadas_Sangoli",
                        "content": "3rd testcase - \"(]\" i am getting error whereas I am getting correct answer on pythontutor and IDE. Dont know whats wrong in my code."
                    },
                    {
                        "username": "Geronimo12",
                        "content": "Why is \"[()]{}\" considered valid, but \"([)]\" considered wrong? I don\\'t understand..."
                    },
                    {
                        "username": "dactung93",
                        "content": "Because [()] is vaid and {} is valid"
                    },
                    {
                        "username": "kevinjolly222",
                        "content": "Can some one help me i tried to submit but its showing error\\nhere is the code:\\n\\nclass Solution \\n{\\n    public boolean isValid(String s) \\n    {\\n        int q=0;\\n        int n=0;\\n        int j=0;\\n        Stack<Character> stk= new Stack<>();  \\n        Stack<Character> st= new Stack<>();  \\n        Stack<Character> suk= new Stack<>();  \\n        char ch[]=s.toCharArray();\\n        for(int i=0;i<ch.length;i++)\\n        {\\n            if(ch[i]==\\'(\\')\\n            {\\n                stk.push(ch[i]);  \\n            }\\n             if(ch[i]==\\'{\\')\\n            {\\n               st.push(ch[i]);  \\n            }\\n             if(ch[i]==\\'[\\')\\n            {\\n               suk.push(ch[i]);  \\n            }\\n            if(ch[i]==\\')\\')\\n            {\\n               stk.pop();  \\n            }\\n              if(ch[i]==\\'}\\')\\n            {\\n               st.pop();  \\n            }\\n            if(ch[i]==\\']\\')\\n            {\\n               suk.pop();  \\n            }\\n            \\n        }\\n    //  for(int i=0;i<ch.length;i++)\\n    //      {\\n           \\n    //     }\\n        if(stk.empty() && st.empty()) && suk.empty())\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }     \\n    }\\n}"
                    },
                    {
                        "username": "Axolet",
                        "content": "Poorly worded Leetcode. \\nMuch time wasted developing algorithms that works perfectly on the example inputs - but doesn\\'t work in actual test cases.\\nWould have saved me time giving us 1-2 more examples. "
                    },
                    {
                        "username": "saro_2003",
                        "content": "```\\nchar stack[2000];\\nint top=-1;\\nvoid push(char a){\\n    stack[++top]=a;\\n}\\nint isempty(){\\n    if(top==-1){\\n        return 1;\\n    }\\n    return 0;\\n}\\nvoid pop(){\\n    --top;\\n}\\nbool isValid(char * s){\\n    \\n    for(int i=0;i<strlen(s);i++){\\n        if(s[i]==\\'(\\' || s[i]==\\'{\\' || s[i]==\\'[\\'){\\n            push(s[i]);\\n        }\\n        else{\\n            if(isempty()==1){\\n                return 0;\\n            }\\n            if(s[i]==\\']\\'){\\n                if(stack[top]==\\'[\\'){\\n                    pop();\\n                    continue;\\n                }\\n                else{\\n                    // return 0;\\n                    break;\\n                }\\n            }\\n            if(s[i]==\\'}\\'){\\n                if(stack[top]==\\'{\\'){\\n                    pop();\\n                    continue;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            if(s[i]==\\')\\'){\\n                if(stack[top]==\\'(\\'){\\n                    pop();\\n                    continue;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    if(isempty()==1){\\n        return 1;\\n    }\\n    return 0;\\n}\\n```\\nfind the mistake in this code . \\n`{[]}` not runs properly"
                    },
                    {
                        "username": "nalinnishant",
                        "content": "can anyone help me to optimize my code?? it is working on O(n) but it only beat the 13% of the leetcoders on submission. \\n\\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> st = new Stack<>();\\n\\n        for(int i = 0; i < s.length(); i++){\\n            if(st.empty()){\\n                st.push(s.charAt(i));\\n            }else if((st.peek()==\\'(\\' && s.charAt(i)==\\')\\') || (st.peek()==\\'{\\' && s.charAt(i)==\\'}\\') || (st.peek()==\\'[\\' && s.charAt(i)==\\']\\') ){\\n                st.pop();\\n            }else{\\n                st.push(s.charAt(i));\\n            }\\n        }\\n\\n        return st.empty();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "alphazwest",
                        "content": "This is a great problem for helping hammer in the importance of defining conditional cases."
                    },
                    {
                        "username": "500lambdaxl9",
                        "content": "My Dumb Ways: use if-else to solve all of it"
                    },
                    {
                        "username": "Alireza_Nikpay",
                        "content": "\"ERROR: AddressSanitizer: heap-buffer-overflow on address\", what does this means? can\\'t really understand. (using std::vector, std::vector::pop_back, std::vector::back, std::push_back)"
                    }
                ]
            },
            {
                "id": 1859633,
                "content": [
                    {
                        "username": "arifsnoor",
                        "content": "#Please help me with c++ switch\nInvalid for testcase : \"{)\"\npossible problem: switch case not working properly\n\n```\nclass Solution {\npublic:\n    bool isValid(string s) {\n        stack<char> opening;\n        for(int i = 0; i < s.length(); i++){\n            char lst = (opening.empty())? '\\0' : opening.top();\n            switch(s.at(i)){\n                case ')':\n                    if(lst == '(') {\n                        opening.pop();\n                        break;  // breaks are inside if block for a specific reason\n                    }\n\n\n                case '}': // HOW THIS CASE IS BEING TRIGGERED BY ')' ? \n                    cout<<s.at(i); //DEBUGGER // STDOUTPUT:  \")\"\n                    if(lst == '{') {\n                        opening.pop();\n                        break;\n                    }\n\n\n                case ']':\n                    if(lst == '[') {\n                        opening.pop();\n                        break; \n                    }\n                default:\n                    opening.push(s.at(i));\n            }\n        }\n        return (opening.empty())? true : false;\n    }\n};\n```"
                    },
                    {
                        "username": "7swap",
                        "content": "# **USING LIST TO SOLVE THE PROBLEM**\\n\\n***s = ({[]})***\\n\\n**Dry run**\\n*l = (           1st iteration\\nl = ({          2nd iteration\\nl = ({[         3rd iteration\\nl = ({      [ ---- this is opposite of ] so we removes it from list\\nl = ({          4th iteration\\nl = (       { ---- this is opposite of } so we removes it from list\\nl = (           5th iteration\\nl =         ( ---- this is opposite of ) so we removes it from list*\\n\\n> at the end of it we check if list is empty and if it is then return True\\n\\n[https://leetcode.com/problems/valid-parentheses/solutions/3401493/using-list-to-solve-the-problem-o-n-time-o-n-space/](https://leetcode.com/problems/valid-parentheses/solutions/3401493/using-list-to-solve-the-problem-o-n-time-o-n-space/)"
                    },
                    {
                        "username": "ms0686714",
                        "content": "[ C ] Does anybody know where I am going wrong?\\n\\nI had alread AC today, and I want to comment out all \"printf\"\\nBut it is wrong answer when I comment out Line 23 as below\\n```\\nprintf(\"push %c to the stack, current _index is %d\\\\n\", ch, _index);\\n```\\nCould someone tell me why?\\nFull code \\nhttps://leetcode.com/problems/valid-parentheses/solutions/3400795/c-does-anybody-know-where-i-am-going-wrong/\\n\\nThanks a lot!"
                    },
                    {
                        "username": "Vansh_Golakiya",
                        "content": "what is the input has a first closed bracket?\\n\\n"
                    },
                    {
                        "username": "mohamed_ahmed123",
                        "content": "The description doesn\\'t give all the details :\\'("
                    },
                    {
                        "username": "s1ttu",
                        "content": "STACK week? "
                    },
                    {
                        "username": "anwendeng",
                        "content": "The problem can be solved. To reduce the number of if-branches, it is suggested to use a container to store the backet-pairs, for example hash-table. The elapsed time for my C++ problem costs only 0 ms"
                    },
                    {
                        "username": "anwendeng",
                        "content": "my solution https://leetcode.com/problems/valid-parentheses/solutions/3399033/easy-c-solution-using-stack-unordered-map-beats-100/"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "a week for stack? "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Finally, a question I\\'ve already solved.\\nLooks like this week will be a \"stack and queue\" week?"
                    },
                    {
                        "username": "vetor",
                        "content": "Finally after a long time easy one \\uD83E\\uDD72"
                    }
                ]
            },
            {
                "id": 1859500,
                "content": [
                    {
                        "username": "arifsnoor",
                        "content": "#Please help me with c++ switch\nInvalid for testcase : \"{)\"\npossible problem: switch case not working properly\n\n```\nclass Solution {\npublic:\n    bool isValid(string s) {\n        stack<char> opening;\n        for(int i = 0; i < s.length(); i++){\n            char lst = (opening.empty())? '\\0' : opening.top();\n            switch(s.at(i)){\n                case ')':\n                    if(lst == '(') {\n                        opening.pop();\n                        break;  // breaks are inside if block for a specific reason\n                    }\n\n\n                case '}': // HOW THIS CASE IS BEING TRIGGERED BY ')' ? \n                    cout<<s.at(i); //DEBUGGER // STDOUTPUT:  \")\"\n                    if(lst == '{') {\n                        opening.pop();\n                        break;\n                    }\n\n\n                case ']':\n                    if(lst == '[') {\n                        opening.pop();\n                        break; \n                    }\n                default:\n                    opening.push(s.at(i));\n            }\n        }\n        return (opening.empty())? true : false;\n    }\n};\n```"
                    },
                    {
                        "username": "7swap",
                        "content": "# **USING LIST TO SOLVE THE PROBLEM**\\n\\n***s = ({[]})***\\n\\n**Dry run**\\n*l = (           1st iteration\\nl = ({          2nd iteration\\nl = ({[         3rd iteration\\nl = ({      [ ---- this is opposite of ] so we removes it from list\\nl = ({          4th iteration\\nl = (       { ---- this is opposite of } so we removes it from list\\nl = (           5th iteration\\nl =         ( ---- this is opposite of ) so we removes it from list*\\n\\n> at the end of it we check if list is empty and if it is then return True\\n\\n[https://leetcode.com/problems/valid-parentheses/solutions/3401493/using-list-to-solve-the-problem-o-n-time-o-n-space/](https://leetcode.com/problems/valid-parentheses/solutions/3401493/using-list-to-solve-the-problem-o-n-time-o-n-space/)"
                    },
                    {
                        "username": "ms0686714",
                        "content": "[ C ] Does anybody know where I am going wrong?\\n\\nI had alread AC today, and I want to comment out all \"printf\"\\nBut it is wrong answer when I comment out Line 23 as below\\n```\\nprintf(\"push %c to the stack, current _index is %d\\\\n\", ch, _index);\\n```\\nCould someone tell me why?\\nFull code \\nhttps://leetcode.com/problems/valid-parentheses/solutions/3400795/c-does-anybody-know-where-i-am-going-wrong/\\n\\nThanks a lot!"
                    },
                    {
                        "username": "Vansh_Golakiya",
                        "content": "what is the input has a first closed bracket?\\n\\n"
                    },
                    {
                        "username": "mohamed_ahmed123",
                        "content": "The description doesn\\'t give all the details :\\'("
                    },
                    {
                        "username": "s1ttu",
                        "content": "STACK week? "
                    },
                    {
                        "username": "anwendeng",
                        "content": "The problem can be solved. To reduce the number of if-branches, it is suggested to use a container to store the backet-pairs, for example hash-table. The elapsed time for my C++ problem costs only 0 ms"
                    },
                    {
                        "username": "anwendeng",
                        "content": "my solution https://leetcode.com/problems/valid-parentheses/solutions/3399033/easy-c-solution-using-stack-unordered-map-beats-100/"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "a week for stack? "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Finally, a question I\\'ve already solved.\\nLooks like this week will be a \"stack and queue\" week?"
                    },
                    {
                        "username": "vetor",
                        "content": "Finally after a long time easy one \\uD83E\\uDD72"
                    }
                ]
            },
            {
                "id": 1859439,
                "content": [
                    {
                        "username": "arifsnoor",
                        "content": "#Please help me with c++ switch\nInvalid for testcase : \"{)\"\npossible problem: switch case not working properly\n\n```\nclass Solution {\npublic:\n    bool isValid(string s) {\n        stack<char> opening;\n        for(int i = 0; i < s.length(); i++){\n            char lst = (opening.empty())? '\\0' : opening.top();\n            switch(s.at(i)){\n                case ')':\n                    if(lst == '(') {\n                        opening.pop();\n                        break;  // breaks are inside if block for a specific reason\n                    }\n\n\n                case '}': // HOW THIS CASE IS BEING TRIGGERED BY ')' ? \n                    cout<<s.at(i); //DEBUGGER // STDOUTPUT:  \")\"\n                    if(lst == '{') {\n                        opening.pop();\n                        break;\n                    }\n\n\n                case ']':\n                    if(lst == '[') {\n                        opening.pop();\n                        break; \n                    }\n                default:\n                    opening.push(s.at(i));\n            }\n        }\n        return (opening.empty())? true : false;\n    }\n};\n```"
                    },
                    {
                        "username": "7swap",
                        "content": "# **USING LIST TO SOLVE THE PROBLEM**\\n\\n***s = ({[]})***\\n\\n**Dry run**\\n*l = (           1st iteration\\nl = ({          2nd iteration\\nl = ({[         3rd iteration\\nl = ({      [ ---- this is opposite of ] so we removes it from list\\nl = ({          4th iteration\\nl = (       { ---- this is opposite of } so we removes it from list\\nl = (           5th iteration\\nl =         ( ---- this is opposite of ) so we removes it from list*\\n\\n> at the end of it we check if list is empty and if it is then return True\\n\\n[https://leetcode.com/problems/valid-parentheses/solutions/3401493/using-list-to-solve-the-problem-o-n-time-o-n-space/](https://leetcode.com/problems/valid-parentheses/solutions/3401493/using-list-to-solve-the-problem-o-n-time-o-n-space/)"
                    },
                    {
                        "username": "ms0686714",
                        "content": "[ C ] Does anybody know where I am going wrong?\\n\\nI had alread AC today, and I want to comment out all \"printf\"\\nBut it is wrong answer when I comment out Line 23 as below\\n```\\nprintf(\"push %c to the stack, current _index is %d\\\\n\", ch, _index);\\n```\\nCould someone tell me why?\\nFull code \\nhttps://leetcode.com/problems/valid-parentheses/solutions/3400795/c-does-anybody-know-where-i-am-going-wrong/\\n\\nThanks a lot!"
                    },
                    {
                        "username": "Vansh_Golakiya",
                        "content": "what is the input has a first closed bracket?\\n\\n"
                    },
                    {
                        "username": "mohamed_ahmed123",
                        "content": "The description doesn\\'t give all the details :\\'("
                    },
                    {
                        "username": "s1ttu",
                        "content": "STACK week? "
                    },
                    {
                        "username": "anwendeng",
                        "content": "The problem can be solved. To reduce the number of if-branches, it is suggested to use a container to store the backet-pairs, for example hash-table. The elapsed time for my C++ problem costs only 0 ms"
                    },
                    {
                        "username": "anwendeng",
                        "content": "my solution https://leetcode.com/problems/valid-parentheses/solutions/3399033/easy-c-solution-using-stack-unordered-map-beats-100/"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "a week for stack? "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Finally, a question I\\'ve already solved.\\nLooks like this week will be a \"stack and queue\" week?"
                    },
                    {
                        "username": "vetor",
                        "content": "Finally after a long time easy one \\uD83E\\uDD72"
                    }
                ]
            },
            {
                "id": 1859362,
                "content": [
                    {
                        "username": "arifsnoor",
                        "content": "#Please help me with c++ switch\nInvalid for testcase : \"{)\"\npossible problem: switch case not working properly\n\n```\nclass Solution {\npublic:\n    bool isValid(string s) {\n        stack<char> opening;\n        for(int i = 0; i < s.length(); i++){\n            char lst = (opening.empty())? '\\0' : opening.top();\n            switch(s.at(i)){\n                case ')':\n                    if(lst == '(') {\n                        opening.pop();\n                        break;  // breaks are inside if block for a specific reason\n                    }\n\n\n                case '}': // HOW THIS CASE IS BEING TRIGGERED BY ')' ? \n                    cout<<s.at(i); //DEBUGGER // STDOUTPUT:  \")\"\n                    if(lst == '{') {\n                        opening.pop();\n                        break;\n                    }\n\n\n                case ']':\n                    if(lst == '[') {\n                        opening.pop();\n                        break; \n                    }\n                default:\n                    opening.push(s.at(i));\n            }\n        }\n        return (opening.empty())? true : false;\n    }\n};\n```"
                    },
                    {
                        "username": "7swap",
                        "content": "# **USING LIST TO SOLVE THE PROBLEM**\\n\\n***s = ({[]})***\\n\\n**Dry run**\\n*l = (           1st iteration\\nl = ({          2nd iteration\\nl = ({[         3rd iteration\\nl = ({      [ ---- this is opposite of ] so we removes it from list\\nl = ({          4th iteration\\nl = (       { ---- this is opposite of } so we removes it from list\\nl = (           5th iteration\\nl =         ( ---- this is opposite of ) so we removes it from list*\\n\\n> at the end of it we check if list is empty and if it is then return True\\n\\n[https://leetcode.com/problems/valid-parentheses/solutions/3401493/using-list-to-solve-the-problem-o-n-time-o-n-space/](https://leetcode.com/problems/valid-parentheses/solutions/3401493/using-list-to-solve-the-problem-o-n-time-o-n-space/)"
                    },
                    {
                        "username": "ms0686714",
                        "content": "[ C ] Does anybody know where I am going wrong?\\n\\nI had alread AC today, and I want to comment out all \"printf\"\\nBut it is wrong answer when I comment out Line 23 as below\\n```\\nprintf(\"push %c to the stack, current _index is %d\\\\n\", ch, _index);\\n```\\nCould someone tell me why?\\nFull code \\nhttps://leetcode.com/problems/valid-parentheses/solutions/3400795/c-does-anybody-know-where-i-am-going-wrong/\\n\\nThanks a lot!"
                    },
                    {
                        "username": "Vansh_Golakiya",
                        "content": "what is the input has a first closed bracket?\\n\\n"
                    },
                    {
                        "username": "mohamed_ahmed123",
                        "content": "The description doesn\\'t give all the details :\\'("
                    },
                    {
                        "username": "s1ttu",
                        "content": "STACK week? "
                    },
                    {
                        "username": "anwendeng",
                        "content": "The problem can be solved. To reduce the number of if-branches, it is suggested to use a container to store the backet-pairs, for example hash-table. The elapsed time for my C++ problem costs only 0 ms"
                    },
                    {
                        "username": "anwendeng",
                        "content": "my solution https://leetcode.com/problems/valid-parentheses/solutions/3399033/easy-c-solution-using-stack-unordered-map-beats-100/"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "a week for stack? "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Finally, a question I\\'ve already solved.\\nLooks like this week will be a \"stack and queue\" week?"
                    },
                    {
                        "username": "vetor",
                        "content": "Finally after a long time easy one \\uD83E\\uDD72"
                    }
                ]
            },
            {
                "id": 1859323,
                "content": [
                    {
                        "username": "arifsnoor",
                        "content": "#Please help me with c++ switch\nInvalid for testcase : \"{)\"\npossible problem: switch case not working properly\n\n```\nclass Solution {\npublic:\n    bool isValid(string s) {\n        stack<char> opening;\n        for(int i = 0; i < s.length(); i++){\n            char lst = (opening.empty())? '\\0' : opening.top();\n            switch(s.at(i)){\n                case ')':\n                    if(lst == '(') {\n                        opening.pop();\n                        break;  // breaks are inside if block for a specific reason\n                    }\n\n\n                case '}': // HOW THIS CASE IS BEING TRIGGERED BY ')' ? \n                    cout<<s.at(i); //DEBUGGER // STDOUTPUT:  \")\"\n                    if(lst == '{') {\n                        opening.pop();\n                        break;\n                    }\n\n\n                case ']':\n                    if(lst == '[') {\n                        opening.pop();\n                        break; \n                    }\n                default:\n                    opening.push(s.at(i));\n            }\n        }\n        return (opening.empty())? true : false;\n    }\n};\n```"
                    },
                    {
                        "username": "7swap",
                        "content": "# **USING LIST TO SOLVE THE PROBLEM**\\n\\n***s = ({[]})***\\n\\n**Dry run**\\n*l = (           1st iteration\\nl = ({          2nd iteration\\nl = ({[         3rd iteration\\nl = ({      [ ---- this is opposite of ] so we removes it from list\\nl = ({          4th iteration\\nl = (       { ---- this is opposite of } so we removes it from list\\nl = (           5th iteration\\nl =         ( ---- this is opposite of ) so we removes it from list*\\n\\n> at the end of it we check if list is empty and if it is then return True\\n\\n[https://leetcode.com/problems/valid-parentheses/solutions/3401493/using-list-to-solve-the-problem-o-n-time-o-n-space/](https://leetcode.com/problems/valid-parentheses/solutions/3401493/using-list-to-solve-the-problem-o-n-time-o-n-space/)"
                    },
                    {
                        "username": "ms0686714",
                        "content": "[ C ] Does anybody know where I am going wrong?\\n\\nI had alread AC today, and I want to comment out all \"printf\"\\nBut it is wrong answer when I comment out Line 23 as below\\n```\\nprintf(\"push %c to the stack, current _index is %d\\\\n\", ch, _index);\\n```\\nCould someone tell me why?\\nFull code \\nhttps://leetcode.com/problems/valid-parentheses/solutions/3400795/c-does-anybody-know-where-i-am-going-wrong/\\n\\nThanks a lot!"
                    },
                    {
                        "username": "Vansh_Golakiya",
                        "content": "what is the input has a first closed bracket?\\n\\n"
                    },
                    {
                        "username": "mohamed_ahmed123",
                        "content": "The description doesn\\'t give all the details :\\'("
                    },
                    {
                        "username": "s1ttu",
                        "content": "STACK week? "
                    },
                    {
                        "username": "anwendeng",
                        "content": "The problem can be solved. To reduce the number of if-branches, it is suggested to use a container to store the backet-pairs, for example hash-table. The elapsed time for my C++ problem costs only 0 ms"
                    },
                    {
                        "username": "anwendeng",
                        "content": "my solution https://leetcode.com/problems/valid-parentheses/solutions/3399033/easy-c-solution-using-stack-unordered-map-beats-100/"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "a week for stack? "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Finally, a question I\\'ve already solved.\\nLooks like this week will be a \"stack and queue\" week?"
                    },
                    {
                        "username": "vetor",
                        "content": "Finally after a long time easy one \\uD83E\\uDD72"
                    }
                ]
            },
            {
                "id": 1859176,
                "content": [
                    {
                        "username": "arifsnoor",
                        "content": "#Please help me with c++ switch\nInvalid for testcase : \"{)\"\npossible problem: switch case not working properly\n\n```\nclass Solution {\npublic:\n    bool isValid(string s) {\n        stack<char> opening;\n        for(int i = 0; i < s.length(); i++){\n            char lst = (opening.empty())? '\\0' : opening.top();\n            switch(s.at(i)){\n                case ')':\n                    if(lst == '(') {\n                        opening.pop();\n                        break;  // breaks are inside if block for a specific reason\n                    }\n\n\n                case '}': // HOW THIS CASE IS BEING TRIGGERED BY ')' ? \n                    cout<<s.at(i); //DEBUGGER // STDOUTPUT:  \")\"\n                    if(lst == '{') {\n                        opening.pop();\n                        break;\n                    }\n\n\n                case ']':\n                    if(lst == '[') {\n                        opening.pop();\n                        break; \n                    }\n                default:\n                    opening.push(s.at(i));\n            }\n        }\n        return (opening.empty())? true : false;\n    }\n};\n```"
                    },
                    {
                        "username": "7swap",
                        "content": "# **USING LIST TO SOLVE THE PROBLEM**\\n\\n***s = ({[]})***\\n\\n**Dry run**\\n*l = (           1st iteration\\nl = ({          2nd iteration\\nl = ({[         3rd iteration\\nl = ({      [ ---- this is opposite of ] so we removes it from list\\nl = ({          4th iteration\\nl = (       { ---- this is opposite of } so we removes it from list\\nl = (           5th iteration\\nl =         ( ---- this is opposite of ) so we removes it from list*\\n\\n> at the end of it we check if list is empty and if it is then return True\\n\\n[https://leetcode.com/problems/valid-parentheses/solutions/3401493/using-list-to-solve-the-problem-o-n-time-o-n-space/](https://leetcode.com/problems/valid-parentheses/solutions/3401493/using-list-to-solve-the-problem-o-n-time-o-n-space/)"
                    },
                    {
                        "username": "ms0686714",
                        "content": "[ C ] Does anybody know where I am going wrong?\\n\\nI had alread AC today, and I want to comment out all \"printf\"\\nBut it is wrong answer when I comment out Line 23 as below\\n```\\nprintf(\"push %c to the stack, current _index is %d\\\\n\", ch, _index);\\n```\\nCould someone tell me why?\\nFull code \\nhttps://leetcode.com/problems/valid-parentheses/solutions/3400795/c-does-anybody-know-where-i-am-going-wrong/\\n\\nThanks a lot!"
                    },
                    {
                        "username": "Vansh_Golakiya",
                        "content": "what is the input has a first closed bracket?\\n\\n"
                    },
                    {
                        "username": "mohamed_ahmed123",
                        "content": "The description doesn\\'t give all the details :\\'("
                    },
                    {
                        "username": "s1ttu",
                        "content": "STACK week? "
                    },
                    {
                        "username": "anwendeng",
                        "content": "The problem can be solved. To reduce the number of if-branches, it is suggested to use a container to store the backet-pairs, for example hash-table. The elapsed time for my C++ problem costs only 0 ms"
                    },
                    {
                        "username": "anwendeng",
                        "content": "my solution https://leetcode.com/problems/valid-parentheses/solutions/3399033/easy-c-solution-using-stack-unordered-map-beats-100/"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "a week for stack? "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Finally, a question I\\'ve already solved.\\nLooks like this week will be a \"stack and queue\" week?"
                    },
                    {
                        "username": "vetor",
                        "content": "Finally after a long time easy one \\uD83E\\uDD72"
                    }
                ]
            },
            {
                "id": 1858950,
                "content": [
                    {
                        "username": "arifsnoor",
                        "content": "#Please help me with c++ switch\nInvalid for testcase : \"{)\"\npossible problem: switch case not working properly\n\n```\nclass Solution {\npublic:\n    bool isValid(string s) {\n        stack<char> opening;\n        for(int i = 0; i < s.length(); i++){\n            char lst = (opening.empty())? '\\0' : opening.top();\n            switch(s.at(i)){\n                case ')':\n                    if(lst == '(') {\n                        opening.pop();\n                        break;  // breaks are inside if block for a specific reason\n                    }\n\n\n                case '}': // HOW THIS CASE IS BEING TRIGGERED BY ')' ? \n                    cout<<s.at(i); //DEBUGGER // STDOUTPUT:  \")\"\n                    if(lst == '{') {\n                        opening.pop();\n                        break;\n                    }\n\n\n                case ']':\n                    if(lst == '[') {\n                        opening.pop();\n                        break; \n                    }\n                default:\n                    opening.push(s.at(i));\n            }\n        }\n        return (opening.empty())? true : false;\n    }\n};\n```"
                    },
                    {
                        "username": "7swap",
                        "content": "# **USING LIST TO SOLVE THE PROBLEM**\\n\\n***s = ({[]})***\\n\\n**Dry run**\\n*l = (           1st iteration\\nl = ({          2nd iteration\\nl = ({[         3rd iteration\\nl = ({      [ ---- this is opposite of ] so we removes it from list\\nl = ({          4th iteration\\nl = (       { ---- this is opposite of } so we removes it from list\\nl = (           5th iteration\\nl =         ( ---- this is opposite of ) so we removes it from list*\\n\\n> at the end of it we check if list is empty and if it is then return True\\n\\n[https://leetcode.com/problems/valid-parentheses/solutions/3401493/using-list-to-solve-the-problem-o-n-time-o-n-space/](https://leetcode.com/problems/valid-parentheses/solutions/3401493/using-list-to-solve-the-problem-o-n-time-o-n-space/)"
                    },
                    {
                        "username": "ms0686714",
                        "content": "[ C ] Does anybody know where I am going wrong?\\n\\nI had alread AC today, and I want to comment out all \"printf\"\\nBut it is wrong answer when I comment out Line 23 as below\\n```\\nprintf(\"push %c to the stack, current _index is %d\\\\n\", ch, _index);\\n```\\nCould someone tell me why?\\nFull code \\nhttps://leetcode.com/problems/valid-parentheses/solutions/3400795/c-does-anybody-know-where-i-am-going-wrong/\\n\\nThanks a lot!"
                    },
                    {
                        "username": "Vansh_Golakiya",
                        "content": "what is the input has a first closed bracket?\\n\\n"
                    },
                    {
                        "username": "mohamed_ahmed123",
                        "content": "The description doesn\\'t give all the details :\\'("
                    },
                    {
                        "username": "s1ttu",
                        "content": "STACK week? "
                    },
                    {
                        "username": "anwendeng",
                        "content": "The problem can be solved. To reduce the number of if-branches, it is suggested to use a container to store the backet-pairs, for example hash-table. The elapsed time for my C++ problem costs only 0 ms"
                    },
                    {
                        "username": "anwendeng",
                        "content": "my solution https://leetcode.com/problems/valid-parentheses/solutions/3399033/easy-c-solution-using-stack-unordered-map-beats-100/"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "a week for stack? "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Finally, a question I\\'ve already solved.\\nLooks like this week will be a \"stack and queue\" week?"
                    },
                    {
                        "username": "vetor",
                        "content": "Finally after a long time easy one \\uD83E\\uDD72"
                    }
                ]
            },
            {
                "id": 1858923,
                "content": [
                    {
                        "username": "arifsnoor",
                        "content": "#Please help me with c++ switch\nInvalid for testcase : \"{)\"\npossible problem: switch case not working properly\n\n```\nclass Solution {\npublic:\n    bool isValid(string s) {\n        stack<char> opening;\n        for(int i = 0; i < s.length(); i++){\n            char lst = (opening.empty())? '\\0' : opening.top();\n            switch(s.at(i)){\n                case ')':\n                    if(lst == '(') {\n                        opening.pop();\n                        break;  // breaks are inside if block for a specific reason\n                    }\n\n\n                case '}': // HOW THIS CASE IS BEING TRIGGERED BY ')' ? \n                    cout<<s.at(i); //DEBUGGER // STDOUTPUT:  \")\"\n                    if(lst == '{') {\n                        opening.pop();\n                        break;\n                    }\n\n\n                case ']':\n                    if(lst == '[') {\n                        opening.pop();\n                        break; \n                    }\n                default:\n                    opening.push(s.at(i));\n            }\n        }\n        return (opening.empty())? true : false;\n    }\n};\n```"
                    },
                    {
                        "username": "7swap",
                        "content": "# **USING LIST TO SOLVE THE PROBLEM**\\n\\n***s = ({[]})***\\n\\n**Dry run**\\n*l = (           1st iteration\\nl = ({          2nd iteration\\nl = ({[         3rd iteration\\nl = ({      [ ---- this is opposite of ] so we removes it from list\\nl = ({          4th iteration\\nl = (       { ---- this is opposite of } so we removes it from list\\nl = (           5th iteration\\nl =         ( ---- this is opposite of ) so we removes it from list*\\n\\n> at the end of it we check if list is empty and if it is then return True\\n\\n[https://leetcode.com/problems/valid-parentheses/solutions/3401493/using-list-to-solve-the-problem-o-n-time-o-n-space/](https://leetcode.com/problems/valid-parentheses/solutions/3401493/using-list-to-solve-the-problem-o-n-time-o-n-space/)"
                    },
                    {
                        "username": "ms0686714",
                        "content": "[ C ] Does anybody know where I am going wrong?\\n\\nI had alread AC today, and I want to comment out all \"printf\"\\nBut it is wrong answer when I comment out Line 23 as below\\n```\\nprintf(\"push %c to the stack, current _index is %d\\\\n\", ch, _index);\\n```\\nCould someone tell me why?\\nFull code \\nhttps://leetcode.com/problems/valid-parentheses/solutions/3400795/c-does-anybody-know-where-i-am-going-wrong/\\n\\nThanks a lot!"
                    },
                    {
                        "username": "Vansh_Golakiya",
                        "content": "what is the input has a first closed bracket?\\n\\n"
                    },
                    {
                        "username": "mohamed_ahmed123",
                        "content": "The description doesn\\'t give all the details :\\'("
                    },
                    {
                        "username": "s1ttu",
                        "content": "STACK week? "
                    },
                    {
                        "username": "anwendeng",
                        "content": "The problem can be solved. To reduce the number of if-branches, it is suggested to use a container to store the backet-pairs, for example hash-table. The elapsed time for my C++ problem costs only 0 ms"
                    },
                    {
                        "username": "anwendeng",
                        "content": "my solution https://leetcode.com/problems/valid-parentheses/solutions/3399033/easy-c-solution-using-stack-unordered-map-beats-100/"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "a week for stack? "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Finally, a question I\\'ve already solved.\\nLooks like this week will be a \"stack and queue\" week?"
                    },
                    {
                        "username": "vetor",
                        "content": "Finally after a long time easy one \\uD83E\\uDD72"
                    }
                ]
            },
            {
                "id": 1858905,
                "content": [
                    {
                        "username": "arifsnoor",
                        "content": "#Please help me with c++ switch\nInvalid for testcase : \"{)\"\npossible problem: switch case not working properly\n\n```\nclass Solution {\npublic:\n    bool isValid(string s) {\n        stack<char> opening;\n        for(int i = 0; i < s.length(); i++){\n            char lst = (opening.empty())? '\\0' : opening.top();\n            switch(s.at(i)){\n                case ')':\n                    if(lst == '(') {\n                        opening.pop();\n                        break;  // breaks are inside if block for a specific reason\n                    }\n\n\n                case '}': // HOW THIS CASE IS BEING TRIGGERED BY ')' ? \n                    cout<<s.at(i); //DEBUGGER // STDOUTPUT:  \")\"\n                    if(lst == '{') {\n                        opening.pop();\n                        break;\n                    }\n\n\n                case ']':\n                    if(lst == '[') {\n                        opening.pop();\n                        break; \n                    }\n                default:\n                    opening.push(s.at(i));\n            }\n        }\n        return (opening.empty())? true : false;\n    }\n};\n```"
                    },
                    {
                        "username": "7swap",
                        "content": "# **USING LIST TO SOLVE THE PROBLEM**\\n\\n***s = ({[]})***\\n\\n**Dry run**\\n*l = (           1st iteration\\nl = ({          2nd iteration\\nl = ({[         3rd iteration\\nl = ({      [ ---- this is opposite of ] so we removes it from list\\nl = ({          4th iteration\\nl = (       { ---- this is opposite of } so we removes it from list\\nl = (           5th iteration\\nl =         ( ---- this is opposite of ) so we removes it from list*\\n\\n> at the end of it we check if list is empty and if it is then return True\\n\\n[https://leetcode.com/problems/valid-parentheses/solutions/3401493/using-list-to-solve-the-problem-o-n-time-o-n-space/](https://leetcode.com/problems/valid-parentheses/solutions/3401493/using-list-to-solve-the-problem-o-n-time-o-n-space/)"
                    },
                    {
                        "username": "ms0686714",
                        "content": "[ C ] Does anybody know where I am going wrong?\\n\\nI had alread AC today, and I want to comment out all \"printf\"\\nBut it is wrong answer when I comment out Line 23 as below\\n```\\nprintf(\"push %c to the stack, current _index is %d\\\\n\", ch, _index);\\n```\\nCould someone tell me why?\\nFull code \\nhttps://leetcode.com/problems/valid-parentheses/solutions/3400795/c-does-anybody-know-where-i-am-going-wrong/\\n\\nThanks a lot!"
                    },
                    {
                        "username": "Vansh_Golakiya",
                        "content": "what is the input has a first closed bracket?\\n\\n"
                    },
                    {
                        "username": "mohamed_ahmed123",
                        "content": "The description doesn\\'t give all the details :\\'("
                    },
                    {
                        "username": "s1ttu",
                        "content": "STACK week? "
                    },
                    {
                        "username": "anwendeng",
                        "content": "The problem can be solved. To reduce the number of if-branches, it is suggested to use a container to store the backet-pairs, for example hash-table. The elapsed time for my C++ problem costs only 0 ms"
                    },
                    {
                        "username": "anwendeng",
                        "content": "my solution https://leetcode.com/problems/valid-parentheses/solutions/3399033/easy-c-solution-using-stack-unordered-map-beats-100/"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "a week for stack? "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Finally, a question I\\'ve already solved.\\nLooks like this week will be a \"stack and queue\" week?"
                    },
                    {
                        "username": "vetor",
                        "content": "Finally after a long time easy one \\uD83E\\uDD72"
                    }
                ]
            },
            {
                "id": 1858903,
                "content": [
                    {
                        "username": "arifsnoor",
                        "content": "#Please help me with c++ switch\nInvalid for testcase : \"{)\"\npossible problem: switch case not working properly\n\n```\nclass Solution {\npublic:\n    bool isValid(string s) {\n        stack<char> opening;\n        for(int i = 0; i < s.length(); i++){\n            char lst = (opening.empty())? '\\0' : opening.top();\n            switch(s.at(i)){\n                case ')':\n                    if(lst == '(') {\n                        opening.pop();\n                        break;  // breaks are inside if block for a specific reason\n                    }\n\n\n                case '}': // HOW THIS CASE IS BEING TRIGGERED BY ')' ? \n                    cout<<s.at(i); //DEBUGGER // STDOUTPUT:  \")\"\n                    if(lst == '{') {\n                        opening.pop();\n                        break;\n                    }\n\n\n                case ']':\n                    if(lst == '[') {\n                        opening.pop();\n                        break; \n                    }\n                default:\n                    opening.push(s.at(i));\n            }\n        }\n        return (opening.empty())? true : false;\n    }\n};\n```"
                    },
                    {
                        "username": "7swap",
                        "content": "# **USING LIST TO SOLVE THE PROBLEM**\\n\\n***s = ({[]})***\\n\\n**Dry run**\\n*l = (           1st iteration\\nl = ({          2nd iteration\\nl = ({[         3rd iteration\\nl = ({      [ ---- this is opposite of ] so we removes it from list\\nl = ({          4th iteration\\nl = (       { ---- this is opposite of } so we removes it from list\\nl = (           5th iteration\\nl =         ( ---- this is opposite of ) so we removes it from list*\\n\\n> at the end of it we check if list is empty and if it is then return True\\n\\n[https://leetcode.com/problems/valid-parentheses/solutions/3401493/using-list-to-solve-the-problem-o-n-time-o-n-space/](https://leetcode.com/problems/valid-parentheses/solutions/3401493/using-list-to-solve-the-problem-o-n-time-o-n-space/)"
                    },
                    {
                        "username": "ms0686714",
                        "content": "[ C ] Does anybody know where I am going wrong?\\n\\nI had alread AC today, and I want to comment out all \"printf\"\\nBut it is wrong answer when I comment out Line 23 as below\\n```\\nprintf(\"push %c to the stack, current _index is %d\\\\n\", ch, _index);\\n```\\nCould someone tell me why?\\nFull code \\nhttps://leetcode.com/problems/valid-parentheses/solutions/3400795/c-does-anybody-know-where-i-am-going-wrong/\\n\\nThanks a lot!"
                    },
                    {
                        "username": "Vansh_Golakiya",
                        "content": "what is the input has a first closed bracket?\\n\\n"
                    },
                    {
                        "username": "mohamed_ahmed123",
                        "content": "The description doesn\\'t give all the details :\\'("
                    },
                    {
                        "username": "s1ttu",
                        "content": "STACK week? "
                    },
                    {
                        "username": "anwendeng",
                        "content": "The problem can be solved. To reduce the number of if-branches, it is suggested to use a container to store the backet-pairs, for example hash-table. The elapsed time for my C++ problem costs only 0 ms"
                    },
                    {
                        "username": "anwendeng",
                        "content": "my solution https://leetcode.com/problems/valid-parentheses/solutions/3399033/easy-c-solution-using-stack-unordered-map-beats-100/"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "a week for stack? "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Finally, a question I\\'ve already solved.\\nLooks like this week will be a \"stack and queue\" week?"
                    },
                    {
                        "username": "vetor",
                        "content": "Finally after a long time easy one \\uD83E\\uDD72"
                    }
                ]
            },
            {
                "id": 1858877,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "Ok, so Leetcode is now compensating from yesterday's hard problem by today's easy one :-)"
                    },
                    {
                        "username": "x-ider",
                        "content": "What a relief after previous daily challenge hard task! Especially, when it\\'s already was solved by you ;)"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def isValid(self, s):\\n        for i in range(len(s)):\\n            s = s.replace(\\'{}\\', \\'\\').replace(\\'[]\\', \\'\\').replace(\\'()\\', \\'\\')\\n        return s == \\'\\'"
                    },
                    {
                        "username": "hathimhassan",
                        "content": "why \"([)]\" is not valid? brackedts are opened and closed properly"
                    },
                    {
                        "username": "sk33_f",
                        "content": "shouldn\\'t this return true \\n\\ns =\\n\"([)]\""
                    },
                    {
                        "username": "TommasoRacc22",
                        "content": "an input like this \"{ ( } )\" is wrong or not?"
                    },
                    {
                        "username": "shubhankar-pande",
                        "content": "class Solution {\\npublic:\\n    bool isValid(string s) {\\n        int n = s.length();\\n        stack<char> st;\\n        bool ans = false;\\n\\n        for(int i=0;i<n;i++){\\n           st.push(s[i]);\\n        }\\n           for(int i=0;i<n;i++){\\n        //    st.pop();\\n           char tp = st.top();\\n           st.pop();\\n           switch(tp){\\n               case \\'(\\':\\n               if(st.top() == \\')\\'){\\n                   ans = true;\\n               }\\n               break;\\n\\n               case \\'{\\':\\n               if(st.top() == \\'}\\'){\\n                   ans = true;\\n               }\\n               break;\\n\\n               case \\'[\\':\\n               if(st.top() == \\']\\'){\\n                   ans = true;\\n               }\\n               break;\\n           }\\n        //    st.pop();\\n        }\\n       return ans;\\n    }\\n};\\nIt is giving a runtime error can anyone please help."
                    },
                    {
                        "username": "Ryomen5ukuna",
                        "content": "This was the first time when i found \"Hint\" to be actually helpful."
                    },
                    {
                        "username": "user5217FD",
                        "content": "([)] is considered false"
                    },
                    {
                        "username": "Q118",
                        "content": "In regards to the ordering confusion; it helped me to think of it like code. The brackets have to be the way they are when we write code"
                    }
                ]
            },
            {
                "id": 1858865,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "Ok, so Leetcode is now compensating from yesterday's hard problem by today's easy one :-)"
                    },
                    {
                        "username": "x-ider",
                        "content": "What a relief after previous daily challenge hard task! Especially, when it\\'s already was solved by you ;)"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def isValid(self, s):\\n        for i in range(len(s)):\\n            s = s.replace(\\'{}\\', \\'\\').replace(\\'[]\\', \\'\\').replace(\\'()\\', \\'\\')\\n        return s == \\'\\'"
                    },
                    {
                        "username": "hathimhassan",
                        "content": "why \"([)]\" is not valid? brackedts are opened and closed properly"
                    },
                    {
                        "username": "sk33_f",
                        "content": "shouldn\\'t this return true \\n\\ns =\\n\"([)]\""
                    },
                    {
                        "username": "TommasoRacc22",
                        "content": "an input like this \"{ ( } )\" is wrong or not?"
                    },
                    {
                        "username": "shubhankar-pande",
                        "content": "class Solution {\\npublic:\\n    bool isValid(string s) {\\n        int n = s.length();\\n        stack<char> st;\\n        bool ans = false;\\n\\n        for(int i=0;i<n;i++){\\n           st.push(s[i]);\\n        }\\n           for(int i=0;i<n;i++){\\n        //    st.pop();\\n           char tp = st.top();\\n           st.pop();\\n           switch(tp){\\n               case \\'(\\':\\n               if(st.top() == \\')\\'){\\n                   ans = true;\\n               }\\n               break;\\n\\n               case \\'{\\':\\n               if(st.top() == \\'}\\'){\\n                   ans = true;\\n               }\\n               break;\\n\\n               case \\'[\\':\\n               if(st.top() == \\']\\'){\\n                   ans = true;\\n               }\\n               break;\\n           }\\n        //    st.pop();\\n        }\\n       return ans;\\n    }\\n};\\nIt is giving a runtime error can anyone please help."
                    },
                    {
                        "username": "Ryomen5ukuna",
                        "content": "This was the first time when i found \"Hint\" to be actually helpful."
                    },
                    {
                        "username": "user5217FD",
                        "content": "([)] is considered false"
                    },
                    {
                        "username": "Q118",
                        "content": "In regards to the ordering confusion; it helped me to think of it like code. The brackets have to be the way they are when we write code"
                    }
                ]
            },
            {
                "id": 1858194,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "Ok, so Leetcode is now compensating from yesterday's hard problem by today's easy one :-)"
                    },
                    {
                        "username": "x-ider",
                        "content": "What a relief after previous daily challenge hard task! Especially, when it\\'s already was solved by you ;)"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def isValid(self, s):\\n        for i in range(len(s)):\\n            s = s.replace(\\'{}\\', \\'\\').replace(\\'[]\\', \\'\\').replace(\\'()\\', \\'\\')\\n        return s == \\'\\'"
                    },
                    {
                        "username": "hathimhassan",
                        "content": "why \"([)]\" is not valid? brackedts are opened and closed properly"
                    },
                    {
                        "username": "sk33_f",
                        "content": "shouldn\\'t this return true \\n\\ns =\\n\"([)]\""
                    },
                    {
                        "username": "TommasoRacc22",
                        "content": "an input like this \"{ ( } )\" is wrong or not?"
                    },
                    {
                        "username": "shubhankar-pande",
                        "content": "class Solution {\\npublic:\\n    bool isValid(string s) {\\n        int n = s.length();\\n        stack<char> st;\\n        bool ans = false;\\n\\n        for(int i=0;i<n;i++){\\n           st.push(s[i]);\\n        }\\n           for(int i=0;i<n;i++){\\n        //    st.pop();\\n           char tp = st.top();\\n           st.pop();\\n           switch(tp){\\n               case \\'(\\':\\n               if(st.top() == \\')\\'){\\n                   ans = true;\\n               }\\n               break;\\n\\n               case \\'{\\':\\n               if(st.top() == \\'}\\'){\\n                   ans = true;\\n               }\\n               break;\\n\\n               case \\'[\\':\\n               if(st.top() == \\']\\'){\\n                   ans = true;\\n               }\\n               break;\\n           }\\n        //    st.pop();\\n        }\\n       return ans;\\n    }\\n};\\nIt is giving a runtime error can anyone please help."
                    },
                    {
                        "username": "Ryomen5ukuna",
                        "content": "This was the first time when i found \"Hint\" to be actually helpful."
                    },
                    {
                        "username": "user5217FD",
                        "content": "([)] is considered false"
                    },
                    {
                        "username": "Q118",
                        "content": "In regards to the ordering confusion; it helped me to think of it like code. The brackets have to be the way they are when we write code"
                    }
                ]
            },
            {
                "id": 1856656,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "Ok, so Leetcode is now compensating from yesterday's hard problem by today's easy one :-)"
                    },
                    {
                        "username": "x-ider",
                        "content": "What a relief after previous daily challenge hard task! Especially, when it\\'s already was solved by you ;)"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def isValid(self, s):\\n        for i in range(len(s)):\\n            s = s.replace(\\'{}\\', \\'\\').replace(\\'[]\\', \\'\\').replace(\\'()\\', \\'\\')\\n        return s == \\'\\'"
                    },
                    {
                        "username": "hathimhassan",
                        "content": "why \"([)]\" is not valid? brackedts are opened and closed properly"
                    },
                    {
                        "username": "sk33_f",
                        "content": "shouldn\\'t this return true \\n\\ns =\\n\"([)]\""
                    },
                    {
                        "username": "TommasoRacc22",
                        "content": "an input like this \"{ ( } )\" is wrong or not?"
                    },
                    {
                        "username": "shubhankar-pande",
                        "content": "class Solution {\\npublic:\\n    bool isValid(string s) {\\n        int n = s.length();\\n        stack<char> st;\\n        bool ans = false;\\n\\n        for(int i=0;i<n;i++){\\n           st.push(s[i]);\\n        }\\n           for(int i=0;i<n;i++){\\n        //    st.pop();\\n           char tp = st.top();\\n           st.pop();\\n           switch(tp){\\n               case \\'(\\':\\n               if(st.top() == \\')\\'){\\n                   ans = true;\\n               }\\n               break;\\n\\n               case \\'{\\':\\n               if(st.top() == \\'}\\'){\\n                   ans = true;\\n               }\\n               break;\\n\\n               case \\'[\\':\\n               if(st.top() == \\']\\'){\\n                   ans = true;\\n               }\\n               break;\\n           }\\n        //    st.pop();\\n        }\\n       return ans;\\n    }\\n};\\nIt is giving a runtime error can anyone please help."
                    },
                    {
                        "username": "Ryomen5ukuna",
                        "content": "This was the first time when i found \"Hint\" to be actually helpful."
                    },
                    {
                        "username": "user5217FD",
                        "content": "([)] is considered false"
                    },
                    {
                        "username": "Q118",
                        "content": "In regards to the ordering confusion; it helped me to think of it like code. The brackets have to be the way they are when we write code"
                    }
                ]
            },
            {
                "id": 1850694,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "Ok, so Leetcode is now compensating from yesterday's hard problem by today's easy one :-)"
                    },
                    {
                        "username": "x-ider",
                        "content": "What a relief after previous daily challenge hard task! Especially, when it\\'s already was solved by you ;)"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def isValid(self, s):\\n        for i in range(len(s)):\\n            s = s.replace(\\'{}\\', \\'\\').replace(\\'[]\\', \\'\\').replace(\\'()\\', \\'\\')\\n        return s == \\'\\'"
                    },
                    {
                        "username": "hathimhassan",
                        "content": "why \"([)]\" is not valid? brackedts are opened and closed properly"
                    },
                    {
                        "username": "sk33_f",
                        "content": "shouldn\\'t this return true \\n\\ns =\\n\"([)]\""
                    },
                    {
                        "username": "TommasoRacc22",
                        "content": "an input like this \"{ ( } )\" is wrong or not?"
                    },
                    {
                        "username": "shubhankar-pande",
                        "content": "class Solution {\\npublic:\\n    bool isValid(string s) {\\n        int n = s.length();\\n        stack<char> st;\\n        bool ans = false;\\n\\n        for(int i=0;i<n;i++){\\n           st.push(s[i]);\\n        }\\n           for(int i=0;i<n;i++){\\n        //    st.pop();\\n           char tp = st.top();\\n           st.pop();\\n           switch(tp){\\n               case \\'(\\':\\n               if(st.top() == \\')\\'){\\n                   ans = true;\\n               }\\n               break;\\n\\n               case \\'{\\':\\n               if(st.top() == \\'}\\'){\\n                   ans = true;\\n               }\\n               break;\\n\\n               case \\'[\\':\\n               if(st.top() == \\']\\'){\\n                   ans = true;\\n               }\\n               break;\\n           }\\n        //    st.pop();\\n        }\\n       return ans;\\n    }\\n};\\nIt is giving a runtime error can anyone please help."
                    },
                    {
                        "username": "Ryomen5ukuna",
                        "content": "This was the first time when i found \"Hint\" to be actually helpful."
                    },
                    {
                        "username": "user5217FD",
                        "content": "([)] is considered false"
                    },
                    {
                        "username": "Q118",
                        "content": "In regards to the ordering confusion; it helped me to think of it like code. The brackets have to be the way they are when we write code"
                    }
                ]
            },
            {
                "id": 1850124,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "Ok, so Leetcode is now compensating from yesterday's hard problem by today's easy one :-)"
                    },
                    {
                        "username": "x-ider",
                        "content": "What a relief after previous daily challenge hard task! Especially, when it\\'s already was solved by you ;)"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def isValid(self, s):\\n        for i in range(len(s)):\\n            s = s.replace(\\'{}\\', \\'\\').replace(\\'[]\\', \\'\\').replace(\\'()\\', \\'\\')\\n        return s == \\'\\'"
                    },
                    {
                        "username": "hathimhassan",
                        "content": "why \"([)]\" is not valid? brackedts are opened and closed properly"
                    },
                    {
                        "username": "sk33_f",
                        "content": "shouldn\\'t this return true \\n\\ns =\\n\"([)]\""
                    },
                    {
                        "username": "TommasoRacc22",
                        "content": "an input like this \"{ ( } )\" is wrong or not?"
                    },
                    {
                        "username": "shubhankar-pande",
                        "content": "class Solution {\\npublic:\\n    bool isValid(string s) {\\n        int n = s.length();\\n        stack<char> st;\\n        bool ans = false;\\n\\n        for(int i=0;i<n;i++){\\n           st.push(s[i]);\\n        }\\n           for(int i=0;i<n;i++){\\n        //    st.pop();\\n           char tp = st.top();\\n           st.pop();\\n           switch(tp){\\n               case \\'(\\':\\n               if(st.top() == \\')\\'){\\n                   ans = true;\\n               }\\n               break;\\n\\n               case \\'{\\':\\n               if(st.top() == \\'}\\'){\\n                   ans = true;\\n               }\\n               break;\\n\\n               case \\'[\\':\\n               if(st.top() == \\']\\'){\\n                   ans = true;\\n               }\\n               break;\\n           }\\n        //    st.pop();\\n        }\\n       return ans;\\n    }\\n};\\nIt is giving a runtime error can anyone please help."
                    },
                    {
                        "username": "Ryomen5ukuna",
                        "content": "This was the first time when i found \"Hint\" to be actually helpful."
                    },
                    {
                        "username": "user5217FD",
                        "content": "([)] is considered false"
                    },
                    {
                        "username": "Q118",
                        "content": "In regards to the ordering confusion; it helped me to think of it like code. The brackets have to be the way they are when we write code"
                    }
                ]
            },
            {
                "id": 1841951,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "Ok, so Leetcode is now compensating from yesterday's hard problem by today's easy one :-)"
                    },
                    {
                        "username": "x-ider",
                        "content": "What a relief after previous daily challenge hard task! Especially, when it\\'s already was solved by you ;)"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def isValid(self, s):\\n        for i in range(len(s)):\\n            s = s.replace(\\'{}\\', \\'\\').replace(\\'[]\\', \\'\\').replace(\\'()\\', \\'\\')\\n        return s == \\'\\'"
                    },
                    {
                        "username": "hathimhassan",
                        "content": "why \"([)]\" is not valid? brackedts are opened and closed properly"
                    },
                    {
                        "username": "sk33_f",
                        "content": "shouldn\\'t this return true \\n\\ns =\\n\"([)]\""
                    },
                    {
                        "username": "TommasoRacc22",
                        "content": "an input like this \"{ ( } )\" is wrong or not?"
                    },
                    {
                        "username": "shubhankar-pande",
                        "content": "class Solution {\\npublic:\\n    bool isValid(string s) {\\n        int n = s.length();\\n        stack<char> st;\\n        bool ans = false;\\n\\n        for(int i=0;i<n;i++){\\n           st.push(s[i]);\\n        }\\n           for(int i=0;i<n;i++){\\n        //    st.pop();\\n           char tp = st.top();\\n           st.pop();\\n           switch(tp){\\n               case \\'(\\':\\n               if(st.top() == \\')\\'){\\n                   ans = true;\\n               }\\n               break;\\n\\n               case \\'{\\':\\n               if(st.top() == \\'}\\'){\\n                   ans = true;\\n               }\\n               break;\\n\\n               case \\'[\\':\\n               if(st.top() == \\']\\'){\\n                   ans = true;\\n               }\\n               break;\\n           }\\n        //    st.pop();\\n        }\\n       return ans;\\n    }\\n};\\nIt is giving a runtime error can anyone please help."
                    },
                    {
                        "username": "Ryomen5ukuna",
                        "content": "This was the first time when i found \"Hint\" to be actually helpful."
                    },
                    {
                        "username": "user5217FD",
                        "content": "([)] is considered false"
                    },
                    {
                        "username": "Q118",
                        "content": "In regards to the ordering confusion; it helped me to think of it like code. The brackets have to be the way they are when we write code"
                    }
                ]
            },
            {
                "id": 1832876,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "Ok, so Leetcode is now compensating from yesterday's hard problem by today's easy one :-)"
                    },
                    {
                        "username": "x-ider",
                        "content": "What a relief after previous daily challenge hard task! Especially, when it\\'s already was solved by you ;)"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def isValid(self, s):\\n        for i in range(len(s)):\\n            s = s.replace(\\'{}\\', \\'\\').replace(\\'[]\\', \\'\\').replace(\\'()\\', \\'\\')\\n        return s == \\'\\'"
                    },
                    {
                        "username": "hathimhassan",
                        "content": "why \"([)]\" is not valid? brackedts are opened and closed properly"
                    },
                    {
                        "username": "sk33_f",
                        "content": "shouldn\\'t this return true \\n\\ns =\\n\"([)]\""
                    },
                    {
                        "username": "TommasoRacc22",
                        "content": "an input like this \"{ ( } )\" is wrong or not?"
                    },
                    {
                        "username": "shubhankar-pande",
                        "content": "class Solution {\\npublic:\\n    bool isValid(string s) {\\n        int n = s.length();\\n        stack<char> st;\\n        bool ans = false;\\n\\n        for(int i=0;i<n;i++){\\n           st.push(s[i]);\\n        }\\n           for(int i=0;i<n;i++){\\n        //    st.pop();\\n           char tp = st.top();\\n           st.pop();\\n           switch(tp){\\n               case \\'(\\':\\n               if(st.top() == \\')\\'){\\n                   ans = true;\\n               }\\n               break;\\n\\n               case \\'{\\':\\n               if(st.top() == \\'}\\'){\\n                   ans = true;\\n               }\\n               break;\\n\\n               case \\'[\\':\\n               if(st.top() == \\']\\'){\\n                   ans = true;\\n               }\\n               break;\\n           }\\n        //    st.pop();\\n        }\\n       return ans;\\n    }\\n};\\nIt is giving a runtime error can anyone please help."
                    },
                    {
                        "username": "Ryomen5ukuna",
                        "content": "This was the first time when i found \"Hint\" to be actually helpful."
                    },
                    {
                        "username": "user5217FD",
                        "content": "([)] is considered false"
                    },
                    {
                        "username": "Q118",
                        "content": "In regards to the ordering confusion; it helped me to think of it like code. The brackets have to be the way they are when we write code"
                    }
                ]
            },
            {
                "id": 1832683,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "Ok, so Leetcode is now compensating from yesterday's hard problem by today's easy one :-)"
                    },
                    {
                        "username": "x-ider",
                        "content": "What a relief after previous daily challenge hard task! Especially, when it\\'s already was solved by you ;)"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def isValid(self, s):\\n        for i in range(len(s)):\\n            s = s.replace(\\'{}\\', \\'\\').replace(\\'[]\\', \\'\\').replace(\\'()\\', \\'\\')\\n        return s == \\'\\'"
                    },
                    {
                        "username": "hathimhassan",
                        "content": "why \"([)]\" is not valid? brackedts are opened and closed properly"
                    },
                    {
                        "username": "sk33_f",
                        "content": "shouldn\\'t this return true \\n\\ns =\\n\"([)]\""
                    },
                    {
                        "username": "TommasoRacc22",
                        "content": "an input like this \"{ ( } )\" is wrong or not?"
                    },
                    {
                        "username": "shubhankar-pande",
                        "content": "class Solution {\\npublic:\\n    bool isValid(string s) {\\n        int n = s.length();\\n        stack<char> st;\\n        bool ans = false;\\n\\n        for(int i=0;i<n;i++){\\n           st.push(s[i]);\\n        }\\n           for(int i=0;i<n;i++){\\n        //    st.pop();\\n           char tp = st.top();\\n           st.pop();\\n           switch(tp){\\n               case \\'(\\':\\n               if(st.top() == \\')\\'){\\n                   ans = true;\\n               }\\n               break;\\n\\n               case \\'{\\':\\n               if(st.top() == \\'}\\'){\\n                   ans = true;\\n               }\\n               break;\\n\\n               case \\'[\\':\\n               if(st.top() == \\']\\'){\\n                   ans = true;\\n               }\\n               break;\\n           }\\n        //    st.pop();\\n        }\\n       return ans;\\n    }\\n};\\nIt is giving a runtime error can anyone please help."
                    },
                    {
                        "username": "Ryomen5ukuna",
                        "content": "This was the first time when i found \"Hint\" to be actually helpful."
                    },
                    {
                        "username": "user5217FD",
                        "content": "([)] is considered false"
                    },
                    {
                        "username": "Q118",
                        "content": "In regards to the ordering confusion; it helped me to think of it like code. The brackets have to be the way they are when we write code"
                    }
                ]
            },
            {
                "id": 1827565,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "Ok, so Leetcode is now compensating from yesterday's hard problem by today's easy one :-)"
                    },
                    {
                        "username": "x-ider",
                        "content": "What a relief after previous daily challenge hard task! Especially, when it\\'s already was solved by you ;)"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def isValid(self, s):\\n        for i in range(len(s)):\\n            s = s.replace(\\'{}\\', \\'\\').replace(\\'[]\\', \\'\\').replace(\\'()\\', \\'\\')\\n        return s == \\'\\'"
                    },
                    {
                        "username": "hathimhassan",
                        "content": "why \"([)]\" is not valid? brackedts are opened and closed properly"
                    },
                    {
                        "username": "sk33_f",
                        "content": "shouldn\\'t this return true \\n\\ns =\\n\"([)]\""
                    },
                    {
                        "username": "TommasoRacc22",
                        "content": "an input like this \"{ ( } )\" is wrong or not?"
                    },
                    {
                        "username": "shubhankar-pande",
                        "content": "class Solution {\\npublic:\\n    bool isValid(string s) {\\n        int n = s.length();\\n        stack<char> st;\\n        bool ans = false;\\n\\n        for(int i=0;i<n;i++){\\n           st.push(s[i]);\\n        }\\n           for(int i=0;i<n;i++){\\n        //    st.pop();\\n           char tp = st.top();\\n           st.pop();\\n           switch(tp){\\n               case \\'(\\':\\n               if(st.top() == \\')\\'){\\n                   ans = true;\\n               }\\n               break;\\n\\n               case \\'{\\':\\n               if(st.top() == \\'}\\'){\\n                   ans = true;\\n               }\\n               break;\\n\\n               case \\'[\\':\\n               if(st.top() == \\']\\'){\\n                   ans = true;\\n               }\\n               break;\\n           }\\n        //    st.pop();\\n        }\\n       return ans;\\n    }\\n};\\nIt is giving a runtime error can anyone please help."
                    },
                    {
                        "username": "Ryomen5ukuna",
                        "content": "This was the first time when i found \"Hint\" to be actually helpful."
                    },
                    {
                        "username": "user5217FD",
                        "content": "([)] is considered false"
                    },
                    {
                        "username": "Q118",
                        "content": "In regards to the ordering confusion; it helped me to think of it like code. The brackets have to be the way they are when we write code"
                    }
                ]
            },
            {
                "id": 1825747,
                "content": [
                    {
                        "username": "yash2280",
                        "content": "how to think about solution of this problem?"
                    },
                    {
                        "username": "mi324015",
                        "content": "description never states nested bracket closing is still valid"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "### Is it possible to do it with Regex ?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "## I could not pass the test of `{[]}`\\n\\n## Code\\n```javascript\\nlet isValid = true;\\n\\n\\tfor (let i = 0; i < s.length; i = i + 2) {\\n\\t\\tlet j = i + 1;\\n\\t\\tif (s[i] == \\'(\\' && s[j] !== \\')\\') isValid = false;\\n\\t\\tif (s[i] == \\'{\\' && s[j] !== \\'}\\') isValid = false;\\n\\t\\tif (s[i] == \\'[\\' && s[j] !== \\']\\') isValid = false;\\n\\t}\\n\\treturn isValid;\\n```\\nWhat should I add to my code to pass this test?"
                    },
                    {
                        "username": "cagils",
                        "content": "tip: concise line for a stack based js solution\\n```js\\nif (o.includes(p)) stack.push(p) else if (o[c.indexOf(p)] !== stack.pop()) return false\\n```"
                    },
                    {
                        "username": "kodyagin",
                        "content": " What it means runtime error?"
                    },
                    {
                        "username": "ortori",
                        "content": "Hey everyone, \nWhy when I click submit, each time I get a different run time and score even though the code is the same? "
                    },
                    {
                        "username": "champ_boss",
                        "content": "What about inputs like { [ ] ( } )? Is it invalid?"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Yes, because the brackets must be closed in the correct order. \\nIn this case you must close ( before closing {"
                    },
                    {
                        "username": "nonethewiser",
                        "content": "What the hell is going on with this solution? Is it designed simply to pass the given cases? I do not understand how it could work. \\n\\nSaw this in the accepted solutions:\\n\\n```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        sub = [\\n            \"()\",\"{}\",\"[]\", \\n            \"(){}\",\"()[]\",\"{}[]\",\\n            \"(){}[]\",\"()[]{}\",\"{[]}\",\"([])\",\"(([]){})\",\"[{()}]\",\"[({(())}[()])]\",\"([]{})\",\"[()](())\",\"{}{}()[]\",\"{}{{}}\",\"[()[[]()]]\",\"[{({(){}})}]\",\"()({}[])[]{}\",\"[(){}[]({})]\",\"{}[{}]((){})(){}\",\"[]()[()()][{}]()\",\"{}([{}{}][])[{}]\",\"([]{{}})[{}[[]]]\",\"([[][]{({}({}))}])\",\"([[]][([][])({})]())\",\"[](([[]]){}{[]}([]))\",\"[][{[{{}}[][]{{}}]}]\"\\n            ]\\n        t = \"({]])]})]}([)}{][)]{}{(])}([]}])})}([]}({}([{][{}\"\\n        tt = len(t)    \\n        if(len(s)> tt):\\n            return True     \\n        if(s in sub):\\n            return True\\n        else:\\n            return False  \\n```"
                    },
                    {
                        "username": "akapar10",
                        "content": "Faulty test case. \"([)]\" test case expected answer is false. This shouldn\\'t be false, my code fails because of this test case. "
                    },
                    {
                        "username": "akapar10",
                        "content": "[@MaximPLV](/MaximPLV) Thanks for the comment. Obviously I misunderstood the problem, thanks for helping me see this."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Why shouldn\\'t it be false? You are closing with a normal bracket before you closed the square bracket. So it\\'s 100% false"
                    }
                ]
            },
            {
                "id": 1822032,
                "content": [
                    {
                        "username": "yash2280",
                        "content": "how to think about solution of this problem?"
                    },
                    {
                        "username": "mi324015",
                        "content": "description never states nested bracket closing is still valid"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "### Is it possible to do it with Regex ?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "## I could not pass the test of `{[]}`\\n\\n## Code\\n```javascript\\nlet isValid = true;\\n\\n\\tfor (let i = 0; i < s.length; i = i + 2) {\\n\\t\\tlet j = i + 1;\\n\\t\\tif (s[i] == \\'(\\' && s[j] !== \\')\\') isValid = false;\\n\\t\\tif (s[i] == \\'{\\' && s[j] !== \\'}\\') isValid = false;\\n\\t\\tif (s[i] == \\'[\\' && s[j] !== \\']\\') isValid = false;\\n\\t}\\n\\treturn isValid;\\n```\\nWhat should I add to my code to pass this test?"
                    },
                    {
                        "username": "cagils",
                        "content": "tip: concise line for a stack based js solution\\n```js\\nif (o.includes(p)) stack.push(p) else if (o[c.indexOf(p)] !== stack.pop()) return false\\n```"
                    },
                    {
                        "username": "kodyagin",
                        "content": " What it means runtime error?"
                    },
                    {
                        "username": "ortori",
                        "content": "Hey everyone, \nWhy when I click submit, each time I get a different run time and score even though the code is the same? "
                    },
                    {
                        "username": "champ_boss",
                        "content": "What about inputs like { [ ] ( } )? Is it invalid?"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Yes, because the brackets must be closed in the correct order. \\nIn this case you must close ( before closing {"
                    },
                    {
                        "username": "nonethewiser",
                        "content": "What the hell is going on with this solution? Is it designed simply to pass the given cases? I do not understand how it could work. \\n\\nSaw this in the accepted solutions:\\n\\n```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        sub = [\\n            \"()\",\"{}\",\"[]\", \\n            \"(){}\",\"()[]\",\"{}[]\",\\n            \"(){}[]\",\"()[]{}\",\"{[]}\",\"([])\",\"(([]){})\",\"[{()}]\",\"[({(())}[()])]\",\"([]{})\",\"[()](())\",\"{}{}()[]\",\"{}{{}}\",\"[()[[]()]]\",\"[{({(){}})}]\",\"()({}[])[]{}\",\"[(){}[]({})]\",\"{}[{}]((){})(){}\",\"[]()[()()][{}]()\",\"{}([{}{}][])[{}]\",\"([]{{}})[{}[[]]]\",\"([[][]{({}({}))}])\",\"([[]][([][])({})]())\",\"[](([[]]){}{[]}([]))\",\"[][{[{{}}[][]{{}}]}]\"\\n            ]\\n        t = \"({]])]})]}([)}{][)]{}{(])}([]}])})}([]}({}([{][{}\"\\n        tt = len(t)    \\n        if(len(s)> tt):\\n            return True     \\n        if(s in sub):\\n            return True\\n        else:\\n            return False  \\n```"
                    },
                    {
                        "username": "akapar10",
                        "content": "Faulty test case. \"([)]\" test case expected answer is false. This shouldn\\'t be false, my code fails because of this test case. "
                    },
                    {
                        "username": "akapar10",
                        "content": "[@MaximPLV](/MaximPLV) Thanks for the comment. Obviously I misunderstood the problem, thanks for helping me see this."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Why shouldn\\'t it be false? You are closing with a normal bracket before you closed the square bracket. So it\\'s 100% false"
                    }
                ]
            },
            {
                "id": 1821733,
                "content": [
                    {
                        "username": "yash2280",
                        "content": "how to think about solution of this problem?"
                    },
                    {
                        "username": "mi324015",
                        "content": "description never states nested bracket closing is still valid"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "### Is it possible to do it with Regex ?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "## I could not pass the test of `{[]}`\\n\\n## Code\\n```javascript\\nlet isValid = true;\\n\\n\\tfor (let i = 0; i < s.length; i = i + 2) {\\n\\t\\tlet j = i + 1;\\n\\t\\tif (s[i] == \\'(\\' && s[j] !== \\')\\') isValid = false;\\n\\t\\tif (s[i] == \\'{\\' && s[j] !== \\'}\\') isValid = false;\\n\\t\\tif (s[i] == \\'[\\' && s[j] !== \\']\\') isValid = false;\\n\\t}\\n\\treturn isValid;\\n```\\nWhat should I add to my code to pass this test?"
                    },
                    {
                        "username": "cagils",
                        "content": "tip: concise line for a stack based js solution\\n```js\\nif (o.includes(p)) stack.push(p) else if (o[c.indexOf(p)] !== stack.pop()) return false\\n```"
                    },
                    {
                        "username": "kodyagin",
                        "content": " What it means runtime error?"
                    },
                    {
                        "username": "ortori",
                        "content": "Hey everyone, \nWhy when I click submit, each time I get a different run time and score even though the code is the same? "
                    },
                    {
                        "username": "champ_boss",
                        "content": "What about inputs like { [ ] ( } )? Is it invalid?"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Yes, because the brackets must be closed in the correct order. \\nIn this case you must close ( before closing {"
                    },
                    {
                        "username": "nonethewiser",
                        "content": "What the hell is going on with this solution? Is it designed simply to pass the given cases? I do not understand how it could work. \\n\\nSaw this in the accepted solutions:\\n\\n```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        sub = [\\n            \"()\",\"{}\",\"[]\", \\n            \"(){}\",\"()[]\",\"{}[]\",\\n            \"(){}[]\",\"()[]{}\",\"{[]}\",\"([])\",\"(([]){})\",\"[{()}]\",\"[({(())}[()])]\",\"([]{})\",\"[()](())\",\"{}{}()[]\",\"{}{{}}\",\"[()[[]()]]\",\"[{({(){}})}]\",\"()({}[])[]{}\",\"[(){}[]({})]\",\"{}[{}]((){})(){}\",\"[]()[()()][{}]()\",\"{}([{}{}][])[{}]\",\"([]{{}})[{}[[]]]\",\"([[][]{({}({}))}])\",\"([[]][([][])({})]())\",\"[](([[]]){}{[]}([]))\",\"[][{[{{}}[][]{{}}]}]\"\\n            ]\\n        t = \"({]])]})]}([)}{][)]{}{(])}([]}])})}([]}({}([{][{}\"\\n        tt = len(t)    \\n        if(len(s)> tt):\\n            return True     \\n        if(s in sub):\\n            return True\\n        else:\\n            return False  \\n```"
                    },
                    {
                        "username": "akapar10",
                        "content": "Faulty test case. \"([)]\" test case expected answer is false. This shouldn\\'t be false, my code fails because of this test case. "
                    },
                    {
                        "username": "akapar10",
                        "content": "[@MaximPLV](/MaximPLV) Thanks for the comment. Obviously I misunderstood the problem, thanks for helping me see this."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Why shouldn\\'t it be false? You are closing with a normal bracket before you closed the square bracket. So it\\'s 100% false"
                    }
                ]
            },
            {
                "id": 1821484,
                "content": [
                    {
                        "username": "yash2280",
                        "content": "how to think about solution of this problem?"
                    },
                    {
                        "username": "mi324015",
                        "content": "description never states nested bracket closing is still valid"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "### Is it possible to do it with Regex ?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "## I could not pass the test of `{[]}`\\n\\n## Code\\n```javascript\\nlet isValid = true;\\n\\n\\tfor (let i = 0; i < s.length; i = i + 2) {\\n\\t\\tlet j = i + 1;\\n\\t\\tif (s[i] == \\'(\\' && s[j] !== \\')\\') isValid = false;\\n\\t\\tif (s[i] == \\'{\\' && s[j] !== \\'}\\') isValid = false;\\n\\t\\tif (s[i] == \\'[\\' && s[j] !== \\']\\') isValid = false;\\n\\t}\\n\\treturn isValid;\\n```\\nWhat should I add to my code to pass this test?"
                    },
                    {
                        "username": "cagils",
                        "content": "tip: concise line for a stack based js solution\\n```js\\nif (o.includes(p)) stack.push(p) else if (o[c.indexOf(p)] !== stack.pop()) return false\\n```"
                    },
                    {
                        "username": "kodyagin",
                        "content": " What it means runtime error?"
                    },
                    {
                        "username": "ortori",
                        "content": "Hey everyone, \nWhy when I click submit, each time I get a different run time and score even though the code is the same? "
                    },
                    {
                        "username": "champ_boss",
                        "content": "What about inputs like { [ ] ( } )? Is it invalid?"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Yes, because the brackets must be closed in the correct order. \\nIn this case you must close ( before closing {"
                    },
                    {
                        "username": "nonethewiser",
                        "content": "What the hell is going on with this solution? Is it designed simply to pass the given cases? I do not understand how it could work. \\n\\nSaw this in the accepted solutions:\\n\\n```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        sub = [\\n            \"()\",\"{}\",\"[]\", \\n            \"(){}\",\"()[]\",\"{}[]\",\\n            \"(){}[]\",\"()[]{}\",\"{[]}\",\"([])\",\"(([]){})\",\"[{()}]\",\"[({(())}[()])]\",\"([]{})\",\"[()](())\",\"{}{}()[]\",\"{}{{}}\",\"[()[[]()]]\",\"[{({(){}})}]\",\"()({}[])[]{}\",\"[(){}[]({})]\",\"{}[{}]((){})(){}\",\"[]()[()()][{}]()\",\"{}([{}{}][])[{}]\",\"([]{{}})[{}[[]]]\",\"([[][]{({}({}))}])\",\"([[]][([][])({})]())\",\"[](([[]]){}{[]}([]))\",\"[][{[{{}}[][]{{}}]}]\"\\n            ]\\n        t = \"({]])]})]}([)}{][)]{}{(])}([]}])})}([]}({}([{][{}\"\\n        tt = len(t)    \\n        if(len(s)> tt):\\n            return True     \\n        if(s in sub):\\n            return True\\n        else:\\n            return False  \\n```"
                    },
                    {
                        "username": "akapar10",
                        "content": "Faulty test case. \"([)]\" test case expected answer is false. This shouldn\\'t be false, my code fails because of this test case. "
                    },
                    {
                        "username": "akapar10",
                        "content": "[@MaximPLV](/MaximPLV) Thanks for the comment. Obviously I misunderstood the problem, thanks for helping me see this."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Why shouldn\\'t it be false? You are closing with a normal bracket before you closed the square bracket. So it\\'s 100% false"
                    }
                ]
            },
            {
                "id": 1818489,
                "content": [
                    {
                        "username": "yash2280",
                        "content": "how to think about solution of this problem?"
                    },
                    {
                        "username": "mi324015",
                        "content": "description never states nested bracket closing is still valid"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "### Is it possible to do it with Regex ?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "## I could not pass the test of `{[]}`\\n\\n## Code\\n```javascript\\nlet isValid = true;\\n\\n\\tfor (let i = 0; i < s.length; i = i + 2) {\\n\\t\\tlet j = i + 1;\\n\\t\\tif (s[i] == \\'(\\' && s[j] !== \\')\\') isValid = false;\\n\\t\\tif (s[i] == \\'{\\' && s[j] !== \\'}\\') isValid = false;\\n\\t\\tif (s[i] == \\'[\\' && s[j] !== \\']\\') isValid = false;\\n\\t}\\n\\treturn isValid;\\n```\\nWhat should I add to my code to pass this test?"
                    },
                    {
                        "username": "cagils",
                        "content": "tip: concise line for a stack based js solution\\n```js\\nif (o.includes(p)) stack.push(p) else if (o[c.indexOf(p)] !== stack.pop()) return false\\n```"
                    },
                    {
                        "username": "kodyagin",
                        "content": " What it means runtime error?"
                    },
                    {
                        "username": "ortori",
                        "content": "Hey everyone, \nWhy when I click submit, each time I get a different run time and score even though the code is the same? "
                    },
                    {
                        "username": "champ_boss",
                        "content": "What about inputs like { [ ] ( } )? Is it invalid?"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Yes, because the brackets must be closed in the correct order. \\nIn this case you must close ( before closing {"
                    },
                    {
                        "username": "nonethewiser",
                        "content": "What the hell is going on with this solution? Is it designed simply to pass the given cases? I do not understand how it could work. \\n\\nSaw this in the accepted solutions:\\n\\n```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        sub = [\\n            \"()\",\"{}\",\"[]\", \\n            \"(){}\",\"()[]\",\"{}[]\",\\n            \"(){}[]\",\"()[]{}\",\"{[]}\",\"([])\",\"(([]){})\",\"[{()}]\",\"[({(())}[()])]\",\"([]{})\",\"[()](())\",\"{}{}()[]\",\"{}{{}}\",\"[()[[]()]]\",\"[{({(){}})}]\",\"()({}[])[]{}\",\"[(){}[]({})]\",\"{}[{}]((){})(){}\",\"[]()[()()][{}]()\",\"{}([{}{}][])[{}]\",\"([]{{}})[{}[[]]]\",\"([[][]{({}({}))}])\",\"([[]][([][])({})]())\",\"[](([[]]){}{[]}([]))\",\"[][{[{{}}[][]{{}}]}]\"\\n            ]\\n        t = \"({]])]})]}([)}{][)]{}{(])}([]}])})}([]}({}([{][{}\"\\n        tt = len(t)    \\n        if(len(s)> tt):\\n            return True     \\n        if(s in sub):\\n            return True\\n        else:\\n            return False  \\n```"
                    },
                    {
                        "username": "akapar10",
                        "content": "Faulty test case. \"([)]\" test case expected answer is false. This shouldn\\'t be false, my code fails because of this test case. "
                    },
                    {
                        "username": "akapar10",
                        "content": "[@MaximPLV](/MaximPLV) Thanks for the comment. Obviously I misunderstood the problem, thanks for helping me see this."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Why shouldn\\'t it be false? You are closing with a normal bracket before you closed the square bracket. So it\\'s 100% false"
                    }
                ]
            },
            {
                "id": 1817347,
                "content": [
                    {
                        "username": "yash2280",
                        "content": "how to think about solution of this problem?"
                    },
                    {
                        "username": "mi324015",
                        "content": "description never states nested bracket closing is still valid"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "### Is it possible to do it with Regex ?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "## I could not pass the test of `{[]}`\\n\\n## Code\\n```javascript\\nlet isValid = true;\\n\\n\\tfor (let i = 0; i < s.length; i = i + 2) {\\n\\t\\tlet j = i + 1;\\n\\t\\tif (s[i] == \\'(\\' && s[j] !== \\')\\') isValid = false;\\n\\t\\tif (s[i] == \\'{\\' && s[j] !== \\'}\\') isValid = false;\\n\\t\\tif (s[i] == \\'[\\' && s[j] !== \\']\\') isValid = false;\\n\\t}\\n\\treturn isValid;\\n```\\nWhat should I add to my code to pass this test?"
                    },
                    {
                        "username": "cagils",
                        "content": "tip: concise line for a stack based js solution\\n```js\\nif (o.includes(p)) stack.push(p) else if (o[c.indexOf(p)] !== stack.pop()) return false\\n```"
                    },
                    {
                        "username": "kodyagin",
                        "content": " What it means runtime error?"
                    },
                    {
                        "username": "ortori",
                        "content": "Hey everyone, \nWhy when I click submit, each time I get a different run time and score even though the code is the same? "
                    },
                    {
                        "username": "champ_boss",
                        "content": "What about inputs like { [ ] ( } )? Is it invalid?"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Yes, because the brackets must be closed in the correct order. \\nIn this case you must close ( before closing {"
                    },
                    {
                        "username": "nonethewiser",
                        "content": "What the hell is going on with this solution? Is it designed simply to pass the given cases? I do not understand how it could work. \\n\\nSaw this in the accepted solutions:\\n\\n```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        sub = [\\n            \"()\",\"{}\",\"[]\", \\n            \"(){}\",\"()[]\",\"{}[]\",\\n            \"(){}[]\",\"()[]{}\",\"{[]}\",\"([])\",\"(([]){})\",\"[{()}]\",\"[({(())}[()])]\",\"([]{})\",\"[()](())\",\"{}{}()[]\",\"{}{{}}\",\"[()[[]()]]\",\"[{({(){}})}]\",\"()({}[])[]{}\",\"[(){}[]({})]\",\"{}[{}]((){})(){}\",\"[]()[()()][{}]()\",\"{}([{}{}][])[{}]\",\"([]{{}})[{}[[]]]\",\"([[][]{({}({}))}])\",\"([[]][([][])({})]())\",\"[](([[]]){}{[]}([]))\",\"[][{[{{}}[][]{{}}]}]\"\\n            ]\\n        t = \"({]])]})]}([)}{][)]{}{(])}([]}])})}([]}({}([{][{}\"\\n        tt = len(t)    \\n        if(len(s)> tt):\\n            return True     \\n        if(s in sub):\\n            return True\\n        else:\\n            return False  \\n```"
                    },
                    {
                        "username": "akapar10",
                        "content": "Faulty test case. \"([)]\" test case expected answer is false. This shouldn\\'t be false, my code fails because of this test case. "
                    },
                    {
                        "username": "akapar10",
                        "content": "[@MaximPLV](/MaximPLV) Thanks for the comment. Obviously I misunderstood the problem, thanks for helping me see this."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Why shouldn\\'t it be false? You are closing with a normal bracket before you closed the square bracket. So it\\'s 100% false"
                    }
                ]
            },
            {
                "id": 1811805,
                "content": [
                    {
                        "username": "yash2280",
                        "content": "how to think about solution of this problem?"
                    },
                    {
                        "username": "mi324015",
                        "content": "description never states nested bracket closing is still valid"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "### Is it possible to do it with Regex ?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "## I could not pass the test of `{[]}`\\n\\n## Code\\n```javascript\\nlet isValid = true;\\n\\n\\tfor (let i = 0; i < s.length; i = i + 2) {\\n\\t\\tlet j = i + 1;\\n\\t\\tif (s[i] == \\'(\\' && s[j] !== \\')\\') isValid = false;\\n\\t\\tif (s[i] == \\'{\\' && s[j] !== \\'}\\') isValid = false;\\n\\t\\tif (s[i] == \\'[\\' && s[j] !== \\']\\') isValid = false;\\n\\t}\\n\\treturn isValid;\\n```\\nWhat should I add to my code to pass this test?"
                    },
                    {
                        "username": "cagils",
                        "content": "tip: concise line for a stack based js solution\\n```js\\nif (o.includes(p)) stack.push(p) else if (o[c.indexOf(p)] !== stack.pop()) return false\\n```"
                    },
                    {
                        "username": "kodyagin",
                        "content": " What it means runtime error?"
                    },
                    {
                        "username": "ortori",
                        "content": "Hey everyone, \nWhy when I click submit, each time I get a different run time and score even though the code is the same? "
                    },
                    {
                        "username": "champ_boss",
                        "content": "What about inputs like { [ ] ( } )? Is it invalid?"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Yes, because the brackets must be closed in the correct order. \\nIn this case you must close ( before closing {"
                    },
                    {
                        "username": "nonethewiser",
                        "content": "What the hell is going on with this solution? Is it designed simply to pass the given cases? I do not understand how it could work. \\n\\nSaw this in the accepted solutions:\\n\\n```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        sub = [\\n            \"()\",\"{}\",\"[]\", \\n            \"(){}\",\"()[]\",\"{}[]\",\\n            \"(){}[]\",\"()[]{}\",\"{[]}\",\"([])\",\"(([]){})\",\"[{()}]\",\"[({(())}[()])]\",\"([]{})\",\"[()](())\",\"{}{}()[]\",\"{}{{}}\",\"[()[[]()]]\",\"[{({(){}})}]\",\"()({}[])[]{}\",\"[(){}[]({})]\",\"{}[{}]((){})(){}\",\"[]()[()()][{}]()\",\"{}([{}{}][])[{}]\",\"([]{{}})[{}[[]]]\",\"([[][]{({}({}))}])\",\"([[]][([][])({})]())\",\"[](([[]]){}{[]}([]))\",\"[][{[{{}}[][]{{}}]}]\"\\n            ]\\n        t = \"({]])]})]}([)}{][)]{}{(])}([]}])})}([]}({}([{][{}\"\\n        tt = len(t)    \\n        if(len(s)> tt):\\n            return True     \\n        if(s in sub):\\n            return True\\n        else:\\n            return False  \\n```"
                    },
                    {
                        "username": "akapar10",
                        "content": "Faulty test case. \"([)]\" test case expected answer is false. This shouldn\\'t be false, my code fails because of this test case. "
                    },
                    {
                        "username": "akapar10",
                        "content": "[@MaximPLV](/MaximPLV) Thanks for the comment. Obviously I misunderstood the problem, thanks for helping me see this."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Why shouldn\\'t it be false? You are closing with a normal bracket before you closed the square bracket. So it\\'s 100% false"
                    }
                ]
            },
            {
                "id": 1809142,
                "content": [
                    {
                        "username": "yash2280",
                        "content": "how to think about solution of this problem?"
                    },
                    {
                        "username": "mi324015",
                        "content": "description never states nested bracket closing is still valid"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "### Is it possible to do it with Regex ?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "## I could not pass the test of `{[]}`\\n\\n## Code\\n```javascript\\nlet isValid = true;\\n\\n\\tfor (let i = 0; i < s.length; i = i + 2) {\\n\\t\\tlet j = i + 1;\\n\\t\\tif (s[i] == \\'(\\' && s[j] !== \\')\\') isValid = false;\\n\\t\\tif (s[i] == \\'{\\' && s[j] !== \\'}\\') isValid = false;\\n\\t\\tif (s[i] == \\'[\\' && s[j] !== \\']\\') isValid = false;\\n\\t}\\n\\treturn isValid;\\n```\\nWhat should I add to my code to pass this test?"
                    },
                    {
                        "username": "cagils",
                        "content": "tip: concise line for a stack based js solution\\n```js\\nif (o.includes(p)) stack.push(p) else if (o[c.indexOf(p)] !== stack.pop()) return false\\n```"
                    },
                    {
                        "username": "kodyagin",
                        "content": " What it means runtime error?"
                    },
                    {
                        "username": "ortori",
                        "content": "Hey everyone, \nWhy when I click submit, each time I get a different run time and score even though the code is the same? "
                    },
                    {
                        "username": "champ_boss",
                        "content": "What about inputs like { [ ] ( } )? Is it invalid?"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Yes, because the brackets must be closed in the correct order. \\nIn this case you must close ( before closing {"
                    },
                    {
                        "username": "nonethewiser",
                        "content": "What the hell is going on with this solution? Is it designed simply to pass the given cases? I do not understand how it could work. \\n\\nSaw this in the accepted solutions:\\n\\n```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        sub = [\\n            \"()\",\"{}\",\"[]\", \\n            \"(){}\",\"()[]\",\"{}[]\",\\n            \"(){}[]\",\"()[]{}\",\"{[]}\",\"([])\",\"(([]){})\",\"[{()}]\",\"[({(())}[()])]\",\"([]{})\",\"[()](())\",\"{}{}()[]\",\"{}{{}}\",\"[()[[]()]]\",\"[{({(){}})}]\",\"()({}[])[]{}\",\"[(){}[]({})]\",\"{}[{}]((){})(){}\",\"[]()[()()][{}]()\",\"{}([{}{}][])[{}]\",\"([]{{}})[{}[[]]]\",\"([[][]{({}({}))}])\",\"([[]][([][])({})]())\",\"[](([[]]){}{[]}([]))\",\"[][{[{{}}[][]{{}}]}]\"\\n            ]\\n        t = \"({]])]})]}([)}{][)]{}{(])}([]}])})}([]}({}([{][{}\"\\n        tt = len(t)    \\n        if(len(s)> tt):\\n            return True     \\n        if(s in sub):\\n            return True\\n        else:\\n            return False  \\n```"
                    },
                    {
                        "username": "akapar10",
                        "content": "Faulty test case. \"([)]\" test case expected answer is false. This shouldn\\'t be false, my code fails because of this test case. "
                    },
                    {
                        "username": "akapar10",
                        "content": "[@MaximPLV](/MaximPLV) Thanks for the comment. Obviously I misunderstood the problem, thanks for helping me see this."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Why shouldn\\'t it be false? You are closing with a normal bracket before you closed the square bracket. So it\\'s 100% false"
                    }
                ]
            },
            {
                "id": 1801020,
                "content": [
                    {
                        "username": "yash2280",
                        "content": "how to think about solution of this problem?"
                    },
                    {
                        "username": "mi324015",
                        "content": "description never states nested bracket closing is still valid"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "### Is it possible to do it with Regex ?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "## I could not pass the test of `{[]}`\\n\\n## Code\\n```javascript\\nlet isValid = true;\\n\\n\\tfor (let i = 0; i < s.length; i = i + 2) {\\n\\t\\tlet j = i + 1;\\n\\t\\tif (s[i] == \\'(\\' && s[j] !== \\')\\') isValid = false;\\n\\t\\tif (s[i] == \\'{\\' && s[j] !== \\'}\\') isValid = false;\\n\\t\\tif (s[i] == \\'[\\' && s[j] !== \\']\\') isValid = false;\\n\\t}\\n\\treturn isValid;\\n```\\nWhat should I add to my code to pass this test?"
                    },
                    {
                        "username": "cagils",
                        "content": "tip: concise line for a stack based js solution\\n```js\\nif (o.includes(p)) stack.push(p) else if (o[c.indexOf(p)] !== stack.pop()) return false\\n```"
                    },
                    {
                        "username": "kodyagin",
                        "content": " What it means runtime error?"
                    },
                    {
                        "username": "ortori",
                        "content": "Hey everyone, \nWhy when I click submit, each time I get a different run time and score even though the code is the same? "
                    },
                    {
                        "username": "champ_boss",
                        "content": "What about inputs like { [ ] ( } )? Is it invalid?"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Yes, because the brackets must be closed in the correct order. \\nIn this case you must close ( before closing {"
                    },
                    {
                        "username": "nonethewiser",
                        "content": "What the hell is going on with this solution? Is it designed simply to pass the given cases? I do not understand how it could work. \\n\\nSaw this in the accepted solutions:\\n\\n```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        sub = [\\n            \"()\",\"{}\",\"[]\", \\n            \"(){}\",\"()[]\",\"{}[]\",\\n            \"(){}[]\",\"()[]{}\",\"{[]}\",\"([])\",\"(([]){})\",\"[{()}]\",\"[({(())}[()])]\",\"([]{})\",\"[()](())\",\"{}{}()[]\",\"{}{{}}\",\"[()[[]()]]\",\"[{({(){}})}]\",\"()({}[])[]{}\",\"[(){}[]({})]\",\"{}[{}]((){})(){}\",\"[]()[()()][{}]()\",\"{}([{}{}][])[{}]\",\"([]{{}})[{}[[]]]\",\"([[][]{({}({}))}])\",\"([[]][([][])({})]())\",\"[](([[]]){}{[]}([]))\",\"[][{[{{}}[][]{{}}]}]\"\\n            ]\\n        t = \"({]])]})]}([)}{][)]{}{(])}([]}])})}([]}({}([{][{}\"\\n        tt = len(t)    \\n        if(len(s)> tt):\\n            return True     \\n        if(s in sub):\\n            return True\\n        else:\\n            return False  \\n```"
                    },
                    {
                        "username": "akapar10",
                        "content": "Faulty test case. \"([)]\" test case expected answer is false. This shouldn\\'t be false, my code fails because of this test case. "
                    },
                    {
                        "username": "akapar10",
                        "content": "[@MaximPLV](/MaximPLV) Thanks for the comment. Obviously I misunderstood the problem, thanks for helping me see this."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Why shouldn\\'t it be false? You are closing with a normal bracket before you closed the square bracket. So it\\'s 100% false"
                    }
                ]
            },
            {
                "id": 1795864,
                "content": [
                    {
                        "username": "yash2280",
                        "content": "how to think about solution of this problem?"
                    },
                    {
                        "username": "mi324015",
                        "content": "description never states nested bracket closing is still valid"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "### Is it possible to do it with Regex ?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "## I could not pass the test of `{[]}`\\n\\n## Code\\n```javascript\\nlet isValid = true;\\n\\n\\tfor (let i = 0; i < s.length; i = i + 2) {\\n\\t\\tlet j = i + 1;\\n\\t\\tif (s[i] == \\'(\\' && s[j] !== \\')\\') isValid = false;\\n\\t\\tif (s[i] == \\'{\\' && s[j] !== \\'}\\') isValid = false;\\n\\t\\tif (s[i] == \\'[\\' && s[j] !== \\']\\') isValid = false;\\n\\t}\\n\\treturn isValid;\\n```\\nWhat should I add to my code to pass this test?"
                    },
                    {
                        "username": "cagils",
                        "content": "tip: concise line for a stack based js solution\\n```js\\nif (o.includes(p)) stack.push(p) else if (o[c.indexOf(p)] !== stack.pop()) return false\\n```"
                    },
                    {
                        "username": "kodyagin",
                        "content": " What it means runtime error?"
                    },
                    {
                        "username": "ortori",
                        "content": "Hey everyone, \nWhy when I click submit, each time I get a different run time and score even though the code is the same? "
                    },
                    {
                        "username": "champ_boss",
                        "content": "What about inputs like { [ ] ( } )? Is it invalid?"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Yes, because the brackets must be closed in the correct order. \\nIn this case you must close ( before closing {"
                    },
                    {
                        "username": "nonethewiser",
                        "content": "What the hell is going on with this solution? Is it designed simply to pass the given cases? I do not understand how it could work. \\n\\nSaw this in the accepted solutions:\\n\\n```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        sub = [\\n            \"()\",\"{}\",\"[]\", \\n            \"(){}\",\"()[]\",\"{}[]\",\\n            \"(){}[]\",\"()[]{}\",\"{[]}\",\"([])\",\"(([]){})\",\"[{()}]\",\"[({(())}[()])]\",\"([]{})\",\"[()](())\",\"{}{}()[]\",\"{}{{}}\",\"[()[[]()]]\",\"[{({(){}})}]\",\"()({}[])[]{}\",\"[(){}[]({})]\",\"{}[{}]((){})(){}\",\"[]()[()()][{}]()\",\"{}([{}{}][])[{}]\",\"([]{{}})[{}[[]]]\",\"([[][]{({}({}))}])\",\"([[]][([][])({})]())\",\"[](([[]]){}{[]}([]))\",\"[][{[{{}}[][]{{}}]}]\"\\n            ]\\n        t = \"({]])]})]}([)}{][)]{}{(])}([]}])})}([]}({}([{][{}\"\\n        tt = len(t)    \\n        if(len(s)> tt):\\n            return True     \\n        if(s in sub):\\n            return True\\n        else:\\n            return False  \\n```"
                    },
                    {
                        "username": "akapar10",
                        "content": "Faulty test case. \"([)]\" test case expected answer is false. This shouldn\\'t be false, my code fails because of this test case. "
                    },
                    {
                        "username": "akapar10",
                        "content": "[@MaximPLV](/MaximPLV) Thanks for the comment. Obviously I misunderstood the problem, thanks for helping me see this."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Why shouldn\\'t it be false? You are closing with a normal bracket before you closed the square bracket. So it\\'s 100% false"
                    }
                ]
            },
            {
                "id": 1794144,
                "content": [
                    {
                        "username": "gvijay370",
                        "content": "class Solution:\\n    def isValid(self, s: str) -> bool:\\n        d1 = [\\'[\\',\\'{\\',\\'(\\']\\n        d2 = [\\']\\',\\'}\\',\\')\\']\\n        l = []\\n        for i in s:\\n            if i in d1:\\n                l.append(i)\\n            else:\\n                if len(l)!=0 and (d1.index(l.pop()) == d2.index(i)):\\n                    pass\\n                else:\\n                    return \\'false\\'\\n        \\n        return \\'true\\'\\n\\ncan someone tell what\\'s the problem in the above code, it is working perfectly fine in other compilers but not on leetcode console."
                    },
                    {
                        "username": "dmigalin",
                        "content": "Hi, Leetcode. I would like to show you the incorrect test for this particular task. Unittest \\u2116 74 stipulates the following values: s = \\u201C({{{{}}}))\\u201D, expected output = False.  I suppose that s[0} + s[-1] = \\u201C()\\u201D and It means that brackets are closed by the same type of brackets and in the correct order. The expected output has to be True, not False. What do you think about it?"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "What do you mean? ({{{{}}})) is 100% false. Lets break down the bracket into multiple bracket pairs from the outer to the inner brackets. () {) {} {} {} You see the second bracket is false because they are 2 different types"
                    },
                    {
                        "username": "mehruddin11",
                        "content": " `your inline code\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        stack =[]\n        p1= 0\n        for i in range(len(s)):\n            p = s[i]\n            if p == '(':\n                stack.append(')')\n            elif p == '[':\n                stack.append(']')\n            elif  p == '{':\n                stack.append('}')\n            else:\n                if stack:\n                    if p != stack.pop():\n                        return False\n                else:\n                    return False\n        return len(stack) == 0\n\nyour inline code...``"
                    },
                    {
                        "username": "lechanga",
                        "content": "The description should be updated.\\n\\'([)]\\' is not valid according to the solution.\\nall paired brackets should be next to each other."
                    },
                    {
                        "username": "seraphsword",
                        "content": "It\\'s not that they need to be next to each other, but they do need to follow normal programming order of operations. So <code>[{()([])}()]</code> is valid, but any situation where an open bracket is followed by a closing bracket of a different type isn\\'t going to be, along with closing brackets that have no equivalent opening bracket before it."
                    },
                    {
                        "username": "vishalsunder",
                        "content": "Horrible problem description. Is {(}) valid? The current description doesn\\'t account for it. Leetcode taking easy questions for granted."
                    },
                    {
                        "username": "seraphsword",
                        "content": "The description does say they need to be \"closed in the correct order\". The description takes for granted that you understand how order of operations works, which anyone who\\'s studied algebra or rudimentary programming should be familiar with."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Is the problem solvable without using a stack?"
                    },
                    {
                        "username": "seraphsword",
                        "content": "Yes, but it would probably take more time or space. You could use a switch statement to directly step through the string, with a bunch of conditionals."
                    },
                    {
                        "username": "akhilnerella",
                        "content": "stack<char>A;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'||s[i]==\\'{\\'||s[i]==\\'[\\'){\\n                A.push(s[i]);\\n            }\\n            else if(s[i]==\\')\\' || s[i]==\\'}\\' || s[i]==\\']\\'){\\n                if((s[i]==\\')\\' && A.top()==\\'(\\')||(s[i]==\\']\\' && A.top()==\\'[\\')||(s[i]==\\'}\\' && A.top()==\\'{\\')){\\n                    A.pop();\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(A.size()==0)\\n            return true;\\n        else\\n            return false;\\n    \\nGetting the below error when I submit\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x000000344a8f bp 0x7fff375171d0 sp 0x7fff375170a0 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #3 0x7f1bf9ae20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING"
                    },
                    {
                        "username": "omerkarabulut169",
                        "content": " `var isValid = function(s) {\\n    var ar = [];\\n    if(s.length % 2 == 0){\\n        for(var i = 0;i < s.length; i += 2){\\n        switch(s[i]){\\n           case \"(\":\\n            if(s[i + 1] == \")\"){\\n                ar.push(true);\\n            }else{\\n                ar.push(false);\\n            }\\n            break;\\n           case \"{\":\\n            if(s[i + 1] == \"}\"){\\n                ar.push(true);\\n            }else{\\n                ar.push(false);\\n            } \\n            break;\\n           case \"[\":\\n             if(s[i + 1] == \"]\"){\\n                ar.push(true);\\n            }else{\\n                ar.push(false);\\n            } \\n            break;  \\n        }\\n     }\\n     var res = ar.every((el) => {\\n         return (el == true);\\n     });\\n     return res;\\n    }else{\\n        return false;\\n    }\\n};`That was my 66/92 code the description dont tells [()] is valid or not pleasa uptade description           "
                    },
                    {
                        "username": "dilaras",
                        "content": "\"(])\" is valid, however expected output is \"false\". Test cases should be updated."
                    },
                    {
                        "username": "harshit_singh17",
                        "content": "\"(])\" is not valid as\"]\" doesn\\'t have it opening brackets "
                    },
                    {
                        "username": "ezhil2744",
                        "content": "class Solution {\\n  bool isValid(String s) {\\n      int len = s.length();\\n      int count=0;\\n      for(int i=0; i<len; i++){\\n          char c = s.charAt(i);\\n          if(c==\\'(\\' || c==\\'{\\' || c==\\'[\\'){\\n              count++;\\n          }\\n          else{\\n              count--;\\n          }\\n      }\\n      if(count==0){\\n          return true;\\n      }\\n      else{\\n        return false;\\n      }\\n  }\\n}\\n\\n\\n\\ndoes anyone tell what is the error in this code"
                    },
                    {
                        "username": "Mrbhatt2348",
                        "content": "it will return true for \")(\", as  the count of both \\')\\' and \\'(\\' cancels each other, the count will be zero, but the string is not a valid paranthesis.\\n"
                    }
                ]
            },
            {
                "id": 1794044,
                "content": [
                    {
                        "username": "gvijay370",
                        "content": "class Solution:\\n    def isValid(self, s: str) -> bool:\\n        d1 = [\\'[\\',\\'{\\',\\'(\\']\\n        d2 = [\\']\\',\\'}\\',\\')\\']\\n        l = []\\n        for i in s:\\n            if i in d1:\\n                l.append(i)\\n            else:\\n                if len(l)!=0 and (d1.index(l.pop()) == d2.index(i)):\\n                    pass\\n                else:\\n                    return \\'false\\'\\n        \\n        return \\'true\\'\\n\\ncan someone tell what\\'s the problem in the above code, it is working perfectly fine in other compilers but not on leetcode console."
                    },
                    {
                        "username": "dmigalin",
                        "content": "Hi, Leetcode. I would like to show you the incorrect test for this particular task. Unittest \\u2116 74 stipulates the following values: s = \\u201C({{{{}}}))\\u201D, expected output = False.  I suppose that s[0} + s[-1] = \\u201C()\\u201D and It means that brackets are closed by the same type of brackets and in the correct order. The expected output has to be True, not False. What do you think about it?"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "What do you mean? ({{{{}}})) is 100% false. Lets break down the bracket into multiple bracket pairs from the outer to the inner brackets. () {) {} {} {} You see the second bracket is false because they are 2 different types"
                    },
                    {
                        "username": "mehruddin11",
                        "content": " `your inline code\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        stack =[]\n        p1= 0\n        for i in range(len(s)):\n            p = s[i]\n            if p == '(':\n                stack.append(')')\n            elif p == '[':\n                stack.append(']')\n            elif  p == '{':\n                stack.append('}')\n            else:\n                if stack:\n                    if p != stack.pop():\n                        return False\n                else:\n                    return False\n        return len(stack) == 0\n\nyour inline code...``"
                    },
                    {
                        "username": "lechanga",
                        "content": "The description should be updated.\\n\\'([)]\\' is not valid according to the solution.\\nall paired brackets should be next to each other."
                    },
                    {
                        "username": "seraphsword",
                        "content": "It\\'s not that they need to be next to each other, but they do need to follow normal programming order of operations. So <code>[{()([])}()]</code> is valid, but any situation where an open bracket is followed by a closing bracket of a different type isn\\'t going to be, along with closing brackets that have no equivalent opening bracket before it."
                    },
                    {
                        "username": "vishalsunder",
                        "content": "Horrible problem description. Is {(}) valid? The current description doesn\\'t account for it. Leetcode taking easy questions for granted."
                    },
                    {
                        "username": "seraphsword",
                        "content": "The description does say they need to be \"closed in the correct order\". The description takes for granted that you understand how order of operations works, which anyone who\\'s studied algebra or rudimentary programming should be familiar with."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Is the problem solvable without using a stack?"
                    },
                    {
                        "username": "seraphsword",
                        "content": "Yes, but it would probably take more time or space. You could use a switch statement to directly step through the string, with a bunch of conditionals."
                    },
                    {
                        "username": "akhilnerella",
                        "content": "stack<char>A;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'||s[i]==\\'{\\'||s[i]==\\'[\\'){\\n                A.push(s[i]);\\n            }\\n            else if(s[i]==\\')\\' || s[i]==\\'}\\' || s[i]==\\']\\'){\\n                if((s[i]==\\')\\' && A.top()==\\'(\\')||(s[i]==\\']\\' && A.top()==\\'[\\')||(s[i]==\\'}\\' && A.top()==\\'{\\')){\\n                    A.pop();\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(A.size()==0)\\n            return true;\\n        else\\n            return false;\\n    \\nGetting the below error when I submit\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x000000344a8f bp 0x7fff375171d0 sp 0x7fff375170a0 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #3 0x7f1bf9ae20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING"
                    },
                    {
                        "username": "omerkarabulut169",
                        "content": " `var isValid = function(s) {\\n    var ar = [];\\n    if(s.length % 2 == 0){\\n        for(var i = 0;i < s.length; i += 2){\\n        switch(s[i]){\\n           case \"(\":\\n            if(s[i + 1] == \")\"){\\n                ar.push(true);\\n            }else{\\n                ar.push(false);\\n            }\\n            break;\\n           case \"{\":\\n            if(s[i + 1] == \"}\"){\\n                ar.push(true);\\n            }else{\\n                ar.push(false);\\n            } \\n            break;\\n           case \"[\":\\n             if(s[i + 1] == \"]\"){\\n                ar.push(true);\\n            }else{\\n                ar.push(false);\\n            } \\n            break;  \\n        }\\n     }\\n     var res = ar.every((el) => {\\n         return (el == true);\\n     });\\n     return res;\\n    }else{\\n        return false;\\n    }\\n};`That was my 66/92 code the description dont tells [()] is valid or not pleasa uptade description           "
                    },
                    {
                        "username": "dilaras",
                        "content": "\"(])\" is valid, however expected output is \"false\". Test cases should be updated."
                    },
                    {
                        "username": "harshit_singh17",
                        "content": "\"(])\" is not valid as\"]\" doesn\\'t have it opening brackets "
                    },
                    {
                        "username": "ezhil2744",
                        "content": "class Solution {\\n  bool isValid(String s) {\\n      int len = s.length();\\n      int count=0;\\n      for(int i=0; i<len; i++){\\n          char c = s.charAt(i);\\n          if(c==\\'(\\' || c==\\'{\\' || c==\\'[\\'){\\n              count++;\\n          }\\n          else{\\n              count--;\\n          }\\n      }\\n      if(count==0){\\n          return true;\\n      }\\n      else{\\n        return false;\\n      }\\n  }\\n}\\n\\n\\n\\ndoes anyone tell what is the error in this code"
                    },
                    {
                        "username": "Mrbhatt2348",
                        "content": "it will return true for \")(\", as  the count of both \\')\\' and \\'(\\' cancels each other, the count will be zero, but the string is not a valid paranthesis.\\n"
                    }
                ]
            },
            {
                "id": 1787264,
                "content": [
                    {
                        "username": "gvijay370",
                        "content": "class Solution:\\n    def isValid(self, s: str) -> bool:\\n        d1 = [\\'[\\',\\'{\\',\\'(\\']\\n        d2 = [\\']\\',\\'}\\',\\')\\']\\n        l = []\\n        for i in s:\\n            if i in d1:\\n                l.append(i)\\n            else:\\n                if len(l)!=0 and (d1.index(l.pop()) == d2.index(i)):\\n                    pass\\n                else:\\n                    return \\'false\\'\\n        \\n        return \\'true\\'\\n\\ncan someone tell what\\'s the problem in the above code, it is working perfectly fine in other compilers but not on leetcode console."
                    },
                    {
                        "username": "dmigalin",
                        "content": "Hi, Leetcode. I would like to show you the incorrect test for this particular task. Unittest \\u2116 74 stipulates the following values: s = \\u201C({{{{}}}))\\u201D, expected output = False.  I suppose that s[0} + s[-1] = \\u201C()\\u201D and It means that brackets are closed by the same type of brackets and in the correct order. The expected output has to be True, not False. What do you think about it?"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "What do you mean? ({{{{}}})) is 100% false. Lets break down the bracket into multiple bracket pairs from the outer to the inner brackets. () {) {} {} {} You see the second bracket is false because they are 2 different types"
                    },
                    {
                        "username": "mehruddin11",
                        "content": " `your inline code\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        stack =[]\n        p1= 0\n        for i in range(len(s)):\n            p = s[i]\n            if p == '(':\n                stack.append(')')\n            elif p == '[':\n                stack.append(']')\n            elif  p == '{':\n                stack.append('}')\n            else:\n                if stack:\n                    if p != stack.pop():\n                        return False\n                else:\n                    return False\n        return len(stack) == 0\n\nyour inline code...``"
                    },
                    {
                        "username": "lechanga",
                        "content": "The description should be updated.\\n\\'([)]\\' is not valid according to the solution.\\nall paired brackets should be next to each other."
                    },
                    {
                        "username": "seraphsword",
                        "content": "It\\'s not that they need to be next to each other, but they do need to follow normal programming order of operations. So <code>[{()([])}()]</code> is valid, but any situation where an open bracket is followed by a closing bracket of a different type isn\\'t going to be, along with closing brackets that have no equivalent opening bracket before it."
                    },
                    {
                        "username": "vishalsunder",
                        "content": "Horrible problem description. Is {(}) valid? The current description doesn\\'t account for it. Leetcode taking easy questions for granted."
                    },
                    {
                        "username": "seraphsword",
                        "content": "The description does say they need to be \"closed in the correct order\". The description takes for granted that you understand how order of operations works, which anyone who\\'s studied algebra or rudimentary programming should be familiar with."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Is the problem solvable without using a stack?"
                    },
                    {
                        "username": "seraphsword",
                        "content": "Yes, but it would probably take more time or space. You could use a switch statement to directly step through the string, with a bunch of conditionals."
                    },
                    {
                        "username": "akhilnerella",
                        "content": "stack<char>A;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'||s[i]==\\'{\\'||s[i]==\\'[\\'){\\n                A.push(s[i]);\\n            }\\n            else if(s[i]==\\')\\' || s[i]==\\'}\\' || s[i]==\\']\\'){\\n                if((s[i]==\\')\\' && A.top()==\\'(\\')||(s[i]==\\']\\' && A.top()==\\'[\\')||(s[i]==\\'}\\' && A.top()==\\'{\\')){\\n                    A.pop();\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(A.size()==0)\\n            return true;\\n        else\\n            return false;\\n    \\nGetting the below error when I submit\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x000000344a8f bp 0x7fff375171d0 sp 0x7fff375170a0 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #3 0x7f1bf9ae20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING"
                    },
                    {
                        "username": "omerkarabulut169",
                        "content": " `var isValid = function(s) {\\n    var ar = [];\\n    if(s.length % 2 == 0){\\n        for(var i = 0;i < s.length; i += 2){\\n        switch(s[i]){\\n           case \"(\":\\n            if(s[i + 1] == \")\"){\\n                ar.push(true);\\n            }else{\\n                ar.push(false);\\n            }\\n            break;\\n           case \"{\":\\n            if(s[i + 1] == \"}\"){\\n                ar.push(true);\\n            }else{\\n                ar.push(false);\\n            } \\n            break;\\n           case \"[\":\\n             if(s[i + 1] == \"]\"){\\n                ar.push(true);\\n            }else{\\n                ar.push(false);\\n            } \\n            break;  \\n        }\\n     }\\n     var res = ar.every((el) => {\\n         return (el == true);\\n     });\\n     return res;\\n    }else{\\n        return false;\\n    }\\n};`That was my 66/92 code the description dont tells [()] is valid or not pleasa uptade description           "
                    },
                    {
                        "username": "dilaras",
                        "content": "\"(])\" is valid, however expected output is \"false\". Test cases should be updated."
                    },
                    {
                        "username": "harshit_singh17",
                        "content": "\"(])\" is not valid as\"]\" doesn\\'t have it opening brackets "
                    },
                    {
                        "username": "ezhil2744",
                        "content": "class Solution {\\n  bool isValid(String s) {\\n      int len = s.length();\\n      int count=0;\\n      for(int i=0; i<len; i++){\\n          char c = s.charAt(i);\\n          if(c==\\'(\\' || c==\\'{\\' || c==\\'[\\'){\\n              count++;\\n          }\\n          else{\\n              count--;\\n          }\\n      }\\n      if(count==0){\\n          return true;\\n      }\\n      else{\\n        return false;\\n      }\\n  }\\n}\\n\\n\\n\\ndoes anyone tell what is the error in this code"
                    },
                    {
                        "username": "Mrbhatt2348",
                        "content": "it will return true for \")(\", as  the count of both \\')\\' and \\'(\\' cancels each other, the count will be zero, but the string is not a valid paranthesis.\\n"
                    }
                ]
            },
            {
                "id": 1786574,
                "content": [
                    {
                        "username": "gvijay370",
                        "content": "class Solution:\\n    def isValid(self, s: str) -> bool:\\n        d1 = [\\'[\\',\\'{\\',\\'(\\']\\n        d2 = [\\']\\',\\'}\\',\\')\\']\\n        l = []\\n        for i in s:\\n            if i in d1:\\n                l.append(i)\\n            else:\\n                if len(l)!=0 and (d1.index(l.pop()) == d2.index(i)):\\n                    pass\\n                else:\\n                    return \\'false\\'\\n        \\n        return \\'true\\'\\n\\ncan someone tell what\\'s the problem in the above code, it is working perfectly fine in other compilers but not on leetcode console."
                    },
                    {
                        "username": "dmigalin",
                        "content": "Hi, Leetcode. I would like to show you the incorrect test for this particular task. Unittest \\u2116 74 stipulates the following values: s = \\u201C({{{{}}}))\\u201D, expected output = False.  I suppose that s[0} + s[-1] = \\u201C()\\u201D and It means that brackets are closed by the same type of brackets and in the correct order. The expected output has to be True, not False. What do you think about it?"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "What do you mean? ({{{{}}})) is 100% false. Lets break down the bracket into multiple bracket pairs from the outer to the inner brackets. () {) {} {} {} You see the second bracket is false because they are 2 different types"
                    },
                    {
                        "username": "mehruddin11",
                        "content": " `your inline code\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        stack =[]\n        p1= 0\n        for i in range(len(s)):\n            p = s[i]\n            if p == '(':\n                stack.append(')')\n            elif p == '[':\n                stack.append(']')\n            elif  p == '{':\n                stack.append('}')\n            else:\n                if stack:\n                    if p != stack.pop():\n                        return False\n                else:\n                    return False\n        return len(stack) == 0\n\nyour inline code...``"
                    },
                    {
                        "username": "lechanga",
                        "content": "The description should be updated.\\n\\'([)]\\' is not valid according to the solution.\\nall paired brackets should be next to each other."
                    },
                    {
                        "username": "seraphsword",
                        "content": "It\\'s not that they need to be next to each other, but they do need to follow normal programming order of operations. So <code>[{()([])}()]</code> is valid, but any situation where an open bracket is followed by a closing bracket of a different type isn\\'t going to be, along with closing brackets that have no equivalent opening bracket before it."
                    },
                    {
                        "username": "vishalsunder",
                        "content": "Horrible problem description. Is {(}) valid? The current description doesn\\'t account for it. Leetcode taking easy questions for granted."
                    },
                    {
                        "username": "seraphsword",
                        "content": "The description does say they need to be \"closed in the correct order\". The description takes for granted that you understand how order of operations works, which anyone who\\'s studied algebra or rudimentary programming should be familiar with."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Is the problem solvable without using a stack?"
                    },
                    {
                        "username": "seraphsword",
                        "content": "Yes, but it would probably take more time or space. You could use a switch statement to directly step through the string, with a bunch of conditionals."
                    },
                    {
                        "username": "akhilnerella",
                        "content": "stack<char>A;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'||s[i]==\\'{\\'||s[i]==\\'[\\'){\\n                A.push(s[i]);\\n            }\\n            else if(s[i]==\\')\\' || s[i]==\\'}\\' || s[i]==\\']\\'){\\n                if((s[i]==\\')\\' && A.top()==\\'(\\')||(s[i]==\\']\\' && A.top()==\\'[\\')||(s[i]==\\'}\\' && A.top()==\\'{\\')){\\n                    A.pop();\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(A.size()==0)\\n            return true;\\n        else\\n            return false;\\n    \\nGetting the below error when I submit\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x000000344a8f bp 0x7fff375171d0 sp 0x7fff375170a0 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #3 0x7f1bf9ae20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING"
                    },
                    {
                        "username": "omerkarabulut169",
                        "content": " `var isValid = function(s) {\\n    var ar = [];\\n    if(s.length % 2 == 0){\\n        for(var i = 0;i < s.length; i += 2){\\n        switch(s[i]){\\n           case \"(\":\\n            if(s[i + 1] == \")\"){\\n                ar.push(true);\\n            }else{\\n                ar.push(false);\\n            }\\n            break;\\n           case \"{\":\\n            if(s[i + 1] == \"}\"){\\n                ar.push(true);\\n            }else{\\n                ar.push(false);\\n            } \\n            break;\\n           case \"[\":\\n             if(s[i + 1] == \"]\"){\\n                ar.push(true);\\n            }else{\\n                ar.push(false);\\n            } \\n            break;  \\n        }\\n     }\\n     var res = ar.every((el) => {\\n         return (el == true);\\n     });\\n     return res;\\n    }else{\\n        return false;\\n    }\\n};`That was my 66/92 code the description dont tells [()] is valid or not pleasa uptade description           "
                    },
                    {
                        "username": "dilaras",
                        "content": "\"(])\" is valid, however expected output is \"false\". Test cases should be updated."
                    },
                    {
                        "username": "harshit_singh17",
                        "content": "\"(])\" is not valid as\"]\" doesn\\'t have it opening brackets "
                    },
                    {
                        "username": "ezhil2744",
                        "content": "class Solution {\\n  bool isValid(String s) {\\n      int len = s.length();\\n      int count=0;\\n      for(int i=0; i<len; i++){\\n          char c = s.charAt(i);\\n          if(c==\\'(\\' || c==\\'{\\' || c==\\'[\\'){\\n              count++;\\n          }\\n          else{\\n              count--;\\n          }\\n      }\\n      if(count==0){\\n          return true;\\n      }\\n      else{\\n        return false;\\n      }\\n  }\\n}\\n\\n\\n\\ndoes anyone tell what is the error in this code"
                    },
                    {
                        "username": "Mrbhatt2348",
                        "content": "it will return true for \")(\", as  the count of both \\')\\' and \\'(\\' cancels each other, the count will be zero, but the string is not a valid paranthesis.\\n"
                    }
                ]
            },
            {
                "id": 1786496,
                "content": [
                    {
                        "username": "gvijay370",
                        "content": "class Solution:\\n    def isValid(self, s: str) -> bool:\\n        d1 = [\\'[\\',\\'{\\',\\'(\\']\\n        d2 = [\\']\\',\\'}\\',\\')\\']\\n        l = []\\n        for i in s:\\n            if i in d1:\\n                l.append(i)\\n            else:\\n                if len(l)!=0 and (d1.index(l.pop()) == d2.index(i)):\\n                    pass\\n                else:\\n                    return \\'false\\'\\n        \\n        return \\'true\\'\\n\\ncan someone tell what\\'s the problem in the above code, it is working perfectly fine in other compilers but not on leetcode console."
                    },
                    {
                        "username": "dmigalin",
                        "content": "Hi, Leetcode. I would like to show you the incorrect test for this particular task. Unittest \\u2116 74 stipulates the following values: s = \\u201C({{{{}}}))\\u201D, expected output = False.  I suppose that s[0} + s[-1] = \\u201C()\\u201D and It means that brackets are closed by the same type of brackets and in the correct order. The expected output has to be True, not False. What do you think about it?"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "What do you mean? ({{{{}}})) is 100% false. Lets break down the bracket into multiple bracket pairs from the outer to the inner brackets. () {) {} {} {} You see the second bracket is false because they are 2 different types"
                    },
                    {
                        "username": "mehruddin11",
                        "content": " `your inline code\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        stack =[]\n        p1= 0\n        for i in range(len(s)):\n            p = s[i]\n            if p == '(':\n                stack.append(')')\n            elif p == '[':\n                stack.append(']')\n            elif  p == '{':\n                stack.append('}')\n            else:\n                if stack:\n                    if p != stack.pop():\n                        return False\n                else:\n                    return False\n        return len(stack) == 0\n\nyour inline code...``"
                    },
                    {
                        "username": "lechanga",
                        "content": "The description should be updated.\\n\\'([)]\\' is not valid according to the solution.\\nall paired brackets should be next to each other."
                    },
                    {
                        "username": "seraphsword",
                        "content": "It\\'s not that they need to be next to each other, but they do need to follow normal programming order of operations. So <code>[{()([])}()]</code> is valid, but any situation where an open bracket is followed by a closing bracket of a different type isn\\'t going to be, along with closing brackets that have no equivalent opening bracket before it."
                    },
                    {
                        "username": "vishalsunder",
                        "content": "Horrible problem description. Is {(}) valid? The current description doesn\\'t account for it. Leetcode taking easy questions for granted."
                    },
                    {
                        "username": "seraphsword",
                        "content": "The description does say they need to be \"closed in the correct order\". The description takes for granted that you understand how order of operations works, which anyone who\\'s studied algebra or rudimentary programming should be familiar with."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Is the problem solvable without using a stack?"
                    },
                    {
                        "username": "seraphsword",
                        "content": "Yes, but it would probably take more time or space. You could use a switch statement to directly step through the string, with a bunch of conditionals."
                    },
                    {
                        "username": "akhilnerella",
                        "content": "stack<char>A;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'||s[i]==\\'{\\'||s[i]==\\'[\\'){\\n                A.push(s[i]);\\n            }\\n            else if(s[i]==\\')\\' || s[i]==\\'}\\' || s[i]==\\']\\'){\\n                if((s[i]==\\')\\' && A.top()==\\'(\\')||(s[i]==\\']\\' && A.top()==\\'[\\')||(s[i]==\\'}\\' && A.top()==\\'{\\')){\\n                    A.pop();\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(A.size()==0)\\n            return true;\\n        else\\n            return false;\\n    \\nGetting the below error when I submit\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x000000344a8f bp 0x7fff375171d0 sp 0x7fff375170a0 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #3 0x7f1bf9ae20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING"
                    },
                    {
                        "username": "omerkarabulut169",
                        "content": " `var isValid = function(s) {\\n    var ar = [];\\n    if(s.length % 2 == 0){\\n        for(var i = 0;i < s.length; i += 2){\\n        switch(s[i]){\\n           case \"(\":\\n            if(s[i + 1] == \")\"){\\n                ar.push(true);\\n            }else{\\n                ar.push(false);\\n            }\\n            break;\\n           case \"{\":\\n            if(s[i + 1] == \"}\"){\\n                ar.push(true);\\n            }else{\\n                ar.push(false);\\n            } \\n            break;\\n           case \"[\":\\n             if(s[i + 1] == \"]\"){\\n                ar.push(true);\\n            }else{\\n                ar.push(false);\\n            } \\n            break;  \\n        }\\n     }\\n     var res = ar.every((el) => {\\n         return (el == true);\\n     });\\n     return res;\\n    }else{\\n        return false;\\n    }\\n};`That was my 66/92 code the description dont tells [()] is valid or not pleasa uptade description           "
                    },
                    {
                        "username": "dilaras",
                        "content": "\"(])\" is valid, however expected output is \"false\". Test cases should be updated."
                    },
                    {
                        "username": "harshit_singh17",
                        "content": "\"(])\" is not valid as\"]\" doesn\\'t have it opening brackets "
                    },
                    {
                        "username": "ezhil2744",
                        "content": "class Solution {\\n  bool isValid(String s) {\\n      int len = s.length();\\n      int count=0;\\n      for(int i=0; i<len; i++){\\n          char c = s.charAt(i);\\n          if(c==\\'(\\' || c==\\'{\\' || c==\\'[\\'){\\n              count++;\\n          }\\n          else{\\n              count--;\\n          }\\n      }\\n      if(count==0){\\n          return true;\\n      }\\n      else{\\n        return false;\\n      }\\n  }\\n}\\n\\n\\n\\ndoes anyone tell what is the error in this code"
                    },
                    {
                        "username": "Mrbhatt2348",
                        "content": "it will return true for \")(\", as  the count of both \\')\\' and \\'(\\' cancels each other, the count will be zero, but the string is not a valid paranthesis.\\n"
                    }
                ]
            },
            {
                "id": 1779497,
                "content": [
                    {
                        "username": "gvijay370",
                        "content": "class Solution:\\n    def isValid(self, s: str) -> bool:\\n        d1 = [\\'[\\',\\'{\\',\\'(\\']\\n        d2 = [\\']\\',\\'}\\',\\')\\']\\n        l = []\\n        for i in s:\\n            if i in d1:\\n                l.append(i)\\n            else:\\n                if len(l)!=0 and (d1.index(l.pop()) == d2.index(i)):\\n                    pass\\n                else:\\n                    return \\'false\\'\\n        \\n        return \\'true\\'\\n\\ncan someone tell what\\'s the problem in the above code, it is working perfectly fine in other compilers but not on leetcode console."
                    },
                    {
                        "username": "dmigalin",
                        "content": "Hi, Leetcode. I would like to show you the incorrect test for this particular task. Unittest \\u2116 74 stipulates the following values: s = \\u201C({{{{}}}))\\u201D, expected output = False.  I suppose that s[0} + s[-1] = \\u201C()\\u201D and It means that brackets are closed by the same type of brackets and in the correct order. The expected output has to be True, not False. What do you think about it?"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "What do you mean? ({{{{}}})) is 100% false. Lets break down the bracket into multiple bracket pairs from the outer to the inner brackets. () {) {} {} {} You see the second bracket is false because they are 2 different types"
                    },
                    {
                        "username": "mehruddin11",
                        "content": " `your inline code\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        stack =[]\n        p1= 0\n        for i in range(len(s)):\n            p = s[i]\n            if p == '(':\n                stack.append(')')\n            elif p == '[':\n                stack.append(']')\n            elif  p == '{':\n                stack.append('}')\n            else:\n                if stack:\n                    if p != stack.pop():\n                        return False\n                else:\n                    return False\n        return len(stack) == 0\n\nyour inline code...``"
                    },
                    {
                        "username": "lechanga",
                        "content": "The description should be updated.\\n\\'([)]\\' is not valid according to the solution.\\nall paired brackets should be next to each other."
                    },
                    {
                        "username": "seraphsword",
                        "content": "It\\'s not that they need to be next to each other, but they do need to follow normal programming order of operations. So <code>[{()([])}()]</code> is valid, but any situation where an open bracket is followed by a closing bracket of a different type isn\\'t going to be, along with closing brackets that have no equivalent opening bracket before it."
                    },
                    {
                        "username": "vishalsunder",
                        "content": "Horrible problem description. Is {(}) valid? The current description doesn\\'t account for it. Leetcode taking easy questions for granted."
                    },
                    {
                        "username": "seraphsword",
                        "content": "The description does say they need to be \"closed in the correct order\". The description takes for granted that you understand how order of operations works, which anyone who\\'s studied algebra or rudimentary programming should be familiar with."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Is the problem solvable without using a stack?"
                    },
                    {
                        "username": "seraphsword",
                        "content": "Yes, but it would probably take more time or space. You could use a switch statement to directly step through the string, with a bunch of conditionals."
                    },
                    {
                        "username": "akhilnerella",
                        "content": "stack<char>A;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'||s[i]==\\'{\\'||s[i]==\\'[\\'){\\n                A.push(s[i]);\\n            }\\n            else if(s[i]==\\')\\' || s[i]==\\'}\\' || s[i]==\\']\\'){\\n                if((s[i]==\\')\\' && A.top()==\\'(\\')||(s[i]==\\']\\' && A.top()==\\'[\\')||(s[i]==\\'}\\' && A.top()==\\'{\\')){\\n                    A.pop();\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(A.size()==0)\\n            return true;\\n        else\\n            return false;\\n    \\nGetting the below error when I submit\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x000000344a8f bp 0x7fff375171d0 sp 0x7fff375170a0 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #3 0x7f1bf9ae20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING"
                    },
                    {
                        "username": "omerkarabulut169",
                        "content": " `var isValid = function(s) {\\n    var ar = [];\\n    if(s.length % 2 == 0){\\n        for(var i = 0;i < s.length; i += 2){\\n        switch(s[i]){\\n           case \"(\":\\n            if(s[i + 1] == \")\"){\\n                ar.push(true);\\n            }else{\\n                ar.push(false);\\n            }\\n            break;\\n           case \"{\":\\n            if(s[i + 1] == \"}\"){\\n                ar.push(true);\\n            }else{\\n                ar.push(false);\\n            } \\n            break;\\n           case \"[\":\\n             if(s[i + 1] == \"]\"){\\n                ar.push(true);\\n            }else{\\n                ar.push(false);\\n            } \\n            break;  \\n        }\\n     }\\n     var res = ar.every((el) => {\\n         return (el == true);\\n     });\\n     return res;\\n    }else{\\n        return false;\\n    }\\n};`That was my 66/92 code the description dont tells [()] is valid or not pleasa uptade description           "
                    },
                    {
                        "username": "dilaras",
                        "content": "\"(])\" is valid, however expected output is \"false\". Test cases should be updated."
                    },
                    {
                        "username": "harshit_singh17",
                        "content": "\"(])\" is not valid as\"]\" doesn\\'t have it opening brackets "
                    },
                    {
                        "username": "ezhil2744",
                        "content": "class Solution {\\n  bool isValid(String s) {\\n      int len = s.length();\\n      int count=0;\\n      for(int i=0; i<len; i++){\\n          char c = s.charAt(i);\\n          if(c==\\'(\\' || c==\\'{\\' || c==\\'[\\'){\\n              count++;\\n          }\\n          else{\\n              count--;\\n          }\\n      }\\n      if(count==0){\\n          return true;\\n      }\\n      else{\\n        return false;\\n      }\\n  }\\n}\\n\\n\\n\\ndoes anyone tell what is the error in this code"
                    },
                    {
                        "username": "Mrbhatt2348",
                        "content": "it will return true for \")(\", as  the count of both \\')\\' and \\'(\\' cancels each other, the count will be zero, but the string is not a valid paranthesis.\\n"
                    }
                ]
            },
            {
                "id": 1777752,
                "content": [
                    {
                        "username": "gvijay370",
                        "content": "class Solution:\\n    def isValid(self, s: str) -> bool:\\n        d1 = [\\'[\\',\\'{\\',\\'(\\']\\n        d2 = [\\']\\',\\'}\\',\\')\\']\\n        l = []\\n        for i in s:\\n            if i in d1:\\n                l.append(i)\\n            else:\\n                if len(l)!=0 and (d1.index(l.pop()) == d2.index(i)):\\n                    pass\\n                else:\\n                    return \\'false\\'\\n        \\n        return \\'true\\'\\n\\ncan someone tell what\\'s the problem in the above code, it is working perfectly fine in other compilers but not on leetcode console."
                    },
                    {
                        "username": "dmigalin",
                        "content": "Hi, Leetcode. I would like to show you the incorrect test for this particular task. Unittest \\u2116 74 stipulates the following values: s = \\u201C({{{{}}}))\\u201D, expected output = False.  I suppose that s[0} + s[-1] = \\u201C()\\u201D and It means that brackets are closed by the same type of brackets and in the correct order. The expected output has to be True, not False. What do you think about it?"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "What do you mean? ({{{{}}})) is 100% false. Lets break down the bracket into multiple bracket pairs from the outer to the inner brackets. () {) {} {} {} You see the second bracket is false because they are 2 different types"
                    },
                    {
                        "username": "mehruddin11",
                        "content": " `your inline code\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        stack =[]\n        p1= 0\n        for i in range(len(s)):\n            p = s[i]\n            if p == '(':\n                stack.append(')')\n            elif p == '[':\n                stack.append(']')\n            elif  p == '{':\n                stack.append('}')\n            else:\n                if stack:\n                    if p != stack.pop():\n                        return False\n                else:\n                    return False\n        return len(stack) == 0\n\nyour inline code...``"
                    },
                    {
                        "username": "lechanga",
                        "content": "The description should be updated.\\n\\'([)]\\' is not valid according to the solution.\\nall paired brackets should be next to each other."
                    },
                    {
                        "username": "seraphsword",
                        "content": "It\\'s not that they need to be next to each other, but they do need to follow normal programming order of operations. So <code>[{()([])}()]</code> is valid, but any situation where an open bracket is followed by a closing bracket of a different type isn\\'t going to be, along with closing brackets that have no equivalent opening bracket before it."
                    },
                    {
                        "username": "vishalsunder",
                        "content": "Horrible problem description. Is {(}) valid? The current description doesn\\'t account for it. Leetcode taking easy questions for granted."
                    },
                    {
                        "username": "seraphsword",
                        "content": "The description does say they need to be \"closed in the correct order\". The description takes for granted that you understand how order of operations works, which anyone who\\'s studied algebra or rudimentary programming should be familiar with."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Is the problem solvable without using a stack?"
                    },
                    {
                        "username": "seraphsword",
                        "content": "Yes, but it would probably take more time or space. You could use a switch statement to directly step through the string, with a bunch of conditionals."
                    },
                    {
                        "username": "akhilnerella",
                        "content": "stack<char>A;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'||s[i]==\\'{\\'||s[i]==\\'[\\'){\\n                A.push(s[i]);\\n            }\\n            else if(s[i]==\\')\\' || s[i]==\\'}\\' || s[i]==\\']\\'){\\n                if((s[i]==\\')\\' && A.top()==\\'(\\')||(s[i]==\\']\\' && A.top()==\\'[\\')||(s[i]==\\'}\\' && A.top()==\\'{\\')){\\n                    A.pop();\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(A.size()==0)\\n            return true;\\n        else\\n            return false;\\n    \\nGetting the below error when I submit\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x000000344a8f bp 0x7fff375171d0 sp 0x7fff375170a0 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #3 0x7f1bf9ae20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING"
                    },
                    {
                        "username": "omerkarabulut169",
                        "content": " `var isValid = function(s) {\\n    var ar = [];\\n    if(s.length % 2 == 0){\\n        for(var i = 0;i < s.length; i += 2){\\n        switch(s[i]){\\n           case \"(\":\\n            if(s[i + 1] == \")\"){\\n                ar.push(true);\\n            }else{\\n                ar.push(false);\\n            }\\n            break;\\n           case \"{\":\\n            if(s[i + 1] == \"}\"){\\n                ar.push(true);\\n            }else{\\n                ar.push(false);\\n            } \\n            break;\\n           case \"[\":\\n             if(s[i + 1] == \"]\"){\\n                ar.push(true);\\n            }else{\\n                ar.push(false);\\n            } \\n            break;  \\n        }\\n     }\\n     var res = ar.every((el) => {\\n         return (el == true);\\n     });\\n     return res;\\n    }else{\\n        return false;\\n    }\\n};`That was my 66/92 code the description dont tells [()] is valid or not pleasa uptade description           "
                    },
                    {
                        "username": "dilaras",
                        "content": "\"(])\" is valid, however expected output is \"false\". Test cases should be updated."
                    },
                    {
                        "username": "harshit_singh17",
                        "content": "\"(])\" is not valid as\"]\" doesn\\'t have it opening brackets "
                    },
                    {
                        "username": "ezhil2744",
                        "content": "class Solution {\\n  bool isValid(String s) {\\n      int len = s.length();\\n      int count=0;\\n      for(int i=0; i<len; i++){\\n          char c = s.charAt(i);\\n          if(c==\\'(\\' || c==\\'{\\' || c==\\'[\\'){\\n              count++;\\n          }\\n          else{\\n              count--;\\n          }\\n      }\\n      if(count==0){\\n          return true;\\n      }\\n      else{\\n        return false;\\n      }\\n  }\\n}\\n\\n\\n\\ndoes anyone tell what is the error in this code"
                    },
                    {
                        "username": "Mrbhatt2348",
                        "content": "it will return true for \")(\", as  the count of both \\')\\' and \\'(\\' cancels each other, the count will be zero, but the string is not a valid paranthesis.\\n"
                    }
                ]
            },
            {
                "id": 1775515,
                "content": [
                    {
                        "username": "gvijay370",
                        "content": "class Solution:\\n    def isValid(self, s: str) -> bool:\\n        d1 = [\\'[\\',\\'{\\',\\'(\\']\\n        d2 = [\\']\\',\\'}\\',\\')\\']\\n        l = []\\n        for i in s:\\n            if i in d1:\\n                l.append(i)\\n            else:\\n                if len(l)!=0 and (d1.index(l.pop()) == d2.index(i)):\\n                    pass\\n                else:\\n                    return \\'false\\'\\n        \\n        return \\'true\\'\\n\\ncan someone tell what\\'s the problem in the above code, it is working perfectly fine in other compilers but not on leetcode console."
                    },
                    {
                        "username": "dmigalin",
                        "content": "Hi, Leetcode. I would like to show you the incorrect test for this particular task. Unittest \\u2116 74 stipulates the following values: s = \\u201C({{{{}}}))\\u201D, expected output = False.  I suppose that s[0} + s[-1] = \\u201C()\\u201D and It means that brackets are closed by the same type of brackets and in the correct order. The expected output has to be True, not False. What do you think about it?"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "What do you mean? ({{{{}}})) is 100% false. Lets break down the bracket into multiple bracket pairs from the outer to the inner brackets. () {) {} {} {} You see the second bracket is false because they are 2 different types"
                    },
                    {
                        "username": "mehruddin11",
                        "content": " `your inline code\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        stack =[]\n        p1= 0\n        for i in range(len(s)):\n            p = s[i]\n            if p == '(':\n                stack.append(')')\n            elif p == '[':\n                stack.append(']')\n            elif  p == '{':\n                stack.append('}')\n            else:\n                if stack:\n                    if p != stack.pop():\n                        return False\n                else:\n                    return False\n        return len(stack) == 0\n\nyour inline code...``"
                    },
                    {
                        "username": "lechanga",
                        "content": "The description should be updated.\\n\\'([)]\\' is not valid according to the solution.\\nall paired brackets should be next to each other."
                    },
                    {
                        "username": "seraphsword",
                        "content": "It\\'s not that they need to be next to each other, but they do need to follow normal programming order of operations. So <code>[{()([])}()]</code> is valid, but any situation where an open bracket is followed by a closing bracket of a different type isn\\'t going to be, along with closing brackets that have no equivalent opening bracket before it."
                    },
                    {
                        "username": "vishalsunder",
                        "content": "Horrible problem description. Is {(}) valid? The current description doesn\\'t account for it. Leetcode taking easy questions for granted."
                    },
                    {
                        "username": "seraphsword",
                        "content": "The description does say they need to be \"closed in the correct order\". The description takes for granted that you understand how order of operations works, which anyone who\\'s studied algebra or rudimentary programming should be familiar with."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Is the problem solvable without using a stack?"
                    },
                    {
                        "username": "seraphsword",
                        "content": "Yes, but it would probably take more time or space. You could use a switch statement to directly step through the string, with a bunch of conditionals."
                    },
                    {
                        "username": "akhilnerella",
                        "content": "stack<char>A;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'||s[i]==\\'{\\'||s[i]==\\'[\\'){\\n                A.push(s[i]);\\n            }\\n            else if(s[i]==\\')\\' || s[i]==\\'}\\' || s[i]==\\']\\'){\\n                if((s[i]==\\')\\' && A.top()==\\'(\\')||(s[i]==\\']\\' && A.top()==\\'[\\')||(s[i]==\\'}\\' && A.top()==\\'{\\')){\\n                    A.pop();\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(A.size()==0)\\n            return true;\\n        else\\n            return false;\\n    \\nGetting the below error when I submit\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x000000344a8f bp 0x7fff375171d0 sp 0x7fff375170a0 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #3 0x7f1bf9ae20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING"
                    },
                    {
                        "username": "omerkarabulut169",
                        "content": " `var isValid = function(s) {\\n    var ar = [];\\n    if(s.length % 2 == 0){\\n        for(var i = 0;i < s.length; i += 2){\\n        switch(s[i]){\\n           case \"(\":\\n            if(s[i + 1] == \")\"){\\n                ar.push(true);\\n            }else{\\n                ar.push(false);\\n            }\\n            break;\\n           case \"{\":\\n            if(s[i + 1] == \"}\"){\\n                ar.push(true);\\n            }else{\\n                ar.push(false);\\n            } \\n            break;\\n           case \"[\":\\n             if(s[i + 1] == \"]\"){\\n                ar.push(true);\\n            }else{\\n                ar.push(false);\\n            } \\n            break;  \\n        }\\n     }\\n     var res = ar.every((el) => {\\n         return (el == true);\\n     });\\n     return res;\\n    }else{\\n        return false;\\n    }\\n};`That was my 66/92 code the description dont tells [()] is valid or not pleasa uptade description           "
                    },
                    {
                        "username": "dilaras",
                        "content": "\"(])\" is valid, however expected output is \"false\". Test cases should be updated."
                    },
                    {
                        "username": "harshit_singh17",
                        "content": "\"(])\" is not valid as\"]\" doesn\\'t have it opening brackets "
                    },
                    {
                        "username": "ezhil2744",
                        "content": "class Solution {\\n  bool isValid(String s) {\\n      int len = s.length();\\n      int count=0;\\n      for(int i=0; i<len; i++){\\n          char c = s.charAt(i);\\n          if(c==\\'(\\' || c==\\'{\\' || c==\\'[\\'){\\n              count++;\\n          }\\n          else{\\n              count--;\\n          }\\n      }\\n      if(count==0){\\n          return true;\\n      }\\n      else{\\n        return false;\\n      }\\n  }\\n}\\n\\n\\n\\ndoes anyone tell what is the error in this code"
                    },
                    {
                        "username": "Mrbhatt2348",
                        "content": "it will return true for \")(\", as  the count of both \\')\\' and \\'(\\' cancels each other, the count will be zero, but the string is not a valid paranthesis.\\n"
                    }
                ]
            },
            {
                "id": 1775121,
                "content": [
                    {
                        "username": "gvijay370",
                        "content": "class Solution:\\n    def isValid(self, s: str) -> bool:\\n        d1 = [\\'[\\',\\'{\\',\\'(\\']\\n        d2 = [\\']\\',\\'}\\',\\')\\']\\n        l = []\\n        for i in s:\\n            if i in d1:\\n                l.append(i)\\n            else:\\n                if len(l)!=0 and (d1.index(l.pop()) == d2.index(i)):\\n                    pass\\n                else:\\n                    return \\'false\\'\\n        \\n        return \\'true\\'\\n\\ncan someone tell what\\'s the problem in the above code, it is working perfectly fine in other compilers but not on leetcode console."
                    },
                    {
                        "username": "dmigalin",
                        "content": "Hi, Leetcode. I would like to show you the incorrect test for this particular task. Unittest \\u2116 74 stipulates the following values: s = \\u201C({{{{}}}))\\u201D, expected output = False.  I suppose that s[0} + s[-1] = \\u201C()\\u201D and It means that brackets are closed by the same type of brackets and in the correct order. The expected output has to be True, not False. What do you think about it?"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "What do you mean? ({{{{}}})) is 100% false. Lets break down the bracket into multiple bracket pairs from the outer to the inner brackets. () {) {} {} {} You see the second bracket is false because they are 2 different types"
                    },
                    {
                        "username": "mehruddin11",
                        "content": " `your inline code\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        stack =[]\n        p1= 0\n        for i in range(len(s)):\n            p = s[i]\n            if p == '(':\n                stack.append(')')\n            elif p == '[':\n                stack.append(']')\n            elif  p == '{':\n                stack.append('}')\n            else:\n                if stack:\n                    if p != stack.pop():\n                        return False\n                else:\n                    return False\n        return len(stack) == 0\n\nyour inline code...``"
                    },
                    {
                        "username": "lechanga",
                        "content": "The description should be updated.\\n\\'([)]\\' is not valid according to the solution.\\nall paired brackets should be next to each other."
                    },
                    {
                        "username": "seraphsword",
                        "content": "It\\'s not that they need to be next to each other, but they do need to follow normal programming order of operations. So <code>[{()([])}()]</code> is valid, but any situation where an open bracket is followed by a closing bracket of a different type isn\\'t going to be, along with closing brackets that have no equivalent opening bracket before it."
                    },
                    {
                        "username": "vishalsunder",
                        "content": "Horrible problem description. Is {(}) valid? The current description doesn\\'t account for it. Leetcode taking easy questions for granted."
                    },
                    {
                        "username": "seraphsword",
                        "content": "The description does say they need to be \"closed in the correct order\". The description takes for granted that you understand how order of operations works, which anyone who\\'s studied algebra or rudimentary programming should be familiar with."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Is the problem solvable without using a stack?"
                    },
                    {
                        "username": "seraphsword",
                        "content": "Yes, but it would probably take more time or space. You could use a switch statement to directly step through the string, with a bunch of conditionals."
                    },
                    {
                        "username": "akhilnerella",
                        "content": "stack<char>A;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'||s[i]==\\'{\\'||s[i]==\\'[\\'){\\n                A.push(s[i]);\\n            }\\n            else if(s[i]==\\')\\' || s[i]==\\'}\\' || s[i]==\\']\\'){\\n                if((s[i]==\\')\\' && A.top()==\\'(\\')||(s[i]==\\']\\' && A.top()==\\'[\\')||(s[i]==\\'}\\' && A.top()==\\'{\\')){\\n                    A.pop();\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(A.size()==0)\\n            return true;\\n        else\\n            return false;\\n    \\nGetting the below error when I submit\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x000000344a8f bp 0x7fff375171d0 sp 0x7fff375170a0 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #3 0x7f1bf9ae20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING"
                    },
                    {
                        "username": "omerkarabulut169",
                        "content": " `var isValid = function(s) {\\n    var ar = [];\\n    if(s.length % 2 == 0){\\n        for(var i = 0;i < s.length; i += 2){\\n        switch(s[i]){\\n           case \"(\":\\n            if(s[i + 1] == \")\"){\\n                ar.push(true);\\n            }else{\\n                ar.push(false);\\n            }\\n            break;\\n           case \"{\":\\n            if(s[i + 1] == \"}\"){\\n                ar.push(true);\\n            }else{\\n                ar.push(false);\\n            } \\n            break;\\n           case \"[\":\\n             if(s[i + 1] == \"]\"){\\n                ar.push(true);\\n            }else{\\n                ar.push(false);\\n            } \\n            break;  \\n        }\\n     }\\n     var res = ar.every((el) => {\\n         return (el == true);\\n     });\\n     return res;\\n    }else{\\n        return false;\\n    }\\n};`That was my 66/92 code the description dont tells [()] is valid or not pleasa uptade description           "
                    },
                    {
                        "username": "dilaras",
                        "content": "\"(])\" is valid, however expected output is \"false\". Test cases should be updated."
                    },
                    {
                        "username": "harshit_singh17",
                        "content": "\"(])\" is not valid as\"]\" doesn\\'t have it opening brackets "
                    },
                    {
                        "username": "ezhil2744",
                        "content": "class Solution {\\n  bool isValid(String s) {\\n      int len = s.length();\\n      int count=0;\\n      for(int i=0; i<len; i++){\\n          char c = s.charAt(i);\\n          if(c==\\'(\\' || c==\\'{\\' || c==\\'[\\'){\\n              count++;\\n          }\\n          else{\\n              count--;\\n          }\\n      }\\n      if(count==0){\\n          return true;\\n      }\\n      else{\\n        return false;\\n      }\\n  }\\n}\\n\\n\\n\\ndoes anyone tell what is the error in this code"
                    },
                    {
                        "username": "Mrbhatt2348",
                        "content": "it will return true for \")(\", as  the count of both \\')\\' and \\'(\\' cancels each other, the count will be zero, but the string is not a valid paranthesis.\\n"
                    }
                ]
            },
            {
                "id": 1767204,
                "content": [
                    {
                        "username": "gvijay370",
                        "content": "class Solution:\\n    def isValid(self, s: str) -> bool:\\n        d1 = [\\'[\\',\\'{\\',\\'(\\']\\n        d2 = [\\']\\',\\'}\\',\\')\\']\\n        l = []\\n        for i in s:\\n            if i in d1:\\n                l.append(i)\\n            else:\\n                if len(l)!=0 and (d1.index(l.pop()) == d2.index(i)):\\n                    pass\\n                else:\\n                    return \\'false\\'\\n        \\n        return \\'true\\'\\n\\ncan someone tell what\\'s the problem in the above code, it is working perfectly fine in other compilers but not on leetcode console."
                    },
                    {
                        "username": "dmigalin",
                        "content": "Hi, Leetcode. I would like to show you the incorrect test for this particular task. Unittest \\u2116 74 stipulates the following values: s = \\u201C({{{{}}}))\\u201D, expected output = False.  I suppose that s[0} + s[-1] = \\u201C()\\u201D and It means that brackets are closed by the same type of brackets and in the correct order. The expected output has to be True, not False. What do you think about it?"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "What do you mean? ({{{{}}})) is 100% false. Lets break down the bracket into multiple bracket pairs from the outer to the inner brackets. () {) {} {} {} You see the second bracket is false because they are 2 different types"
                    },
                    {
                        "username": "mehruddin11",
                        "content": " `your inline code\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        stack =[]\n        p1= 0\n        for i in range(len(s)):\n            p = s[i]\n            if p == '(':\n                stack.append(')')\n            elif p == '[':\n                stack.append(']')\n            elif  p == '{':\n                stack.append('}')\n            else:\n                if stack:\n                    if p != stack.pop():\n                        return False\n                else:\n                    return False\n        return len(stack) == 0\n\nyour inline code...``"
                    },
                    {
                        "username": "lechanga",
                        "content": "The description should be updated.\\n\\'([)]\\' is not valid according to the solution.\\nall paired brackets should be next to each other."
                    },
                    {
                        "username": "seraphsword",
                        "content": "It\\'s not that they need to be next to each other, but they do need to follow normal programming order of operations. So <code>[{()([])}()]</code> is valid, but any situation where an open bracket is followed by a closing bracket of a different type isn\\'t going to be, along with closing brackets that have no equivalent opening bracket before it."
                    },
                    {
                        "username": "vishalsunder",
                        "content": "Horrible problem description. Is {(}) valid? The current description doesn\\'t account for it. Leetcode taking easy questions for granted."
                    },
                    {
                        "username": "seraphsword",
                        "content": "The description does say they need to be \"closed in the correct order\". The description takes for granted that you understand how order of operations works, which anyone who\\'s studied algebra or rudimentary programming should be familiar with."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Is the problem solvable without using a stack?"
                    },
                    {
                        "username": "seraphsword",
                        "content": "Yes, but it would probably take more time or space. You could use a switch statement to directly step through the string, with a bunch of conditionals."
                    },
                    {
                        "username": "akhilnerella",
                        "content": "stack<char>A;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'||s[i]==\\'{\\'||s[i]==\\'[\\'){\\n                A.push(s[i]);\\n            }\\n            else if(s[i]==\\')\\' || s[i]==\\'}\\' || s[i]==\\']\\'){\\n                if((s[i]==\\')\\' && A.top()==\\'(\\')||(s[i]==\\']\\' && A.top()==\\'[\\')||(s[i]==\\'}\\' && A.top()==\\'{\\')){\\n                    A.pop();\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(A.size()==0)\\n            return true;\\n        else\\n            return false;\\n    \\nGetting the below error when I submit\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x000000344a8f bp 0x7fff375171d0 sp 0x7fff375170a0 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #3 0x7f1bf9ae20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING"
                    },
                    {
                        "username": "omerkarabulut169",
                        "content": " `var isValid = function(s) {\\n    var ar = [];\\n    if(s.length % 2 == 0){\\n        for(var i = 0;i < s.length; i += 2){\\n        switch(s[i]){\\n           case \"(\":\\n            if(s[i + 1] == \")\"){\\n                ar.push(true);\\n            }else{\\n                ar.push(false);\\n            }\\n            break;\\n           case \"{\":\\n            if(s[i + 1] == \"}\"){\\n                ar.push(true);\\n            }else{\\n                ar.push(false);\\n            } \\n            break;\\n           case \"[\":\\n             if(s[i + 1] == \"]\"){\\n                ar.push(true);\\n            }else{\\n                ar.push(false);\\n            } \\n            break;  \\n        }\\n     }\\n     var res = ar.every((el) => {\\n         return (el == true);\\n     });\\n     return res;\\n    }else{\\n        return false;\\n    }\\n};`That was my 66/92 code the description dont tells [()] is valid or not pleasa uptade description           "
                    },
                    {
                        "username": "dilaras",
                        "content": "\"(])\" is valid, however expected output is \"false\". Test cases should be updated."
                    },
                    {
                        "username": "harshit_singh17",
                        "content": "\"(])\" is not valid as\"]\" doesn\\'t have it opening brackets "
                    },
                    {
                        "username": "ezhil2744",
                        "content": "class Solution {\\n  bool isValid(String s) {\\n      int len = s.length();\\n      int count=0;\\n      for(int i=0; i<len; i++){\\n          char c = s.charAt(i);\\n          if(c==\\'(\\' || c==\\'{\\' || c==\\'[\\'){\\n              count++;\\n          }\\n          else{\\n              count--;\\n          }\\n      }\\n      if(count==0){\\n          return true;\\n      }\\n      else{\\n        return false;\\n      }\\n  }\\n}\\n\\n\\n\\ndoes anyone tell what is the error in this code"
                    },
                    {
                        "username": "Mrbhatt2348",
                        "content": "it will return true for \")(\", as  the count of both \\')\\' and \\'(\\' cancels each other, the count will be zero, but the string is not a valid paranthesis.\\n"
                    }
                ]
            },
            {
                "id": 1766346,
                "content": [
                    {
                        "username": "zv_proger",
                        "content": "#Give adequate test cases!\nMy solution with O(N^3) have acc status and worked for 57 ms"
                    },
                    {
                        "username": "pottee",
                        "content": "It shouldn't be easy level , even try with stack but there are additional few more edge cases to handle.\notherwise will failed the test case. not only stack with push and pop ... but need to review results and edge cases.\n\nwhen like ([[[]]}) , ([] , [()]{ "
                    },
                    {
                        "username": "ssinha17",
                        "content": "s =\"{[]}\" why this testcase  is showing wrong output (false), my code is working fine in other complier ."
                    },
                    {
                        "username": "SlaverPy",
                        "content": "I also suffered until I went into the comments and saw the keyword: \"word\": stack"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/zF0khZ51jxg"
                    },
                    {
                        "username": "JeremiahGriffin",
                        "content": "This question makes no mention that nested brackets are a possibility as \"Open brackets must be closed in the correct order \" is  ambigious in such a case. It also makes appropriate two different strategies for parsing; the stack based solution suggested in hints is extremely suboptimal for nested strings as it could result in catastrophic backtracing, suggesting that this unmentioned case would indeed not be tested for."
                    },
                    {
                        "username": "Likhith_Kumar_S",
                        "content": "For this problem using for / while loop and pure conditionals is an important part, but how we can use these concepts to solve this problem, here lies the true presentation of solving capability."
                    },
                    {
                        "username": "CyberRedPanda",
                        "content": "Wasted more time on the wrong approach to this problem than any other on LeetCode. Don\\'t try to iterate recursively. Think about how to \"simplify\" the input from the inside out."
                    },
                    {
                        "username": "DenisUstinov",
                        "content": "\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u043E \\u0441\\u0444\\u043E\\u0440\\u043C\\u0443\\u043B\\u0438\\u0440\\u043E\\u0432\\u0430\\u043D\\u043D\\u043E\\u0435 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435, \\u0438 \\u0443\\u0442\\u043E\\u0447\\u043D\\u044F\\u044E\\u0449\\u0438\\u0435 \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B! \\u0414\\u043B\\u044F \\u044D\\u0442\\u0438\\u0445 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0445 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0445 \\u043D\\u0435\\u0442 \\u043D\\u0435\\u043E\\u0431\\u0445\\u043E\\u0434\\u0438\\u043C\\u043E\\u0441\\u0442\\u0438 \\u0432 \\u0441\\u0442\\u0435\\u043A\\u0435! \\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        tmp = None\\n        l = {\\n            \"(\": \")\",\\n            \"{\": \"}\",\\n            \"[\": \"]\"\\n        }\\n\\n        for c in s:\\n            if tmp is None and c in l:\\n                tmp = c\\n            elif c == l[tmp]:\\n                tmp = None\\n            else:\\n                return False\\n        return True"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-parentheses-leet-code-20/"
                    }
                ]
            },
            {
                "id": 1764859,
                "content": [
                    {
                        "username": "zv_proger",
                        "content": "#Give adequate test cases!\nMy solution with O(N^3) have acc status and worked for 57 ms"
                    },
                    {
                        "username": "pottee",
                        "content": "It shouldn't be easy level , even try with stack but there are additional few more edge cases to handle.\notherwise will failed the test case. not only stack with push and pop ... but need to review results and edge cases.\n\nwhen like ([[[]]}) , ([] , [()]{ "
                    },
                    {
                        "username": "ssinha17",
                        "content": "s =\"{[]}\" why this testcase  is showing wrong output (false), my code is working fine in other complier ."
                    },
                    {
                        "username": "SlaverPy",
                        "content": "I also suffered until I went into the comments and saw the keyword: \"word\": stack"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/zF0khZ51jxg"
                    },
                    {
                        "username": "JeremiahGriffin",
                        "content": "This question makes no mention that nested brackets are a possibility as \"Open brackets must be closed in the correct order \" is  ambigious in such a case. It also makes appropriate two different strategies for parsing; the stack based solution suggested in hints is extremely suboptimal for nested strings as it could result in catastrophic backtracing, suggesting that this unmentioned case would indeed not be tested for."
                    },
                    {
                        "username": "Likhith_Kumar_S",
                        "content": "For this problem using for / while loop and pure conditionals is an important part, but how we can use these concepts to solve this problem, here lies the true presentation of solving capability."
                    },
                    {
                        "username": "CyberRedPanda",
                        "content": "Wasted more time on the wrong approach to this problem than any other on LeetCode. Don\\'t try to iterate recursively. Think about how to \"simplify\" the input from the inside out."
                    },
                    {
                        "username": "DenisUstinov",
                        "content": "\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u043E \\u0441\\u0444\\u043E\\u0440\\u043C\\u0443\\u043B\\u0438\\u0440\\u043E\\u0432\\u0430\\u043D\\u043D\\u043E\\u0435 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435, \\u0438 \\u0443\\u0442\\u043E\\u0447\\u043D\\u044F\\u044E\\u0449\\u0438\\u0435 \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B! \\u0414\\u043B\\u044F \\u044D\\u0442\\u0438\\u0445 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0445 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0445 \\u043D\\u0435\\u0442 \\u043D\\u0435\\u043E\\u0431\\u0445\\u043E\\u0434\\u0438\\u043C\\u043E\\u0441\\u0442\\u0438 \\u0432 \\u0441\\u0442\\u0435\\u043A\\u0435! \\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        tmp = None\\n        l = {\\n            \"(\": \")\",\\n            \"{\": \"}\",\\n            \"[\": \"]\"\\n        }\\n\\n        for c in s:\\n            if tmp is None and c in l:\\n                tmp = c\\n            elif c == l[tmp]:\\n                tmp = None\\n            else:\\n                return False\\n        return True"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-parentheses-leet-code-20/"
                    }
                ]
            },
            {
                "id": 1763724,
                "content": [
                    {
                        "username": "zv_proger",
                        "content": "#Give adequate test cases!\nMy solution with O(N^3) have acc status and worked for 57 ms"
                    },
                    {
                        "username": "pottee",
                        "content": "It shouldn't be easy level , even try with stack but there are additional few more edge cases to handle.\notherwise will failed the test case. not only stack with push and pop ... but need to review results and edge cases.\n\nwhen like ([[[]]}) , ([] , [()]{ "
                    },
                    {
                        "username": "ssinha17",
                        "content": "s =\"{[]}\" why this testcase  is showing wrong output (false), my code is working fine in other complier ."
                    },
                    {
                        "username": "SlaverPy",
                        "content": "I also suffered until I went into the comments and saw the keyword: \"word\": stack"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/zF0khZ51jxg"
                    },
                    {
                        "username": "JeremiahGriffin",
                        "content": "This question makes no mention that nested brackets are a possibility as \"Open brackets must be closed in the correct order \" is  ambigious in such a case. It also makes appropriate two different strategies for parsing; the stack based solution suggested in hints is extremely suboptimal for nested strings as it could result in catastrophic backtracing, suggesting that this unmentioned case would indeed not be tested for."
                    },
                    {
                        "username": "Likhith_Kumar_S",
                        "content": "For this problem using for / while loop and pure conditionals is an important part, but how we can use these concepts to solve this problem, here lies the true presentation of solving capability."
                    },
                    {
                        "username": "CyberRedPanda",
                        "content": "Wasted more time on the wrong approach to this problem than any other on LeetCode. Don\\'t try to iterate recursively. Think about how to \"simplify\" the input from the inside out."
                    },
                    {
                        "username": "DenisUstinov",
                        "content": "\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u043E \\u0441\\u0444\\u043E\\u0440\\u043C\\u0443\\u043B\\u0438\\u0440\\u043E\\u0432\\u0430\\u043D\\u043D\\u043E\\u0435 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435, \\u0438 \\u0443\\u0442\\u043E\\u0447\\u043D\\u044F\\u044E\\u0449\\u0438\\u0435 \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B! \\u0414\\u043B\\u044F \\u044D\\u0442\\u0438\\u0445 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0445 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0445 \\u043D\\u0435\\u0442 \\u043D\\u0435\\u043E\\u0431\\u0445\\u043E\\u0434\\u0438\\u043C\\u043E\\u0441\\u0442\\u0438 \\u0432 \\u0441\\u0442\\u0435\\u043A\\u0435! \\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        tmp = None\\n        l = {\\n            \"(\": \")\",\\n            \"{\": \"}\",\\n            \"[\": \"]\"\\n        }\\n\\n        for c in s:\\n            if tmp is None and c in l:\\n                tmp = c\\n            elif c == l[tmp]:\\n                tmp = None\\n            else:\\n                return False\\n        return True"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-parentheses-leet-code-20/"
                    }
                ]
            },
            {
                "id": 1763274,
                "content": [
                    {
                        "username": "zv_proger",
                        "content": "#Give adequate test cases!\nMy solution with O(N^3) have acc status and worked for 57 ms"
                    },
                    {
                        "username": "pottee",
                        "content": "It shouldn't be easy level , even try with stack but there are additional few more edge cases to handle.\notherwise will failed the test case. not only stack with push and pop ... but need to review results and edge cases.\n\nwhen like ([[[]]}) , ([] , [()]{ "
                    },
                    {
                        "username": "ssinha17",
                        "content": "s =\"{[]}\" why this testcase  is showing wrong output (false), my code is working fine in other complier ."
                    },
                    {
                        "username": "SlaverPy",
                        "content": "I also suffered until I went into the comments and saw the keyword: \"word\": stack"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/zF0khZ51jxg"
                    },
                    {
                        "username": "JeremiahGriffin",
                        "content": "This question makes no mention that nested brackets are a possibility as \"Open brackets must be closed in the correct order \" is  ambigious in such a case. It also makes appropriate two different strategies for parsing; the stack based solution suggested in hints is extremely suboptimal for nested strings as it could result in catastrophic backtracing, suggesting that this unmentioned case would indeed not be tested for."
                    },
                    {
                        "username": "Likhith_Kumar_S",
                        "content": "For this problem using for / while loop and pure conditionals is an important part, but how we can use these concepts to solve this problem, here lies the true presentation of solving capability."
                    },
                    {
                        "username": "CyberRedPanda",
                        "content": "Wasted more time on the wrong approach to this problem than any other on LeetCode. Don\\'t try to iterate recursively. Think about how to \"simplify\" the input from the inside out."
                    },
                    {
                        "username": "DenisUstinov",
                        "content": "\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u043E \\u0441\\u0444\\u043E\\u0440\\u043C\\u0443\\u043B\\u0438\\u0440\\u043E\\u0432\\u0430\\u043D\\u043D\\u043E\\u0435 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435, \\u0438 \\u0443\\u0442\\u043E\\u0447\\u043D\\u044F\\u044E\\u0449\\u0438\\u0435 \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B! \\u0414\\u043B\\u044F \\u044D\\u0442\\u0438\\u0445 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0445 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0445 \\u043D\\u0435\\u0442 \\u043D\\u0435\\u043E\\u0431\\u0445\\u043E\\u0434\\u0438\\u043C\\u043E\\u0441\\u0442\\u0438 \\u0432 \\u0441\\u0442\\u0435\\u043A\\u0435! \\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        tmp = None\\n        l = {\\n            \"(\": \")\",\\n            \"{\": \"}\",\\n            \"[\": \"]\"\\n        }\\n\\n        for c in s:\\n            if tmp is None and c in l:\\n                tmp = c\\n            elif c == l[tmp]:\\n                tmp = None\\n            else:\\n                return False\\n        return True"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-parentheses-leet-code-20/"
                    }
                ]
            },
            {
                "id": 1762693,
                "content": [
                    {
                        "username": "zv_proger",
                        "content": "#Give adequate test cases!\nMy solution with O(N^3) have acc status and worked for 57 ms"
                    },
                    {
                        "username": "pottee",
                        "content": "It shouldn't be easy level , even try with stack but there are additional few more edge cases to handle.\notherwise will failed the test case. not only stack with push and pop ... but need to review results and edge cases.\n\nwhen like ([[[]]}) , ([] , [()]{ "
                    },
                    {
                        "username": "ssinha17",
                        "content": "s =\"{[]}\" why this testcase  is showing wrong output (false), my code is working fine in other complier ."
                    },
                    {
                        "username": "SlaverPy",
                        "content": "I also suffered until I went into the comments and saw the keyword: \"word\": stack"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/zF0khZ51jxg"
                    },
                    {
                        "username": "JeremiahGriffin",
                        "content": "This question makes no mention that nested brackets are a possibility as \"Open brackets must be closed in the correct order \" is  ambigious in such a case. It also makes appropriate two different strategies for parsing; the stack based solution suggested in hints is extremely suboptimal for nested strings as it could result in catastrophic backtracing, suggesting that this unmentioned case would indeed not be tested for."
                    },
                    {
                        "username": "Likhith_Kumar_S",
                        "content": "For this problem using for / while loop and pure conditionals is an important part, but how we can use these concepts to solve this problem, here lies the true presentation of solving capability."
                    },
                    {
                        "username": "CyberRedPanda",
                        "content": "Wasted more time on the wrong approach to this problem than any other on LeetCode. Don\\'t try to iterate recursively. Think about how to \"simplify\" the input from the inside out."
                    },
                    {
                        "username": "DenisUstinov",
                        "content": "\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u043E \\u0441\\u0444\\u043E\\u0440\\u043C\\u0443\\u043B\\u0438\\u0440\\u043E\\u0432\\u0430\\u043D\\u043D\\u043E\\u0435 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435, \\u0438 \\u0443\\u0442\\u043E\\u0447\\u043D\\u044F\\u044E\\u0449\\u0438\\u0435 \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B! \\u0414\\u043B\\u044F \\u044D\\u0442\\u0438\\u0445 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0445 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0445 \\u043D\\u0435\\u0442 \\u043D\\u0435\\u043E\\u0431\\u0445\\u043E\\u0434\\u0438\\u043C\\u043E\\u0441\\u0442\\u0438 \\u0432 \\u0441\\u0442\\u0435\\u043A\\u0435! \\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        tmp = None\\n        l = {\\n            \"(\": \")\",\\n            \"{\": \"}\",\\n            \"[\": \"]\"\\n        }\\n\\n        for c in s:\\n            if tmp is None and c in l:\\n                tmp = c\\n            elif c == l[tmp]:\\n                tmp = None\\n            else:\\n                return False\\n        return True"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-parentheses-leet-code-20/"
                    }
                ]
            },
            {
                "id": 1761587,
                "content": [
                    {
                        "username": "zv_proger",
                        "content": "#Give adequate test cases!\nMy solution with O(N^3) have acc status and worked for 57 ms"
                    },
                    {
                        "username": "pottee",
                        "content": "It shouldn't be easy level , even try with stack but there are additional few more edge cases to handle.\notherwise will failed the test case. not only stack with push and pop ... but need to review results and edge cases.\n\nwhen like ([[[]]}) , ([] , [()]{ "
                    },
                    {
                        "username": "ssinha17",
                        "content": "s =\"{[]}\" why this testcase  is showing wrong output (false), my code is working fine in other complier ."
                    },
                    {
                        "username": "SlaverPy",
                        "content": "I also suffered until I went into the comments and saw the keyword: \"word\": stack"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/zF0khZ51jxg"
                    },
                    {
                        "username": "JeremiahGriffin",
                        "content": "This question makes no mention that nested brackets are a possibility as \"Open brackets must be closed in the correct order \" is  ambigious in such a case. It also makes appropriate two different strategies for parsing; the stack based solution suggested in hints is extremely suboptimal for nested strings as it could result in catastrophic backtracing, suggesting that this unmentioned case would indeed not be tested for."
                    },
                    {
                        "username": "Likhith_Kumar_S",
                        "content": "For this problem using for / while loop and pure conditionals is an important part, but how we can use these concepts to solve this problem, here lies the true presentation of solving capability."
                    },
                    {
                        "username": "CyberRedPanda",
                        "content": "Wasted more time on the wrong approach to this problem than any other on LeetCode. Don\\'t try to iterate recursively. Think about how to \"simplify\" the input from the inside out."
                    },
                    {
                        "username": "DenisUstinov",
                        "content": "\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u043E \\u0441\\u0444\\u043E\\u0440\\u043C\\u0443\\u043B\\u0438\\u0440\\u043E\\u0432\\u0430\\u043D\\u043D\\u043E\\u0435 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435, \\u0438 \\u0443\\u0442\\u043E\\u0447\\u043D\\u044F\\u044E\\u0449\\u0438\\u0435 \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B! \\u0414\\u043B\\u044F \\u044D\\u0442\\u0438\\u0445 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0445 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0445 \\u043D\\u0435\\u0442 \\u043D\\u0435\\u043E\\u0431\\u0445\\u043E\\u0434\\u0438\\u043C\\u043E\\u0441\\u0442\\u0438 \\u0432 \\u0441\\u0442\\u0435\\u043A\\u0435! \\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        tmp = None\\n        l = {\\n            \"(\": \")\",\\n            \"{\": \"}\",\\n            \"[\": \"]\"\\n        }\\n\\n        for c in s:\\n            if tmp is None and c in l:\\n                tmp = c\\n            elif c == l[tmp]:\\n                tmp = None\\n            else:\\n                return False\\n        return True"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-parentheses-leet-code-20/"
                    }
                ]
            },
            {
                "id": 1761468,
                "content": [
                    {
                        "username": "zv_proger",
                        "content": "#Give adequate test cases!\nMy solution with O(N^3) have acc status and worked for 57 ms"
                    },
                    {
                        "username": "pottee",
                        "content": "It shouldn't be easy level , even try with stack but there are additional few more edge cases to handle.\notherwise will failed the test case. not only stack with push and pop ... but need to review results and edge cases.\n\nwhen like ([[[]]}) , ([] , [()]{ "
                    },
                    {
                        "username": "ssinha17",
                        "content": "s =\"{[]}\" why this testcase  is showing wrong output (false), my code is working fine in other complier ."
                    },
                    {
                        "username": "SlaverPy",
                        "content": "I also suffered until I went into the comments and saw the keyword: \"word\": stack"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/zF0khZ51jxg"
                    },
                    {
                        "username": "JeremiahGriffin",
                        "content": "This question makes no mention that nested brackets are a possibility as \"Open brackets must be closed in the correct order \" is  ambigious in such a case. It also makes appropriate two different strategies for parsing; the stack based solution suggested in hints is extremely suboptimal for nested strings as it could result in catastrophic backtracing, suggesting that this unmentioned case would indeed not be tested for."
                    },
                    {
                        "username": "Likhith_Kumar_S",
                        "content": "For this problem using for / while loop and pure conditionals is an important part, but how we can use these concepts to solve this problem, here lies the true presentation of solving capability."
                    },
                    {
                        "username": "CyberRedPanda",
                        "content": "Wasted more time on the wrong approach to this problem than any other on LeetCode. Don\\'t try to iterate recursively. Think about how to \"simplify\" the input from the inside out."
                    },
                    {
                        "username": "DenisUstinov",
                        "content": "\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u043E \\u0441\\u0444\\u043E\\u0440\\u043C\\u0443\\u043B\\u0438\\u0440\\u043E\\u0432\\u0430\\u043D\\u043D\\u043E\\u0435 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435, \\u0438 \\u0443\\u0442\\u043E\\u0447\\u043D\\u044F\\u044E\\u0449\\u0438\\u0435 \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B! \\u0414\\u043B\\u044F \\u044D\\u0442\\u0438\\u0445 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0445 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0445 \\u043D\\u0435\\u0442 \\u043D\\u0435\\u043E\\u0431\\u0445\\u043E\\u0434\\u0438\\u043C\\u043E\\u0441\\u0442\\u0438 \\u0432 \\u0441\\u0442\\u0435\\u043A\\u0435! \\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        tmp = None\\n        l = {\\n            \"(\": \")\",\\n            \"{\": \"}\",\\n            \"[\": \"]\"\\n        }\\n\\n        for c in s:\\n            if tmp is None and c in l:\\n                tmp = c\\n            elif c == l[tmp]:\\n                tmp = None\\n            else:\\n                return False\\n        return True"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-parentheses-leet-code-20/"
                    }
                ]
            },
            {
                "id": 1761049,
                "content": [
                    {
                        "username": "zv_proger",
                        "content": "#Give adequate test cases!\nMy solution with O(N^3) have acc status and worked for 57 ms"
                    },
                    {
                        "username": "pottee",
                        "content": "It shouldn't be easy level , even try with stack but there are additional few more edge cases to handle.\notherwise will failed the test case. not only stack with push and pop ... but need to review results and edge cases.\n\nwhen like ([[[]]}) , ([] , [()]{ "
                    },
                    {
                        "username": "ssinha17",
                        "content": "s =\"{[]}\" why this testcase  is showing wrong output (false), my code is working fine in other complier ."
                    },
                    {
                        "username": "SlaverPy",
                        "content": "I also suffered until I went into the comments and saw the keyword: \"word\": stack"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/zF0khZ51jxg"
                    },
                    {
                        "username": "JeremiahGriffin",
                        "content": "This question makes no mention that nested brackets are a possibility as \"Open brackets must be closed in the correct order \" is  ambigious in such a case. It also makes appropriate two different strategies for parsing; the stack based solution suggested in hints is extremely suboptimal for nested strings as it could result in catastrophic backtracing, suggesting that this unmentioned case would indeed not be tested for."
                    },
                    {
                        "username": "Likhith_Kumar_S",
                        "content": "For this problem using for / while loop and pure conditionals is an important part, but how we can use these concepts to solve this problem, here lies the true presentation of solving capability."
                    },
                    {
                        "username": "CyberRedPanda",
                        "content": "Wasted more time on the wrong approach to this problem than any other on LeetCode. Don\\'t try to iterate recursively. Think about how to \"simplify\" the input from the inside out."
                    },
                    {
                        "username": "DenisUstinov",
                        "content": "\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u043E \\u0441\\u0444\\u043E\\u0440\\u043C\\u0443\\u043B\\u0438\\u0440\\u043E\\u0432\\u0430\\u043D\\u043D\\u043E\\u0435 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435, \\u0438 \\u0443\\u0442\\u043E\\u0447\\u043D\\u044F\\u044E\\u0449\\u0438\\u0435 \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B! \\u0414\\u043B\\u044F \\u044D\\u0442\\u0438\\u0445 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0445 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0445 \\u043D\\u0435\\u0442 \\u043D\\u0435\\u043E\\u0431\\u0445\\u043E\\u0434\\u0438\\u043C\\u043E\\u0441\\u0442\\u0438 \\u0432 \\u0441\\u0442\\u0435\\u043A\\u0435! \\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        tmp = None\\n        l = {\\n            \"(\": \")\",\\n            \"{\": \"}\",\\n            \"[\": \"]\"\\n        }\\n\\n        for c in s:\\n            if tmp is None and c in l:\\n                tmp = c\\n            elif c == l[tmp]:\\n                tmp = None\\n            else:\\n                return False\\n        return True"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-parentheses-leet-code-20/"
                    }
                ]
            },
            {
                "id": 1759788,
                "content": [
                    {
                        "username": "zv_proger",
                        "content": "#Give adequate test cases!\nMy solution with O(N^3) have acc status and worked for 57 ms"
                    },
                    {
                        "username": "pottee",
                        "content": "It shouldn't be easy level , even try with stack but there are additional few more edge cases to handle.\notherwise will failed the test case. not only stack with push and pop ... but need to review results and edge cases.\n\nwhen like ([[[]]}) , ([] , [()]{ "
                    },
                    {
                        "username": "ssinha17",
                        "content": "s =\"{[]}\" why this testcase  is showing wrong output (false), my code is working fine in other complier ."
                    },
                    {
                        "username": "SlaverPy",
                        "content": "I also suffered until I went into the comments and saw the keyword: \"word\": stack"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/zF0khZ51jxg"
                    },
                    {
                        "username": "JeremiahGriffin",
                        "content": "This question makes no mention that nested brackets are a possibility as \"Open brackets must be closed in the correct order \" is  ambigious in such a case. It also makes appropriate two different strategies for parsing; the stack based solution suggested in hints is extremely suboptimal for nested strings as it could result in catastrophic backtracing, suggesting that this unmentioned case would indeed not be tested for."
                    },
                    {
                        "username": "Likhith_Kumar_S",
                        "content": "For this problem using for / while loop and pure conditionals is an important part, but how we can use these concepts to solve this problem, here lies the true presentation of solving capability."
                    },
                    {
                        "username": "CyberRedPanda",
                        "content": "Wasted more time on the wrong approach to this problem than any other on LeetCode. Don\\'t try to iterate recursively. Think about how to \"simplify\" the input from the inside out."
                    },
                    {
                        "username": "DenisUstinov",
                        "content": "\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u043E \\u0441\\u0444\\u043E\\u0440\\u043C\\u0443\\u043B\\u0438\\u0440\\u043E\\u0432\\u0430\\u043D\\u043D\\u043E\\u0435 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435, \\u0438 \\u0443\\u0442\\u043E\\u0447\\u043D\\u044F\\u044E\\u0449\\u0438\\u0435 \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B! \\u0414\\u043B\\u044F \\u044D\\u0442\\u0438\\u0445 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0445 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0445 \\u043D\\u0435\\u0442 \\u043D\\u0435\\u043E\\u0431\\u0445\\u043E\\u0434\\u0438\\u043C\\u043E\\u0441\\u0442\\u0438 \\u0432 \\u0441\\u0442\\u0435\\u043A\\u0435! \\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        tmp = None\\n        l = {\\n            \"(\": \")\",\\n            \"{\": \"}\",\\n            \"[\": \"]\"\\n        }\\n\\n        for c in s:\\n            if tmp is None and c in l:\\n                tmp = c\\n            elif c == l[tmp]:\\n                tmp = None\\n            else:\\n                return False\\n        return True"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-parentheses-leet-code-20/"
                    }
                ]
            },
            {
                "id": 1757015,
                "content": [
                    {
                        "username": "zv_proger",
                        "content": "#Give adequate test cases!\nMy solution with O(N^3) have acc status and worked for 57 ms"
                    },
                    {
                        "username": "pottee",
                        "content": "It shouldn't be easy level , even try with stack but there are additional few more edge cases to handle.\notherwise will failed the test case. not only stack with push and pop ... but need to review results and edge cases.\n\nwhen like ([[[]]}) , ([] , [()]{ "
                    },
                    {
                        "username": "ssinha17",
                        "content": "s =\"{[]}\" why this testcase  is showing wrong output (false), my code is working fine in other complier ."
                    },
                    {
                        "username": "SlaverPy",
                        "content": "I also suffered until I went into the comments and saw the keyword: \"word\": stack"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/zF0khZ51jxg"
                    },
                    {
                        "username": "JeremiahGriffin",
                        "content": "This question makes no mention that nested brackets are a possibility as \"Open brackets must be closed in the correct order \" is  ambigious in such a case. It also makes appropriate two different strategies for parsing; the stack based solution suggested in hints is extremely suboptimal for nested strings as it could result in catastrophic backtracing, suggesting that this unmentioned case would indeed not be tested for."
                    },
                    {
                        "username": "Likhith_Kumar_S",
                        "content": "For this problem using for / while loop and pure conditionals is an important part, but how we can use these concepts to solve this problem, here lies the true presentation of solving capability."
                    },
                    {
                        "username": "CyberRedPanda",
                        "content": "Wasted more time on the wrong approach to this problem than any other on LeetCode. Don\\'t try to iterate recursively. Think about how to \"simplify\" the input from the inside out."
                    },
                    {
                        "username": "DenisUstinov",
                        "content": "\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u043E \\u0441\\u0444\\u043E\\u0440\\u043C\\u0443\\u043B\\u0438\\u0440\\u043E\\u0432\\u0430\\u043D\\u043D\\u043E\\u0435 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435, \\u0438 \\u0443\\u0442\\u043E\\u0447\\u043D\\u044F\\u044E\\u0449\\u0438\\u0435 \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B! \\u0414\\u043B\\u044F \\u044D\\u0442\\u0438\\u0445 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0445 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0445 \\u043D\\u0435\\u0442 \\u043D\\u0435\\u043E\\u0431\\u0445\\u043E\\u0434\\u0438\\u043C\\u043E\\u0441\\u0442\\u0438 \\u0432 \\u0441\\u0442\\u0435\\u043A\\u0435! \\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        tmp = None\\n        l = {\\n            \"(\": \")\",\\n            \"{\": \"}\",\\n            \"[\": \"]\"\\n        }\\n\\n        for c in s:\\n            if tmp is None and c in l:\\n                tmp = c\\n            elif c == l[tmp]:\\n                tmp = None\\n            else:\\n                return False\\n        return True"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-parentheses-leet-code-20/"
                    }
                ]
            },
            {
                "id": 1754662,
                "content": [
                    {
                        "username": "fbwipo",
                        "content": "this will teach you good usage of stack data structure."
                    },
                    {
                        "username": "programmer3001",
                        "content": "`class Solution(object):\n    def isValid(self, s):\n        if s.count('(') == s.count(')') and s.count('[') == s.count(']') and s.count('{') == s.count('}'):\n            return True\n        else:\n            return False`\n\ninput\ns =\n\"([)]\"\nOutput\ntrue\nExpected\nfalse\n\nwhat's wrong lol"
                    },
                    {
                        "username": "omjain",
                        "content": "bro just assume the parentheses hierarchy we do while coding. \\nFor this case it should be `([])`"
                    },
                    {
                        "username": "uvinayak7",
                        "content": " `class Solution {\\npublic:\\n    // Function to check if a string of brackets is valid\\n    bool isValid(string s) {\\n        // Create a stack to store the brackets\\n        stack<char> st;\\n\\n        // Iterate through each character in the string\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s[i];\\n\\n            // If the character is an opening bracket, push it onto the stack\\n            if (ch == \\'(\\' || ch == \\'{\\' || ch == \\'[\\') {\\n                st.push(ch);\\n            }\\n            // If the character is a closing bracket, check if it matches the top element on the stack\\n            else {\\n                // If the stack is not empty\\n                if (!st.empty()) {\\n                    // Get the top element on the stack\\n                    char top = st.top();\\n                    // If the closing bracket matches the top element on the stack, pop the top element\\n                    if ((ch == \\')\\' && top == \\'(\\') ||\\n                        (ch == \\'}\\' && top == \\'{\\') ||\\n                        (ch == \\']\\' && top == \\'[\\')) {\\n                        st.pop();\\n                    }\\n                    // If the closing bracket does not match the top element on the stack, return false\\n                    else {\\n                        return false;\\n                    }\\n                }\\n                // If the stack is empty and a closing bracket is encountered, return false\\n                else {\\n                    return false;\\n                }\\n            }\\n        }\\n        // If the stack is empty at the end, return true\\n        if (st.empty()) {\\n            return true;\\n        }\\n        // If the stack is not empty at the end, return false\\n        else {\\n            return false;\\n        }\\n    }  \\n};\\n\\n\\n`"
                    },
                    {
                        "username": "trifo75",
                        "content": "Well, it seems, nested brackets must be handled. It is not clear from the problem description. "
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "There is a problem with vector pop_back() function in leetcode compiler.\nI ran the same code i wrote in LeetCode in vs code software and it ran perfectly.\nError occurs on test case 9 and the error is below.\nERROR (Runtime Error): Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000130 overflowed to 0x60200000012f (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\n\nI cannot understand why this error is only occurs on only leetcode.\nHelp me if you know how to solve this error."
                    },
                    {
                        "username": "user5404o",
                        "content": "class Solution:\\n    def isValid(self, s: str) -> bool:\\n        flag1,flag2,flag=0,0,0\\n        for i in range(len(s)):\\n            if s[i]==\"(\":flag=flag+1\\n            elif s[i]==\"[\":flag1=flag1+1\\n            elif s[i]==\"{\":flag2=flag2+1\\n            elif s[i]==\")\":flag=flag-1\\n            elif s[i]==\"}\":flag2=flag2-1\\n            elif s[i]==\"]\":flag1=flag1-1\\n            else:\\n                pass\\n        if flag==0 and flag1==0 and flag2==0:\\n            return True\\n        else:\\n            return False \\n\\n\\n\\n\\n###################\\n82 Case pass only\\n#################### "
                    },
                    {
                        "username": "dream101221",
                        "content": "Here is the solution [Click Here](https://unknown-coder-here.blogspot.com/2023/01/valid-parentheses-problem-solution-in.html)"
                    },
                    {
                        "username": "JuanQP",
                        "content": "For those who are trying to solve this, I\\'ll give you a hint: google what is a \"stack data structure\". And then, try to think how to use it here. It\\'s very useful for this kind of problems where you need some kind of symmetry"
                    },
                    {
                        "username": "adivee__",
                        "content": "\"([)]\" is not valid one acc to test cases, but its not mentioned in the description that the closing bracket must be the corresponding character else its invalid. what even \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Mahammad_ahmadov2",
                        "content": "(([]){}) is valid too :(\\n"
                    }
                ]
            },
            {
                "id": 1749778,
                "content": [
                    {
                        "username": "fbwipo",
                        "content": "this will teach you good usage of stack data structure."
                    },
                    {
                        "username": "programmer3001",
                        "content": "`class Solution(object):\n    def isValid(self, s):\n        if s.count('(') == s.count(')') and s.count('[') == s.count(']') and s.count('{') == s.count('}'):\n            return True\n        else:\n            return False`\n\ninput\ns =\n\"([)]\"\nOutput\ntrue\nExpected\nfalse\n\nwhat's wrong lol"
                    },
                    {
                        "username": "omjain",
                        "content": "bro just assume the parentheses hierarchy we do while coding. \\nFor this case it should be `([])`"
                    },
                    {
                        "username": "uvinayak7",
                        "content": " `class Solution {\\npublic:\\n    // Function to check if a string of brackets is valid\\n    bool isValid(string s) {\\n        // Create a stack to store the brackets\\n        stack<char> st;\\n\\n        // Iterate through each character in the string\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s[i];\\n\\n            // If the character is an opening bracket, push it onto the stack\\n            if (ch == \\'(\\' || ch == \\'{\\' || ch == \\'[\\') {\\n                st.push(ch);\\n            }\\n            // If the character is a closing bracket, check if it matches the top element on the stack\\n            else {\\n                // If the stack is not empty\\n                if (!st.empty()) {\\n                    // Get the top element on the stack\\n                    char top = st.top();\\n                    // If the closing bracket matches the top element on the stack, pop the top element\\n                    if ((ch == \\')\\' && top == \\'(\\') ||\\n                        (ch == \\'}\\' && top == \\'{\\') ||\\n                        (ch == \\']\\' && top == \\'[\\')) {\\n                        st.pop();\\n                    }\\n                    // If the closing bracket does not match the top element on the stack, return false\\n                    else {\\n                        return false;\\n                    }\\n                }\\n                // If the stack is empty and a closing bracket is encountered, return false\\n                else {\\n                    return false;\\n                }\\n            }\\n        }\\n        // If the stack is empty at the end, return true\\n        if (st.empty()) {\\n            return true;\\n        }\\n        // If the stack is not empty at the end, return false\\n        else {\\n            return false;\\n        }\\n    }  \\n};\\n\\n\\n`"
                    },
                    {
                        "username": "trifo75",
                        "content": "Well, it seems, nested brackets must be handled. It is not clear from the problem description. "
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "There is a problem with vector pop_back() function in leetcode compiler.\nI ran the same code i wrote in LeetCode in vs code software and it ran perfectly.\nError occurs on test case 9 and the error is below.\nERROR (Runtime Error): Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000130 overflowed to 0x60200000012f (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\n\nI cannot understand why this error is only occurs on only leetcode.\nHelp me if you know how to solve this error."
                    },
                    {
                        "username": "user5404o",
                        "content": "class Solution:\\n    def isValid(self, s: str) -> bool:\\n        flag1,flag2,flag=0,0,0\\n        for i in range(len(s)):\\n            if s[i]==\"(\":flag=flag+1\\n            elif s[i]==\"[\":flag1=flag1+1\\n            elif s[i]==\"{\":flag2=flag2+1\\n            elif s[i]==\")\":flag=flag-1\\n            elif s[i]==\"}\":flag2=flag2-1\\n            elif s[i]==\"]\":flag1=flag1-1\\n            else:\\n                pass\\n        if flag==0 and flag1==0 and flag2==0:\\n            return True\\n        else:\\n            return False \\n\\n\\n\\n\\n###################\\n82 Case pass only\\n#################### "
                    },
                    {
                        "username": "dream101221",
                        "content": "Here is the solution [Click Here](https://unknown-coder-here.blogspot.com/2023/01/valid-parentheses-problem-solution-in.html)"
                    },
                    {
                        "username": "JuanQP",
                        "content": "For those who are trying to solve this, I\\'ll give you a hint: google what is a \"stack data structure\". And then, try to think how to use it here. It\\'s very useful for this kind of problems where you need some kind of symmetry"
                    },
                    {
                        "username": "adivee__",
                        "content": "\"([)]\" is not valid one acc to test cases, but its not mentioned in the description that the closing bracket must be the corresponding character else its invalid. what even \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Mahammad_ahmadov2",
                        "content": "(([]){}) is valid too :(\\n"
                    }
                ]
            },
            {
                "id": 1749362,
                "content": [
                    {
                        "username": "fbwipo",
                        "content": "this will teach you good usage of stack data structure."
                    },
                    {
                        "username": "programmer3001",
                        "content": "`class Solution(object):\n    def isValid(self, s):\n        if s.count('(') == s.count(')') and s.count('[') == s.count(']') and s.count('{') == s.count('}'):\n            return True\n        else:\n            return False`\n\ninput\ns =\n\"([)]\"\nOutput\ntrue\nExpected\nfalse\n\nwhat's wrong lol"
                    },
                    {
                        "username": "omjain",
                        "content": "bro just assume the parentheses hierarchy we do while coding. \\nFor this case it should be `([])`"
                    },
                    {
                        "username": "uvinayak7",
                        "content": " `class Solution {\\npublic:\\n    // Function to check if a string of brackets is valid\\n    bool isValid(string s) {\\n        // Create a stack to store the brackets\\n        stack<char> st;\\n\\n        // Iterate through each character in the string\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s[i];\\n\\n            // If the character is an opening bracket, push it onto the stack\\n            if (ch == \\'(\\' || ch == \\'{\\' || ch == \\'[\\') {\\n                st.push(ch);\\n            }\\n            // If the character is a closing bracket, check if it matches the top element on the stack\\n            else {\\n                // If the stack is not empty\\n                if (!st.empty()) {\\n                    // Get the top element on the stack\\n                    char top = st.top();\\n                    // If the closing bracket matches the top element on the stack, pop the top element\\n                    if ((ch == \\')\\' && top == \\'(\\') ||\\n                        (ch == \\'}\\' && top == \\'{\\') ||\\n                        (ch == \\']\\' && top == \\'[\\')) {\\n                        st.pop();\\n                    }\\n                    // If the closing bracket does not match the top element on the stack, return false\\n                    else {\\n                        return false;\\n                    }\\n                }\\n                // If the stack is empty and a closing bracket is encountered, return false\\n                else {\\n                    return false;\\n                }\\n            }\\n        }\\n        // If the stack is empty at the end, return true\\n        if (st.empty()) {\\n            return true;\\n        }\\n        // If the stack is not empty at the end, return false\\n        else {\\n            return false;\\n        }\\n    }  \\n};\\n\\n\\n`"
                    },
                    {
                        "username": "trifo75",
                        "content": "Well, it seems, nested brackets must be handled. It is not clear from the problem description. "
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "There is a problem with vector pop_back() function in leetcode compiler.\nI ran the same code i wrote in LeetCode in vs code software and it ran perfectly.\nError occurs on test case 9 and the error is below.\nERROR (Runtime Error): Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000130 overflowed to 0x60200000012f (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\n\nI cannot understand why this error is only occurs on only leetcode.\nHelp me if you know how to solve this error."
                    },
                    {
                        "username": "user5404o",
                        "content": "class Solution:\\n    def isValid(self, s: str) -> bool:\\n        flag1,flag2,flag=0,0,0\\n        for i in range(len(s)):\\n            if s[i]==\"(\":flag=flag+1\\n            elif s[i]==\"[\":flag1=flag1+1\\n            elif s[i]==\"{\":flag2=flag2+1\\n            elif s[i]==\")\":flag=flag-1\\n            elif s[i]==\"}\":flag2=flag2-1\\n            elif s[i]==\"]\":flag1=flag1-1\\n            else:\\n                pass\\n        if flag==0 and flag1==0 and flag2==0:\\n            return True\\n        else:\\n            return False \\n\\n\\n\\n\\n###################\\n82 Case pass only\\n#################### "
                    },
                    {
                        "username": "dream101221",
                        "content": "Here is the solution [Click Here](https://unknown-coder-here.blogspot.com/2023/01/valid-parentheses-problem-solution-in.html)"
                    },
                    {
                        "username": "JuanQP",
                        "content": "For those who are trying to solve this, I\\'ll give you a hint: google what is a \"stack data structure\". And then, try to think how to use it here. It\\'s very useful for this kind of problems where you need some kind of symmetry"
                    },
                    {
                        "username": "adivee__",
                        "content": "\"([)]\" is not valid one acc to test cases, but its not mentioned in the description that the closing bracket must be the corresponding character else its invalid. what even \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Mahammad_ahmadov2",
                        "content": "(([]){}) is valid too :(\\n"
                    }
                ]
            },
            {
                "id": 1748720,
                "content": [
                    {
                        "username": "fbwipo",
                        "content": "this will teach you good usage of stack data structure."
                    },
                    {
                        "username": "programmer3001",
                        "content": "`class Solution(object):\n    def isValid(self, s):\n        if s.count('(') == s.count(')') and s.count('[') == s.count(']') and s.count('{') == s.count('}'):\n            return True\n        else:\n            return False`\n\ninput\ns =\n\"([)]\"\nOutput\ntrue\nExpected\nfalse\n\nwhat's wrong lol"
                    },
                    {
                        "username": "omjain",
                        "content": "bro just assume the parentheses hierarchy we do while coding. \\nFor this case it should be `([])`"
                    },
                    {
                        "username": "uvinayak7",
                        "content": " `class Solution {\\npublic:\\n    // Function to check if a string of brackets is valid\\n    bool isValid(string s) {\\n        // Create a stack to store the brackets\\n        stack<char> st;\\n\\n        // Iterate through each character in the string\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s[i];\\n\\n            // If the character is an opening bracket, push it onto the stack\\n            if (ch == \\'(\\' || ch == \\'{\\' || ch == \\'[\\') {\\n                st.push(ch);\\n            }\\n            // If the character is a closing bracket, check if it matches the top element on the stack\\n            else {\\n                // If the stack is not empty\\n                if (!st.empty()) {\\n                    // Get the top element on the stack\\n                    char top = st.top();\\n                    // If the closing bracket matches the top element on the stack, pop the top element\\n                    if ((ch == \\')\\' && top == \\'(\\') ||\\n                        (ch == \\'}\\' && top == \\'{\\') ||\\n                        (ch == \\']\\' && top == \\'[\\')) {\\n                        st.pop();\\n                    }\\n                    // If the closing bracket does not match the top element on the stack, return false\\n                    else {\\n                        return false;\\n                    }\\n                }\\n                // If the stack is empty and a closing bracket is encountered, return false\\n                else {\\n                    return false;\\n                }\\n            }\\n        }\\n        // If the stack is empty at the end, return true\\n        if (st.empty()) {\\n            return true;\\n        }\\n        // If the stack is not empty at the end, return false\\n        else {\\n            return false;\\n        }\\n    }  \\n};\\n\\n\\n`"
                    },
                    {
                        "username": "trifo75",
                        "content": "Well, it seems, nested brackets must be handled. It is not clear from the problem description. "
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "There is a problem with vector pop_back() function in leetcode compiler.\nI ran the same code i wrote in LeetCode in vs code software and it ran perfectly.\nError occurs on test case 9 and the error is below.\nERROR (Runtime Error): Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000130 overflowed to 0x60200000012f (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\n\nI cannot understand why this error is only occurs on only leetcode.\nHelp me if you know how to solve this error."
                    },
                    {
                        "username": "user5404o",
                        "content": "class Solution:\\n    def isValid(self, s: str) -> bool:\\n        flag1,flag2,flag=0,0,0\\n        for i in range(len(s)):\\n            if s[i]==\"(\":flag=flag+1\\n            elif s[i]==\"[\":flag1=flag1+1\\n            elif s[i]==\"{\":flag2=flag2+1\\n            elif s[i]==\")\":flag=flag-1\\n            elif s[i]==\"}\":flag2=flag2-1\\n            elif s[i]==\"]\":flag1=flag1-1\\n            else:\\n                pass\\n        if flag==0 and flag1==0 and flag2==0:\\n            return True\\n        else:\\n            return False \\n\\n\\n\\n\\n###################\\n82 Case pass only\\n#################### "
                    },
                    {
                        "username": "dream101221",
                        "content": "Here is the solution [Click Here](https://unknown-coder-here.blogspot.com/2023/01/valid-parentheses-problem-solution-in.html)"
                    },
                    {
                        "username": "JuanQP",
                        "content": "For those who are trying to solve this, I\\'ll give you a hint: google what is a \"stack data structure\". And then, try to think how to use it here. It\\'s very useful for this kind of problems where you need some kind of symmetry"
                    },
                    {
                        "username": "adivee__",
                        "content": "\"([)]\" is not valid one acc to test cases, but its not mentioned in the description that the closing bracket must be the corresponding character else its invalid. what even \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Mahammad_ahmadov2",
                        "content": "(([]){}) is valid too :(\\n"
                    }
                ]
            },
            {
                "id": 1748549,
                "content": [
                    {
                        "username": "fbwipo",
                        "content": "this will teach you good usage of stack data structure."
                    },
                    {
                        "username": "programmer3001",
                        "content": "`class Solution(object):\n    def isValid(self, s):\n        if s.count('(') == s.count(')') and s.count('[') == s.count(']') and s.count('{') == s.count('}'):\n            return True\n        else:\n            return False`\n\ninput\ns =\n\"([)]\"\nOutput\ntrue\nExpected\nfalse\n\nwhat's wrong lol"
                    },
                    {
                        "username": "omjain",
                        "content": "bro just assume the parentheses hierarchy we do while coding. \\nFor this case it should be `([])`"
                    },
                    {
                        "username": "uvinayak7",
                        "content": " `class Solution {\\npublic:\\n    // Function to check if a string of brackets is valid\\n    bool isValid(string s) {\\n        // Create a stack to store the brackets\\n        stack<char> st;\\n\\n        // Iterate through each character in the string\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s[i];\\n\\n            // If the character is an opening bracket, push it onto the stack\\n            if (ch == \\'(\\' || ch == \\'{\\' || ch == \\'[\\') {\\n                st.push(ch);\\n            }\\n            // If the character is a closing bracket, check if it matches the top element on the stack\\n            else {\\n                // If the stack is not empty\\n                if (!st.empty()) {\\n                    // Get the top element on the stack\\n                    char top = st.top();\\n                    // If the closing bracket matches the top element on the stack, pop the top element\\n                    if ((ch == \\')\\' && top == \\'(\\') ||\\n                        (ch == \\'}\\' && top == \\'{\\') ||\\n                        (ch == \\']\\' && top == \\'[\\')) {\\n                        st.pop();\\n                    }\\n                    // If the closing bracket does not match the top element on the stack, return false\\n                    else {\\n                        return false;\\n                    }\\n                }\\n                // If the stack is empty and a closing bracket is encountered, return false\\n                else {\\n                    return false;\\n                }\\n            }\\n        }\\n        // If the stack is empty at the end, return true\\n        if (st.empty()) {\\n            return true;\\n        }\\n        // If the stack is not empty at the end, return false\\n        else {\\n            return false;\\n        }\\n    }  \\n};\\n\\n\\n`"
                    },
                    {
                        "username": "trifo75",
                        "content": "Well, it seems, nested brackets must be handled. It is not clear from the problem description. "
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "There is a problem with vector pop_back() function in leetcode compiler.\nI ran the same code i wrote in LeetCode in vs code software and it ran perfectly.\nError occurs on test case 9 and the error is below.\nERROR (Runtime Error): Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000130 overflowed to 0x60200000012f (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\n\nI cannot understand why this error is only occurs on only leetcode.\nHelp me if you know how to solve this error."
                    },
                    {
                        "username": "user5404o",
                        "content": "class Solution:\\n    def isValid(self, s: str) -> bool:\\n        flag1,flag2,flag=0,0,0\\n        for i in range(len(s)):\\n            if s[i]==\"(\":flag=flag+1\\n            elif s[i]==\"[\":flag1=flag1+1\\n            elif s[i]==\"{\":flag2=flag2+1\\n            elif s[i]==\")\":flag=flag-1\\n            elif s[i]==\"}\":flag2=flag2-1\\n            elif s[i]==\"]\":flag1=flag1-1\\n            else:\\n                pass\\n        if flag==0 and flag1==0 and flag2==0:\\n            return True\\n        else:\\n            return False \\n\\n\\n\\n\\n###################\\n82 Case pass only\\n#################### "
                    },
                    {
                        "username": "dream101221",
                        "content": "Here is the solution [Click Here](https://unknown-coder-here.blogspot.com/2023/01/valid-parentheses-problem-solution-in.html)"
                    },
                    {
                        "username": "JuanQP",
                        "content": "For those who are trying to solve this, I\\'ll give you a hint: google what is a \"stack data structure\". And then, try to think how to use it here. It\\'s very useful for this kind of problems where you need some kind of symmetry"
                    },
                    {
                        "username": "adivee__",
                        "content": "\"([)]\" is not valid one acc to test cases, but its not mentioned in the description that the closing bracket must be the corresponding character else its invalid. what even \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Mahammad_ahmadov2",
                        "content": "(([]){}) is valid too :(\\n"
                    }
                ]
            },
            {
                "id": 1748208,
                "content": [
                    {
                        "username": "fbwipo",
                        "content": "this will teach you good usage of stack data structure."
                    },
                    {
                        "username": "programmer3001",
                        "content": "`class Solution(object):\n    def isValid(self, s):\n        if s.count('(') == s.count(')') and s.count('[') == s.count(']') and s.count('{') == s.count('}'):\n            return True\n        else:\n            return False`\n\ninput\ns =\n\"([)]\"\nOutput\ntrue\nExpected\nfalse\n\nwhat's wrong lol"
                    },
                    {
                        "username": "omjain",
                        "content": "bro just assume the parentheses hierarchy we do while coding. \\nFor this case it should be `([])`"
                    },
                    {
                        "username": "uvinayak7",
                        "content": " `class Solution {\\npublic:\\n    // Function to check if a string of brackets is valid\\n    bool isValid(string s) {\\n        // Create a stack to store the brackets\\n        stack<char> st;\\n\\n        // Iterate through each character in the string\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s[i];\\n\\n            // If the character is an opening bracket, push it onto the stack\\n            if (ch == \\'(\\' || ch == \\'{\\' || ch == \\'[\\') {\\n                st.push(ch);\\n            }\\n            // If the character is a closing bracket, check if it matches the top element on the stack\\n            else {\\n                // If the stack is not empty\\n                if (!st.empty()) {\\n                    // Get the top element on the stack\\n                    char top = st.top();\\n                    // If the closing bracket matches the top element on the stack, pop the top element\\n                    if ((ch == \\')\\' && top == \\'(\\') ||\\n                        (ch == \\'}\\' && top == \\'{\\') ||\\n                        (ch == \\']\\' && top == \\'[\\')) {\\n                        st.pop();\\n                    }\\n                    // If the closing bracket does not match the top element on the stack, return false\\n                    else {\\n                        return false;\\n                    }\\n                }\\n                // If the stack is empty and a closing bracket is encountered, return false\\n                else {\\n                    return false;\\n                }\\n            }\\n        }\\n        // If the stack is empty at the end, return true\\n        if (st.empty()) {\\n            return true;\\n        }\\n        // If the stack is not empty at the end, return false\\n        else {\\n            return false;\\n        }\\n    }  \\n};\\n\\n\\n`"
                    },
                    {
                        "username": "trifo75",
                        "content": "Well, it seems, nested brackets must be handled. It is not clear from the problem description. "
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "There is a problem with vector pop_back() function in leetcode compiler.\nI ran the same code i wrote in LeetCode in vs code software and it ran perfectly.\nError occurs on test case 9 and the error is below.\nERROR (Runtime Error): Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000130 overflowed to 0x60200000012f (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\n\nI cannot understand why this error is only occurs on only leetcode.\nHelp me if you know how to solve this error."
                    },
                    {
                        "username": "user5404o",
                        "content": "class Solution:\\n    def isValid(self, s: str) -> bool:\\n        flag1,flag2,flag=0,0,0\\n        for i in range(len(s)):\\n            if s[i]==\"(\":flag=flag+1\\n            elif s[i]==\"[\":flag1=flag1+1\\n            elif s[i]==\"{\":flag2=flag2+1\\n            elif s[i]==\")\":flag=flag-1\\n            elif s[i]==\"}\":flag2=flag2-1\\n            elif s[i]==\"]\":flag1=flag1-1\\n            else:\\n                pass\\n        if flag==0 and flag1==0 and flag2==0:\\n            return True\\n        else:\\n            return False \\n\\n\\n\\n\\n###################\\n82 Case pass only\\n#################### "
                    },
                    {
                        "username": "dream101221",
                        "content": "Here is the solution [Click Here](https://unknown-coder-here.blogspot.com/2023/01/valid-parentheses-problem-solution-in.html)"
                    },
                    {
                        "username": "JuanQP",
                        "content": "For those who are trying to solve this, I\\'ll give you a hint: google what is a \"stack data structure\". And then, try to think how to use it here. It\\'s very useful for this kind of problems where you need some kind of symmetry"
                    },
                    {
                        "username": "adivee__",
                        "content": "\"([)]\" is not valid one acc to test cases, but its not mentioned in the description that the closing bracket must be the corresponding character else its invalid. what even \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Mahammad_ahmadov2",
                        "content": "(([]){}) is valid too :(\\n"
                    }
                ]
            },
            {
                "id": 1747599,
                "content": [
                    {
                        "username": "fbwipo",
                        "content": "this will teach you good usage of stack data structure."
                    },
                    {
                        "username": "programmer3001",
                        "content": "`class Solution(object):\n    def isValid(self, s):\n        if s.count('(') == s.count(')') and s.count('[') == s.count(']') and s.count('{') == s.count('}'):\n            return True\n        else:\n            return False`\n\ninput\ns =\n\"([)]\"\nOutput\ntrue\nExpected\nfalse\n\nwhat's wrong lol"
                    },
                    {
                        "username": "omjain",
                        "content": "bro just assume the parentheses hierarchy we do while coding. \\nFor this case it should be `([])`"
                    },
                    {
                        "username": "uvinayak7",
                        "content": " `class Solution {\\npublic:\\n    // Function to check if a string of brackets is valid\\n    bool isValid(string s) {\\n        // Create a stack to store the brackets\\n        stack<char> st;\\n\\n        // Iterate through each character in the string\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s[i];\\n\\n            // If the character is an opening bracket, push it onto the stack\\n            if (ch == \\'(\\' || ch == \\'{\\' || ch == \\'[\\') {\\n                st.push(ch);\\n            }\\n            // If the character is a closing bracket, check if it matches the top element on the stack\\n            else {\\n                // If the stack is not empty\\n                if (!st.empty()) {\\n                    // Get the top element on the stack\\n                    char top = st.top();\\n                    // If the closing bracket matches the top element on the stack, pop the top element\\n                    if ((ch == \\')\\' && top == \\'(\\') ||\\n                        (ch == \\'}\\' && top == \\'{\\') ||\\n                        (ch == \\']\\' && top == \\'[\\')) {\\n                        st.pop();\\n                    }\\n                    // If the closing bracket does not match the top element on the stack, return false\\n                    else {\\n                        return false;\\n                    }\\n                }\\n                // If the stack is empty and a closing bracket is encountered, return false\\n                else {\\n                    return false;\\n                }\\n            }\\n        }\\n        // If the stack is empty at the end, return true\\n        if (st.empty()) {\\n            return true;\\n        }\\n        // If the stack is not empty at the end, return false\\n        else {\\n            return false;\\n        }\\n    }  \\n};\\n\\n\\n`"
                    },
                    {
                        "username": "trifo75",
                        "content": "Well, it seems, nested brackets must be handled. It is not clear from the problem description. "
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "There is a problem with vector pop_back() function in leetcode compiler.\nI ran the same code i wrote in LeetCode in vs code software and it ran perfectly.\nError occurs on test case 9 and the error is below.\nERROR (Runtime Error): Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000130 overflowed to 0x60200000012f (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\n\nI cannot understand why this error is only occurs on only leetcode.\nHelp me if you know how to solve this error."
                    },
                    {
                        "username": "user5404o",
                        "content": "class Solution:\\n    def isValid(self, s: str) -> bool:\\n        flag1,flag2,flag=0,0,0\\n        for i in range(len(s)):\\n            if s[i]==\"(\":flag=flag+1\\n            elif s[i]==\"[\":flag1=flag1+1\\n            elif s[i]==\"{\":flag2=flag2+1\\n            elif s[i]==\")\":flag=flag-1\\n            elif s[i]==\"}\":flag2=flag2-1\\n            elif s[i]==\"]\":flag1=flag1-1\\n            else:\\n                pass\\n        if flag==0 and flag1==0 and flag2==0:\\n            return True\\n        else:\\n            return False \\n\\n\\n\\n\\n###################\\n82 Case pass only\\n#################### "
                    },
                    {
                        "username": "dream101221",
                        "content": "Here is the solution [Click Here](https://unknown-coder-here.blogspot.com/2023/01/valid-parentheses-problem-solution-in.html)"
                    },
                    {
                        "username": "JuanQP",
                        "content": "For those who are trying to solve this, I\\'ll give you a hint: google what is a \"stack data structure\". And then, try to think how to use it here. It\\'s very useful for this kind of problems where you need some kind of symmetry"
                    },
                    {
                        "username": "adivee__",
                        "content": "\"([)]\" is not valid one acc to test cases, but its not mentioned in the description that the closing bracket must be the corresponding character else its invalid. what even \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Mahammad_ahmadov2",
                        "content": "(([]){}) is valid too :(\\n"
                    }
                ]
            },
            {
                "id": 1747039,
                "content": [
                    {
                        "username": "fbwipo",
                        "content": "this will teach you good usage of stack data structure."
                    },
                    {
                        "username": "programmer3001",
                        "content": "`class Solution(object):\n    def isValid(self, s):\n        if s.count('(') == s.count(')') and s.count('[') == s.count(']') and s.count('{') == s.count('}'):\n            return True\n        else:\n            return False`\n\ninput\ns =\n\"([)]\"\nOutput\ntrue\nExpected\nfalse\n\nwhat's wrong lol"
                    },
                    {
                        "username": "omjain",
                        "content": "bro just assume the parentheses hierarchy we do while coding. \\nFor this case it should be `([])`"
                    },
                    {
                        "username": "uvinayak7",
                        "content": " `class Solution {\\npublic:\\n    // Function to check if a string of brackets is valid\\n    bool isValid(string s) {\\n        // Create a stack to store the brackets\\n        stack<char> st;\\n\\n        // Iterate through each character in the string\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s[i];\\n\\n            // If the character is an opening bracket, push it onto the stack\\n            if (ch == \\'(\\' || ch == \\'{\\' || ch == \\'[\\') {\\n                st.push(ch);\\n            }\\n            // If the character is a closing bracket, check if it matches the top element on the stack\\n            else {\\n                // If the stack is not empty\\n                if (!st.empty()) {\\n                    // Get the top element on the stack\\n                    char top = st.top();\\n                    // If the closing bracket matches the top element on the stack, pop the top element\\n                    if ((ch == \\')\\' && top == \\'(\\') ||\\n                        (ch == \\'}\\' && top == \\'{\\') ||\\n                        (ch == \\']\\' && top == \\'[\\')) {\\n                        st.pop();\\n                    }\\n                    // If the closing bracket does not match the top element on the stack, return false\\n                    else {\\n                        return false;\\n                    }\\n                }\\n                // If the stack is empty and a closing bracket is encountered, return false\\n                else {\\n                    return false;\\n                }\\n            }\\n        }\\n        // If the stack is empty at the end, return true\\n        if (st.empty()) {\\n            return true;\\n        }\\n        // If the stack is not empty at the end, return false\\n        else {\\n            return false;\\n        }\\n    }  \\n};\\n\\n\\n`"
                    },
                    {
                        "username": "trifo75",
                        "content": "Well, it seems, nested brackets must be handled. It is not clear from the problem description. "
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "There is a problem with vector pop_back() function in leetcode compiler.\nI ran the same code i wrote in LeetCode in vs code software and it ran perfectly.\nError occurs on test case 9 and the error is below.\nERROR (Runtime Error): Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000130 overflowed to 0x60200000012f (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\n\nI cannot understand why this error is only occurs on only leetcode.\nHelp me if you know how to solve this error."
                    },
                    {
                        "username": "user5404o",
                        "content": "class Solution:\\n    def isValid(self, s: str) -> bool:\\n        flag1,flag2,flag=0,0,0\\n        for i in range(len(s)):\\n            if s[i]==\"(\":flag=flag+1\\n            elif s[i]==\"[\":flag1=flag1+1\\n            elif s[i]==\"{\":flag2=flag2+1\\n            elif s[i]==\")\":flag=flag-1\\n            elif s[i]==\"}\":flag2=flag2-1\\n            elif s[i]==\"]\":flag1=flag1-1\\n            else:\\n                pass\\n        if flag==0 and flag1==0 and flag2==0:\\n            return True\\n        else:\\n            return False \\n\\n\\n\\n\\n###################\\n82 Case pass only\\n#################### "
                    },
                    {
                        "username": "dream101221",
                        "content": "Here is the solution [Click Here](https://unknown-coder-here.blogspot.com/2023/01/valid-parentheses-problem-solution-in.html)"
                    },
                    {
                        "username": "JuanQP",
                        "content": "For those who are trying to solve this, I\\'ll give you a hint: google what is a \"stack data structure\". And then, try to think how to use it here. It\\'s very useful for this kind of problems where you need some kind of symmetry"
                    },
                    {
                        "username": "adivee__",
                        "content": "\"([)]\" is not valid one acc to test cases, but its not mentioned in the description that the closing bracket must be the corresponding character else its invalid. what even \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Mahammad_ahmadov2",
                        "content": "(([]){}) is valid too :(\\n"
                    }
                ]
            },
            {
                "id": 1743452,
                "content": [
                    {
                        "username": "fbwipo",
                        "content": "this will teach you good usage of stack data structure."
                    },
                    {
                        "username": "programmer3001",
                        "content": "`class Solution(object):\n    def isValid(self, s):\n        if s.count('(') == s.count(')') and s.count('[') == s.count(']') and s.count('{') == s.count('}'):\n            return True\n        else:\n            return False`\n\ninput\ns =\n\"([)]\"\nOutput\ntrue\nExpected\nfalse\n\nwhat's wrong lol"
                    },
                    {
                        "username": "omjain",
                        "content": "bro just assume the parentheses hierarchy we do while coding. \\nFor this case it should be `([])`"
                    },
                    {
                        "username": "uvinayak7",
                        "content": " `class Solution {\\npublic:\\n    // Function to check if a string of brackets is valid\\n    bool isValid(string s) {\\n        // Create a stack to store the brackets\\n        stack<char> st;\\n\\n        // Iterate through each character in the string\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s[i];\\n\\n            // If the character is an opening bracket, push it onto the stack\\n            if (ch == \\'(\\' || ch == \\'{\\' || ch == \\'[\\') {\\n                st.push(ch);\\n            }\\n            // If the character is a closing bracket, check if it matches the top element on the stack\\n            else {\\n                // If the stack is not empty\\n                if (!st.empty()) {\\n                    // Get the top element on the stack\\n                    char top = st.top();\\n                    // If the closing bracket matches the top element on the stack, pop the top element\\n                    if ((ch == \\')\\' && top == \\'(\\') ||\\n                        (ch == \\'}\\' && top == \\'{\\') ||\\n                        (ch == \\']\\' && top == \\'[\\')) {\\n                        st.pop();\\n                    }\\n                    // If the closing bracket does not match the top element on the stack, return false\\n                    else {\\n                        return false;\\n                    }\\n                }\\n                // If the stack is empty and a closing bracket is encountered, return false\\n                else {\\n                    return false;\\n                }\\n            }\\n        }\\n        // If the stack is empty at the end, return true\\n        if (st.empty()) {\\n            return true;\\n        }\\n        // If the stack is not empty at the end, return false\\n        else {\\n            return false;\\n        }\\n    }  \\n};\\n\\n\\n`"
                    },
                    {
                        "username": "trifo75",
                        "content": "Well, it seems, nested brackets must be handled. It is not clear from the problem description. "
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "There is a problem with vector pop_back() function in leetcode compiler.\nI ran the same code i wrote in LeetCode in vs code software and it ran perfectly.\nError occurs on test case 9 and the error is below.\nERROR (Runtime Error): Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000130 overflowed to 0x60200000012f (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\n\nI cannot understand why this error is only occurs on only leetcode.\nHelp me if you know how to solve this error."
                    },
                    {
                        "username": "user5404o",
                        "content": "class Solution:\\n    def isValid(self, s: str) -> bool:\\n        flag1,flag2,flag=0,0,0\\n        for i in range(len(s)):\\n            if s[i]==\"(\":flag=flag+1\\n            elif s[i]==\"[\":flag1=flag1+1\\n            elif s[i]==\"{\":flag2=flag2+1\\n            elif s[i]==\")\":flag=flag-1\\n            elif s[i]==\"}\":flag2=flag2-1\\n            elif s[i]==\"]\":flag1=flag1-1\\n            else:\\n                pass\\n        if flag==0 and flag1==0 and flag2==0:\\n            return True\\n        else:\\n            return False \\n\\n\\n\\n\\n###################\\n82 Case pass only\\n#################### "
                    },
                    {
                        "username": "dream101221",
                        "content": "Here is the solution [Click Here](https://unknown-coder-here.blogspot.com/2023/01/valid-parentheses-problem-solution-in.html)"
                    },
                    {
                        "username": "JuanQP",
                        "content": "For those who are trying to solve this, I\\'ll give you a hint: google what is a \"stack data structure\". And then, try to think how to use it here. It\\'s very useful for this kind of problems where you need some kind of symmetry"
                    },
                    {
                        "username": "adivee__",
                        "content": "\"([)]\" is not valid one acc to test cases, but its not mentioned in the description that the closing bracket must be the corresponding character else its invalid. what even \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Mahammad_ahmadov2",
                        "content": "(([]){}) is valid too :(\\n"
                    }
                ]
            },
            {
                "id": 1743321,
                "content": [
                    {
                        "username": "fbwipo",
                        "content": "this will teach you good usage of stack data structure."
                    },
                    {
                        "username": "programmer3001",
                        "content": "`class Solution(object):\n    def isValid(self, s):\n        if s.count('(') == s.count(')') and s.count('[') == s.count(']') and s.count('{') == s.count('}'):\n            return True\n        else:\n            return False`\n\ninput\ns =\n\"([)]\"\nOutput\ntrue\nExpected\nfalse\n\nwhat's wrong lol"
                    },
                    {
                        "username": "omjain",
                        "content": "bro just assume the parentheses hierarchy we do while coding. \\nFor this case it should be `([])`"
                    },
                    {
                        "username": "uvinayak7",
                        "content": " `class Solution {\\npublic:\\n    // Function to check if a string of brackets is valid\\n    bool isValid(string s) {\\n        // Create a stack to store the brackets\\n        stack<char> st;\\n\\n        // Iterate through each character in the string\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s[i];\\n\\n            // If the character is an opening bracket, push it onto the stack\\n            if (ch == \\'(\\' || ch == \\'{\\' || ch == \\'[\\') {\\n                st.push(ch);\\n            }\\n            // If the character is a closing bracket, check if it matches the top element on the stack\\n            else {\\n                // If the stack is not empty\\n                if (!st.empty()) {\\n                    // Get the top element on the stack\\n                    char top = st.top();\\n                    // If the closing bracket matches the top element on the stack, pop the top element\\n                    if ((ch == \\')\\' && top == \\'(\\') ||\\n                        (ch == \\'}\\' && top == \\'{\\') ||\\n                        (ch == \\']\\' && top == \\'[\\')) {\\n                        st.pop();\\n                    }\\n                    // If the closing bracket does not match the top element on the stack, return false\\n                    else {\\n                        return false;\\n                    }\\n                }\\n                // If the stack is empty and a closing bracket is encountered, return false\\n                else {\\n                    return false;\\n                }\\n            }\\n        }\\n        // If the stack is empty at the end, return true\\n        if (st.empty()) {\\n            return true;\\n        }\\n        // If the stack is not empty at the end, return false\\n        else {\\n            return false;\\n        }\\n    }  \\n};\\n\\n\\n`"
                    },
                    {
                        "username": "trifo75",
                        "content": "Well, it seems, nested brackets must be handled. It is not clear from the problem description. "
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "There is a problem with vector pop_back() function in leetcode compiler.\nI ran the same code i wrote in LeetCode in vs code software and it ran perfectly.\nError occurs on test case 9 and the error is below.\nERROR (Runtime Error): Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000130 overflowed to 0x60200000012f (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\n\nI cannot understand why this error is only occurs on only leetcode.\nHelp me if you know how to solve this error."
                    },
                    {
                        "username": "user5404o",
                        "content": "class Solution:\\n    def isValid(self, s: str) -> bool:\\n        flag1,flag2,flag=0,0,0\\n        for i in range(len(s)):\\n            if s[i]==\"(\":flag=flag+1\\n            elif s[i]==\"[\":flag1=flag1+1\\n            elif s[i]==\"{\":flag2=flag2+1\\n            elif s[i]==\")\":flag=flag-1\\n            elif s[i]==\"}\":flag2=flag2-1\\n            elif s[i]==\"]\":flag1=flag1-1\\n            else:\\n                pass\\n        if flag==0 and flag1==0 and flag2==0:\\n            return True\\n        else:\\n            return False \\n\\n\\n\\n\\n###################\\n82 Case pass only\\n#################### "
                    },
                    {
                        "username": "dream101221",
                        "content": "Here is the solution [Click Here](https://unknown-coder-here.blogspot.com/2023/01/valid-parentheses-problem-solution-in.html)"
                    },
                    {
                        "username": "JuanQP",
                        "content": "For those who are trying to solve this, I\\'ll give you a hint: google what is a \"stack data structure\". And then, try to think how to use it here. It\\'s very useful for this kind of problems where you need some kind of symmetry"
                    },
                    {
                        "username": "adivee__",
                        "content": "\"([)]\" is not valid one acc to test cases, but its not mentioned in the description that the closing bracket must be the corresponding character else its invalid. what even \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Mahammad_ahmadov2",
                        "content": "(([]){}) is valid too :(\\n"
                    }
                ]
            },
            {
                "id": 1741955,
                "content": [
                    {
                        "username": "ways",
                        "content": "What\\'s wrong with case \"{[]}\", it works for when I execute it in my pc but web still tells me that I\\'m failing that case XD"
                    },
                    {
                        "username": "bajipathak",
                        "content": "Why this gives a runtime error\\n=\\n\\n\\\\\\\\\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<int> st;\\n        st.push(s[0]);\\n        for(int i=1;i<s.length();i++){\\n            cout<<st.top()<<s[i]-1;\\n            if(st.empty()&&i==s.length()-1)\\n                return true;\\n            else if(st.empty())\\n                {\\n                    \\n                    st.push(s[i]);\\n                    i+=1;\\n                }\\n           if(st.top()+1==int(s[i])||st.top()+2==int(s[i])){\\n               st.pop();\\n           } \\n           else{\\n               st.push(s[i]);\\n           }\\n        }\\n    if(st.empty())\\n        return true;\\n    return false;\\n    }\\n}; \\\\\\\\"
                    },
                    {
                        "username": "_Prashant29",
                        "content": "whats wrong in this?????? i\\'m getting false only for every case\\n\\nclass Solution {\\n    public boolean isValid(String s) {\\n        char[] c = s.toCharArray();\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        for(int i=0;i<c.length;i++){\\n            if(map.containsKey(c[i])){\\n                map.replace(c[i],map.get(c[i])+1);\\n\\n            }else{\\n                map.put(c[i],1);\\n            }\\n        }\\n        boolean ok=true;\\n        for(Integer i:map.values()){\\n            if(i%2==1){\\n               ok=false;\\n            }\\n        }\\n        if(!ok){\\n           return false;\\n        }else{\\n            return true;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "WorthOnPython",
                        "content": "I don\\'t know why Im failing the TC \"(]\" I tested it on pycharm and passed but I keep failing it here.\\n\\nMy code:\\n\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        map = {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\\n        j = []\\n        k = []\\n        for i in s:\\n            if i in map:\\n                j.append(i)\\n            elif len(j) > 0 and i == map[j[-1]]:\\n                j.pop()\\n            else:\\n                k.append(\"False\")\\n\\n        if \"False\" not in k and len(j) == 0:\\n            return(\"true\")\\n        else:\\n            return(\"false\")"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/valid-parentheses-leet-code-20/"
                    },
                    {
                        "username": "charant587",
                        "content": "is anything wrong in my solution\\nclass Solution(object):\\n    def isValid(self, s):\\n        f=[]\\n        for i in range(0,len(s)-1):\\n\\n            if s[i] in (\\'(\\',\\'[\\',\\'{\\'):\\n                f.append(s[i])\\n            elif f[-1] == \"(\" and s[i]==\\')\\':\\n                f.pop()\\n            elif f[-1] == \"[\" and s[i]==\\']\\':\\n                f.pop()\\n            elif f[-1] == \"{\" and s[i]==\\'}\\':\\n                f.pop()\\n           \\n        if f is None :\\n            return True"
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\n    vector<char> dataStack;\\npublic:\\n    bool isValid(string s) {\\n        if(s.size() %2 !=0){\\n            return false;\\n        }\\n        if(s.size() == 0){\\n            return true;\\n        }\\n\\n        for(int i=0; i<s.size(); i++){\\n            dataStack.push_back(s[i]);\\n\\n            if(dataStack[dataStack.size() -1] == \\'}\\'){\\n                if(dataStack.size()> 1){\\n                    if(dataStack[dataStack.size()-2]==\\'{\\'){\\n                        dataStack.pop_back();\\n                        dataStack.pop_back();\\n                    }\\n                }\\n            }\\n            else if(dataStack[dataStack.size() -1] == \\')\\'){\\n                if(dataStack.size()> 1){\\n                    if(dataStack[dataStack.size()-2]==\\'(\\'){\\n                        dataStack.pop_back();\\n                        dataStack.pop_back();\\n                    }\\n                }\\n            }\\n            else if(dataStack[dataStack.size() -1] == \\']\\'){\\n                if(dataStack.size()> 1){\\n                    if(dataStack[dataStack.size()-2]==\\'[\\'){\\n                        dataStack.pop_back();\\n                        dataStack.pop_back();\\n                    }\\n                }\\n            }\\n        }\\n\\n        if(!dataStack.empty()){\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n};`"
                    },
                    {
                        "username": "sk33_f",
                        "content": "why is it not letting me set item. visited[i] ??\\n\\n    def isValid(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        visited = False * len(s)\\n        for i in range(0,len(s)):\\n            for j in range(i+1,len(s)):\\n                if(s[i]==\\'(\\'):\\n                    if(s[j]==\\')\\'):\\n                        visited[i] = True\\n                        visited[j] = True\\n                print(i,j)"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), because the stack grows in size as the input string grows, and the maximum size of the stack is equal to the length of the input string.\\n\\nThe time complexity of this solution is O(n), because the function must iterate through the input string once and perform a constant amount of work for each character.\\n\\nTherefore, the overall complexity of this solution is O(n) in both space and time."
                    },
                    {
                        "username": "nikhrasuryansh",
                        "content": "WHAT DOES GIVEN BELOW ERROR MEAN ?\\n\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x0000003449b6 bp 0x7fffe67870f0 sp 0x7fffe6786fe0 T0)\\n==34==The signal is caused by a READ memory access.\\n==34==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #3 0x7f1f0a5ed0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==34==ABORTING"
                    }
                ]
            },
            {
                "id": 1740301,
                "content": [
                    {
                        "username": "ways",
                        "content": "What\\'s wrong with case \"{[]}\", it works for when I execute it in my pc but web still tells me that I\\'m failing that case XD"
                    },
                    {
                        "username": "bajipathak",
                        "content": "Why this gives a runtime error\\n=\\n\\n\\\\\\\\\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<int> st;\\n        st.push(s[0]);\\n        for(int i=1;i<s.length();i++){\\n            cout<<st.top()<<s[i]-1;\\n            if(st.empty()&&i==s.length()-1)\\n                return true;\\n            else if(st.empty())\\n                {\\n                    \\n                    st.push(s[i]);\\n                    i+=1;\\n                }\\n           if(st.top()+1==int(s[i])||st.top()+2==int(s[i])){\\n               st.pop();\\n           } \\n           else{\\n               st.push(s[i]);\\n           }\\n        }\\n    if(st.empty())\\n        return true;\\n    return false;\\n    }\\n}; \\\\\\\\"
                    },
                    {
                        "username": "_Prashant29",
                        "content": "whats wrong in this?????? i\\'m getting false only for every case\\n\\nclass Solution {\\n    public boolean isValid(String s) {\\n        char[] c = s.toCharArray();\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        for(int i=0;i<c.length;i++){\\n            if(map.containsKey(c[i])){\\n                map.replace(c[i],map.get(c[i])+1);\\n\\n            }else{\\n                map.put(c[i],1);\\n            }\\n        }\\n        boolean ok=true;\\n        for(Integer i:map.values()){\\n            if(i%2==1){\\n               ok=false;\\n            }\\n        }\\n        if(!ok){\\n           return false;\\n        }else{\\n            return true;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "WorthOnPython",
                        "content": "I don\\'t know why Im failing the TC \"(]\" I tested it on pycharm and passed but I keep failing it here.\\n\\nMy code:\\n\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        map = {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\\n        j = []\\n        k = []\\n        for i in s:\\n            if i in map:\\n                j.append(i)\\n            elif len(j) > 0 and i == map[j[-1]]:\\n                j.pop()\\n            else:\\n                k.append(\"False\")\\n\\n        if \"False\" not in k and len(j) == 0:\\n            return(\"true\")\\n        else:\\n            return(\"false\")"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/valid-parentheses-leet-code-20/"
                    },
                    {
                        "username": "charant587",
                        "content": "is anything wrong in my solution\\nclass Solution(object):\\n    def isValid(self, s):\\n        f=[]\\n        for i in range(0,len(s)-1):\\n\\n            if s[i] in (\\'(\\',\\'[\\',\\'{\\'):\\n                f.append(s[i])\\n            elif f[-1] == \"(\" and s[i]==\\')\\':\\n                f.pop()\\n            elif f[-1] == \"[\" and s[i]==\\']\\':\\n                f.pop()\\n            elif f[-1] == \"{\" and s[i]==\\'}\\':\\n                f.pop()\\n           \\n        if f is None :\\n            return True"
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\n    vector<char> dataStack;\\npublic:\\n    bool isValid(string s) {\\n        if(s.size() %2 !=0){\\n            return false;\\n        }\\n        if(s.size() == 0){\\n            return true;\\n        }\\n\\n        for(int i=0; i<s.size(); i++){\\n            dataStack.push_back(s[i]);\\n\\n            if(dataStack[dataStack.size() -1] == \\'}\\'){\\n                if(dataStack.size()> 1){\\n                    if(dataStack[dataStack.size()-2]==\\'{\\'){\\n                        dataStack.pop_back();\\n                        dataStack.pop_back();\\n                    }\\n                }\\n            }\\n            else if(dataStack[dataStack.size() -1] == \\')\\'){\\n                if(dataStack.size()> 1){\\n                    if(dataStack[dataStack.size()-2]==\\'(\\'){\\n                        dataStack.pop_back();\\n                        dataStack.pop_back();\\n                    }\\n                }\\n            }\\n            else if(dataStack[dataStack.size() -1] == \\']\\'){\\n                if(dataStack.size()> 1){\\n                    if(dataStack[dataStack.size()-2]==\\'[\\'){\\n                        dataStack.pop_back();\\n                        dataStack.pop_back();\\n                    }\\n                }\\n            }\\n        }\\n\\n        if(!dataStack.empty()){\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n};`"
                    },
                    {
                        "username": "sk33_f",
                        "content": "why is it not letting me set item. visited[i] ??\\n\\n    def isValid(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        visited = False * len(s)\\n        for i in range(0,len(s)):\\n            for j in range(i+1,len(s)):\\n                if(s[i]==\\'(\\'):\\n                    if(s[j]==\\')\\'):\\n                        visited[i] = True\\n                        visited[j] = True\\n                print(i,j)"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), because the stack grows in size as the input string grows, and the maximum size of the stack is equal to the length of the input string.\\n\\nThe time complexity of this solution is O(n), because the function must iterate through the input string once and perform a constant amount of work for each character.\\n\\nTherefore, the overall complexity of this solution is O(n) in both space and time."
                    },
                    {
                        "username": "nikhrasuryansh",
                        "content": "WHAT DOES GIVEN BELOW ERROR MEAN ?\\n\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x0000003449b6 bp 0x7fffe67870f0 sp 0x7fffe6786fe0 T0)\\n==34==The signal is caused by a READ memory access.\\n==34==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #3 0x7f1f0a5ed0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==34==ABORTING"
                    }
                ]
            },
            {
                "id": 1738392,
                "content": [
                    {
                        "username": "ways",
                        "content": "What\\'s wrong with case \"{[]}\", it works for when I execute it in my pc but web still tells me that I\\'m failing that case XD"
                    },
                    {
                        "username": "bajipathak",
                        "content": "Why this gives a runtime error\\n=\\n\\n\\\\\\\\\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<int> st;\\n        st.push(s[0]);\\n        for(int i=1;i<s.length();i++){\\n            cout<<st.top()<<s[i]-1;\\n            if(st.empty()&&i==s.length()-1)\\n                return true;\\n            else if(st.empty())\\n                {\\n                    \\n                    st.push(s[i]);\\n                    i+=1;\\n                }\\n           if(st.top()+1==int(s[i])||st.top()+2==int(s[i])){\\n               st.pop();\\n           } \\n           else{\\n               st.push(s[i]);\\n           }\\n        }\\n    if(st.empty())\\n        return true;\\n    return false;\\n    }\\n}; \\\\\\\\"
                    },
                    {
                        "username": "_Prashant29",
                        "content": "whats wrong in this?????? i\\'m getting false only for every case\\n\\nclass Solution {\\n    public boolean isValid(String s) {\\n        char[] c = s.toCharArray();\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        for(int i=0;i<c.length;i++){\\n            if(map.containsKey(c[i])){\\n                map.replace(c[i],map.get(c[i])+1);\\n\\n            }else{\\n                map.put(c[i],1);\\n            }\\n        }\\n        boolean ok=true;\\n        for(Integer i:map.values()){\\n            if(i%2==1){\\n               ok=false;\\n            }\\n        }\\n        if(!ok){\\n           return false;\\n        }else{\\n            return true;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "WorthOnPython",
                        "content": "I don\\'t know why Im failing the TC \"(]\" I tested it on pycharm and passed but I keep failing it here.\\n\\nMy code:\\n\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        map = {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\\n        j = []\\n        k = []\\n        for i in s:\\n            if i in map:\\n                j.append(i)\\n            elif len(j) > 0 and i == map[j[-1]]:\\n                j.pop()\\n            else:\\n                k.append(\"False\")\\n\\n        if \"False\" not in k and len(j) == 0:\\n            return(\"true\")\\n        else:\\n            return(\"false\")"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/valid-parentheses-leet-code-20/"
                    },
                    {
                        "username": "charant587",
                        "content": "is anything wrong in my solution\\nclass Solution(object):\\n    def isValid(self, s):\\n        f=[]\\n        for i in range(0,len(s)-1):\\n\\n            if s[i] in (\\'(\\',\\'[\\',\\'{\\'):\\n                f.append(s[i])\\n            elif f[-1] == \"(\" and s[i]==\\')\\':\\n                f.pop()\\n            elif f[-1] == \"[\" and s[i]==\\']\\':\\n                f.pop()\\n            elif f[-1] == \"{\" and s[i]==\\'}\\':\\n                f.pop()\\n           \\n        if f is None :\\n            return True"
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\n    vector<char> dataStack;\\npublic:\\n    bool isValid(string s) {\\n        if(s.size() %2 !=0){\\n            return false;\\n        }\\n        if(s.size() == 0){\\n            return true;\\n        }\\n\\n        for(int i=0; i<s.size(); i++){\\n            dataStack.push_back(s[i]);\\n\\n            if(dataStack[dataStack.size() -1] == \\'}\\'){\\n                if(dataStack.size()> 1){\\n                    if(dataStack[dataStack.size()-2]==\\'{\\'){\\n                        dataStack.pop_back();\\n                        dataStack.pop_back();\\n                    }\\n                }\\n            }\\n            else if(dataStack[dataStack.size() -1] == \\')\\'){\\n                if(dataStack.size()> 1){\\n                    if(dataStack[dataStack.size()-2]==\\'(\\'){\\n                        dataStack.pop_back();\\n                        dataStack.pop_back();\\n                    }\\n                }\\n            }\\n            else if(dataStack[dataStack.size() -1] == \\']\\'){\\n                if(dataStack.size()> 1){\\n                    if(dataStack[dataStack.size()-2]==\\'[\\'){\\n                        dataStack.pop_back();\\n                        dataStack.pop_back();\\n                    }\\n                }\\n            }\\n        }\\n\\n        if(!dataStack.empty()){\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n};`"
                    },
                    {
                        "username": "sk33_f",
                        "content": "why is it not letting me set item. visited[i] ??\\n\\n    def isValid(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        visited = False * len(s)\\n        for i in range(0,len(s)):\\n            for j in range(i+1,len(s)):\\n                if(s[i]==\\'(\\'):\\n                    if(s[j]==\\')\\'):\\n                        visited[i] = True\\n                        visited[j] = True\\n                print(i,j)"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), because the stack grows in size as the input string grows, and the maximum size of the stack is equal to the length of the input string.\\n\\nThe time complexity of this solution is O(n), because the function must iterate through the input string once and perform a constant amount of work for each character.\\n\\nTherefore, the overall complexity of this solution is O(n) in both space and time."
                    },
                    {
                        "username": "nikhrasuryansh",
                        "content": "WHAT DOES GIVEN BELOW ERROR MEAN ?\\n\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x0000003449b6 bp 0x7fffe67870f0 sp 0x7fffe6786fe0 T0)\\n==34==The signal is caused by a READ memory access.\\n==34==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #3 0x7f1f0a5ed0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==34==ABORTING"
                    }
                ]
            },
            {
                "id": 1737701,
                "content": [
                    {
                        "username": "ways",
                        "content": "What\\'s wrong with case \"{[]}\", it works for when I execute it in my pc but web still tells me that I\\'m failing that case XD"
                    },
                    {
                        "username": "bajipathak",
                        "content": "Why this gives a runtime error\\n=\\n\\n\\\\\\\\\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<int> st;\\n        st.push(s[0]);\\n        for(int i=1;i<s.length();i++){\\n            cout<<st.top()<<s[i]-1;\\n            if(st.empty()&&i==s.length()-1)\\n                return true;\\n            else if(st.empty())\\n                {\\n                    \\n                    st.push(s[i]);\\n                    i+=1;\\n                }\\n           if(st.top()+1==int(s[i])||st.top()+2==int(s[i])){\\n               st.pop();\\n           } \\n           else{\\n               st.push(s[i]);\\n           }\\n        }\\n    if(st.empty())\\n        return true;\\n    return false;\\n    }\\n}; \\\\\\\\"
                    },
                    {
                        "username": "_Prashant29",
                        "content": "whats wrong in this?????? i\\'m getting false only for every case\\n\\nclass Solution {\\n    public boolean isValid(String s) {\\n        char[] c = s.toCharArray();\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        for(int i=0;i<c.length;i++){\\n            if(map.containsKey(c[i])){\\n                map.replace(c[i],map.get(c[i])+1);\\n\\n            }else{\\n                map.put(c[i],1);\\n            }\\n        }\\n        boolean ok=true;\\n        for(Integer i:map.values()){\\n            if(i%2==1){\\n               ok=false;\\n            }\\n        }\\n        if(!ok){\\n           return false;\\n        }else{\\n            return true;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "WorthOnPython",
                        "content": "I don\\'t know why Im failing the TC \"(]\" I tested it on pycharm and passed but I keep failing it here.\\n\\nMy code:\\n\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        map = {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\\n        j = []\\n        k = []\\n        for i in s:\\n            if i in map:\\n                j.append(i)\\n            elif len(j) > 0 and i == map[j[-1]]:\\n                j.pop()\\n            else:\\n                k.append(\"False\")\\n\\n        if \"False\" not in k and len(j) == 0:\\n            return(\"true\")\\n        else:\\n            return(\"false\")"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/valid-parentheses-leet-code-20/"
                    },
                    {
                        "username": "charant587",
                        "content": "is anything wrong in my solution\\nclass Solution(object):\\n    def isValid(self, s):\\n        f=[]\\n        for i in range(0,len(s)-1):\\n\\n            if s[i] in (\\'(\\',\\'[\\',\\'{\\'):\\n                f.append(s[i])\\n            elif f[-1] == \"(\" and s[i]==\\')\\':\\n                f.pop()\\n            elif f[-1] == \"[\" and s[i]==\\']\\':\\n                f.pop()\\n            elif f[-1] == \"{\" and s[i]==\\'}\\':\\n                f.pop()\\n           \\n        if f is None :\\n            return True"
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\n    vector<char> dataStack;\\npublic:\\n    bool isValid(string s) {\\n        if(s.size() %2 !=0){\\n            return false;\\n        }\\n        if(s.size() == 0){\\n            return true;\\n        }\\n\\n        for(int i=0; i<s.size(); i++){\\n            dataStack.push_back(s[i]);\\n\\n            if(dataStack[dataStack.size() -1] == \\'}\\'){\\n                if(dataStack.size()> 1){\\n                    if(dataStack[dataStack.size()-2]==\\'{\\'){\\n                        dataStack.pop_back();\\n                        dataStack.pop_back();\\n                    }\\n                }\\n            }\\n            else if(dataStack[dataStack.size() -1] == \\')\\'){\\n                if(dataStack.size()> 1){\\n                    if(dataStack[dataStack.size()-2]==\\'(\\'){\\n                        dataStack.pop_back();\\n                        dataStack.pop_back();\\n                    }\\n                }\\n            }\\n            else if(dataStack[dataStack.size() -1] == \\']\\'){\\n                if(dataStack.size()> 1){\\n                    if(dataStack[dataStack.size()-2]==\\'[\\'){\\n                        dataStack.pop_back();\\n                        dataStack.pop_back();\\n                    }\\n                }\\n            }\\n        }\\n\\n        if(!dataStack.empty()){\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n};`"
                    },
                    {
                        "username": "sk33_f",
                        "content": "why is it not letting me set item. visited[i] ??\\n\\n    def isValid(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        visited = False * len(s)\\n        for i in range(0,len(s)):\\n            for j in range(i+1,len(s)):\\n                if(s[i]==\\'(\\'):\\n                    if(s[j]==\\')\\'):\\n                        visited[i] = True\\n                        visited[j] = True\\n                print(i,j)"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), because the stack grows in size as the input string grows, and the maximum size of the stack is equal to the length of the input string.\\n\\nThe time complexity of this solution is O(n), because the function must iterate through the input string once and perform a constant amount of work for each character.\\n\\nTherefore, the overall complexity of this solution is O(n) in both space and time."
                    },
                    {
                        "username": "nikhrasuryansh",
                        "content": "WHAT DOES GIVEN BELOW ERROR MEAN ?\\n\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x0000003449b6 bp 0x7fffe67870f0 sp 0x7fffe6786fe0 T0)\\n==34==The signal is caused by a READ memory access.\\n==34==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #3 0x7f1f0a5ed0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==34==ABORTING"
                    }
                ]
            },
            {
                "id": 1735525,
                "content": [
                    {
                        "username": "ways",
                        "content": "What\\'s wrong with case \"{[]}\", it works for when I execute it in my pc but web still tells me that I\\'m failing that case XD"
                    },
                    {
                        "username": "bajipathak",
                        "content": "Why this gives a runtime error\\n=\\n\\n\\\\\\\\\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<int> st;\\n        st.push(s[0]);\\n        for(int i=1;i<s.length();i++){\\n            cout<<st.top()<<s[i]-1;\\n            if(st.empty()&&i==s.length()-1)\\n                return true;\\n            else if(st.empty())\\n                {\\n                    \\n                    st.push(s[i]);\\n                    i+=1;\\n                }\\n           if(st.top()+1==int(s[i])||st.top()+2==int(s[i])){\\n               st.pop();\\n           } \\n           else{\\n               st.push(s[i]);\\n           }\\n        }\\n    if(st.empty())\\n        return true;\\n    return false;\\n    }\\n}; \\\\\\\\"
                    },
                    {
                        "username": "_Prashant29",
                        "content": "whats wrong in this?????? i\\'m getting false only for every case\\n\\nclass Solution {\\n    public boolean isValid(String s) {\\n        char[] c = s.toCharArray();\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        for(int i=0;i<c.length;i++){\\n            if(map.containsKey(c[i])){\\n                map.replace(c[i],map.get(c[i])+1);\\n\\n            }else{\\n                map.put(c[i],1);\\n            }\\n        }\\n        boolean ok=true;\\n        for(Integer i:map.values()){\\n            if(i%2==1){\\n               ok=false;\\n            }\\n        }\\n        if(!ok){\\n           return false;\\n        }else{\\n            return true;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "WorthOnPython",
                        "content": "I don\\'t know why Im failing the TC \"(]\" I tested it on pycharm and passed but I keep failing it here.\\n\\nMy code:\\n\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        map = {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\\n        j = []\\n        k = []\\n        for i in s:\\n            if i in map:\\n                j.append(i)\\n            elif len(j) > 0 and i == map[j[-1]]:\\n                j.pop()\\n            else:\\n                k.append(\"False\")\\n\\n        if \"False\" not in k and len(j) == 0:\\n            return(\"true\")\\n        else:\\n            return(\"false\")"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/valid-parentheses-leet-code-20/"
                    },
                    {
                        "username": "charant587",
                        "content": "is anything wrong in my solution\\nclass Solution(object):\\n    def isValid(self, s):\\n        f=[]\\n        for i in range(0,len(s)-1):\\n\\n            if s[i] in (\\'(\\',\\'[\\',\\'{\\'):\\n                f.append(s[i])\\n            elif f[-1] == \"(\" and s[i]==\\')\\':\\n                f.pop()\\n            elif f[-1] == \"[\" and s[i]==\\']\\':\\n                f.pop()\\n            elif f[-1] == \"{\" and s[i]==\\'}\\':\\n                f.pop()\\n           \\n        if f is None :\\n            return True"
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\n    vector<char> dataStack;\\npublic:\\n    bool isValid(string s) {\\n        if(s.size() %2 !=0){\\n            return false;\\n        }\\n        if(s.size() == 0){\\n            return true;\\n        }\\n\\n        for(int i=0; i<s.size(); i++){\\n            dataStack.push_back(s[i]);\\n\\n            if(dataStack[dataStack.size() -1] == \\'}\\'){\\n                if(dataStack.size()> 1){\\n                    if(dataStack[dataStack.size()-2]==\\'{\\'){\\n                        dataStack.pop_back();\\n                        dataStack.pop_back();\\n                    }\\n                }\\n            }\\n            else if(dataStack[dataStack.size() -1] == \\')\\'){\\n                if(dataStack.size()> 1){\\n                    if(dataStack[dataStack.size()-2]==\\'(\\'){\\n                        dataStack.pop_back();\\n                        dataStack.pop_back();\\n                    }\\n                }\\n            }\\n            else if(dataStack[dataStack.size() -1] == \\']\\'){\\n                if(dataStack.size()> 1){\\n                    if(dataStack[dataStack.size()-2]==\\'[\\'){\\n                        dataStack.pop_back();\\n                        dataStack.pop_back();\\n                    }\\n                }\\n            }\\n        }\\n\\n        if(!dataStack.empty()){\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n};`"
                    },
                    {
                        "username": "sk33_f",
                        "content": "why is it not letting me set item. visited[i] ??\\n\\n    def isValid(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        visited = False * len(s)\\n        for i in range(0,len(s)):\\n            for j in range(i+1,len(s)):\\n                if(s[i]==\\'(\\'):\\n                    if(s[j]==\\')\\'):\\n                        visited[i] = True\\n                        visited[j] = True\\n                print(i,j)"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), because the stack grows in size as the input string grows, and the maximum size of the stack is equal to the length of the input string.\\n\\nThe time complexity of this solution is O(n), because the function must iterate through the input string once and perform a constant amount of work for each character.\\n\\nTherefore, the overall complexity of this solution is O(n) in both space and time."
                    },
                    {
                        "username": "nikhrasuryansh",
                        "content": "WHAT DOES GIVEN BELOW ERROR MEAN ?\\n\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x0000003449b6 bp 0x7fffe67870f0 sp 0x7fffe6786fe0 T0)\\n==34==The signal is caused by a READ memory access.\\n==34==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #3 0x7f1f0a5ed0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==34==ABORTING"
                    }
                ]
            },
            {
                "id": 1734563,
                "content": [
                    {
                        "username": "ways",
                        "content": "What\\'s wrong with case \"{[]}\", it works for when I execute it in my pc but web still tells me that I\\'m failing that case XD"
                    },
                    {
                        "username": "bajipathak",
                        "content": "Why this gives a runtime error\\n=\\n\\n\\\\\\\\\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<int> st;\\n        st.push(s[0]);\\n        for(int i=1;i<s.length();i++){\\n            cout<<st.top()<<s[i]-1;\\n            if(st.empty()&&i==s.length()-1)\\n                return true;\\n            else if(st.empty())\\n                {\\n                    \\n                    st.push(s[i]);\\n                    i+=1;\\n                }\\n           if(st.top()+1==int(s[i])||st.top()+2==int(s[i])){\\n               st.pop();\\n           } \\n           else{\\n               st.push(s[i]);\\n           }\\n        }\\n    if(st.empty())\\n        return true;\\n    return false;\\n    }\\n}; \\\\\\\\"
                    },
                    {
                        "username": "_Prashant29",
                        "content": "whats wrong in this?????? i\\'m getting false only for every case\\n\\nclass Solution {\\n    public boolean isValid(String s) {\\n        char[] c = s.toCharArray();\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        for(int i=0;i<c.length;i++){\\n            if(map.containsKey(c[i])){\\n                map.replace(c[i],map.get(c[i])+1);\\n\\n            }else{\\n                map.put(c[i],1);\\n            }\\n        }\\n        boolean ok=true;\\n        for(Integer i:map.values()){\\n            if(i%2==1){\\n               ok=false;\\n            }\\n        }\\n        if(!ok){\\n           return false;\\n        }else{\\n            return true;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "WorthOnPython",
                        "content": "I don\\'t know why Im failing the TC \"(]\" I tested it on pycharm and passed but I keep failing it here.\\n\\nMy code:\\n\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        map = {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\\n        j = []\\n        k = []\\n        for i in s:\\n            if i in map:\\n                j.append(i)\\n            elif len(j) > 0 and i == map[j[-1]]:\\n                j.pop()\\n            else:\\n                k.append(\"False\")\\n\\n        if \"False\" not in k and len(j) == 0:\\n            return(\"true\")\\n        else:\\n            return(\"false\")"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/valid-parentheses-leet-code-20/"
                    },
                    {
                        "username": "charant587",
                        "content": "is anything wrong in my solution\\nclass Solution(object):\\n    def isValid(self, s):\\n        f=[]\\n        for i in range(0,len(s)-1):\\n\\n            if s[i] in (\\'(\\',\\'[\\',\\'{\\'):\\n                f.append(s[i])\\n            elif f[-1] == \"(\" and s[i]==\\')\\':\\n                f.pop()\\n            elif f[-1] == \"[\" and s[i]==\\']\\':\\n                f.pop()\\n            elif f[-1] == \"{\" and s[i]==\\'}\\':\\n                f.pop()\\n           \\n        if f is None :\\n            return True"
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\n    vector<char> dataStack;\\npublic:\\n    bool isValid(string s) {\\n        if(s.size() %2 !=0){\\n            return false;\\n        }\\n        if(s.size() == 0){\\n            return true;\\n        }\\n\\n        for(int i=0; i<s.size(); i++){\\n            dataStack.push_back(s[i]);\\n\\n            if(dataStack[dataStack.size() -1] == \\'}\\'){\\n                if(dataStack.size()> 1){\\n                    if(dataStack[dataStack.size()-2]==\\'{\\'){\\n                        dataStack.pop_back();\\n                        dataStack.pop_back();\\n                    }\\n                }\\n            }\\n            else if(dataStack[dataStack.size() -1] == \\')\\'){\\n                if(dataStack.size()> 1){\\n                    if(dataStack[dataStack.size()-2]==\\'(\\'){\\n                        dataStack.pop_back();\\n                        dataStack.pop_back();\\n                    }\\n                }\\n            }\\n            else if(dataStack[dataStack.size() -1] == \\']\\'){\\n                if(dataStack.size()> 1){\\n                    if(dataStack[dataStack.size()-2]==\\'[\\'){\\n                        dataStack.pop_back();\\n                        dataStack.pop_back();\\n                    }\\n                }\\n            }\\n        }\\n\\n        if(!dataStack.empty()){\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n};`"
                    },
                    {
                        "username": "sk33_f",
                        "content": "why is it not letting me set item. visited[i] ??\\n\\n    def isValid(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        visited = False * len(s)\\n        for i in range(0,len(s)):\\n            for j in range(i+1,len(s)):\\n                if(s[i]==\\'(\\'):\\n                    if(s[j]==\\')\\'):\\n                        visited[i] = True\\n                        visited[j] = True\\n                print(i,j)"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), because the stack grows in size as the input string grows, and the maximum size of the stack is equal to the length of the input string.\\n\\nThe time complexity of this solution is O(n), because the function must iterate through the input string once and perform a constant amount of work for each character.\\n\\nTherefore, the overall complexity of this solution is O(n) in both space and time."
                    },
                    {
                        "username": "nikhrasuryansh",
                        "content": "WHAT DOES GIVEN BELOW ERROR MEAN ?\\n\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x0000003449b6 bp 0x7fffe67870f0 sp 0x7fffe6786fe0 T0)\\n==34==The signal is caused by a READ memory access.\\n==34==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #3 0x7f1f0a5ed0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==34==ABORTING"
                    }
                ]
            },
            {
                "id": 1734284,
                "content": [
                    {
                        "username": "ways",
                        "content": "What\\'s wrong with case \"{[]}\", it works for when I execute it in my pc but web still tells me that I\\'m failing that case XD"
                    },
                    {
                        "username": "bajipathak",
                        "content": "Why this gives a runtime error\\n=\\n\\n\\\\\\\\\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<int> st;\\n        st.push(s[0]);\\n        for(int i=1;i<s.length();i++){\\n            cout<<st.top()<<s[i]-1;\\n            if(st.empty()&&i==s.length()-1)\\n                return true;\\n            else if(st.empty())\\n                {\\n                    \\n                    st.push(s[i]);\\n                    i+=1;\\n                }\\n           if(st.top()+1==int(s[i])||st.top()+2==int(s[i])){\\n               st.pop();\\n           } \\n           else{\\n               st.push(s[i]);\\n           }\\n        }\\n    if(st.empty())\\n        return true;\\n    return false;\\n    }\\n}; \\\\\\\\"
                    },
                    {
                        "username": "_Prashant29",
                        "content": "whats wrong in this?????? i\\'m getting false only for every case\\n\\nclass Solution {\\n    public boolean isValid(String s) {\\n        char[] c = s.toCharArray();\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        for(int i=0;i<c.length;i++){\\n            if(map.containsKey(c[i])){\\n                map.replace(c[i],map.get(c[i])+1);\\n\\n            }else{\\n                map.put(c[i],1);\\n            }\\n        }\\n        boolean ok=true;\\n        for(Integer i:map.values()){\\n            if(i%2==1){\\n               ok=false;\\n            }\\n        }\\n        if(!ok){\\n           return false;\\n        }else{\\n            return true;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "WorthOnPython",
                        "content": "I don\\'t know why Im failing the TC \"(]\" I tested it on pycharm and passed but I keep failing it here.\\n\\nMy code:\\n\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        map = {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\\n        j = []\\n        k = []\\n        for i in s:\\n            if i in map:\\n                j.append(i)\\n            elif len(j) > 0 and i == map[j[-1]]:\\n                j.pop()\\n            else:\\n                k.append(\"False\")\\n\\n        if \"False\" not in k and len(j) == 0:\\n            return(\"true\")\\n        else:\\n            return(\"false\")"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/valid-parentheses-leet-code-20/"
                    },
                    {
                        "username": "charant587",
                        "content": "is anything wrong in my solution\\nclass Solution(object):\\n    def isValid(self, s):\\n        f=[]\\n        for i in range(0,len(s)-1):\\n\\n            if s[i] in (\\'(\\',\\'[\\',\\'{\\'):\\n                f.append(s[i])\\n            elif f[-1] == \"(\" and s[i]==\\')\\':\\n                f.pop()\\n            elif f[-1] == \"[\" and s[i]==\\']\\':\\n                f.pop()\\n            elif f[-1] == \"{\" and s[i]==\\'}\\':\\n                f.pop()\\n           \\n        if f is None :\\n            return True"
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\n    vector<char> dataStack;\\npublic:\\n    bool isValid(string s) {\\n        if(s.size() %2 !=0){\\n            return false;\\n        }\\n        if(s.size() == 0){\\n            return true;\\n        }\\n\\n        for(int i=0; i<s.size(); i++){\\n            dataStack.push_back(s[i]);\\n\\n            if(dataStack[dataStack.size() -1] == \\'}\\'){\\n                if(dataStack.size()> 1){\\n                    if(dataStack[dataStack.size()-2]==\\'{\\'){\\n                        dataStack.pop_back();\\n                        dataStack.pop_back();\\n                    }\\n                }\\n            }\\n            else if(dataStack[dataStack.size() -1] == \\')\\'){\\n                if(dataStack.size()> 1){\\n                    if(dataStack[dataStack.size()-2]==\\'(\\'){\\n                        dataStack.pop_back();\\n                        dataStack.pop_back();\\n                    }\\n                }\\n            }\\n            else if(dataStack[dataStack.size() -1] == \\']\\'){\\n                if(dataStack.size()> 1){\\n                    if(dataStack[dataStack.size()-2]==\\'[\\'){\\n                        dataStack.pop_back();\\n                        dataStack.pop_back();\\n                    }\\n                }\\n            }\\n        }\\n\\n        if(!dataStack.empty()){\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n};`"
                    },
                    {
                        "username": "sk33_f",
                        "content": "why is it not letting me set item. visited[i] ??\\n\\n    def isValid(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        visited = False * len(s)\\n        for i in range(0,len(s)):\\n            for j in range(i+1,len(s)):\\n                if(s[i]==\\'(\\'):\\n                    if(s[j]==\\')\\'):\\n                        visited[i] = True\\n                        visited[j] = True\\n                print(i,j)"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), because the stack grows in size as the input string grows, and the maximum size of the stack is equal to the length of the input string.\\n\\nThe time complexity of this solution is O(n), because the function must iterate through the input string once and perform a constant amount of work for each character.\\n\\nTherefore, the overall complexity of this solution is O(n) in both space and time."
                    },
                    {
                        "username": "nikhrasuryansh",
                        "content": "WHAT DOES GIVEN BELOW ERROR MEAN ?\\n\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x0000003449b6 bp 0x7fffe67870f0 sp 0x7fffe6786fe0 T0)\\n==34==The signal is caused by a READ memory access.\\n==34==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #3 0x7f1f0a5ed0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==34==ABORTING"
                    }
                ]
            },
            {
                "id": 1733468,
                "content": [
                    {
                        "username": "ways",
                        "content": "What\\'s wrong with case \"{[]}\", it works for when I execute it in my pc but web still tells me that I\\'m failing that case XD"
                    },
                    {
                        "username": "bajipathak",
                        "content": "Why this gives a runtime error\\n=\\n\\n\\\\\\\\\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<int> st;\\n        st.push(s[0]);\\n        for(int i=1;i<s.length();i++){\\n            cout<<st.top()<<s[i]-1;\\n            if(st.empty()&&i==s.length()-1)\\n                return true;\\n            else if(st.empty())\\n                {\\n                    \\n                    st.push(s[i]);\\n                    i+=1;\\n                }\\n           if(st.top()+1==int(s[i])||st.top()+2==int(s[i])){\\n               st.pop();\\n           } \\n           else{\\n               st.push(s[i]);\\n           }\\n        }\\n    if(st.empty())\\n        return true;\\n    return false;\\n    }\\n}; \\\\\\\\"
                    },
                    {
                        "username": "_Prashant29",
                        "content": "whats wrong in this?????? i\\'m getting false only for every case\\n\\nclass Solution {\\n    public boolean isValid(String s) {\\n        char[] c = s.toCharArray();\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        for(int i=0;i<c.length;i++){\\n            if(map.containsKey(c[i])){\\n                map.replace(c[i],map.get(c[i])+1);\\n\\n            }else{\\n                map.put(c[i],1);\\n            }\\n        }\\n        boolean ok=true;\\n        for(Integer i:map.values()){\\n            if(i%2==1){\\n               ok=false;\\n            }\\n        }\\n        if(!ok){\\n           return false;\\n        }else{\\n            return true;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "WorthOnPython",
                        "content": "I don\\'t know why Im failing the TC \"(]\" I tested it on pycharm and passed but I keep failing it here.\\n\\nMy code:\\n\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        map = {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\\n        j = []\\n        k = []\\n        for i in s:\\n            if i in map:\\n                j.append(i)\\n            elif len(j) > 0 and i == map[j[-1]]:\\n                j.pop()\\n            else:\\n                k.append(\"False\")\\n\\n        if \"False\" not in k and len(j) == 0:\\n            return(\"true\")\\n        else:\\n            return(\"false\")"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/valid-parentheses-leet-code-20/"
                    },
                    {
                        "username": "charant587",
                        "content": "is anything wrong in my solution\\nclass Solution(object):\\n    def isValid(self, s):\\n        f=[]\\n        for i in range(0,len(s)-1):\\n\\n            if s[i] in (\\'(\\',\\'[\\',\\'{\\'):\\n                f.append(s[i])\\n            elif f[-1] == \"(\" and s[i]==\\')\\':\\n                f.pop()\\n            elif f[-1] == \"[\" and s[i]==\\']\\':\\n                f.pop()\\n            elif f[-1] == \"{\" and s[i]==\\'}\\':\\n                f.pop()\\n           \\n        if f is None :\\n            return True"
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\n    vector<char> dataStack;\\npublic:\\n    bool isValid(string s) {\\n        if(s.size() %2 !=0){\\n            return false;\\n        }\\n        if(s.size() == 0){\\n            return true;\\n        }\\n\\n        for(int i=0; i<s.size(); i++){\\n            dataStack.push_back(s[i]);\\n\\n            if(dataStack[dataStack.size() -1] == \\'}\\'){\\n                if(dataStack.size()> 1){\\n                    if(dataStack[dataStack.size()-2]==\\'{\\'){\\n                        dataStack.pop_back();\\n                        dataStack.pop_back();\\n                    }\\n                }\\n            }\\n            else if(dataStack[dataStack.size() -1] == \\')\\'){\\n                if(dataStack.size()> 1){\\n                    if(dataStack[dataStack.size()-2]==\\'(\\'){\\n                        dataStack.pop_back();\\n                        dataStack.pop_back();\\n                    }\\n                }\\n            }\\n            else if(dataStack[dataStack.size() -1] == \\']\\'){\\n                if(dataStack.size()> 1){\\n                    if(dataStack[dataStack.size()-2]==\\'[\\'){\\n                        dataStack.pop_back();\\n                        dataStack.pop_back();\\n                    }\\n                }\\n            }\\n        }\\n\\n        if(!dataStack.empty()){\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n};`"
                    },
                    {
                        "username": "sk33_f",
                        "content": "why is it not letting me set item. visited[i] ??\\n\\n    def isValid(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        visited = False * len(s)\\n        for i in range(0,len(s)):\\n            for j in range(i+1,len(s)):\\n                if(s[i]==\\'(\\'):\\n                    if(s[j]==\\')\\'):\\n                        visited[i] = True\\n                        visited[j] = True\\n                print(i,j)"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), because the stack grows in size as the input string grows, and the maximum size of the stack is equal to the length of the input string.\\n\\nThe time complexity of this solution is O(n), because the function must iterate through the input string once and perform a constant amount of work for each character.\\n\\nTherefore, the overall complexity of this solution is O(n) in both space and time."
                    },
                    {
                        "username": "nikhrasuryansh",
                        "content": "WHAT DOES GIVEN BELOW ERROR MEAN ?\\n\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x0000003449b6 bp 0x7fffe67870f0 sp 0x7fffe6786fe0 T0)\\n==34==The signal is caused by a READ memory access.\\n==34==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #3 0x7f1f0a5ed0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==34==ABORTING"
                    }
                ]
            },
            {
                "id": 1733450,
                "content": [
                    {
                        "username": "ways",
                        "content": "What\\'s wrong with case \"{[]}\", it works for when I execute it in my pc but web still tells me that I\\'m failing that case XD"
                    },
                    {
                        "username": "bajipathak",
                        "content": "Why this gives a runtime error\\n=\\n\\n\\\\\\\\\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<int> st;\\n        st.push(s[0]);\\n        for(int i=1;i<s.length();i++){\\n            cout<<st.top()<<s[i]-1;\\n            if(st.empty()&&i==s.length()-1)\\n                return true;\\n            else if(st.empty())\\n                {\\n                    \\n                    st.push(s[i]);\\n                    i+=1;\\n                }\\n           if(st.top()+1==int(s[i])||st.top()+2==int(s[i])){\\n               st.pop();\\n           } \\n           else{\\n               st.push(s[i]);\\n           }\\n        }\\n    if(st.empty())\\n        return true;\\n    return false;\\n    }\\n}; \\\\\\\\"
                    },
                    {
                        "username": "_Prashant29",
                        "content": "whats wrong in this?????? i\\'m getting false only for every case\\n\\nclass Solution {\\n    public boolean isValid(String s) {\\n        char[] c = s.toCharArray();\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        for(int i=0;i<c.length;i++){\\n            if(map.containsKey(c[i])){\\n                map.replace(c[i],map.get(c[i])+1);\\n\\n            }else{\\n                map.put(c[i],1);\\n            }\\n        }\\n        boolean ok=true;\\n        for(Integer i:map.values()){\\n            if(i%2==1){\\n               ok=false;\\n            }\\n        }\\n        if(!ok){\\n           return false;\\n        }else{\\n            return true;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "WorthOnPython",
                        "content": "I don\\'t know why Im failing the TC \"(]\" I tested it on pycharm and passed but I keep failing it here.\\n\\nMy code:\\n\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        map = {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\\n        j = []\\n        k = []\\n        for i in s:\\n            if i in map:\\n                j.append(i)\\n            elif len(j) > 0 and i == map[j[-1]]:\\n                j.pop()\\n            else:\\n                k.append(\"False\")\\n\\n        if \"False\" not in k and len(j) == 0:\\n            return(\"true\")\\n        else:\\n            return(\"false\")"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/valid-parentheses-leet-code-20/"
                    },
                    {
                        "username": "charant587",
                        "content": "is anything wrong in my solution\\nclass Solution(object):\\n    def isValid(self, s):\\n        f=[]\\n        for i in range(0,len(s)-1):\\n\\n            if s[i] in (\\'(\\',\\'[\\',\\'{\\'):\\n                f.append(s[i])\\n            elif f[-1] == \"(\" and s[i]==\\')\\':\\n                f.pop()\\n            elif f[-1] == \"[\" and s[i]==\\']\\':\\n                f.pop()\\n            elif f[-1] == \"{\" and s[i]==\\'}\\':\\n                f.pop()\\n           \\n        if f is None :\\n            return True"
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\n    vector<char> dataStack;\\npublic:\\n    bool isValid(string s) {\\n        if(s.size() %2 !=0){\\n            return false;\\n        }\\n        if(s.size() == 0){\\n            return true;\\n        }\\n\\n        for(int i=0; i<s.size(); i++){\\n            dataStack.push_back(s[i]);\\n\\n            if(dataStack[dataStack.size() -1] == \\'}\\'){\\n                if(dataStack.size()> 1){\\n                    if(dataStack[dataStack.size()-2]==\\'{\\'){\\n                        dataStack.pop_back();\\n                        dataStack.pop_back();\\n                    }\\n                }\\n            }\\n            else if(dataStack[dataStack.size() -1] == \\')\\'){\\n                if(dataStack.size()> 1){\\n                    if(dataStack[dataStack.size()-2]==\\'(\\'){\\n                        dataStack.pop_back();\\n                        dataStack.pop_back();\\n                    }\\n                }\\n            }\\n            else if(dataStack[dataStack.size() -1] == \\']\\'){\\n                if(dataStack.size()> 1){\\n                    if(dataStack[dataStack.size()-2]==\\'[\\'){\\n                        dataStack.pop_back();\\n                        dataStack.pop_back();\\n                    }\\n                }\\n            }\\n        }\\n\\n        if(!dataStack.empty()){\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n};`"
                    },
                    {
                        "username": "sk33_f",
                        "content": "why is it not letting me set item. visited[i] ??\\n\\n    def isValid(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        visited = False * len(s)\\n        for i in range(0,len(s)):\\n            for j in range(i+1,len(s)):\\n                if(s[i]==\\'(\\'):\\n                    if(s[j]==\\')\\'):\\n                        visited[i] = True\\n                        visited[j] = True\\n                print(i,j)"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), because the stack grows in size as the input string grows, and the maximum size of the stack is equal to the length of the input string.\\n\\nThe time complexity of this solution is O(n), because the function must iterate through the input string once and perform a constant amount of work for each character.\\n\\nTherefore, the overall complexity of this solution is O(n) in both space and time."
                    },
                    {
                        "username": "nikhrasuryansh",
                        "content": "WHAT DOES GIVEN BELOW ERROR MEAN ?\\n\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x0000003449b6 bp 0x7fffe67870f0 sp 0x7fffe6786fe0 T0)\\n==34==The signal is caused by a READ memory access.\\n==34==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #3 0x7f1f0a5ed0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==34==ABORTING"
                    }
                ]
            },
            {
                "id": 1733378,
                "content": [
                    {
                        "username": "ways",
                        "content": "What\\'s wrong with case \"{[]}\", it works for when I execute it in my pc but web still tells me that I\\'m failing that case XD"
                    },
                    {
                        "username": "bajipathak",
                        "content": "Why this gives a runtime error\\n=\\n\\n\\\\\\\\\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<int> st;\\n        st.push(s[0]);\\n        for(int i=1;i<s.length();i++){\\n            cout<<st.top()<<s[i]-1;\\n            if(st.empty()&&i==s.length()-1)\\n                return true;\\n            else if(st.empty())\\n                {\\n                    \\n                    st.push(s[i]);\\n                    i+=1;\\n                }\\n           if(st.top()+1==int(s[i])||st.top()+2==int(s[i])){\\n               st.pop();\\n           } \\n           else{\\n               st.push(s[i]);\\n           }\\n        }\\n    if(st.empty())\\n        return true;\\n    return false;\\n    }\\n}; \\\\\\\\"
                    },
                    {
                        "username": "_Prashant29",
                        "content": "whats wrong in this?????? i\\'m getting false only for every case\\n\\nclass Solution {\\n    public boolean isValid(String s) {\\n        char[] c = s.toCharArray();\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        for(int i=0;i<c.length;i++){\\n            if(map.containsKey(c[i])){\\n                map.replace(c[i],map.get(c[i])+1);\\n\\n            }else{\\n                map.put(c[i],1);\\n            }\\n        }\\n        boolean ok=true;\\n        for(Integer i:map.values()){\\n            if(i%2==1){\\n               ok=false;\\n            }\\n        }\\n        if(!ok){\\n           return false;\\n        }else{\\n            return true;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "WorthOnPython",
                        "content": "I don\\'t know why Im failing the TC \"(]\" I tested it on pycharm and passed but I keep failing it here.\\n\\nMy code:\\n\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        map = {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\\n        j = []\\n        k = []\\n        for i in s:\\n            if i in map:\\n                j.append(i)\\n            elif len(j) > 0 and i == map[j[-1]]:\\n                j.pop()\\n            else:\\n                k.append(\"False\")\\n\\n        if \"False\" not in k and len(j) == 0:\\n            return(\"true\")\\n        else:\\n            return(\"false\")"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/valid-parentheses-leet-code-20/"
                    },
                    {
                        "username": "charant587",
                        "content": "is anything wrong in my solution\\nclass Solution(object):\\n    def isValid(self, s):\\n        f=[]\\n        for i in range(0,len(s)-1):\\n\\n            if s[i] in (\\'(\\',\\'[\\',\\'{\\'):\\n                f.append(s[i])\\n            elif f[-1] == \"(\" and s[i]==\\')\\':\\n                f.pop()\\n            elif f[-1] == \"[\" and s[i]==\\']\\':\\n                f.pop()\\n            elif f[-1] == \"{\" and s[i]==\\'}\\':\\n                f.pop()\\n           \\n        if f is None :\\n            return True"
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\n    vector<char> dataStack;\\npublic:\\n    bool isValid(string s) {\\n        if(s.size() %2 !=0){\\n            return false;\\n        }\\n        if(s.size() == 0){\\n            return true;\\n        }\\n\\n        for(int i=0; i<s.size(); i++){\\n            dataStack.push_back(s[i]);\\n\\n            if(dataStack[dataStack.size() -1] == \\'}\\'){\\n                if(dataStack.size()> 1){\\n                    if(dataStack[dataStack.size()-2]==\\'{\\'){\\n                        dataStack.pop_back();\\n                        dataStack.pop_back();\\n                    }\\n                }\\n            }\\n            else if(dataStack[dataStack.size() -1] == \\')\\'){\\n                if(dataStack.size()> 1){\\n                    if(dataStack[dataStack.size()-2]==\\'(\\'){\\n                        dataStack.pop_back();\\n                        dataStack.pop_back();\\n                    }\\n                }\\n            }\\n            else if(dataStack[dataStack.size() -1] == \\']\\'){\\n                if(dataStack.size()> 1){\\n                    if(dataStack[dataStack.size()-2]==\\'[\\'){\\n                        dataStack.pop_back();\\n                        dataStack.pop_back();\\n                    }\\n                }\\n            }\\n        }\\n\\n        if(!dataStack.empty()){\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n};`"
                    },
                    {
                        "username": "sk33_f",
                        "content": "why is it not letting me set item. visited[i] ??\\n\\n    def isValid(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        visited = False * len(s)\\n        for i in range(0,len(s)):\\n            for j in range(i+1,len(s)):\\n                if(s[i]==\\'(\\'):\\n                    if(s[j]==\\')\\'):\\n                        visited[i] = True\\n                        visited[j] = True\\n                print(i,j)"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), because the stack grows in size as the input string grows, and the maximum size of the stack is equal to the length of the input string.\\n\\nThe time complexity of this solution is O(n), because the function must iterate through the input string once and perform a constant amount of work for each character.\\n\\nTherefore, the overall complexity of this solution is O(n) in both space and time."
                    },
                    {
                        "username": "nikhrasuryansh",
                        "content": "WHAT DOES GIVEN BELOW ERROR MEAN ?\\n\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x0000003449b6 bp 0x7fffe67870f0 sp 0x7fffe6786fe0 T0)\\n==34==The signal is caused by a READ memory access.\\n==34==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #3 0x7f1f0a5ed0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==34==ABORTING"
                    }
                ]
            },
            {
                "id": 1730481,
                "content": [
                    {
                        "username": "user4628p",
                        "content": "Best Java Solution T.C=O(n)\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> sh=new Stack<>();\\n        for(int i=0; i<s.length();i++) {\\n            char ch=s.charAt(i);\\n            if(ch==\\'(\\' || ch==\\'{\\'|| ch==\\'[\\'){\\n                sh.push(ch);\\n            }else{\\n                if(sh.isEmpty()){\\n                    return false;\\n                }\\n                if((sh.peek()==\\'(\\' && ch==\\')\\' ||sh.peek()==\\'[\\' && ch==\\']\\' || sh.peek()==\\'{\\' && ch==\\'}\\')){\\n                    sh.pop();\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(sh.isEmpty()){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "maitrayob",
                        "content": "what is wrong with this solution? I am running this code in a separate IDE and its passing all the public tests but one of the tests are failing here. here's the code:\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        s = list(s)\n        for i in range(len(s)-1):\n            a = 0\n            if s[i] == '(' and s[i+1] == ')':\n                a += 1\n            elif s[i] == '{' and s[i+1] == '}':\n                a += 1\n            elif s[i] == '[' and s[i+1] == ']':\n                a += 1\n            else:\n                continue\n        if a * 2 == len(s):\n            return True\n        else:\n            return False"
                    },
                    {
                        "username": "eduard92",
                        "content": "Nice testcase \"{[]}\".\\nYou know this isn\\'t a real interview to ask IF it requires validation for nested parentheses. "
                    },
                    {
                        "username": "bmagana5",
                        "content": "I made a DFA and generated a Regular Expression to solve for the first 50~ of the test cases. Didn't account for cases like \"{[]}\", which kind of threw a wrench into things lol. I'll try to come up with a better DFA in the meantime.\n\n*edited: fixed some poor grammar"
                    },
                    {
                        "username": "raka_7317",
                        "content": "Runtime Error\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x000000344abb bp 0x7ffce3daf010 sp 0x7ffce3daeee0 T0)\\n==34==The signal is caused by a READ memory access.\\n==34==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #3 0x7f3c7c5350b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==34==ABORTING\\n\\nCAN ANYONE TELL ME WHY IS THIS ERROR AND HOW TO RESOLV IT;\\n\\n\\n\\nclass Solution {\\npublic:\\n      bool isValid(string s) {\\n        stack<char> st;\\n        \\n        char a;\\n       int n=s.size();\\n       for(int i=0;i<n;i++){\\n            \\n            if(s[i]==\\'{\\' || s[i]==\\'(\\'|| s[i]==\\'[\\'){\\n                st.push(s[i]);\\n                continue;\\n            }\\n            if(st.empty()){\\n                return  false;\\n                break;\\n            }\\n            switch(s[i]){\\n                case \\')\\':\\n                    a=st.top();\\n                   st.pop();\\n                   if(a==\\'[\\'||a==\\'{\\'){\\n                       return false;\\n                       break;\\n                   } \\n                   case \\'}\\':\\n                    a=st.top();\\n                     st.pop();\\n                     if(a==\\'[\\'||a==\\'(\\'){\\n                       return false;\\n                       break;\\n                   }\\n                   case \\']\\':\\n                     a=st.top();\\n                     st.pop();\\n                     if(a==\\'(\\'||a==\\'{\\'){\\n                       return false;\\n                       break;\\n                   }\\n            }\\n       }\\n       return(st.empty());\\n    }\\n    \\n};"
                    },
                    {
                        "username": "tomho5",
                        "content": "\"([)]\" why would this be expected to output false?"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "this is not nested properly that means [ opens then it have to be closed before ) closes \nupvote if u understand the explanation "
                    },
                    {
                        "username": "msagor",
                        "content": "Can anyone PLEASE tell me why my code is wrong and not working ??? \\n\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack <char> stack;\\n        for(auto sign:s){\\n\\n            if(stack.empty()==true && sign==\\'}\\' || sign==\\'}\\' || sign ==\\']\\'){\\n                return false;\\n            }\\n\\n            if(sign==\\'(\\' || sign==\\'{\\' || sign==\\'[\\'){\\n                stack.push(sign);\\n            }else if(sign==\\')\\' && stack.top()==\\'(\\'){\\n                stack.pop();\\n            }else if(sign==\\'}\\' && stack.top()==\\'{\\'){\\n                stack.pop();\\n            }else if(sign==\\']\\' && stack.top()==\\'[\\'){\\n                stack.pop();\\n            }else{return false;}\\n        }\\n\\n        return stack.empty();\\n    }\\n};\\n"
                    },
                    {
                        "username": "st3n",
                        "content": "Looking at the examples given I had no way to know that nested brackets were allowed. I think the description should be changed or another example be added to show nested brackets because it was very frustrating to only see this when submitting. "
                    },
                    {
                        "username": "Jagadeeshravi",
                        "content": "What wrong with this code??:\\nworks fine in other compilers but not here\\n\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        dic = {\\'open\\':[\\'(\\',\\'{\\',\\'[\\'],\\'close\\':[\\')\\',\\'}\\',\\']\\']}\\n        out = \\'false\\'\\n        i=0\\n        \\n        while(len(s)%2 == 0 and len(s)>0):\\n            if s[i] in dic[\\'open\\'] :\\n                if s[i+1]!=dic[\\'close\\'][dic[\\'open\\'].index(s[i])]:\\n                    out = \\'false\\'\\n                    break\\n                else:\\n                    out = \\'true\\'\\n                    s = s[2:]\\n            \\n        print(out)"
                    },
                    {
                        "username": "lemmasamaha",
                        "content": "Why do a lot of the solutions use stack.pop()? couldn't we just do return true at the end of the function? I guess I'm not understanding how stack.pop() and return stack.empty() benefit the program anymore than just having return true at then end. \n\nedit: i also ran my code with return true at the end and it still passed the test cases"
                    },
                    {
                        "username": "lemmasamaha",
                        "content": "I think I understand, so I'll post here in case anyone had the same question. \n\nNote: explanation is based off this solution\n\nbool isValid(string s) {\n        stack<char> brackets;\n        for (auto i : s) {\n            if (i == '(' || i == '{' || i == '[') {\n                brackets.push(i);\n            } else {\n                if (brackets.empty() || (brackets.top() == '(' && i != ')') || (brackets.top() == '{' && i != '}') || (brackets.top() == '[' && i != ']')) {\n                    return false;\n                }\n                brackets.pop();\n            }   \n        }\n        return brackets.empty();\n    }\n\nFirst off, its important to note that the only parentheses that'll be pushed into the stack are the opening brackets. Let's use the example \"()\", we enter the for loop and the current index of i = 0 while the value of i = '('. Since i is an opening bracket at this point we push it into the stack and we start at the beginning of the for loop again. Now the index of i = 1 and the value of i = ')'. This skips over the \"if\" and enters the \"else\". At this point our stack isn't empty, so stack.top() == '(' and i = ')' is a closing bracket, so the if statement isn't satisfied. We then do stack.pop() (which will pop '(') because there is a corresponding closing bracket for the open bracket. Now outside of the for loop we return stack.empty() because if the stack is empty at this point we know that their a valid pair of brackets/parentheses. \n\nThis is a walkthrough of the entire code, but essentially even if return true does work instead of return stack.empty(), it doesn't utilize the stack."
                    }
                ]
            },
            {
                "id": 1730118,
                "content": [
                    {
                        "username": "user4628p",
                        "content": "Best Java Solution T.C=O(n)\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> sh=new Stack<>();\\n        for(int i=0; i<s.length();i++) {\\n            char ch=s.charAt(i);\\n            if(ch==\\'(\\' || ch==\\'{\\'|| ch==\\'[\\'){\\n                sh.push(ch);\\n            }else{\\n                if(sh.isEmpty()){\\n                    return false;\\n                }\\n                if((sh.peek()==\\'(\\' && ch==\\')\\' ||sh.peek()==\\'[\\' && ch==\\']\\' || sh.peek()==\\'{\\' && ch==\\'}\\')){\\n                    sh.pop();\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(sh.isEmpty()){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "maitrayob",
                        "content": "what is wrong with this solution? I am running this code in a separate IDE and its passing all the public tests but one of the tests are failing here. here's the code:\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        s = list(s)\n        for i in range(len(s)-1):\n            a = 0\n            if s[i] == '(' and s[i+1] == ')':\n                a += 1\n            elif s[i] == '{' and s[i+1] == '}':\n                a += 1\n            elif s[i] == '[' and s[i+1] == ']':\n                a += 1\n            else:\n                continue\n        if a * 2 == len(s):\n            return True\n        else:\n            return False"
                    },
                    {
                        "username": "eduard92",
                        "content": "Nice testcase \"{[]}\".\\nYou know this isn\\'t a real interview to ask IF it requires validation for nested parentheses. "
                    },
                    {
                        "username": "bmagana5",
                        "content": "I made a DFA and generated a Regular Expression to solve for the first 50~ of the test cases. Didn't account for cases like \"{[]}\", which kind of threw a wrench into things lol. I'll try to come up with a better DFA in the meantime.\n\n*edited: fixed some poor grammar"
                    },
                    {
                        "username": "raka_7317",
                        "content": "Runtime Error\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x000000344abb bp 0x7ffce3daf010 sp 0x7ffce3daeee0 T0)\\n==34==The signal is caused by a READ memory access.\\n==34==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #3 0x7f3c7c5350b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==34==ABORTING\\n\\nCAN ANYONE TELL ME WHY IS THIS ERROR AND HOW TO RESOLV IT;\\n\\n\\n\\nclass Solution {\\npublic:\\n      bool isValid(string s) {\\n        stack<char> st;\\n        \\n        char a;\\n       int n=s.size();\\n       for(int i=0;i<n;i++){\\n            \\n            if(s[i]==\\'{\\' || s[i]==\\'(\\'|| s[i]==\\'[\\'){\\n                st.push(s[i]);\\n                continue;\\n            }\\n            if(st.empty()){\\n                return  false;\\n                break;\\n            }\\n            switch(s[i]){\\n                case \\')\\':\\n                    a=st.top();\\n                   st.pop();\\n                   if(a==\\'[\\'||a==\\'{\\'){\\n                       return false;\\n                       break;\\n                   } \\n                   case \\'}\\':\\n                    a=st.top();\\n                     st.pop();\\n                     if(a==\\'[\\'||a==\\'(\\'){\\n                       return false;\\n                       break;\\n                   }\\n                   case \\']\\':\\n                     a=st.top();\\n                     st.pop();\\n                     if(a==\\'(\\'||a==\\'{\\'){\\n                       return false;\\n                       break;\\n                   }\\n            }\\n       }\\n       return(st.empty());\\n    }\\n    \\n};"
                    },
                    {
                        "username": "tomho5",
                        "content": "\"([)]\" why would this be expected to output false?"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "this is not nested properly that means [ opens then it have to be closed before ) closes \nupvote if u understand the explanation "
                    },
                    {
                        "username": "msagor",
                        "content": "Can anyone PLEASE tell me why my code is wrong and not working ??? \\n\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack <char> stack;\\n        for(auto sign:s){\\n\\n            if(stack.empty()==true && sign==\\'}\\' || sign==\\'}\\' || sign ==\\']\\'){\\n                return false;\\n            }\\n\\n            if(sign==\\'(\\' || sign==\\'{\\' || sign==\\'[\\'){\\n                stack.push(sign);\\n            }else if(sign==\\')\\' && stack.top()==\\'(\\'){\\n                stack.pop();\\n            }else if(sign==\\'}\\' && stack.top()==\\'{\\'){\\n                stack.pop();\\n            }else if(sign==\\']\\' && stack.top()==\\'[\\'){\\n                stack.pop();\\n            }else{return false;}\\n        }\\n\\n        return stack.empty();\\n    }\\n};\\n"
                    },
                    {
                        "username": "st3n",
                        "content": "Looking at the examples given I had no way to know that nested brackets were allowed. I think the description should be changed or another example be added to show nested brackets because it was very frustrating to only see this when submitting. "
                    },
                    {
                        "username": "Jagadeeshravi",
                        "content": "What wrong with this code??:\\nworks fine in other compilers but not here\\n\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        dic = {\\'open\\':[\\'(\\',\\'{\\',\\'[\\'],\\'close\\':[\\')\\',\\'}\\',\\']\\']}\\n        out = \\'false\\'\\n        i=0\\n        \\n        while(len(s)%2 == 0 and len(s)>0):\\n            if s[i] in dic[\\'open\\'] :\\n                if s[i+1]!=dic[\\'close\\'][dic[\\'open\\'].index(s[i])]:\\n                    out = \\'false\\'\\n                    break\\n                else:\\n                    out = \\'true\\'\\n                    s = s[2:]\\n            \\n        print(out)"
                    },
                    {
                        "username": "lemmasamaha",
                        "content": "Why do a lot of the solutions use stack.pop()? couldn't we just do return true at the end of the function? I guess I'm not understanding how stack.pop() and return stack.empty() benefit the program anymore than just having return true at then end. \n\nedit: i also ran my code with return true at the end and it still passed the test cases"
                    },
                    {
                        "username": "lemmasamaha",
                        "content": "I think I understand, so I'll post here in case anyone had the same question. \n\nNote: explanation is based off this solution\n\nbool isValid(string s) {\n        stack<char> brackets;\n        for (auto i : s) {\n            if (i == '(' || i == '{' || i == '[') {\n                brackets.push(i);\n            } else {\n                if (brackets.empty() || (brackets.top() == '(' && i != ')') || (brackets.top() == '{' && i != '}') || (brackets.top() == '[' && i != ']')) {\n                    return false;\n                }\n                brackets.pop();\n            }   \n        }\n        return brackets.empty();\n    }\n\nFirst off, its important to note that the only parentheses that'll be pushed into the stack are the opening brackets. Let's use the example \"()\", we enter the for loop and the current index of i = 0 while the value of i = '('. Since i is an opening bracket at this point we push it into the stack and we start at the beginning of the for loop again. Now the index of i = 1 and the value of i = ')'. This skips over the \"if\" and enters the \"else\". At this point our stack isn't empty, so stack.top() == '(' and i = ')' is a closing bracket, so the if statement isn't satisfied. We then do stack.pop() (which will pop '(') because there is a corresponding closing bracket for the open bracket. Now outside of the for loop we return stack.empty() because if the stack is empty at this point we know that their a valid pair of brackets/parentheses. \n\nThis is a walkthrough of the entire code, but essentially even if return true does work instead of return stack.empty(), it doesn't utilize the stack."
                    }
                ]
            },
            {
                "id": 1729078,
                "content": [
                    {
                        "username": "user4628p",
                        "content": "Best Java Solution T.C=O(n)\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> sh=new Stack<>();\\n        for(int i=0; i<s.length();i++) {\\n            char ch=s.charAt(i);\\n            if(ch==\\'(\\' || ch==\\'{\\'|| ch==\\'[\\'){\\n                sh.push(ch);\\n            }else{\\n                if(sh.isEmpty()){\\n                    return false;\\n                }\\n                if((sh.peek()==\\'(\\' && ch==\\')\\' ||sh.peek()==\\'[\\' && ch==\\']\\' || sh.peek()==\\'{\\' && ch==\\'}\\')){\\n                    sh.pop();\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(sh.isEmpty()){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "maitrayob",
                        "content": "what is wrong with this solution? I am running this code in a separate IDE and its passing all the public tests but one of the tests are failing here. here's the code:\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        s = list(s)\n        for i in range(len(s)-1):\n            a = 0\n            if s[i] == '(' and s[i+1] == ')':\n                a += 1\n            elif s[i] == '{' and s[i+1] == '}':\n                a += 1\n            elif s[i] == '[' and s[i+1] == ']':\n                a += 1\n            else:\n                continue\n        if a * 2 == len(s):\n            return True\n        else:\n            return False"
                    },
                    {
                        "username": "eduard92",
                        "content": "Nice testcase \"{[]}\".\\nYou know this isn\\'t a real interview to ask IF it requires validation for nested parentheses. "
                    },
                    {
                        "username": "bmagana5",
                        "content": "I made a DFA and generated a Regular Expression to solve for the first 50~ of the test cases. Didn't account for cases like \"{[]}\", which kind of threw a wrench into things lol. I'll try to come up with a better DFA in the meantime.\n\n*edited: fixed some poor grammar"
                    },
                    {
                        "username": "raka_7317",
                        "content": "Runtime Error\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x000000344abb bp 0x7ffce3daf010 sp 0x7ffce3daeee0 T0)\\n==34==The signal is caused by a READ memory access.\\n==34==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #3 0x7f3c7c5350b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==34==ABORTING\\n\\nCAN ANYONE TELL ME WHY IS THIS ERROR AND HOW TO RESOLV IT;\\n\\n\\n\\nclass Solution {\\npublic:\\n      bool isValid(string s) {\\n        stack<char> st;\\n        \\n        char a;\\n       int n=s.size();\\n       for(int i=0;i<n;i++){\\n            \\n            if(s[i]==\\'{\\' || s[i]==\\'(\\'|| s[i]==\\'[\\'){\\n                st.push(s[i]);\\n                continue;\\n            }\\n            if(st.empty()){\\n                return  false;\\n                break;\\n            }\\n            switch(s[i]){\\n                case \\')\\':\\n                    a=st.top();\\n                   st.pop();\\n                   if(a==\\'[\\'||a==\\'{\\'){\\n                       return false;\\n                       break;\\n                   } \\n                   case \\'}\\':\\n                    a=st.top();\\n                     st.pop();\\n                     if(a==\\'[\\'||a==\\'(\\'){\\n                       return false;\\n                       break;\\n                   }\\n                   case \\']\\':\\n                     a=st.top();\\n                     st.pop();\\n                     if(a==\\'(\\'||a==\\'{\\'){\\n                       return false;\\n                       break;\\n                   }\\n            }\\n       }\\n       return(st.empty());\\n    }\\n    \\n};"
                    },
                    {
                        "username": "tomho5",
                        "content": "\"([)]\" why would this be expected to output false?"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "this is not nested properly that means [ opens then it have to be closed before ) closes \nupvote if u understand the explanation "
                    },
                    {
                        "username": "msagor",
                        "content": "Can anyone PLEASE tell me why my code is wrong and not working ??? \\n\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack <char> stack;\\n        for(auto sign:s){\\n\\n            if(stack.empty()==true && sign==\\'}\\' || sign==\\'}\\' || sign ==\\']\\'){\\n                return false;\\n            }\\n\\n            if(sign==\\'(\\' || sign==\\'{\\' || sign==\\'[\\'){\\n                stack.push(sign);\\n            }else if(sign==\\')\\' && stack.top()==\\'(\\'){\\n                stack.pop();\\n            }else if(sign==\\'}\\' && stack.top()==\\'{\\'){\\n                stack.pop();\\n            }else if(sign==\\']\\' && stack.top()==\\'[\\'){\\n                stack.pop();\\n            }else{return false;}\\n        }\\n\\n        return stack.empty();\\n    }\\n};\\n"
                    },
                    {
                        "username": "st3n",
                        "content": "Looking at the examples given I had no way to know that nested brackets were allowed. I think the description should be changed or another example be added to show nested brackets because it was very frustrating to only see this when submitting. "
                    },
                    {
                        "username": "Jagadeeshravi",
                        "content": "What wrong with this code??:\\nworks fine in other compilers but not here\\n\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        dic = {\\'open\\':[\\'(\\',\\'{\\',\\'[\\'],\\'close\\':[\\')\\',\\'}\\',\\']\\']}\\n        out = \\'false\\'\\n        i=0\\n        \\n        while(len(s)%2 == 0 and len(s)>0):\\n            if s[i] in dic[\\'open\\'] :\\n                if s[i+1]!=dic[\\'close\\'][dic[\\'open\\'].index(s[i])]:\\n                    out = \\'false\\'\\n                    break\\n                else:\\n                    out = \\'true\\'\\n                    s = s[2:]\\n            \\n        print(out)"
                    },
                    {
                        "username": "lemmasamaha",
                        "content": "Why do a lot of the solutions use stack.pop()? couldn't we just do return true at the end of the function? I guess I'm not understanding how stack.pop() and return stack.empty() benefit the program anymore than just having return true at then end. \n\nedit: i also ran my code with return true at the end and it still passed the test cases"
                    },
                    {
                        "username": "lemmasamaha",
                        "content": "I think I understand, so I'll post here in case anyone had the same question. \n\nNote: explanation is based off this solution\n\nbool isValid(string s) {\n        stack<char> brackets;\n        for (auto i : s) {\n            if (i == '(' || i == '{' || i == '[') {\n                brackets.push(i);\n            } else {\n                if (brackets.empty() || (brackets.top() == '(' && i != ')') || (brackets.top() == '{' && i != '}') || (brackets.top() == '[' && i != ']')) {\n                    return false;\n                }\n                brackets.pop();\n            }   \n        }\n        return brackets.empty();\n    }\n\nFirst off, its important to note that the only parentheses that'll be pushed into the stack are the opening brackets. Let's use the example \"()\", we enter the for loop and the current index of i = 0 while the value of i = '('. Since i is an opening bracket at this point we push it into the stack and we start at the beginning of the for loop again. Now the index of i = 1 and the value of i = ')'. This skips over the \"if\" and enters the \"else\". At this point our stack isn't empty, so stack.top() == '(' and i = ')' is a closing bracket, so the if statement isn't satisfied. We then do stack.pop() (which will pop '(') because there is a corresponding closing bracket for the open bracket. Now outside of the for loop we return stack.empty() because if the stack is empty at this point we know that their a valid pair of brackets/parentheses. \n\nThis is a walkthrough of the entire code, but essentially even if return true does work instead of return stack.empty(), it doesn't utilize the stack."
                    }
                ]
            },
            {
                "id": 1725204,
                "content": [
                    {
                        "username": "user4628p",
                        "content": "Best Java Solution T.C=O(n)\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> sh=new Stack<>();\\n        for(int i=0; i<s.length();i++) {\\n            char ch=s.charAt(i);\\n            if(ch==\\'(\\' || ch==\\'{\\'|| ch==\\'[\\'){\\n                sh.push(ch);\\n            }else{\\n                if(sh.isEmpty()){\\n                    return false;\\n                }\\n                if((sh.peek()==\\'(\\' && ch==\\')\\' ||sh.peek()==\\'[\\' && ch==\\']\\' || sh.peek()==\\'{\\' && ch==\\'}\\')){\\n                    sh.pop();\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(sh.isEmpty()){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "maitrayob",
                        "content": "what is wrong with this solution? I am running this code in a separate IDE and its passing all the public tests but one of the tests are failing here. here's the code:\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        s = list(s)\n        for i in range(len(s)-1):\n            a = 0\n            if s[i] == '(' and s[i+1] == ')':\n                a += 1\n            elif s[i] == '{' and s[i+1] == '}':\n                a += 1\n            elif s[i] == '[' and s[i+1] == ']':\n                a += 1\n            else:\n                continue\n        if a * 2 == len(s):\n            return True\n        else:\n            return False"
                    },
                    {
                        "username": "eduard92",
                        "content": "Nice testcase \"{[]}\".\\nYou know this isn\\'t a real interview to ask IF it requires validation for nested parentheses. "
                    },
                    {
                        "username": "bmagana5",
                        "content": "I made a DFA and generated a Regular Expression to solve for the first 50~ of the test cases. Didn't account for cases like \"{[]}\", which kind of threw a wrench into things lol. I'll try to come up with a better DFA in the meantime.\n\n*edited: fixed some poor grammar"
                    },
                    {
                        "username": "raka_7317",
                        "content": "Runtime Error\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x000000344abb bp 0x7ffce3daf010 sp 0x7ffce3daeee0 T0)\\n==34==The signal is caused by a READ memory access.\\n==34==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #3 0x7f3c7c5350b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==34==ABORTING\\n\\nCAN ANYONE TELL ME WHY IS THIS ERROR AND HOW TO RESOLV IT;\\n\\n\\n\\nclass Solution {\\npublic:\\n      bool isValid(string s) {\\n        stack<char> st;\\n        \\n        char a;\\n       int n=s.size();\\n       for(int i=0;i<n;i++){\\n            \\n            if(s[i]==\\'{\\' || s[i]==\\'(\\'|| s[i]==\\'[\\'){\\n                st.push(s[i]);\\n                continue;\\n            }\\n            if(st.empty()){\\n                return  false;\\n                break;\\n            }\\n            switch(s[i]){\\n                case \\')\\':\\n                    a=st.top();\\n                   st.pop();\\n                   if(a==\\'[\\'||a==\\'{\\'){\\n                       return false;\\n                       break;\\n                   } \\n                   case \\'}\\':\\n                    a=st.top();\\n                     st.pop();\\n                     if(a==\\'[\\'||a==\\'(\\'){\\n                       return false;\\n                       break;\\n                   }\\n                   case \\']\\':\\n                     a=st.top();\\n                     st.pop();\\n                     if(a==\\'(\\'||a==\\'{\\'){\\n                       return false;\\n                       break;\\n                   }\\n            }\\n       }\\n       return(st.empty());\\n    }\\n    \\n};"
                    },
                    {
                        "username": "tomho5",
                        "content": "\"([)]\" why would this be expected to output false?"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "this is not nested properly that means [ opens then it have to be closed before ) closes \nupvote if u understand the explanation "
                    },
                    {
                        "username": "msagor",
                        "content": "Can anyone PLEASE tell me why my code is wrong and not working ??? \\n\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack <char> stack;\\n        for(auto sign:s){\\n\\n            if(stack.empty()==true && sign==\\'}\\' || sign==\\'}\\' || sign ==\\']\\'){\\n                return false;\\n            }\\n\\n            if(sign==\\'(\\' || sign==\\'{\\' || sign==\\'[\\'){\\n                stack.push(sign);\\n            }else if(sign==\\')\\' && stack.top()==\\'(\\'){\\n                stack.pop();\\n            }else if(sign==\\'}\\' && stack.top()==\\'{\\'){\\n                stack.pop();\\n            }else if(sign==\\']\\' && stack.top()==\\'[\\'){\\n                stack.pop();\\n            }else{return false;}\\n        }\\n\\n        return stack.empty();\\n    }\\n};\\n"
                    },
                    {
                        "username": "st3n",
                        "content": "Looking at the examples given I had no way to know that nested brackets were allowed. I think the description should be changed or another example be added to show nested brackets because it was very frustrating to only see this when submitting. "
                    },
                    {
                        "username": "Jagadeeshravi",
                        "content": "What wrong with this code??:\\nworks fine in other compilers but not here\\n\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        dic = {\\'open\\':[\\'(\\',\\'{\\',\\'[\\'],\\'close\\':[\\')\\',\\'}\\',\\']\\']}\\n        out = \\'false\\'\\n        i=0\\n        \\n        while(len(s)%2 == 0 and len(s)>0):\\n            if s[i] in dic[\\'open\\'] :\\n                if s[i+1]!=dic[\\'close\\'][dic[\\'open\\'].index(s[i])]:\\n                    out = \\'false\\'\\n                    break\\n                else:\\n                    out = \\'true\\'\\n                    s = s[2:]\\n            \\n        print(out)"
                    },
                    {
                        "username": "lemmasamaha",
                        "content": "Why do a lot of the solutions use stack.pop()? couldn't we just do return true at the end of the function? I guess I'm not understanding how stack.pop() and return stack.empty() benefit the program anymore than just having return true at then end. \n\nedit: i also ran my code with return true at the end and it still passed the test cases"
                    },
                    {
                        "username": "lemmasamaha",
                        "content": "I think I understand, so I'll post here in case anyone had the same question. \n\nNote: explanation is based off this solution\n\nbool isValid(string s) {\n        stack<char> brackets;\n        for (auto i : s) {\n            if (i == '(' || i == '{' || i == '[') {\n                brackets.push(i);\n            } else {\n                if (brackets.empty() || (brackets.top() == '(' && i != ')') || (brackets.top() == '{' && i != '}') || (brackets.top() == '[' && i != ']')) {\n                    return false;\n                }\n                brackets.pop();\n            }   \n        }\n        return brackets.empty();\n    }\n\nFirst off, its important to note that the only parentheses that'll be pushed into the stack are the opening brackets. Let's use the example \"()\", we enter the for loop and the current index of i = 0 while the value of i = '('. Since i is an opening bracket at this point we push it into the stack and we start at the beginning of the for loop again. Now the index of i = 1 and the value of i = ')'. This skips over the \"if\" and enters the \"else\". At this point our stack isn't empty, so stack.top() == '(' and i = ')' is a closing bracket, so the if statement isn't satisfied. We then do stack.pop() (which will pop '(') because there is a corresponding closing bracket for the open bracket. Now outside of the for loop we return stack.empty() because if the stack is empty at this point we know that their a valid pair of brackets/parentheses. \n\nThis is a walkthrough of the entire code, but essentially even if return true does work instead of return stack.empty(), it doesn't utilize the stack."
                    }
                ]
            },
            {
                "id": 1725163,
                "content": [
                    {
                        "username": "user4628p",
                        "content": "Best Java Solution T.C=O(n)\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> sh=new Stack<>();\\n        for(int i=0; i<s.length();i++) {\\n            char ch=s.charAt(i);\\n            if(ch==\\'(\\' || ch==\\'{\\'|| ch==\\'[\\'){\\n                sh.push(ch);\\n            }else{\\n                if(sh.isEmpty()){\\n                    return false;\\n                }\\n                if((sh.peek()==\\'(\\' && ch==\\')\\' ||sh.peek()==\\'[\\' && ch==\\']\\' || sh.peek()==\\'{\\' && ch==\\'}\\')){\\n                    sh.pop();\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(sh.isEmpty()){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "maitrayob",
                        "content": "what is wrong with this solution? I am running this code in a separate IDE and its passing all the public tests but one of the tests are failing here. here's the code:\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        s = list(s)\n        for i in range(len(s)-1):\n            a = 0\n            if s[i] == '(' and s[i+1] == ')':\n                a += 1\n            elif s[i] == '{' and s[i+1] == '}':\n                a += 1\n            elif s[i] == '[' and s[i+1] == ']':\n                a += 1\n            else:\n                continue\n        if a * 2 == len(s):\n            return True\n        else:\n            return False"
                    },
                    {
                        "username": "eduard92",
                        "content": "Nice testcase \"{[]}\".\\nYou know this isn\\'t a real interview to ask IF it requires validation for nested parentheses. "
                    },
                    {
                        "username": "bmagana5",
                        "content": "I made a DFA and generated a Regular Expression to solve for the first 50~ of the test cases. Didn't account for cases like \"{[]}\", which kind of threw a wrench into things lol. I'll try to come up with a better DFA in the meantime.\n\n*edited: fixed some poor grammar"
                    },
                    {
                        "username": "raka_7317",
                        "content": "Runtime Error\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x000000344abb bp 0x7ffce3daf010 sp 0x7ffce3daeee0 T0)\\n==34==The signal is caused by a READ memory access.\\n==34==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #3 0x7f3c7c5350b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==34==ABORTING\\n\\nCAN ANYONE TELL ME WHY IS THIS ERROR AND HOW TO RESOLV IT;\\n\\n\\n\\nclass Solution {\\npublic:\\n      bool isValid(string s) {\\n        stack<char> st;\\n        \\n        char a;\\n       int n=s.size();\\n       for(int i=0;i<n;i++){\\n            \\n            if(s[i]==\\'{\\' || s[i]==\\'(\\'|| s[i]==\\'[\\'){\\n                st.push(s[i]);\\n                continue;\\n            }\\n            if(st.empty()){\\n                return  false;\\n                break;\\n            }\\n            switch(s[i]){\\n                case \\')\\':\\n                    a=st.top();\\n                   st.pop();\\n                   if(a==\\'[\\'||a==\\'{\\'){\\n                       return false;\\n                       break;\\n                   } \\n                   case \\'}\\':\\n                    a=st.top();\\n                     st.pop();\\n                     if(a==\\'[\\'||a==\\'(\\'){\\n                       return false;\\n                       break;\\n                   }\\n                   case \\']\\':\\n                     a=st.top();\\n                     st.pop();\\n                     if(a==\\'(\\'||a==\\'{\\'){\\n                       return false;\\n                       break;\\n                   }\\n            }\\n       }\\n       return(st.empty());\\n    }\\n    \\n};"
                    },
                    {
                        "username": "tomho5",
                        "content": "\"([)]\" why would this be expected to output false?"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "this is not nested properly that means [ opens then it have to be closed before ) closes \nupvote if u understand the explanation "
                    },
                    {
                        "username": "msagor",
                        "content": "Can anyone PLEASE tell me why my code is wrong and not working ??? \\n\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack <char> stack;\\n        for(auto sign:s){\\n\\n            if(stack.empty()==true && sign==\\'}\\' || sign==\\'}\\' || sign ==\\']\\'){\\n                return false;\\n            }\\n\\n            if(sign==\\'(\\' || sign==\\'{\\' || sign==\\'[\\'){\\n                stack.push(sign);\\n            }else if(sign==\\')\\' && stack.top()==\\'(\\'){\\n                stack.pop();\\n            }else if(sign==\\'}\\' && stack.top()==\\'{\\'){\\n                stack.pop();\\n            }else if(sign==\\']\\' && stack.top()==\\'[\\'){\\n                stack.pop();\\n            }else{return false;}\\n        }\\n\\n        return stack.empty();\\n    }\\n};\\n"
                    },
                    {
                        "username": "st3n",
                        "content": "Looking at the examples given I had no way to know that nested brackets were allowed. I think the description should be changed or another example be added to show nested brackets because it was very frustrating to only see this when submitting. "
                    },
                    {
                        "username": "Jagadeeshravi",
                        "content": "What wrong with this code??:\\nworks fine in other compilers but not here\\n\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        dic = {\\'open\\':[\\'(\\',\\'{\\',\\'[\\'],\\'close\\':[\\')\\',\\'}\\',\\']\\']}\\n        out = \\'false\\'\\n        i=0\\n        \\n        while(len(s)%2 == 0 and len(s)>0):\\n            if s[i] in dic[\\'open\\'] :\\n                if s[i+1]!=dic[\\'close\\'][dic[\\'open\\'].index(s[i])]:\\n                    out = \\'false\\'\\n                    break\\n                else:\\n                    out = \\'true\\'\\n                    s = s[2:]\\n            \\n        print(out)"
                    },
                    {
                        "username": "lemmasamaha",
                        "content": "Why do a lot of the solutions use stack.pop()? couldn't we just do return true at the end of the function? I guess I'm not understanding how stack.pop() and return stack.empty() benefit the program anymore than just having return true at then end. \n\nedit: i also ran my code with return true at the end and it still passed the test cases"
                    },
                    {
                        "username": "lemmasamaha",
                        "content": "I think I understand, so I'll post here in case anyone had the same question. \n\nNote: explanation is based off this solution\n\nbool isValid(string s) {\n        stack<char> brackets;\n        for (auto i : s) {\n            if (i == '(' || i == '{' || i == '[') {\n                brackets.push(i);\n            } else {\n                if (brackets.empty() || (brackets.top() == '(' && i != ')') || (brackets.top() == '{' && i != '}') || (brackets.top() == '[' && i != ']')) {\n                    return false;\n                }\n                brackets.pop();\n            }   \n        }\n        return brackets.empty();\n    }\n\nFirst off, its important to note that the only parentheses that'll be pushed into the stack are the opening brackets. Let's use the example \"()\", we enter the for loop and the current index of i = 0 while the value of i = '('. Since i is an opening bracket at this point we push it into the stack and we start at the beginning of the for loop again. Now the index of i = 1 and the value of i = ')'. This skips over the \"if\" and enters the \"else\". At this point our stack isn't empty, so stack.top() == '(' and i = ')' is a closing bracket, so the if statement isn't satisfied. We then do stack.pop() (which will pop '(') because there is a corresponding closing bracket for the open bracket. Now outside of the for loop we return stack.empty() because if the stack is empty at this point we know that their a valid pair of brackets/parentheses. \n\nThis is a walkthrough of the entire code, but essentially even if return true does work instead of return stack.empty(), it doesn't utilize the stack."
                    }
                ]
            },
            {
                "id": 1725046,
                "content": [
                    {
                        "username": "user4628p",
                        "content": "Best Java Solution T.C=O(n)\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> sh=new Stack<>();\\n        for(int i=0; i<s.length();i++) {\\n            char ch=s.charAt(i);\\n            if(ch==\\'(\\' || ch==\\'{\\'|| ch==\\'[\\'){\\n                sh.push(ch);\\n            }else{\\n                if(sh.isEmpty()){\\n                    return false;\\n                }\\n                if((sh.peek()==\\'(\\' && ch==\\')\\' ||sh.peek()==\\'[\\' && ch==\\']\\' || sh.peek()==\\'{\\' && ch==\\'}\\')){\\n                    sh.pop();\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(sh.isEmpty()){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "maitrayob",
                        "content": "what is wrong with this solution? I am running this code in a separate IDE and its passing all the public tests but one of the tests are failing here. here's the code:\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        s = list(s)\n        for i in range(len(s)-1):\n            a = 0\n            if s[i] == '(' and s[i+1] == ')':\n                a += 1\n            elif s[i] == '{' and s[i+1] == '}':\n                a += 1\n            elif s[i] == '[' and s[i+1] == ']':\n                a += 1\n            else:\n                continue\n        if a * 2 == len(s):\n            return True\n        else:\n            return False"
                    },
                    {
                        "username": "eduard92",
                        "content": "Nice testcase \"{[]}\".\\nYou know this isn\\'t a real interview to ask IF it requires validation for nested parentheses. "
                    },
                    {
                        "username": "bmagana5",
                        "content": "I made a DFA and generated a Regular Expression to solve for the first 50~ of the test cases. Didn't account for cases like \"{[]}\", which kind of threw a wrench into things lol. I'll try to come up with a better DFA in the meantime.\n\n*edited: fixed some poor grammar"
                    },
                    {
                        "username": "raka_7317",
                        "content": "Runtime Error\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x000000344abb bp 0x7ffce3daf010 sp 0x7ffce3daeee0 T0)\\n==34==The signal is caused by a READ memory access.\\n==34==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #3 0x7f3c7c5350b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==34==ABORTING\\n\\nCAN ANYONE TELL ME WHY IS THIS ERROR AND HOW TO RESOLV IT;\\n\\n\\n\\nclass Solution {\\npublic:\\n      bool isValid(string s) {\\n        stack<char> st;\\n        \\n        char a;\\n       int n=s.size();\\n       for(int i=0;i<n;i++){\\n            \\n            if(s[i]==\\'{\\' || s[i]==\\'(\\'|| s[i]==\\'[\\'){\\n                st.push(s[i]);\\n                continue;\\n            }\\n            if(st.empty()){\\n                return  false;\\n                break;\\n            }\\n            switch(s[i]){\\n                case \\')\\':\\n                    a=st.top();\\n                   st.pop();\\n                   if(a==\\'[\\'||a==\\'{\\'){\\n                       return false;\\n                       break;\\n                   } \\n                   case \\'}\\':\\n                    a=st.top();\\n                     st.pop();\\n                     if(a==\\'[\\'||a==\\'(\\'){\\n                       return false;\\n                       break;\\n                   }\\n                   case \\']\\':\\n                     a=st.top();\\n                     st.pop();\\n                     if(a==\\'(\\'||a==\\'{\\'){\\n                       return false;\\n                       break;\\n                   }\\n            }\\n       }\\n       return(st.empty());\\n    }\\n    \\n};"
                    },
                    {
                        "username": "tomho5",
                        "content": "\"([)]\" why would this be expected to output false?"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "this is not nested properly that means [ opens then it have to be closed before ) closes \nupvote if u understand the explanation "
                    },
                    {
                        "username": "msagor",
                        "content": "Can anyone PLEASE tell me why my code is wrong and not working ??? \\n\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack <char> stack;\\n        for(auto sign:s){\\n\\n            if(stack.empty()==true && sign==\\'}\\' || sign==\\'}\\' || sign ==\\']\\'){\\n                return false;\\n            }\\n\\n            if(sign==\\'(\\' || sign==\\'{\\' || sign==\\'[\\'){\\n                stack.push(sign);\\n            }else if(sign==\\')\\' && stack.top()==\\'(\\'){\\n                stack.pop();\\n            }else if(sign==\\'}\\' && stack.top()==\\'{\\'){\\n                stack.pop();\\n            }else if(sign==\\']\\' && stack.top()==\\'[\\'){\\n                stack.pop();\\n            }else{return false;}\\n        }\\n\\n        return stack.empty();\\n    }\\n};\\n"
                    },
                    {
                        "username": "st3n",
                        "content": "Looking at the examples given I had no way to know that nested brackets were allowed. I think the description should be changed or another example be added to show nested brackets because it was very frustrating to only see this when submitting. "
                    },
                    {
                        "username": "Jagadeeshravi",
                        "content": "What wrong with this code??:\\nworks fine in other compilers but not here\\n\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        dic = {\\'open\\':[\\'(\\',\\'{\\',\\'[\\'],\\'close\\':[\\')\\',\\'}\\',\\']\\']}\\n        out = \\'false\\'\\n        i=0\\n        \\n        while(len(s)%2 == 0 and len(s)>0):\\n            if s[i] in dic[\\'open\\'] :\\n                if s[i+1]!=dic[\\'close\\'][dic[\\'open\\'].index(s[i])]:\\n                    out = \\'false\\'\\n                    break\\n                else:\\n                    out = \\'true\\'\\n                    s = s[2:]\\n            \\n        print(out)"
                    },
                    {
                        "username": "lemmasamaha",
                        "content": "Why do a lot of the solutions use stack.pop()? couldn't we just do return true at the end of the function? I guess I'm not understanding how stack.pop() and return stack.empty() benefit the program anymore than just having return true at then end. \n\nedit: i also ran my code with return true at the end and it still passed the test cases"
                    },
                    {
                        "username": "lemmasamaha",
                        "content": "I think I understand, so I'll post here in case anyone had the same question. \n\nNote: explanation is based off this solution\n\nbool isValid(string s) {\n        stack<char> brackets;\n        for (auto i : s) {\n            if (i == '(' || i == '{' || i == '[') {\n                brackets.push(i);\n            } else {\n                if (brackets.empty() || (brackets.top() == '(' && i != ')') || (brackets.top() == '{' && i != '}') || (brackets.top() == '[' && i != ']')) {\n                    return false;\n                }\n                brackets.pop();\n            }   \n        }\n        return brackets.empty();\n    }\n\nFirst off, its important to note that the only parentheses that'll be pushed into the stack are the opening brackets. Let's use the example \"()\", we enter the for loop and the current index of i = 0 while the value of i = '('. Since i is an opening bracket at this point we push it into the stack and we start at the beginning of the for loop again. Now the index of i = 1 and the value of i = ')'. This skips over the \"if\" and enters the \"else\". At this point our stack isn't empty, so stack.top() == '(' and i = ')' is a closing bracket, so the if statement isn't satisfied. We then do stack.pop() (which will pop '(') because there is a corresponding closing bracket for the open bracket. Now outside of the for loop we return stack.empty() because if the stack is empty at this point we know that their a valid pair of brackets/parentheses. \n\nThis is a walkthrough of the entire code, but essentially even if return true does work instead of return stack.empty(), it doesn't utilize the stack."
                    }
                ]
            },
            {
                "id": 1725033,
                "content": [
                    {
                        "username": "user4628p",
                        "content": "Best Java Solution T.C=O(n)\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> sh=new Stack<>();\\n        for(int i=0; i<s.length();i++) {\\n            char ch=s.charAt(i);\\n            if(ch==\\'(\\' || ch==\\'{\\'|| ch==\\'[\\'){\\n                sh.push(ch);\\n            }else{\\n                if(sh.isEmpty()){\\n                    return false;\\n                }\\n                if((sh.peek()==\\'(\\' && ch==\\')\\' ||sh.peek()==\\'[\\' && ch==\\']\\' || sh.peek()==\\'{\\' && ch==\\'}\\')){\\n                    sh.pop();\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(sh.isEmpty()){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "maitrayob",
                        "content": "what is wrong with this solution? I am running this code in a separate IDE and its passing all the public tests but one of the tests are failing here. here's the code:\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        s = list(s)\n        for i in range(len(s)-1):\n            a = 0\n            if s[i] == '(' and s[i+1] == ')':\n                a += 1\n            elif s[i] == '{' and s[i+1] == '}':\n                a += 1\n            elif s[i] == '[' and s[i+1] == ']':\n                a += 1\n            else:\n                continue\n        if a * 2 == len(s):\n            return True\n        else:\n            return False"
                    },
                    {
                        "username": "eduard92",
                        "content": "Nice testcase \"{[]}\".\\nYou know this isn\\'t a real interview to ask IF it requires validation for nested parentheses. "
                    },
                    {
                        "username": "bmagana5",
                        "content": "I made a DFA and generated a Regular Expression to solve for the first 50~ of the test cases. Didn't account for cases like \"{[]}\", which kind of threw a wrench into things lol. I'll try to come up with a better DFA in the meantime.\n\n*edited: fixed some poor grammar"
                    },
                    {
                        "username": "raka_7317",
                        "content": "Runtime Error\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x000000344abb bp 0x7ffce3daf010 sp 0x7ffce3daeee0 T0)\\n==34==The signal is caused by a READ memory access.\\n==34==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #3 0x7f3c7c5350b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==34==ABORTING\\n\\nCAN ANYONE TELL ME WHY IS THIS ERROR AND HOW TO RESOLV IT;\\n\\n\\n\\nclass Solution {\\npublic:\\n      bool isValid(string s) {\\n        stack<char> st;\\n        \\n        char a;\\n       int n=s.size();\\n       for(int i=0;i<n;i++){\\n            \\n            if(s[i]==\\'{\\' || s[i]==\\'(\\'|| s[i]==\\'[\\'){\\n                st.push(s[i]);\\n                continue;\\n            }\\n            if(st.empty()){\\n                return  false;\\n                break;\\n            }\\n            switch(s[i]){\\n                case \\')\\':\\n                    a=st.top();\\n                   st.pop();\\n                   if(a==\\'[\\'||a==\\'{\\'){\\n                       return false;\\n                       break;\\n                   } \\n                   case \\'}\\':\\n                    a=st.top();\\n                     st.pop();\\n                     if(a==\\'[\\'||a==\\'(\\'){\\n                       return false;\\n                       break;\\n                   }\\n                   case \\']\\':\\n                     a=st.top();\\n                     st.pop();\\n                     if(a==\\'(\\'||a==\\'{\\'){\\n                       return false;\\n                       break;\\n                   }\\n            }\\n       }\\n       return(st.empty());\\n    }\\n    \\n};"
                    },
                    {
                        "username": "tomho5",
                        "content": "\"([)]\" why would this be expected to output false?"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "this is not nested properly that means [ opens then it have to be closed before ) closes \nupvote if u understand the explanation "
                    },
                    {
                        "username": "msagor",
                        "content": "Can anyone PLEASE tell me why my code is wrong and not working ??? \\n\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack <char> stack;\\n        for(auto sign:s){\\n\\n            if(stack.empty()==true && sign==\\'}\\' || sign==\\'}\\' || sign ==\\']\\'){\\n                return false;\\n            }\\n\\n            if(sign==\\'(\\' || sign==\\'{\\' || sign==\\'[\\'){\\n                stack.push(sign);\\n            }else if(sign==\\')\\' && stack.top()==\\'(\\'){\\n                stack.pop();\\n            }else if(sign==\\'}\\' && stack.top()==\\'{\\'){\\n                stack.pop();\\n            }else if(sign==\\']\\' && stack.top()==\\'[\\'){\\n                stack.pop();\\n            }else{return false;}\\n        }\\n\\n        return stack.empty();\\n    }\\n};\\n"
                    },
                    {
                        "username": "st3n",
                        "content": "Looking at the examples given I had no way to know that nested brackets were allowed. I think the description should be changed or another example be added to show nested brackets because it was very frustrating to only see this when submitting. "
                    },
                    {
                        "username": "Jagadeeshravi",
                        "content": "What wrong with this code??:\\nworks fine in other compilers but not here\\n\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        dic = {\\'open\\':[\\'(\\',\\'{\\',\\'[\\'],\\'close\\':[\\')\\',\\'}\\',\\']\\']}\\n        out = \\'false\\'\\n        i=0\\n        \\n        while(len(s)%2 == 0 and len(s)>0):\\n            if s[i] in dic[\\'open\\'] :\\n                if s[i+1]!=dic[\\'close\\'][dic[\\'open\\'].index(s[i])]:\\n                    out = \\'false\\'\\n                    break\\n                else:\\n                    out = \\'true\\'\\n                    s = s[2:]\\n            \\n        print(out)"
                    },
                    {
                        "username": "lemmasamaha",
                        "content": "Why do a lot of the solutions use stack.pop()? couldn't we just do return true at the end of the function? I guess I'm not understanding how stack.pop() and return stack.empty() benefit the program anymore than just having return true at then end. \n\nedit: i also ran my code with return true at the end and it still passed the test cases"
                    },
                    {
                        "username": "lemmasamaha",
                        "content": "I think I understand, so I'll post here in case anyone had the same question. \n\nNote: explanation is based off this solution\n\nbool isValid(string s) {\n        stack<char> brackets;\n        for (auto i : s) {\n            if (i == '(' || i == '{' || i == '[') {\n                brackets.push(i);\n            } else {\n                if (brackets.empty() || (brackets.top() == '(' && i != ')') || (brackets.top() == '{' && i != '}') || (brackets.top() == '[' && i != ']')) {\n                    return false;\n                }\n                brackets.pop();\n            }   \n        }\n        return brackets.empty();\n    }\n\nFirst off, its important to note that the only parentheses that'll be pushed into the stack are the opening brackets. Let's use the example \"()\", we enter the for loop and the current index of i = 0 while the value of i = '('. Since i is an opening bracket at this point we push it into the stack and we start at the beginning of the for loop again. Now the index of i = 1 and the value of i = ')'. This skips over the \"if\" and enters the \"else\". At this point our stack isn't empty, so stack.top() == '(' and i = ')' is a closing bracket, so the if statement isn't satisfied. We then do stack.pop() (which will pop '(') because there is a corresponding closing bracket for the open bracket. Now outside of the for loop we return stack.empty() because if the stack is empty at this point we know that their a valid pair of brackets/parentheses. \n\nThis is a walkthrough of the entire code, but essentially even if return true does work instead of return stack.empty(), it doesn't utilize the stack."
                    }
                ]
            },
            {
                "id": 1725012,
                "content": [
                    {
                        "username": "user4628p",
                        "content": "Best Java Solution T.C=O(n)\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> sh=new Stack<>();\\n        for(int i=0; i<s.length();i++) {\\n            char ch=s.charAt(i);\\n            if(ch==\\'(\\' || ch==\\'{\\'|| ch==\\'[\\'){\\n                sh.push(ch);\\n            }else{\\n                if(sh.isEmpty()){\\n                    return false;\\n                }\\n                if((sh.peek()==\\'(\\' && ch==\\')\\' ||sh.peek()==\\'[\\' && ch==\\']\\' || sh.peek()==\\'{\\' && ch==\\'}\\')){\\n                    sh.pop();\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(sh.isEmpty()){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "maitrayob",
                        "content": "what is wrong with this solution? I am running this code in a separate IDE and its passing all the public tests but one of the tests are failing here. here's the code:\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        s = list(s)\n        for i in range(len(s)-1):\n            a = 0\n            if s[i] == '(' and s[i+1] == ')':\n                a += 1\n            elif s[i] == '{' and s[i+1] == '}':\n                a += 1\n            elif s[i] == '[' and s[i+1] == ']':\n                a += 1\n            else:\n                continue\n        if a * 2 == len(s):\n            return True\n        else:\n            return False"
                    },
                    {
                        "username": "eduard92",
                        "content": "Nice testcase \"{[]}\".\\nYou know this isn\\'t a real interview to ask IF it requires validation for nested parentheses. "
                    },
                    {
                        "username": "bmagana5",
                        "content": "I made a DFA and generated a Regular Expression to solve for the first 50~ of the test cases. Didn't account for cases like \"{[]}\", which kind of threw a wrench into things lol. I'll try to come up with a better DFA in the meantime.\n\n*edited: fixed some poor grammar"
                    },
                    {
                        "username": "raka_7317",
                        "content": "Runtime Error\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x000000344abb bp 0x7ffce3daf010 sp 0x7ffce3daeee0 T0)\\n==34==The signal is caused by a READ memory access.\\n==34==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #3 0x7f3c7c5350b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==34==ABORTING\\n\\nCAN ANYONE TELL ME WHY IS THIS ERROR AND HOW TO RESOLV IT;\\n\\n\\n\\nclass Solution {\\npublic:\\n      bool isValid(string s) {\\n        stack<char> st;\\n        \\n        char a;\\n       int n=s.size();\\n       for(int i=0;i<n;i++){\\n            \\n            if(s[i]==\\'{\\' || s[i]==\\'(\\'|| s[i]==\\'[\\'){\\n                st.push(s[i]);\\n                continue;\\n            }\\n            if(st.empty()){\\n                return  false;\\n                break;\\n            }\\n            switch(s[i]){\\n                case \\')\\':\\n                    a=st.top();\\n                   st.pop();\\n                   if(a==\\'[\\'||a==\\'{\\'){\\n                       return false;\\n                       break;\\n                   } \\n                   case \\'}\\':\\n                    a=st.top();\\n                     st.pop();\\n                     if(a==\\'[\\'||a==\\'(\\'){\\n                       return false;\\n                       break;\\n                   }\\n                   case \\']\\':\\n                     a=st.top();\\n                     st.pop();\\n                     if(a==\\'(\\'||a==\\'{\\'){\\n                       return false;\\n                       break;\\n                   }\\n            }\\n       }\\n       return(st.empty());\\n    }\\n    \\n};"
                    },
                    {
                        "username": "tomho5",
                        "content": "\"([)]\" why would this be expected to output false?"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "this is not nested properly that means [ opens then it have to be closed before ) closes \nupvote if u understand the explanation "
                    },
                    {
                        "username": "msagor",
                        "content": "Can anyone PLEASE tell me why my code is wrong and not working ??? \\n\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack <char> stack;\\n        for(auto sign:s){\\n\\n            if(stack.empty()==true && sign==\\'}\\' || sign==\\'}\\' || sign ==\\']\\'){\\n                return false;\\n            }\\n\\n            if(sign==\\'(\\' || sign==\\'{\\' || sign==\\'[\\'){\\n                stack.push(sign);\\n            }else if(sign==\\')\\' && stack.top()==\\'(\\'){\\n                stack.pop();\\n            }else if(sign==\\'}\\' && stack.top()==\\'{\\'){\\n                stack.pop();\\n            }else if(sign==\\']\\' && stack.top()==\\'[\\'){\\n                stack.pop();\\n            }else{return false;}\\n        }\\n\\n        return stack.empty();\\n    }\\n};\\n"
                    },
                    {
                        "username": "st3n",
                        "content": "Looking at the examples given I had no way to know that nested brackets were allowed. I think the description should be changed or another example be added to show nested brackets because it was very frustrating to only see this when submitting. "
                    },
                    {
                        "username": "Jagadeeshravi",
                        "content": "What wrong with this code??:\\nworks fine in other compilers but not here\\n\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        dic = {\\'open\\':[\\'(\\',\\'{\\',\\'[\\'],\\'close\\':[\\')\\',\\'}\\',\\']\\']}\\n        out = \\'false\\'\\n        i=0\\n        \\n        while(len(s)%2 == 0 and len(s)>0):\\n            if s[i] in dic[\\'open\\'] :\\n                if s[i+1]!=dic[\\'close\\'][dic[\\'open\\'].index(s[i])]:\\n                    out = \\'false\\'\\n                    break\\n                else:\\n                    out = \\'true\\'\\n                    s = s[2:]\\n            \\n        print(out)"
                    },
                    {
                        "username": "lemmasamaha",
                        "content": "Why do a lot of the solutions use stack.pop()? couldn't we just do return true at the end of the function? I guess I'm not understanding how stack.pop() and return stack.empty() benefit the program anymore than just having return true at then end. \n\nedit: i also ran my code with return true at the end and it still passed the test cases"
                    },
                    {
                        "username": "lemmasamaha",
                        "content": "I think I understand, so I'll post here in case anyone had the same question. \n\nNote: explanation is based off this solution\n\nbool isValid(string s) {\n        stack<char> brackets;\n        for (auto i : s) {\n            if (i == '(' || i == '{' || i == '[') {\n                brackets.push(i);\n            } else {\n                if (brackets.empty() || (brackets.top() == '(' && i != ')') || (brackets.top() == '{' && i != '}') || (brackets.top() == '[' && i != ']')) {\n                    return false;\n                }\n                brackets.pop();\n            }   \n        }\n        return brackets.empty();\n    }\n\nFirst off, its important to note that the only parentheses that'll be pushed into the stack are the opening brackets. Let's use the example \"()\", we enter the for loop and the current index of i = 0 while the value of i = '('. Since i is an opening bracket at this point we push it into the stack and we start at the beginning of the for loop again. Now the index of i = 1 and the value of i = ')'. This skips over the \"if\" and enters the \"else\". At this point our stack isn't empty, so stack.top() == '(' and i = ')' is a closing bracket, so the if statement isn't satisfied. We then do stack.pop() (which will pop '(') because there is a corresponding closing bracket for the open bracket. Now outside of the for loop we return stack.empty() because if the stack is empty at this point we know that their a valid pair of brackets/parentheses. \n\nThis is a walkthrough of the entire code, but essentially even if return true does work instead of return stack.empty(), it doesn't utilize the stack."
                    }
                ]
            },
            {
                "id": 1724932,
                "content": [
                    {
                        "username": "user4628p",
                        "content": "Best Java Solution T.C=O(n)\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> sh=new Stack<>();\\n        for(int i=0; i<s.length();i++) {\\n            char ch=s.charAt(i);\\n            if(ch==\\'(\\' || ch==\\'{\\'|| ch==\\'[\\'){\\n                sh.push(ch);\\n            }else{\\n                if(sh.isEmpty()){\\n                    return false;\\n                }\\n                if((sh.peek()==\\'(\\' && ch==\\')\\' ||sh.peek()==\\'[\\' && ch==\\']\\' || sh.peek()==\\'{\\' && ch==\\'}\\')){\\n                    sh.pop();\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(sh.isEmpty()){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "maitrayob",
                        "content": "what is wrong with this solution? I am running this code in a separate IDE and its passing all the public tests but one of the tests are failing here. here's the code:\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        s = list(s)\n        for i in range(len(s)-1):\n            a = 0\n            if s[i] == '(' and s[i+1] == ')':\n                a += 1\n            elif s[i] == '{' and s[i+1] == '}':\n                a += 1\n            elif s[i] == '[' and s[i+1] == ']':\n                a += 1\n            else:\n                continue\n        if a * 2 == len(s):\n            return True\n        else:\n            return False"
                    },
                    {
                        "username": "eduard92",
                        "content": "Nice testcase \"{[]}\".\\nYou know this isn\\'t a real interview to ask IF it requires validation for nested parentheses. "
                    },
                    {
                        "username": "bmagana5",
                        "content": "I made a DFA and generated a Regular Expression to solve for the first 50~ of the test cases. Didn't account for cases like \"{[]}\", which kind of threw a wrench into things lol. I'll try to come up with a better DFA in the meantime.\n\n*edited: fixed some poor grammar"
                    },
                    {
                        "username": "raka_7317",
                        "content": "Runtime Error\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x000000344abb bp 0x7ffce3daf010 sp 0x7ffce3daeee0 T0)\\n==34==The signal is caused by a READ memory access.\\n==34==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #3 0x7f3c7c5350b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==34==ABORTING\\n\\nCAN ANYONE TELL ME WHY IS THIS ERROR AND HOW TO RESOLV IT;\\n\\n\\n\\nclass Solution {\\npublic:\\n      bool isValid(string s) {\\n        stack<char> st;\\n        \\n        char a;\\n       int n=s.size();\\n       for(int i=0;i<n;i++){\\n            \\n            if(s[i]==\\'{\\' || s[i]==\\'(\\'|| s[i]==\\'[\\'){\\n                st.push(s[i]);\\n                continue;\\n            }\\n            if(st.empty()){\\n                return  false;\\n                break;\\n            }\\n            switch(s[i]){\\n                case \\')\\':\\n                    a=st.top();\\n                   st.pop();\\n                   if(a==\\'[\\'||a==\\'{\\'){\\n                       return false;\\n                       break;\\n                   } \\n                   case \\'}\\':\\n                    a=st.top();\\n                     st.pop();\\n                     if(a==\\'[\\'||a==\\'(\\'){\\n                       return false;\\n                       break;\\n                   }\\n                   case \\']\\':\\n                     a=st.top();\\n                     st.pop();\\n                     if(a==\\'(\\'||a==\\'{\\'){\\n                       return false;\\n                       break;\\n                   }\\n            }\\n       }\\n       return(st.empty());\\n    }\\n    \\n};"
                    },
                    {
                        "username": "tomho5",
                        "content": "\"([)]\" why would this be expected to output false?"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "this is not nested properly that means [ opens then it have to be closed before ) closes \nupvote if u understand the explanation "
                    },
                    {
                        "username": "msagor",
                        "content": "Can anyone PLEASE tell me why my code is wrong and not working ??? \\n\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack <char> stack;\\n        for(auto sign:s){\\n\\n            if(stack.empty()==true && sign==\\'}\\' || sign==\\'}\\' || sign ==\\']\\'){\\n                return false;\\n            }\\n\\n            if(sign==\\'(\\' || sign==\\'{\\' || sign==\\'[\\'){\\n                stack.push(sign);\\n            }else if(sign==\\')\\' && stack.top()==\\'(\\'){\\n                stack.pop();\\n            }else if(sign==\\'}\\' && stack.top()==\\'{\\'){\\n                stack.pop();\\n            }else if(sign==\\']\\' && stack.top()==\\'[\\'){\\n                stack.pop();\\n            }else{return false;}\\n        }\\n\\n        return stack.empty();\\n    }\\n};\\n"
                    },
                    {
                        "username": "st3n",
                        "content": "Looking at the examples given I had no way to know that nested brackets were allowed. I think the description should be changed or another example be added to show nested brackets because it was very frustrating to only see this when submitting. "
                    },
                    {
                        "username": "Jagadeeshravi",
                        "content": "What wrong with this code??:\\nworks fine in other compilers but not here\\n\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        dic = {\\'open\\':[\\'(\\',\\'{\\',\\'[\\'],\\'close\\':[\\')\\',\\'}\\',\\']\\']}\\n        out = \\'false\\'\\n        i=0\\n        \\n        while(len(s)%2 == 0 and len(s)>0):\\n            if s[i] in dic[\\'open\\'] :\\n                if s[i+1]!=dic[\\'close\\'][dic[\\'open\\'].index(s[i])]:\\n                    out = \\'false\\'\\n                    break\\n                else:\\n                    out = \\'true\\'\\n                    s = s[2:]\\n            \\n        print(out)"
                    },
                    {
                        "username": "lemmasamaha",
                        "content": "Why do a lot of the solutions use stack.pop()? couldn't we just do return true at the end of the function? I guess I'm not understanding how stack.pop() and return stack.empty() benefit the program anymore than just having return true at then end. \n\nedit: i also ran my code with return true at the end and it still passed the test cases"
                    },
                    {
                        "username": "lemmasamaha",
                        "content": "I think I understand, so I'll post here in case anyone had the same question. \n\nNote: explanation is based off this solution\n\nbool isValid(string s) {\n        stack<char> brackets;\n        for (auto i : s) {\n            if (i == '(' || i == '{' || i == '[') {\n                brackets.push(i);\n            } else {\n                if (brackets.empty() || (brackets.top() == '(' && i != ')') || (brackets.top() == '{' && i != '}') || (brackets.top() == '[' && i != ']')) {\n                    return false;\n                }\n                brackets.pop();\n            }   \n        }\n        return brackets.empty();\n    }\n\nFirst off, its important to note that the only parentheses that'll be pushed into the stack are the opening brackets. Let's use the example \"()\", we enter the for loop and the current index of i = 0 while the value of i = '('. Since i is an opening bracket at this point we push it into the stack and we start at the beginning of the for loop again. Now the index of i = 1 and the value of i = ')'. This skips over the \"if\" and enters the \"else\". At this point our stack isn't empty, so stack.top() == '(' and i = ')' is a closing bracket, so the if statement isn't satisfied. We then do stack.pop() (which will pop '(') because there is a corresponding closing bracket for the open bracket. Now outside of the for loop we return stack.empty() because if the stack is empty at this point we know that their a valid pair of brackets/parentheses. \n\nThis is a walkthrough of the entire code, but essentially even if return true does work instead of return stack.empty(), it doesn't utilize the stack."
                    }
                ]
            },
            {
                "id": 1724733,
                "content": [
                    {
                        "username": "user4628p",
                        "content": "Best Java Solution T.C=O(n)\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> sh=new Stack<>();\\n        for(int i=0; i<s.length();i++) {\\n            char ch=s.charAt(i);\\n            if(ch==\\'(\\' || ch==\\'{\\'|| ch==\\'[\\'){\\n                sh.push(ch);\\n            }else{\\n                if(sh.isEmpty()){\\n                    return false;\\n                }\\n                if((sh.peek()==\\'(\\' && ch==\\')\\' ||sh.peek()==\\'[\\' && ch==\\']\\' || sh.peek()==\\'{\\' && ch==\\'}\\')){\\n                    sh.pop();\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        if(sh.isEmpty()){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "maitrayob",
                        "content": "what is wrong with this solution? I am running this code in a separate IDE and its passing all the public tests but one of the tests are failing here. here's the code:\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        s = list(s)\n        for i in range(len(s)-1):\n            a = 0\n            if s[i] == '(' and s[i+1] == ')':\n                a += 1\n            elif s[i] == '{' and s[i+1] == '}':\n                a += 1\n            elif s[i] == '[' and s[i+1] == ']':\n                a += 1\n            else:\n                continue\n        if a * 2 == len(s):\n            return True\n        else:\n            return False"
                    },
                    {
                        "username": "eduard92",
                        "content": "Nice testcase \"{[]}\".\\nYou know this isn\\'t a real interview to ask IF it requires validation for nested parentheses. "
                    },
                    {
                        "username": "bmagana5",
                        "content": "I made a DFA and generated a Regular Expression to solve for the first 50~ of the test cases. Didn't account for cases like \"{[]}\", which kind of threw a wrench into things lol. I'll try to come up with a better DFA in the meantime.\n\n*edited: fixed some poor grammar"
                    },
                    {
                        "username": "raka_7317",
                        "content": "Runtime Error\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x000000344abb bp 0x7ffce3daf010 sp 0x7ffce3daeee0 T0)\\n==34==The signal is caused by a READ memory access.\\n==34==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #3 0x7f3c7c5350b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==34==ABORTING\\n\\nCAN ANYONE TELL ME WHY IS THIS ERROR AND HOW TO RESOLV IT;\\n\\n\\n\\nclass Solution {\\npublic:\\n      bool isValid(string s) {\\n        stack<char> st;\\n        \\n        char a;\\n       int n=s.size();\\n       for(int i=0;i<n;i++){\\n            \\n            if(s[i]==\\'{\\' || s[i]==\\'(\\'|| s[i]==\\'[\\'){\\n                st.push(s[i]);\\n                continue;\\n            }\\n            if(st.empty()){\\n                return  false;\\n                break;\\n            }\\n            switch(s[i]){\\n                case \\')\\':\\n                    a=st.top();\\n                   st.pop();\\n                   if(a==\\'[\\'||a==\\'{\\'){\\n                       return false;\\n                       break;\\n                   } \\n                   case \\'}\\':\\n                    a=st.top();\\n                     st.pop();\\n                     if(a==\\'[\\'||a==\\'(\\'){\\n                       return false;\\n                       break;\\n                   }\\n                   case \\']\\':\\n                     a=st.top();\\n                     st.pop();\\n                     if(a==\\'(\\'||a==\\'{\\'){\\n                       return false;\\n                       break;\\n                   }\\n            }\\n       }\\n       return(st.empty());\\n    }\\n    \\n};"
                    },
                    {
                        "username": "tomho5",
                        "content": "\"([)]\" why would this be expected to output false?"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "this is not nested properly that means [ opens then it have to be closed before ) closes \nupvote if u understand the explanation "
                    },
                    {
                        "username": "msagor",
                        "content": "Can anyone PLEASE tell me why my code is wrong and not working ??? \\n\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack <char> stack;\\n        for(auto sign:s){\\n\\n            if(stack.empty()==true && sign==\\'}\\' || sign==\\'}\\' || sign ==\\']\\'){\\n                return false;\\n            }\\n\\n            if(sign==\\'(\\' || sign==\\'{\\' || sign==\\'[\\'){\\n                stack.push(sign);\\n            }else if(sign==\\')\\' && stack.top()==\\'(\\'){\\n                stack.pop();\\n            }else if(sign==\\'}\\' && stack.top()==\\'{\\'){\\n                stack.pop();\\n            }else if(sign==\\']\\' && stack.top()==\\'[\\'){\\n                stack.pop();\\n            }else{return false;}\\n        }\\n\\n        return stack.empty();\\n    }\\n};\\n"
                    },
                    {
                        "username": "st3n",
                        "content": "Looking at the examples given I had no way to know that nested brackets were allowed. I think the description should be changed or another example be added to show nested brackets because it was very frustrating to only see this when submitting. "
                    },
                    {
                        "username": "Jagadeeshravi",
                        "content": "What wrong with this code??:\\nworks fine in other compilers but not here\\n\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        dic = {\\'open\\':[\\'(\\',\\'{\\',\\'[\\'],\\'close\\':[\\')\\',\\'}\\',\\']\\']}\\n        out = \\'false\\'\\n        i=0\\n        \\n        while(len(s)%2 == 0 and len(s)>0):\\n            if s[i] in dic[\\'open\\'] :\\n                if s[i+1]!=dic[\\'close\\'][dic[\\'open\\'].index(s[i])]:\\n                    out = \\'false\\'\\n                    break\\n                else:\\n                    out = \\'true\\'\\n                    s = s[2:]\\n            \\n        print(out)"
                    },
                    {
                        "username": "lemmasamaha",
                        "content": "Why do a lot of the solutions use stack.pop()? couldn't we just do return true at the end of the function? I guess I'm not understanding how stack.pop() and return stack.empty() benefit the program anymore than just having return true at then end. \n\nedit: i also ran my code with return true at the end and it still passed the test cases"
                    },
                    {
                        "username": "lemmasamaha",
                        "content": "I think I understand, so I'll post here in case anyone had the same question. \n\nNote: explanation is based off this solution\n\nbool isValid(string s) {\n        stack<char> brackets;\n        for (auto i : s) {\n            if (i == '(' || i == '{' || i == '[') {\n                brackets.push(i);\n            } else {\n                if (brackets.empty() || (brackets.top() == '(' && i != ')') || (brackets.top() == '{' && i != '}') || (brackets.top() == '[' && i != ']')) {\n                    return false;\n                }\n                brackets.pop();\n            }   \n        }\n        return brackets.empty();\n    }\n\nFirst off, its important to note that the only parentheses that'll be pushed into the stack are the opening brackets. Let's use the example \"()\", we enter the for loop and the current index of i = 0 while the value of i = '('. Since i is an opening bracket at this point we push it into the stack and we start at the beginning of the for loop again. Now the index of i = 1 and the value of i = ')'. This skips over the \"if\" and enters the \"else\". At this point our stack isn't empty, so stack.top() == '(' and i = ')' is a closing bracket, so the if statement isn't satisfied. We then do stack.pop() (which will pop '(') because there is a corresponding closing bracket for the open bracket. Now outside of the for loop we return stack.empty() because if the stack is empty at this point we know that their a valid pair of brackets/parentheses. \n\nThis is a walkthrough of the entire code, but essentially even if return true does work instead of return stack.empty(), it doesn't utilize the stack."
                    }
                ]
            },
            {
                "id": 1723348,
                "content": [
                    {
                        "username": "Adarshs_12",
                        "content": "//can anyone please explain where i made mistake//\\n\\nclass Solution {\\n    public boolean isValid(String s) {\\n        if(s.length() == 1){\\n            return false;\\n        }\\n        char[] arr = s.toCharArray();\\n        Stack<Character> st = new Stack<>();\\n        for(int i=0; i<arr.length; i++){\\n            char ch = arr[i];\\n            if(ch == \\'(\\' || ch == \\'{\\' || ch == \\'[\\'){\\n                st.push(ch);\\n            }\\n            else if(ch == \\')\\' && st.peek() == \\'(\\'){\\n                st.pop();\\n            }\\n            else if(ch == \\'}\\' && st.peek() == \\'{\\'){\\n                st.pop();\\n            }\\n            else if(ch == \\']\\' && st.peek() == \\'[\\'){\\n                st.pop();\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        if(st.isEmpty()){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mr_nobody_4",
                        "content": " [@LeetCode](/LeetCode)\n\nHi, i can't submit my solution, it doesn't pass this test \"{[]}\", but it passes in the testcase block.\n\n`\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid push(char val);\nchar pop();\nbool isEmpty();\nbool isValid(char *s);\n\nstruct node\n{\n  char val;\n  struct node *next;\n};\n\nstruct node *head;\n\nint main()\n{\n  char temp[] = \"{[]}\";\n  printf(\"Valid is %d\\n\", isValid(temp));\n}\n\nbool isValid(char *s)\n{\n  for (int i = 0; i < strlen(s); i++)\n  {\n    if (s[i] == '(' || s[i] == '[' || s[i] == '{')\n    {\n      push(s[i]);\n    }\n    else if (!isEmpty())\n    {\n      char symbol = pop();\n      // printf(\"symbol %c\\n\", symbol);\n\n      if (symbol == '(' && s[i] != ')')\n      {\n        return false;\n      }\n\n      else if (symbol == '[' && s[i] != ']')\n      {\n        return false;\n      }\n      else if (symbol == '{' && s[i] != '}')\n      {\n        return false;\n      }\n    }\n    else\n    {\n      return false;\n    }\n  }\n  return isEmpty() ? true : false;\n}\n\nvoid push(char val)\n{\n  struct node *ptr = (struct node *)malloc(sizeof(struct node));\n\n  if (head == NULL)\n  {\n    ptr->val = val;\n    ptr->next = NULL;\n    head = ptr;\n  }\n  else\n  {\n    ptr->val = val;\n    ptr->next = head;\n    head = ptr;\n  }\n}\n\nchar pop()\n{\n  char item;\n  struct node *ptr;\n  if (head == NULL)\n    printf(\"Underflow State: can't remove any item\");\n  else\n  {\n    item = head->val;\n    ptr = head;\n    head = head->next;\n    free(ptr);\n    return item;\n  }\n  return -1;\n}\n\nbool isEmpty()\n{\n  return head == NULL ? true : false;\n}\n`\n"
                    },
                    {
                        "username": "mhou2009",
                        "content": "`        if (pi % 2 == 1 or ci % 2 == 1 or bi % 1 == 0):\\n            self.output = \"false\"\\n        print(self.output)\\n        return (self.output)`\\nthat\\'s my code at the end.\\nthe stdout says \"false\"\\nthe expected says \"false\"\\nbut the output is \"true\"\\ndoes the return somehow change the value?\\ns = \"(]\" here. i tried doing \\n`if s == \"(]\":\\n    self.output = \"false\"`\\nbut it still outputs true"
                    },
                    {
                        "username": "icdeadmoney",
                        "content": "return (self.output) is evaluating if the variable is assigned, as opposed to what it is assigned to.\\nfor example if you did\\n\\nprint((self.output)) return (self.output)\\n\\nthe extra () in the print may cause it to print \"true\" even though the word \"false\" is stored in the variable.\\n\\npersonally I would go with\\n\\nprint(self.output) return self.output\\n"
                    },
                    {
                        "username": "gauravbagul",
                        "content": "class Solution:\\n    def isValid(self, s: str) -> bool:\\n        l = len(s)\\n        while len(s) > 0:\\n            s = s.replace(\\'()\\',\\'\\').replace(\\'{}\\',\\'\\').replace(\\'[]\\',\\'\\')\\n            if l==len(s): \\n                return False\\n        return True"
                    },
                    {
                        "username": "tima4124",
                        "content": "public class Solution {\\n    public bool IsValid(string s) {\\n        Stack<char> temp = new Stack<char>();\\n            Boolean output = false;\\n            for(int i=0;i<s.Length;i++)\\n            {\\n                if(s[i]==\\'(\\'|| s[i] == \\'{\\'|| s[i] == \\'[\\')\\n                {\\n                    temp.Push(s[i]);\\n                }\\n                else\\n                {\\n                    if (temp.Count == 0)\\n                    return false;\\n                    char ch=temp.Pop();\\n                    if((s[i] == \\')\\'&&ch==\\'(\\')||(s[i] == \\'}\\' && ch == \\'{\\')||(s[i] == \\']\\' && ch == \\'[\\'))\\n                    {\\n                        output = true;\\n                    }\\n                    else\\n                    {\\n                        output = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(!output|| temp.Count>0)\\n            return false;\\n            else\\n            return true;\\n    }\\n}"
                    },
                    {
                        "username": "pulkit-raina",
                        "content": "bool isValid(char * s){\\n    int i, f=0;\\n    char queue[10000];\\n    for(i = 0 ; i <= strlen(s) ; i++)\\n    {\\n        if(s[i] == \\'(\\' || s[i] == \\'{\\' || s[i] == \\'[\\')\\n            queue[f++] = s[i];\\n        else if(s[i] == \\')\\' || s[i] == \\'}\\' || s[i] == \\']\\')\\n        {\\n            if (s[i] == \\')\\')\\n                if (queue[--f] != \\'(\\')\\n                        return false;\\n                else\\n                    continue;\\n            else if (s[i] == \\']\\')\\n                if (queue[--f] != \\'[\\')\\n                    return false;\\n                else\\n                    continue;\\n            else if (s[i] == \\'}\\')\\n                if (queue[--f] != \\'{\\')\\n                    return false;\\n                else\\n                    continue;\\n            else\\n                return false;\\n        }\\n        else if(s[i]==\\'\\\\0\\')\\n        {\\n            if(f==0)\\n                return true;\\n            else\\n                return false;\\n        }\\n\\n        else\\n            return false;\\n    }\\n}\\n\\ncan someone pls tell me what\\'s wrong in this C code. the comment on this says it reaches the end without any return value. when i run it in codeblocks, it runs properly, but here it doesn\\'t seem to"
                    },
                    {
                        "username": "Lupin_1107",
                        "content": "s =\\n\"{}{}{}{}{}{(([[]]))]\"\\nwhich condition i missed??"
                    },
                    {
                        "username": "ddowy",
                        "content": "Was stuck on this problem all day, then I read the hint... facepalm."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string str) {\\n        stack<char> left;\\n        for (char c : str) {\\n            if (c == \\'(\\' || c == \\'{\\' || c == \\'[\\')\\n                left.push(c);\\n            else { \\n                if (!left.empty() && leftOf(c) == left.top())\\n                    left.pop();\\n                else\\n                    \\n                    return false;\\n            }\\n        }\\n        \\n        return left.empty();\\n    }\\n\\n    char leftOf(char c) {\\n        if (c == \\'}\\') return \\'{\\';\\n        if (c == \\')\\') return \\'(\\';\\n        return \\'[\\';\\n    }\\n};\\n```"
                    },
                    {
                        "username": "briton2004",
                        "content": "var list = {\\n  \"{\": \"}\",\\n  \"[\": \"]\",\\n  \"(\": \")\",\\n};\\nvar check = [];\\nvar isValid = function (s) {\\n  for (i = 0; i < s.length; i++) {\\n    if (list[s[i]]) {\\n      check.push(list[s[i]]);\\n    } else if (check.length > 0 && check[check.length - 1] === s[i]) {\\n      check.pop();\\n    } else {\\n      return false;\\n    }\\n  }\\n  return check.length === 0;\\n};\\n\\nMY mehod workds in IDE but DOESNT WORK ON LEETCODE WHY?"
                    }
                ]
            },
            {
                "id": 1722325,
                "content": [
                    {
                        "username": "Adarshs_12",
                        "content": "//can anyone please explain where i made mistake//\\n\\nclass Solution {\\n    public boolean isValid(String s) {\\n        if(s.length() == 1){\\n            return false;\\n        }\\n        char[] arr = s.toCharArray();\\n        Stack<Character> st = new Stack<>();\\n        for(int i=0; i<arr.length; i++){\\n            char ch = arr[i];\\n            if(ch == \\'(\\' || ch == \\'{\\' || ch == \\'[\\'){\\n                st.push(ch);\\n            }\\n            else if(ch == \\')\\' && st.peek() == \\'(\\'){\\n                st.pop();\\n            }\\n            else if(ch == \\'}\\' && st.peek() == \\'{\\'){\\n                st.pop();\\n            }\\n            else if(ch == \\']\\' && st.peek() == \\'[\\'){\\n                st.pop();\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        if(st.isEmpty()){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mr_nobody_4",
                        "content": " [@LeetCode](/LeetCode)\n\nHi, i can't submit my solution, it doesn't pass this test \"{[]}\", but it passes in the testcase block.\n\n`\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid push(char val);\nchar pop();\nbool isEmpty();\nbool isValid(char *s);\n\nstruct node\n{\n  char val;\n  struct node *next;\n};\n\nstruct node *head;\n\nint main()\n{\n  char temp[] = \"{[]}\";\n  printf(\"Valid is %d\\n\", isValid(temp));\n}\n\nbool isValid(char *s)\n{\n  for (int i = 0; i < strlen(s); i++)\n  {\n    if (s[i] == '(' || s[i] == '[' || s[i] == '{')\n    {\n      push(s[i]);\n    }\n    else if (!isEmpty())\n    {\n      char symbol = pop();\n      // printf(\"symbol %c\\n\", symbol);\n\n      if (symbol == '(' && s[i] != ')')\n      {\n        return false;\n      }\n\n      else if (symbol == '[' && s[i] != ']')\n      {\n        return false;\n      }\n      else if (symbol == '{' && s[i] != '}')\n      {\n        return false;\n      }\n    }\n    else\n    {\n      return false;\n    }\n  }\n  return isEmpty() ? true : false;\n}\n\nvoid push(char val)\n{\n  struct node *ptr = (struct node *)malloc(sizeof(struct node));\n\n  if (head == NULL)\n  {\n    ptr->val = val;\n    ptr->next = NULL;\n    head = ptr;\n  }\n  else\n  {\n    ptr->val = val;\n    ptr->next = head;\n    head = ptr;\n  }\n}\n\nchar pop()\n{\n  char item;\n  struct node *ptr;\n  if (head == NULL)\n    printf(\"Underflow State: can't remove any item\");\n  else\n  {\n    item = head->val;\n    ptr = head;\n    head = head->next;\n    free(ptr);\n    return item;\n  }\n  return -1;\n}\n\nbool isEmpty()\n{\n  return head == NULL ? true : false;\n}\n`\n"
                    },
                    {
                        "username": "mhou2009",
                        "content": "`        if (pi % 2 == 1 or ci % 2 == 1 or bi % 1 == 0):\\n            self.output = \"false\"\\n        print(self.output)\\n        return (self.output)`\\nthat\\'s my code at the end.\\nthe stdout says \"false\"\\nthe expected says \"false\"\\nbut the output is \"true\"\\ndoes the return somehow change the value?\\ns = \"(]\" here. i tried doing \\n`if s == \"(]\":\\n    self.output = \"false\"`\\nbut it still outputs true"
                    },
                    {
                        "username": "icdeadmoney",
                        "content": "return (self.output) is evaluating if the variable is assigned, as opposed to what it is assigned to.\\nfor example if you did\\n\\nprint((self.output)) return (self.output)\\n\\nthe extra () in the print may cause it to print \"true\" even though the word \"false\" is stored in the variable.\\n\\npersonally I would go with\\n\\nprint(self.output) return self.output\\n"
                    },
                    {
                        "username": "gauravbagul",
                        "content": "class Solution:\\n    def isValid(self, s: str) -> bool:\\n        l = len(s)\\n        while len(s) > 0:\\n            s = s.replace(\\'()\\',\\'\\').replace(\\'{}\\',\\'\\').replace(\\'[]\\',\\'\\')\\n            if l==len(s): \\n                return False\\n        return True"
                    },
                    {
                        "username": "tima4124",
                        "content": "public class Solution {\\n    public bool IsValid(string s) {\\n        Stack<char> temp = new Stack<char>();\\n            Boolean output = false;\\n            for(int i=0;i<s.Length;i++)\\n            {\\n                if(s[i]==\\'(\\'|| s[i] == \\'{\\'|| s[i] == \\'[\\')\\n                {\\n                    temp.Push(s[i]);\\n                }\\n                else\\n                {\\n                    if (temp.Count == 0)\\n                    return false;\\n                    char ch=temp.Pop();\\n                    if((s[i] == \\')\\'&&ch==\\'(\\')||(s[i] == \\'}\\' && ch == \\'{\\')||(s[i] == \\']\\' && ch == \\'[\\'))\\n                    {\\n                        output = true;\\n                    }\\n                    else\\n                    {\\n                        output = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(!output|| temp.Count>0)\\n            return false;\\n            else\\n            return true;\\n    }\\n}"
                    },
                    {
                        "username": "pulkit-raina",
                        "content": "bool isValid(char * s){\\n    int i, f=0;\\n    char queue[10000];\\n    for(i = 0 ; i <= strlen(s) ; i++)\\n    {\\n        if(s[i] == \\'(\\' || s[i] == \\'{\\' || s[i] == \\'[\\')\\n            queue[f++] = s[i];\\n        else if(s[i] == \\')\\' || s[i] == \\'}\\' || s[i] == \\']\\')\\n        {\\n            if (s[i] == \\')\\')\\n                if (queue[--f] != \\'(\\')\\n                        return false;\\n                else\\n                    continue;\\n            else if (s[i] == \\']\\')\\n                if (queue[--f] != \\'[\\')\\n                    return false;\\n                else\\n                    continue;\\n            else if (s[i] == \\'}\\')\\n                if (queue[--f] != \\'{\\')\\n                    return false;\\n                else\\n                    continue;\\n            else\\n                return false;\\n        }\\n        else if(s[i]==\\'\\\\0\\')\\n        {\\n            if(f==0)\\n                return true;\\n            else\\n                return false;\\n        }\\n\\n        else\\n            return false;\\n    }\\n}\\n\\ncan someone pls tell me what\\'s wrong in this C code. the comment on this says it reaches the end without any return value. when i run it in codeblocks, it runs properly, but here it doesn\\'t seem to"
                    },
                    {
                        "username": "Lupin_1107",
                        "content": "s =\\n\"{}{}{}{}{}{(([[]]))]\"\\nwhich condition i missed??"
                    },
                    {
                        "username": "ddowy",
                        "content": "Was stuck on this problem all day, then I read the hint... facepalm."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string str) {\\n        stack<char> left;\\n        for (char c : str) {\\n            if (c == \\'(\\' || c == \\'{\\' || c == \\'[\\')\\n                left.push(c);\\n            else { \\n                if (!left.empty() && leftOf(c) == left.top())\\n                    left.pop();\\n                else\\n                    \\n                    return false;\\n            }\\n        }\\n        \\n        return left.empty();\\n    }\\n\\n    char leftOf(char c) {\\n        if (c == \\'}\\') return \\'{\\';\\n        if (c == \\')\\') return \\'(\\';\\n        return \\'[\\';\\n    }\\n};\\n```"
                    },
                    {
                        "username": "briton2004",
                        "content": "var list = {\\n  \"{\": \"}\",\\n  \"[\": \"]\",\\n  \"(\": \")\",\\n};\\nvar check = [];\\nvar isValid = function (s) {\\n  for (i = 0; i < s.length; i++) {\\n    if (list[s[i]]) {\\n      check.push(list[s[i]]);\\n    } else if (check.length > 0 && check[check.length - 1] === s[i]) {\\n      check.pop();\\n    } else {\\n      return false;\\n    }\\n  }\\n  return check.length === 0;\\n};\\n\\nMY mehod workds in IDE but DOESNT WORK ON LEETCODE WHY?"
                    }
                ]
            },
            {
                "id": 1720797,
                "content": [
                    {
                        "username": "Adarshs_12",
                        "content": "//can anyone please explain where i made mistake//\\n\\nclass Solution {\\n    public boolean isValid(String s) {\\n        if(s.length() == 1){\\n            return false;\\n        }\\n        char[] arr = s.toCharArray();\\n        Stack<Character> st = new Stack<>();\\n        for(int i=0; i<arr.length; i++){\\n            char ch = arr[i];\\n            if(ch == \\'(\\' || ch == \\'{\\' || ch == \\'[\\'){\\n                st.push(ch);\\n            }\\n            else if(ch == \\')\\' && st.peek() == \\'(\\'){\\n                st.pop();\\n            }\\n            else if(ch == \\'}\\' && st.peek() == \\'{\\'){\\n                st.pop();\\n            }\\n            else if(ch == \\']\\' && st.peek() == \\'[\\'){\\n                st.pop();\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        if(st.isEmpty()){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mr_nobody_4",
                        "content": " [@LeetCode](/LeetCode)\n\nHi, i can't submit my solution, it doesn't pass this test \"{[]}\", but it passes in the testcase block.\n\n`\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid push(char val);\nchar pop();\nbool isEmpty();\nbool isValid(char *s);\n\nstruct node\n{\n  char val;\n  struct node *next;\n};\n\nstruct node *head;\n\nint main()\n{\n  char temp[] = \"{[]}\";\n  printf(\"Valid is %d\\n\", isValid(temp));\n}\n\nbool isValid(char *s)\n{\n  for (int i = 0; i < strlen(s); i++)\n  {\n    if (s[i] == '(' || s[i] == '[' || s[i] == '{')\n    {\n      push(s[i]);\n    }\n    else if (!isEmpty())\n    {\n      char symbol = pop();\n      // printf(\"symbol %c\\n\", symbol);\n\n      if (symbol == '(' && s[i] != ')')\n      {\n        return false;\n      }\n\n      else if (symbol == '[' && s[i] != ']')\n      {\n        return false;\n      }\n      else if (symbol == '{' && s[i] != '}')\n      {\n        return false;\n      }\n    }\n    else\n    {\n      return false;\n    }\n  }\n  return isEmpty() ? true : false;\n}\n\nvoid push(char val)\n{\n  struct node *ptr = (struct node *)malloc(sizeof(struct node));\n\n  if (head == NULL)\n  {\n    ptr->val = val;\n    ptr->next = NULL;\n    head = ptr;\n  }\n  else\n  {\n    ptr->val = val;\n    ptr->next = head;\n    head = ptr;\n  }\n}\n\nchar pop()\n{\n  char item;\n  struct node *ptr;\n  if (head == NULL)\n    printf(\"Underflow State: can't remove any item\");\n  else\n  {\n    item = head->val;\n    ptr = head;\n    head = head->next;\n    free(ptr);\n    return item;\n  }\n  return -1;\n}\n\nbool isEmpty()\n{\n  return head == NULL ? true : false;\n}\n`\n"
                    },
                    {
                        "username": "mhou2009",
                        "content": "`        if (pi % 2 == 1 or ci % 2 == 1 or bi % 1 == 0):\\n            self.output = \"false\"\\n        print(self.output)\\n        return (self.output)`\\nthat\\'s my code at the end.\\nthe stdout says \"false\"\\nthe expected says \"false\"\\nbut the output is \"true\"\\ndoes the return somehow change the value?\\ns = \"(]\" here. i tried doing \\n`if s == \"(]\":\\n    self.output = \"false\"`\\nbut it still outputs true"
                    },
                    {
                        "username": "icdeadmoney",
                        "content": "return (self.output) is evaluating if the variable is assigned, as opposed to what it is assigned to.\\nfor example if you did\\n\\nprint((self.output)) return (self.output)\\n\\nthe extra () in the print may cause it to print \"true\" even though the word \"false\" is stored in the variable.\\n\\npersonally I would go with\\n\\nprint(self.output) return self.output\\n"
                    },
                    {
                        "username": "gauravbagul",
                        "content": "class Solution:\\n    def isValid(self, s: str) -> bool:\\n        l = len(s)\\n        while len(s) > 0:\\n            s = s.replace(\\'()\\',\\'\\').replace(\\'{}\\',\\'\\').replace(\\'[]\\',\\'\\')\\n            if l==len(s): \\n                return False\\n        return True"
                    },
                    {
                        "username": "tima4124",
                        "content": "public class Solution {\\n    public bool IsValid(string s) {\\n        Stack<char> temp = new Stack<char>();\\n            Boolean output = false;\\n            for(int i=0;i<s.Length;i++)\\n            {\\n                if(s[i]==\\'(\\'|| s[i] == \\'{\\'|| s[i] == \\'[\\')\\n                {\\n                    temp.Push(s[i]);\\n                }\\n                else\\n                {\\n                    if (temp.Count == 0)\\n                    return false;\\n                    char ch=temp.Pop();\\n                    if((s[i] == \\')\\'&&ch==\\'(\\')||(s[i] == \\'}\\' && ch == \\'{\\')||(s[i] == \\']\\' && ch == \\'[\\'))\\n                    {\\n                        output = true;\\n                    }\\n                    else\\n                    {\\n                        output = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(!output|| temp.Count>0)\\n            return false;\\n            else\\n            return true;\\n    }\\n}"
                    },
                    {
                        "username": "pulkit-raina",
                        "content": "bool isValid(char * s){\\n    int i, f=0;\\n    char queue[10000];\\n    for(i = 0 ; i <= strlen(s) ; i++)\\n    {\\n        if(s[i] == \\'(\\' || s[i] == \\'{\\' || s[i] == \\'[\\')\\n            queue[f++] = s[i];\\n        else if(s[i] == \\')\\' || s[i] == \\'}\\' || s[i] == \\']\\')\\n        {\\n            if (s[i] == \\')\\')\\n                if (queue[--f] != \\'(\\')\\n                        return false;\\n                else\\n                    continue;\\n            else if (s[i] == \\']\\')\\n                if (queue[--f] != \\'[\\')\\n                    return false;\\n                else\\n                    continue;\\n            else if (s[i] == \\'}\\')\\n                if (queue[--f] != \\'{\\')\\n                    return false;\\n                else\\n                    continue;\\n            else\\n                return false;\\n        }\\n        else if(s[i]==\\'\\\\0\\')\\n        {\\n            if(f==0)\\n                return true;\\n            else\\n                return false;\\n        }\\n\\n        else\\n            return false;\\n    }\\n}\\n\\ncan someone pls tell me what\\'s wrong in this C code. the comment on this says it reaches the end without any return value. when i run it in codeblocks, it runs properly, but here it doesn\\'t seem to"
                    },
                    {
                        "username": "Lupin_1107",
                        "content": "s =\\n\"{}{}{}{}{}{(([[]]))]\"\\nwhich condition i missed??"
                    },
                    {
                        "username": "ddowy",
                        "content": "Was stuck on this problem all day, then I read the hint... facepalm."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string str) {\\n        stack<char> left;\\n        for (char c : str) {\\n            if (c == \\'(\\' || c == \\'{\\' || c == \\'[\\')\\n                left.push(c);\\n            else { \\n                if (!left.empty() && leftOf(c) == left.top())\\n                    left.pop();\\n                else\\n                    \\n                    return false;\\n            }\\n        }\\n        \\n        return left.empty();\\n    }\\n\\n    char leftOf(char c) {\\n        if (c == \\'}\\') return \\'{\\';\\n        if (c == \\')\\') return \\'(\\';\\n        return \\'[\\';\\n    }\\n};\\n```"
                    },
                    {
                        "username": "briton2004",
                        "content": "var list = {\\n  \"{\": \"}\",\\n  \"[\": \"]\",\\n  \"(\": \")\",\\n};\\nvar check = [];\\nvar isValid = function (s) {\\n  for (i = 0; i < s.length; i++) {\\n    if (list[s[i]]) {\\n      check.push(list[s[i]]);\\n    } else if (check.length > 0 && check[check.length - 1] === s[i]) {\\n      check.pop();\\n    } else {\\n      return false;\\n    }\\n  }\\n  return check.length === 0;\\n};\\n\\nMY mehod workds in IDE but DOESNT WORK ON LEETCODE WHY?"
                    }
                ]
            },
            {
                "id": 1717307,
                "content": [
                    {
                        "username": "Adarshs_12",
                        "content": "//can anyone please explain where i made mistake//\\n\\nclass Solution {\\n    public boolean isValid(String s) {\\n        if(s.length() == 1){\\n            return false;\\n        }\\n        char[] arr = s.toCharArray();\\n        Stack<Character> st = new Stack<>();\\n        for(int i=0; i<arr.length; i++){\\n            char ch = arr[i];\\n            if(ch == \\'(\\' || ch == \\'{\\' || ch == \\'[\\'){\\n                st.push(ch);\\n            }\\n            else if(ch == \\')\\' && st.peek() == \\'(\\'){\\n                st.pop();\\n            }\\n            else if(ch == \\'}\\' && st.peek() == \\'{\\'){\\n                st.pop();\\n            }\\n            else if(ch == \\']\\' && st.peek() == \\'[\\'){\\n                st.pop();\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        if(st.isEmpty()){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mr_nobody_4",
                        "content": " [@LeetCode](/LeetCode)\n\nHi, i can't submit my solution, it doesn't pass this test \"{[]}\", but it passes in the testcase block.\n\n`\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid push(char val);\nchar pop();\nbool isEmpty();\nbool isValid(char *s);\n\nstruct node\n{\n  char val;\n  struct node *next;\n};\n\nstruct node *head;\n\nint main()\n{\n  char temp[] = \"{[]}\";\n  printf(\"Valid is %d\\n\", isValid(temp));\n}\n\nbool isValid(char *s)\n{\n  for (int i = 0; i < strlen(s); i++)\n  {\n    if (s[i] == '(' || s[i] == '[' || s[i] == '{')\n    {\n      push(s[i]);\n    }\n    else if (!isEmpty())\n    {\n      char symbol = pop();\n      // printf(\"symbol %c\\n\", symbol);\n\n      if (symbol == '(' && s[i] != ')')\n      {\n        return false;\n      }\n\n      else if (symbol == '[' && s[i] != ']')\n      {\n        return false;\n      }\n      else if (symbol == '{' && s[i] != '}')\n      {\n        return false;\n      }\n    }\n    else\n    {\n      return false;\n    }\n  }\n  return isEmpty() ? true : false;\n}\n\nvoid push(char val)\n{\n  struct node *ptr = (struct node *)malloc(sizeof(struct node));\n\n  if (head == NULL)\n  {\n    ptr->val = val;\n    ptr->next = NULL;\n    head = ptr;\n  }\n  else\n  {\n    ptr->val = val;\n    ptr->next = head;\n    head = ptr;\n  }\n}\n\nchar pop()\n{\n  char item;\n  struct node *ptr;\n  if (head == NULL)\n    printf(\"Underflow State: can't remove any item\");\n  else\n  {\n    item = head->val;\n    ptr = head;\n    head = head->next;\n    free(ptr);\n    return item;\n  }\n  return -1;\n}\n\nbool isEmpty()\n{\n  return head == NULL ? true : false;\n}\n`\n"
                    },
                    {
                        "username": "mhou2009",
                        "content": "`        if (pi % 2 == 1 or ci % 2 == 1 or bi % 1 == 0):\\n            self.output = \"false\"\\n        print(self.output)\\n        return (self.output)`\\nthat\\'s my code at the end.\\nthe stdout says \"false\"\\nthe expected says \"false\"\\nbut the output is \"true\"\\ndoes the return somehow change the value?\\ns = \"(]\" here. i tried doing \\n`if s == \"(]\":\\n    self.output = \"false\"`\\nbut it still outputs true"
                    },
                    {
                        "username": "icdeadmoney",
                        "content": "return (self.output) is evaluating if the variable is assigned, as opposed to what it is assigned to.\\nfor example if you did\\n\\nprint((self.output)) return (self.output)\\n\\nthe extra () in the print may cause it to print \"true\" even though the word \"false\" is stored in the variable.\\n\\npersonally I would go with\\n\\nprint(self.output) return self.output\\n"
                    },
                    {
                        "username": "gauravbagul",
                        "content": "class Solution:\\n    def isValid(self, s: str) -> bool:\\n        l = len(s)\\n        while len(s) > 0:\\n            s = s.replace(\\'()\\',\\'\\').replace(\\'{}\\',\\'\\').replace(\\'[]\\',\\'\\')\\n            if l==len(s): \\n                return False\\n        return True"
                    },
                    {
                        "username": "tima4124",
                        "content": "public class Solution {\\n    public bool IsValid(string s) {\\n        Stack<char> temp = new Stack<char>();\\n            Boolean output = false;\\n            for(int i=0;i<s.Length;i++)\\n            {\\n                if(s[i]==\\'(\\'|| s[i] == \\'{\\'|| s[i] == \\'[\\')\\n                {\\n                    temp.Push(s[i]);\\n                }\\n                else\\n                {\\n                    if (temp.Count == 0)\\n                    return false;\\n                    char ch=temp.Pop();\\n                    if((s[i] == \\')\\'&&ch==\\'(\\')||(s[i] == \\'}\\' && ch == \\'{\\')||(s[i] == \\']\\' && ch == \\'[\\'))\\n                    {\\n                        output = true;\\n                    }\\n                    else\\n                    {\\n                        output = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(!output|| temp.Count>0)\\n            return false;\\n            else\\n            return true;\\n    }\\n}"
                    },
                    {
                        "username": "pulkit-raina",
                        "content": "bool isValid(char * s){\\n    int i, f=0;\\n    char queue[10000];\\n    for(i = 0 ; i <= strlen(s) ; i++)\\n    {\\n        if(s[i] == \\'(\\' || s[i] == \\'{\\' || s[i] == \\'[\\')\\n            queue[f++] = s[i];\\n        else if(s[i] == \\')\\' || s[i] == \\'}\\' || s[i] == \\']\\')\\n        {\\n            if (s[i] == \\')\\')\\n                if (queue[--f] != \\'(\\')\\n                        return false;\\n                else\\n                    continue;\\n            else if (s[i] == \\']\\')\\n                if (queue[--f] != \\'[\\')\\n                    return false;\\n                else\\n                    continue;\\n            else if (s[i] == \\'}\\')\\n                if (queue[--f] != \\'{\\')\\n                    return false;\\n                else\\n                    continue;\\n            else\\n                return false;\\n        }\\n        else if(s[i]==\\'\\\\0\\')\\n        {\\n            if(f==0)\\n                return true;\\n            else\\n                return false;\\n        }\\n\\n        else\\n            return false;\\n    }\\n}\\n\\ncan someone pls tell me what\\'s wrong in this C code. the comment on this says it reaches the end without any return value. when i run it in codeblocks, it runs properly, but here it doesn\\'t seem to"
                    },
                    {
                        "username": "Lupin_1107",
                        "content": "s =\\n\"{}{}{}{}{}{(([[]]))]\"\\nwhich condition i missed??"
                    },
                    {
                        "username": "ddowy",
                        "content": "Was stuck on this problem all day, then I read the hint... facepalm."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string str) {\\n        stack<char> left;\\n        for (char c : str) {\\n            if (c == \\'(\\' || c == \\'{\\' || c == \\'[\\')\\n                left.push(c);\\n            else { \\n                if (!left.empty() && leftOf(c) == left.top())\\n                    left.pop();\\n                else\\n                    \\n                    return false;\\n            }\\n        }\\n        \\n        return left.empty();\\n    }\\n\\n    char leftOf(char c) {\\n        if (c == \\'}\\') return \\'{\\';\\n        if (c == \\')\\') return \\'(\\';\\n        return \\'[\\';\\n    }\\n};\\n```"
                    },
                    {
                        "username": "briton2004",
                        "content": "var list = {\\n  \"{\": \"}\",\\n  \"[\": \"]\",\\n  \"(\": \")\",\\n};\\nvar check = [];\\nvar isValid = function (s) {\\n  for (i = 0; i < s.length; i++) {\\n    if (list[s[i]]) {\\n      check.push(list[s[i]]);\\n    } else if (check.length > 0 && check[check.length - 1] === s[i]) {\\n      check.pop();\\n    } else {\\n      return false;\\n    }\\n  }\\n  return check.length === 0;\\n};\\n\\nMY mehod workds in IDE but DOESNT WORK ON LEETCODE WHY?"
                    }
                ]
            },
            {
                "id": 1712294,
                "content": [
                    {
                        "username": "Adarshs_12",
                        "content": "//can anyone please explain where i made mistake//\\n\\nclass Solution {\\n    public boolean isValid(String s) {\\n        if(s.length() == 1){\\n            return false;\\n        }\\n        char[] arr = s.toCharArray();\\n        Stack<Character> st = new Stack<>();\\n        for(int i=0; i<arr.length; i++){\\n            char ch = arr[i];\\n            if(ch == \\'(\\' || ch == \\'{\\' || ch == \\'[\\'){\\n                st.push(ch);\\n            }\\n            else if(ch == \\')\\' && st.peek() == \\'(\\'){\\n                st.pop();\\n            }\\n            else if(ch == \\'}\\' && st.peek() == \\'{\\'){\\n                st.pop();\\n            }\\n            else if(ch == \\']\\' && st.peek() == \\'[\\'){\\n                st.pop();\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        if(st.isEmpty()){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mr_nobody_4",
                        "content": " [@LeetCode](/LeetCode)\n\nHi, i can't submit my solution, it doesn't pass this test \"{[]}\", but it passes in the testcase block.\n\n`\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid push(char val);\nchar pop();\nbool isEmpty();\nbool isValid(char *s);\n\nstruct node\n{\n  char val;\n  struct node *next;\n};\n\nstruct node *head;\n\nint main()\n{\n  char temp[] = \"{[]}\";\n  printf(\"Valid is %d\\n\", isValid(temp));\n}\n\nbool isValid(char *s)\n{\n  for (int i = 0; i < strlen(s); i++)\n  {\n    if (s[i] == '(' || s[i] == '[' || s[i] == '{')\n    {\n      push(s[i]);\n    }\n    else if (!isEmpty())\n    {\n      char symbol = pop();\n      // printf(\"symbol %c\\n\", symbol);\n\n      if (symbol == '(' && s[i] != ')')\n      {\n        return false;\n      }\n\n      else if (symbol == '[' && s[i] != ']')\n      {\n        return false;\n      }\n      else if (symbol == '{' && s[i] != '}')\n      {\n        return false;\n      }\n    }\n    else\n    {\n      return false;\n    }\n  }\n  return isEmpty() ? true : false;\n}\n\nvoid push(char val)\n{\n  struct node *ptr = (struct node *)malloc(sizeof(struct node));\n\n  if (head == NULL)\n  {\n    ptr->val = val;\n    ptr->next = NULL;\n    head = ptr;\n  }\n  else\n  {\n    ptr->val = val;\n    ptr->next = head;\n    head = ptr;\n  }\n}\n\nchar pop()\n{\n  char item;\n  struct node *ptr;\n  if (head == NULL)\n    printf(\"Underflow State: can't remove any item\");\n  else\n  {\n    item = head->val;\n    ptr = head;\n    head = head->next;\n    free(ptr);\n    return item;\n  }\n  return -1;\n}\n\nbool isEmpty()\n{\n  return head == NULL ? true : false;\n}\n`\n"
                    },
                    {
                        "username": "mhou2009",
                        "content": "`        if (pi % 2 == 1 or ci % 2 == 1 or bi % 1 == 0):\\n            self.output = \"false\"\\n        print(self.output)\\n        return (self.output)`\\nthat\\'s my code at the end.\\nthe stdout says \"false\"\\nthe expected says \"false\"\\nbut the output is \"true\"\\ndoes the return somehow change the value?\\ns = \"(]\" here. i tried doing \\n`if s == \"(]\":\\n    self.output = \"false\"`\\nbut it still outputs true"
                    },
                    {
                        "username": "icdeadmoney",
                        "content": "return (self.output) is evaluating if the variable is assigned, as opposed to what it is assigned to.\\nfor example if you did\\n\\nprint((self.output)) return (self.output)\\n\\nthe extra () in the print may cause it to print \"true\" even though the word \"false\" is stored in the variable.\\n\\npersonally I would go with\\n\\nprint(self.output) return self.output\\n"
                    },
                    {
                        "username": "gauravbagul",
                        "content": "class Solution:\\n    def isValid(self, s: str) -> bool:\\n        l = len(s)\\n        while len(s) > 0:\\n            s = s.replace(\\'()\\',\\'\\').replace(\\'{}\\',\\'\\').replace(\\'[]\\',\\'\\')\\n            if l==len(s): \\n                return False\\n        return True"
                    },
                    {
                        "username": "tima4124",
                        "content": "public class Solution {\\n    public bool IsValid(string s) {\\n        Stack<char> temp = new Stack<char>();\\n            Boolean output = false;\\n            for(int i=0;i<s.Length;i++)\\n            {\\n                if(s[i]==\\'(\\'|| s[i] == \\'{\\'|| s[i] == \\'[\\')\\n                {\\n                    temp.Push(s[i]);\\n                }\\n                else\\n                {\\n                    if (temp.Count == 0)\\n                    return false;\\n                    char ch=temp.Pop();\\n                    if((s[i] == \\')\\'&&ch==\\'(\\')||(s[i] == \\'}\\' && ch == \\'{\\')||(s[i] == \\']\\' && ch == \\'[\\'))\\n                    {\\n                        output = true;\\n                    }\\n                    else\\n                    {\\n                        output = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(!output|| temp.Count>0)\\n            return false;\\n            else\\n            return true;\\n    }\\n}"
                    },
                    {
                        "username": "pulkit-raina",
                        "content": "bool isValid(char * s){\\n    int i, f=0;\\n    char queue[10000];\\n    for(i = 0 ; i <= strlen(s) ; i++)\\n    {\\n        if(s[i] == \\'(\\' || s[i] == \\'{\\' || s[i] == \\'[\\')\\n            queue[f++] = s[i];\\n        else if(s[i] == \\')\\' || s[i] == \\'}\\' || s[i] == \\']\\')\\n        {\\n            if (s[i] == \\')\\')\\n                if (queue[--f] != \\'(\\')\\n                        return false;\\n                else\\n                    continue;\\n            else if (s[i] == \\']\\')\\n                if (queue[--f] != \\'[\\')\\n                    return false;\\n                else\\n                    continue;\\n            else if (s[i] == \\'}\\')\\n                if (queue[--f] != \\'{\\')\\n                    return false;\\n                else\\n                    continue;\\n            else\\n                return false;\\n        }\\n        else if(s[i]==\\'\\\\0\\')\\n        {\\n            if(f==0)\\n                return true;\\n            else\\n                return false;\\n        }\\n\\n        else\\n            return false;\\n    }\\n}\\n\\ncan someone pls tell me what\\'s wrong in this C code. the comment on this says it reaches the end without any return value. when i run it in codeblocks, it runs properly, but here it doesn\\'t seem to"
                    },
                    {
                        "username": "Lupin_1107",
                        "content": "s =\\n\"{}{}{}{}{}{(([[]]))]\"\\nwhich condition i missed??"
                    },
                    {
                        "username": "ddowy",
                        "content": "Was stuck on this problem all day, then I read the hint... facepalm."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string str) {\\n        stack<char> left;\\n        for (char c : str) {\\n            if (c == \\'(\\' || c == \\'{\\' || c == \\'[\\')\\n                left.push(c);\\n            else { \\n                if (!left.empty() && leftOf(c) == left.top())\\n                    left.pop();\\n                else\\n                    \\n                    return false;\\n            }\\n        }\\n        \\n        return left.empty();\\n    }\\n\\n    char leftOf(char c) {\\n        if (c == \\'}\\') return \\'{\\';\\n        if (c == \\')\\') return \\'(\\';\\n        return \\'[\\';\\n    }\\n};\\n```"
                    },
                    {
                        "username": "briton2004",
                        "content": "var list = {\\n  \"{\": \"}\",\\n  \"[\": \"]\",\\n  \"(\": \")\",\\n};\\nvar check = [];\\nvar isValid = function (s) {\\n  for (i = 0; i < s.length; i++) {\\n    if (list[s[i]]) {\\n      check.push(list[s[i]]);\\n    } else if (check.length > 0 && check[check.length - 1] === s[i]) {\\n      check.pop();\\n    } else {\\n      return false;\\n    }\\n  }\\n  return check.length === 0;\\n};\\n\\nMY mehod workds in IDE but DOESNT WORK ON LEETCODE WHY?"
                    }
                ]
            },
            {
                "id": 1708957,
                "content": [
                    {
                        "username": "Adarshs_12",
                        "content": "//can anyone please explain where i made mistake//\\n\\nclass Solution {\\n    public boolean isValid(String s) {\\n        if(s.length() == 1){\\n            return false;\\n        }\\n        char[] arr = s.toCharArray();\\n        Stack<Character> st = new Stack<>();\\n        for(int i=0; i<arr.length; i++){\\n            char ch = arr[i];\\n            if(ch == \\'(\\' || ch == \\'{\\' || ch == \\'[\\'){\\n                st.push(ch);\\n            }\\n            else if(ch == \\')\\' && st.peek() == \\'(\\'){\\n                st.pop();\\n            }\\n            else if(ch == \\'}\\' && st.peek() == \\'{\\'){\\n                st.pop();\\n            }\\n            else if(ch == \\']\\' && st.peek() == \\'[\\'){\\n                st.pop();\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        if(st.isEmpty()){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mr_nobody_4",
                        "content": " [@LeetCode](/LeetCode)\n\nHi, i can't submit my solution, it doesn't pass this test \"{[]}\", but it passes in the testcase block.\n\n`\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid push(char val);\nchar pop();\nbool isEmpty();\nbool isValid(char *s);\n\nstruct node\n{\n  char val;\n  struct node *next;\n};\n\nstruct node *head;\n\nint main()\n{\n  char temp[] = \"{[]}\";\n  printf(\"Valid is %d\\n\", isValid(temp));\n}\n\nbool isValid(char *s)\n{\n  for (int i = 0; i < strlen(s); i++)\n  {\n    if (s[i] == '(' || s[i] == '[' || s[i] == '{')\n    {\n      push(s[i]);\n    }\n    else if (!isEmpty())\n    {\n      char symbol = pop();\n      // printf(\"symbol %c\\n\", symbol);\n\n      if (symbol == '(' && s[i] != ')')\n      {\n        return false;\n      }\n\n      else if (symbol == '[' && s[i] != ']')\n      {\n        return false;\n      }\n      else if (symbol == '{' && s[i] != '}')\n      {\n        return false;\n      }\n    }\n    else\n    {\n      return false;\n    }\n  }\n  return isEmpty() ? true : false;\n}\n\nvoid push(char val)\n{\n  struct node *ptr = (struct node *)malloc(sizeof(struct node));\n\n  if (head == NULL)\n  {\n    ptr->val = val;\n    ptr->next = NULL;\n    head = ptr;\n  }\n  else\n  {\n    ptr->val = val;\n    ptr->next = head;\n    head = ptr;\n  }\n}\n\nchar pop()\n{\n  char item;\n  struct node *ptr;\n  if (head == NULL)\n    printf(\"Underflow State: can't remove any item\");\n  else\n  {\n    item = head->val;\n    ptr = head;\n    head = head->next;\n    free(ptr);\n    return item;\n  }\n  return -1;\n}\n\nbool isEmpty()\n{\n  return head == NULL ? true : false;\n}\n`\n"
                    },
                    {
                        "username": "mhou2009",
                        "content": "`        if (pi % 2 == 1 or ci % 2 == 1 or bi % 1 == 0):\\n            self.output = \"false\"\\n        print(self.output)\\n        return (self.output)`\\nthat\\'s my code at the end.\\nthe stdout says \"false\"\\nthe expected says \"false\"\\nbut the output is \"true\"\\ndoes the return somehow change the value?\\ns = \"(]\" here. i tried doing \\n`if s == \"(]\":\\n    self.output = \"false\"`\\nbut it still outputs true"
                    },
                    {
                        "username": "icdeadmoney",
                        "content": "return (self.output) is evaluating if the variable is assigned, as opposed to what it is assigned to.\\nfor example if you did\\n\\nprint((self.output)) return (self.output)\\n\\nthe extra () in the print may cause it to print \"true\" even though the word \"false\" is stored in the variable.\\n\\npersonally I would go with\\n\\nprint(self.output) return self.output\\n"
                    },
                    {
                        "username": "gauravbagul",
                        "content": "class Solution:\\n    def isValid(self, s: str) -> bool:\\n        l = len(s)\\n        while len(s) > 0:\\n            s = s.replace(\\'()\\',\\'\\').replace(\\'{}\\',\\'\\').replace(\\'[]\\',\\'\\')\\n            if l==len(s): \\n                return False\\n        return True"
                    },
                    {
                        "username": "tima4124",
                        "content": "public class Solution {\\n    public bool IsValid(string s) {\\n        Stack<char> temp = new Stack<char>();\\n            Boolean output = false;\\n            for(int i=0;i<s.Length;i++)\\n            {\\n                if(s[i]==\\'(\\'|| s[i] == \\'{\\'|| s[i] == \\'[\\')\\n                {\\n                    temp.Push(s[i]);\\n                }\\n                else\\n                {\\n                    if (temp.Count == 0)\\n                    return false;\\n                    char ch=temp.Pop();\\n                    if((s[i] == \\')\\'&&ch==\\'(\\')||(s[i] == \\'}\\' && ch == \\'{\\')||(s[i] == \\']\\' && ch == \\'[\\'))\\n                    {\\n                        output = true;\\n                    }\\n                    else\\n                    {\\n                        output = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(!output|| temp.Count>0)\\n            return false;\\n            else\\n            return true;\\n    }\\n}"
                    },
                    {
                        "username": "pulkit-raina",
                        "content": "bool isValid(char * s){\\n    int i, f=0;\\n    char queue[10000];\\n    for(i = 0 ; i <= strlen(s) ; i++)\\n    {\\n        if(s[i] == \\'(\\' || s[i] == \\'{\\' || s[i] == \\'[\\')\\n            queue[f++] = s[i];\\n        else if(s[i] == \\')\\' || s[i] == \\'}\\' || s[i] == \\']\\')\\n        {\\n            if (s[i] == \\')\\')\\n                if (queue[--f] != \\'(\\')\\n                        return false;\\n                else\\n                    continue;\\n            else if (s[i] == \\']\\')\\n                if (queue[--f] != \\'[\\')\\n                    return false;\\n                else\\n                    continue;\\n            else if (s[i] == \\'}\\')\\n                if (queue[--f] != \\'{\\')\\n                    return false;\\n                else\\n                    continue;\\n            else\\n                return false;\\n        }\\n        else if(s[i]==\\'\\\\0\\')\\n        {\\n            if(f==0)\\n                return true;\\n            else\\n                return false;\\n        }\\n\\n        else\\n            return false;\\n    }\\n}\\n\\ncan someone pls tell me what\\'s wrong in this C code. the comment on this says it reaches the end without any return value. when i run it in codeblocks, it runs properly, but here it doesn\\'t seem to"
                    },
                    {
                        "username": "Lupin_1107",
                        "content": "s =\\n\"{}{}{}{}{}{(([[]]))]\"\\nwhich condition i missed??"
                    },
                    {
                        "username": "ddowy",
                        "content": "Was stuck on this problem all day, then I read the hint... facepalm."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string str) {\\n        stack<char> left;\\n        for (char c : str) {\\n            if (c == \\'(\\' || c == \\'{\\' || c == \\'[\\')\\n                left.push(c);\\n            else { \\n                if (!left.empty() && leftOf(c) == left.top())\\n                    left.pop();\\n                else\\n                    \\n                    return false;\\n            }\\n        }\\n        \\n        return left.empty();\\n    }\\n\\n    char leftOf(char c) {\\n        if (c == \\'}\\') return \\'{\\';\\n        if (c == \\')\\') return \\'(\\';\\n        return \\'[\\';\\n    }\\n};\\n```"
                    },
                    {
                        "username": "briton2004",
                        "content": "var list = {\\n  \"{\": \"}\",\\n  \"[\": \"]\",\\n  \"(\": \")\",\\n};\\nvar check = [];\\nvar isValid = function (s) {\\n  for (i = 0; i < s.length; i++) {\\n    if (list[s[i]]) {\\n      check.push(list[s[i]]);\\n    } else if (check.length > 0 && check[check.length - 1] === s[i]) {\\n      check.pop();\\n    } else {\\n      return false;\\n    }\\n  }\\n  return check.length === 0;\\n};\\n\\nMY mehod workds in IDE but DOESNT WORK ON LEETCODE WHY?"
                    }
                ]
            },
            {
                "id": 1708665,
                "content": [
                    {
                        "username": "Adarshs_12",
                        "content": "//can anyone please explain where i made mistake//\\n\\nclass Solution {\\n    public boolean isValid(String s) {\\n        if(s.length() == 1){\\n            return false;\\n        }\\n        char[] arr = s.toCharArray();\\n        Stack<Character> st = new Stack<>();\\n        for(int i=0; i<arr.length; i++){\\n            char ch = arr[i];\\n            if(ch == \\'(\\' || ch == \\'{\\' || ch == \\'[\\'){\\n                st.push(ch);\\n            }\\n            else if(ch == \\')\\' && st.peek() == \\'(\\'){\\n                st.pop();\\n            }\\n            else if(ch == \\'}\\' && st.peek() == \\'{\\'){\\n                st.pop();\\n            }\\n            else if(ch == \\']\\' && st.peek() == \\'[\\'){\\n                st.pop();\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        if(st.isEmpty()){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mr_nobody_4",
                        "content": " [@LeetCode](/LeetCode)\n\nHi, i can't submit my solution, it doesn't pass this test \"{[]}\", but it passes in the testcase block.\n\n`\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid push(char val);\nchar pop();\nbool isEmpty();\nbool isValid(char *s);\n\nstruct node\n{\n  char val;\n  struct node *next;\n};\n\nstruct node *head;\n\nint main()\n{\n  char temp[] = \"{[]}\";\n  printf(\"Valid is %d\\n\", isValid(temp));\n}\n\nbool isValid(char *s)\n{\n  for (int i = 0; i < strlen(s); i++)\n  {\n    if (s[i] == '(' || s[i] == '[' || s[i] == '{')\n    {\n      push(s[i]);\n    }\n    else if (!isEmpty())\n    {\n      char symbol = pop();\n      // printf(\"symbol %c\\n\", symbol);\n\n      if (symbol == '(' && s[i] != ')')\n      {\n        return false;\n      }\n\n      else if (symbol == '[' && s[i] != ']')\n      {\n        return false;\n      }\n      else if (symbol == '{' && s[i] != '}')\n      {\n        return false;\n      }\n    }\n    else\n    {\n      return false;\n    }\n  }\n  return isEmpty() ? true : false;\n}\n\nvoid push(char val)\n{\n  struct node *ptr = (struct node *)malloc(sizeof(struct node));\n\n  if (head == NULL)\n  {\n    ptr->val = val;\n    ptr->next = NULL;\n    head = ptr;\n  }\n  else\n  {\n    ptr->val = val;\n    ptr->next = head;\n    head = ptr;\n  }\n}\n\nchar pop()\n{\n  char item;\n  struct node *ptr;\n  if (head == NULL)\n    printf(\"Underflow State: can't remove any item\");\n  else\n  {\n    item = head->val;\n    ptr = head;\n    head = head->next;\n    free(ptr);\n    return item;\n  }\n  return -1;\n}\n\nbool isEmpty()\n{\n  return head == NULL ? true : false;\n}\n`\n"
                    },
                    {
                        "username": "mhou2009",
                        "content": "`        if (pi % 2 == 1 or ci % 2 == 1 or bi % 1 == 0):\\n            self.output = \"false\"\\n        print(self.output)\\n        return (self.output)`\\nthat\\'s my code at the end.\\nthe stdout says \"false\"\\nthe expected says \"false\"\\nbut the output is \"true\"\\ndoes the return somehow change the value?\\ns = \"(]\" here. i tried doing \\n`if s == \"(]\":\\n    self.output = \"false\"`\\nbut it still outputs true"
                    },
                    {
                        "username": "icdeadmoney",
                        "content": "return (self.output) is evaluating if the variable is assigned, as opposed to what it is assigned to.\\nfor example if you did\\n\\nprint((self.output)) return (self.output)\\n\\nthe extra () in the print may cause it to print \"true\" even though the word \"false\" is stored in the variable.\\n\\npersonally I would go with\\n\\nprint(self.output) return self.output\\n"
                    },
                    {
                        "username": "gauravbagul",
                        "content": "class Solution:\\n    def isValid(self, s: str) -> bool:\\n        l = len(s)\\n        while len(s) > 0:\\n            s = s.replace(\\'()\\',\\'\\').replace(\\'{}\\',\\'\\').replace(\\'[]\\',\\'\\')\\n            if l==len(s): \\n                return False\\n        return True"
                    },
                    {
                        "username": "tima4124",
                        "content": "public class Solution {\\n    public bool IsValid(string s) {\\n        Stack<char> temp = new Stack<char>();\\n            Boolean output = false;\\n            for(int i=0;i<s.Length;i++)\\n            {\\n                if(s[i]==\\'(\\'|| s[i] == \\'{\\'|| s[i] == \\'[\\')\\n                {\\n                    temp.Push(s[i]);\\n                }\\n                else\\n                {\\n                    if (temp.Count == 0)\\n                    return false;\\n                    char ch=temp.Pop();\\n                    if((s[i] == \\')\\'&&ch==\\'(\\')||(s[i] == \\'}\\' && ch == \\'{\\')||(s[i] == \\']\\' && ch == \\'[\\'))\\n                    {\\n                        output = true;\\n                    }\\n                    else\\n                    {\\n                        output = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(!output|| temp.Count>0)\\n            return false;\\n            else\\n            return true;\\n    }\\n}"
                    },
                    {
                        "username": "pulkit-raina",
                        "content": "bool isValid(char * s){\\n    int i, f=0;\\n    char queue[10000];\\n    for(i = 0 ; i <= strlen(s) ; i++)\\n    {\\n        if(s[i] == \\'(\\' || s[i] == \\'{\\' || s[i] == \\'[\\')\\n            queue[f++] = s[i];\\n        else if(s[i] == \\')\\' || s[i] == \\'}\\' || s[i] == \\']\\')\\n        {\\n            if (s[i] == \\')\\')\\n                if (queue[--f] != \\'(\\')\\n                        return false;\\n                else\\n                    continue;\\n            else if (s[i] == \\']\\')\\n                if (queue[--f] != \\'[\\')\\n                    return false;\\n                else\\n                    continue;\\n            else if (s[i] == \\'}\\')\\n                if (queue[--f] != \\'{\\')\\n                    return false;\\n                else\\n                    continue;\\n            else\\n                return false;\\n        }\\n        else if(s[i]==\\'\\\\0\\')\\n        {\\n            if(f==0)\\n                return true;\\n            else\\n                return false;\\n        }\\n\\n        else\\n            return false;\\n    }\\n}\\n\\ncan someone pls tell me what\\'s wrong in this C code. the comment on this says it reaches the end without any return value. when i run it in codeblocks, it runs properly, but here it doesn\\'t seem to"
                    },
                    {
                        "username": "Lupin_1107",
                        "content": "s =\\n\"{}{}{}{}{}{(([[]]))]\"\\nwhich condition i missed??"
                    },
                    {
                        "username": "ddowy",
                        "content": "Was stuck on this problem all day, then I read the hint... facepalm."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string str) {\\n        stack<char> left;\\n        for (char c : str) {\\n            if (c == \\'(\\' || c == \\'{\\' || c == \\'[\\')\\n                left.push(c);\\n            else { \\n                if (!left.empty() && leftOf(c) == left.top())\\n                    left.pop();\\n                else\\n                    \\n                    return false;\\n            }\\n        }\\n        \\n        return left.empty();\\n    }\\n\\n    char leftOf(char c) {\\n        if (c == \\'}\\') return \\'{\\';\\n        if (c == \\')\\') return \\'(\\';\\n        return \\'[\\';\\n    }\\n};\\n```"
                    },
                    {
                        "username": "briton2004",
                        "content": "var list = {\\n  \"{\": \"}\",\\n  \"[\": \"]\",\\n  \"(\": \")\",\\n};\\nvar check = [];\\nvar isValid = function (s) {\\n  for (i = 0; i < s.length; i++) {\\n    if (list[s[i]]) {\\n      check.push(list[s[i]]);\\n    } else if (check.length > 0 && check[check.length - 1] === s[i]) {\\n      check.pop();\\n    } else {\\n      return false;\\n    }\\n  }\\n  return check.length === 0;\\n};\\n\\nMY mehod workds in IDE but DOESNT WORK ON LEETCODE WHY?"
                    }
                ]
            },
            {
                "id": 1700338,
                "content": [
                    {
                        "username": "Adarshs_12",
                        "content": "//can anyone please explain where i made mistake//\\n\\nclass Solution {\\n    public boolean isValid(String s) {\\n        if(s.length() == 1){\\n            return false;\\n        }\\n        char[] arr = s.toCharArray();\\n        Stack<Character> st = new Stack<>();\\n        for(int i=0; i<arr.length; i++){\\n            char ch = arr[i];\\n            if(ch == \\'(\\' || ch == \\'{\\' || ch == \\'[\\'){\\n                st.push(ch);\\n            }\\n            else if(ch == \\')\\' && st.peek() == \\'(\\'){\\n                st.pop();\\n            }\\n            else if(ch == \\'}\\' && st.peek() == \\'{\\'){\\n                st.pop();\\n            }\\n            else if(ch == \\']\\' && st.peek() == \\'[\\'){\\n                st.pop();\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        if(st.isEmpty()){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mr_nobody_4",
                        "content": " [@LeetCode](/LeetCode)\n\nHi, i can't submit my solution, it doesn't pass this test \"{[]}\", but it passes in the testcase block.\n\n`\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid push(char val);\nchar pop();\nbool isEmpty();\nbool isValid(char *s);\n\nstruct node\n{\n  char val;\n  struct node *next;\n};\n\nstruct node *head;\n\nint main()\n{\n  char temp[] = \"{[]}\";\n  printf(\"Valid is %d\\n\", isValid(temp));\n}\n\nbool isValid(char *s)\n{\n  for (int i = 0; i < strlen(s); i++)\n  {\n    if (s[i] == '(' || s[i] == '[' || s[i] == '{')\n    {\n      push(s[i]);\n    }\n    else if (!isEmpty())\n    {\n      char symbol = pop();\n      // printf(\"symbol %c\\n\", symbol);\n\n      if (symbol == '(' && s[i] != ')')\n      {\n        return false;\n      }\n\n      else if (symbol == '[' && s[i] != ']')\n      {\n        return false;\n      }\n      else if (symbol == '{' && s[i] != '}')\n      {\n        return false;\n      }\n    }\n    else\n    {\n      return false;\n    }\n  }\n  return isEmpty() ? true : false;\n}\n\nvoid push(char val)\n{\n  struct node *ptr = (struct node *)malloc(sizeof(struct node));\n\n  if (head == NULL)\n  {\n    ptr->val = val;\n    ptr->next = NULL;\n    head = ptr;\n  }\n  else\n  {\n    ptr->val = val;\n    ptr->next = head;\n    head = ptr;\n  }\n}\n\nchar pop()\n{\n  char item;\n  struct node *ptr;\n  if (head == NULL)\n    printf(\"Underflow State: can't remove any item\");\n  else\n  {\n    item = head->val;\n    ptr = head;\n    head = head->next;\n    free(ptr);\n    return item;\n  }\n  return -1;\n}\n\nbool isEmpty()\n{\n  return head == NULL ? true : false;\n}\n`\n"
                    },
                    {
                        "username": "mhou2009",
                        "content": "`        if (pi % 2 == 1 or ci % 2 == 1 or bi % 1 == 0):\\n            self.output = \"false\"\\n        print(self.output)\\n        return (self.output)`\\nthat\\'s my code at the end.\\nthe stdout says \"false\"\\nthe expected says \"false\"\\nbut the output is \"true\"\\ndoes the return somehow change the value?\\ns = \"(]\" here. i tried doing \\n`if s == \"(]\":\\n    self.output = \"false\"`\\nbut it still outputs true"
                    },
                    {
                        "username": "icdeadmoney",
                        "content": "return (self.output) is evaluating if the variable is assigned, as opposed to what it is assigned to.\\nfor example if you did\\n\\nprint((self.output)) return (self.output)\\n\\nthe extra () in the print may cause it to print \"true\" even though the word \"false\" is stored in the variable.\\n\\npersonally I would go with\\n\\nprint(self.output) return self.output\\n"
                    },
                    {
                        "username": "gauravbagul",
                        "content": "class Solution:\\n    def isValid(self, s: str) -> bool:\\n        l = len(s)\\n        while len(s) > 0:\\n            s = s.replace(\\'()\\',\\'\\').replace(\\'{}\\',\\'\\').replace(\\'[]\\',\\'\\')\\n            if l==len(s): \\n                return False\\n        return True"
                    },
                    {
                        "username": "tima4124",
                        "content": "public class Solution {\\n    public bool IsValid(string s) {\\n        Stack<char> temp = new Stack<char>();\\n            Boolean output = false;\\n            for(int i=0;i<s.Length;i++)\\n            {\\n                if(s[i]==\\'(\\'|| s[i] == \\'{\\'|| s[i] == \\'[\\')\\n                {\\n                    temp.Push(s[i]);\\n                }\\n                else\\n                {\\n                    if (temp.Count == 0)\\n                    return false;\\n                    char ch=temp.Pop();\\n                    if((s[i] == \\')\\'&&ch==\\'(\\')||(s[i] == \\'}\\' && ch == \\'{\\')||(s[i] == \\']\\' && ch == \\'[\\'))\\n                    {\\n                        output = true;\\n                    }\\n                    else\\n                    {\\n                        output = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(!output|| temp.Count>0)\\n            return false;\\n            else\\n            return true;\\n    }\\n}"
                    },
                    {
                        "username": "pulkit-raina",
                        "content": "bool isValid(char * s){\\n    int i, f=0;\\n    char queue[10000];\\n    for(i = 0 ; i <= strlen(s) ; i++)\\n    {\\n        if(s[i] == \\'(\\' || s[i] == \\'{\\' || s[i] == \\'[\\')\\n            queue[f++] = s[i];\\n        else if(s[i] == \\')\\' || s[i] == \\'}\\' || s[i] == \\']\\')\\n        {\\n            if (s[i] == \\')\\')\\n                if (queue[--f] != \\'(\\')\\n                        return false;\\n                else\\n                    continue;\\n            else if (s[i] == \\']\\')\\n                if (queue[--f] != \\'[\\')\\n                    return false;\\n                else\\n                    continue;\\n            else if (s[i] == \\'}\\')\\n                if (queue[--f] != \\'{\\')\\n                    return false;\\n                else\\n                    continue;\\n            else\\n                return false;\\n        }\\n        else if(s[i]==\\'\\\\0\\')\\n        {\\n            if(f==0)\\n                return true;\\n            else\\n                return false;\\n        }\\n\\n        else\\n            return false;\\n    }\\n}\\n\\ncan someone pls tell me what\\'s wrong in this C code. the comment on this says it reaches the end without any return value. when i run it in codeblocks, it runs properly, but here it doesn\\'t seem to"
                    },
                    {
                        "username": "Lupin_1107",
                        "content": "s =\\n\"{}{}{}{}{}{(([[]]))]\"\\nwhich condition i missed??"
                    },
                    {
                        "username": "ddowy",
                        "content": "Was stuck on this problem all day, then I read the hint... facepalm."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string str) {\\n        stack<char> left;\\n        for (char c : str) {\\n            if (c == \\'(\\' || c == \\'{\\' || c == \\'[\\')\\n                left.push(c);\\n            else { \\n                if (!left.empty() && leftOf(c) == left.top())\\n                    left.pop();\\n                else\\n                    \\n                    return false;\\n            }\\n        }\\n        \\n        return left.empty();\\n    }\\n\\n    char leftOf(char c) {\\n        if (c == \\'}\\') return \\'{\\';\\n        if (c == \\')\\') return \\'(\\';\\n        return \\'[\\';\\n    }\\n};\\n```"
                    },
                    {
                        "username": "briton2004",
                        "content": "var list = {\\n  \"{\": \"}\",\\n  \"[\": \"]\",\\n  \"(\": \")\",\\n};\\nvar check = [];\\nvar isValid = function (s) {\\n  for (i = 0; i < s.length; i++) {\\n    if (list[s[i]]) {\\n      check.push(list[s[i]]);\\n    } else if (check.length > 0 && check[check.length - 1] === s[i]) {\\n      check.pop();\\n    } else {\\n      return false;\\n    }\\n  }\\n  return check.length === 0;\\n};\\n\\nMY mehod workds in IDE but DOESNT WORK ON LEETCODE WHY?"
                    }
                ]
            },
            {
                "id": 1699460,
                "content": [
                    {
                        "username": "Adarshs_12",
                        "content": "//can anyone please explain where i made mistake//\\n\\nclass Solution {\\n    public boolean isValid(String s) {\\n        if(s.length() == 1){\\n            return false;\\n        }\\n        char[] arr = s.toCharArray();\\n        Stack<Character> st = new Stack<>();\\n        for(int i=0; i<arr.length; i++){\\n            char ch = arr[i];\\n            if(ch == \\'(\\' || ch == \\'{\\' || ch == \\'[\\'){\\n                st.push(ch);\\n            }\\n            else if(ch == \\')\\' && st.peek() == \\'(\\'){\\n                st.pop();\\n            }\\n            else if(ch == \\'}\\' && st.peek() == \\'{\\'){\\n                st.pop();\\n            }\\n            else if(ch == \\']\\' && st.peek() == \\'[\\'){\\n                st.pop();\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        if(st.isEmpty()){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mr_nobody_4",
                        "content": " [@LeetCode](/LeetCode)\n\nHi, i can't submit my solution, it doesn't pass this test \"{[]}\", but it passes in the testcase block.\n\n`\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid push(char val);\nchar pop();\nbool isEmpty();\nbool isValid(char *s);\n\nstruct node\n{\n  char val;\n  struct node *next;\n};\n\nstruct node *head;\n\nint main()\n{\n  char temp[] = \"{[]}\";\n  printf(\"Valid is %d\\n\", isValid(temp));\n}\n\nbool isValid(char *s)\n{\n  for (int i = 0; i < strlen(s); i++)\n  {\n    if (s[i] == '(' || s[i] == '[' || s[i] == '{')\n    {\n      push(s[i]);\n    }\n    else if (!isEmpty())\n    {\n      char symbol = pop();\n      // printf(\"symbol %c\\n\", symbol);\n\n      if (symbol == '(' && s[i] != ')')\n      {\n        return false;\n      }\n\n      else if (symbol == '[' && s[i] != ']')\n      {\n        return false;\n      }\n      else if (symbol == '{' && s[i] != '}')\n      {\n        return false;\n      }\n    }\n    else\n    {\n      return false;\n    }\n  }\n  return isEmpty() ? true : false;\n}\n\nvoid push(char val)\n{\n  struct node *ptr = (struct node *)malloc(sizeof(struct node));\n\n  if (head == NULL)\n  {\n    ptr->val = val;\n    ptr->next = NULL;\n    head = ptr;\n  }\n  else\n  {\n    ptr->val = val;\n    ptr->next = head;\n    head = ptr;\n  }\n}\n\nchar pop()\n{\n  char item;\n  struct node *ptr;\n  if (head == NULL)\n    printf(\"Underflow State: can't remove any item\");\n  else\n  {\n    item = head->val;\n    ptr = head;\n    head = head->next;\n    free(ptr);\n    return item;\n  }\n  return -1;\n}\n\nbool isEmpty()\n{\n  return head == NULL ? true : false;\n}\n`\n"
                    },
                    {
                        "username": "mhou2009",
                        "content": "`        if (pi % 2 == 1 or ci % 2 == 1 or bi % 1 == 0):\\n            self.output = \"false\"\\n        print(self.output)\\n        return (self.output)`\\nthat\\'s my code at the end.\\nthe stdout says \"false\"\\nthe expected says \"false\"\\nbut the output is \"true\"\\ndoes the return somehow change the value?\\ns = \"(]\" here. i tried doing \\n`if s == \"(]\":\\n    self.output = \"false\"`\\nbut it still outputs true"
                    },
                    {
                        "username": "icdeadmoney",
                        "content": "return (self.output) is evaluating if the variable is assigned, as opposed to what it is assigned to.\\nfor example if you did\\n\\nprint((self.output)) return (self.output)\\n\\nthe extra () in the print may cause it to print \"true\" even though the word \"false\" is stored in the variable.\\n\\npersonally I would go with\\n\\nprint(self.output) return self.output\\n"
                    },
                    {
                        "username": "gauravbagul",
                        "content": "class Solution:\\n    def isValid(self, s: str) -> bool:\\n        l = len(s)\\n        while len(s) > 0:\\n            s = s.replace(\\'()\\',\\'\\').replace(\\'{}\\',\\'\\').replace(\\'[]\\',\\'\\')\\n            if l==len(s): \\n                return False\\n        return True"
                    },
                    {
                        "username": "tima4124",
                        "content": "public class Solution {\\n    public bool IsValid(string s) {\\n        Stack<char> temp = new Stack<char>();\\n            Boolean output = false;\\n            for(int i=0;i<s.Length;i++)\\n            {\\n                if(s[i]==\\'(\\'|| s[i] == \\'{\\'|| s[i] == \\'[\\')\\n                {\\n                    temp.Push(s[i]);\\n                }\\n                else\\n                {\\n                    if (temp.Count == 0)\\n                    return false;\\n                    char ch=temp.Pop();\\n                    if((s[i] == \\')\\'&&ch==\\'(\\')||(s[i] == \\'}\\' && ch == \\'{\\')||(s[i] == \\']\\' && ch == \\'[\\'))\\n                    {\\n                        output = true;\\n                    }\\n                    else\\n                    {\\n                        output = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(!output|| temp.Count>0)\\n            return false;\\n            else\\n            return true;\\n    }\\n}"
                    },
                    {
                        "username": "pulkit-raina",
                        "content": "bool isValid(char * s){\\n    int i, f=0;\\n    char queue[10000];\\n    for(i = 0 ; i <= strlen(s) ; i++)\\n    {\\n        if(s[i] == \\'(\\' || s[i] == \\'{\\' || s[i] == \\'[\\')\\n            queue[f++] = s[i];\\n        else if(s[i] == \\')\\' || s[i] == \\'}\\' || s[i] == \\']\\')\\n        {\\n            if (s[i] == \\')\\')\\n                if (queue[--f] != \\'(\\')\\n                        return false;\\n                else\\n                    continue;\\n            else if (s[i] == \\']\\')\\n                if (queue[--f] != \\'[\\')\\n                    return false;\\n                else\\n                    continue;\\n            else if (s[i] == \\'}\\')\\n                if (queue[--f] != \\'{\\')\\n                    return false;\\n                else\\n                    continue;\\n            else\\n                return false;\\n        }\\n        else if(s[i]==\\'\\\\0\\')\\n        {\\n            if(f==0)\\n                return true;\\n            else\\n                return false;\\n        }\\n\\n        else\\n            return false;\\n    }\\n}\\n\\ncan someone pls tell me what\\'s wrong in this C code. the comment on this says it reaches the end without any return value. when i run it in codeblocks, it runs properly, but here it doesn\\'t seem to"
                    },
                    {
                        "username": "Lupin_1107",
                        "content": "s =\\n\"{}{}{}{}{}{(([[]]))]\"\\nwhich condition i missed??"
                    },
                    {
                        "username": "ddowy",
                        "content": "Was stuck on this problem all day, then I read the hint... facepalm."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string str) {\\n        stack<char> left;\\n        for (char c : str) {\\n            if (c == \\'(\\' || c == \\'{\\' || c == \\'[\\')\\n                left.push(c);\\n            else { \\n                if (!left.empty() && leftOf(c) == left.top())\\n                    left.pop();\\n                else\\n                    \\n                    return false;\\n            }\\n        }\\n        \\n        return left.empty();\\n    }\\n\\n    char leftOf(char c) {\\n        if (c == \\'}\\') return \\'{\\';\\n        if (c == \\')\\') return \\'(\\';\\n        return \\'[\\';\\n    }\\n};\\n```"
                    },
                    {
                        "username": "briton2004",
                        "content": "var list = {\\n  \"{\": \"}\",\\n  \"[\": \"]\",\\n  \"(\": \")\",\\n};\\nvar check = [];\\nvar isValid = function (s) {\\n  for (i = 0; i < s.length; i++) {\\n    if (list[s[i]]) {\\n      check.push(list[s[i]]);\\n    } else if (check.length > 0 && check[check.length - 1] === s[i]) {\\n      check.pop();\\n    } else {\\n      return false;\\n    }\\n  }\\n  return check.length === 0;\\n};\\n\\nMY mehod workds in IDE but DOESNT WORK ON LEETCODE WHY?"
                    }
                ]
            },
            {
                "id": 1696513,
                "content": [
                    {
                        "username": "Adarshs_12",
                        "content": "//can anyone please explain where i made mistake//\\n\\nclass Solution {\\n    public boolean isValid(String s) {\\n        if(s.length() == 1){\\n            return false;\\n        }\\n        char[] arr = s.toCharArray();\\n        Stack<Character> st = new Stack<>();\\n        for(int i=0; i<arr.length; i++){\\n            char ch = arr[i];\\n            if(ch == \\'(\\' || ch == \\'{\\' || ch == \\'[\\'){\\n                st.push(ch);\\n            }\\n            else if(ch == \\')\\' && st.peek() == \\'(\\'){\\n                st.pop();\\n            }\\n            else if(ch == \\'}\\' && st.peek() == \\'{\\'){\\n                st.pop();\\n            }\\n            else if(ch == \\']\\' && st.peek() == \\'[\\'){\\n                st.pop();\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        if(st.isEmpty()){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mr_nobody_4",
                        "content": " [@LeetCode](/LeetCode)\n\nHi, i can't submit my solution, it doesn't pass this test \"{[]}\", but it passes in the testcase block.\n\n`\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid push(char val);\nchar pop();\nbool isEmpty();\nbool isValid(char *s);\n\nstruct node\n{\n  char val;\n  struct node *next;\n};\n\nstruct node *head;\n\nint main()\n{\n  char temp[] = \"{[]}\";\n  printf(\"Valid is %d\\n\", isValid(temp));\n}\n\nbool isValid(char *s)\n{\n  for (int i = 0; i < strlen(s); i++)\n  {\n    if (s[i] == '(' || s[i] == '[' || s[i] == '{')\n    {\n      push(s[i]);\n    }\n    else if (!isEmpty())\n    {\n      char symbol = pop();\n      // printf(\"symbol %c\\n\", symbol);\n\n      if (symbol == '(' && s[i] != ')')\n      {\n        return false;\n      }\n\n      else if (symbol == '[' && s[i] != ']')\n      {\n        return false;\n      }\n      else if (symbol == '{' && s[i] != '}')\n      {\n        return false;\n      }\n    }\n    else\n    {\n      return false;\n    }\n  }\n  return isEmpty() ? true : false;\n}\n\nvoid push(char val)\n{\n  struct node *ptr = (struct node *)malloc(sizeof(struct node));\n\n  if (head == NULL)\n  {\n    ptr->val = val;\n    ptr->next = NULL;\n    head = ptr;\n  }\n  else\n  {\n    ptr->val = val;\n    ptr->next = head;\n    head = ptr;\n  }\n}\n\nchar pop()\n{\n  char item;\n  struct node *ptr;\n  if (head == NULL)\n    printf(\"Underflow State: can't remove any item\");\n  else\n  {\n    item = head->val;\n    ptr = head;\n    head = head->next;\n    free(ptr);\n    return item;\n  }\n  return -1;\n}\n\nbool isEmpty()\n{\n  return head == NULL ? true : false;\n}\n`\n"
                    },
                    {
                        "username": "mhou2009",
                        "content": "`        if (pi % 2 == 1 or ci % 2 == 1 or bi % 1 == 0):\\n            self.output = \"false\"\\n        print(self.output)\\n        return (self.output)`\\nthat\\'s my code at the end.\\nthe stdout says \"false\"\\nthe expected says \"false\"\\nbut the output is \"true\"\\ndoes the return somehow change the value?\\ns = \"(]\" here. i tried doing \\n`if s == \"(]\":\\n    self.output = \"false\"`\\nbut it still outputs true"
                    },
                    {
                        "username": "icdeadmoney",
                        "content": "return (self.output) is evaluating if the variable is assigned, as opposed to what it is assigned to.\\nfor example if you did\\n\\nprint((self.output)) return (self.output)\\n\\nthe extra () in the print may cause it to print \"true\" even though the word \"false\" is stored in the variable.\\n\\npersonally I would go with\\n\\nprint(self.output) return self.output\\n"
                    },
                    {
                        "username": "gauravbagul",
                        "content": "class Solution:\\n    def isValid(self, s: str) -> bool:\\n        l = len(s)\\n        while len(s) > 0:\\n            s = s.replace(\\'()\\',\\'\\').replace(\\'{}\\',\\'\\').replace(\\'[]\\',\\'\\')\\n            if l==len(s): \\n                return False\\n        return True"
                    },
                    {
                        "username": "tima4124",
                        "content": "public class Solution {\\n    public bool IsValid(string s) {\\n        Stack<char> temp = new Stack<char>();\\n            Boolean output = false;\\n            for(int i=0;i<s.Length;i++)\\n            {\\n                if(s[i]==\\'(\\'|| s[i] == \\'{\\'|| s[i] == \\'[\\')\\n                {\\n                    temp.Push(s[i]);\\n                }\\n                else\\n                {\\n                    if (temp.Count == 0)\\n                    return false;\\n                    char ch=temp.Pop();\\n                    if((s[i] == \\')\\'&&ch==\\'(\\')||(s[i] == \\'}\\' && ch == \\'{\\')||(s[i] == \\']\\' && ch == \\'[\\'))\\n                    {\\n                        output = true;\\n                    }\\n                    else\\n                    {\\n                        output = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(!output|| temp.Count>0)\\n            return false;\\n            else\\n            return true;\\n    }\\n}"
                    },
                    {
                        "username": "pulkit-raina",
                        "content": "bool isValid(char * s){\\n    int i, f=0;\\n    char queue[10000];\\n    for(i = 0 ; i <= strlen(s) ; i++)\\n    {\\n        if(s[i] == \\'(\\' || s[i] == \\'{\\' || s[i] == \\'[\\')\\n            queue[f++] = s[i];\\n        else if(s[i] == \\')\\' || s[i] == \\'}\\' || s[i] == \\']\\')\\n        {\\n            if (s[i] == \\')\\')\\n                if (queue[--f] != \\'(\\')\\n                        return false;\\n                else\\n                    continue;\\n            else if (s[i] == \\']\\')\\n                if (queue[--f] != \\'[\\')\\n                    return false;\\n                else\\n                    continue;\\n            else if (s[i] == \\'}\\')\\n                if (queue[--f] != \\'{\\')\\n                    return false;\\n                else\\n                    continue;\\n            else\\n                return false;\\n        }\\n        else if(s[i]==\\'\\\\0\\')\\n        {\\n            if(f==0)\\n                return true;\\n            else\\n                return false;\\n        }\\n\\n        else\\n            return false;\\n    }\\n}\\n\\ncan someone pls tell me what\\'s wrong in this C code. the comment on this says it reaches the end without any return value. when i run it in codeblocks, it runs properly, but here it doesn\\'t seem to"
                    },
                    {
                        "username": "Lupin_1107",
                        "content": "s =\\n\"{}{}{}{}{}{(([[]]))]\"\\nwhich condition i missed??"
                    },
                    {
                        "username": "ddowy",
                        "content": "Was stuck on this problem all day, then I read the hint... facepalm."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string str) {\\n        stack<char> left;\\n        for (char c : str) {\\n            if (c == \\'(\\' || c == \\'{\\' || c == \\'[\\')\\n                left.push(c);\\n            else { \\n                if (!left.empty() && leftOf(c) == left.top())\\n                    left.pop();\\n                else\\n                    \\n                    return false;\\n            }\\n        }\\n        \\n        return left.empty();\\n    }\\n\\n    char leftOf(char c) {\\n        if (c == \\'}\\') return \\'{\\';\\n        if (c == \\')\\') return \\'(\\';\\n        return \\'[\\';\\n    }\\n};\\n```"
                    },
                    {
                        "username": "briton2004",
                        "content": "var list = {\\n  \"{\": \"}\",\\n  \"[\": \"]\",\\n  \"(\": \")\",\\n};\\nvar check = [];\\nvar isValid = function (s) {\\n  for (i = 0; i < s.length; i++) {\\n    if (list[s[i]]) {\\n      check.push(list[s[i]]);\\n    } else if (check.length > 0 && check[check.length - 1] === s[i]) {\\n      check.pop();\\n    } else {\\n      return false;\\n    }\\n  }\\n  return check.length === 0;\\n};\\n\\nMY mehod workds in IDE but DOESNT WORK ON LEETCODE WHY?"
                    }
                ]
            },
            {
                "id": 1694336,
                "content": [
                    {
                        "username": "gi_raffe",
                        "content": "As my understanding, the problem description doesn\\'t rule out the case where the string could contain an odd number of characters, e.g., \"()[\". This should be included in the test case"
                    },
                    {
                        "username": "sayWhatOneMoreTime",
                        "content": "Well it actually does. The following sentence in the description rules out this case: \"Every close bracket has a corresponding open bracket of the same type.\""
                    },
                    {
                        "username": "ULUGBEK_KOZIMOV",
                        "content": "I cheked \"([)]\" with JS case 58, but if in code wasn't (return false), anyway expected was = false; WTF?"
                    },
                    {
                        "username": "Badhrinarayana",
                        "content": "I used a stack and my code was working well with sample testcases but it is giving a runtime error plese help me\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n\\n        int n=s.size();\\n        if(n%2 ==1)\\n        return false;\\n\\n        stack<char>stk;\\n        for(int i=0;i<s.size();i++){\\n            char c=s[i];\\n            if(c==\\'(\\'|| c==\\'[\\'|| c==\\'{\\'){\\n                stk.push(c);\\n            }\\n            else{\\n                char t=stk.top();\\n                if( (t==\\'(\\' && c==\\')\\') ||(t==\\'[\\' && c==\\']\\') ||(t==\\'{\\' && c==\\'}\\') )\\n                stk.pop();\\n\\n                else\\n                stk.push(c);\\n            }\\n            \\n        }\\n        if(stk.empty())\\n        return true;\\n\\n        return false;\\n\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "saagicha1601",
                        "content": "if v follow all the instructions that is give \\nthis test case should be valid  \"( [ ) ]\" \\ncan some1 tell the correct way \\nonly this test case is not working "
                    },
                    {
                        "username": "jskiertsky",
                        "content": "Important concept here is that of the *stack* - a data structure that lets you in constant time add/remove to the end/top, and in constant time \\'peek\\' at the top.\\n\\nThis question can be solved in linear time with the use of a stack data structure."
                    },
                    {
                        "username": "shabnamhaque",
                        "content": "i am stuck at separating the sentence into character array.w e can solve using ascii value method."
                    },
                    {
                        "username": "uz-java",
                        "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> leftSymbols=new Stack<>();\\n\\n        for(char c: s.toCharArray()){\\n            if(c==\\'(\\' || c==\\'{\\' || c==\\'[\\'){\\n                leftSymbols.push(c);\\n            }else if(c==\\')\\' && !leftSymbols.isEmpty() && leftSymbols.peek()==\\'(\\'){\\n                leftSymbols.pop();\\n            }else if(c==\\'}\\' && !leftSymbols.isEmpty() && leftSymbols.peek()==\\'{\\'){\\n                leftSymbols.pop();\\n            }else if(c==\\']\\' && !leftSymbols.isEmpty() && leftSymbols.peek()==\\'[\\'){\\n                leftSymbols.pop();\\n            }else{\\n                return false;\\n            }\\n        }\\n        return leftSymbols.isEmpty();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "karunasagar6",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> st = new Stack <>();\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\' || s.charAt(i) == \\'{\\' ) \\n                st.push(s.charAt(i));\\n            else{\\n                if(st.empty()) return false;\\n                else if (st.peek() == \\'(\\'  && s.charAt(i) == \\')\\' ) st.pop();\\n                else if (st.peek() == \\'[\\'  && s.charAt(i) == \\']\\' ) st.pop();\\n                else if (st.peek() == \\'{\\'  && s.charAt(i) == \\'}\\' ) st.pop();\\n                else return false;\\n            }\\n        }\\n        return st.empty();\\n    }\\n}"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-valid-parentheses-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-valid-parentheses-problem-solution.html)"
                    },
                    {
                        "username": "ashokekumar",
                        "content": "class Solution {\\npublic:\\n    stack<string> st;\\n    bool isValid(string s) {\\n    for(int i=0; i<s.size(); i++)\\n        {\\n        if(s[i]==\\'(\\' || s[i]==\\'[\\' ||\\n           s[i]==\\'{\\')\\n            st.push(s[i]);\\n        else\\n           if(s[i]==\\')\\' && st.peek()!=\\'(\\') return false;\\n        \\n        \\n  else   if(s[i]==\\']\\' && st.peek()!=\\'[\\') return false;\\n              \\n else  if(s[i]==\\'}\\' && st.peek()!=\\'{\\') return false;\\n                \\n  else \\n    st.pop();\\n    }\\n      if(st.empty()) return true; else return false;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1691473,
                "content": [
                    {
                        "username": "gi_raffe",
                        "content": "As my understanding, the problem description doesn\\'t rule out the case where the string could contain an odd number of characters, e.g., \"()[\". This should be included in the test case"
                    },
                    {
                        "username": "sayWhatOneMoreTime",
                        "content": "Well it actually does. The following sentence in the description rules out this case: \"Every close bracket has a corresponding open bracket of the same type.\""
                    },
                    {
                        "username": "ULUGBEK_KOZIMOV",
                        "content": "I cheked \"([)]\" with JS case 58, but if in code wasn't (return false), anyway expected was = false; WTF?"
                    },
                    {
                        "username": "Badhrinarayana",
                        "content": "I used a stack and my code was working well with sample testcases but it is giving a runtime error plese help me\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n\\n        int n=s.size();\\n        if(n%2 ==1)\\n        return false;\\n\\n        stack<char>stk;\\n        for(int i=0;i<s.size();i++){\\n            char c=s[i];\\n            if(c==\\'(\\'|| c==\\'[\\'|| c==\\'{\\'){\\n                stk.push(c);\\n            }\\n            else{\\n                char t=stk.top();\\n                if( (t==\\'(\\' && c==\\')\\') ||(t==\\'[\\' && c==\\']\\') ||(t==\\'{\\' && c==\\'}\\') )\\n                stk.pop();\\n\\n                else\\n                stk.push(c);\\n            }\\n            \\n        }\\n        if(stk.empty())\\n        return true;\\n\\n        return false;\\n\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "saagicha1601",
                        "content": "if v follow all the instructions that is give \\nthis test case should be valid  \"( [ ) ]\" \\ncan some1 tell the correct way \\nonly this test case is not working "
                    },
                    {
                        "username": "jskiertsky",
                        "content": "Important concept here is that of the *stack* - a data structure that lets you in constant time add/remove to the end/top, and in constant time \\'peek\\' at the top.\\n\\nThis question can be solved in linear time with the use of a stack data structure."
                    },
                    {
                        "username": "shabnamhaque",
                        "content": "i am stuck at separating the sentence into character array.w e can solve using ascii value method."
                    },
                    {
                        "username": "uz-java",
                        "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> leftSymbols=new Stack<>();\\n\\n        for(char c: s.toCharArray()){\\n            if(c==\\'(\\' || c==\\'{\\' || c==\\'[\\'){\\n                leftSymbols.push(c);\\n            }else if(c==\\')\\' && !leftSymbols.isEmpty() && leftSymbols.peek()==\\'(\\'){\\n                leftSymbols.pop();\\n            }else if(c==\\'}\\' && !leftSymbols.isEmpty() && leftSymbols.peek()==\\'{\\'){\\n                leftSymbols.pop();\\n            }else if(c==\\']\\' && !leftSymbols.isEmpty() && leftSymbols.peek()==\\'[\\'){\\n                leftSymbols.pop();\\n            }else{\\n                return false;\\n            }\\n        }\\n        return leftSymbols.isEmpty();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "karunasagar6",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> st = new Stack <>();\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\' || s.charAt(i) == \\'{\\' ) \\n                st.push(s.charAt(i));\\n            else{\\n                if(st.empty()) return false;\\n                else if (st.peek() == \\'(\\'  && s.charAt(i) == \\')\\' ) st.pop();\\n                else if (st.peek() == \\'[\\'  && s.charAt(i) == \\']\\' ) st.pop();\\n                else if (st.peek() == \\'{\\'  && s.charAt(i) == \\'}\\' ) st.pop();\\n                else return false;\\n            }\\n        }\\n        return st.empty();\\n    }\\n}"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-valid-parentheses-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-valid-parentheses-problem-solution.html)"
                    },
                    {
                        "username": "ashokekumar",
                        "content": "class Solution {\\npublic:\\n    stack<string> st;\\n    bool isValid(string s) {\\n    for(int i=0; i<s.size(); i++)\\n        {\\n        if(s[i]==\\'(\\' || s[i]==\\'[\\' ||\\n           s[i]==\\'{\\')\\n            st.push(s[i]);\\n        else\\n           if(s[i]==\\')\\' && st.peek()!=\\'(\\') return false;\\n        \\n        \\n  else   if(s[i]==\\']\\' && st.peek()!=\\'[\\') return false;\\n              \\n else  if(s[i]==\\'}\\' && st.peek()!=\\'{\\') return false;\\n                \\n  else \\n    st.pop();\\n    }\\n      if(st.empty()) return true; else return false;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1689951,
                "content": [
                    {
                        "username": "gi_raffe",
                        "content": "As my understanding, the problem description doesn\\'t rule out the case where the string could contain an odd number of characters, e.g., \"()[\". This should be included in the test case"
                    },
                    {
                        "username": "sayWhatOneMoreTime",
                        "content": "Well it actually does. The following sentence in the description rules out this case: \"Every close bracket has a corresponding open bracket of the same type.\""
                    },
                    {
                        "username": "ULUGBEK_KOZIMOV",
                        "content": "I cheked \"([)]\" with JS case 58, but if in code wasn't (return false), anyway expected was = false; WTF?"
                    },
                    {
                        "username": "Badhrinarayana",
                        "content": "I used a stack and my code was working well with sample testcases but it is giving a runtime error plese help me\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n\\n        int n=s.size();\\n        if(n%2 ==1)\\n        return false;\\n\\n        stack<char>stk;\\n        for(int i=0;i<s.size();i++){\\n            char c=s[i];\\n            if(c==\\'(\\'|| c==\\'[\\'|| c==\\'{\\'){\\n                stk.push(c);\\n            }\\n            else{\\n                char t=stk.top();\\n                if( (t==\\'(\\' && c==\\')\\') ||(t==\\'[\\' && c==\\']\\') ||(t==\\'{\\' && c==\\'}\\') )\\n                stk.pop();\\n\\n                else\\n                stk.push(c);\\n            }\\n            \\n        }\\n        if(stk.empty())\\n        return true;\\n\\n        return false;\\n\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "saagicha1601",
                        "content": "if v follow all the instructions that is give \\nthis test case should be valid  \"( [ ) ]\" \\ncan some1 tell the correct way \\nonly this test case is not working "
                    },
                    {
                        "username": "jskiertsky",
                        "content": "Important concept here is that of the *stack* - a data structure that lets you in constant time add/remove to the end/top, and in constant time \\'peek\\' at the top.\\n\\nThis question can be solved in linear time with the use of a stack data structure."
                    },
                    {
                        "username": "shabnamhaque",
                        "content": "i am stuck at separating the sentence into character array.w e can solve using ascii value method."
                    },
                    {
                        "username": "uz-java",
                        "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> leftSymbols=new Stack<>();\\n\\n        for(char c: s.toCharArray()){\\n            if(c==\\'(\\' || c==\\'{\\' || c==\\'[\\'){\\n                leftSymbols.push(c);\\n            }else if(c==\\')\\' && !leftSymbols.isEmpty() && leftSymbols.peek()==\\'(\\'){\\n                leftSymbols.pop();\\n            }else if(c==\\'}\\' && !leftSymbols.isEmpty() && leftSymbols.peek()==\\'{\\'){\\n                leftSymbols.pop();\\n            }else if(c==\\']\\' && !leftSymbols.isEmpty() && leftSymbols.peek()==\\'[\\'){\\n                leftSymbols.pop();\\n            }else{\\n                return false;\\n            }\\n        }\\n        return leftSymbols.isEmpty();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "karunasagar6",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> st = new Stack <>();\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\' || s.charAt(i) == \\'{\\' ) \\n                st.push(s.charAt(i));\\n            else{\\n                if(st.empty()) return false;\\n                else if (st.peek() == \\'(\\'  && s.charAt(i) == \\')\\' ) st.pop();\\n                else if (st.peek() == \\'[\\'  && s.charAt(i) == \\']\\' ) st.pop();\\n                else if (st.peek() == \\'{\\'  && s.charAt(i) == \\'}\\' ) st.pop();\\n                else return false;\\n            }\\n        }\\n        return st.empty();\\n    }\\n}"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-valid-parentheses-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-valid-parentheses-problem-solution.html)"
                    },
                    {
                        "username": "ashokekumar",
                        "content": "class Solution {\\npublic:\\n    stack<string> st;\\n    bool isValid(string s) {\\n    for(int i=0; i<s.size(); i++)\\n        {\\n        if(s[i]==\\'(\\' || s[i]==\\'[\\' ||\\n           s[i]==\\'{\\')\\n            st.push(s[i]);\\n        else\\n           if(s[i]==\\')\\' && st.peek()!=\\'(\\') return false;\\n        \\n        \\n  else   if(s[i]==\\']\\' && st.peek()!=\\'[\\') return false;\\n              \\n else  if(s[i]==\\'}\\' && st.peek()!=\\'{\\') return false;\\n                \\n  else \\n    st.pop();\\n    }\\n      if(st.empty()) return true; else return false;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1689395,
                "content": [
                    {
                        "username": "gi_raffe",
                        "content": "As my understanding, the problem description doesn\\'t rule out the case where the string could contain an odd number of characters, e.g., \"()[\". This should be included in the test case"
                    },
                    {
                        "username": "sayWhatOneMoreTime",
                        "content": "Well it actually does. The following sentence in the description rules out this case: \"Every close bracket has a corresponding open bracket of the same type.\""
                    },
                    {
                        "username": "ULUGBEK_KOZIMOV",
                        "content": "I cheked \"([)]\" with JS case 58, but if in code wasn't (return false), anyway expected was = false; WTF?"
                    },
                    {
                        "username": "Badhrinarayana",
                        "content": "I used a stack and my code was working well with sample testcases but it is giving a runtime error plese help me\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n\\n        int n=s.size();\\n        if(n%2 ==1)\\n        return false;\\n\\n        stack<char>stk;\\n        for(int i=0;i<s.size();i++){\\n            char c=s[i];\\n            if(c==\\'(\\'|| c==\\'[\\'|| c==\\'{\\'){\\n                stk.push(c);\\n            }\\n            else{\\n                char t=stk.top();\\n                if( (t==\\'(\\' && c==\\')\\') ||(t==\\'[\\' && c==\\']\\') ||(t==\\'{\\' && c==\\'}\\') )\\n                stk.pop();\\n\\n                else\\n                stk.push(c);\\n            }\\n            \\n        }\\n        if(stk.empty())\\n        return true;\\n\\n        return false;\\n\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "saagicha1601",
                        "content": "if v follow all the instructions that is give \\nthis test case should be valid  \"( [ ) ]\" \\ncan some1 tell the correct way \\nonly this test case is not working "
                    },
                    {
                        "username": "jskiertsky",
                        "content": "Important concept here is that of the *stack* - a data structure that lets you in constant time add/remove to the end/top, and in constant time \\'peek\\' at the top.\\n\\nThis question can be solved in linear time with the use of a stack data structure."
                    },
                    {
                        "username": "shabnamhaque",
                        "content": "i am stuck at separating the sentence into character array.w e can solve using ascii value method."
                    },
                    {
                        "username": "uz-java",
                        "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> leftSymbols=new Stack<>();\\n\\n        for(char c: s.toCharArray()){\\n            if(c==\\'(\\' || c==\\'{\\' || c==\\'[\\'){\\n                leftSymbols.push(c);\\n            }else if(c==\\')\\' && !leftSymbols.isEmpty() && leftSymbols.peek()==\\'(\\'){\\n                leftSymbols.pop();\\n            }else if(c==\\'}\\' && !leftSymbols.isEmpty() && leftSymbols.peek()==\\'{\\'){\\n                leftSymbols.pop();\\n            }else if(c==\\']\\' && !leftSymbols.isEmpty() && leftSymbols.peek()==\\'[\\'){\\n                leftSymbols.pop();\\n            }else{\\n                return false;\\n            }\\n        }\\n        return leftSymbols.isEmpty();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "karunasagar6",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> st = new Stack <>();\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\' || s.charAt(i) == \\'{\\' ) \\n                st.push(s.charAt(i));\\n            else{\\n                if(st.empty()) return false;\\n                else if (st.peek() == \\'(\\'  && s.charAt(i) == \\')\\' ) st.pop();\\n                else if (st.peek() == \\'[\\'  && s.charAt(i) == \\']\\' ) st.pop();\\n                else if (st.peek() == \\'{\\'  && s.charAt(i) == \\'}\\' ) st.pop();\\n                else return false;\\n            }\\n        }\\n        return st.empty();\\n    }\\n}"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-valid-parentheses-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-valid-parentheses-problem-solution.html)"
                    },
                    {
                        "username": "ashokekumar",
                        "content": "class Solution {\\npublic:\\n    stack<string> st;\\n    bool isValid(string s) {\\n    for(int i=0; i<s.size(); i++)\\n        {\\n        if(s[i]==\\'(\\' || s[i]==\\'[\\' ||\\n           s[i]==\\'{\\')\\n            st.push(s[i]);\\n        else\\n           if(s[i]==\\')\\' && st.peek()!=\\'(\\') return false;\\n        \\n        \\n  else   if(s[i]==\\']\\' && st.peek()!=\\'[\\') return false;\\n              \\n else  if(s[i]==\\'}\\' && st.peek()!=\\'{\\') return false;\\n                \\n  else \\n    st.pop();\\n    }\\n      if(st.empty()) return true; else return false;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1687619,
                "content": [
                    {
                        "username": "gi_raffe",
                        "content": "As my understanding, the problem description doesn\\'t rule out the case where the string could contain an odd number of characters, e.g., \"()[\". This should be included in the test case"
                    },
                    {
                        "username": "sayWhatOneMoreTime",
                        "content": "Well it actually does. The following sentence in the description rules out this case: \"Every close bracket has a corresponding open bracket of the same type.\""
                    },
                    {
                        "username": "ULUGBEK_KOZIMOV",
                        "content": "I cheked \"([)]\" with JS case 58, but if in code wasn't (return false), anyway expected was = false; WTF?"
                    },
                    {
                        "username": "Badhrinarayana",
                        "content": "I used a stack and my code was working well with sample testcases but it is giving a runtime error plese help me\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n\\n        int n=s.size();\\n        if(n%2 ==1)\\n        return false;\\n\\n        stack<char>stk;\\n        for(int i=0;i<s.size();i++){\\n            char c=s[i];\\n            if(c==\\'(\\'|| c==\\'[\\'|| c==\\'{\\'){\\n                stk.push(c);\\n            }\\n            else{\\n                char t=stk.top();\\n                if( (t==\\'(\\' && c==\\')\\') ||(t==\\'[\\' && c==\\']\\') ||(t==\\'{\\' && c==\\'}\\') )\\n                stk.pop();\\n\\n                else\\n                stk.push(c);\\n            }\\n            \\n        }\\n        if(stk.empty())\\n        return true;\\n\\n        return false;\\n\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "saagicha1601",
                        "content": "if v follow all the instructions that is give \\nthis test case should be valid  \"( [ ) ]\" \\ncan some1 tell the correct way \\nonly this test case is not working "
                    },
                    {
                        "username": "jskiertsky",
                        "content": "Important concept here is that of the *stack* - a data structure that lets you in constant time add/remove to the end/top, and in constant time \\'peek\\' at the top.\\n\\nThis question can be solved in linear time with the use of a stack data structure."
                    },
                    {
                        "username": "shabnamhaque",
                        "content": "i am stuck at separating the sentence into character array.w e can solve using ascii value method."
                    },
                    {
                        "username": "uz-java",
                        "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> leftSymbols=new Stack<>();\\n\\n        for(char c: s.toCharArray()){\\n            if(c==\\'(\\' || c==\\'{\\' || c==\\'[\\'){\\n                leftSymbols.push(c);\\n            }else if(c==\\')\\' && !leftSymbols.isEmpty() && leftSymbols.peek()==\\'(\\'){\\n                leftSymbols.pop();\\n            }else if(c==\\'}\\' && !leftSymbols.isEmpty() && leftSymbols.peek()==\\'{\\'){\\n                leftSymbols.pop();\\n            }else if(c==\\']\\' && !leftSymbols.isEmpty() && leftSymbols.peek()==\\'[\\'){\\n                leftSymbols.pop();\\n            }else{\\n                return false;\\n            }\\n        }\\n        return leftSymbols.isEmpty();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "karunasagar6",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> st = new Stack <>();\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\' || s.charAt(i) == \\'{\\' ) \\n                st.push(s.charAt(i));\\n            else{\\n                if(st.empty()) return false;\\n                else if (st.peek() == \\'(\\'  && s.charAt(i) == \\')\\' ) st.pop();\\n                else if (st.peek() == \\'[\\'  && s.charAt(i) == \\']\\' ) st.pop();\\n                else if (st.peek() == \\'{\\'  && s.charAt(i) == \\'}\\' ) st.pop();\\n                else return false;\\n            }\\n        }\\n        return st.empty();\\n    }\\n}"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-valid-parentheses-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-valid-parentheses-problem-solution.html)"
                    },
                    {
                        "username": "ashokekumar",
                        "content": "class Solution {\\npublic:\\n    stack<string> st;\\n    bool isValid(string s) {\\n    for(int i=0; i<s.size(); i++)\\n        {\\n        if(s[i]==\\'(\\' || s[i]==\\'[\\' ||\\n           s[i]==\\'{\\')\\n            st.push(s[i]);\\n        else\\n           if(s[i]==\\')\\' && st.peek()!=\\'(\\') return false;\\n        \\n        \\n  else   if(s[i]==\\']\\' && st.peek()!=\\'[\\') return false;\\n              \\n else  if(s[i]==\\'}\\' && st.peek()!=\\'{\\') return false;\\n                \\n  else \\n    st.pop();\\n    }\\n      if(st.empty()) return true; else return false;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1686263,
                "content": [
                    {
                        "username": "gi_raffe",
                        "content": "As my understanding, the problem description doesn\\'t rule out the case where the string could contain an odd number of characters, e.g., \"()[\". This should be included in the test case"
                    },
                    {
                        "username": "sayWhatOneMoreTime",
                        "content": "Well it actually does. The following sentence in the description rules out this case: \"Every close bracket has a corresponding open bracket of the same type.\""
                    },
                    {
                        "username": "ULUGBEK_KOZIMOV",
                        "content": "I cheked \"([)]\" with JS case 58, but if in code wasn't (return false), anyway expected was = false; WTF?"
                    },
                    {
                        "username": "Badhrinarayana",
                        "content": "I used a stack and my code was working well with sample testcases but it is giving a runtime error plese help me\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n\\n        int n=s.size();\\n        if(n%2 ==1)\\n        return false;\\n\\n        stack<char>stk;\\n        for(int i=0;i<s.size();i++){\\n            char c=s[i];\\n            if(c==\\'(\\'|| c==\\'[\\'|| c==\\'{\\'){\\n                stk.push(c);\\n            }\\n            else{\\n                char t=stk.top();\\n                if( (t==\\'(\\' && c==\\')\\') ||(t==\\'[\\' && c==\\']\\') ||(t==\\'{\\' && c==\\'}\\') )\\n                stk.pop();\\n\\n                else\\n                stk.push(c);\\n            }\\n            \\n        }\\n        if(stk.empty())\\n        return true;\\n\\n        return false;\\n\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "saagicha1601",
                        "content": "if v follow all the instructions that is give \\nthis test case should be valid  \"( [ ) ]\" \\ncan some1 tell the correct way \\nonly this test case is not working "
                    },
                    {
                        "username": "jskiertsky",
                        "content": "Important concept here is that of the *stack* - a data structure that lets you in constant time add/remove to the end/top, and in constant time \\'peek\\' at the top.\\n\\nThis question can be solved in linear time with the use of a stack data structure."
                    },
                    {
                        "username": "shabnamhaque",
                        "content": "i am stuck at separating the sentence into character array.w e can solve using ascii value method."
                    },
                    {
                        "username": "uz-java",
                        "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> leftSymbols=new Stack<>();\\n\\n        for(char c: s.toCharArray()){\\n            if(c==\\'(\\' || c==\\'{\\' || c==\\'[\\'){\\n                leftSymbols.push(c);\\n            }else if(c==\\')\\' && !leftSymbols.isEmpty() && leftSymbols.peek()==\\'(\\'){\\n                leftSymbols.pop();\\n            }else if(c==\\'}\\' && !leftSymbols.isEmpty() && leftSymbols.peek()==\\'{\\'){\\n                leftSymbols.pop();\\n            }else if(c==\\']\\' && !leftSymbols.isEmpty() && leftSymbols.peek()==\\'[\\'){\\n                leftSymbols.pop();\\n            }else{\\n                return false;\\n            }\\n        }\\n        return leftSymbols.isEmpty();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "karunasagar6",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> st = new Stack <>();\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\' || s.charAt(i) == \\'{\\' ) \\n                st.push(s.charAt(i));\\n            else{\\n                if(st.empty()) return false;\\n                else if (st.peek() == \\'(\\'  && s.charAt(i) == \\')\\' ) st.pop();\\n                else if (st.peek() == \\'[\\'  && s.charAt(i) == \\']\\' ) st.pop();\\n                else if (st.peek() == \\'{\\'  && s.charAt(i) == \\'}\\' ) st.pop();\\n                else return false;\\n            }\\n        }\\n        return st.empty();\\n    }\\n}"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-valid-parentheses-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-valid-parentheses-problem-solution.html)"
                    },
                    {
                        "username": "ashokekumar",
                        "content": "class Solution {\\npublic:\\n    stack<string> st;\\n    bool isValid(string s) {\\n    for(int i=0; i<s.size(); i++)\\n        {\\n        if(s[i]==\\'(\\' || s[i]==\\'[\\' ||\\n           s[i]==\\'{\\')\\n            st.push(s[i]);\\n        else\\n           if(s[i]==\\')\\' && st.peek()!=\\'(\\') return false;\\n        \\n        \\n  else   if(s[i]==\\']\\' && st.peek()!=\\'[\\') return false;\\n              \\n else  if(s[i]==\\'}\\' && st.peek()!=\\'{\\') return false;\\n                \\n  else \\n    st.pop();\\n    }\\n      if(st.empty()) return true; else return false;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1683967,
                "content": [
                    {
                        "username": "gi_raffe",
                        "content": "As my understanding, the problem description doesn\\'t rule out the case where the string could contain an odd number of characters, e.g., \"()[\". This should be included in the test case"
                    },
                    {
                        "username": "sayWhatOneMoreTime",
                        "content": "Well it actually does. The following sentence in the description rules out this case: \"Every close bracket has a corresponding open bracket of the same type.\""
                    },
                    {
                        "username": "ULUGBEK_KOZIMOV",
                        "content": "I cheked \"([)]\" with JS case 58, but if in code wasn't (return false), anyway expected was = false; WTF?"
                    },
                    {
                        "username": "Badhrinarayana",
                        "content": "I used a stack and my code was working well with sample testcases but it is giving a runtime error plese help me\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n\\n        int n=s.size();\\n        if(n%2 ==1)\\n        return false;\\n\\n        stack<char>stk;\\n        for(int i=0;i<s.size();i++){\\n            char c=s[i];\\n            if(c==\\'(\\'|| c==\\'[\\'|| c==\\'{\\'){\\n                stk.push(c);\\n            }\\n            else{\\n                char t=stk.top();\\n                if( (t==\\'(\\' && c==\\')\\') ||(t==\\'[\\' && c==\\']\\') ||(t==\\'{\\' && c==\\'}\\') )\\n                stk.pop();\\n\\n                else\\n                stk.push(c);\\n            }\\n            \\n        }\\n        if(stk.empty())\\n        return true;\\n\\n        return false;\\n\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "saagicha1601",
                        "content": "if v follow all the instructions that is give \\nthis test case should be valid  \"( [ ) ]\" \\ncan some1 tell the correct way \\nonly this test case is not working "
                    },
                    {
                        "username": "jskiertsky",
                        "content": "Important concept here is that of the *stack* - a data structure that lets you in constant time add/remove to the end/top, and in constant time \\'peek\\' at the top.\\n\\nThis question can be solved in linear time with the use of a stack data structure."
                    },
                    {
                        "username": "shabnamhaque",
                        "content": "i am stuck at separating the sentence into character array.w e can solve using ascii value method."
                    },
                    {
                        "username": "uz-java",
                        "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> leftSymbols=new Stack<>();\\n\\n        for(char c: s.toCharArray()){\\n            if(c==\\'(\\' || c==\\'{\\' || c==\\'[\\'){\\n                leftSymbols.push(c);\\n            }else if(c==\\')\\' && !leftSymbols.isEmpty() && leftSymbols.peek()==\\'(\\'){\\n                leftSymbols.pop();\\n            }else if(c==\\'}\\' && !leftSymbols.isEmpty() && leftSymbols.peek()==\\'{\\'){\\n                leftSymbols.pop();\\n            }else if(c==\\']\\' && !leftSymbols.isEmpty() && leftSymbols.peek()==\\'[\\'){\\n                leftSymbols.pop();\\n            }else{\\n                return false;\\n            }\\n        }\\n        return leftSymbols.isEmpty();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "karunasagar6",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> st = new Stack <>();\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\' || s.charAt(i) == \\'{\\' ) \\n                st.push(s.charAt(i));\\n            else{\\n                if(st.empty()) return false;\\n                else if (st.peek() == \\'(\\'  && s.charAt(i) == \\')\\' ) st.pop();\\n                else if (st.peek() == \\'[\\'  && s.charAt(i) == \\']\\' ) st.pop();\\n                else if (st.peek() == \\'{\\'  && s.charAt(i) == \\'}\\' ) st.pop();\\n                else return false;\\n            }\\n        }\\n        return st.empty();\\n    }\\n}"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-valid-parentheses-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-valid-parentheses-problem-solution.html)"
                    },
                    {
                        "username": "ashokekumar",
                        "content": "class Solution {\\npublic:\\n    stack<string> st;\\n    bool isValid(string s) {\\n    for(int i=0; i<s.size(); i++)\\n        {\\n        if(s[i]==\\'(\\' || s[i]==\\'[\\' ||\\n           s[i]==\\'{\\')\\n            st.push(s[i]);\\n        else\\n           if(s[i]==\\')\\' && st.peek()!=\\'(\\') return false;\\n        \\n        \\n  else   if(s[i]==\\']\\' && st.peek()!=\\'[\\') return false;\\n              \\n else  if(s[i]==\\'}\\' && st.peek()!=\\'{\\') return false;\\n                \\n  else \\n    st.pop();\\n    }\\n      if(st.empty()) return true; else return false;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1671961,
                "content": [
                    {
                        "username": "gi_raffe",
                        "content": "As my understanding, the problem description doesn\\'t rule out the case where the string could contain an odd number of characters, e.g., \"()[\". This should be included in the test case"
                    },
                    {
                        "username": "sayWhatOneMoreTime",
                        "content": "Well it actually does. The following sentence in the description rules out this case: \"Every close bracket has a corresponding open bracket of the same type.\""
                    },
                    {
                        "username": "ULUGBEK_KOZIMOV",
                        "content": "I cheked \"([)]\" with JS case 58, but if in code wasn't (return false), anyway expected was = false; WTF?"
                    },
                    {
                        "username": "Badhrinarayana",
                        "content": "I used a stack and my code was working well with sample testcases but it is giving a runtime error plese help me\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n\\n        int n=s.size();\\n        if(n%2 ==1)\\n        return false;\\n\\n        stack<char>stk;\\n        for(int i=0;i<s.size();i++){\\n            char c=s[i];\\n            if(c==\\'(\\'|| c==\\'[\\'|| c==\\'{\\'){\\n                stk.push(c);\\n            }\\n            else{\\n                char t=stk.top();\\n                if( (t==\\'(\\' && c==\\')\\') ||(t==\\'[\\' && c==\\']\\') ||(t==\\'{\\' && c==\\'}\\') )\\n                stk.pop();\\n\\n                else\\n                stk.push(c);\\n            }\\n            \\n        }\\n        if(stk.empty())\\n        return true;\\n\\n        return false;\\n\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "saagicha1601",
                        "content": "if v follow all the instructions that is give \\nthis test case should be valid  \"( [ ) ]\" \\ncan some1 tell the correct way \\nonly this test case is not working "
                    },
                    {
                        "username": "jskiertsky",
                        "content": "Important concept here is that of the *stack* - a data structure that lets you in constant time add/remove to the end/top, and in constant time \\'peek\\' at the top.\\n\\nThis question can be solved in linear time with the use of a stack data structure."
                    },
                    {
                        "username": "shabnamhaque",
                        "content": "i am stuck at separating the sentence into character array.w e can solve using ascii value method."
                    },
                    {
                        "username": "uz-java",
                        "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> leftSymbols=new Stack<>();\\n\\n        for(char c: s.toCharArray()){\\n            if(c==\\'(\\' || c==\\'{\\' || c==\\'[\\'){\\n                leftSymbols.push(c);\\n            }else if(c==\\')\\' && !leftSymbols.isEmpty() && leftSymbols.peek()==\\'(\\'){\\n                leftSymbols.pop();\\n            }else if(c==\\'}\\' && !leftSymbols.isEmpty() && leftSymbols.peek()==\\'{\\'){\\n                leftSymbols.pop();\\n            }else if(c==\\']\\' && !leftSymbols.isEmpty() && leftSymbols.peek()==\\'[\\'){\\n                leftSymbols.pop();\\n            }else{\\n                return false;\\n            }\\n        }\\n        return leftSymbols.isEmpty();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "karunasagar6",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> st = new Stack <>();\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\' || s.charAt(i) == \\'{\\' ) \\n                st.push(s.charAt(i));\\n            else{\\n                if(st.empty()) return false;\\n                else if (st.peek() == \\'(\\'  && s.charAt(i) == \\')\\' ) st.pop();\\n                else if (st.peek() == \\'[\\'  && s.charAt(i) == \\']\\' ) st.pop();\\n                else if (st.peek() == \\'{\\'  && s.charAt(i) == \\'}\\' ) st.pop();\\n                else return false;\\n            }\\n        }\\n        return st.empty();\\n    }\\n}"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-valid-parentheses-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-valid-parentheses-problem-solution.html)"
                    },
                    {
                        "username": "ashokekumar",
                        "content": "class Solution {\\npublic:\\n    stack<string> st;\\n    bool isValid(string s) {\\n    for(int i=0; i<s.size(); i++)\\n        {\\n        if(s[i]==\\'(\\' || s[i]==\\'[\\' ||\\n           s[i]==\\'{\\')\\n            st.push(s[i]);\\n        else\\n           if(s[i]==\\')\\' && st.peek()!=\\'(\\') return false;\\n        \\n        \\n  else   if(s[i]==\\']\\' && st.peek()!=\\'[\\') return false;\\n              \\n else  if(s[i]==\\'}\\' && st.peek()!=\\'{\\') return false;\\n                \\n  else \\n    st.pop();\\n    }\\n      if(st.empty()) return true; else return false;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1671273,
                "content": [
                    {
                        "username": "gi_raffe",
                        "content": "As my understanding, the problem description doesn\\'t rule out the case where the string could contain an odd number of characters, e.g., \"()[\". This should be included in the test case"
                    },
                    {
                        "username": "sayWhatOneMoreTime",
                        "content": "Well it actually does. The following sentence in the description rules out this case: \"Every close bracket has a corresponding open bracket of the same type.\""
                    },
                    {
                        "username": "ULUGBEK_KOZIMOV",
                        "content": "I cheked \"([)]\" with JS case 58, but if in code wasn't (return false), anyway expected was = false; WTF?"
                    },
                    {
                        "username": "Badhrinarayana",
                        "content": "I used a stack and my code was working well with sample testcases but it is giving a runtime error plese help me\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n\\n        int n=s.size();\\n        if(n%2 ==1)\\n        return false;\\n\\n        stack<char>stk;\\n        for(int i=0;i<s.size();i++){\\n            char c=s[i];\\n            if(c==\\'(\\'|| c==\\'[\\'|| c==\\'{\\'){\\n                stk.push(c);\\n            }\\n            else{\\n                char t=stk.top();\\n                if( (t==\\'(\\' && c==\\')\\') ||(t==\\'[\\' && c==\\']\\') ||(t==\\'{\\' && c==\\'}\\') )\\n                stk.pop();\\n\\n                else\\n                stk.push(c);\\n            }\\n            \\n        }\\n        if(stk.empty())\\n        return true;\\n\\n        return false;\\n\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "saagicha1601",
                        "content": "if v follow all the instructions that is give \\nthis test case should be valid  \"( [ ) ]\" \\ncan some1 tell the correct way \\nonly this test case is not working "
                    },
                    {
                        "username": "jskiertsky",
                        "content": "Important concept here is that of the *stack* - a data structure that lets you in constant time add/remove to the end/top, and in constant time \\'peek\\' at the top.\\n\\nThis question can be solved in linear time with the use of a stack data structure."
                    },
                    {
                        "username": "shabnamhaque",
                        "content": "i am stuck at separating the sentence into character array.w e can solve using ascii value method."
                    },
                    {
                        "username": "uz-java",
                        "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> leftSymbols=new Stack<>();\\n\\n        for(char c: s.toCharArray()){\\n            if(c==\\'(\\' || c==\\'{\\' || c==\\'[\\'){\\n                leftSymbols.push(c);\\n            }else if(c==\\')\\' && !leftSymbols.isEmpty() && leftSymbols.peek()==\\'(\\'){\\n                leftSymbols.pop();\\n            }else if(c==\\'}\\' && !leftSymbols.isEmpty() && leftSymbols.peek()==\\'{\\'){\\n                leftSymbols.pop();\\n            }else if(c==\\']\\' && !leftSymbols.isEmpty() && leftSymbols.peek()==\\'[\\'){\\n                leftSymbols.pop();\\n            }else{\\n                return false;\\n            }\\n        }\\n        return leftSymbols.isEmpty();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "karunasagar6",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> st = new Stack <>();\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\' || s.charAt(i) == \\'{\\' ) \\n                st.push(s.charAt(i));\\n            else{\\n                if(st.empty()) return false;\\n                else if (st.peek() == \\'(\\'  && s.charAt(i) == \\')\\' ) st.pop();\\n                else if (st.peek() == \\'[\\'  && s.charAt(i) == \\']\\' ) st.pop();\\n                else if (st.peek() == \\'{\\'  && s.charAt(i) == \\'}\\' ) st.pop();\\n                else return false;\\n            }\\n        }\\n        return st.empty();\\n    }\\n}"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-valid-parentheses-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-valid-parentheses-problem-solution.html)"
                    },
                    {
                        "username": "ashokekumar",
                        "content": "class Solution {\\npublic:\\n    stack<string> st;\\n    bool isValid(string s) {\\n    for(int i=0; i<s.size(); i++)\\n        {\\n        if(s[i]==\\'(\\' || s[i]==\\'[\\' ||\\n           s[i]==\\'{\\')\\n            st.push(s[i]);\\n        else\\n           if(s[i]==\\')\\' && st.peek()!=\\'(\\') return false;\\n        \\n        \\n  else   if(s[i]==\\']\\' && st.peek()!=\\'[\\') return false;\\n              \\n else  if(s[i]==\\'}\\' && st.peek()!=\\'{\\') return false;\\n                \\n  else \\n    st.pop();\\n    }\\n      if(st.empty()) return true; else return false;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1668466,
                "content": [
                    {
                        "username": "gi_raffe",
                        "content": "As my understanding, the problem description doesn\\'t rule out the case where the string could contain an odd number of characters, e.g., \"()[\". This should be included in the test case"
                    },
                    {
                        "username": "sayWhatOneMoreTime",
                        "content": "Well it actually does. The following sentence in the description rules out this case: \"Every close bracket has a corresponding open bracket of the same type.\""
                    },
                    {
                        "username": "ULUGBEK_KOZIMOV",
                        "content": "I cheked \"([)]\" with JS case 58, but if in code wasn't (return false), anyway expected was = false; WTF?"
                    },
                    {
                        "username": "Badhrinarayana",
                        "content": "I used a stack and my code was working well with sample testcases but it is giving a runtime error plese help me\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n\\n        int n=s.size();\\n        if(n%2 ==1)\\n        return false;\\n\\n        stack<char>stk;\\n        for(int i=0;i<s.size();i++){\\n            char c=s[i];\\n            if(c==\\'(\\'|| c==\\'[\\'|| c==\\'{\\'){\\n                stk.push(c);\\n            }\\n            else{\\n                char t=stk.top();\\n                if( (t==\\'(\\' && c==\\')\\') ||(t==\\'[\\' && c==\\']\\') ||(t==\\'{\\' && c==\\'}\\') )\\n                stk.pop();\\n\\n                else\\n                stk.push(c);\\n            }\\n            \\n        }\\n        if(stk.empty())\\n        return true;\\n\\n        return false;\\n\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "saagicha1601",
                        "content": "if v follow all the instructions that is give \\nthis test case should be valid  \"( [ ) ]\" \\ncan some1 tell the correct way \\nonly this test case is not working "
                    },
                    {
                        "username": "jskiertsky",
                        "content": "Important concept here is that of the *stack* - a data structure that lets you in constant time add/remove to the end/top, and in constant time \\'peek\\' at the top.\\n\\nThis question can be solved in linear time with the use of a stack data structure."
                    },
                    {
                        "username": "shabnamhaque",
                        "content": "i am stuck at separating the sentence into character array.w e can solve using ascii value method."
                    },
                    {
                        "username": "uz-java",
                        "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> leftSymbols=new Stack<>();\\n\\n        for(char c: s.toCharArray()){\\n            if(c==\\'(\\' || c==\\'{\\' || c==\\'[\\'){\\n                leftSymbols.push(c);\\n            }else if(c==\\')\\' && !leftSymbols.isEmpty() && leftSymbols.peek()==\\'(\\'){\\n                leftSymbols.pop();\\n            }else if(c==\\'}\\' && !leftSymbols.isEmpty() && leftSymbols.peek()==\\'{\\'){\\n                leftSymbols.pop();\\n            }else if(c==\\']\\' && !leftSymbols.isEmpty() && leftSymbols.peek()==\\'[\\'){\\n                leftSymbols.pop();\\n            }else{\\n                return false;\\n            }\\n        }\\n        return leftSymbols.isEmpty();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "karunasagar6",
                        "content": "class Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> st = new Stack <>();\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\' || s.charAt(i) == \\'{\\' ) \\n                st.push(s.charAt(i));\\n            else{\\n                if(st.empty()) return false;\\n                else if (st.peek() == \\'(\\'  && s.charAt(i) == \\')\\' ) st.pop();\\n                else if (st.peek() == \\'[\\'  && s.charAt(i) == \\']\\' ) st.pop();\\n                else if (st.peek() == \\'{\\'  && s.charAt(i) == \\'}\\' ) st.pop();\\n                else return false;\\n            }\\n        }\\n        return st.empty();\\n    }\\n}"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-valid-parentheses-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-valid-parentheses-problem-solution.html)"
                    },
                    {
                        "username": "ashokekumar",
                        "content": "class Solution {\\npublic:\\n    stack<string> st;\\n    bool isValid(string s) {\\n    for(int i=0; i<s.size(); i++)\\n        {\\n        if(s[i]==\\'(\\' || s[i]==\\'[\\' ||\\n           s[i]==\\'{\\')\\n            st.push(s[i]);\\n        else\\n           if(s[i]==\\')\\' && st.peek()!=\\'(\\') return false;\\n        \\n        \\n  else   if(s[i]==\\']\\' && st.peek()!=\\'[\\') return false;\\n              \\n else  if(s[i]==\\'}\\' && st.peek()!=\\'{\\') return false;\\n                \\n  else \\n    st.pop();\\n    }\\n      if(st.empty()) return true; else return false;\\n    }\\n};"
                    }
                ]
            }
        ]
    },
    {
        "title": "Investments in 2016",
        "question_content": "<p>Table: <code>Insurance</code></p>\n\n<pre>\n+-------------+-------+\n| Column Name | Type  |\n+-------------+-------+\n| pid         | int   |\n| tiv_2015    | float |\n| tiv_2016    | float |\n| lat         | float |\n| lon         | float |\n+-------------+-------+\npid is the primary key (column with unique values) for this table.\nEach row of this table contains information about one policy where:\npid is the policyholder&#39;s policy ID.\ntiv_2015 is the total investment value in 2015 and tiv_2016 is the total investment value in 2016.\nlat is the latitude of the policy holder&#39;s city. It&#39;s guaranteed that lat is not NULL.\nlon is the longitude of the policy holder&#39;s city. It&#39;s guaranteed that lon is not NULL.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to report the sum of all total investment values in 2016 <code>tiv_2016</code>, for all policyholders who:</p>\n\n<ul>\n\t<li>have the same <code>tiv_2015</code> value as one or more other policyholders, and</li>\n\t<li>are not located in the same city as any other policyholder (i.e., the (<code>lat, lon</code>) attribute pairs must be unique).</li>\n</ul>\n\n<p>Round <code>tiv_2016</code> to <strong>two decimal places</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nInsurance table:\n+-----+----------+----------+-----+-----+\n| pid | tiv_2015 | tiv_2016 | lat | lon |\n+-----+----------+----------+-----+-----+\n| 1   | 10       | 5        | 10  | 10  |\n| 2   | 20       | 20       | 20  | 20  |\n| 3   | 10       | 30       | 20  | 20  |\n| 4   | 10       | 40       | 40  | 40  |\n+-----+----------+----------+-----+-----+\n<strong>Output:</strong> \n+----------+\n| tiv_2016 |\n+----------+\n| 45.00    |\n+----------+\n<strong>Explanation:</strong> \nThe first record in the table, like the last record, meets both of the two criteria.\nThe tiv_2015 value 10 is the same as the third and fourth records, and its location is unique.\n\nThe second record does not meet any of the two criteria. Its tiv_2015 is not like any other policyholders and its location is the same as the third record, which makes the third record fail, too.\nSo, the result is the sum of tiv_2016 of the first and last record, which is 45.\n</pre>\n",
        "solutions": [
            {
                "id": 353937,
                "title": "window-function",
                "content": "```\\nSELECT ROUND(SUM(TIV_2016),2) AS TIV_2016\\nFROM\\n(SELECT *,\\nCOUNT(*) OVER(PARTITION BY TIV_2015) AS CNT1,\\nCOUNT(*) OVER(PARTITION BY LAT, LON) AS CNT2\\nFROM INSURANCE\\n) AS TBL\\nWHERE CNT1 > =2 AND CNT2 =1\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT ROUND(SUM(TIV_2016),2) AS TIV_2016\\nFROM\\n(SELECT *,\\nCOUNT(*) OVER(PARTITION BY TIV_2015) AS CNT1,\\nCOUNT(*) OVER(PARTITION BY LAT, LON) AS CNT2\\nFROM INSURANCE\\n) AS TBL\\nWHERE CNT1 > =2 AND CNT2 =1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 103292,
                "title": "here-is-my-simple-code",
                "content": "\\n```\\nselect sum(TIV_2016) TIV_2016\\nfrom insurance a\\nwhere 1 = (select count(*) from insurance b where a.LAT=b.LAT and a.LON=b.LON) \\nand 1 < (select count(*) from insurance c where a.TIV_2015=c.TIV_2015)  ;\\n```",
                "solutionTags": [],
                "code": "```\\nselect sum(TIV_2016) TIV_2016\\nfrom insurance a\\nwhere 1 = (select count(*) from insurance b where a.LAT=b.LAT and a.LON=b.LON) \\nand 1 < (select count(*) from insurance c where a.TIV_2015=c.TIV_2015)  ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 455702,
                "title": "mysql-simple-3-line-code",
                "content": "```\\nSELECT ROUND(SUM(TIV_2016),2) AS TIV_2016 FROM Insurance a\\nWHERE EXISTS (SELECT * FROM Insurance WHERE PID <> a.PID AND TIV_2015 = a.TIV_2015)\\nAND NOT EXISTS (SELECT * FROM Insurance WHERE PID <> a.PID AND (LAT,LON) = (a.LAT,a.LON));\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT ROUND(SUM(TIV_2016),2) AS TIV_2016 FROM Insurance a\\nWHERE EXISTS (SELECT * FROM Insurance WHERE PID <> a.PID AND TIV_2015 = a.TIV_2015)\\nAND NOT EXISTS (SELECT * FROM Insurance WHERE PID <> a.PID AND (LAT,LON) = (a.LAT,a.LON));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3670790,
                "title": "best-optimum-solution-with-explanation",
                "content": "## ***Please Upvote my solution, if you find it helpful ;)***\\n\\n# Intuition\\nThe solution aims to calculate the total insured value in 2016 for the insurance policies that meet specific conditions.\\n\\n# Approach\\n1. We want to calculate the total insured value in the year 2016 for specific insurance policies.\\n1. We start by looking at the \"Insurance\" table.\\n1. First, we find all the policies where the insured value in 2015 appears more than once. This helps us identify policies that have been renewed or updated.\\n1. Next, we find all the unique combinations of latitude and longitude where only one policy exists. This helps us identify policies with unique locations.\\n1. We then apply these two conditions together using the AND operator to filter the policies that meet both criteria.\\n1. Finally, we calculate the sum of the insured values in 2016 for the filtered policies, rounding the result to two decimal places.\\n# Complexity\\n- Time complexity:\\nThe time complexity of the query depends on the size of the \"Insurance\" table. The subqueries used to filter the data have a time complexity of $$O(n^2)$$, where n is the number of rows in the table. Overall, the time complexity can be considered linear or $$O(n)$$ in terms of the number of rows in the table.\\n\\n- Space complexity:\\nThe space complexity of the query is determined by the size of the \"Insurance\" table and the number of distinct tiv_2015, lat, and lon values. The query itself does not consume significant additional space beyond the input table. Thus, the space complexity can be considered $$O(n)$$, where n is the number of rows in the table.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT ROUND(SUM(tiv_2016), 2) AS tiv_2016\\nFROM Insurance\\nWHERE tiv_2015 IN (\\n    SELECT tiv_2015\\n    FROM Insurance\\n    GROUP BY tiv_2015\\n    HAVING COUNT(*) > 1\\n)\\nAND (lat, lon) IN (\\n    SELECT lat, lon\\n    FROM Insurance\\n    GROUP BY lat, lon\\n    HAVING COUNT(*) = 1\\n)\\n```\\n***Please Upvote my solution, if you find it helpful ;)***\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/357d9092-5663-4406-91a5-ee96314dee53_1687455656.6799042.jpeg)\\n",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT ROUND(SUM(tiv_2016), 2) AS tiv_2016\\nFROM Insurance\\nWHERE tiv_2015 IN (\\n    SELECT tiv_2015\\n    FROM Insurance\\n    GROUP BY tiv_2015\\n    HAVING COUNT(*) > 1\\n)\\nAND (lat, lon) IN (\\n    SELECT lat, lon\\n    FROM Insurance\\n    GROUP BY lat, lon\\n    HAVING COUNT(*) = 1\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 103294,
                "title": "using-group-by-and-having-count-to-choose-the-not-unique-data",
                "content": "Another trick is to represent the location information by concat the LAT and LON.\\n```\\nSELECT SUM(insurance.TIV_2016) AS TIV_2016\\nFROM insurance\\nWHERE insurance.TIV_2015 IN -- meet the creteria #1\\n    (\\n       SELECT TIV_2015\\n        FROM insurance\\n        GROUP BY TIV_2015\\n        HAVING COUNT(*) > 1\\n        )\\nAND CONCAT(LAT, LON) IN -- meet the creteria #2\\n    (\\n      SELECT CONCAT(LAT, LON) -- trick to take the LAT and LON as a pair\\n      FROM insurance\\n      GROUP BY LAT , LON\\n      HAVING COUNT(*) = 1\\n)\\n;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT SUM(insurance.TIV_2016) AS TIV_2016\\nFROM insurance\\nWHERE insurance.TIV_2015 IN -- meet the creteria #1\\n    (\\n       SELECT TIV_2015\\n        FROM insurance\\n        GROUP BY TIV_2015\\n        HAVING COUNT(*) > 1\\n        )\\nAND CONCAT(LAT, LON) IN -- meet the creteria #2\\n    (\\n      SELECT CONCAT(LAT, LON) -- trick to take the LAT and LON as a pair\\n      FROM insurance\\n      GROUP BY LAT , LON\\n      HAVING COUNT(*) = 1\\n)\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3551697,
                "title": "2-mysql-solutions-compared-and-explained",
                "content": "# Option 1: Window function in subquery\\n```\\nselect\\n    round(sum(tiv_2016), 2) as tiv_2016\\nfrom\\n    (\\n        select\\n            *\\n            , count(*) over (partition by tiv_2015) as tiv_2015_cnt\\n            , count(*) over (partition by lat, lon) as location_cnt\\n        from\\n            insurance\\n    ) t -- every derived table must have its own alias\\nwhere tiv_2015_cnt > 1 and location_cnt = 1\\n```\\n- The query uses window functions to calculate the count of `tiv_2015` and the count of distinct `(lat, lon)` pairs.\\n- By performing these calculations within the subquery, the main query can simply filter based on the pre-calculated counts.\\n- This approach avoids the need for additional subqueries and allows the database engine to optimize the window function calculations.\\n- The use of window functions allows for a more concise and self-contained query structure.\\n- The derived table `t` provides a clear context for the calculations being performed.\\n- The filtering conditions in the outer query are straightforward and easily understandable.\\n\\n# Option 2: two subqueries in where clause\\n```\\nSELECT\\n    ROUND(SUM(insurance.TIV_2016),2) AS TIV_2016\\nFROM\\n    insurance\\nWHERE\\n    insurance.TIV_2015 IN\\n    (\\n      SELECT\\n        TIV_2015\\n      FROM\\n        insurance\\n      GROUP BY TIV_2015\\n      HAVING COUNT(*) > 1\\n    )\\n    AND CONCAT(LAT, LON) IN\\n    (\\n      SELECT\\n        CONCAT(LAT, LON)\\n      FROM\\n        insurance\\n      GROUP BY LAT , LON\\n      HAVING COUNT(*) = 1\\n    )\\n```\\n\\n- The query uses subqueries to identify the `TIV_2015` values with a count greater than 1 and the distinct `(lat, lon)` pairs with a count of exactly 1.\\n- The subqueries are executed independently and provide the filtering conditions for the main query.\\n- This approach involves multiple subqueries, which can potentially impact performance, especially if the underlying tables are large.\\n- The subqueries explicitly express the conditions for filtering the `TIV_2015` values and the `(lat, lon)` pairs.\\n- The separate subqueries may make it easier to understand the individual filtering logic.\\n- However, the query structure can become more complex with multiple subqueries, which may slightly reduce readability.\\n\\n# Summary\\nOverall, Option 1 strikes a good balance between performance and readability. It leverages window functions to perform the necessary calculations efficiently while maintaining a clear and concise query structure.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect\\n    round(sum(tiv_2016), 2) as tiv_2016\\nfrom\\n    (\\n        select\\n            *\\n            , count(*) over (partition by tiv_2015) as tiv_2015_cnt\\n            , count(*) over (partition by lat, lon) as location_cnt\\n        from\\n            insurance\\n    ) t -- every derived table must have its own alias\\nwhere tiv_2015_cnt > 1 and location_cnt = 1\\n```\n```\\nSELECT\\n    ROUND(SUM(insurance.TIV_2016),2) AS TIV_2016\\nFROM\\n    insurance\\nWHERE\\n    insurance.TIV_2015 IN\\n    (\\n      SELECT\\n        TIV_2015\\n      FROM\\n        insurance\\n      GROUP BY TIV_2015\\n      HAVING COUNT(*) > 1\\n    )\\n    AND CONCAT(LAT, LON) IN\\n    (\\n      SELECT\\n        CONCAT(LAT, LON)\\n      FROM\\n        insurance\\n      GROUP BY LAT , LON\\n      HAVING COUNT(*) = 1\\n    )\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 114036,
                "title": "my-easy-to-understand-query",
                "content": "```\\nSELECT ROUND(SUM(TIV_2016), 2) AS TIV_2016 FROM insurance \\nWHERE PID IN \\n(SELECT PID FROM insurance GROUP BY LAT, LON HAVING COUNT(*) = 1) \\nAND PID NOT IN\\n(SELECT PID FROM insurance GROUP BY TIV_2015 HAVING COUNT(*) = 1)\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT ROUND(SUM(TIV_2016), 2) AS TIV_2016 FROM insurance \\nWHERE PID IN \\n(SELECT PID FROM insurance GROUP BY LAT, LON HAVING COUNT(*) = 1) \\nAND PID NOT IN\\n(SELECT PID FROM insurance GROUP BY TIV_2015 HAVING COUNT(*) = 1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3441396,
                "title": "solution-with-count-over-sql-server-beats-100",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\n\\r\\n\\r\\nWITH CTE AS (\\r\\n\\t\\tSELECT\\r\\n\\t\\t\\t*,\\r\\n\\t\\t\\tCOUNT(lat) OVER(PARTITION BY lat,lon) CountLatLon,\\r\\n\\t\\t\\tCOUNT(tiv_2015) OVER(PARTITION BY tiv_2015) CountT_2015\\r\\n\\t\\tFROM\\r\\n\\t\\t\\tInsurance T1\\r\\n)\\r\\nSELECT\\r\\n\\tROUND(SUM(tiv_2016),2) tiv_2016 \\r\\nFROM\\r\\n\\tCTE\\r\\nWHERE\\r\\n\\tCountLatLon = 1\\r\\nAND\\r\\n\\tCountT_2015 > 1\\r\\n\\r\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\n\\r\\n\\r\\nWITH CTE AS (\\r\\n\\t\\tSELECT\\r\\n\\t\\t\\t*,\\r\\n\\t\\t\\tCOUNT(lat) OVER(PARTITION BY lat,lon) CountLatLon,\\r\\n\\t\\t\\tCOUNT(tiv_2015) OVER(PARTITION BY tiv_2015) CountT_2015\\r\\n\\t\\tFROM\\r\\n\\t\\t\\tInsurance T1\\r\\n)\\r\\nSELECT\\r\\n\\tROUND(SUM(tiv_2016),2) tiv_2016 \\r\\nFROM\\r\\n\\tCTE\\r\\nWHERE\\r\\n\\tCountLatLon = 1\\r\\nAND\\r\\n\\tCountT_2015 > 1\\r\\n\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3333641,
                "title": "straightforward-mysql-using-in-and-subquery",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSELECT ROUND(SUM(tiv_2016),2) as tiv_2016\\nFROM insurance i1\\nWHERE tiv_2015 IN (SELECT tiv_2015 FROM insurance i2\\n                   WHERE i1.pid != i2.pid)\\nAND (lat, lon) NOT IN (SELECT lat, lon FROM insurance i3\\n                       WHERE i3.pid != i1.pid)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT ROUND(SUM(tiv_2016),2) as tiv_2016\\nFROM insurance i1\\nWHERE tiv_2015 IN (SELECT tiv_2015 FROM insurance i2\\n                   WHERE i1.pid != i2.pid)\\nAND (lat, lon) NOT IN (SELECT lat, lon FROM insurance i3\\n                       WHERE i3.pid != i1.pid)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2491003,
                "title": "mysql-multiple-ctes-round-sum-good-luck",
                "content": "```\\n# Write your MySQL query statement below\\n/**\\nOne Table: Insurance\\npid is the primary key column for Insurance table.\\nInsurance table contains information about one policy where:\\n    pid is the policyholder\\'s policy ID.\\n    tiv_2015 is the total investment value in 2015 and tiv_2016 is the total investment value in 2016.\\n    lat is the latitude of the policy holder\\'s city.\\n    lon is the longitude of the policy holder\\'s city.\\nPROBLEM:\\nWrite an SQL query to report the sum of all total investment values in 2016 tiv_2016, for all policyholders who:\\n\\nhave the same tiv_2015 value as one or more other policyholders, and\\nare not located in the same city like any other policyholder (i.e., the (lat, lon) attribute pairs must be unique).\\nRound tiv_2016 to two decimal places.\\n\\nSTEPS:\\nTwo Criteria\\n    Build Two CTEs\\n    1. tiv_2015 having count(*) > 1\\n    2. Unique lat,lon having count(*) = 1\\n    \\n*/\\n\\n\\nWITH firstConditionCTE AS\\n(\\nSELECT tiv_2015 FROM Insurance GROUP BY tiv_2015 HAVING COUNT(*) > 1\\n),\\n\\nSecondConditionCTE AS \\n(\\nSELECT lat,lon FROM Insurance GROUP BY lat,lon HAVING COUNT(*) = 1\\n)\\n\\nSELECT\\n    ROUND(SUM(tiv_2016),2) AS tiv_2016\\nFROM Insurance\\nWHERE tiv_2015 IN (SELECT * FROM firstConditionCTE)\\n    AND\\n    (lat,lon) IN (SELECT * FROM SecondConditionCTE)\\n\\n\\n\\n```\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n/**\\nOne Table: Insurance\\npid is the primary key column for Insurance table.\\nInsurance table contains information about one policy where:\\n    pid is the policyholder\\'s policy ID.\\n    tiv_2015 is the total investment value in 2015 and tiv_2016 is the total investment value in 2016.\\n    lat is the latitude of the policy holder\\'s city.\\n    lon is the longitude of the policy holder\\'s city.\\nPROBLEM:\\nWrite an SQL query to report the sum of all total investment values in 2016 tiv_2016, for all policyholders who:\\n\\nhave the same tiv_2015 value as one or more other policyholders, and\\nare not located in the same city like any other policyholder (i.e., the (lat, lon) attribute pairs must be unique).\\nRound tiv_2016 to two decimal places.\\n\\nSTEPS:\\nTwo Criteria\\n    Build Two CTEs\\n    1. tiv_2015 having count(*) > 1\\n    2. Unique lat,lon having count(*) = 1\\n    \\n*/\\n\\n\\nWITH firstConditionCTE AS\\n(\\nSELECT tiv_2015 FROM Insurance GROUP BY tiv_2015 HAVING COUNT(*) > 1\\n),\\n\\nSecondConditionCTE AS \\n(\\nSELECT lat,lon FROM Insurance GROUP BY lat,lon HAVING COUNT(*) = 1\\n)\\n\\nSELECT\\n    ROUND(SUM(tiv_2016),2) AS tiv_2016\\nFROM Insurance\\nWHERE tiv_2015 IN (SELECT * FROM firstConditionCTE)\\n    AND\\n    (lat,lon) IN (SELECT * FROM SecondConditionCTE)\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3605595,
                "title": "mysql-solution-for-investments-in-2016-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to identify policyholders who have the same tiv_2015 value as one or more other policyholders, and whose location (lat, lon) is unique. We need to calculate the sum of their tiv_2016 values.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is to use subqueries to find the distinct tiv_2015 values with multiple occurrences and the distinct (lat, lon) pairs with only one occurrence. We then use these subqueries as conditions in the main query to select the policyholders and calculate the sum of their tiv_2016 values.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is dependent on the size of the Insurance table and the efficiency of the database engine\\'s query execution. The subqueries that find distinct tiv_2015 values and (lat, lon) pairs have a time complexity of O(n), where n is the number of rows in the Insurance table. The overall time complexity will depend on the database engine\\'s optimization and indexing.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is also dependent on the size of the Insurance table. The subqueries and the main query use additional memory to store and process the intermediate results. The space complexity will depend on the implementation of the database engine and the amount of data being processed.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT ROUND(SUM(tiv_2016), 2) AS tiv_2016\\nFROM Insurance\\nWHERE tiv_2015 IN (\\n    SELECT tiv_2015\\n    FROM Insurance\\n    GROUP BY tiv_2015\\n    HAVING COUNT(*) > 1\\n)\\nAND (lat, lon) IN (\\n    SELECT lat, lon\\n    FROM Insurance\\n    GROUP BY lat, lon\\n    HAVING COUNT(*) = 1\\n);\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT ROUND(SUM(tiv_2016), 2) AS tiv_2016\\nFROM Insurance\\nWHERE tiv_2015 IN (\\n    SELECT tiv_2015\\n    FROM Insurance\\n    GROUP BY tiv_2015\\n    HAVING COUNT(*) > 1\\n)\\nAND (lat, lon) IN (\\n    SELECT lat, lon\\n    FROM Insurance\\n    GROUP BY lat, lon\\n    HAVING COUNT(*) = 1\\n);\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 947092,
                "title": "mysql-join-solution-no-subqueries",
                "content": "I prefer using joins as it is more intuitive if you are answering this for an interview. The most upvoted answers are too clever to come up with under time constraint. Those design patterns are foreign to me.\\n```\\nSELECT SUM(TIV_2016) AS TIV_2016\\nFROM (\\n    SELECT DISTINCT i1.pid, i1.TIV_2016\\n    FROM insurance i1\\n    JOIN insurance i3 ON i3.pid != i1.pid AND i3.TIV_2015 = i1.TIV_2015\\n    LEFT JOIN insurance i2 ON i1.lat = i2.lat AND i1.pid != i2.pid AND i1.lon = i2.lon\\n    WHERE i2.lat IS NULL\\n) t1\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT SUM(TIV_2016) AS TIV_2016\\nFROM (\\n    SELECT DISTINCT i1.pid, i1.TIV_2016\\n    FROM insurance i1\\n    JOIN insurance i3 ON i3.pid != i1.pid AND i3.TIV_2015 = i1.TIV_2015\\n    LEFT JOIN insurance i2 ON i1.lat = i2.lat AND i1.pid != i2.pid AND i1.lon = i2.lon\\n    WHERE i2.lat IS NULL\\n) t1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 623513,
                "title": "faster-than-90-and-very-simple",
                "content": "select sum(tiv_2016) as tiv_2016 from\\n(select tiv_2015, tiv_2016, count(pid) over (partition by tiv_2015) as count_tid, lat, lon, count(*) over (partition by lat,lon) count_loc from insurance) a\\nwhere count_tid>1 and count_loc=1",
                "solutionTags": [],
                "code": "select sum(tiv_2016) as tiv_2016 from\\n(select tiv_2015, tiv_2016, count(pid) over (partition by tiv_2015) as count_tid, lat, lon, count(*) over (partition by lat,lon) count_loc from insurance) a\\nwhere count_tid>1 and count_loc=1",
                "codeTag": "Unknown"
            },
            {
                "id": 3577053,
                "title": "simple-solutions-with-detailed-explanation-for-mysql-ms-sql-server",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition is to use WHERE clause to filter based on the problem description. We need two conditions here:\\n1. The values of lat and lon must not exist in other rows\\n2. The value of tiv_2015 exists in other rows\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we need to figure out what to write in the SELECT clause. This part is rather trivial, as we simply need to SUM the values in the column tiv_2016 for all rows matching the conditions (more on this later), rounded to 2 decimal places:\\n```\\nSELECT ROUND(SUM(tiv_2016), 2) FROM Insurance i\\n```\\n\\nNext, we need to write the WHERE clause to only keep the wanted rows. For the first condition, we can use EXISTS (and NOT) to determine whether the lat and lon exists in other rows by the following boolean expression w/ subquery\\n```\\nNOT EXISTS (\\n    SELECT * FROM Insurance i2 WHERE i2.pid != i.pid AND i2.lat = i.lat AND i2.lon = i.lon\\n)\\n```\\nThe subquery simply returns all rows that has different pid than the current row in the outer query, but identical lat and lon values. If this subquery returns 0 rows, then our first condition is met.\\n\\nFor the second condition, we can use similar logic as before by checking the boolean expression:\\n```\\nEXISTS (\\n    SELECT * FROM Insurance i3 WHERE i3.pid != i.pid AND i3.tiv_2015 = i.tiv_2015\\n)\\n```\\nAlternatively, we can use IN to check this condition:\\n```\\ntiv_2015 IN (\\n    SELECT tiv_2015 FROM Insurance i3 WHERE i3.pid != i.pid\\n)\\n```\\nThen we can use an AND keyword to connect the above two expressions in the WHERE clause.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT\\n    ROUND(SUM(tiv_2016), 2) as tiv_2016\\nFROM Insurance i\\nWHERE NOT EXISTS (\\n    SELECT * FROM Insurance i2 WHERE i2.pid != i.pid AND i2.lat = i.lat AND i2.lon = i.lon\\n) AND tiv_2015 IN (\\n    SELECT tiv_2015 FROM Insurance i3 WHERE i3.pid != i.pid\\n)\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT ROUND(SUM(tiv_2016), 2) FROM Insurance i\\n```\n```\\nNOT EXISTS (\\n    SELECT * FROM Insurance i2 WHERE i2.pid != i.pid AND i2.lat = i.lat AND i2.lon = i.lon\\n)\\n```\n```\\nEXISTS (\\n    SELECT * FROM Insurance i3 WHERE i3.pid != i.pid AND i3.tiv_2015 = i.tiv_2015\\n)\\n```\n```\\ntiv_2015 IN (\\n    SELECT tiv_2015 FROM Insurance i3 WHERE i3.pid != i.pid\\n)\\n```\n```\\n# Write your MySQL query statement below\\nSELECT\\n    ROUND(SUM(tiv_2016), 2) as tiv_2016\\nFROM Insurance i\\nWHERE NOT EXISTS (\\n    SELECT * FROM Insurance i2 WHERE i2.pid != i.pid AND i2.lat = i.lat AND i2.lon = i.lon\\n) AND tiv_2015 IN (\\n    SELECT tiv_2015 FROM Insurance i3 WHERE i3.pid != i.pid\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3556377,
                "title": "nested-query-with-exists",
                "content": "# Approach\\n**From first order logic (FOL)**:\\n\\n$$\\u2200 i \\u2208 Insurance:( \\u2200 i2 \\u2208 Insurance: i2.lat <> i.lat \\u2228 i2.lon <> i.lon) \\u2261 \\u2200 i \\u2208 Insurance:( $$**\\xAC\\u2203 i2 \\u2208 Insurance: i2.lat = i.lat \\u2227 i2.lon = i.lon**$$) $$\\n\\n# Code\\n```\\nselect ROUND(sum(i.tiv_2016), 2) as tiv_2016\\nfrom Insurance as i\\nwhere exists (select *\\n              from Insurance as i2\\n              where i.tiv_2015 = i2.tiv_2015\\n                    and i.pid <> i2.pid)\\n\\n    /* \\n        The lat and long values must be different from all other policyholders. \\n        A universal quantification is equivalent to a denied existential quantification\\n    */\\n    and not exists (select *\\n                    from Insurance as i2\\n                    where (i.lat = i2.lat\\n                            and i.lon = i2.lon)\\n                          and i.pid <> i2.pid) -- I exclude himself\\n```\\n**Please Upvote**\\uD83D\\uDD25\\uD83D\\uDE09\\n*Thanks for visiting my solution.*",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\nselect ROUND(sum(i.tiv_2016), 2) as tiv_2016\\nfrom Insurance as i\\nwhere exists (select *\\n              from Insurance as i2\\n              where i.tiv_2015 = i2.tiv_2015\\n                    and i.pid <> i2.pid)\\n\\n    /* \\n        The lat and long values must be different from all other policyholders. \\n        A universal quantification is equivalent to a denied existential quantification\\n    */\\n    and not exists (select *\\n                    from Insurance as i2\\n                    where (i.lat = i2.lat\\n                            and i.lon = i2.lon)\\n                          and i.pid <> i2.pid) -- I exclude himself\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1638845,
                "title": "mysql-subquery-solution",
                "content": "```\\nselect round(sum(tiv_2016), 2) tiv_2016\\nfrom insurance i\\nwhere (lat, lon) not in (select lat, lon from insurance where pid<>i.pid)\\n    and (select count(tiv_2015) from insurance where tiv_2015=i.tiv_2015) > 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect round(sum(tiv_2016), 2) tiv_2016\\nfrom insurance i\\nwhere (lat, lon) not in (select lat, lon from insurance where pid<>i.pid)\\n    and (select count(tiv_2015) from insurance where tiv_2015=i.tiv_2015) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1047085,
                "title": "cte-with-window-functio",
                "content": "```\\nwith cte as(\\nselect TIV_2016, count(PID) over(partition by TIV_2015 ) as condition1, count(PID) over(partition by LAT, LON) as condition2\\nfrom insurance )\\n\\nselect sum(TIV_2016) as TIV_2016\\nfrom cte\\nwhere condition1 >= 2 and condition2 = 1\\n```",
                "solutionTags": [],
                "code": "```\\nwith cte as(\\nselect TIV_2016, count(PID) over(partition by TIV_2015 ) as condition1, count(PID) over(partition by LAT, LON) as condition2\\nfrom insurance )\\n\\nselect sum(TIV_2016) as TIV_2016\\nfrom cte\\nwhere condition1 >= 2 and condition2 = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 799919,
                "title": "sql-server-simple-solution-with-cte",
                "content": "```SQL\\nWITH temp AS(\\n    SELECT\\n        TIV_2016\\n        , COUNT(*) OVER (PARTITION BY TIV_2015) AS cnt_15\\n        , COUNT(*) OVER (PARTITION BY LAT, LON) AS location_cnt\\n    FROM insurance\\n)\\nSELECT\\n    CAST(SUM(TIV_2016) AS DECIMAL(10,2)) AS TIV_2016\\nFROM temp\\nWHERE cnt_15 >= 2 AND location_cnt = 1;\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```SQL\\nWITH temp AS(\\n    SELECT\\n        TIV_2016\\n        , COUNT(*) OVER (PARTITION BY TIV_2015) AS cnt_15\\n        , COUNT(*) OVER (PARTITION BY LAT, LON) AS location_cnt\\n    FROM insurance\\n)\\nSELECT\\n    CAST(SUM(TIV_2016) AS DECIMAL(10,2)) AS TIV_2016\\nFROM temp\\nWHERE cnt_15 >= 2 AND location_cnt = 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 103288,
                "title": "my-accepted-solution-using-exists",
                "content": "select round(sum(i1.TIV_2016), 2) as TIV_2016\\nfrom insurance i1\\nwhere EXISTS (select *\\n             from insurance i2\\n             where i1.PID <> i2.PID and i1.TIV_2015 = i2.TIV_2015)\\n    and NOT EXISTS(select *\\n                  from insurance i3\\n                  where i1.PID <> i3.PID and i1.LAT = i3.LAT and i1.LON = i3.LON)",
                "solutionTags": [],
                "code": "select round(sum(i1.TIV_2016), 2) as TIV_2016\\nfrom insurance i1\\nwhere EXISTS (select *\\n             from insurance i2\\n             where i1.PID <> i2.PID and i1.TIV_2015 = i2.TIV_2015)\\n    and NOT EXISTS(select *\\n                  from insurance i3\\n                  where i1.PID <> i3.PID and i1.LAT = i3.LAT and i1.LON = i3.LON)",
                "codeTag": "Unknown"
            },
            {
                "id": 1255732,
                "title": "windows-function",
                "content": "select round(sum(TIV_2016), 2) as TIV_2016\\nfrom\\n(select *, count(PID) over (partition by TIV_2015) as num,\\ncount(PID) over (partition by concat(LAT, LON)) as lo\\nfrom insurance) tmp\\nwhere num > 1 and lo = 1",
                "solutionTags": [],
                "code": "select round(sum(TIV_2016), 2) as TIV_2016\\nfrom\\n(select *, count(PID) over (partition by TIV_2015) as num,\\ncount(PID) over (partition by concat(LAT, LON)) as lo\\nfrom insurance) tmp\\nwhere num > 1 and lo = 1",
                "codeTag": "Unknown"
            },
            {
                "id": 751802,
                "title": "mysql-beats-94",
                "content": "select \\n       ROUND(sum(tiv_2016),2) as \\'TIV_2016\\'\\nfrom insurance \\nwhere \\ntiv_2015 in \\n(select tiv_2015 from insurance group by tiv_2015 having count(pid) > 1)\\nand\\nconcat(lat,\\'-\\',lon) in \\n(select concat(lat,\\'-\\',lon) from insurance group by concat(lat,\\'-\\',lon) having count(pid) = 1)",
                "solutionTags": [],
                "code": "select \\n       ROUND(sum(tiv_2016),2) as \\'TIV_2016\\'\\nfrom insurance \\nwhere \\ntiv_2015 in \\n(select tiv_2015 from insurance group by tiv_2015 having count(pid) > 1)\\nand\\nconcat(lat,\\'-\\',lon) in \\n(select concat(lat,\\'-\\',lon) from insurance group by concat(lat,\\'-\\',lon) having count(pid) = 1)",
                "codeTag": "Unknown"
            },
            {
                "id": 3956846,
                "title": "simple-very-easy-optimum-mysql-solution-with-explanation",
                "content": "# Intuition\\nWe need to find the SUM of tov_2016 which holds the following 2 conditions.\\n1. latitude and longtitude should be unique in the table\\n2. tiv_2015 should not be unique.\\n\\n# Approach\\n1. at 1st I find out all pid\\'s having non unique latitude and longitude using INNER JOIN on lat and lon column together.\\n2. Then I find out the all tiv_2015 having pid count more than 1.\\n3. Finally found the sum of all tiv_2016 by putting above stated conditions(Not IN 1 AND In 2) in Where clause.\\n\\n# Code\\n```\\nSELECT ROUND(SUM(tiv_2016),2) as tiv_2016 FROM Insurance\\nWHERE \\npid NOT IN\\n(SELECT a.pid FROM Insurance a\\nINNER JOIN Insurance b on (a.lat,a.lon) = (b. lat,b.lon)\\nWHERE a.pid <> b.pid)\\nAND\\ntiv_2015 IN\\n(SELECT tiv_2015 FROM Insurance\\nGROUP BY tiv_2015 HAVING COUNT(pid)>1);\\n```\\nUsing subquery beat 98%.\\n```\\nSELECT ROUND(SUM(tiv_2016),2) as tiv_2016 FROM\\n(SELECT * FROM Insurance \\nGROUP BY lat,lon \\nHAVING COUNT(lat) = 1 and COUNT(lon)=1\\nAND \\ntiv_2015 IN (SELECT tiv_2015 FROM Insurance \\nGROUP BY tiv_2015 \\nHAVING COUNT(tiv_2015)>1)) as table1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT ROUND(SUM(tiv_2016),2) as tiv_2016 FROM Insurance\\nWHERE \\npid NOT IN\\n(SELECT a.pid FROM Insurance a\\nINNER JOIN Insurance b on (a.lat,a.lon) = (b. lat,b.lon)\\nWHERE a.pid <> b.pid)\\nAND\\ntiv_2015 IN\\n(SELECT tiv_2015 FROM Insurance\\nGROUP BY tiv_2015 HAVING COUNT(pid)>1);\\n```\n```\\nSELECT ROUND(SUM(tiv_2016),2) as tiv_2016 FROM\\n(SELECT * FROM Insurance \\nGROUP BY lat,lon \\nHAVING COUNT(lat) = 1 and COUNT(lon)=1\\nAND \\ntiv_2015 IN (SELECT tiv_2015 FROM Insurance \\nGROUP BY tiv_2015 \\nHAVING COUNT(tiv_2015)>1)) as table1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3894104,
                "title": "585-investments-in-2016",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n# Write your MySQL query statement below\\r\\nSELECT ROUND(SUM(insurance.tiv_2016), 2) AS tiv_2016\\r\\nFROM Insurance\\r\\nWHERE\\r\\n    tiv_2015 IN\\r\\n    (\\r\\n        SELECT tiv_2015\\r\\n        FROM Insurance\\r\\n        GROUP BY tiv_2015\\r\\n        HAVING COUNT(*) > 1\\r\\n    )\\r\\n    AND CONCAT(lat, lon) IN\\r\\n    (\\r\\n        SELECT CONCAT(lat, lon)\\r\\n        FROM Insurance\\r\\n        GROUP BY lat, lon\\r\\n        HAVING COUNT(*) = 1\\r\\n    )\\r\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\r\\n# Write your MySQL query statement below\\r\\nSELECT ROUND(SUM(insurance.tiv_2016), 2) AS tiv_2016\\r\\nFROM Insurance\\r\\nWHERE\\r\\n    tiv_2015 IN\\r\\n    (\\r\\n        SELECT tiv_2015\\r\\n        FROM Insurance\\r\\n        GROUP BY tiv_2015\\r\\n        HAVING COUNT(*) > 1\\r\\n    )\\r\\n    AND CONCAT(lat, lon) IN\\r\\n    (\\r\\n        SELECT CONCAT(lat, lon)\\r\\n        FROM Insurance\\r\\n        GROUP BY lat, lon\\r\\n        HAVING COUNT(*) = 1\\r\\n    )\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3706890,
                "title": "simple-neat-solution-beats-80-without-where-clause",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement \\nwith sub as (select *,\\ncount(tiv_2015) over(partition by tiv_2015) as counter\\nfrom Insurance)\\n\\nselect \\nround(sum(case when counter > 1 and \\npid in   (SELECT pid\\n    FROM Insurance\\n    GROUP BY lat,lon\\n    HAVING COUNT(pid) = 1) then tiv_2016\\n    end), 2) as tiv_2016\\nfrom sub\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement \\nwith sub as (select *,\\ncount(tiv_2015) over(partition by tiv_2015) as counter\\nfrom Insurance)\\n\\nselect \\nround(sum(case when counter > 1 and \\npid in   (SELECT pid\\n    FROM Insurance\\n    GROUP BY lat,lon\\n    HAVING COUNT(pid) = 1) then tiv_2016\\n    end), 2) as tiv_2016\\nfrom sub\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3619239,
                "title": "mysql-easy-solution-using-subquery",
                "content": "```\\nselect ROUND(SUM(DISTINCT i1.tiv_2016),2) as tiv_2016 \\nfrom Insurance i1, Insurance i2\\nwhere i1.tiv_2015 = i2.tiv_2015\\n  AND i1.pid <> i2.pid \\n  AND i1.pid NOT IN \\n(select DISTINCT a.pid \\nfrom insurance a, insurance b\\nwhere  a.pid <> b.pid \\n   AND a.lat = b.lat \\n   AND b.lon = a.lon);\\n   ```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect ROUND(SUM(DISTINCT i1.tiv_2016),2) as tiv_2016 \\nfrom Insurance i1, Insurance i2\\nwhere i1.tiv_2015 = i2.tiv_2015\\n  AND i1.pid <> i2.pid \\n  AND i1.pid NOT IN \\n(select DISTINCT a.pid \\nfrom insurance a, insurance b\\nwhere  a.pid <> b.pid \\n   AND a.lat = b.lat \\n   AND b.lon = a.lon);\\n   ```",
                "codeTag": "Unknown"
            },
            {
                "id": 2448640,
                "title": "simple-and-fast",
                "content": "```\\nselect round(sum(tiv_2016), 2) as tiv_2016 from (\\nselect  pid, tiv_2015, tiv_2016, lat, lon, count(1) over (partition by tiv_2015) as cnt_15, count(1) over (partition by lat, lon) as cnt_loc\\nfrom Insurance\\n) sub\\nwhere cnt_loc = 1 and cnt_15 > 1\\n\\n```",
                "solutionTags": [],
                "code": "```\\nselect round(sum(tiv_2016), 2) as tiv_2016 from (\\nselect  pid, tiv_2015, tiv_2016, lat, lon, count(1) over (partition by tiv_2015) as cnt_15, count(1) over (partition by lat, lon) as cnt_loc\\nfrom Insurance\\n) sub\\nwhere cnt_loc = 1 and cnt_15 > 1\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2257277,
                "title": "mysql",
                "content": "SELECT ROUND(SUM(tiv_2016),2) AS tiv_2016\\nFROM Insurance\\nWHERE tiv_2015 IN (SELECT tiv_2015 FROM Insurance GROUP BY tiv_2015 HAVING COUNT(tiv_2016)>1)\\nAND CONCAT(lat,lon) IN (SELECT CONCAT(lat,lon) FROM Insurance GROUP BY CONCAT(lat,lon) HAVING COUNT(CONCAT(lat,lon))=1)\\n;",
                "solutionTags": [],
                "code": "SELECT ROUND(SUM(tiv_2016),2) AS tiv_2016\\nFROM Insurance\\nWHERE tiv_2015 IN (SELECT tiv_2015 FROM Insurance GROUP BY tiv_2015 HAVING COUNT(tiv_2016)>1)\\nAND CONCAT(lat,lon) IN (SELECT CONCAT(lat,lon) FROM Insurance GROUP BY CONCAT(lat,lon) HAVING COUNT(CONCAT(lat,lon))=1)\\n;",
                "codeTag": "Unknown"
            },
            {
                "id": 1735464,
                "title": "mysql-solution-using-cte-and-window-functions",
                "content": "```\\nWITH insurance_aggs\\n     AS (SELECT *,\\n                Count(*)\\n                  OVER(\\n                    partition BY tiv_2015) tiv_rn,\\n                Count(*)\\n                  OVER(\\n                    partition BY lat, lon) loc_rn\\n         FROM   insurance)\\nSELECT Round(Sum(tiv_2016), 2) AS tiv_2016\\nFROM   insurance_aggs\\nWHERE  tiv_rn > 1\\n       AND loc_rn = 1 \\n```",
                "solutionTags": [],
                "code": "```\\nWITH insurance_aggs\\n     AS (SELECT *,\\n                Count(*)\\n                  OVER(\\n                    partition BY tiv_2015) tiv_rn,\\n                Count(*)\\n                  OVER(\\n                    partition BY lat, lon) loc_rn\\n         FROM   insurance)\\nSELECT Round(Sum(tiv_2016), 2) AS tiv_2016\\nFROM   insurance_aggs\\nWHERE  tiv_rn > 1\\n       AND loc_rn = 1 \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1587710,
                "title": "easiest-solution-faster-than-98-63-of-mysql",
                "content": "```\\nwith t1 as(select pid\\nfrom insurance\\ngroup by tiv_2015\\nhaving count(*)=1),\\n\\n t2 as(select pid, concat(lat, lon) loc\\nfrom insurance\\ngroup by loc\\nhaving count(*)=1)\\n\\n\\n\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom insurance\\nwhere pid not in (select * from t1) and pid in (select pid from t2)\\n```\\nso for table t1 we get the pid with distinct tiv_2015 value\\ntable t2 we get pid with distinct location\\nin the final code we pick pid not in t1 and pid in t2",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith t1 as(select pid\\nfrom insurance\\ngroup by tiv_2015\\nhaving count(*)=1),\\n\\n t2 as(select pid, concat(lat, lon) loc\\nfrom insurance\\ngroup by loc\\nhaving count(*)=1)\\n\\n\\n\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom insurance\\nwhere pid not in (select * from t1) and pid in (select pid from t2)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1505209,
                "title": "simple-logic-beat-98-98-submissions",
                "content": "select sum(tiv_2016) as TIV_2016 from insurance \\nwhere tiv_2015 in (select tiv_2015 from insurance \\n\\t\\t\\t\\t\\t\\t\\t\\tgroup by tiv_2015 \\n\\t\\t\\t\\t\\t\\t\\t\\thaving count(*) >1) \\n\\t\\t\\t\\t\\t\\tand \\n             (lat,lon) in (select lat,lon from insurance \\n\\t\\t\\t\\t\\t\\t\\t\\tgroup by lat,lon \\n\\t\\t\\t\\t\\t\\t\\t\\thaving count(*) =1)",
                "solutionTags": [],
                "code": "select sum(tiv_2016) as TIV_2016 from insurance \\nwhere tiv_2015 in (select tiv_2015 from insurance \\n\\t\\t\\t\\t\\t\\t\\t\\tgroup by tiv_2015 \\n\\t\\t\\t\\t\\t\\t\\t\\thaving count(*) >1) \\n\\t\\t\\t\\t\\t\\tand \\n             (lat,lon) in (select lat,lon from insurance \\n\\t\\t\\t\\t\\t\\t\\t\\tgroup by lat,lon \\n\\t\\t\\t\\t\\t\\t\\t\\thaving count(*) =1)",
                "codeTag": "Unknown"
            },
            {
                "id": 1139660,
                "title": "simple-mysql-solution-using-having-count",
                "content": "```\\nselect sum(TIV_2016) as TIV_2016\\nfrom insurance\\nwhere PID not in\\n(\\n    select PID from insurance\\n    group by TIV_2015\\n    having count(*) = 1    \\n)\\nand PID in\\n(\\n    select PID from insurance\\n    group by LAT, LON\\n    having count(*) = 1\\n)\\n```",
                "solutionTags": [],
                "code": "```\\nselect sum(TIV_2016) as TIV_2016\\nfrom insurance\\nwhere PID not in\\n(\\n    select PID from insurance\\n    group by TIV_2015\\n    having count(*) = 1    \\n)\\nand PID in\\n(\\n    select PID from insurance\\n    group by LAT, LON\\n    having count(*) = 1\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1059480,
                "title": "2-simple-solutions-for-any-sql-self-joins-and-where-not-in-having",
                "content": "```\\nSELECT ROUND(SUM(TIV_2016),2) AS TIV_2016 FROM insurance\\nWHERE TIV_2015 NOT IN (SELECT TIV_2015 FROM insurance GROUP BY TIV_2015 HAVING COUNT(PID) = 1)\\n      AND LAT NOT IN (SELECT LAT FROM insurance GROUP BY LAT,LON HAVING COUNT(PID) > 1)\\n```\\n\\n```\\nSELECT ROUND(SUM(TIV_2016),2) AS TIV_2016 \\nFROM \\n( \\nSELECT DISTINCT T1.PID,T1.TIV_2015,T1.TIV_2016,T1.LAT,T1.LON\\nFROM insurance T1 \\nLEFT JOIN insurance T2 ON T1.PID <> T2.PID AND T1.LAT = T2.LAT AND T1.LON = T2.LON\\nLEFT JOIN insurance T3 ON T1.PID <> T3.PID AND T1.TIV_2015 = T3.TIV_2015 \\nWHERE T2.LAT IS NULL AND T2.LON IS NULL AND T3.TIV_2015 IS NOT NULL ) TEMP\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT ROUND(SUM(TIV_2016),2) AS TIV_2016 FROM insurance\\nWHERE TIV_2015 NOT IN (SELECT TIV_2015 FROM insurance GROUP BY TIV_2015 HAVING COUNT(PID) = 1)\\n      AND LAT NOT IN (SELECT LAT FROM insurance GROUP BY LAT,LON HAVING COUNT(PID) > 1)\\n```\n```\\nSELECT ROUND(SUM(TIV_2016),2) AS TIV_2016 \\nFROM \\n( \\nSELECT DISTINCT T1.PID,T1.TIV_2015,T1.TIV_2016,T1.LAT,T1.LON\\nFROM insurance T1 \\nLEFT JOIN insurance T2 ON T1.PID <> T2.PID AND T1.LAT = T2.LAT AND T1.LON = T2.LON\\nLEFT JOIN insurance T3 ON T1.PID <> T3.PID AND T1.TIV_2015 = T3.TIV_2015 \\nWHERE T2.LAT IS NULL AND T2.LON IS NULL AND T3.TIV_2015 IS NOT NULL ) TEMP\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 771997,
                "title": "ms-sql-solution-window-function-no-concat-need",
                "content": "Use window function create 2 new column, which store the number of counts\\nThen, apply 2 simple where condition\\n\\n```\\nselect sum(TIV_2016) as TIV_2016 from\\n(\\n    select\\n        TIV_2016,\\n        count(*) over(partition by LAT, LON) as count_LATANDLON,\\n        count(*) over(partition by TIV_2015) as count_TIV2015\\nfrom insurance\\n) as t\\nwhere count_TIV2015 > 1 and count_LATANDLON = 1\\n```",
                "solutionTags": [
                    "MS SQL Server",
                    "Sliding Window"
                ],
                "code": "```\\nselect sum(TIV_2016) as TIV_2016 from\\n(\\n    select\\n        TIV_2016,\\n        count(*) over(partition by LAT, LON) as count_LATANDLON,\\n        count(*) over(partition by TIV_2015) as count_TIV2015\\nfrom insurance\\n) as t\\nwhere count_TIV2015 > 1 and count_LATANDLON = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 698983,
                "title": "oracle-solution",
                "content": "```\\nselect ROUND(SUM(TIV_2016),2) as TIV_2016 from (\\nselect PID, TIV_2015, TIV_2016, LAT, LON,\\nCOUNT(TIV_2015) OVER (PARTITION BY TIV_2015) as cnt_2015,\\nCOUNT(LAT) OVER (PARTITION BY LAT,LON) as cnt_city\\nfrom insurance\\n    )\\n    where cnt_2015>1\\n    and cnt_city=1\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nselect ROUND(SUM(TIV_2016),2) as TIV_2016 from (\\nselect PID, TIV_2015, TIV_2016, LAT, LON,\\nCOUNT(TIV_2015) OVER (PARTITION BY TIV_2015) as cnt_2015,\\nCOUNT(LAT) OVER (PARTITION BY LAT,LON) as cnt_city\\nfrom insurance\\n    )\\n    where cnt_2015>1\\n    and cnt_city=1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 520693,
                "title": "simple-and-easy-read-my-sql-solution",
                "content": "select sum(TIV_2016) TIV_2016  \\nfrom insurance \\nwhere TIV_2015 in (select TIV_2015 from insurance group by TIV_2015 having count(TIV_2015) > 1 ) \\nand (LAT,LON) in (select LAT,LON from insurance  group by LAT,LON having count(*) = 1)",
                "solutionTags": [],
                "code": "select sum(TIV_2016) TIV_2016  \\nfrom insurance \\nwhere TIV_2015 in (select TIV_2015 from insurance group by TIV_2015 having count(TIV_2015) > 1 ) \\nand (LAT,LON) in (select LAT,LON from insurance  group by LAT,LON having count(*) = 1)",
                "codeTag": "Unknown"
            },
            {
                "id": 232122,
                "title": "this-works-with-group-by-and-having",
                "content": "```\\nselect round(sum(TIV_2016 ),2) as TIV_2016 \\nfrom insurance \\nwhere tiv_2015 in (select TIV_2015  from insurance \\ngroup by tiv_2015\\nhaving count(*) > 1)\\nand (lat, lon) in (select lat, lon from insurance group by lat, lon having count(*) = 1)\\n```",
                "solutionTags": [],
                "code": "```\\nselect round(sum(TIV_2016 ),2) as TIV_2016 \\nfrom insurance \\nwhere tiv_2015 in (select TIV_2015  from insurance \\ngroup by tiv_2015\\nhaving count(*) > 1)\\nand (lat, lon) in (select lat, lon from insurance group by lat, lon having count(*) = 1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3983974,
                "title": "beats-80-one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef find_investments(insurance: pd.DataFrame) -> pd.DataFrame:\\n    return (pd.DataFrame({\"tiv_2016\":[insurance[(insurance.duplicated(subset=[\\'tiv_2015\\'], keep=False)) & (~(insurance.duplicated(subset=[\\'lat\\',\\'lon\\'], keep=False)))][\\'tiv_2016\\'].sum().round(2)]}))\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef find_investments(insurance: pd.DataFrame) -> pd.DataFrame:\\n    return (pd.DataFrame({\"tiv_2016\":[insurance[(insurance.duplicated(subset=[\\'tiv_2015\\'], keep=False)) & (~(insurance.duplicated(subset=[\\'lat\\',\\'lon\\'], keep=False)))][\\'tiv_2016\\'].sum().round(2)]}))\\n\\n\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3968223,
                "title": "pandas-solution-merging-unique-city-and-duplicate-tiv",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef find_investments(insurance: pd.DataFrame) -> pd.DataFrame:\\n    city=insurance[[\\'pid\\',\\'lat\\',\\'lon\\']]\\n    city_duplicates=city.duplicated(subset=[\\'lat\\',\\'lon\\'],keep=False)\\n    city_unique=city[~city_duplicates]\\n    tiv=insurance[[\\'pid\\',\\'tiv_2015\\',\\'tiv_2016\\']]\\n    tiv_duplicates=tiv.duplicated(subset=[\\'tiv_2015\\'],keep=False)\\n    tiv_dup=tiv[tiv_duplicates]\\n    target_insurance=pd.merge(tiv_dup,city_unique,on=\\'pid\\')\\n    tiv_2016_sum=target_insurance[\\'tiv_2016\\'].sum().round(2)\\n    data={\\'tiv_2016\\':[tiv_2016_sum]}\\n    return pd.DataFrame(data)\\n     \\n\\n\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef find_investments(insurance: pd.DataFrame) -> pd.DataFrame:\\n    city=insurance[[\\'pid\\',\\'lat\\',\\'lon\\']]\\n    city_duplicates=city.duplicated(subset=[\\'lat\\',\\'lon\\'],keep=False)\\n    city_unique=city[~city_duplicates]\\n    tiv=insurance[[\\'pid\\',\\'tiv_2015\\',\\'tiv_2016\\']]\\n    tiv_duplicates=tiv.duplicated(subset=[\\'tiv_2015\\'],keep=False)\\n    tiv_dup=tiv[tiv_duplicates]\\n    target_insurance=pd.merge(tiv_dup,city_unique,on=\\'pid\\')\\n    tiv_2016_sum=target_insurance[\\'tiv_2016\\'].sum().round(2)\\n    data={\\'tiv_2016\\':[tiv_2016_sum]}\\n    return pd.DataFrame(data)\\n     \\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3944627,
                "title": "pandas-two-filters-sum-remaining",
                "content": "# Intuition\\nCreate filters that will met the given criteria, and then just sum the ones that are left after filtering.\\n\\n# Approach\\neasiest way is to create 2 criteria, that later will be used in `.isin()`:\\n- Thise one is making sure we are dropping all rows where lat and lon are not unique (keep = False ensures we are not leaving one occurance of duplicated, as it normally happens) - leave only `pid` column:\\n`insurance.drop_duplicates(subset = [\\'lat\\',\\'lon\\'], keep = False).pid`\\n- Same logic, but this time we want duplicated: \\n`not_uniq_tiv_2015 = insurance.loc[insurance.duplicated(subset = \\'tiv_2015\\', keep=False)].pid`\\n\\nafter this, simply return sum of those tiv_2016, which are left after filtering with two criteria created earlier.\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef find_investments(insurance: pd.DataFrame) -> pd.DataFrame:\\n  uniq_lat_lon = insurance.drop_duplicates(subset = [\\'lat\\',\\'lon\\'], keep = False).pid\\n  not_uniq_tiv_2015 = insurance.loc[insurance.duplicated(subset = \\'tiv_2015\\', keep=False)].pid\\n  df = insurance.loc[insurance.pid.isin(uniq_lat_lon) & insurance.pid.isin(not_uniq_tiv_2015)]\\n  return df[[\\'tiv_2016\\']].sum().to_frame(\\'tiv_2016\\').round(2)\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef find_investments(insurance: pd.DataFrame) -> pd.DataFrame:\\n  uniq_lat_lon = insurance.drop_duplicates(subset = [\\'lat\\',\\'lon\\'], keep = False).pid\\n  not_uniq_tiv_2015 = insurance.loc[insurance.duplicated(subset = \\'tiv_2015\\', keep=False)].pid\\n  df = insurance.loc[insurance.pid.isin(uniq_lat_lon) & insurance.pid.isin(not_uniq_tiv_2015)]\\n  return df[[\\'tiv_2016\\']].sum().to_frame(\\'tiv_2016\\').round(2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3751433,
                "title": "simple-subqueries",
                "content": "\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nselect round(sum(tiv_2016),2) tiv_2016 from insurance i1\\nwhere 1 = (select count(lat||\\'#\\'||lon) from insurance i2 where i2.lat=i1.lat and i1.lon=i2.lon)\\nand 1 < (select count(tiv_2015) from insurance i3 where i3.tiv_2015=i1.tiv_2015)\\n\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nselect round(sum(tiv_2016),2) tiv_2016 from insurance i1\\nwhere 1 = (select count(lat||\\'#\\'||lon) from insurance i2 where i2.lat=i1.lat and i1.lon=i2.lon)\\nand 1 < (select count(tiv_2015) from insurance i3 where i3.tiv_2015=i1.tiv_2015)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3651889,
                "title": "simple-and-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nWITH A AS(SELECT tiv_2016,\\ncount(*) over (partition by lat, lon) as countlatlon,\\ncount(*) over (partition by tiv_2015) as counttiv2015\\nfrom Insurance)\\nSELECT ROUND(SUM(tiv_2016),2) as tiv_2016 FROM A \\nWHERE countlatlon = 1 and counttiv2015 >1\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nWITH A AS(SELECT tiv_2016,\\ncount(*) over (partition by lat, lon) as countlatlon,\\ncount(*) over (partition by tiv_2015) as counttiv2015\\nfrom Insurance)\\nSELECT ROUND(SUM(tiv_2016),2) as tiv_2016 FROM A \\nWHERE countlatlon = 1 and counttiv2015 >1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3631656,
                "title": "mysql-solution-using-sub-query",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT ROUND(SUM(tiv_2016), 2) AS tiv_2016\\nFROM Insurance\\nWHERE tiv_2015 IN (\\n    SELECT tiv_2015\\n    FROM Insurance\\n    GROUP BY tiv_2015\\n    HAVING COUNT(*) > 1\\n)\\nAND (lat, lon) IN (\\n    SELECT lat, lon\\n    FROM Insurance\\n    GROUP BY lat, lon\\n    HAVING COUNT(*) = 1\\n);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT ROUND(SUM(tiv_2016), 2) AS tiv_2016\\nFROM Insurance\\nWHERE tiv_2015 IN (\\n    SELECT tiv_2015\\n    FROM Insurance\\n    GROUP BY tiv_2015\\n    HAVING COUNT(*) > 1\\n)\\nAND (lat, lon) IN (\\n    SELECT lat, lon\\n    FROM Insurance\\n    GROUP BY lat, lon\\n    HAVING COUNT(*) = 1\\n);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3590706,
                "title": "cte",
                "content": "WITH cte AS(\\n    SELECT pid,tiv_2015,tiv_2016,COUNT(CONCAT(lat,lon)) OVER(PARTITION BY CONCAT(lat,lon)) AS cnt1,COUNT(tiv_2015) OVER(PARTITION BY tiv_2015) AS cnt\\n    FROM insurance\\n)\\n\\nSELECT ROUND(SUM(tiv_2016),2) AS tiv_2016\\nFROM cte\\nWHERE cnt1 = 1 AND cnt != 1;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "WITH cte AS(\\n    SELECT pid,tiv_2015,tiv_2016,COUNT(CONCAT(lat,lon)) OVER(PARTITION BY CONCAT(lat,lon)) AS cnt1,COUNT(tiv_2015) OVER(PARTITION BY tiv_2015) AS cnt\\n    FROM insurance\\n)\\n\\nSELECT ROUND(SUM(tiv_2016),2) AS tiv_2016\\nFROM cte\\nWHERE cnt1 = 1 AND cnt != 1;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2204192,
                "title": "mysql-with-subquery-explantion-inlcuded",
                "content": "```\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom\\n(select *\\nfrom insurance \\ngroup by lat,lon\\nhaving count(pid)=1) a #organize by the pair of lat & lon and select the group with unique pair\\nwhere tiv_2015 not in \\n(select tiv_2015\\nfrom insurance\\ngroup by tiv_2015\\nhaving count(tiv_2015)=1) # the list of all the unique tiv_2015\\n```",
                "solutionTags": [],
                "code": "```\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom\\n(select *\\nfrom insurance \\ngroup by lat,lon\\nhaving count(pid)=1) a #organize by the pair of lat & lon and select the group with unique pair\\nwhere tiv_2015 not in \\n(select tiv_2015\\nfrom insurance\\ngroup by tiv_2015\\nhaving count(tiv_2015)=1) # the list of all the unique tiv_2015\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2059875,
                "title": "readable-solution-with-full-explanation-faster-than-72-of-solutions",
                "content": "![image](https://assets.leetcode.com/users/images/1fcdb88e-a2d6-46bc-a6ec-cc92040af38c_1653130849.969336.png)\\n\\nWrite a query which joins the table to itself on ```a.pid != b.pid```, giving us all combinations of ```PID```. In the ```WHERE``` clause, place two conditions:\\n\\ni. The first condition finds all records where ```tiv_2015```  for a ```PID``` is equal to the ```tiv_2015``` for another ```PID```\\nii. The second condition filters through another query using ```NOT IN```\\n\\nThis subquery also joins the table to itself on the same condition, but finds all ```PID``` where the location (concatenation of ```longitude``` and ```latitude```) is *not equal*. Thus, ```NOT IN``` helps us remove these records.\\n\\nFinally, select the sum from the CTE and round to two figures\\n\\n\\n```\\nwith cte1 as\\n\\n(select distinct a.pid as a_id, a.tiv_2016\\nfrom Insurance a\\njoin Insurance b on a.pid != b.pid\\nwhere\\na.tiv_2015 = b.tiv_2015 and a.pid not in\\n\\n# subquery begins here\\n\\n(select distinct a.pid\\nfrom Insurance a\\njoin Insurance b on a.pid != b.pid\\nwhere concat(a.lat, \\', \\', a.lon) = concat(b.lat, \\', \\', b.lon)))\\n\\n# Collect the final, needed results\\n\\nselect round(sum(cte1.tiv_2016), 2) as tiv_2016 from cte1\\n```",
                "solutionTags": [],
                "code": "```a.pid != b.pid```\n```PID```\n```WHERE```\n```tiv_2015```\n```PID```\n```tiv_2015```\n```PID```\n```NOT IN```\n```PID```\n```longitude```\n```latitude```\n```NOT IN```\n```\\nwith cte1 as\\n\\n(select distinct a.pid as a_id, a.tiv_2016\\nfrom Insurance a\\njoin Insurance b on a.pid != b.pid\\nwhere\\na.tiv_2015 = b.tiv_2015 and a.pid not in\\n\\n# subquery begins here\\n\\n(select distinct a.pid\\nfrom Insurance a\\njoin Insurance b on a.pid != b.pid\\nwhere concat(a.lat, \\', \\', a.lon) = concat(b.lat, \\', \\', b.lon)))\\n\\n# Collect the final, needed results\\n\\nselect round(sum(cte1.tiv_2016), 2) as tiv_2016 from cte1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2027424,
                "title": "mssql-mysql",
                "content": "Runtime: 1007 ms, faster than 72.07% of MS SQL Server online submissions for Investments in 2016.\\nMemory Usage: 0B, less than 100.00% of MS SQL Server online submissions for Investments in 2016.\\n\\n```\\n/* Write your T-SQL query statement below */\\nselect ROUND(SUM(tiv_2016),2) AS tiv_2016 \\nfrom Insurance \\nwhere tiv_2015 IN ( select tiv_2015 from Insurance group by tiv_2015 having count(*) > 1 )\\nand CONCAT(lat,lon) NOT IN (select CONCAT(lat,lon) from Insurance group by lat,lon having count(*) > 1 )\\n```\\n\\nRuntime: 528 ms, faster than 51.36% of MySQL online submissions for Investments in 2016.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Investments in 2016.\\n```\\n# Write your MySQL query statement below\\nselect ROUND(SUM(tiv_2016),2) AS tiv_2016 \\nfrom Insurance \\nwhere tiv_2015 IN ( select tiv_2015 from Insurance group by tiv_2015 having count(*) > 1 )\\nand CONCAT(lat,lon) NOT IN (select CONCAT(lat,lon) from Insurance group by lat,lon having count(*) > 1 )\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect ROUND(SUM(tiv_2016),2) AS tiv_2016 \\nfrom Insurance \\nwhere tiv_2015 IN ( select tiv_2015 from Insurance group by tiv_2015 having count(*) > 1 )\\nand CONCAT(lat,lon) NOT IN (select CONCAT(lat,lon) from Insurance group by lat,lon having count(*) > 1 )\\n```\n```\\n# Write your MySQL query statement below\\nselect ROUND(SUM(tiv_2016),2) AS tiv_2016 \\nfrom Insurance \\nwhere tiv_2015 IN ( select tiv_2015 from Insurance group by tiv_2015 having count(*) > 1 )\\nand CONCAT(lat,lon) NOT IN (select CONCAT(lat,lon) from Insurance group by lat,lon having count(*) > 1 )\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2000231,
                "title": "simple-mysql-solution-with-cte",
                "content": "```\\nwith t1 as(\\n    select tiv_2015\\n    from Insurance\\n    group by tiv_2015\\n    having count(tiv_2015) > 1\\n),\\n\\nt2 as (\\n    select *\\n    from Insurance\\n    group by lat, lon\\n    having count(*) = 1\\n)\\n\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom Insurance\\nwhere tiv_2015 in (select * from t1) and pid in (select pid from t2)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nwith t1 as(\\n    select tiv_2015\\n    from Insurance\\n    group by tiv_2015\\n    having count(tiv_2015) > 1\\n),\\n\\nt2 as (\\n    select *\\n    from Insurance\\n    group by lat, lon\\n    having count(*) = 1\\n)\\n\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom Insurance\\nwhere tiv_2015 in (select * from t1) and pid in (select pid from t2)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1981002,
                "title": "simple-mysql-solution-using-having-in-count",
                "content": "```\\nselect ROUND(SUM(tiv_2016), 2) as tiv_2016\\nfrom insurance\\nwhere tiv_2015 IN\\n(select tiv_2015 from insurance group by tiv_2015 having COUNT(*) > 1)\\nand (lat, lon) IN\\n(select lat, lon from insurance group by lat, lon having COUNT(*) = 1)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect ROUND(SUM(tiv_2016), 2) as tiv_2016\\nfrom insurance\\nwhere tiv_2015 IN\\n(select tiv_2015 from insurance group by tiv_2015 having COUNT(*) > 1)\\nand (lat, lon) IN\\n(select lat, lon from insurance group by lat, lon having COUNT(*) = 1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1857177,
                "title": "mysql-one-sub-query-solution-beat-88",
                "content": "SELECT ROUND(SUM(tiv_2016),2) AS tiv_2016\\nFROM \\n       (SELECT pid,tiv_2015,tiv_2016,\\n        COUNT(pid) OVER(PARTITION BY lat,lon) AS C_cnt, \\n        COUNT(pid) OVER(PARTITION BY tiv_2015) AS T_cnt \\n        FROM Insurance) AS t\\nWHERE C_cnt=1 AND T_cnt>=2\\n",
                "solutionTags": [],
                "code": "SELECT ROUND(SUM(tiv_2016),2) AS tiv_2016\\nFROM \\n       (SELECT pid,tiv_2015,tiv_2016,\\n        COUNT(pid) OVER(PARTITION BY lat,lon) AS C_cnt, \\n        COUNT(pid) OVER(PARTITION BY tiv_2015) AS T_cnt \\n        FROM Insurance) AS t\\nWHERE C_cnt=1 AND T_cnt>=2\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1723059,
                "title": "window-functions-solution-95-faster",
                "content": "```\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom (\\n\\nselect *,count(*) over(partition by tiv_2015) cnt_2015,count(*) over(partition by lat,lon) cnt_loc from insurance\\n) a where cnt_2015 > 1 and cnt_loc = 1\\n```",
                "solutionTags": [],
                "code": "```\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom (\\n\\nselect *,count(*) over(partition by tiv_2015) cnt_2015,count(*) over(partition by lat,lon) cnt_loc from insurance\\n) a where cnt_2015 > 1 and cnt_loc = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1710553,
                "title": "very-easy-to-read-and-straightforward",
                "content": "```\\nselect\\nround(sum(tiv_2016),2) tiv_2016\\nfrom(\\nselect\\npid,\\ntiv_2016,\\ncount(pid) over (partition by tiv_2015) tiv_2015,\\ncount(pid) over (partition by lat,lon) lat_long\\n\\nfrom\\nInsurance\\n)a where tiv_2015 > 1 and lat_long = 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect\\nround(sum(tiv_2016),2) tiv_2016\\nfrom(\\nselect\\npid,\\ntiv_2016,\\ncount(pid) over (partition by tiv_2015) tiv_2015,\\ncount(pid) over (partition by lat,lon) lat_long\\n\\nfrom\\nInsurance\\n)a where tiv_2015 > 1 and lat_long = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1656743,
                "title": "oracle-solution-using-correlated-subquery",
                "content": "```\\nselect round(sum(tiv_2016), 2) \"tiv_2016\"\\nfrom insurance a\\nwhere tiv_2015 in (select tiv_2015 from insurance b where a.pid <> b.pid)\\nand (lat, lon) not in (select lat, lon from insurance b where a.pid <> b.pid)\\n```\\n\\n",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nselect round(sum(tiv_2016), 2) \"tiv_2016\"\\nfrom insurance a\\nwhere tiv_2015 in (select tiv_2015 from insurance b where a.pid <> b.pid)\\nand (lat, lon) not in (select lat, lon from insurance b where a.pid <> b.pid)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1634617,
                "title": "mysql-window-function-beats-96",
                "content": "select round(sum(tiv_2016),2) as tiv_2016\\nfrom\\n(select *, count(*) over (partition by lat, lon) as loc_cnt, count(*) over (partition by tiv_2015) as tiv_cnt from Insurance) a\\nwhere loc_cnt = 1 and tiv_cnt > 1;",
                "solutionTags": [],
                "code": "select round(sum(tiv_2016),2) as tiv_2016\\nfrom\\n(select *, count(*) over (partition by lat, lon) as loc_cnt, count(*) over (partition by tiv_2015) as tiv_cnt from Insurance) a\\nwhere loc_cnt = 1 and tiv_cnt > 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 1577856,
                "title": "mysql-easy-to-understand-solution",
                "content": "```\\nWITH my_table AS(\\nSELECT\\n    DISTINCT tb1.pid,\\n    tb1.tiv_2016\\n    \\nFROM \\n    Insurance tb1, Insurance tb2\\nWHERE \\n    tb1.pid <> tb2.pid\\n    AND tb1.tiv_2015 = tb2.tiv_2015\\nORDER BY \\n    tb1.pid\\n)\\n\\nSELECT ROUND(SUM(tiv_2016),2) AS tiv_2016 FROM my_table \\nWHERE pid IN (SELECT tb1.pid FROM (\\nSELECT \\n    pid,\\n    tiv_2016,\\n    CONCAT (lat, \\' \\' , lon) as conc\\nFROM\\n    Insurance\\nGROUP BY \\n    conc\\nHAVING \\n    Count(conc) = 1) tb1 )\\n```",
                "solutionTags": [],
                "code": "```\\nWITH my_table AS(\\nSELECT\\n    DISTINCT tb1.pid,\\n    tb1.tiv_2016\\n    \\nFROM \\n    Insurance tb1, Insurance tb2\\nWHERE \\n    tb1.pid <> tb2.pid\\n    AND tb1.tiv_2015 = tb2.tiv_2015\\nORDER BY \\n    tb1.pid\\n)\\n\\nSELECT ROUND(SUM(tiv_2016),2) AS tiv_2016 FROM my_table \\nWHERE pid IN (SELECT tb1.pid FROM (\\nSELECT \\n    pid,\\n    tiv_2016,\\n    CONCAT (lat, \\' \\' , lon) as conc\\nFROM\\n    Insurance\\nGROUP BY \\n    conc\\nHAVING \\n    Count(conc) = 1) tb1 )\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1481571,
                "title": "simple-oracle-solution",
                "content": "Here is my simple Oracle query\\n```\\nselect sum(tiv_2016) tiv_2016\\nfrom insurance a \\nwhere (lat, lon) not in (select lat, lon from insurance where pid <> a.pid)\\nand tiv_2015 in (select tiv_2015 from insurance where pid <> a.pid)\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nselect sum(tiv_2016) tiv_2016\\nfrom insurance a \\nwhere (lat, lon) not in (select lat, lon from insurance where pid <> a.pid)\\nand tiv_2015 in (select tiv_2015 from insurance where pid <> a.pid)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1477250,
                "title": "window-function-clear-login",
                "content": "```\\nSELECT SUM(b.TIV_2016) as TIV_2016\\nFROM\\n    (SELECT a.PID,a.TIV_2016, a.TIV_2015, COUNT(a.PID) OVER (PARTITION BY a.LOCATION) as location_count\\n    FROM\\n        (SELECT PID, TIV_2016, TIV_2015, CONCAT(LAT,LON) as Location\\n        FROM insurance) a)b -- count the location number\\nWHERE b.TIV_2015 in (SELECT TIV_2015 FROM insurance GROUP BY TIV_2015 HAVING COUNT(*) > 1) --set the filter on TIV_2015\\n    AND b.location_count = 1 --filter on the unique location\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT SUM(b.TIV_2016) as TIV_2016\\nFROM\\n    (SELECT a.PID,a.TIV_2016, a.TIV_2015, COUNT(a.PID) OVER (PARTITION BY a.LOCATION) as location_count\\n    FROM\\n        (SELECT PID, TIV_2016, TIV_2015, CONCAT(LAT,LON) as Location\\n        FROM insurance) a)b -- count the location number\\nWHERE b.TIV_2015 in (SELECT TIV_2015 FROM insurance GROUP BY TIV_2015 HAVING COUNT(*) > 1) --set the filter on TIV_2015\\n    AND b.location_count = 1 --filter on the unique location\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1424333,
                "title": "how-to-handle-null-case",
                "content": "I have my code as following which passes the test code but fails the submission. Due to the case when it\\'s null, it returns empty rather than null. Why would this happen and how to handle it? \\n```\\nselect sum(TIV_2016) TIV_2016\\nfrom (select *, count(*) over (partition by LAT, LON) ctloc\\nfrom insurance) tb\\nwhere ctloc=1\\ngroup by TIV_2015\\nhaving count(TIV_2015)>1\\n```",
                "solutionTags": [],
                "code": "```\\nselect sum(TIV_2016) TIV_2016\\nfrom (select *, count(*) over (partition by LAT, LON) ctloc\\nfrom insurance) tb\\nwhere ctloc=1\\ngroup by TIV_2015\\nhaving count(TIV_2015)>1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1403412,
                "title": "ms-sql-fast-simple",
                "content": "SELECT SUM(l1.TIV_2016) AS TIV_2016\\nFROM insurance l1 \\nWHERE l1.TIV_2015 IN (SELECT l2.TIV_2015 FROM insurance l2 WHERE l2.PID != l1.PID) \\nAND CONCAT(l1.LAT,l1.LON) NOT IN (SELECT CONCAT(l2.LAT,l2.LON)\\n                                   FROM insurance l2\\n                                  WHERE l2.PID != l1.PID);",
                "solutionTags": [],
                "code": "SELECT SUM(l1.TIV_2016) AS TIV_2016\\nFROM insurance l1 \\nWHERE l1.TIV_2015 IN (SELECT l2.TIV_2015 FROM insurance l2 WHERE l2.PID != l1.PID) \\nAND CONCAT(l1.LAT,l1.LON) NOT IN (SELECT CONCAT(l2.LAT,l2.LON)\\n                                   FROM insurance l2\\n                                  WHERE l2.PID != l1.PID);",
                "codeTag": "Unknown"
            },
            {
                "id": 1257794,
                "title": "easy-mysql-solution",
                "content": "select sum(t.tv16) as TIV_2016 \\nfrom\\n(select i.pid,i.tiv_2015 as tv15,i.tiv_2016 as tv16 from insurance i\\ngroup by i.lat,i.lon \\nhaving count(*)=1)t\\nwhere t.tv15 in \\n(select tiv_2015 from insurance i\\ngroup by tiv_2015 \\nhaving count(*)>1)",
                "solutionTags": [],
                "code": "select sum(t.tv16) as TIV_2016 \\nfrom\\n(select i.pid,i.tiv_2015 as tv15,i.tiv_2016 as tv16 from insurance i\\ngroup by i.lat,i.lon \\nhaving count(*)=1)t\\nwhere t.tv15 in \\n(select tiv_2015 from insurance i\\ngroup by tiv_2015 \\nhaving count(*)>1)",
                "codeTag": "Unknown"
            },
            {
                "id": 1039856,
                "title": "partition-by",
                "content": "```\\n# Write your MySQL query statement below\\nWITH tab AS (\\n    SELECT\\n        TIV_2016,\\n        COUNT(*) OVER (PARTITION BY TIV_2015) AS tiv_freq,\\n        COUNT(*) OVER (PARTITION BY LAT, LON) AS place_freq\\n    FROM\\n        insurance)\\n\\n\\n\\nSELECT\\n    ROUND(SUM(TIV_2016), 2) AS TIV_2016\\nFROM\\n    tab\\nWHERE\\n    tiv_freq > 1 AND\\n    place_freq = 1\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nWITH tab AS (\\n    SELECT\\n        TIV_2016,\\n        COUNT(*) OVER (PARTITION BY TIV_2015) AS tiv_freq,\\n        COUNT(*) OVER (PARTITION BY LAT, LON) AS place_freq\\n    FROM\\n        insurance)\\n\\n\\n\\nSELECT\\n    ROUND(SUM(TIV_2016), 2) AS TIV_2016\\nFROM\\n    tab\\nWHERE\\n    tiv_freq > 1 AND\\n    place_freq = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 938777,
                "title": "mysql-beats-100",
                "content": "```\\n# Write your MySQL query statement below\\nwith a as (\\nselect *, \\n    count(*) over (partition by TIV_2015) as cnt1,\\n    count(*) over (partition by LAT, LON) as cnt2\\n    from insurance\\n)\\nselect sum(TIV_2016) as TIV_2016 \\nfrom a\\nwhere cnt1 > 1 and cnt2 = 1\\n;\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nwith a as (\\nselect *, \\n    count(*) over (partition by TIV_2015) as cnt1,\\n    count(*) over (partition by LAT, LON) as cnt2\\n    from insurance\\n)\\nselect sum(TIV_2016) as TIV_2016 \\nfrom a\\nwhere cnt1 > 1 and cnt2 = 1\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 817593,
                "title": "faster-than-90-94-of-mysql-online-submissions-for-investments-in-2016",
                "content": "```\\n\\nwith t as \\n(\\n    select lat, lon, count(*) as cnt\\n    from insurance \\n    group by 1,2\\n    having cnt =1\\n    \\n)\\n\\n, f as\\n(\\n    select tiv_2015, count(*) as cnt\\n    from insurance \\n    group by 1\\n    having cnt>1\\n)\\n\\n\\nselect sum(a.tiv_2016) TIV_2016 \\nfrom insurance a\\njoin t b on a.lat = b.lat and a.lon = b.lon\\njoin f c on a.tiv_2015 = c.tiv_2015\\n```",
                "solutionTags": [],
                "code": "```\\n\\nwith t as \\n(\\n    select lat, lon, count(*) as cnt\\n    from insurance \\n    group by 1,2\\n    having cnt =1\\n    \\n)\\n\\n, f as\\n(\\n    select tiv_2015, count(*) as cnt\\n    from insurance \\n    group by 1\\n    having cnt>1\\n)\\n\\n\\nselect sum(a.tiv_2016) TIV_2016 \\nfrom insurance a\\njoin t b on a.lat = b.lat and a.lon = b.lon\\njoin f c on a.tiv_2015 = c.tiv_2015\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 684278,
                "title": "mysql-without-window-functions",
                "content": "```\\nSELECT\\n    SUM(TIV_2016) TIV_2016\\nFROM insurance x\\nWHERE \\n(SELECT COUNT(*) FROM insurance WHERE x.TIV_2015=TIV_2015) >1 AND \\n(SELECT COUNT(*) FROM insurance WHERE x.LAT=LAT AND x.LON=LON)=1;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n    SUM(TIV_2016) TIV_2016\\nFROM insurance x\\nWHERE \\n(SELECT COUNT(*) FROM insurance WHERE x.TIV_2015=TIV_2015) >1 AND \\n(SELECT COUNT(*) FROM insurance WHERE x.LAT=LAT AND x.LON=LON)=1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 589865,
                "title": "oracle",
                "content": "```\\nSELECT ROUND(SUM(TIV_2016),2) TIV_2016 \\nFROM\\n    (SELECT PID, TIV_2016,\\n        COUNT(PID)OVER(PARTITION BY TIV_2015) COUNT2015SAME,\\n        COUNT(PID)OVER(PARTITION BY LAT+LON) COUNTLOCATION\\n    FROM insurance) TEMP\\nWHERE COUNT2015SAME>1 AND COUNTLOCATION=1;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT ROUND(SUM(TIV_2016),2) TIV_2016 \\nFROM\\n    (SELECT PID, TIV_2016,\\n        COUNT(PID)OVER(PARTITION BY TIV_2015) COUNT2015SAME,\\n        COUNT(PID)OVER(PARTITION BY LAT+LON) COUNTLOCATION\\n    FROM insurance) TEMP\\nWHERE COUNT2015SAME>1 AND COUNTLOCATION=1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 564028,
                "title": "short-and-soimple",
                "content": "```\\nselect sum(tiv_2016) as tiv_2016 from (select pid, count(tiv_2015) over(partition by tiv_2015) as c, \\ntiv_2015, tiv_2016, count(concat(lat,lon)) over(partition by concat(lat,lon)) as l from insurance)t where c>1 and l=1\\n```",
                "solutionTags": [],
                "code": "```\\nselect sum(tiv_2016) as tiv_2016 from (select pid, count(tiv_2015) over(partition by tiv_2015) as c, \\ntiv_2015, tiv_2016, count(concat(lat,lon)) over(partition by concat(lat,lon)) as l from insurance)t where c>1 and l=1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 527189,
                "title": "oracle-solution-case-when-and-window",
                "content": "```\\nSelect\\nround(sum(TIV_2016),2) as TIV_2016\\nfrom\\n(\\n    Select\\npid,\\nTIV_2016,\\ncase when count(pid) over (partition by TIV_2015)>1 then \\'Y\\' else \\'N\\' end as tiv_2015_con,\\ncase when count(pid) over (partition by concat(LAT,LON) )>1 then \\'N\\' else \\'Y\\' end as latlon_con\\nFrom insurance\\n)where tiv_2015_con=\\'Y\\' and latlon_con=\\'Y\\'\\n```",
                "solutionTags": [],
                "code": "```\\nSelect\\nround(sum(TIV_2016),2) as TIV_2016\\nfrom\\n(\\n    Select\\npid,\\nTIV_2016,\\ncase when count(pid) over (partition by TIV_2015)>1 then \\'Y\\' else \\'N\\' end as tiv_2015_con,\\ncase when count(pid) over (partition by concat(LAT,LON) )>1 then \\'N\\' else \\'Y\\' end as latlon_con\\nFrom insurance\\n)where tiv_2015_con=\\'Y\\' and latlon_con=\\'Y\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 500042,
                "title": "mysql-two-methods-join-in",
                "content": "Method 1 - JOIN\\n\\nUse two left joins to get the occurrence of `TIV_2015` and `(LAT, LON)`, and then thoose the records with many occurrence of `TIV_2015` and only one occurrence of `(LAT, LON)` (562ms, 81.05%): \\n```\\nSELECT SUM(TIV_2016) AS TIV_2016\\nFROM \\n    insurance\\n    LEFT JOIN (SELECT TIV_2015, COUNT(*) AS f1 FROM insurance GROUP BY TIV_2015) a USING (TIV_2015)\\n    LEFT JOIN (SELECT LAT, LON, COUNT(*) AS f2 FROM insurance GROUP BY LAT, LON) b USING (LAT, LON)\\nWHERE\\n    f1 > 1 AND f2 = 1; \\n```\\n\\nMethod 2 - IN\\nDirectly choose records which satisfy requirements (253ms, 99.53%): \\n```\\nSELECT SUM(TIV_2016) AS TIV_2016\\nFROM insurance\\nWHERE\\n    TIV_2015 IN (SELECT TIV_2015 FROM insurance GROUP BY TIV_2015 HAVING COUNT(*) > 1)\\nAND\\n    CONCAT(LAT, LON) IN (SELECT CONCAT(LAT, LON) FROM insurance GROUP BY LAT, LON HAVING COUNT(*) = 1); \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT SUM(TIV_2016) AS TIV_2016\\nFROM \\n    insurance\\n    LEFT JOIN (SELECT TIV_2015, COUNT(*) AS f1 FROM insurance GROUP BY TIV_2015) a USING (TIV_2015)\\n    LEFT JOIN (SELECT LAT, LON, COUNT(*) AS f2 FROM insurance GROUP BY LAT, LON) b USING (LAT, LON)\\nWHERE\\n    f1 > 1 AND f2 = 1; \\n```\n```\\nSELECT SUM(TIV_2016) AS TIV_2016\\nFROM insurance\\nWHERE\\n    TIV_2015 IN (SELECT TIV_2015 FROM insurance GROUP BY TIV_2015 HAVING COUNT(*) > 1)\\nAND\\n    CONCAT(LAT, LON) IN (SELECT CONCAT(LAT, LON) FROM insurance GROUP BY LAT, LON HAVING COUNT(*) = 1); \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 487293,
                "title": "99-38-mssql-with-windows-aggregation-and-cte",
                "content": "```\\nwith cte1 as (\\nselect count(pid) over (partition by lat,lon) ctl, count(pid) over (partition by tiv_2015) ctt, TIV_2016 from insurance\\n), cte2 as (\\nselect TIV_2016 from cte1 where ctl = 1 and ctt >= 2\\n)\\nselect sum(TIV_2016) TIV_2016 from cte2\\n```",
                "solutionTags": [],
                "code": "```\\nwith cte1 as (\\nselect count(pid) over (partition by lat,lon) ctl, count(pid) over (partition by tiv_2015) ctt, TIV_2016 from insurance\\n), cte2 as (\\nselect TIV_2016 from cte1 where ctl = 1 and ctt >= 2\\n)\\nselect sum(TIV_2016) TIV_2016 from cte2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 420801,
                "title": "having",
                "content": "select round(sum(TIV_2016),2) as TIV_2016\\nfrom insurance\\nwhere TIV_2015 in \\n(select TIV_2015\\nfrom insurance \\ngroup by TIV_2015    \\nhaving count(1) >1) \\nand \\n(lat, lon) in \\n(select lat, lon\\nfrom insurance\\ngroup by lat, lon\\nhaving count(1) = 1)",
                "solutionTags": [],
                "code": "select round(sum(TIV_2016),2) as TIV_2016\\nfrom insurance\\nwhere TIV_2015 in \\n(select TIV_2015\\nfrom insurance \\ngroup by TIV_2015    \\nhaving count(1) >1) \\nand \\n(lat, lon) in \\n(select lat, lon\\nfrom insurance\\ngroup by lat, lon\\nhaving count(1) = 1)",
                "codeTag": "Unknown"
            },
            {
                "id": 390988,
                "title": "clean-solution-using-exists-and-not-exists",
                "content": "```\\nselect round(sum(i.tiv_2016), 2) as TIV_2016 from insurance i\\nwhere exists (select 1 from insurance where pid != i.pid and tiv_2015 = i.tiv_2015)\\nand not exists (select 1 from insurance where pid != i.pid and (i.lat, i.lon) = (lat, lon));\\n```",
                "solutionTags": [],
                "code": "```\\nselect round(sum(i.tiv_2016), 2) as TIV_2016 from insurance i\\nwhere exists (select 1 from insurance where pid != i.pid and tiv_2015 = i.tiv_2015)\\nand not exists (select 1 from insurance where pid != i.pid and (i.lat, i.lon) = (lat, lon));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 381765,
                "title": "sql-server",
                "content": "```\\nSELECT CAST(SUM(TIV_2016) AS DECIMAL(10,2)) AS TIV_2016\\nFROM insurance AS i\\nWHERE \\n1 < (SELECT COUNT(*) FROM insurance as i1 WHERE i1.TIV_2015 = i.TIV_2015 )\\nAND \\n1 = (SELECT COUNT(*) FROM insurance as i1 WHERE i1.LAT = i.LAT AND i1.LON = i.LON)\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT CAST(SUM(TIV_2016) AS DECIMAL(10,2)) AS TIV_2016\\nFROM insurance AS i\\nWHERE \\n1 < (SELECT COUNT(*) FROM insurance as i1 WHERE i1.TIV_2015 = i.TIV_2015 )\\nAND \\n1 = (SELECT COUNT(*) FROM insurance as i1 WHERE i1.LAT = i.LAT AND i1.LON = i.LON)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 372665,
                "title": "ms-sql-solution",
                "content": "```\\nWITH value_crit AS\\n(SELECT TIV_2015 FROM insurance\\nGROUP BY TIV_2015\\nHAVING COUNT(TIV_2015)>1)\\n, loc_crit AS\\n(SELECT LAT, LON FROM insurance\\nGROUP BY LAT, LON\\nHAVING COUNT(*)=1)\\nSELECT SUM(TIV_2016) AS TIV_2016 FROM \\ninsurance i\\nINNER JOIN loc_crit c\\nON i.LAT = c.LAT\\nAND i.LON = c.LON\\nWHERE TIV_2015 IN (SELECT TIV_2015 FROM value_crit)\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nWITH value_crit AS\\n(SELECT TIV_2015 FROM insurance\\nGROUP BY TIV_2015\\nHAVING COUNT(TIV_2015)>1)\\n, loc_crit AS\\n(SELECT LAT, LON FROM insurance\\nGROUP BY LAT, LON\\nHAVING COUNT(*)=1)\\nSELECT SUM(TIV_2016) AS TIV_2016 FROM \\ninsurance i\\nINNER JOIN loc_crit c\\nON i.LAT = c.LAT\\nAND i.LON = c.LON\\nWHERE TIV_2015 IN (SELECT TIV_2015 FROM value_crit)\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 370034,
                "title": "ms-sql-with-cte-or-subquery",
                "content": "with t as (\\nselect pid,tiv_2015,\\ncount(*) over(partition by tiv_2015) ctiv,\\ncount(*) over(partition by lat,lon) clat\\n from insurance) \\n select sum(tiv_2016) as TIV_2016\\n from insurance i\\n join t on t.pid=i.pid and t.ctiv>1 and t.clat=1",
                "solutionTags": [],
                "code": "with t as (\\nselect pid,tiv_2015,\\ncount(*) over(partition by tiv_2015) ctiv,\\ncount(*) over(partition by lat,lon) clat\\n from insurance) \\n select sum(tiv_2016) as TIV_2016\\n from insurance i\\n join t on t.pid=i.pid and t.ctiv>1 and t.clat=1",
                "codeTag": "Unknown"
            },
            {
                "id": 346587,
                "title": "using-subquery",
                "content": "```\\nselect sum(i.TIV_2016) TIV_2016\\nfrom insurance i\\nwhere \\n    # criteria 1\\n    i.pid in (select i.pid \\n                  from insurance i3\\n                where i.pid != i3.pid and \\n                        i.TIV_2015 = i3.TIV_2015)\\n    and  \\n    # criteria 2\\n    i.pid not in (select i1.pid\\n                from insurance i1, insurance i2\\n                where (i1.lat, i1.lon) = (i2.lat, i2.lon) and i1.pid != i2.pid)\\n```",
                "solutionTags": [],
                "code": "```\\nselect sum(i.TIV_2016) TIV_2016\\nfrom insurance i\\nwhere \\n    # criteria 1\\n    i.pid in (select i.pid \\n                  from insurance i3\\n                where i.pid != i3.pid and \\n                        i.TIV_2015 = i3.TIV_2015)\\n    and  \\n    # criteria 2\\n    i.pid not in (select i1.pid\\n                from insurance i1, insurance i2\\n                where (i1.lat, i1.lon) = (i2.lat, i2.lon) and i1.pid != i2.pid)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 320761,
                "title": "straightforward-mysql-solution-without-using-group-by-or-count",
                "content": "```\\nSELECT ROUND(SUM(TIV_2016), 2) AS TIV_2016\\nFROM   insurance i\\nJOIN  (SELECT    DISTINCT i1.PID\\n       FROM      insurance i1\\n       JOIN      insurance i2\\n       ON        i1.PID <> i2.PID AND i1.TIV_2015 = i2.TIV_2015\\n       LEFT JOIN insurance i3\\n       ON        i1.PID <> i3.PID AND i1.LAT = i3.LAT AND i1.LON = i3.LON\\n       WHERE     i3.PID IS NULL) j\\nON     i.PID = j.PID;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT ROUND(SUM(TIV_2016), 2) AS TIV_2016\\nFROM   insurance i\\nJOIN  (SELECT    DISTINCT i1.PID\\n       FROM      insurance i1\\n       JOIN      insurance i2\\n       ON        i1.PID <> i2.PID AND i1.TIV_2015 = i2.TIV_2015\\n       LEFT JOIN insurance i3\\n       ON        i1.PID <> i3.PID AND i1.LAT = i3.LAT AND i1.LON = i3.LON\\n       WHERE     i3.PID IS NULL) j\\nON     i.PID = j.PID;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 295459,
                "title": "using-oracle-analytic-functions-faster-than-100-solutions",
                "content": "Select sum(TIV_2016) as TIV_2016 \\nfrom\\n(select A.*,\\ncount(*) over(partition by TIV_2015) TIV2015_Count,\\ncount(*) over(partition by concat(LAT,LON)) Loc_Count\\nfrom Insurance A)\\nwhere TIV2015_Count > 1\\nand Loc_Count = 1;",
                "solutionTags": [],
                "code": "Select sum(TIV_2016) as TIV_2016 \\nfrom\\n(select A.*,\\ncount(*) over(partition by TIV_2015) TIV2015_Count,\\ncount(*) over(partition by concat(LAT,LON)) Loc_Count\\nfrom Insurance A)\\nwhere TIV2015_Count > 1\\nand Loc_Count = 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 245169,
                "title": "simple-groupby-and-filter-twice-274-ms",
                "content": "Find the PIDs that are valid by meeting the conditions, and get the sum. \\n\\nCode should be pretty self-explantory.\\n\\n```\\nSELECT SUM(TIV_2016) as TIV_2016 FROM Insurance \\nWHERE PID IN (\\n    SELECT PID FROM Insurance \\n    WHERE TIV_2015 IN (\\n        SELECT TIV_2015 FROM Insurance\\n        GROUP BY TIV_2015\\n        HAVING COUNT(PID) > 1\\n        )\\n    AND PID IN (\\n        SELECT PID FROM Insurance\\n        GROUP BY CONCAT(lat, lon) \\n        HAVING count(CONCAT(lat, lon)) < 2\\n        )\\n    )\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT SUM(TIV_2016) as TIV_2016 FROM Insurance \\nWHERE PID IN (\\n    SELECT PID FROM Insurance \\n    WHERE TIV_2015 IN (\\n        SELECT TIV_2015 FROM Insurance\\n        GROUP BY TIV_2015\\n        HAVING COUNT(PID) > 1\\n        )\\n    AND PID IN (\\n        SELECT PID FROM Insurance\\n        GROUP BY CONCAT(lat, lon) \\n        HAVING count(CONCAT(lat, lon)) < 2\\n        )\\n    )\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 103291,
                "title": "my-accepted-solution",
                "content": "```\\nselect sum(I.TIV_2016) as TIV_2016\\nFrom Insurance I\\nWhere I.Pid In (select I1.PID\\n    From Insurance I1, Insurance I2\\n    Where I1.TIV_2015 = I2.TIV_2015\\n    and I1.PID <> I2.Pid) \\n\\nand I.Pid Not In (select I1.PID\\n    From Insurance I1, Insurance I2\\n    Where I1.LAT = I2.LAT\\n    and I1.LON = I2.LON\\n    and I1.Pid <> I2.Pid)",
                "solutionTags": [],
                "code": "```\\nselect sum(I.TIV_2016) as TIV_2016\\nFrom Insurance I\\nWhere I.Pid In (select I1.PID\\n    From Insurance I1, Insurance I2\\n    Where I1.TIV_2015 = I2.TIV_2015\\n    and I1.PID <> I2.Pid) \\n\\nand I.Pid Not In (select I1.PID\\n    From Insurance I1, Insurance I2\\n    Where I1.LAT = I2.LAT\\n    and I1.LON = I2.LON\\n    and I1.Pid <> I2.Pid)",
                "codeTag": "Unknown"
            },
            {
                "id": 4106252,
                "title": "in-round-sum",
                "content": "# Code\\n```\\nSELECT ROUND(SUM(tiv_2016),2) AS tiv_2016\\nFROM Insurance\\nWHERE tiv_2015 IN (\\n    SELECT tiv_2015 \\n    FROM Insurance\\n    GROUP BY tiv_2015\\n    HAVING COUNT(*) > 1\\n)\\nAND\\n(lat, lon) IN (\\n    SELECT lat, lon\\n    FROM Insurance\\n    GROUP BY CONCAT(lat, lon)\\n    HAVING COUNT(*) = 1\\n)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT ROUND(SUM(tiv_2016),2) AS tiv_2016\\nFROM Insurance\\nWHERE tiv_2015 IN (\\n    SELECT tiv_2015 \\n    FROM Insurance\\n    GROUP BY tiv_2015\\n    HAVING COUNT(*) > 1\\n)\\nAND\\n(lat, lon) IN (\\n    SELECT lat, lon\\n    FROM Insurance\\n    GROUP BY CONCAT(lat, lon)\\n    HAVING COUNT(*) = 1\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4101069,
                "title": "solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT ROUND(SUM(i1.tiv_2016),2) as tiv_2016 FROM Insurance i1\\nWHERE (i1.pid, 1) IN (SELECT i2.pid, (SELECT IF(COUNT(i3.tiv_2015)>=1,1,0) FROM Insurance i3 WHERE i2.tiv_2015=i3.tiv_2015 AND NOT i2.pid=i3.pid) as cnt_tiv FROM Insurance i2 GROUP BY i2.pid) AND (i1.pid, 1) IN (SELECT i2.pid, (SELECT COUNT(i3.pid) FROM Insurance i3 WHERE (i2.lat, i2.lon) = (i3.lat, i3.lon)) as cnt_latlon FROM Insurance i2 GROUP BY i2.pid)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT ROUND(SUM(i1.tiv_2016),2) as tiv_2016 FROM Insurance i1\\nWHERE (i1.pid, 1) IN (SELECT i2.pid, (SELECT IF(COUNT(i3.tiv_2015)>=1,1,0) FROM Insurance i3 WHERE i2.tiv_2015=i3.tiv_2015 AND NOT i2.pid=i3.pid) as cnt_tiv FROM Insurance i2 GROUP BY i2.pid) AND (i1.pid, 1) IN (SELECT i2.pid, (SELECT COUNT(i3.pid) FROM Insurance i3 WHERE (i2.lat, i2.lon) = (i3.lat, i3.lon)) as cnt_latlon FROM Insurance i2 GROUP BY i2.pid)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4099506,
                "title": "sql-simple-solution-with-over-clause",
                "content": "# Code\\n```\\nSELECT\\n  round(sum(tiv_2016), 2) AS tiv_2016\\nFROM (\\n  SELECT\\n    tiv_2016,\\n    count(*) OVER(PARTITION BY tiv_2015) AS \\'tiv_count\\',\\n    count(*) OVER(PARTITION BY lat, lon) AS \\'coord_count\\'\\n  FROM Insurance\\n) i1\\nWHERE tiv_count > 1 AND coord_count = 1\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT\\n  round(sum(tiv_2016), 2) AS tiv_2016\\nFROM (\\n  SELECT\\n    tiv_2016,\\n    count(*) OVER(PARTITION BY tiv_2015) AS \\'tiv_count\\',\\n    count(*) OVER(PARTITION BY lat, lon) AS \\'coord_count\\'\\n  FROM Insurance\\n) i1\\nWHERE tiv_count > 1 AND coord_count = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4097347,
                "title": "mysql-solution-with-exists-and-not-exists",
                "content": "mysql solution with exists and not exists\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect ROUND(sum(tiv_2016),2) tiv_2016 \\n  from insurance\\n where exists (select * \\n                          from insurance is2\\n                        where is2.tiv_2015 = insurance.tiv_2015\\n                          and is2.pid <> insurance.pid)\\n    and not exists(select * \\n                     from insurance is2\\n                    where is2.lat = insurance.lat\\n                      and is2.lon = insurance.lon\\n                      and is2.pid <> insurance.pid)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect ROUND(sum(tiv_2016),2) tiv_2016 \\n  from insurance\\n where exists (select * \\n                          from insurance is2\\n                        where is2.tiv_2015 = insurance.tiv_2015\\n                          and is2.pid <> insurance.pid)\\n    and not exists(select * \\n                     from insurance is2\\n                    where is2.lat = insurance.lat\\n                      and is2.lon = insurance.lon\\n                      and is2.pid <> insurance.pid)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4096145,
                "title": "",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nWITH tb1 (pid, tiv_2016)\\nAS(\\nSELECT pid, tiv_2016\\nFROM Insurance ins\\nWHERE tiv_2015 IN (select tiv_2015\\n                  from Insurance r\\n                  where r.pid != ins.pid)\\n),\\ntb2 (pid, tiv_2016)\\nAS (\\n  SELECT pid, tiv_2016\\n  FROM Insurance ins\\n  WHERE (lat, lon) NOT IN (\\n    select lat, lon\\n    from Insurance n\\n    where n.pid != ins.pid\\n  )\\n)\\nSELECT ROUND(SUM(tb1.tiv_2016), 2) AS tiv_2016\\nFROM tb1\\n  INNER JOIN tb2 USING(pid)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nWITH tb1 (pid, tiv_2016)\\nAS(\\nSELECT pid, tiv_2016\\nFROM Insurance ins\\nWHERE tiv_2015 IN (select tiv_2015\\n                  from Insurance r\\n                  where r.pid != ins.pid)\\n),\\ntb2 (pid, tiv_2016)\\nAS (\\n  SELECT pid, tiv_2016\\n  FROM Insurance ins\\n  WHERE (lat, lon) NOT IN (\\n    select lat, lon\\n    from Insurance n\\n    where n.pid != ins.pid\\n  )\\n)\\nSELECT ROUND(SUM(tb1.tiv_2016), 2) AS tiv_2016\\nFROM tb1\\n  INNER JOIN tb2 USING(pid)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4093895,
                "title": "solution-using-subqueries",
                "content": "# Code\\n```\\nselect round(sum(t.tiv_2016), 2) as tiv_2016\\nfrom (\\n    select\\n        p1.tiv_2016, \\n        (select sum(if(p2.tiv_2015 = p1.tiv_2015 and p1.pid != p2.pid, 1, 0)) from insurance p2) > 0 as is_same_tiv_2015,\\n        (select sum(if(p3.lat = p1.lat and p3.lon = p1.lon and p1.pid != p3.pid, 1, 0)) from insurance p3) = 0 as is_unique_geo\\n    from insurance p1\\n) t\\nwhere t.is_same_tiv_2015 = 1 and t.is_unique_geo = 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect round(sum(t.tiv_2016), 2) as tiv_2016\\nfrom (\\n    select\\n        p1.tiv_2016, \\n        (select sum(if(p2.tiv_2015 = p1.tiv_2015 and p1.pid != p2.pid, 1, 0)) from insurance p2) > 0 as is_same_tiv_2015,\\n        (select sum(if(p3.lat = p1.lat and p3.lon = p1.lon and p1.pid != p3.pid, 1, 0)) from insurance p3) = 0 as is_unique_geo\\n    from insurance p1\\n) t\\nwhere t.is_same_tiv_2015 = 1 and t.is_unique_geo = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4092156,
                "title": "easy-method-using-with-as",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nWITH tivc AS(\\n  SELECT tiv_2015,COUNT(*) AS counts\\n  FROM Insurance\\n  GROUP BY tiv_2015\\n),\\nlatlon AS(\\n  SELECT lat,lon,COUNT(*) AS counts\\n  FROM Insurance\\n  GROUP BY lat,lon\\n)\\nSELECT ROUND(SUM(tiv_2016),2) AS tiv_2016\\nFROM Insurance I\\nLEFT JOIN latlon ON latlon.lat=I.lat AND latlon.lon=I.lon\\nLEFT JOIN tivc ON tivc.tiv_2015=I.tiv_2015\\nWHERE tivc.counts>1 AND latlon.counts=1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nWITH tivc AS(\\n  SELECT tiv_2015,COUNT(*) AS counts\\n  FROM Insurance\\n  GROUP BY tiv_2015\\n),\\nlatlon AS(\\n  SELECT lat,lon,COUNT(*) AS counts\\n  FROM Insurance\\n  GROUP BY lat,lon\\n)\\nSELECT ROUND(SUM(tiv_2016),2) AS tiv_2016\\nFROM Insurance I\\nLEFT JOIN latlon ON latlon.lat=I.lat AND latlon.lon=I.lon\\nLEFT JOIN tivc ON tivc.tiv_2015=I.tiv_2015\\nWHERE tivc.counts>1 AND latlon.counts=1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4091888,
                "title": "easy-to-understand-soln-beats-99-no-concat-or-partition",
                "content": "lat and lon to be unique so count and see that it doesnt go over 1, and select tiv_2015 that have count more than 1\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nWith cte as (\\n    select *,count(lat) as clat, count(lon) as clon from Insurance\\n    group by lat,lon\\n    having tiv_2015 in (select tiv_2015 from insurance group by tiv_2015 having count(tiv_2015)>1)\\n)\\n\\n\\nselect round(sum(tiv_2016),2) as tiv_2016 from cte\\nwhere clon=1 and clat = 1\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nWith cte as (\\n    select *,count(lat) as clat, count(lon) as clon from Insurance\\n    group by lat,lon\\n    having tiv_2015 in (select tiv_2015 from insurance group by tiv_2015 having count(tiv_2015)>1)\\n)\\n\\n\\nselect round(sum(tiv_2016),2) as tiv_2016 from cte\\nwhere clon=1 and clat = 1\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4090968,
                "title": "join-vs-in",
                "content": "# IN\\n```\\nSELECT round(sum(tiv_2016), 2) as tiv_2016\\nFROM insurance\\nWHERE tiv_2015 IN (\\n\\xA0 \\xA0 SELECT tiv_2015\\n\\xA0 \\xA0 FROM insurance\\n\\xA0 \\xA0 GROUP BY tiv_2015\\n\\xA0 \\xA0 HAVING count(pid) > 1\\n) and (lat, lon) IN (\\n\\xA0 \\xA0 SELECT lat, lon\\n\\xA0 \\xA0 FROM insurance\\n\\xA0 \\xA0 GROUP BY lat, lon\\n\\xA0 \\xA0 HAVING count(pid) = 1\\n)\\n```\\n# JOIN\\n```\\nSELECT round(sum(tiv_2016), 2) as tiv_2016\\nFROM insurance\\nJOIN (\\n    SELECT tiv_2015\\n    FROM insurance\\n    GROUP BY tiv_2015\\n    HAVING count(pid) > 1\\n) AS t1 USING(tiv_2015) \\nJOIN (\\n    SELECT lat, lon\\n    FROM insurance\\n    GROUP BY lat, lon\\n    HAVING count(pid) = 1\\n) AS t2 USING(lat, lon)\\n```\\n\\n![newcat.jpeg](https://assets.leetcode.com/users/images/cb06bcac-0c98-441f-9a63-29da29817688_1696038117.3384302.jpeg)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT round(sum(tiv_2016), 2) as tiv_2016\\nFROM insurance\\nWHERE tiv_2015 IN (\\n\\xA0 \\xA0 SELECT tiv_2015\\n\\xA0 \\xA0 FROM insurance\\n\\xA0 \\xA0 GROUP BY tiv_2015\\n\\xA0 \\xA0 HAVING count(pid) > 1\\n) and (lat, lon) IN (\\n\\xA0 \\xA0 SELECT lat, lon\\n\\xA0 \\xA0 FROM insurance\\n\\xA0 \\xA0 GROUP BY lat, lon\\n\\xA0 \\xA0 HAVING count(pid) = 1\\n)\\n```\n```\\nSELECT round(sum(tiv_2016), 2) as tiv_2016\\nFROM insurance\\nJOIN (\\n    SELECT tiv_2015\\n    FROM insurance\\n    GROUP BY tiv_2015\\n    HAVING count(pid) > 1\\n) AS t1 USING(tiv_2015) \\nJOIN (\\n    SELECT lat, lon\\n    FROM insurance\\n    GROUP BY lat, lon\\n    HAVING count(pid) = 1\\n) AS t2 USING(lat, lon)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4089830,
                "title": "built-using-basics-of-python",
                "content": "# Code\\n```\\nimport pandas as pd\\n\\ndef find_investments(insurance: pd.DataFrame) -> pd.DataFrame:\\n    insurance[\\'location\\'] = insurance[\\'lat\\'] + insurance[\\'lon\\']\\n    cri_1 = insurance[\\'tiv_2015\\'].values\\n    d1 = {}\\n    for i in cri_1:\\n        d1.setdefault(i,0)\\n        d1[i] = d1[i] + 1\\n    cri_2 = insurance[\\'location\\'].values\\n    d2 = {}\\n    for i in cri_2:\\n        d2.setdefault(i,0)\\n        d2[i] = d2[i] + 1\\n\\n    l1 = []\\n    for i,v in d1.items():\\n        if v >= 2:\\n            l1.append(i)\\n    l2 = []\\n    for i,v in d2.items():\\n        if v >= 2:\\n            l2.append(i)\\n    \\n    l1_indices = []\\n    for i in l1:\\n        l1_indices.extend(list(insurance[insurance[\\'tiv_2015\\'] == i].index))\\n    l2_indices = []\\n    for i in l2:\\n        l2_indices.extend(list(insurance[insurance[\\'location\\'] == i].index))\\n\\n    ind = list(range(insurance.shape[0]))\\n    new_index = []\\n    for i in ind:\\n        if i not in l1_indices:\\n            new_index.append(i)\\n    \\n    new_index.extend(l2_indices)\\n    drop_indices = list(set(new_index))\\n    insurance.drop(index = drop_indices,inplace = True)\\n\\n    ans = pd.DataFrame(columns = [\\'tiv_2016\\'])\\n    n = sum(insurance[\\'tiv_2016\\'])\\n    ans.loc[0,:] = round(n,2)\\n    \\n    return ans\\n\\n\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef find_investments(insurance: pd.DataFrame) -> pd.DataFrame:\\n    insurance[\\'location\\'] = insurance[\\'lat\\'] + insurance[\\'lon\\']\\n    cri_1 = insurance[\\'tiv_2015\\'].values\\n    d1 = {}\\n    for i in cri_1:\\n        d1.setdefault(i,0)\\n        d1[i] = d1[i] + 1\\n    cri_2 = insurance[\\'location\\'].values\\n    d2 = {}\\n    for i in cri_2:\\n        d2.setdefault(i,0)\\n        d2[i] = d2[i] + 1\\n\\n    l1 = []\\n    for i,v in d1.items():\\n        if v >= 2:\\n            l1.append(i)\\n    l2 = []\\n    for i,v in d2.items():\\n        if v >= 2:\\n            l2.append(i)\\n    \\n    l1_indices = []\\n    for i in l1:\\n        l1_indices.extend(list(insurance[insurance[\\'tiv_2015\\'] == i].index))\\n    l2_indices = []\\n    for i in l2:\\n        l2_indices.extend(list(insurance[insurance[\\'location\\'] == i].index))\\n\\n    ind = list(range(insurance.shape[0]))\\n    new_index = []\\n    for i in ind:\\n        if i not in l1_indices:\\n            new_index.append(i)\\n    \\n    new_index.extend(l2_indices)\\n    drop_indices = list(set(new_index))\\n    insurance.drop(index = drop_indices,inplace = True)\\n\\n    ans = pd.DataFrame(columns = [\\'tiv_2016\\'])\\n    n = sum(insurance[\\'tiv_2016\\'])\\n    ans.loc[0,:] = round(n,2)\\n    \\n    return ans\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4089689,
                "title": "easy-approach",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith table1 as(\\nselect pid , tiv_2015 ,count(tiv_2015) over(partition by tiv_2015) as cnt_tiv_2015 ,tiv_2016 , count(concat(lat,lon)) over(partition by concat(lat,lon)) as cnt_location\\nfrom insurance)\\nselect round(sum(tiv_2016),2) as tiv_2016 \\nfrom table1\\nwhere cnt_tiv_2015 >= 2 and cnt_location <= 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith table1 as(\\nselect pid , tiv_2015 ,count(tiv_2015) over(partition by tiv_2015) as cnt_tiv_2015 ,tiv_2016 , count(concat(lat,lon)) over(partition by concat(lat,lon)) as cnt_location\\nfrom insurance)\\nselect round(sum(tiv_2016),2) as tiv_2016 \\nfrom table1\\nwhere cnt_tiv_2015 >= 2 and cnt_location <= 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4088840,
                "title": "simple-subquery-solution-98-runtime",
                "content": "# Code\\n```\\nSELECT \\n    ROUND(SUM(i.tiv_2016),2) AS tiv_2016\\nFROM insurance i\\nINNER JOIN (\\n    SELECT lon, lat\\n    FROM insurance\\n    GROUP BY lon, lat\\n    HAVING COUNT(*) = 1\\n) t1 ON t1.lon = i.lon AND t1.lat = i.lat\\nINNER JOIN (\\n    SELECT tiv_2015\\n    FROM insurance\\n    GROUP BY tiv_2015\\n    HAVING COUNT(*) > 1\\n) t2 ON t2.tiv_2015 = i.tiv_2015\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\n    ROUND(SUM(i.tiv_2016),2) AS tiv_2016\\nFROM insurance i\\nINNER JOIN (\\n    SELECT lon, lat\\n    FROM insurance\\n    GROUP BY lon, lat\\n    HAVING COUNT(*) = 1\\n) t1 ON t1.lon = i.lon AND t1.lat = i.lat\\nINNER JOIN (\\n    SELECT tiv_2015\\n    FROM insurance\\n    GROUP BY tiv_2015\\n    HAVING COUNT(*) > 1\\n) t2 ON t2.tiv_2015 = i.tiv_2015\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4085264,
                "title": "easy-simple-naive-solution-mysql-with-exists-and-not-exists",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect ROUND(sum(i1.tiv_2016), 2) as tiv_2016\\nfrom Insurance i1\\nwhere not exists \\n(select 1 from Insurance i2\\nwhere i1.pid <> i2.pid and i1.lat = i2.lat and i1.lon = i2.lon \\n) \\nand exists \\n(select 1 from Insurance i3\\nwhere i1.pid <> i3.pid and i1.tiv_2015 = i3.tiv_2015\\n)\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect ROUND(sum(i1.tiv_2016), 2) as tiv_2016\\nfrom Insurance i1\\nwhere not exists \\n(select 1 from Insurance i2\\nwhere i1.pid <> i2.pid and i1.lat = i2.lat and i1.lon = i2.lon \\n) \\nand exists \\n(select 1 from Insurance i3\\nwhere i1.pid <> i3.pid and i1.tiv_2015 = i3.tiv_2015\\n)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4084123,
                "title": "all-test-cases-passed-beginner-friendly-solution",
                "content": "<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Code\\n```\\nwith cte as \\n(select  concat(lat,\\',\\',lon) as loc from Insurance group by lat,lon\\nhaving count(pid)>1),\\n\\ncte2 as (\\nselect distinct n.* from Insurance n left join Insurance n2 on n.tiv_2015 =n2.tiv_2015 where n.pid<>n2.pid and concat(n.lat,\\',\\',n.lon) not in (select loc from cte)\\n)\\nselect round(sum(tiv_2016),2) as tiv_2016 from cte2\\n```\\n\\nrefered and learned from youtube",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith cte as \\n(select  concat(lat,\\',\\',lon) as loc from Insurance group by lat,lon\\nhaving count(pid)>1),\\n\\ncte2 as (\\nselect distinct n.* from Insurance n left join Insurance n2 on n.tiv_2015 =n2.tiv_2015 where n.pid<>n2.pid and concat(n.lat,\\',\\',n.lon) not in (select loc from cte)\\n)\\nselect round(sum(tiv_2016),2) as tiv_2016 from cte2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4083597,
                "title": "this-is-my-solution-with-sql-server-i-love-vietnam",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT \\nROUND(SUM(tiv_2016),2) AS tiv_2016 \\nFROM Insurance AS i\\nWHERE tiv_2015 IN (SELECT tiv_2015 FROM Insurance AS ins WHERE ins.pid!=i.pid) \\nAND NOT EXISTS (\\n    SELECT 1\\n    FROM (\\n        SELECT lat, lon, COUNT(*) AS count\\n        FROM Insurance \\n        GROUP BY lat,lon\\n    ) AS insu\\n    WHERE i.lat=insu.lat AND i.lon=insu.lon AND insu.count>1\\n)\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT \\nROUND(SUM(tiv_2016),2) AS tiv_2016 \\nFROM Insurance AS i\\nWHERE tiv_2015 IN (SELECT tiv_2015 FROM Insurance AS ins WHERE ins.pid!=i.pid) \\nAND NOT EXISTS (\\n    SELECT 1\\n    FROM (\\n        SELECT lat, lon, COUNT(*) AS count\\n        FROM Insurance \\n        GROUP BY lat,lon\\n    ) AS insu\\n    WHERE i.lat=insu.lat AND i.lon=insu.lon AND insu.count>1\\n)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4081864,
                "title": "with-partitions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect round(sum(tiv_2016),2) as tiv_2016 \\nfrom\\n(select tiv_2016, \\ncount(tiv_2015) over(partition by concat(lat,lon)) as cnt_tiv_2015,\\ncount(concat(lat,lon)) over(partition by tiv_2015) as cnt_lat_lon\\nfrom Insurance)A\\nwhere  cnt_tiv_2015=1 \\nand cnt_lat_lon>=2\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect round(sum(tiv_2016),2) as tiv_2016 \\nfrom\\n(select tiv_2016, \\ncount(tiv_2015) over(partition by concat(lat,lon)) as cnt_tiv_2015,\\ncount(concat(lat,lon)) over(partition by tiv_2015) as cnt_lat_lon\\nfrom Insurance)A\\nwhere  cnt_tiv_2015=1 \\nand cnt_lat_lon>=2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4080367,
                "title": "mssql-with-exists",
                "content": "# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nselect\\n    round(sum(tiv_2016), 2) as tiv_2016 \\nfrom Insurance i \\nwhere exists (select * from Insurance o where o.pid!=i.pid and i.tiv_2015=o.tiv_2015)\\n  and not exists ( select * from Insurance o where o.pid!=i.pid and i.lon=o.lon and i.lat=o.lat)\\n```",
                "solutionTags": [
                    "MS SQL Server",
                    "Database"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nselect\\n    round(sum(tiv_2016), 2) as tiv_2016 \\nfrom Insurance i \\nwhere exists (select * from Insurance o where o.pid!=i.pid and i.tiv_2015=o.tiv_2015)\\n  and not exists ( select * from Insurance o where o.pid!=i.pid and i.lon=o.lon and i.lat=o.lat)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4076093,
                "title": "runtime-beats-84-77-and-memory-beats-100-00-of-users-with-oracle",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT round(sum(i1.tiv_2016),2) tiv_2016\\nFROM (SELECT pid,tiv_2015,tiv_2016,lat,lon, \\ncount(tiv_2015) over(partition by tiv_2015 order by tiv_2015) cnt\\nFROM Insurance) i1\\nINNER JOIN insurance i2\\nON i1.pid=i2.pid\\nWHERE i1.cnt>1 AND (i1.lat,i1.lon) \\nNOT IN (SELECT i2.lat, i2.lon FROM insurance i2 WHERE i2.pid != i1.pid)\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT round(sum(i1.tiv_2016),2) tiv_2016\\nFROM (SELECT pid,tiv_2015,tiv_2016,lat,lon, \\ncount(tiv_2015) over(partition by tiv_2015 order by tiv_2015) cnt\\nFROM Insurance) i1\\nINNER JOIN insurance i2\\nON i1.pid=i2.pid\\nWHERE i1.cnt>1 AND (i1.lat,i1.lon) \\nNOT IN (SELECT i2.lat, i2.lon FROM insurance i2 WHERE i2.pid != i1.pid)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4074315,
                "title": "mysql-subquery",
                "content": "# Code 1\\n```\\n# Write your MySQL query statement below\\nselect round(sum(tiv_2016), 2) as tiv_2016\\nfrom insurance i1\\nwhere tiv_2015 in (select tiv_2015 from insurance i2 where i1.pid != i2.pid)\\nand (lat, lon) not in (select lat, lon from insurance i3 where i3.pid != i1.pid)\\n```\\n# Code 2\\n```\\n# Write your MySQL query statement below\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom insurance\\nwhere tiv_2015 in (\\n  select tiv_2015 from insurance group by tiv_2015 having count(*) > 1\\n) \\nand (lat, lon) in (\\n  select lat, lon from insurance group by lat, lon having count(*) = 1\\n)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect round(sum(tiv_2016), 2) as tiv_2016\\nfrom insurance i1\\nwhere tiv_2015 in (select tiv_2015 from insurance i2 where i1.pid != i2.pid)\\nand (lat, lon) not in (select lat, lon from insurance i3 where i3.pid != i1.pid)\\n```\n```\\n# Write your MySQL query statement below\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom insurance\\nwhere tiv_2015 in (\\n  select tiv_2015 from insurance group by tiv_2015 having count(*) > 1\\n) \\nand (lat, lon) in (\\n  select lat, lon from insurance group by lat, lon having count(*) = 1\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4074154,
                "title": "using-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom Insurance I\\nLEFT JOIN (\\n    SELECT pid, tiv_2015,\\n           ROW_NUMBER() OVER(PARTITION BY tiv_2015 ORDER BY pid) as row_num_tiv,\\n           COUNT(*) OVER(PARTITION BY tiv_2015) as count_tiv\\n    FROM Insurance\\n) t ON I.pid = t.pid\\nLEFT JOIN (\\n    SELECT pid, lat, lon,\\n           ROW_NUMBER() OVER(PARTITION BY lat, lon ORDER BY pid) as row_num_lat_lon,\\n           COUNT(*) OVER(PARTITION BY lat, lon) as count_lat_lon\\n    FROM Insurance\\n) l\\non t.pid = l.pid\\nWHERE l.count_lat_lon = 1 AND t.count_tiv > 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom Insurance I\\nLEFT JOIN (\\n    SELECT pid, tiv_2015,\\n           ROW_NUMBER() OVER(PARTITION BY tiv_2015 ORDER BY pid) as row_num_tiv,\\n           COUNT(*) OVER(PARTITION BY tiv_2015) as count_tiv\\n    FROM Insurance\\n) t ON I.pid = t.pid\\nLEFT JOIN (\\n    SELECT pid, lat, lon,\\n           ROW_NUMBER() OVER(PARTITION BY lat, lon ORDER BY pid) as row_num_lat_lon,\\n           COUNT(*) OVER(PARTITION BY lat, lon) as count_lat_lon\\n    FROM Insurance\\n) l\\non t.pid = l.pid\\nWHERE l.count_lat_lon = 1 AND t.count_tiv > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4073119,
                "title": "oracle-solution",
                "content": "\\u2757\\uFE0F**Please upvote if you find this solution useful**\\n\\n# Code\\n```\\nSELECT round(sum(tiv_2016), 2) AS tiv_2016\\nFROM insurance i1\\nWHERE i1.tiv_2015 IN (SELECT tiv_2015 FROM insurance i2 WHERE i2.pid != i1.pid)\\n  AND (i1.lat, i1.lon) NOT IN (SELECT i2.lat, i2.lon FROM insurance i2 WHERE i2.pid != i1.pid);\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSELECT round(sum(tiv_2016), 2) AS tiv_2016\\nFROM insurance i1\\nWHERE i1.tiv_2015 IN (SELECT tiv_2015 FROM insurance i2 WHERE i2.pid != i1.pid)\\n  AND (i1.lat, i1.lon) NOT IN (SELECT i2.lat, i2.lon FROM insurance i2 WHERE i2.pid != i1.pid);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4071155,
                "title": "super-simplified-solution-without-any-complex-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect round(sum(tiv_2016), 2) as tiv_2016 from insurance\\nwhere tiv_2015 IN\\n(select tiv_2015 from insurance group by tiv_2015 having count(*)>1)\\nAND (lat, lon) IN\\n(Select lat, lon from insurance group by lat, lon\\nhaving count(*) <2 )\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect round(sum(tiv_2016), 2) as tiv_2016 from insurance\\nwhere tiv_2015 IN\\n(select tiv_2015 from insurance group by tiv_2015 having count(*)>1)\\nAND (lat, lon) IN\\n(Select lat, lon from insurance group by lat, lon\\nhaving count(*) <2 )\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4062795,
                "title": "ms-sql-server-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nSELECT ROUND(SUM(tiv_2016), 2) AS tiv_2016\\nFROM (\\n    SELECT DISTINCT i1.tiv_2015, i1.tiv_2016\\n    FROM Insurance i1\\n    INNER JOIN (\\n        SELECT lat, lon\\n        FROM Insurance\\n        GROUP BY lat, lon\\n        HAVING COUNT(*) = 1\\n    ) AS unique_locations\\n    ON i1.lat = unique_locations.lat AND i1.lon = unique_locations.lon\\n    WHERE i1.tiv_2015 IN (\\n        SELECT tiv_2015\\n        FROM Insurance\\n        GROUP BY tiv_2015\\n        HAVING COUNT(*) > 1\\n    )\\n) AS PolicyholdersMeetingCriteria;\\n\\n\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT ROUND(SUM(tiv_2016), 2) AS tiv_2016\\nFROM (\\n    SELECT DISTINCT i1.tiv_2015, i1.tiv_2016\\n    FROM Insurance i1\\n    INNER JOIN (\\n        SELECT lat, lon\\n        FROM Insurance\\n        GROUP BY lat, lon\\n        HAVING COUNT(*) = 1\\n    ) AS unique_locations\\n    ON i1.lat = unique_locations.lat AND i1.lon = unique_locations.lon\\n    WHERE i1.tiv_2015 IN (\\n        SELECT tiv_2015\\n        FROM Insurance\\n        GROUP BY tiv_2015\\n        HAVING COUNT(*) > 1\\n    )\\n) AS PolicyholdersMeetingCriteria;\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4059716,
                "title": "cte-and-window-functions-beats-98-56",
                "content": "# Code\\n```\\n/* Write your T-SQL query statement below */\\nWITH tiv_cte AS (\\n    SELECT pid, tiv_2015, tiv_2016,\\n        count (pid) over (partition by tiv_2015) as cnt_tiv_2015, \\n        lat, lon, count(pid) over (partition by lat, lon) as cnt_city \\n    FROM Insurance\\n)\\nSELECT round(sum(tiv_2016),2) as tiv_2016\\nFROM tiv_cte\\nWHERE cnt_tiv_2015 > 1 and cnt_city = 1;\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nWITH tiv_cte AS (\\n    SELECT pid, tiv_2015, tiv_2016,\\n        count (pid) over (partition by tiv_2015) as cnt_tiv_2015, \\n        lat, lon, count(pid) over (partition by lat, lon) as cnt_city \\n    FROM Insurance\\n)\\nSELECT round(sum(tiv_2016),2) as tiv_2016\\nFROM tiv_cte\\nWHERE cnt_tiv_2015 > 1 and cnt_city = 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4051870,
                "title": "mysql-solution",
                "content": "# Code\\n```\\nwith t15 as (\\n    select tiv_2015 from Insurance\\n    group by tiv_2015\\n    having count(*) > 1\\n),\\nloc as (\\n    select concat(lat, lon) latlon from Insurance\\n    group by concat(lat, lon)\\n    having count(*) > 1\\n)\\nselect round(sum(tiv_2016), 2) as tiv_2016 \\nfrom Insurance\\nwhere (tiv_2015 IN (select * from t15)) and\\n        (concat(lat,lon) NOT IN (select * from loc))\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith t15 as (\\n    select tiv_2015 from Insurance\\n    group by tiv_2015\\n    having count(*) > 1\\n),\\nloc as (\\n    select concat(lat, lon) latlon from Insurance\\n    group by concat(lat, lon)\\n    having count(*) > 1\\n)\\nselect round(sum(tiv_2016), 2) as tiv_2016 \\nfrom Insurance\\nwhere (tiv_2015 IN (select * from t15)) and\\n        (concat(lat,lon) NOT IN (select * from loc))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4049633,
                "title": "simple-fast-solution-using-ctes",
                "content": "# Approach\\n- `Unique Places`This **CTE** selects `pid`where the combination of`lat`,`lon`occurs only once.\\n\\n- `unUNiquetiv_2015`This **CTE** selects tiv_2015 values that appear more than once in the table.\\n\\n- `PIDforunUNiquetiv_2015`This CTE to retrieve `pid` values for records where the `tiv_2015` value matches values obtained from the `Uniquetiv_2015`.\\n\\n- `Final Query`: In the final query, we calculate the sum of `tiv_2016` for records that meet **two conditions**: they have **unique combinations** of ***lat*** and ***lon*** (from the UniquePlaces CTE), and their pid values are found in the PIDforunUNiquetiv_2015 CTE.\\n\\n\\n\\n# Code\\n```\\nwith UNiquePlaces as (\\nSELECT pid\\nFROM Insurance \\nGROUP BY lat, lon\\nHAVING COUNT(*) = 1\\n\\n),\\nunUNiquetiv_2015 as(\\n          SELECT tiv_2015\\n        FROM Insurance\\n        GROUP BY tiv_2015\\n        HAVING COUNT(*) > 1\\n\\n),\\n\\n PIDforunUNiquetiv_2015 AS (\\n    SELECT pid\\n    FROM Insurance\\n    WHERE tiv_2015 IN (\\n      select tiv_2015 from unUNiquetiv_2015\\n    )\\n)\\n\\nSELECT round(sum(tiv_2016 ),2) as tiv_2016 \\nFROM Insurance\\nWHERE pid IN (SELECT pid FROM UNiquePlaces)\\n   and pid IN (SELECT pid FROM PIDforunUNiquetiv_2015);\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith UNiquePlaces as (\\nSELECT pid\\nFROM Insurance \\nGROUP BY lat, lon\\nHAVING COUNT(*) = 1\\n\\n),\\nunUNiquetiv_2015 as(\\n          SELECT tiv_2015\\n        FROM Insurance\\n        GROUP BY tiv_2015\\n        HAVING COUNT(*) > 1\\n\\n),\\n\\n PIDforunUNiquetiv_2015 AS (\\n    SELECT pid\\n    FROM Insurance\\n    WHERE tiv_2015 IN (\\n      select tiv_2015 from unUNiquetiv_2015\\n    )\\n)\\n\\nSELECT round(sum(tiv_2016 ),2) as tiv_2016 \\nFROM Insurance\\nWHERE pid IN (SELECT pid FROM UNiquePlaces)\\n   and pid IN (SELECT pid FROM PIDforunUNiquetiv_2015);\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4044836,
                "title": "easy-ms-sql-solution-using-exists-no-cte-complicated-joins-or-subqueries",
                "content": "# Approach\\n\\nUnfortunately there\\'s not a way to approach this without any type of subquery, but using `EXISTS` is a simple way to filter to the rows we want to sum up.\\n\\nThere are two separate conditions:\\n1) The 2015 investment matches at least one other policyholder\\'s investment. An `EXIST` statement is used to find those matches. This should offer better performance since as soon as a match is found for a row it stops checking (versus a subquery or `IN` that will look at the entire table)\\n2) The policyholder is not located in the same location as any other holder. This requires a second `WHERE` clause, this time `NOT EXISTS` but is the same principal as the first; if we find a match to the city, we can stop searching and exclude that policy from the total.\\n\\nFrom there it\\'s a simple SUM and then ROUND of the unfiltered 2016 investments.\\n\\n# Code\\n```\\nSELECT ROUND(SUM(ins.tiv_2016),2) AS tiv_2016\\nFROM Insurance ins\\nWHERE EXISTS (SELECT 1\\n              FROM Insurance ins2\\n              WHERE ins.tiv_2015 = ins2.tiv_2015 -- Matches 2015 of other policyholders\\n                AND ins.pid <> ins2.pid -- Is not the same policyholder\\n             )\\n  AND NOT EXISTS (SELECT 1\\n              FROM Insurance ins3\\n              WHERE ins.pid <> ins3.pid \\n                AND ins.lat = ins3.lat \\n                AND ins.lon = ins3.lon \\n             ) -- Does not match location of any other policy holder\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT ROUND(SUM(ins.tiv_2016),2) AS tiv_2016\\nFROM Insurance ins\\nWHERE EXISTS (SELECT 1\\n              FROM Insurance ins2\\n              WHERE ins.tiv_2015 = ins2.tiv_2015 -- Matches 2015 of other policyholders\\n                AND ins.pid <> ins2.pid -- Is not the same policyholder\\n             )\\n  AND NOT EXISTS (SELECT 1\\n              FROM Insurance ins3\\n              WHERE ins.pid <> ins3.pid \\n                AND ins.lat = ins3.lat \\n                AND ins.lon = ins3.lon \\n             ) -- Does not match location of any other policy holder\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4044053,
                "title": "optimizing-memory-usage-to-outperform-99-74-of-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution to this problem is to identify and filter the relevant policyholders based on these conditions. We can then calculate the sum of their `tiv_2016` values.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Convert the relevant columns `tiv_2015`, `lat`, `lon` to the `float32` data type using `astype()` to reduce memory usage.\\n2. Filter the DataFrame by:\\n    - Identifying policyholders with duplicate `tiv_2015` values using `duplicated()` and keeping only the duplicates.\\n    - Removing policyholders with `duplicate` `lat`, `lon` pairs using `duplicated()` and `~` (negation operator can be used to perform element-wise logical `NOT` operations on pandas Series or DataFrames.).\\n3. Calculate the sum of the `tiv_2016` values from the filtered DataFrame using `sum()`.\\n4. Return a new DataFrame with the sum of `tiv_2016` as the only column.\\n# Complexity\\n##### Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$, where $$n$$ is the number of elements or rows in the `insurance` DataFrame.*\\n\\n*Converting columns to the `float32` data type requires additional memory, but it is relatively small compared to the overall DataFrame size.\\n##### Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$, where $$n$$ is the number of elements or rows in the `insurance` DataFrame.\\n# Runtime & Memory\\n![Screenshot 2023-09-14 at 15.21.09.png](https://assets.leetcode.com/users/images/c9d11fed-52e0-4ee0-8524-8cc165866b2a_1694697700.353277.png)\\n\\n# Code\\n```\\nimport pandas as pd\\n\\n\\ndef find_investments(insurance: pd.DataFrame) -> pd.DataFrame:\\n    cols_to_float32 = [\"tiv_2015\", \"lat\", \"lon\"]\\n    insurance[cols_to_float32] = insurance[cols_to_float32].astype(\"float32\")\\n    filtered_df = insurance[\\n        insurance[\"tiv_2015\"].duplicated(keep=False)\\n        & ~insurance.duplicated(subset=[\"lat\", \"lon\"], keep=False)\\n    ]\\n    return pd.DataFrame({\"tiv_2016\": [filtered_df[\"tiv_2016\"].sum()]})\\n\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\n\\ndef find_investments(insurance: pd.DataFrame) -> pd.DataFrame:\\n    cols_to_float32 = [\"tiv_2015\", \"lat\", \"lon\"]\\n    insurance[cols_to_float32] = insurance[cols_to_float32].astype(\"float32\")\\n    filtered_df = insurance[\\n        insurance[\"tiv_2015\"].duplicated(keep=False)\\n        & ~insurance.duplicated(subset=[\"lat\", \"lon\"], keep=False)\\n    ]\\n    return pd.DataFrame({\"tiv_2016\": [filtered_df[\"tiv_2016\"].sum()]})\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4043826,
                "title": "simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nlat,lon needs to be grouped but question needs to be grouped by tiv_2015 as well.\\ni toke help of another solution submitted here.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ni too toke help of another solution submitted here.\\n\\nselected tiv_2016 and in where condition i concated lat, lon to make another field from where i can select rows of favorable condition.\\n\\nlater i also added condition where tiv_2015 is > 1 amd lastly i selected sum of tiv_2016.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom Insurance\\nwhere concat(lat,lon) in\\n                        (\\n                            select concat(lat,lon) from Insurance\\n                            group by lat,lon\\n                            having count(pid) = 1\\n                        )\\nand\\ntiv_2015 in \\n            (\\n                select tiv_2015 from Insurance\\n                group by tiv_2015 having count(pid) > 1\\n            )\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom Insurance\\nwhere concat(lat,lon) in\\n                        (\\n                            select concat(lat,lon) from Insurance\\n                            group by lat,lon\\n                            having count(pid) = 1\\n                        )\\nand\\ntiv_2015 in \\n            (\\n                select tiv_2015 from Insurance\\n                group by tiv_2015 having count(pid) > 1\\n            )\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4038366,
                "title": "just-sub-query",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT ROUND(SUM(tiv_2016),2) tiv_2016 FROM INSURANCE \\nWHERE tiv_2015 IN (SELECT tiv_2015 FROM INSURANCE \\nGROUP BY tiv_2015 HAVING COUNT(1)>1)\\nAND LAT||\\'-\\'||LON IN\\n(SELECT LAT||\\'-\\'||LON FROM INSURANCE \\nGROUP BY LAT||\\'-\\'||LON HAVING COUNT(1)=1);\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT ROUND(SUM(tiv_2016),2) tiv_2016 FROM INSURANCE \\nWHERE tiv_2015 IN (SELECT tiv_2015 FROM INSURANCE \\nGROUP BY tiv_2015 HAVING COUNT(1)>1)\\nAND LAT||\\'-\\'||LON IN\\n(SELECT LAT||\\'-\\'||LON FROM INSURANCE \\nGROUP BY LAT||\\'-\\'||LON HAVING COUNT(1)=1);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4037408,
                "title": "without-concat-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n/*WITH CTE AS (\\n    SELECT\\n        tiv_2015,tiv_2016 from Insurance where\\n       LAG(lat, 1) OVER () <> LEAD(lat, 1) OVER () and LAG(lon, 1) OVER () <> LEAD(lon, 1) OVER()\\n)\\nselect sum(tiv_2016) from CTE where tiv_2015 <> tiv_2016;*/\\nselect round(sum(tiv_2016),2) as tiv_2016 from Insurance i1 where i1.tiv_2015 in (select i2.tiv_2015 from Insurance i2 where i1.pid <> i2.pid) and (i1.lat,i1.lon) not in (select lat,lon from Insurance i3 where i1.pid <> i3.pid);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n/*WITH CTE AS (\\n    SELECT\\n        tiv_2015,tiv_2016 from Insurance where\\n       LAG(lat, 1) OVER () <> LEAD(lat, 1) OVER () and LAG(lon, 1) OVER () <> LEAD(lon, 1) OVER()\\n)\\nselect sum(tiv_2016) from CTE where tiv_2015 <> tiv_2016;*/\\nselect round(sum(tiv_2016),2) as tiv_2016 from Insurance i1 where i1.tiv_2015 in (select i2.tiv_2015 from Insurance i2 where i1.pid <> i2.pid) and (i1.lat,i1.lon) not in (select lat,lon from Insurance i3 where i1.pid <> i3.pid);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4035579,
                "title": "pandas-detailed-comments-boolean-indexing-solution",
                "content": "# Approach\\nTo solve this problem we should choose the efficient  and concise (or at least not horrible) way to peform multiple filtering operations to satisfy given conditions.\\n\\nBoolean Indexing does this just fine.\\n- Using `tuple(zip())` instead of `.apply()` saves A LOT of time\\n- Using Boolean Indexing instead of `.query()` is also way more efficient\\n\\n1. Create the new column \\'geo\\': `tuple` represeting the latitude and longitude for each policy holder for easier filtering.\\n2. Filter the DataFrame to satisfy the conditions.\\n3. Compute the sum of `\\'tiv_2016\\'` for the filtered rows, as required.\\n4. Construct and return the DataFrame with solution.\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef find_investments(insurance: pd.DataFrame) -> pd.DataFrame:\\n    insurance[\\'geo\\'] = tuple(zip(insurance[\\'lat\\'], insurance[\\'lon\\']))\\n\\n    # Find rows with duplicate \\'tiv_2015\\' values but unique \\'geo\\' values\\n    filtered_insurance = insurance[insurance.duplicated(subset=[\\'tiv_2015\\'], keep=False) & \\\\\\n                                  ~insurance.duplicated(subset=[\\'geo\\']     , keep=False)]\\n\\n    # Calculate the sum of \\'tiv_2016\\' for the filtered rows\\n    sum_tiv2016 = filtered_insurance[\\'tiv_2016\\'].sum()\\n\\n    # Create a DataFrame for the result\\n    ans = pd.DataFrame(data=[sum_tiv2016], columns=[\\'tiv_2016\\'])\\n\\n    return ans\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef find_investments(insurance: pd.DataFrame) -> pd.DataFrame:\\n    insurance[\\'geo\\'] = tuple(zip(insurance[\\'lat\\'], insurance[\\'lon\\']))\\n\\n    # Find rows with duplicate \\'tiv_2015\\' values but unique \\'geo\\' values\\n    filtered_insurance = insurance[insurance.duplicated(subset=[\\'tiv_2015\\'], keep=False) & \\\\\\n                                  ~insurance.duplicated(subset=[\\'geo\\']     , keep=False)]\\n\\n    # Calculate the sum of \\'tiv_2016\\' for the filtered rows\\n    sum_tiv2016 = filtered_insurance[\\'tiv_2016\\'].sum()\\n\\n    # Create a DataFrame for the result\\n    ans = pd.DataFrame(data=[sum_tiv2016], columns=[\\'tiv_2016\\'])\\n\\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4034476,
                "title": "easy-to-understand-subquery-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect round(sum(c.tiv_2016), 2) as tiv_2016\\nfrom\\n(\\n  select a.pid, a.tiv_2016\\n  from Insurance a,  insurance b\\n  where  a.pid <> b.pid\\n  and  a.tiv_2015 = b.tiv_2015\\n  and a.pid not in\\n  (\\n      select  distinct i.pid\\n      from Insurance i,  insurance j \\n      where  i.pid <> j.pid \\n      and i.lat = j.lat and i.lon=j.lon\\n  )\\n  group by 1\\n  )c\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect round(sum(c.tiv_2016), 2) as tiv_2016\\nfrom\\n(\\n  select a.pid, a.tiv_2016\\n  from Insurance a,  insurance b\\n  where  a.pid <> b.pid\\n  and  a.tiv_2015 = b.tiv_2015\\n  and a.pid not in\\n  (\\n      select  distinct i.pid\\n      from Insurance i,  insurance j \\n      where  i.pid <> j.pid \\n      and i.lat = j.lat and i.lon=j.lon\\n  )\\n  group by 1\\n  )c\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4033888,
                "title": "easy-solution-beats-91-97",
                "content": "# Intuition\\nFirstly, we want to get those records that don\\'t have same lat or long so we count lat and lon, so that those records with count=1 are only considered.\\nSecondly, we want to get records that have count(tiv_2015)<>1 because those are the policyholders that have same tiv_2015 as other policyholders.\\nThen we sum tiv_2016 based on above 2 conditions.\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON,lat) AS LONG, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND LONG=1\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON,lat) AS LONG, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND LONG=1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4030652,
                "title": "easy-and-efficient-solution-2-approaches",
                "content": "# Code\\n```\\n/* Write your PL/SQL query statement below */\\n--Approach 1: Just using Count \\nwith cte1 as (\\nselect pid,\\ntiv_2015 ,\\ncount(tiv_2015) over(partition by tiv_2015) as cnt15\\n,tiv_2016 \\n,lat||\\',\\'||lon as latlon\\n,count(lat||\\',\\'||lon) over(partition by lat||\\',\\'||lon) as cnt\\nfrom Insurance)\\nselect round(sum(tiv_2016),2) as tiv_2016 from cte1 where cnt15 > 1 and cnt = 1\\n\\n--Approach 2: Using Self join\\nwith cte as (\\nselect distinct i1.* \\nfrom insurance i1 join insurance i2 on i1.tiv_2015 = i2.tiv_2015 and i1.lat <> i2.lat and i1.lon <> i2.lon)\\nselect round(sum(tiv_2016),2) as tiv_2016 from cte where not exists (select 1 from insurance i1 where cte.pid <> i1.pid and cte.lat = i1.lat and cte.lon = i1.lon ) order by 1 \\n\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\n--Approach 1: Just using Count \\nwith cte1 as (\\nselect pid,\\ntiv_2015 ,\\ncount(tiv_2015) over(partition by tiv_2015) as cnt15\\n,tiv_2016 \\n,lat||\\',\\'||lon as latlon\\n,count(lat||\\',\\'||lon) over(partition by lat||\\',\\'||lon) as cnt\\nfrom Insurance)\\nselect round(sum(tiv_2016),2) as tiv_2016 from cte1 where cnt15 > 1 and cnt = 1\\n\\n--Approach 2: Using Self join\\nwith cte as (\\nselect distinct i1.* \\nfrom insurance i1 join insurance i2 on i1.tiv_2015 = i2.tiv_2015 and i1.lat <> i2.lat and i1.lon <> i2.lon)\\nselect round(sum(tiv_2016),2) as tiv_2016 from cte where not exists (select 1 from insurance i1 where cte.pid <> i1.pid and cte.lat = i1.lat and cte.lon = i1.lon ) order by 1 \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4030181,
                "title": "ms-sql-left-join-exists-round",
                "content": "# Code\\n```\\nSELECT\\n    ROUND(SUM(i.tiv_2016), 2) AS tiv_2016\\nFROM\\n    Insurance i\\n        LEFT JOIN Insurance place\\n        ON i.pid != place.pid\\n            AND i.lat = place.lat\\n            AND i.lon = place.lon\\nWHERE\\n    place.pid IS NULL\\n    AND EXISTS(SELECT\\n                *\\n            FROM\\n                Insurance tiv\\n            WHERE\\n                i.pid != tiv.pid\\n                AND i.tiv_2015 = tiv.tiv_2015)\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT\\n    ROUND(SUM(i.tiv_2016), 2) AS tiv_2016\\nFROM\\n    Insurance i\\n        LEFT JOIN Insurance place\\n        ON i.pid != place.pid\\n            AND i.lat = place.lat\\n            AND i.lon = place.lon\\nWHERE\\n    place.pid IS NULL\\n    AND EXISTS(SELECT\\n                *\\n            FROM\\n                Insurance tiv\\n            WHERE\\n                i.pid != tiv.pid\\n                AND i.tiv_2015 = tiv.tiv_2015)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4028987,
                "title": "oracle-solution-using-windows-functions-913-ms-98-92-faster",
                "content": "SELECT \\n    SUM(tiv_2016) AS tiv_2016\\nFROM (\\n    SELECT \\n        tiv_2016, \\n        COUNT(*) OVER (PARTITION BY tiv_2015) AS same,\\n        COUNT(*) OVER (PARTITION BY lat, lon) AS uniq\\n    FROM insurance\\n)\\nWHERE same > 1\\n    AND uniq = 1;",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "SELECT \\n    SUM(tiv_2016) AS tiv_2016\\nFROM (\\n    SELECT \\n        tiv_2016, \\n        COUNT(*) OVER (PARTITION BY tiv_2015) AS same,\\n        COUNT(*) OVER (PARTITION BY lat, lon) AS uniq\\n    FROM insurance\\n)\\nWHERE same > 1\\n    AND uniq = 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 4026017,
                "title": "mysql-easy-solution-using-sub-query",
                "content": "\\n\\n# Code\\n```\\nSELECT ROUND(SUM(tiv_2016), 2) AS \\'TIV_2016\\'\\nFROM insurance i1\\nWHERE i1.tiv_2015 IN (SELECT i2.tiv_2015 FROM insurance i2 WHERE i1.pid != i2.pid)\\nAND (i1.lat, i1.lon) NOT IN (SELECT lat, lon FROM insurance i3 where i1.pid != i3.pid);\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nSELECT ROUND(SUM(tiv_2016), 2) AS \\'TIV_2016\\'\\nFROM insurance i1\\nWHERE i1.tiv_2015 IN (SELECT i2.tiv_2015 FROM insurance i2 WHERE i1.pid != i2.pid)\\nAND (i1.lat, i1.lon) NOT IN (SELECT lat, lon FROM insurance i3 where i1.pid != i3.pid);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4025829,
                "title": "window-partitions-simple-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Group the location and eliminate the items with total count more than 1 from the same location\\n2. Group the first years(2015) same value counts and eliminate single items\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWindow partition can be the best approachwhich can be faster\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom (select *, \\ncount(*) over(partition by tiv_2015) as cnt_2015,\\ncount(*) over(partition by concat(lat,lon)) as cnt_loc \\nfrom Insurance)a\\nwhere cnt_loc = 1 and cnt_2015 > 1 ;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom (select *, \\ncount(*) over(partition by tiv_2015) as cnt_2015,\\ncount(*) over(partition by concat(lat,lon)) as cnt_loc \\nfrom Insurance)a\\nwhere cnt_loc = 1 and cnt_2015 > 1 ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4023882,
                "title": "mysql-detailed-explaination-intersect-subquery-cte",
                "content": "\\n# Approach using Intersect and sub-query\\n\\nIn this SQL problem, we are tasked with calculating the sum of total investment values in 2016 (`tiv_2016`) for policyholders who meet specific criteria. The criteria are as follows:\\n\\n1. Policyholders must have the same `tiv_2015` value as one or more other policyholders.\\n2. Policyholders must not be located in the same city as any other policyholder. (City locations are determined by unique `(lat, lon)` pairs.)\\n\\nLet\\'s break down the problem step by step and explore the SQL query that accomplishes this task:\\n\\n```sql\\nSELECT ROUND(SUM(tiv_2016), 2) AS tiv_2016\\nFROM Insurance\\nWHERE pid IN (\\n    SELECT pid\\n    FROM Insurance\\n    WHERE tiv_2015 IN (\\n        SELECT tiv_2015\\n        FROM Insurance\\n        GROUP BY tiv_2015\\n        HAVING COUNT(pid) > 1\\n    )\\n    INTERSECT\\n    SELECT pid\\n    FROM Insurance\\n    GROUP BY lat, lon\\n    HAVING COUNT(pid) = 1\\n);\\n```\\n\\n**Explanation:**\\n\\n1. We start with the outermost query, where we calculate the sum of `tiv_2016` for policyholders who meet the criteria. The `ROUND` function is used to round the result to two decimal places.\\n\\n2. We use a subquery to identify policyholders who meet the first criteria:\\n   - In the first subquery, we select `pid` values from the `Insurance` table where `tiv_2015` matches the `tiv_2015` values of other policyholders. We do this by grouping by `tiv_2015` and selecting those with a count greater than 1.\\n\\n3. We use the `INTERSECT` operator to find the common `pid` values between the two subqueries:\\n   - The first subquery identifies policyholders with the same `tiv_2015` value as others.\\n   - The second subquery identifies policyholders with unique `(lat, lon)` pairs, indicating they are not located in the same city as any other policyholder.\\n\\n4. Finally, we sum the `tiv_2016` values for the selected policyholders who meet both criteria.\\n\\n\\n\\nCertainly! Here\\'s the post with an alternate approach using window functions:\\n\\n---\\n## Approach Using Window Functions\\n\\nTo achieve this, we can utilize SQL window functions to calculate the counts of policyholders with the same `tiv_2015` value and the counts of policyholders sharing the same `(lat, lon)` coordinates.\\n\\nHere\\'s the SQL query for this approach:\\n\\n```sql\\nSELECT ROUND(SUM(tiv_2016), 2) AS tiv_2016\\nFROM (\\n    SELECT *,\\n        COUNT(*) OVER (PARTITION BY tiv_2015) AS tiv_2015_count,\\n        COUNT(*) OVER (PARTITION BY lat, lon) AS coordinates_count\\n    FROM Insurance\\n) AS TBL\\nWHERE tiv_2015_count > 1 AND coordinates_count = 1;\\n```\\n\\n**Explanation:**\\n\\n1. We start by selecting all columns from the `Insurance` table within a subquery (labeled as `TBL`).\\n\\n2. Inside the subquery, we use two window functions:\\n   - `tiv_2015_count`: This function counts the number of policyholders who share the same `tiv_2015` value as the current row.\\n   - `coordinates_count`: This function counts the number of policyholders with the same `(lat, lon)` coordinates.\\n\\n3. In the outer query, we filter the results from the subquery based on the specified conditions:\\n   - `tiv_2015_count > 1`: We select rows where the `tiv_2015_count` is greater than 1, indicating that other policyholders have the same `tiv_2015` value.\\n   - `coordinates_count = 1`: We include rows where the `coordinates_count` is equal to 1, indicating that the policyholder has unique `(lat, lon)` coordinates and is not located in the same city as any other policyholder.\\n\\n4. Finally, we calculate the sum of `tiv_2016` for the selected policyholders and round the result to two decimal places.\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```sql\\nSELECT ROUND(SUM(tiv_2016), 2) AS tiv_2016\\nFROM Insurance\\nWHERE pid IN (\\n    SELECT pid\\n    FROM Insurance\\n    WHERE tiv_2015 IN (\\n        SELECT tiv_2015\\n        FROM Insurance\\n        GROUP BY tiv_2015\\n        HAVING COUNT(pid) > 1\\n    )\\n    INTERSECT\\n    SELECT pid\\n    FROM Insurance\\n    GROUP BY lat, lon\\n    HAVING COUNT(pid) = 1\\n);\\n```\n```sql\\nSELECT ROUND(SUM(tiv_2016), 2) AS tiv_2016\\nFROM (\\n    SELECT *,\\n        COUNT(*) OVER (PARTITION BY tiv_2015) AS tiv_2015_count,\\n        COUNT(*) OVER (PARTITION BY lat, lon) AS coordinates_count\\n    FROM Insurance\\n) AS TBL\\nWHERE tiv_2015_count > 1 AND coordinates_count = 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4016514,
                "title": "beautiful-and-neat-solusion-with-window-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT ROUND(SUM(tiv_2016),2) tiv_2016\\nFROM(\\nSELECT pid,tiv_2016, COUNT(pid) OVER(PARTITION BY tiv_2015) cnt_2015,\\nCOUNT(pid) OVER(PARTITION BY lat, lon) cnt_loc\\nFROM Insurance) A\\nWHERE cnt_2015 >1 AND cnt_loc = 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT ROUND(SUM(tiv_2016),2) tiv_2016\\nFROM(\\nSELECT pid,tiv_2016, COUNT(pid) OVER(PARTITION BY tiv_2015) cnt_2015,\\nCOUNT(pid) OVER(PARTITION BY lat, lon) cnt_loc\\nFROM Insurance) A\\nWHERE cnt_2015 >1 AND cnt_loc = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013751,
                "title": "basic",
                "content": "\\n# Code\\n```\\nSELECT round(sum(tiv_2016),2) as tiv_2016 \\nFROM insurance \\nWHERE \\ntiv_2015 IN (SELECT tiv_2015 FROM insurance group by tiv_2015 HAVING COUNT(*)>1) \\nAND\\n(lat,lon) NOT IN (SELECT lat , lon FROM insurance group by lat,lon HAVING COUNT(*)>1)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT round(sum(tiv_2016),2) as tiv_2016 \\nFROM insurance \\nWHERE \\ntiv_2015 IN (SELECT tiv_2015 FROM insurance group by tiv_2015 HAVING COUNT(*)>1) \\nAND\\n(lat,lon) NOT IN (SELECT lat , lon FROM insurance group by lat,lon HAVING COUNT(*)>1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013065,
                "title": "with-having-and-case",
                "content": "```\\nselect ifnull(round(sum(tiv_2016),2),0) as tiv_2016 from \\n(\\n\\n# Write your MySQL query statement below\\nselect distinct i1.pid , i1.tiv_2016 from insurance i1 \\nleft join insurance i2 \\non i1.lat != i2.lat and i1.lon != i2.lon where\\n i1.tiv_2015 = i2.tiv_2015 \\nand case when i1.pid in \\n(\\nselect pid from \\n(\\nwith a \\nas\\n(\\n     # Write your MySQL query statement below\\nselect distinct i1.pid , i2.tiv_2016 from insurance i1 \\ninner join insurance i2 \\non i1.lat = i2.lat and i1.lon = i2.lon \\ngroup by 1 \\nhaving count(i1.lat) >= 2 and count(i1.lon) >= 2\\n)\\nselect pid from a \\n) l1\\n)  then 0 else 1 end \\n) l2 \\n```",
                "solutionTags": [],
                "code": "```\\nselect ifnull(round(sum(tiv_2016),2),0) as tiv_2016 from \\n(\\n\\n# Write your MySQL query statement below\\nselect distinct i1.pid , i1.tiv_2016 from insurance i1 \\nleft join insurance i2 \\non i1.lat != i2.lat and i1.lon != i2.lon where\\n i1.tiv_2015 = i2.tiv_2015 \\nand case when i1.pid in \\n(\\nselect pid from \\n(\\nwith a \\nas\\n(\\n     # Write your MySQL query statement below\\nselect distinct i1.pid , i2.tiv_2016 from insurance i1 \\ninner join insurance i2 \\non i1.lat = i2.lat and i1.lon = i2.lon \\ngroup by 1 \\nhaving count(i1.lat) >= 2 and count(i1.lon) >= 2\\n)\\nselect pid from a \\n) l1\\n)  then 0 else 1 end \\n) l2 \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4011328,
                "title": "super-easy-approach-beats-97-63",
                "content": "# Intuition\\r\\n![upvote.png](https://assets.leetcode.com/users/images/474cef25-26f2-4c2b-976a-edc439a5060b_1694027724.026928.png)\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\nWITH tiv_2015Duplicates \\r\\nAS\\r\\n(\\r\\n    SELECT tiv_2015\\r\\n    FROM Insurance\\r\\n    GROUP BY tiv_2015\\r\\n    HAVING COUNT(*) > 1\\r\\n),\\r\\nlat_lonDuplicates\\r\\nAS\\r\\n(\\r\\n    SELECT lat, lon\\r\\n    FROM Insurance \\r\\n    GROUP BY lat, lon\\r\\n    HAVING COUNT(*) = 1\\r\\n)\\r\\nSELECT ROUND(SUM(tiv_2016), 2) AS tiv_2016\\r\\nFROM Insurance I\\r\\nJOIN lat_lonDuplicates l\\r\\nON I.lat = l.lat AND I.lon = l.lon\\r\\nWHERE I.tiv_2015 IN (SELECT tiv_2015 FROM tiv_2015Duplicates)\\r\\n\\r\\n\\r\\n\\r\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\nWITH tiv_2015Duplicates \\r\\nAS\\r\\n(\\r\\n    SELECT tiv_2015\\r\\n    FROM Insurance\\r\\n    GROUP BY tiv_2015\\r\\n    HAVING COUNT(*) > 1\\r\\n),\\r\\nlat_lonDuplicates\\r\\nAS\\r\\n(\\r\\n    SELECT lat, lon\\r\\n    FROM Insurance \\r\\n    GROUP BY lat, lon\\r\\n    HAVING COUNT(*) = 1\\r\\n)\\r\\nSELECT ROUND(SUM(tiv_2016), 2) AS tiv_2016\\r\\nFROM Insurance I\\r\\nJOIN lat_lonDuplicates l\\r\\nON I.lat = l.lat AND I.lon = l.lon\\r\\nWHERE I.tiv_2015 IN (SELECT tiv_2015 FROM tiv_2015Duplicates)\\r\\n\\r\\n\\r\\n\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4010427,
                "title": "clear-easy-sql-step-by-step-correct-formatting-comprehensive-explanation",
                "content": "# \\u2757 Upvote \\u2B06 if you found this useful \\u2714\\n\\nMySQL solution for **585. Investments in 2016** Problem. \\n\\n![image.png](https://assets.leetcode.com/users/images/4b1d3937-b51e-403e-a9b5-6bf85aae0979_1694014177.0987067.png)\\n\\n\\n# \\uD83D\\uDCA1 Intuition (hint)\\n\\nThis problem is harder to understand than to solved. Can be conquered with CTEs or subqueries and simple filters using WHERE. \\n\\n# \\uD83C\\uDFAF Approach (solution)\\n\\nIn this solution we will use three-level query. \\n\\nGoing from the lowest level, we have two subqueries that are used later to search for *pid* that meets both conditions. \\n\\n**Query 1** - simple query that finds all *tiv_2015* that occur more than once in the table (are not unique)\\n```sql\\nSELECT tiv_2015\\nFROM Insurance\\nGROUP BY tiv_2015\\nHAVING COUNT(tiv_2015) > 1\\n```\\n\\n**Query 2** - simple query that finds all combination of *lat* and *con* that occur exactly once in the table (are unique).\\nCONCAT is used to combine both *lat* and *con* into one field. \\n```sql\\nSELECT CONCAT(lat, \\'+\\', lon)\\nFROM Insurance\\nGROUP BY CONCAT(lat, \\'+\\', lon)\\nHAVING COUNT(CONCAT(lat, \\'+\\', lon)) = 1\\n```\\n\\nThe **middle query** consists of a query that looks for *pid* that meets 2 conditions:\\n1. *tiv_2015* is present in list of non-unique *tiv_2015*\\n2. *CONCAT(lat, \\'+\\', lon)* is present in list of unique *CONCAT(lat, \\'+\\', lon)*\\n```sql\\n    SELECT pid\\n    FROM Insurance\\n    WHERE \\n        tiv_2015 IN (**Query 1**)\\n        AND CONCAT(lat, \\'+\\', lon) IN (**Query 2**)\\n```\\n\\nThe highest level query just calculates the SUM of all *tiv_2016* for all *pid* that are filtered in the **middle query**\\n```sql\\nSELECT ROUND(SUM(tiv_2016), 2) AS tiv_2016\\nFROM Insurance\\nWHERE pid IN (**middle query**)\\n```\\n# \\uD83D\\uDCC8 Complexity\\n\\n- \\u23F1 Time complexity:\\nBeats 76% of solutions with MySQL (at the time of submission)\\n\\n- \\uD83D\\uDCBE Space complexity:\\nBeats 100% of solutions with MySQL (space complexity in case of this problem is constant for all solutions)\\n\\n# \\uD83D\\uDD25 Code\\n\\n```sql\\nSELECT ROUND(SUM(tiv_2016), 2) AS tiv_2016\\nFROM Insurance\\nWHERE pid IN (\\n    SELECT pid\\n    FROM Insurance\\n    WHERE \\n        tiv_2015 IN (\\n            SELECT tiv_2015\\n            FROM Insurance\\n            GROUP BY tiv_2015\\n            HAVING COUNT(tiv_2015) > 1\\n    )\\n        AND CONCAT(lat, \\'+\\', lon) IN (\\n            SELECT CONCAT(lat, \\'+\\', lon)\\n            FROM Insurance\\n            GROUP BY CONCAT(lat, \\'+\\', lon)\\n            HAVING COUNT(CONCAT(lat, \\'+\\', lon)) = 1\\n    )\\n);\\n```\\n# \\u2757 Upvote \\u2B06 if you found this useful \\u2714",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```sql\\nSELECT tiv_2015\\nFROM Insurance\\nGROUP BY tiv_2015\\nHAVING COUNT(tiv_2015) > 1\\n```\n```sql\\nSELECT CONCAT(lat, \\'+\\', lon)\\nFROM Insurance\\nGROUP BY CONCAT(lat, \\'+\\', lon)\\nHAVING COUNT(CONCAT(lat, \\'+\\', lon)) = 1\\n```\n```sql\\n    SELECT pid\\n    FROM Insurance\\n    WHERE \\n        tiv_2015 IN (**Query 1**)\\n        AND CONCAT(lat, \\'+\\', lon) IN (**Query 2**)\\n```\n```sql\\nSELECT ROUND(SUM(tiv_2016), 2) AS tiv_2016\\nFROM Insurance\\nWHERE pid IN (**middle query**)\\n```\n```sql\\nSELECT ROUND(SUM(tiv_2016), 2) AS tiv_2016\\nFROM Insurance\\nWHERE pid IN (\\n    SELECT pid\\n    FROM Insurance\\n    WHERE \\n        tiv_2015 IN (\\n            SELECT tiv_2015\\n            FROM Insurance\\n            GROUP BY tiv_2015\\n            HAVING COUNT(tiv_2015) > 1\\n    )\\n        AND CONCAT(lat, \\'+\\', lon) IN (\\n            SELECT CONCAT(lat, \\'+\\', lon)\\n            FROM Insurance\\n            GROUP BY CONCAT(lat, \\'+\\', lon)\\n            HAVING COUNT(CONCAT(lat, \\'+\\', lon)) = 1\\n    )\\n);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4009754,
                "title": "mysql-ez-to-understand-2-subqueries",
                "content": "# Intuition\\n- Find all non unique values in tiv_2015 field \\n- Find all unique pairs in lat, lon fields\\n- Use the above resulst as subqueries for filtering\\n- Find sum\\n- You are perfect!\\n\\n# Code for first filter\\n\\n```\\nselect tiv_2015\\nfrom Insurance\\ngroup by tiv_2015 having count(*) > 1\\n```\\n# Code for second filter\\n\\n```\\nselect lat, lon\\nfrom Insurance\\ngroup by lat, lon having count(*) = 1\\n\\n```\\n# Final code\\n```\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom Insurance\\nwhere tiv_2015 in (select tiv_2015\\n  from Insurance\\n  group by tiv_2015 having count(*) > 1) \\nand \\n  (lat, lon) in (select lat, lon\\n  from Insurance\\n  group by lat, lon having count(*) = 1)\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect tiv_2015\\nfrom Insurance\\ngroup by tiv_2015 having count(*) > 1\\n```\n```\\nselect lat, lon\\nfrom Insurance\\ngroup by lat, lon having count(*) = 1\\n\\n```\n```\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom Insurance\\nwhere tiv_2015 in (select tiv_2015\\n  from Insurance\\n  group by tiv_2015 having count(*) > 1) \\nand \\n  (lat, lon) in (select lat, lon\\n  from Insurance\\n  group by lat, lon having count(*) = 1)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4009647,
                "title": "solution-if-you-forgot-pandas-functions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStoring whether condition is met or not in an Array on N size \\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef find_investments(insurance: pd.DataFrame) -> pd.DataFrame:\\n    tiv = insurance[\"tiv_2015\"]\\n    n = len(tiv)\\n    condition1 = [False]*n\\n    for i in range(n):\\n        for j in range(n):\\n            if(i!=j and tiv[i]==tiv[j]):\\n                condition1[i]=True\\n    \\n    condition2 = [True]*n\\n    location = []\\n    i=0\\n    print(n)\\n    for i in range(n):\\n        location.append(str(insurance[\"lat\"][i]) + \"|\" + str(insurance[\"lon\"][i]))\\n\\n    for i in range(n):\\n        for j in range(n):\\n            if(i!=j and location[i]==location[j]):\\n                condition2[i]=False\\n    \\n    insurance[\"condition1\"]=condition1\\n    insurance[\"condition2\"]=condition2\\n\\n    result = []\\n    result.append(insurance[(insurance[\"condition1\"] == True) & (insurance[\"condition2\"] == True)][\"tiv_2016\"].sum())\\n    print(result)\\n    return pd.DataFrame(result,columns = [\"tiv_2016\"])\\n    \\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef find_investments(insurance: pd.DataFrame) -> pd.DataFrame:\\n    tiv = insurance[\"tiv_2015\"]\\n    n = len(tiv)\\n    condition1 = [False]*n\\n    for i in range(n):\\n        for j in range(n):\\n            if(i!=j and tiv[i]==tiv[j]):\\n                condition1[i]=True\\n    \\n    condition2 = [True]*n\\n    location = []\\n    i=0\\n    print(n)\\n    for i in range(n):\\n        location.append(str(insurance[\"lat\"][i]) + \"|\" + str(insurance[\"lon\"][i]))\\n\\n    for i in range(n):\\n        for j in range(n):\\n            if(i!=j and location[i]==location[j]):\\n                condition2[i]=False\\n    \\n    insurance[\"condition1\"]=condition1\\n    insurance[\"condition2\"]=condition2\\n\\n    result = []\\n    result.append(insurance[(insurance[\"condition1\"] == True) & (insurance[\"condition2\"] == True)][\"tiv_2016\"].sum())\\n    print(result)\\n    return pd.DataFrame(result,columns = [\"tiv_2016\"])\\n    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4009400,
                "title": "oracle-solution",
                "content": "# Intuition\\nIn my case I had to create two subqueries, since it looks like mostly simple to understand.\\n\\n# Approach\\n1) Find unique locations described in \"subq1\"\\n2) Find not unique TIVs, to filter it descripted in \"subq2\". By the way, without \"subq2\" in test case will be PASS, however in Submit you\\'ll get error in Case 1\\n3) Inner join subq1-2 and get sum\\n\\n# Code\\n```\\nselect round(sum(i.tiv_2016), 2) as tiv_2016\\nfrom Insurance i\\n         join (select lat || \\'.\\' || lon merged\\n               from Insurance\\n               group by lat || \\'.\\' || lon\\n               having count(lat || \\'.\\' || lon) = 1) subq1\\n                        on i.lat || \\'.\\' || i.lon = subq1.merged\\n         join (select tiv_2015\\n               from Insurance\\n               group by tiv_2015\\n               having count(tiv_2015) != 1) subq2\\n                        on i.tiv_2015 = subq2.tiv_2015\\n```\\n\\nP.s. It is my first solution",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nselect round(sum(i.tiv_2016), 2) as tiv_2016\\nfrom Insurance i\\n         join (select lat || \\'.\\' || lon merged\\n               from Insurance\\n               group by lat || \\'.\\' || lon\\n               having count(lat || \\'.\\' || lon) = 1) subq1\\n                        on i.lat || \\'.\\' || i.lon = subq1.merged\\n         join (select tiv_2015\\n               from Insurance\\n               group by tiv_2015\\n               having count(tiv_2015) != 1) subq2\\n                        on i.tiv_2015 = subq2.tiv_2015\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4009250,
                "title": "solution-using-ctes",
                "content": "\\n# Approach\\n1. Find out pid of unique city based on`lat`, `lon`.\\n2. Find out pid whose`tiv_2015` is same.\\n3. Inner join both CTEs based on pids and then add the `tiv_2016`\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nWith UniqueCity As\\n(\\n        Select pid, tiv_2016\\n        From Insurance\\n        Group by lat,lon\\n        Having count(lat) = 1 and count(lon) = 1\\n),\\n\\nSametiv as\\n(\\n        Select distinct i1.pid\\n        From Insurance as i1\\n        Inner join Insurance as i2\\n        on i1.pid != i2.pid\\n        Where i1.tiv_2015 = i2.tiv_2015\\n        order by i1.pid\\n)\\n\\nSelect round(sum(UniqueCity.tiv_2016), 2) as tiv_2016\\nFrom UniqueCity\\nInner join Sametiv\\non UniqueCity.pid = Sametiv.pid;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nWith UniqueCity As\\n(\\n        Select pid, tiv_2016\\n        From Insurance\\n        Group by lat,lon\\n        Having count(lat) = 1 and count(lon) = 1\\n),\\n\\nSametiv as\\n(\\n        Select distinct i1.pid\\n        From Insurance as i1\\n        Inner join Insurance as i2\\n        on i1.pid != i2.pid\\n        Where i1.tiv_2015 = i2.tiv_2015\\n        order by i1.pid\\n)\\n\\nSelect round(sum(UniqueCity.tiv_2016), 2) as tiv_2016\\nFrom UniqueCity\\nInner join Sametiv\\non UniqueCity.pid = Sametiv.pid;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4008257,
                "title": "investments-in-2016",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT ROUND(SUM(tiv_2016),2) AS tiv_2016\\nFROM Insurance\\nWHERE tiv_2015 IN (\\n    SELECT tiv_2015 FROM Insurance\\n    GROUP BY tiv_2015\\n    HAVING COUNT(*)!=1\\n)\\nAND (lat,lon) IN (\\n    SELECT lat,lon FROM Insurance\\n    GROUP BY lat, lon\\n    HAVING COUNT(*)=1\\n)\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT ROUND(SUM(tiv_2016),2) AS tiv_2016\\nFROM Insurance\\nWHERE tiv_2015 IN (\\n    SELECT tiv_2015 FROM Insurance\\n    GROUP BY tiv_2015\\n    HAVING COUNT(*)!=1\\n)\\nAND (lat,lon) IN (\\n    SELECT lat,lon FROM Insurance\\n    GROUP BY lat, lon\\n    HAVING COUNT(*)=1\\n)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4007404,
                "title": "mysql-solution-using-ctes",
                "content": "# Approach\\n* Find the unique lat and lon combinations.\\n* Find shared tiv_2015 instances.\\n* Join them to the main table for filtering.\\n\\n# Code\\n```\\nWITH lat_lon AS(\\n    SELECT CONCAT(lat, lon) AS place FROM Insurance\\n),\\nuniq_places AS (\\n    SELECT\\n        place,\\n        COUNT(place) AS place_count\\n    FROM lat_lon\\n    GROUP BY 1\\n    HAVING place_count = 1\\n),\\nshared_tiv_2015 AS (\\n    SELECT\\n        tiv_2015,\\n        COUNT(tiv_2015) AS tiv2015_count\\n    FROM Insurance\\n    GROUP BY 1\\n    HAVING tiv2015_count > 1\\n)\\nSELECT ROUND(SUM(i.tiv_2016), 2) AS tiv_2016\\nFROM Insurance AS i\\nJOIN uniq_places AS u on u.place = CONCAT(i.lat, i.lon)\\nJOIN shared_tiv_2015 USING (tiv_2015);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nWITH lat_lon AS(\\n    SELECT CONCAT(lat, lon) AS place FROM Insurance\\n),\\nuniq_places AS (\\n    SELECT\\n        place,\\n        COUNT(place) AS place_count\\n    FROM lat_lon\\n    GROUP BY 1\\n    HAVING place_count = 1\\n),\\nshared_tiv_2015 AS (\\n    SELECT\\n        tiv_2015,\\n        COUNT(tiv_2015) AS tiv2015_count\\n    FROM Insurance\\n    GROUP BY 1\\n    HAVING tiv2015_count > 1\\n)\\nSELECT ROUND(SUM(i.tiv_2016), 2) AS tiv_2016\\nFROM Insurance AS i\\nJOIN uniq_places AS u on u.place = CONCAT(i.lat, i.lon)\\nJOIN shared_tiv_2015 USING (tiv_2015);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4007381,
                "title": "one-line-solution",
                "content": "Enjoy\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef find_investments(insurance: pd.DataFrame) -> pd.DataFrame:\\n    t = insurance[~insurance.duplicated(subset=[\\'lat\\', \\'lon\\'], keep=False)&\\\\\\n                         insurance.duplicated(subset=\\'tiv_2015\\', keep=False)]\\n\\n    return pd.DataFrame({\\'tiv_2016\\': [t.tiv_2016.sum()]})\\n    \\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef find_investments(insurance: pd.DataFrame) -> pd.DataFrame:\\n    t = insurance[~insurance.duplicated(subset=[\\'lat\\', \\'lon\\'], keep=False)&\\\\\\n                         insurance.duplicated(subset=\\'tiv_2015\\', keep=False)]\\n\\n    return pd.DataFrame({\\'tiv_2016\\': [t.tiv_2016.sum()]})\\n    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4005031,
                "title": "best-solution-easy-query",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect ROUND(SUM(DISTINCT i1.tiv_2016),2) as tiv_2016 \\nfrom Insurance i1, Insurance i2\\nwhere i1.tiv_2015 = i2.tiv_2015\\n  AND i1.pid <> i2.pid \\n  AND i1.pid NOT IN \\n(select DISTINCT a.pid \\nfrom insurance a, insurance b\\nwhere  a.pid <> b.pid \\n   AND a.lat = b.lat \\n   AND b.lon = a.lon);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect ROUND(SUM(DISTINCT i1.tiv_2016),2) as tiv_2016 \\nfrom Insurance i1, Insurance i2\\nwhere i1.tiv_2015 = i2.tiv_2015\\n  AND i1.pid <> i2.pid \\n  AND i1.pid NOT IN \\n(select DISTINCT a.pid \\nfrom insurance a, insurance b\\nwhere  a.pid <> b.pid \\n   AND a.lat = b.lat \\n   AND b.lon = a.lon);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4004569,
                "title": "sql-solution-filter-the-people-who-has-unique-location",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe result of the below code:\\n```\\nselect a.pid, b.pid from Insurance a inner join Insurance b on (a.lat,a.lon) = (b.lat,b.lon)\\nwhere a.pid<>b.pid\\n```\\nis:\\n```\\n| pid | pid |\\n| --- | --- |\\n| 1   | 1   |\\n| 3   | 2   |\\n| 2   | 2   |\\n| 3   | 3   |\\n| 2   | 3   |\\n| 4   | 4   |\\n```\\nSo when filtering the `where a.pid<>b.pid`, we get the policyholder who has the unique location.\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect round(sum(tiv_2016), 2) tiv_2016 from Insurance\\nwhere pid not in (\\n  select a.pid from Insurance a inner join Insurance b on (a.lat,a.lon) = (b.lat,b.lon)\\n  where a.pid<>b.pid\\n)\\nand\\ntiv_2015 in (\\n  select tiv_2015 from Insurance group by tiv_2015 having count(pid)>1\\n)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect a.pid, b.pid from Insurance a inner join Insurance b on (a.lat,a.lon) = (b.lat,b.lon)\\nwhere a.pid<>b.pid\\n```\n```\\n| pid | pid |\\n| --- | --- |\\n| 1   | 1   |\\n| 3   | 2   |\\n| 2   | 2   |\\n| 3   | 3   |\\n| 2   | 3   |\\n| 4   | 4   |\\n```\n```\\n# Write your MySQL query statement below\\nselect round(sum(tiv_2016), 2) tiv_2016 from Insurance\\nwhere pid not in (\\n  select a.pid from Insurance a inner join Insurance b on (a.lat,a.lon) = (b.lat,b.lon)\\n  where a.pid<>b.pid\\n)\\nand\\ntiv_2015 in (\\n  select tiv_2015 from Insurance group by tiv_2015 having count(pid)>1\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4002941,
                "title": "my-sql-investments-in-2016-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT ROUND(SUM(tiv_2016),2) AS tiv_2016\\nFROM Insurance\\nWHERE tiv_2015 IN\\n(SELECT tiv_2015\\nFROM Insurance\\nGROUP BY tiv_2015\\nHAVING COUNT(*)>1)\\nAND (lat,lon) IN\\n(SELECT lat,lon\\nFROM Insurance\\nGROUP BY lat,lon\\nHAVING COUNT(*)=1);\\n\\n\\n/* Method 2:\\nSELECT ROUND(SUM(i1.tiv_2016),2) AS tiv_2016\\nFROM Insurance AS i1, Insurance AS i2\\nWHERE i1.tiv_2015 = i2.tiv_2015\\nAND i1.pid <> i2.pid\\nAND  i1.pid NOT IN\\n        (SELECT DISTINCT a.pid \\n        FROM Insurance a, Insurance b\\n        WHERE a.pid<>b.pid \\n        AND a.lat = b.lat \\n        AND a.lon = b.lon)\\nAND  i2.pid NOT IN\\n        (SELECT DISTINCT a.pid \\n        FROM Insurance a, Insurance b\\n        WHERE a.pid<>b.pid \\n        AND a.lat = b.lat \\n        AND a.lon = b.lon);*/\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT ROUND(SUM(tiv_2016),2) AS tiv_2016\\nFROM Insurance\\nWHERE tiv_2015 IN\\n(SELECT tiv_2015\\nFROM Insurance\\nGROUP BY tiv_2015\\nHAVING COUNT(*)>1)\\nAND (lat,lon) IN\\n(SELECT lat,lon\\nFROM Insurance\\nGROUP BY lat,lon\\nHAVING COUNT(*)=1);\\n\\n\\n/* Method 2:\\nSELECT ROUND(SUM(i1.tiv_2016),2) AS tiv_2016\\nFROM Insurance AS i1, Insurance AS i2\\nWHERE i1.tiv_2015 = i2.tiv_2015\\nAND i1.pid <> i2.pid\\nAND  i1.pid NOT IN\\n        (SELECT DISTINCT a.pid \\n        FROM Insurance a, Insurance b\\n        WHERE a.pid<>b.pid \\n        AND a.lat = b.lat \\n        AND a.lon = b.lon)\\nAND  i2.pid NOT IN\\n        (SELECT DISTINCT a.pid \\n        FROM Insurance a, Insurance b\\n        WHERE a.pid<>b.pid \\n        AND a.lat = b.lat \\n        AND a.lon = b.lon);*/\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4000940,
                "title": "simple-solution-mysql",
                "content": "# Code\\n```\\nSELECT ROUND(SUM(TIV_2016), 2) TIV_2016\\n  FROM INSURANCE I\\n WHERE NOT EXISTS(SELECT 1\\n                    FROM INSURANCE I1\\n                   WHERE I.LAT = I1.LAT AND I.LON = I1.LON\\n                     AND I.PID <> I1.PID)\\n  AND EXISTS(SELECT 1\\n                    FROM INSURANCE I1\\n                   WHERE I.TIV_2015 = I1.TIV_2015\\n                     AND I.PID <> I1.PID);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT ROUND(SUM(TIV_2016), 2) TIV_2016\\n  FROM INSURANCE I\\n WHERE NOT EXISTS(SELECT 1\\n                    FROM INSURANCE I1\\n                   WHERE I.LAT = I1.LAT AND I.LON = I1.LON\\n                     AND I.PID <> I1.PID)\\n  AND EXISTS(SELECT 1\\n                    FROM INSURANCE I1\\n                   WHERE I.TIV_2015 = I1.TIV_2015\\n                     AND I.PID <> I1.PID);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3999781,
                "title": "pandas-4-lines-with-explanation",
                "content": "# Intuition\\n\\nConsists of 4 lines:\\n 1. Get pids based on two statements\\n 2. Filter based on them\\n 3. Get sum and round\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef find_investments(df: pd.DataFrame) -> pd.DataFrame:\\n  id1 = df.drop_duplicates(subset=[\\'lat\\',\\'lon\\'], keep=False).pid\\n  id2 = df.loc[df.duplicated(subset=\\'tiv_2015\\', keep=False)].pid\\n  df = df.loc[df.pid.isin(id1) & df.pid.isin(id2)]\\n  return df[[\\'tiv_2016\\']].sum().to_frame(\\'tiv_2016\\').round(2)\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef find_investments(df: pd.DataFrame) -> pd.DataFrame:\\n  id1 = df.drop_duplicates(subset=[\\'lat\\',\\'lon\\'], keep=False).pid\\n  id2 = df.loc[df.duplicated(subset=\\'tiv_2015\\', keep=False)].pid\\n  df = df.loc[df.pid.isin(id1) & df.pid.isin(id2)]\\n  return df[[\\'tiv_2016\\']].sum().to_frame(\\'tiv_2016\\').round(2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3994601,
                "title": "oracle-exists-solution",
                "content": "# Code\\n```\\nselect round(sum(i.tiv_2016), 2) tiv_2016 \\n  from insurance i\\n where exists(select 1 from insurance where pid != i.pid and i.tiv_2015 = tiv_2015) \\n   and not exists(select 1 from insurance where pid != i.pid and i.lat = lat and i.lon = lon)\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nselect round(sum(i.tiv_2016), 2) tiv_2016 \\n  from insurance i\\n where exists(select 1 from insurance where pid != i.pid and i.tiv_2015 = tiv_2015) \\n   and not exists(select 1 from insurance where pid != i.pid and i.lat = lat and i.lon = lon)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3993578,
                "title": "very-simple-solution-with-minimal-code-with-explanation",
                "content": "# Intuition\\n\\nThese approach emphasizes achieving **performance with minimal code**.\\n\\nPlease **Upvote** if you find helpful.\\n\\n# Approach\\n\\nThe step by step explanation based on the code is:\\n\\n1. The outermost query selects the **rounded sum of tiv_2016 values** as tiv_2016.\\n\\n2. The **WHERE clause filters rows** based on two conditions:\\n\\n    - The **first condition** checks if the tiv_2015 value of a policyholder exists in a subquery\\'s result. \\n    The subquery finds tiv_2015 values that occur more than once in the Insurance table, indicating that multiple policyholders share the same tiv_2015 value.\\n\\n    - The **second condition** checks if the combination of latitude (lat) and longitude (lon) values exists in another subquery\\'s result.\\n    The subquery groups rows by lat and lon and selects groups that have a count of 1. This means that these groups represent unique (lat, lon) pairs, indicating that the policyholders in these groups are located in the unique location.\\n\\n3. By combining these two conditions, the query identifies policyholders who have the same tiv_2015 value as one or more others (first condition) and are not located in the same city as any other policyholder (second condition).\\n\\n4. Finally, the query calculates the sum of tiv_2016 values for the selected policyholders, rounds the result to two decimal places, and returns it as tiv_2016.\\n\\n# Code\\n```\\nSELECT ROUND(SUM(tiv_2016), 2) as tiv_2016\\nFROM Insurance\\nWHERE tiv_2015 IN\\n(\\n  SELECT tiv_2015\\n  FROM Insurance\\n  GROUP BY tiv_2015\\n  HAVING COUNT(*) > 1\\n)\\nAND (lat, lon) IN\\n(\\n  SELECT lat, lon\\n  FROM Insurance\\n  GROUP BY lat, lon\\n  HAVING COUNT(*) = 1\\n)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT ROUND(SUM(tiv_2016), 2) as tiv_2016\\nFROM Insurance\\nWHERE tiv_2015 IN\\n(\\n  SELECT tiv_2015\\n  FROM Insurance\\n  GROUP BY tiv_2015\\n  HAVING COUNT(*) > 1\\n)\\nAND (lat, lon) IN\\n(\\n  SELECT lat, lon\\n  FROM Insurance\\n  GROUP BY lat, lon\\n  HAVING COUNT(*) = 1\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3993238,
                "title": "simple-easy-to-understand-mysql-solution",
                "content": "# Approach\\n* Create cte1 to find all records with COUNT(tiv_2015)>1\\n* Create cte2 to find Unique pairs of lat, lon\\n\\nThe problem does not require creation of cte1 and cte2 as both can be incoporated into the main query itself.\\nI have created the ctes for simplicity and better understanding.\\n\\n# Complexity\\n- Time complexity: Beats 94.6%\\n- Space complexity: Beats 100%\\n\\n# Code\\n```\\nWITH cte1 AS(\\n    SELECT DISTINCT \\n        tiv_2015\\n    FROM Insurance\\n    GROUP BY tiv_2015\\n    HAVING COUNT(tiv_2015)>1\\n),\\n\\ncte2 AS (\\n    SELECT \\n        lat, lon\\n    FROM Insurance\\n    GROUP BY lat, lon\\n    HAVING COUNT(lat)=1 OR COUNT(lon)=1\\n)\\n\\nSELECT \\n    ROUND(SUM(tiv_2016), 2) AS tiv_2016\\nFROM Insurance\\nWHERE \\n    tiv_2015 IN (SELECT tiv_2015 FROM cte1) AND\\n    lat IN (SELECT lat FROM cte2) AND\\n    lon IN (SELECT lon FROM cte2)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nWITH cte1 AS(\\n    SELECT DISTINCT \\n        tiv_2015\\n    FROM Insurance\\n    GROUP BY tiv_2015\\n    HAVING COUNT(tiv_2015)>1\\n),\\n\\ncte2 AS (\\n    SELECT \\n        lat, lon\\n    FROM Insurance\\n    GROUP BY lat, lon\\n    HAVING COUNT(lat)=1 OR COUNT(lon)=1\\n)\\n\\nSELECT \\n    ROUND(SUM(tiv_2016), 2) AS tiv_2016\\nFROM Insurance\\nWHERE \\n    tiv_2015 IN (SELECT tiv_2015 FROM cte1) AND\\n    lat IN (SELECT lat FROM cte2) AND\\n    lon IN (SELECT lon FROM cte2)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3992097,
                "title": "using-windows-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom(\\n  select tiv_2016,\\n  count(*) over(partition by tiv_2015) as cnt_tiv_2015,\\n  count(*) over(partition by lat,lon) as cnt_lat_lon\\n  from insurance\\n) a\\nwhere cnt_tiv_2015 >1 and cnt_lat_lon=1\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom(\\n  select tiv_2016,\\n  count(*) over(partition by tiv_2015) as cnt_tiv_2015,\\n  count(*) over(partition by lat,lon) as cnt_lat_lon\\n  from insurance\\n) a\\nwhere cnt_tiv_2015 >1 and cnt_lat_lon=1\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3992031,
                "title": "easy-breakdown-of-the-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\nselect round(sum(tiv_2016),2) as tiv_2016 from\\n\\n(select i.pid,i.tiv_2015,i.tiv_2016 from Insurance i left join Insurance ii on i.tiv_2015=ii.tiv_2015 where i.pid<>ii.pid and i.pid not in \\n\\n(select i.pid from Insurance i join Insurance ii on i.lat=ii.lat where i.pid<>ii.pid \\nand (i.lat=ii.lat and i.lon=ii.lon) \\n)\\ngroup by i.pid)\\n\\n as cte\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n\\n\\nselect round(sum(tiv_2016),2) as tiv_2016 from\\n\\n(select i.pid,i.tiv_2015,i.tiv_2016 from Insurance i left join Insurance ii on i.tiv_2015=ii.tiv_2015 where i.pid<>ii.pid and i.pid not in \\n\\n(select i.pid from Insurance i join Insurance ii on i.lat=ii.lat where i.pid<>ii.pid \\nand (i.lat=ii.lat and i.lon=ii.lon) \\n)\\ngroup by i.pid)\\n\\n as cte\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3984822,
                "title": "pandas-solution-beginner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef find_investments(insurance: pd.DataFrame) -> pd.DataFrame:\\n    filtered = insurance[insurance.duplicated(subset=\"tiv_2015\", keep=False) & ~insurance.duplicated(subset=[\"lat\", \"lon\"], keep=False)]\\n    \\n    return pd.DataFrame({\"tiv_2016\":[filtered[\"tiv_2016\"].sum()]})\\n\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef find_investments(insurance: pd.DataFrame) -> pd.DataFrame:\\n    filtered = insurance[insurance.duplicated(subset=\"tiv_2015\", keep=False) & ~insurance.duplicated(subset=[\"lat\", \"lon\"], keep=False)]\\n    \\n    return pd.DataFrame({\"tiv_2016\":[filtered[\"tiv_2016\"].sum()]})\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3983853,
                "title": "mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect round(sum(tiv_2016), 2) as tiv_2016\\nfrom insurance \\nwhere (lat, lon, 1) in\\n    (select lat, lon, count(*)\\n    from insurance\\n    group by lat, lon)\\nand tiv_2015 in\\n    (select tiv_2015 from\\n        (select tiv_2015, count(*) as c\\n        from insurance\\n        group by tiv_2015\\n        having c > 1) x)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect round(sum(tiv_2016), 2) as tiv_2016\\nfrom insurance \\nwhere (lat, lon, 1) in\\n    (select lat, lon, count(*)\\n    from insurance\\n    group by lat, lon)\\nand tiv_2015 in\\n    (select tiv_2015 from\\n        (select tiv_2015, count(*) as c\\n        from insurance\\n        group by tiv_2015\\n        having c > 1) x)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3983704,
                "title": "omg-finally-sloved",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef find_investments(insurance: pd.DataFrame) -> pd.DataFrame:\\n    list1 = list(insurance[\\'lat\\'])\\n    list2 = list(insurance[\\'lon\\'])\\n    list3 = list(zip(list1,list2))\\n    #print(list3)\\n    list3_copy = list(set(list3))\\n    list3_copy_1 = list(set(list3))\\n    #print(list3_copy)\\n    \\n\\n    for i in list3_copy_1:\\n        if list3.count(i) > 1:\\n            list3_copy.pop(list3_copy.index(i))\\n\\n    print(list3_copy)\\n    result_table = pd.DataFrame(columns = [\\'pid\\',\\'tiv_2015\\',\\'tiv_2016\\',\\'lat\\',\\'lon\\'])\\n    result_table2 = pd.DataFrame(columns = [\\'pid\\',\\'tiv_2015\\',\\'tiv_2016\\',\\'lat\\',\\'lon\\'])\\n\\n    if len(list3_copy) > 0:\\n\\n        for i in list3_copy:\\n            lat = i[0]\\n            lon = i[1]\\n            table1 = insurance[insurance[\\'lat\\'] == lat]\\n            #print(table1)\\n            table2 = table1[table1[\\'lon\\'] == lon]\\n            print(table2)\\n            \\n            result_table = pd.concat([result_table,table2], axis = 0, ignore_index = True)\\n            #print(result_table)\\n    \\n    print(result_table)\\n    tiv_2015 = list(set(list(result_table[\\'tiv_2015\\'])))\\n    #print(tiv_2015)\\n    tiv_2015_copy = list(insurance[\\'tiv_2015\\'])\\n\\n    for i in tiv_2015:\\n        if tiv_2015_copy.count(i) > 1:\\n            result_table_f = result_table[result_table[\\'tiv_2015\\'] == i]\\n            result_table2 = pd.concat([result_table2, result_table_f], axis=0, ignore_index = True)\\n            print(result_table2)\\n\\n    tiv_2016 = sum(list(result_table2[\\'tiv_2016\\']))\\n    result_table = pd.DataFrame({\\'tiv_2016\\':[tiv_2016]})\\n    return result_table\\n\\n\\n\\n\\n    \\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef find_investments(insurance: pd.DataFrame) -> pd.DataFrame:\\n    list1 = list(insurance[\\'lat\\'])\\n    list2 = list(insurance[\\'lon\\'])\\n    list3 = list(zip(list1,list2))\\n    #print(list3)\\n    list3_copy = list(set(list3))\\n    list3_copy_1 = list(set(list3))\\n    #print(list3_copy)\\n    \\n\\n    for i in list3_copy_1:\\n        if list3.count(i) > 1:\\n            list3_copy.pop(list3_copy.index(i))\\n\\n    print(list3_copy)\\n    result_table = pd.DataFrame(columns = [\\'pid\\',\\'tiv_2015\\',\\'tiv_2016\\',\\'lat\\',\\'lon\\'])\\n    result_table2 = pd.DataFrame(columns = [\\'pid\\',\\'tiv_2015\\',\\'tiv_2016\\',\\'lat\\',\\'lon\\'])\\n\\n    if len(list3_copy) > 0:\\n\\n        for i in list3_copy:\\n            lat = i[0]\\n            lon = i[1]\\n            table1 = insurance[insurance[\\'lat\\'] == lat]\\n            #print(table1)\\n            table2 = table1[table1[\\'lon\\'] == lon]\\n            print(table2)\\n            \\n            result_table = pd.concat([result_table,table2], axis = 0, ignore_index = True)\\n            #print(result_table)\\n    \\n    print(result_table)\\n    tiv_2015 = list(set(list(result_table[\\'tiv_2015\\'])))\\n    #print(tiv_2015)\\n    tiv_2015_copy = list(insurance[\\'tiv_2015\\'])\\n\\n    for i in tiv_2015:\\n        if tiv_2015_copy.count(i) > 1:\\n            result_table_f = result_table[result_table[\\'tiv_2015\\'] == i]\\n            result_table2 = pd.concat([result_table2, result_table_f], axis=0, ignore_index = True)\\n            print(result_table2)\\n\\n    tiv_2016 = sum(list(result_table2[\\'tiv_2016\\']))\\n    result_table = pd.DataFrame({\\'tiv_2016\\':[tiv_2016]})\\n    return result_table\\n\\n\\n\\n\\n    \\n\\n\\n\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3982985,
                "title": "another-approach",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect round(sum(aa.tiv_2016),2) as tiv_2016 from Insurance as aa\\nwhere (aa.pid,aa.tiv_2016) in (\\n  select a.pid, a.tiv_2016 from Insurance as a\\njoin Insurance as b\\nwhere a.lat != b.lat and a.lon != b.lon and a.tiv_2015 = b.tiv_2015 \\ngroup by a.tiv_2016\\n)\\nand (aa.lon, aa.lat)  in (\\n  select lon, lat from Insurance\\n  group by lon, lat\\n  having count(*) = 1\\n)\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect round(sum(aa.tiv_2016),2) as tiv_2016 from Insurance as aa\\nwhere (aa.pid,aa.tiv_2016) in (\\n  select a.pid, a.tiv_2016 from Insurance as a\\njoin Insurance as b\\nwhere a.lat != b.lat and a.lon != b.lon and a.tiv_2015 = b.tiv_2015 \\ngroup by a.tiv_2016\\n)\\nand (aa.lon, aa.lat)  in (\\n  select lon, lat from Insurance\\n  group by lon, lat\\n  having count(*) = 1\\n)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3981012,
                "title": "simple-and-straightforward-solution",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n# Write your MySQL query statement below\\r\\n\\r\\nselect round(sum(tiv_2016),2) as tiv_2016\\r\\nfrom(\\r\\nselect *, CONCAT(LAT, LON) as l\\r\\nfrom insurance) a\\r\\nwhere tiv_2015 in (select tiv_2015\\r\\nfrom(\\r\\nSELECT *, CONCAT(LAT, LON) as loc\\r\\nfrom insurance ) a\\r\\ngroup by tiv_2015\\r\\nhaving count(tiv_2015) >1 )\\r\\n\\r\\nAND l in (select loc\\r\\nfrom(\\r\\nSELECT *, CONCAT(LAT, LON) as loc\\r\\nfrom insurance ) a\\r\\ngroup by  loc\\r\\nhaving count(loc) = 1)\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\r\\n# Write your MySQL query statement below\\r\\n\\r\\nselect round(sum(tiv_2016),2) as tiv_2016\\r\\nfrom(\\r\\nselect *, CONCAT(LAT, LON) as l\\r\\nfrom insurance) a\\r\\nwhere tiv_2015 in (select tiv_2015\\r\\nfrom(\\r\\nSELECT *, CONCAT(LAT, LON) as loc\\r\\nfrom insurance ) a\\r\\ngroup by tiv_2015\\r\\nhaving count(tiv_2015) >1 )\\r\\n\\r\\nAND l in (select loc\\r\\nfrom(\\r\\nSELECT *, CONCAT(LAT, LON) as loc\\r\\nfrom insurance ) a\\r\\ngroup by  loc\\r\\nhaving count(loc) = 1)\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3980876,
                "title": "easy-solution-with-cte-and-subquery",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\nWe have two critaria, so pid should not be in same city. we have to manage it and then we check wheather invest value have to be same with one or more policyholder.\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n1. We take out same city policyholders, so that we exclude that pid.\\r\\n2. Then we have to check value of tiv_2015 should be same with one or more policyholder so we do left join for comparsion but to easy our work, we can use that t2.pid not equal to t1.pid so that we don\\'t to compare with the same raw.\\r\\n3. Now just exclude loaction in this table from cte, we use not in for excluding because we can have more then one resulting row.\\r\\n4. Now sum of tic_2016 with round with 2 decimal.\\r\\n\\r\\n# Code\\r\\n```\\r\\n# Write your MySQL query statement below\\r\\nwith cte as (\\r\\n    select concat(lat,\\',\\',lon) as location\\r\\n    from Insurance\\r\\n    group by lat, lon\\r\\n    having count(pid)>1\\r\\n),\\r\\n\\r\\ncte2 as (\\r\\n    select distinct i1.*\\r\\n    from Insurance i1\\r\\n    left join Insurance i2\\r\\n    on i1.tiv_2015=i2.tiv_2015\\r\\n    where i1.pid<>i2.pid\\r\\n    and concat(i1.lat,\\',\\',i1.lon) not in (\\r\\n        select location from cte\\r\\n    )\\r\\n)\\r\\n\\r\\nselect round(sum(tiv_2016), 2) as tiv_2016\\r\\nfrom cte2\\r\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\r\\n# Write your MySQL query statement below\\r\\nwith cte as (\\r\\n    select concat(lat,\\',\\',lon) as location\\r\\n    from Insurance\\r\\n    group by lat, lon\\r\\n    having count(pid)>1\\r\\n),\\r\\n\\r\\ncte2 as (\\r\\n    select distinct i1.*\\r\\n    from Insurance i1\\r\\n    left join Insurance i2\\r\\n    on i1.tiv_2015=i2.tiv_2015\\r\\n    where i1.pid<>i2.pid\\r\\n    and concat(i1.lat,\\',\\',i1.lon) not in (\\r\\n        select location from cte\\r\\n    )\\r\\n)\\r\\n\\r\\nselect round(sum(tiv_2016), 2) as tiv_2016\\r\\nfrom cte2\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3980304,
                "title": "pandas-intuitive-one-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere are two conditions to check, based on the number of occurrences of certain values in the table. If we include the count of these values as new columns, it is easy to filter for the desired conditions.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn order to add the extra columns with the counts we use the built-in ```value_counts()``` and merge.\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef find_investments(insurance: pd.DataFrame) -> pd.DataFrame:\\n    return pd.DataFrame({\\n        \\'tiv_2016\\': [\\n        insurance.merge(\\n            insurance[\\'tiv_2015\\'].value_counts().rename(\\'tiv_2015_count\\'),\\n            left_on=\\'tiv_2015\\',\\n            right_index=True,\\n            how=\\'left\\'\\n        ).merge(\\n            insurance[[\\'lat\\',\\'lon\\']].value_counts().rename(\\'city_count\\'),\\n            left_on=[\\'lat\\', \\'lon\\'],\\n            right_index=True,\\n            how=\\'left\\'\\n        ).query(\\n            \\'tiv_2015_count >= 2 & city_count == 1\\'\\n        )[\\n            \\'tiv_2016\\'\\n        ].sum()]\\n    })\\n\\n\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```value_counts()```\n```\\nimport pandas as pd\\n\\ndef find_investments(insurance: pd.DataFrame) -> pd.DataFrame:\\n    return pd.DataFrame({\\n        \\'tiv_2016\\': [\\n        insurance.merge(\\n            insurance[\\'tiv_2015\\'].value_counts().rename(\\'tiv_2015_count\\'),\\n            left_on=\\'tiv_2015\\',\\n            right_index=True,\\n            how=\\'left\\'\\n        ).merge(\\n            insurance[[\\'lat\\',\\'lon\\']].value_counts().rename(\\'city_count\\'),\\n            left_on=[\\'lat\\', \\'lon\\'],\\n            right_index=True,\\n            how=\\'left\\'\\n        ).query(\\n            \\'tiv_2015_count >= 2 & city_count == 1\\'\\n        )[\\n            \\'tiv_2016\\'\\n        ].sum()]\\n    })\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3979451,
                "title": "pandas-solution-4-lines",
                "content": "\\n# idea\\nmask both condition and filter at the same time \\n\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef find_investments(insurance: pd.DataFrame) -> pd.DataFrame:\\n    \\n    # have the same tiv_2015 value as one or more other policyholders\\n    cond1 = (insurance.duplicated(subset=[\\'tiv_2015\\'], keep=False))\\n    \\n     #are not located in the same city as any other policyholder \\n     #(i.e., the (lat, lon) attribute pairs must be unique)\\n    cond2 =  ~(insurance.duplicated(subset=[\\'lat\\',\\'lon\\'], keep=False))\\n    # both conditions       \\n    insurance = insurance[cond1 & cond2]\\n    \\n    \\n    return  pd.DataFrame({\"tiv_2016\":[insurance[\\'tiv_2016\\'].sum().round(2)]})\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef find_investments(insurance: pd.DataFrame) -> pd.DataFrame:\\n    \\n    # have the same tiv_2015 value as one or more other policyholders\\n    cond1 = (insurance.duplicated(subset=[\\'tiv_2015\\'], keep=False))\\n    \\n     #are not located in the same city as any other policyholder \\n     #(i.e., the (lat, lon) attribute pairs must be unique)\\n    cond2 =  ~(insurance.duplicated(subset=[\\'lat\\',\\'lon\\'], keep=False))\\n    # both conditions       \\n    insurance = insurance[cond1 & cond2]\\n    \\n    \\n    return  pd.DataFrame({\"tiv_2016\":[insurance[\\'tiv_2016\\'].sum().round(2)]})\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3979068,
                "title": "simplest-solution-subquery-neatcode",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need sum of only those tiv_2016 that meet these two conditions:\\n1. The corresponding tiv_2015 should not be unique.\\n2. The corresponding (lat,lon) pair should be unique\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor uniqueness in (lat,lon) pair, we use Group By & COUNT(*) = 1 in a subquery.\\nFor Non-uniqueness in tiv_2015, we use Group By & COUNT(*) > 1 in a subquery.\\n\\n# Code\\n```\\nSELECT\\n    ROUND(SUM(tiv_2016),2) AS tiv_2016\\nFROM\\n    Insurance\\nWHERE\\n    (lat,lon) IN (SELECT lat,lon FROM Insurance GROUP BY 1,2 HAVING COUNT(*) = 1)\\nAND\\n    tiv_2015 IN (SELECT tiv_2015 FROM Insurance GROUP BY 1 HAVING COUNT(*) > 1)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT\\n    ROUND(SUM(tiv_2016),2) AS tiv_2016\\nFROM\\n    Insurance\\nWHERE\\n    (lat,lon) IN (SELECT lat,lon FROM Insurance GROUP BY 1,2 HAVING COUNT(*) = 1)\\nAND\\n    tiv_2015 IN (SELECT tiv_2015 FROM Insurance GROUP BY 1 HAVING COUNT(*) > 1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3979047,
                "title": "simplest-solution-cte-join-neatcode",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need sum of only those tiv_2016 that meet these two conditions:\\n1. The corresponding tiv_2015 should not be unique.\\n2. The corresponding (lat,lon) pair should be unique\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe write two CTEs each for tiv and location.\\nFor uniqueness in (lat,lon) pair, we use Group By & COUNT(*) = 1.\\nFor Non-uniqueness in tiv_2015, we use Group By & COUNT(*) > 1.\\nThen Join these CTEs with the Insurance Table.\\n\\n---\\n> *Consider Upvote, if you like the solution.*\\n---\\n\\n\\n# Code\\n```\\nWITH CTE_loc AS\\n(\\n    SELECT \\n        lat, lon \\n    FROM \\n        Insurance \\n    GROUP BY\\n        lat, lon \\n    HAVING \\n        COUNT(*) = 1\\n),\\n\\nCTE_tiv AS\\n(\\n    SELECT \\n        tiv_2015 \\n    FROM \\n        Insurance \\n    GROUP BY \\n        tiv_2015 \\n    HAVING \\n        COUNT(*) > 1\\n)\\n\\nSELECT\\n    ROUND(SUM(i.tiv_2016), 2) AS tiv_2016\\nFROM\\n    Insurance AS i\\nJOIN\\n    CTE_tiv AS t ON i.tiv_2015 = t.tiv_2015\\nJOIN\\n    CTE_loc AS l ON i.lat = l.lat AND i.lon = l.lon;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nWITH CTE_loc AS\\n(\\n    SELECT \\n        lat, lon \\n    FROM \\n        Insurance \\n    GROUP BY\\n        lat, lon \\n    HAVING \\n        COUNT(*) = 1\\n),\\n\\nCTE_tiv AS\\n(\\n    SELECT \\n        tiv_2015 \\n    FROM \\n        Insurance \\n    GROUP BY \\n        tiv_2015 \\n    HAVING \\n        COUNT(*) > 1\\n)\\n\\nSELECT\\n    ROUND(SUM(i.tiv_2016), 2) AS tiv_2016\\nFROM\\n    Insurance AS i\\nJOIN\\n    CTE_tiv AS t ON i.tiv_2015 = t.tiv_2015\\nJOIN\\n    CTE_loc AS l ON i.lat = l.lat AND i.lon = l.lon;\\n\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1573006,
                "content": [
                    {
                        "username": "henryangela",
                        "content": "# Write your MySQL query statement below\\nselect round(sum(TIV_2016),2) as TIV_2016 from insurance\\nwhere TIV_2015 in\\n(select TIV_2015 from insurance group by TIV_2015 having count(TIV_2015) >1)\\nand concat(LAT, LON) not in\\n(select concat(LAT, LON) from insurance group by LAT, LON having count(concat(LAT, LON)) >1)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "why you use concat in here, you can just couple it in parentheses\\n\\n# Write your MySQL query statement below\\n\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom insurance \\nwhere tiv_2015 in (\\n    select tiv_2015\\n    from insurance\\n    group by tiv_2015\\n    having count(*) >1\\n)\\nand (lat,lon) in (\\n    select lat, lon\\n    from insurance \\n    group by lat,lon\\n    having count(*) = 1\\n)"
                    },
                    {
                        "username": "pittchen",
                        "content": "wtf"
                    },
                    {
                        "username": "sunbo199587",
                        "content": "with cte as \\n(select pid, TIV_2015, TIV_2016, count(concat(lat, lon)) over (partition by concat(lat, lon))as cnt1, count(TIV_2015) over(partition by tiv_2015) as cnt\\nfrom insurance)\\n\\nselect sum(TIV_2016) as TIV_2016 from cte where cnt1=1 and cnt!=1"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "While testing queries for this problem on a local server, I encountered \"Insufficient number of values for placeholders in query\" error. I\\'ve spent, like, 2 hours browsing different forums, and found NO help for the situation I have here. Would really appreciate if someone could help me understand what\\'s the deal here, and/or guided to some sort of documentation on this stuff.\\n\\n<b>PLEASE NOTE: LEETCODE DOES NOT HAVE SUCH AN ISSUE, IT\\'S JUST ABOUT MY LOCAL SERVER.</b>\\nCode in question:\\n\\n`SELECT i1.pid AS pid`\\n`    FROM Insurance AS i1`\\n`    INNER JOIN Insurance AS i2`\\n`    ON i1.lat = i2.lat AND i1.lon = i2.lon AND i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nI feel like what\\'s really going on here, is SQL has trouble linking all of the fields, as exactly same issue arised once I separated one of the conditions into consequent WHERE statement:\\n\\n`SELECT i1.pid AS pid`\\n`FROM Insurance AS i1`\\n`INNER JOIN Insurance AS i2`\\n`ON i1.lat = i2.lat AND i1.lon = i2.lon`\\n`WHERE i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nOnce again, would appreciate any help."
                    },
                    {
                        "username": "sannanakbar56",
                        "content": "\"\"\"select sum(tiv_2016) as tiv_2016 from insurance where \\nlat || lon in (select lat || lon\\nfrom insurance\\ngroup by lat || lon\\nhaving count(*) = 1)\\nand tiv_2015 in (select tiv_2015 from insurance group by tiv_2015 having count(*) > 1)\"\"\""
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect sum(a.TIV_2016) as TIV_2016 from insurance a\\nwhere \\na.TIV_2015 in (select b.TIV_2015 from insurance b where a.PID <> b.PID)\\nand \\n(a.LAT, a.LON) not in (select c.LAT, c.LON from insurance c where a.PID <> c.PID)\\n;"
                    },
                    {
                        "username": "__ppt_29",
                        "content": "WITH tiv AS (\n    SELECT tiv_2015, tiv_2016\n    FROM Insurance \n    GROUP BY CONCAT(lat,lon)\n    HAVING COUNT(\\*)= 1\n),\ntiv_sum AS (\n    SELECT tiv_2015, SUM(tiv_2016) AS tiv_2016\n    FROM tiv\n    GROUP BY tiv_2015\n    HAVING COUNT(\\*) >= 2\n)\n\nSELECT ROUND(SUM(tiv_2016),2) AS tiv_2016\nFROM tiv_sum\n\n\ncan anyone tell me why this isn't working "
                    },
                    {
                        "username": "Almas21",
                        "content": "hi, guys!!\\n\\nCan you explain me the algorith on the following test case:\\n\\n| pid | tiv_2015 | tiv_2016 | lat  | lon  |\\n| --- | -------- | -------- | ---- | ---- |\\n| 1   | 224.17   | 952.73   | 32.4 | 20.2 |\\n| 2   | 224.17   | 900.66   | 52.4 | 32.7 |\\n| 3   | 824.61   | 645.13   | 72.4 | 45.2 |\\n| 4   | 424.32   | 323.66   | 12.4 | 7.7  |\\n| 5   | 424.32   | 282.9    | 12.4 | 7.7  |\\n| 6   | 625.05   | 243.53   | 52.5 | 32.8 |\\n| 7   | 424.32   | 968.94   | 72.5 | 45.3 |\\n| 8   | 624.46   | 714.13   | 12.5 | 7.8  |\\n| 9   | 425.49   | 463.85   | 32.5 | 20.3 |\\n| 10  | 624.46   | 776.85   | 12.4 | 7.7  |\\n| 11  | 624.46   | 692.71   | 72.5 | 45.3 |\\n| 12  | 225.93   | 933      | 12.5 | 7.8  |\\n| 13  | 824.61   | 786.86   | 32.6 | 20.3 |\\n| 14  | 824.61   | 935.34   | 52.6 | 32.8 |\\n| 15  | 826.37   | 516.1    | 12.4 | 7.7  |\\n| 16  | 824.61   | 374.5    | 12.6 | 7.9  |\\n| 17  | 824.61   | 924.19   | 32.6 | 20.4 |\\n| 18  | 626.81   | 897.47   | 52.6 | 32.9 |\\n| 19  | 224.76   | 714.79   | 72.6 | 45.4 |\\n| 20  | 224.76   | 681.53   | 12.4 | 7.7  |\\n| 21  | 427.25   | 263.27   | 32.7 | 20.4 |\\n| 22  | 224.76   | 671.8    | 52.7 | 32.9 |\\n| 23  | 424.9    | 769.18   | 72.7 | 45.4 |\\n| 24  | 227.69   | 830.5    | 12.7 | 7.9  |\\n| 25  | 424.9    | 844.97   | 12.4 | 7.7  |\\n| 26  | 424.9    | 733.35   | 52.7 | 32.9 |\\n| 27  | 828.13   | 931.83   | 72.8 | 45.5 |\\n| 28  | 625.05   | 659.13   | 12.8 | 8    |\\n| 29  | 625.05   | 300.16   | 32.8 | 20.5 |\\n\\nI really could not get what is required."
                    },
                    {
                        "username": "Abdur1997",
                        "content": "SELECT ROUND(SUM(a.TIV_2016), 2) AS TIV_2016\nFROM insurance a\nWHERE EXISTS (\n    SELECT 1\n    FROM insurance b\n    WHERE a.PID <> b.PID AND a.TIV_2015 = b.TIV_2015\n)\nAND NOT EXISTS (\n    SELECT 1\n    FROM insurance c\n    WHERE a.PID <> c.PID AND (a.LAT = c.LAT AND a.LON = c.LON)\n)\n"
                    },
                    {
                        "username": "user1448rE",
                        "content": "Could anyone explain what\\'s wrong with this solution? \\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON) AS LONG, COUNT(LON) OVER (PARTITION BY LAT) AS LATI, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND (LONG=1 OR LATI=1)\\n\\nAbove solution doesn\\'t work but when I changed it to the one below it works fine.\\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON,lat) AS LONG, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND LONG=1"
                    },
                    {
                        "username": "srjefers",
                        "content": "I can explain 💡, on your first solution you has been taking the columns of `lat & lon` as separeted values, there are more like a composite key that you need to concatenate to have the real value and know/understand on which cases are they really being duplicated. By applying the concatenation of both of them, something that you did on the second solution with the `partition by`, you would be able to count each of them and remove duplicated values. The `TIV` columns you got it right 👍"
                    }
                ]
            },
            {
                "id": 2037890,
                "content": [
                    {
                        "username": "henryangela",
                        "content": "# Write your MySQL query statement below\\nselect round(sum(TIV_2016),2) as TIV_2016 from insurance\\nwhere TIV_2015 in\\n(select TIV_2015 from insurance group by TIV_2015 having count(TIV_2015) >1)\\nand concat(LAT, LON) not in\\n(select concat(LAT, LON) from insurance group by LAT, LON having count(concat(LAT, LON)) >1)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "why you use concat in here, you can just couple it in parentheses\\n\\n# Write your MySQL query statement below\\n\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom insurance \\nwhere tiv_2015 in (\\n    select tiv_2015\\n    from insurance\\n    group by tiv_2015\\n    having count(*) >1\\n)\\nand (lat,lon) in (\\n    select lat, lon\\n    from insurance \\n    group by lat,lon\\n    having count(*) = 1\\n)"
                    },
                    {
                        "username": "pittchen",
                        "content": "wtf"
                    },
                    {
                        "username": "sunbo199587",
                        "content": "with cte as \\n(select pid, TIV_2015, TIV_2016, count(concat(lat, lon)) over (partition by concat(lat, lon))as cnt1, count(TIV_2015) over(partition by tiv_2015) as cnt\\nfrom insurance)\\n\\nselect sum(TIV_2016) as TIV_2016 from cte where cnt1=1 and cnt!=1"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "While testing queries for this problem on a local server, I encountered \"Insufficient number of values for placeholders in query\" error. I\\'ve spent, like, 2 hours browsing different forums, and found NO help for the situation I have here. Would really appreciate if someone could help me understand what\\'s the deal here, and/or guided to some sort of documentation on this stuff.\\n\\n<b>PLEASE NOTE: LEETCODE DOES NOT HAVE SUCH AN ISSUE, IT\\'S JUST ABOUT MY LOCAL SERVER.</b>\\nCode in question:\\n\\n`SELECT i1.pid AS pid`\\n`    FROM Insurance AS i1`\\n`    INNER JOIN Insurance AS i2`\\n`    ON i1.lat = i2.lat AND i1.lon = i2.lon AND i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nI feel like what\\'s really going on here, is SQL has trouble linking all of the fields, as exactly same issue arised once I separated one of the conditions into consequent WHERE statement:\\n\\n`SELECT i1.pid AS pid`\\n`FROM Insurance AS i1`\\n`INNER JOIN Insurance AS i2`\\n`ON i1.lat = i2.lat AND i1.lon = i2.lon`\\n`WHERE i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nOnce again, would appreciate any help."
                    },
                    {
                        "username": "sannanakbar56",
                        "content": "\"\"\"select sum(tiv_2016) as tiv_2016 from insurance where \\nlat || lon in (select lat || lon\\nfrom insurance\\ngroup by lat || lon\\nhaving count(*) = 1)\\nand tiv_2015 in (select tiv_2015 from insurance group by tiv_2015 having count(*) > 1)\"\"\""
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect sum(a.TIV_2016) as TIV_2016 from insurance a\\nwhere \\na.TIV_2015 in (select b.TIV_2015 from insurance b where a.PID <> b.PID)\\nand \\n(a.LAT, a.LON) not in (select c.LAT, c.LON from insurance c where a.PID <> c.PID)\\n;"
                    },
                    {
                        "username": "__ppt_29",
                        "content": "WITH tiv AS (\n    SELECT tiv_2015, tiv_2016\n    FROM Insurance \n    GROUP BY CONCAT(lat,lon)\n    HAVING COUNT(\\*)= 1\n),\ntiv_sum AS (\n    SELECT tiv_2015, SUM(tiv_2016) AS tiv_2016\n    FROM tiv\n    GROUP BY tiv_2015\n    HAVING COUNT(\\*) >= 2\n)\n\nSELECT ROUND(SUM(tiv_2016),2) AS tiv_2016\nFROM tiv_sum\n\n\ncan anyone tell me why this isn't working "
                    },
                    {
                        "username": "Almas21",
                        "content": "hi, guys!!\\n\\nCan you explain me the algorith on the following test case:\\n\\n| pid | tiv_2015 | tiv_2016 | lat  | lon  |\\n| --- | -------- | -------- | ---- | ---- |\\n| 1   | 224.17   | 952.73   | 32.4 | 20.2 |\\n| 2   | 224.17   | 900.66   | 52.4 | 32.7 |\\n| 3   | 824.61   | 645.13   | 72.4 | 45.2 |\\n| 4   | 424.32   | 323.66   | 12.4 | 7.7  |\\n| 5   | 424.32   | 282.9    | 12.4 | 7.7  |\\n| 6   | 625.05   | 243.53   | 52.5 | 32.8 |\\n| 7   | 424.32   | 968.94   | 72.5 | 45.3 |\\n| 8   | 624.46   | 714.13   | 12.5 | 7.8  |\\n| 9   | 425.49   | 463.85   | 32.5 | 20.3 |\\n| 10  | 624.46   | 776.85   | 12.4 | 7.7  |\\n| 11  | 624.46   | 692.71   | 72.5 | 45.3 |\\n| 12  | 225.93   | 933      | 12.5 | 7.8  |\\n| 13  | 824.61   | 786.86   | 32.6 | 20.3 |\\n| 14  | 824.61   | 935.34   | 52.6 | 32.8 |\\n| 15  | 826.37   | 516.1    | 12.4 | 7.7  |\\n| 16  | 824.61   | 374.5    | 12.6 | 7.9  |\\n| 17  | 824.61   | 924.19   | 32.6 | 20.4 |\\n| 18  | 626.81   | 897.47   | 52.6 | 32.9 |\\n| 19  | 224.76   | 714.79   | 72.6 | 45.4 |\\n| 20  | 224.76   | 681.53   | 12.4 | 7.7  |\\n| 21  | 427.25   | 263.27   | 32.7 | 20.4 |\\n| 22  | 224.76   | 671.8    | 52.7 | 32.9 |\\n| 23  | 424.9    | 769.18   | 72.7 | 45.4 |\\n| 24  | 227.69   | 830.5    | 12.7 | 7.9  |\\n| 25  | 424.9    | 844.97   | 12.4 | 7.7  |\\n| 26  | 424.9    | 733.35   | 52.7 | 32.9 |\\n| 27  | 828.13   | 931.83   | 72.8 | 45.5 |\\n| 28  | 625.05   | 659.13   | 12.8 | 8    |\\n| 29  | 625.05   | 300.16   | 32.8 | 20.5 |\\n\\nI really could not get what is required."
                    },
                    {
                        "username": "Abdur1997",
                        "content": "SELECT ROUND(SUM(a.TIV_2016), 2) AS TIV_2016\nFROM insurance a\nWHERE EXISTS (\n    SELECT 1\n    FROM insurance b\n    WHERE a.PID <> b.PID AND a.TIV_2015 = b.TIV_2015\n)\nAND NOT EXISTS (\n    SELECT 1\n    FROM insurance c\n    WHERE a.PID <> c.PID AND (a.LAT = c.LAT AND a.LON = c.LON)\n)\n"
                    },
                    {
                        "username": "user1448rE",
                        "content": "Could anyone explain what\\'s wrong with this solution? \\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON) AS LONG, COUNT(LON) OVER (PARTITION BY LAT) AS LATI, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND (LONG=1 OR LATI=1)\\n\\nAbove solution doesn\\'t work but when I changed it to the one below it works fine.\\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON,lat) AS LONG, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND LONG=1"
                    },
                    {
                        "username": "srjefers",
                        "content": "I can explain 💡, on your first solution you has been taking the columns of `lat & lon` as separeted values, there are more like a composite key that you need to concatenate to have the real value and know/understand on which cases are they really being duplicated. By applying the concatenation of both of them, something that you did on the second solution with the `partition by`, you would be able to count each of them and remove duplicated values. The `TIV` columns you got it right 👍"
                    }
                ]
            },
            {
                "id": 1575554,
                "content": [
                    {
                        "username": "henryangela",
                        "content": "# Write your MySQL query statement below\\nselect round(sum(TIV_2016),2) as TIV_2016 from insurance\\nwhere TIV_2015 in\\n(select TIV_2015 from insurance group by TIV_2015 having count(TIV_2015) >1)\\nand concat(LAT, LON) not in\\n(select concat(LAT, LON) from insurance group by LAT, LON having count(concat(LAT, LON)) >1)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "why you use concat in here, you can just couple it in parentheses\\n\\n# Write your MySQL query statement below\\n\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom insurance \\nwhere tiv_2015 in (\\n    select tiv_2015\\n    from insurance\\n    group by tiv_2015\\n    having count(*) >1\\n)\\nand (lat,lon) in (\\n    select lat, lon\\n    from insurance \\n    group by lat,lon\\n    having count(*) = 1\\n)"
                    },
                    {
                        "username": "pittchen",
                        "content": "wtf"
                    },
                    {
                        "username": "sunbo199587",
                        "content": "with cte as \\n(select pid, TIV_2015, TIV_2016, count(concat(lat, lon)) over (partition by concat(lat, lon))as cnt1, count(TIV_2015) over(partition by tiv_2015) as cnt\\nfrom insurance)\\n\\nselect sum(TIV_2016) as TIV_2016 from cte where cnt1=1 and cnt!=1"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "While testing queries for this problem on a local server, I encountered \"Insufficient number of values for placeholders in query\" error. I\\'ve spent, like, 2 hours browsing different forums, and found NO help for the situation I have here. Would really appreciate if someone could help me understand what\\'s the deal here, and/or guided to some sort of documentation on this stuff.\\n\\n<b>PLEASE NOTE: LEETCODE DOES NOT HAVE SUCH AN ISSUE, IT\\'S JUST ABOUT MY LOCAL SERVER.</b>\\nCode in question:\\n\\n`SELECT i1.pid AS pid`\\n`    FROM Insurance AS i1`\\n`    INNER JOIN Insurance AS i2`\\n`    ON i1.lat = i2.lat AND i1.lon = i2.lon AND i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nI feel like what\\'s really going on here, is SQL has trouble linking all of the fields, as exactly same issue arised once I separated one of the conditions into consequent WHERE statement:\\n\\n`SELECT i1.pid AS pid`\\n`FROM Insurance AS i1`\\n`INNER JOIN Insurance AS i2`\\n`ON i1.lat = i2.lat AND i1.lon = i2.lon`\\n`WHERE i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nOnce again, would appreciate any help."
                    },
                    {
                        "username": "sannanakbar56",
                        "content": "\"\"\"select sum(tiv_2016) as tiv_2016 from insurance where \\nlat || lon in (select lat || lon\\nfrom insurance\\ngroup by lat || lon\\nhaving count(*) = 1)\\nand tiv_2015 in (select tiv_2015 from insurance group by tiv_2015 having count(*) > 1)\"\"\""
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect sum(a.TIV_2016) as TIV_2016 from insurance a\\nwhere \\na.TIV_2015 in (select b.TIV_2015 from insurance b where a.PID <> b.PID)\\nand \\n(a.LAT, a.LON) not in (select c.LAT, c.LON from insurance c where a.PID <> c.PID)\\n;"
                    },
                    {
                        "username": "__ppt_29",
                        "content": "WITH tiv AS (\n    SELECT tiv_2015, tiv_2016\n    FROM Insurance \n    GROUP BY CONCAT(lat,lon)\n    HAVING COUNT(\\*)= 1\n),\ntiv_sum AS (\n    SELECT tiv_2015, SUM(tiv_2016) AS tiv_2016\n    FROM tiv\n    GROUP BY tiv_2015\n    HAVING COUNT(\\*) >= 2\n)\n\nSELECT ROUND(SUM(tiv_2016),2) AS tiv_2016\nFROM tiv_sum\n\n\ncan anyone tell me why this isn't working "
                    },
                    {
                        "username": "Almas21",
                        "content": "hi, guys!!\\n\\nCan you explain me the algorith on the following test case:\\n\\n| pid | tiv_2015 | tiv_2016 | lat  | lon  |\\n| --- | -------- | -------- | ---- | ---- |\\n| 1   | 224.17   | 952.73   | 32.4 | 20.2 |\\n| 2   | 224.17   | 900.66   | 52.4 | 32.7 |\\n| 3   | 824.61   | 645.13   | 72.4 | 45.2 |\\n| 4   | 424.32   | 323.66   | 12.4 | 7.7  |\\n| 5   | 424.32   | 282.9    | 12.4 | 7.7  |\\n| 6   | 625.05   | 243.53   | 52.5 | 32.8 |\\n| 7   | 424.32   | 968.94   | 72.5 | 45.3 |\\n| 8   | 624.46   | 714.13   | 12.5 | 7.8  |\\n| 9   | 425.49   | 463.85   | 32.5 | 20.3 |\\n| 10  | 624.46   | 776.85   | 12.4 | 7.7  |\\n| 11  | 624.46   | 692.71   | 72.5 | 45.3 |\\n| 12  | 225.93   | 933      | 12.5 | 7.8  |\\n| 13  | 824.61   | 786.86   | 32.6 | 20.3 |\\n| 14  | 824.61   | 935.34   | 52.6 | 32.8 |\\n| 15  | 826.37   | 516.1    | 12.4 | 7.7  |\\n| 16  | 824.61   | 374.5    | 12.6 | 7.9  |\\n| 17  | 824.61   | 924.19   | 32.6 | 20.4 |\\n| 18  | 626.81   | 897.47   | 52.6 | 32.9 |\\n| 19  | 224.76   | 714.79   | 72.6 | 45.4 |\\n| 20  | 224.76   | 681.53   | 12.4 | 7.7  |\\n| 21  | 427.25   | 263.27   | 32.7 | 20.4 |\\n| 22  | 224.76   | 671.8    | 52.7 | 32.9 |\\n| 23  | 424.9    | 769.18   | 72.7 | 45.4 |\\n| 24  | 227.69   | 830.5    | 12.7 | 7.9  |\\n| 25  | 424.9    | 844.97   | 12.4 | 7.7  |\\n| 26  | 424.9    | 733.35   | 52.7 | 32.9 |\\n| 27  | 828.13   | 931.83   | 72.8 | 45.5 |\\n| 28  | 625.05   | 659.13   | 12.8 | 8    |\\n| 29  | 625.05   | 300.16   | 32.8 | 20.5 |\\n\\nI really could not get what is required."
                    },
                    {
                        "username": "Abdur1997",
                        "content": "SELECT ROUND(SUM(a.TIV_2016), 2) AS TIV_2016\nFROM insurance a\nWHERE EXISTS (\n    SELECT 1\n    FROM insurance b\n    WHERE a.PID <> b.PID AND a.TIV_2015 = b.TIV_2015\n)\nAND NOT EXISTS (\n    SELECT 1\n    FROM insurance c\n    WHERE a.PID <> c.PID AND (a.LAT = c.LAT AND a.LON = c.LON)\n)\n"
                    },
                    {
                        "username": "user1448rE",
                        "content": "Could anyone explain what\\'s wrong with this solution? \\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON) AS LONG, COUNT(LON) OVER (PARTITION BY LAT) AS LATI, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND (LONG=1 OR LATI=1)\\n\\nAbove solution doesn\\'t work but when I changed it to the one below it works fine.\\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON,lat) AS LONG, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND LONG=1"
                    },
                    {
                        "username": "srjefers",
                        "content": "I can explain 💡, on your first solution you has been taking the columns of `lat & lon` as separeted values, there are more like a composite key that you need to concatenate to have the real value and know/understand on which cases are they really being duplicated. By applying the concatenation of both of them, something that you did on the second solution with the `partition by`, you would be able to count each of them and remove duplicated values. The `TIV` columns you got it right 👍"
                    }
                ]
            },
            {
                "id": 1934980,
                "content": [
                    {
                        "username": "henryangela",
                        "content": "# Write your MySQL query statement below\\nselect round(sum(TIV_2016),2) as TIV_2016 from insurance\\nwhere TIV_2015 in\\n(select TIV_2015 from insurance group by TIV_2015 having count(TIV_2015) >1)\\nand concat(LAT, LON) not in\\n(select concat(LAT, LON) from insurance group by LAT, LON having count(concat(LAT, LON)) >1)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "why you use concat in here, you can just couple it in parentheses\\n\\n# Write your MySQL query statement below\\n\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom insurance \\nwhere tiv_2015 in (\\n    select tiv_2015\\n    from insurance\\n    group by tiv_2015\\n    having count(*) >1\\n)\\nand (lat,lon) in (\\n    select lat, lon\\n    from insurance \\n    group by lat,lon\\n    having count(*) = 1\\n)"
                    },
                    {
                        "username": "pittchen",
                        "content": "wtf"
                    },
                    {
                        "username": "sunbo199587",
                        "content": "with cte as \\n(select pid, TIV_2015, TIV_2016, count(concat(lat, lon)) over (partition by concat(lat, lon))as cnt1, count(TIV_2015) over(partition by tiv_2015) as cnt\\nfrom insurance)\\n\\nselect sum(TIV_2016) as TIV_2016 from cte where cnt1=1 and cnt!=1"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "While testing queries for this problem on a local server, I encountered \"Insufficient number of values for placeholders in query\" error. I\\'ve spent, like, 2 hours browsing different forums, and found NO help for the situation I have here. Would really appreciate if someone could help me understand what\\'s the deal here, and/or guided to some sort of documentation on this stuff.\\n\\n<b>PLEASE NOTE: LEETCODE DOES NOT HAVE SUCH AN ISSUE, IT\\'S JUST ABOUT MY LOCAL SERVER.</b>\\nCode in question:\\n\\n`SELECT i1.pid AS pid`\\n`    FROM Insurance AS i1`\\n`    INNER JOIN Insurance AS i2`\\n`    ON i1.lat = i2.lat AND i1.lon = i2.lon AND i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nI feel like what\\'s really going on here, is SQL has trouble linking all of the fields, as exactly same issue arised once I separated one of the conditions into consequent WHERE statement:\\n\\n`SELECT i1.pid AS pid`\\n`FROM Insurance AS i1`\\n`INNER JOIN Insurance AS i2`\\n`ON i1.lat = i2.lat AND i1.lon = i2.lon`\\n`WHERE i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nOnce again, would appreciate any help."
                    },
                    {
                        "username": "sannanakbar56",
                        "content": "\"\"\"select sum(tiv_2016) as tiv_2016 from insurance where \\nlat || lon in (select lat || lon\\nfrom insurance\\ngroup by lat || lon\\nhaving count(*) = 1)\\nand tiv_2015 in (select tiv_2015 from insurance group by tiv_2015 having count(*) > 1)\"\"\""
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect sum(a.TIV_2016) as TIV_2016 from insurance a\\nwhere \\na.TIV_2015 in (select b.TIV_2015 from insurance b where a.PID <> b.PID)\\nand \\n(a.LAT, a.LON) not in (select c.LAT, c.LON from insurance c where a.PID <> c.PID)\\n;"
                    },
                    {
                        "username": "__ppt_29",
                        "content": "WITH tiv AS (\n    SELECT tiv_2015, tiv_2016\n    FROM Insurance \n    GROUP BY CONCAT(lat,lon)\n    HAVING COUNT(\\*)= 1\n),\ntiv_sum AS (\n    SELECT tiv_2015, SUM(tiv_2016) AS tiv_2016\n    FROM tiv\n    GROUP BY tiv_2015\n    HAVING COUNT(\\*) >= 2\n)\n\nSELECT ROUND(SUM(tiv_2016),2) AS tiv_2016\nFROM tiv_sum\n\n\ncan anyone tell me why this isn't working "
                    },
                    {
                        "username": "Almas21",
                        "content": "hi, guys!!\\n\\nCan you explain me the algorith on the following test case:\\n\\n| pid | tiv_2015 | tiv_2016 | lat  | lon  |\\n| --- | -------- | -------- | ---- | ---- |\\n| 1   | 224.17   | 952.73   | 32.4 | 20.2 |\\n| 2   | 224.17   | 900.66   | 52.4 | 32.7 |\\n| 3   | 824.61   | 645.13   | 72.4 | 45.2 |\\n| 4   | 424.32   | 323.66   | 12.4 | 7.7  |\\n| 5   | 424.32   | 282.9    | 12.4 | 7.7  |\\n| 6   | 625.05   | 243.53   | 52.5 | 32.8 |\\n| 7   | 424.32   | 968.94   | 72.5 | 45.3 |\\n| 8   | 624.46   | 714.13   | 12.5 | 7.8  |\\n| 9   | 425.49   | 463.85   | 32.5 | 20.3 |\\n| 10  | 624.46   | 776.85   | 12.4 | 7.7  |\\n| 11  | 624.46   | 692.71   | 72.5 | 45.3 |\\n| 12  | 225.93   | 933      | 12.5 | 7.8  |\\n| 13  | 824.61   | 786.86   | 32.6 | 20.3 |\\n| 14  | 824.61   | 935.34   | 52.6 | 32.8 |\\n| 15  | 826.37   | 516.1    | 12.4 | 7.7  |\\n| 16  | 824.61   | 374.5    | 12.6 | 7.9  |\\n| 17  | 824.61   | 924.19   | 32.6 | 20.4 |\\n| 18  | 626.81   | 897.47   | 52.6 | 32.9 |\\n| 19  | 224.76   | 714.79   | 72.6 | 45.4 |\\n| 20  | 224.76   | 681.53   | 12.4 | 7.7  |\\n| 21  | 427.25   | 263.27   | 32.7 | 20.4 |\\n| 22  | 224.76   | 671.8    | 52.7 | 32.9 |\\n| 23  | 424.9    | 769.18   | 72.7 | 45.4 |\\n| 24  | 227.69   | 830.5    | 12.7 | 7.9  |\\n| 25  | 424.9    | 844.97   | 12.4 | 7.7  |\\n| 26  | 424.9    | 733.35   | 52.7 | 32.9 |\\n| 27  | 828.13   | 931.83   | 72.8 | 45.5 |\\n| 28  | 625.05   | 659.13   | 12.8 | 8    |\\n| 29  | 625.05   | 300.16   | 32.8 | 20.5 |\\n\\nI really could not get what is required."
                    },
                    {
                        "username": "Abdur1997",
                        "content": "SELECT ROUND(SUM(a.TIV_2016), 2) AS TIV_2016\nFROM insurance a\nWHERE EXISTS (\n    SELECT 1\n    FROM insurance b\n    WHERE a.PID <> b.PID AND a.TIV_2015 = b.TIV_2015\n)\nAND NOT EXISTS (\n    SELECT 1\n    FROM insurance c\n    WHERE a.PID <> c.PID AND (a.LAT = c.LAT AND a.LON = c.LON)\n)\n"
                    },
                    {
                        "username": "user1448rE",
                        "content": "Could anyone explain what\\'s wrong with this solution? \\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON) AS LONG, COUNT(LON) OVER (PARTITION BY LAT) AS LATI, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND (LONG=1 OR LATI=1)\\n\\nAbove solution doesn\\'t work but when I changed it to the one below it works fine.\\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON,lat) AS LONG, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND LONG=1"
                    },
                    {
                        "username": "srjefers",
                        "content": "I can explain 💡, on your first solution you has been taking the columns of `lat & lon` as separeted values, there are more like a composite key that you need to concatenate to have the real value and know/understand on which cases are they really being duplicated. By applying the concatenation of both of them, something that you did on the second solution with the `partition by`, you would be able to count each of them and remove duplicated values. The `TIV` columns you got it right 👍"
                    }
                ]
            },
            {
                "id": 1574369,
                "content": [
                    {
                        "username": "henryangela",
                        "content": "# Write your MySQL query statement below\\nselect round(sum(TIV_2016),2) as TIV_2016 from insurance\\nwhere TIV_2015 in\\n(select TIV_2015 from insurance group by TIV_2015 having count(TIV_2015) >1)\\nand concat(LAT, LON) not in\\n(select concat(LAT, LON) from insurance group by LAT, LON having count(concat(LAT, LON)) >1)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "why you use concat in here, you can just couple it in parentheses\\n\\n# Write your MySQL query statement below\\n\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom insurance \\nwhere tiv_2015 in (\\n    select tiv_2015\\n    from insurance\\n    group by tiv_2015\\n    having count(*) >1\\n)\\nand (lat,lon) in (\\n    select lat, lon\\n    from insurance \\n    group by lat,lon\\n    having count(*) = 1\\n)"
                    },
                    {
                        "username": "pittchen",
                        "content": "wtf"
                    },
                    {
                        "username": "sunbo199587",
                        "content": "with cte as \\n(select pid, TIV_2015, TIV_2016, count(concat(lat, lon)) over (partition by concat(lat, lon))as cnt1, count(TIV_2015) over(partition by tiv_2015) as cnt\\nfrom insurance)\\n\\nselect sum(TIV_2016) as TIV_2016 from cte where cnt1=1 and cnt!=1"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "While testing queries for this problem on a local server, I encountered \"Insufficient number of values for placeholders in query\" error. I\\'ve spent, like, 2 hours browsing different forums, and found NO help for the situation I have here. Would really appreciate if someone could help me understand what\\'s the deal here, and/or guided to some sort of documentation on this stuff.\\n\\n<b>PLEASE NOTE: LEETCODE DOES NOT HAVE SUCH AN ISSUE, IT\\'S JUST ABOUT MY LOCAL SERVER.</b>\\nCode in question:\\n\\n`SELECT i1.pid AS pid`\\n`    FROM Insurance AS i1`\\n`    INNER JOIN Insurance AS i2`\\n`    ON i1.lat = i2.lat AND i1.lon = i2.lon AND i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nI feel like what\\'s really going on here, is SQL has trouble linking all of the fields, as exactly same issue arised once I separated one of the conditions into consequent WHERE statement:\\n\\n`SELECT i1.pid AS pid`\\n`FROM Insurance AS i1`\\n`INNER JOIN Insurance AS i2`\\n`ON i1.lat = i2.lat AND i1.lon = i2.lon`\\n`WHERE i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nOnce again, would appreciate any help."
                    },
                    {
                        "username": "sannanakbar56",
                        "content": "\"\"\"select sum(tiv_2016) as tiv_2016 from insurance where \\nlat || lon in (select lat || lon\\nfrom insurance\\ngroup by lat || lon\\nhaving count(*) = 1)\\nand tiv_2015 in (select tiv_2015 from insurance group by tiv_2015 having count(*) > 1)\"\"\""
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect sum(a.TIV_2016) as TIV_2016 from insurance a\\nwhere \\na.TIV_2015 in (select b.TIV_2015 from insurance b where a.PID <> b.PID)\\nand \\n(a.LAT, a.LON) not in (select c.LAT, c.LON from insurance c where a.PID <> c.PID)\\n;"
                    },
                    {
                        "username": "__ppt_29",
                        "content": "WITH tiv AS (\n    SELECT tiv_2015, tiv_2016\n    FROM Insurance \n    GROUP BY CONCAT(lat,lon)\n    HAVING COUNT(\\*)= 1\n),\ntiv_sum AS (\n    SELECT tiv_2015, SUM(tiv_2016) AS tiv_2016\n    FROM tiv\n    GROUP BY tiv_2015\n    HAVING COUNT(\\*) >= 2\n)\n\nSELECT ROUND(SUM(tiv_2016),2) AS tiv_2016\nFROM tiv_sum\n\n\ncan anyone tell me why this isn't working "
                    },
                    {
                        "username": "Almas21",
                        "content": "hi, guys!!\\n\\nCan you explain me the algorith on the following test case:\\n\\n| pid | tiv_2015 | tiv_2016 | lat  | lon  |\\n| --- | -------- | -------- | ---- | ---- |\\n| 1   | 224.17   | 952.73   | 32.4 | 20.2 |\\n| 2   | 224.17   | 900.66   | 52.4 | 32.7 |\\n| 3   | 824.61   | 645.13   | 72.4 | 45.2 |\\n| 4   | 424.32   | 323.66   | 12.4 | 7.7  |\\n| 5   | 424.32   | 282.9    | 12.4 | 7.7  |\\n| 6   | 625.05   | 243.53   | 52.5 | 32.8 |\\n| 7   | 424.32   | 968.94   | 72.5 | 45.3 |\\n| 8   | 624.46   | 714.13   | 12.5 | 7.8  |\\n| 9   | 425.49   | 463.85   | 32.5 | 20.3 |\\n| 10  | 624.46   | 776.85   | 12.4 | 7.7  |\\n| 11  | 624.46   | 692.71   | 72.5 | 45.3 |\\n| 12  | 225.93   | 933      | 12.5 | 7.8  |\\n| 13  | 824.61   | 786.86   | 32.6 | 20.3 |\\n| 14  | 824.61   | 935.34   | 52.6 | 32.8 |\\n| 15  | 826.37   | 516.1    | 12.4 | 7.7  |\\n| 16  | 824.61   | 374.5    | 12.6 | 7.9  |\\n| 17  | 824.61   | 924.19   | 32.6 | 20.4 |\\n| 18  | 626.81   | 897.47   | 52.6 | 32.9 |\\n| 19  | 224.76   | 714.79   | 72.6 | 45.4 |\\n| 20  | 224.76   | 681.53   | 12.4 | 7.7  |\\n| 21  | 427.25   | 263.27   | 32.7 | 20.4 |\\n| 22  | 224.76   | 671.8    | 52.7 | 32.9 |\\n| 23  | 424.9    | 769.18   | 72.7 | 45.4 |\\n| 24  | 227.69   | 830.5    | 12.7 | 7.9  |\\n| 25  | 424.9    | 844.97   | 12.4 | 7.7  |\\n| 26  | 424.9    | 733.35   | 52.7 | 32.9 |\\n| 27  | 828.13   | 931.83   | 72.8 | 45.5 |\\n| 28  | 625.05   | 659.13   | 12.8 | 8    |\\n| 29  | 625.05   | 300.16   | 32.8 | 20.5 |\\n\\nI really could not get what is required."
                    },
                    {
                        "username": "Abdur1997",
                        "content": "SELECT ROUND(SUM(a.TIV_2016), 2) AS TIV_2016\nFROM insurance a\nWHERE EXISTS (\n    SELECT 1\n    FROM insurance b\n    WHERE a.PID <> b.PID AND a.TIV_2015 = b.TIV_2015\n)\nAND NOT EXISTS (\n    SELECT 1\n    FROM insurance c\n    WHERE a.PID <> c.PID AND (a.LAT = c.LAT AND a.LON = c.LON)\n)\n"
                    },
                    {
                        "username": "user1448rE",
                        "content": "Could anyone explain what\\'s wrong with this solution? \\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON) AS LONG, COUNT(LON) OVER (PARTITION BY LAT) AS LATI, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND (LONG=1 OR LATI=1)\\n\\nAbove solution doesn\\'t work but when I changed it to the one below it works fine.\\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON,lat) AS LONG, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND LONG=1"
                    },
                    {
                        "username": "srjefers",
                        "content": "I can explain 💡, on your first solution you has been taking the columns of `lat & lon` as separeted values, there are more like a composite key that you need to concatenate to have the real value and know/understand on which cases are they really being duplicated. By applying the concatenation of both of them, something that you did on the second solution with the `partition by`, you would be able to count each of them and remove duplicated values. The `TIV` columns you got it right 👍"
                    }
                ]
            },
            {
                "id": 1572890,
                "content": [
                    {
                        "username": "henryangela",
                        "content": "# Write your MySQL query statement below\\nselect round(sum(TIV_2016),2) as TIV_2016 from insurance\\nwhere TIV_2015 in\\n(select TIV_2015 from insurance group by TIV_2015 having count(TIV_2015) >1)\\nand concat(LAT, LON) not in\\n(select concat(LAT, LON) from insurance group by LAT, LON having count(concat(LAT, LON)) >1)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "why you use concat in here, you can just couple it in parentheses\\n\\n# Write your MySQL query statement below\\n\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom insurance \\nwhere tiv_2015 in (\\n    select tiv_2015\\n    from insurance\\n    group by tiv_2015\\n    having count(*) >1\\n)\\nand (lat,lon) in (\\n    select lat, lon\\n    from insurance \\n    group by lat,lon\\n    having count(*) = 1\\n)"
                    },
                    {
                        "username": "pittchen",
                        "content": "wtf"
                    },
                    {
                        "username": "sunbo199587",
                        "content": "with cte as \\n(select pid, TIV_2015, TIV_2016, count(concat(lat, lon)) over (partition by concat(lat, lon))as cnt1, count(TIV_2015) over(partition by tiv_2015) as cnt\\nfrom insurance)\\n\\nselect sum(TIV_2016) as TIV_2016 from cte where cnt1=1 and cnt!=1"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "While testing queries for this problem on a local server, I encountered \"Insufficient number of values for placeholders in query\" error. I\\'ve spent, like, 2 hours browsing different forums, and found NO help for the situation I have here. Would really appreciate if someone could help me understand what\\'s the deal here, and/or guided to some sort of documentation on this stuff.\\n\\n<b>PLEASE NOTE: LEETCODE DOES NOT HAVE SUCH AN ISSUE, IT\\'S JUST ABOUT MY LOCAL SERVER.</b>\\nCode in question:\\n\\n`SELECT i1.pid AS pid`\\n`    FROM Insurance AS i1`\\n`    INNER JOIN Insurance AS i2`\\n`    ON i1.lat = i2.lat AND i1.lon = i2.lon AND i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nI feel like what\\'s really going on here, is SQL has trouble linking all of the fields, as exactly same issue arised once I separated one of the conditions into consequent WHERE statement:\\n\\n`SELECT i1.pid AS pid`\\n`FROM Insurance AS i1`\\n`INNER JOIN Insurance AS i2`\\n`ON i1.lat = i2.lat AND i1.lon = i2.lon`\\n`WHERE i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nOnce again, would appreciate any help."
                    },
                    {
                        "username": "sannanakbar56",
                        "content": "\"\"\"select sum(tiv_2016) as tiv_2016 from insurance where \\nlat || lon in (select lat || lon\\nfrom insurance\\ngroup by lat || lon\\nhaving count(*) = 1)\\nand tiv_2015 in (select tiv_2015 from insurance group by tiv_2015 having count(*) > 1)\"\"\""
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect sum(a.TIV_2016) as TIV_2016 from insurance a\\nwhere \\na.TIV_2015 in (select b.TIV_2015 from insurance b where a.PID <> b.PID)\\nand \\n(a.LAT, a.LON) not in (select c.LAT, c.LON from insurance c where a.PID <> c.PID)\\n;"
                    },
                    {
                        "username": "__ppt_29",
                        "content": "WITH tiv AS (\n    SELECT tiv_2015, tiv_2016\n    FROM Insurance \n    GROUP BY CONCAT(lat,lon)\n    HAVING COUNT(\\*)= 1\n),\ntiv_sum AS (\n    SELECT tiv_2015, SUM(tiv_2016) AS tiv_2016\n    FROM tiv\n    GROUP BY tiv_2015\n    HAVING COUNT(\\*) >= 2\n)\n\nSELECT ROUND(SUM(tiv_2016),2) AS tiv_2016\nFROM tiv_sum\n\n\ncan anyone tell me why this isn't working "
                    },
                    {
                        "username": "Almas21",
                        "content": "hi, guys!!\\n\\nCan you explain me the algorith on the following test case:\\n\\n| pid | tiv_2015 | tiv_2016 | lat  | lon  |\\n| --- | -------- | -------- | ---- | ---- |\\n| 1   | 224.17   | 952.73   | 32.4 | 20.2 |\\n| 2   | 224.17   | 900.66   | 52.4 | 32.7 |\\n| 3   | 824.61   | 645.13   | 72.4 | 45.2 |\\n| 4   | 424.32   | 323.66   | 12.4 | 7.7  |\\n| 5   | 424.32   | 282.9    | 12.4 | 7.7  |\\n| 6   | 625.05   | 243.53   | 52.5 | 32.8 |\\n| 7   | 424.32   | 968.94   | 72.5 | 45.3 |\\n| 8   | 624.46   | 714.13   | 12.5 | 7.8  |\\n| 9   | 425.49   | 463.85   | 32.5 | 20.3 |\\n| 10  | 624.46   | 776.85   | 12.4 | 7.7  |\\n| 11  | 624.46   | 692.71   | 72.5 | 45.3 |\\n| 12  | 225.93   | 933      | 12.5 | 7.8  |\\n| 13  | 824.61   | 786.86   | 32.6 | 20.3 |\\n| 14  | 824.61   | 935.34   | 52.6 | 32.8 |\\n| 15  | 826.37   | 516.1    | 12.4 | 7.7  |\\n| 16  | 824.61   | 374.5    | 12.6 | 7.9  |\\n| 17  | 824.61   | 924.19   | 32.6 | 20.4 |\\n| 18  | 626.81   | 897.47   | 52.6 | 32.9 |\\n| 19  | 224.76   | 714.79   | 72.6 | 45.4 |\\n| 20  | 224.76   | 681.53   | 12.4 | 7.7  |\\n| 21  | 427.25   | 263.27   | 32.7 | 20.4 |\\n| 22  | 224.76   | 671.8    | 52.7 | 32.9 |\\n| 23  | 424.9    | 769.18   | 72.7 | 45.4 |\\n| 24  | 227.69   | 830.5    | 12.7 | 7.9  |\\n| 25  | 424.9    | 844.97   | 12.4 | 7.7  |\\n| 26  | 424.9    | 733.35   | 52.7 | 32.9 |\\n| 27  | 828.13   | 931.83   | 72.8 | 45.5 |\\n| 28  | 625.05   | 659.13   | 12.8 | 8    |\\n| 29  | 625.05   | 300.16   | 32.8 | 20.5 |\\n\\nI really could not get what is required."
                    },
                    {
                        "username": "Abdur1997",
                        "content": "SELECT ROUND(SUM(a.TIV_2016), 2) AS TIV_2016\nFROM insurance a\nWHERE EXISTS (\n    SELECT 1\n    FROM insurance b\n    WHERE a.PID <> b.PID AND a.TIV_2015 = b.TIV_2015\n)\nAND NOT EXISTS (\n    SELECT 1\n    FROM insurance c\n    WHERE a.PID <> c.PID AND (a.LAT = c.LAT AND a.LON = c.LON)\n)\n"
                    },
                    {
                        "username": "user1448rE",
                        "content": "Could anyone explain what\\'s wrong with this solution? \\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON) AS LONG, COUNT(LON) OVER (PARTITION BY LAT) AS LATI, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND (LONG=1 OR LATI=1)\\n\\nAbove solution doesn\\'t work but when I changed it to the one below it works fine.\\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON,lat) AS LONG, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND LONG=1"
                    },
                    {
                        "username": "srjefers",
                        "content": "I can explain 💡, on your first solution you has been taking the columns of `lat & lon` as separeted values, there are more like a composite key that you need to concatenate to have the real value and know/understand on which cases are they really being duplicated. By applying the concatenation of both of them, something that you did on the second solution with the `partition by`, you would be able to count each of them and remove duplicated values. The `TIV` columns you got it right 👍"
                    }
                ]
            },
            {
                "id": 2076984,
                "content": [
                    {
                        "username": "henryangela",
                        "content": "# Write your MySQL query statement below\\nselect round(sum(TIV_2016),2) as TIV_2016 from insurance\\nwhere TIV_2015 in\\n(select TIV_2015 from insurance group by TIV_2015 having count(TIV_2015) >1)\\nand concat(LAT, LON) not in\\n(select concat(LAT, LON) from insurance group by LAT, LON having count(concat(LAT, LON)) >1)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "why you use concat in here, you can just couple it in parentheses\\n\\n# Write your MySQL query statement below\\n\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom insurance \\nwhere tiv_2015 in (\\n    select tiv_2015\\n    from insurance\\n    group by tiv_2015\\n    having count(*) >1\\n)\\nand (lat,lon) in (\\n    select lat, lon\\n    from insurance \\n    group by lat,lon\\n    having count(*) = 1\\n)"
                    },
                    {
                        "username": "pittchen",
                        "content": "wtf"
                    },
                    {
                        "username": "sunbo199587",
                        "content": "with cte as \\n(select pid, TIV_2015, TIV_2016, count(concat(lat, lon)) over (partition by concat(lat, lon))as cnt1, count(TIV_2015) over(partition by tiv_2015) as cnt\\nfrom insurance)\\n\\nselect sum(TIV_2016) as TIV_2016 from cte where cnt1=1 and cnt!=1"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "While testing queries for this problem on a local server, I encountered \"Insufficient number of values for placeholders in query\" error. I\\'ve spent, like, 2 hours browsing different forums, and found NO help for the situation I have here. Would really appreciate if someone could help me understand what\\'s the deal here, and/or guided to some sort of documentation on this stuff.\\n\\n<b>PLEASE NOTE: LEETCODE DOES NOT HAVE SUCH AN ISSUE, IT\\'S JUST ABOUT MY LOCAL SERVER.</b>\\nCode in question:\\n\\n`SELECT i1.pid AS pid`\\n`    FROM Insurance AS i1`\\n`    INNER JOIN Insurance AS i2`\\n`    ON i1.lat = i2.lat AND i1.lon = i2.lon AND i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nI feel like what\\'s really going on here, is SQL has trouble linking all of the fields, as exactly same issue arised once I separated one of the conditions into consequent WHERE statement:\\n\\n`SELECT i1.pid AS pid`\\n`FROM Insurance AS i1`\\n`INNER JOIN Insurance AS i2`\\n`ON i1.lat = i2.lat AND i1.lon = i2.lon`\\n`WHERE i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nOnce again, would appreciate any help."
                    },
                    {
                        "username": "sannanakbar56",
                        "content": "\"\"\"select sum(tiv_2016) as tiv_2016 from insurance where \\nlat || lon in (select lat || lon\\nfrom insurance\\ngroup by lat || lon\\nhaving count(*) = 1)\\nand tiv_2015 in (select tiv_2015 from insurance group by tiv_2015 having count(*) > 1)\"\"\""
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect sum(a.TIV_2016) as TIV_2016 from insurance a\\nwhere \\na.TIV_2015 in (select b.TIV_2015 from insurance b where a.PID <> b.PID)\\nand \\n(a.LAT, a.LON) not in (select c.LAT, c.LON from insurance c where a.PID <> c.PID)\\n;"
                    },
                    {
                        "username": "__ppt_29",
                        "content": "WITH tiv AS (\n    SELECT tiv_2015, tiv_2016\n    FROM Insurance \n    GROUP BY CONCAT(lat,lon)\n    HAVING COUNT(\\*)= 1\n),\ntiv_sum AS (\n    SELECT tiv_2015, SUM(tiv_2016) AS tiv_2016\n    FROM tiv\n    GROUP BY tiv_2015\n    HAVING COUNT(\\*) >= 2\n)\n\nSELECT ROUND(SUM(tiv_2016),2) AS tiv_2016\nFROM tiv_sum\n\n\ncan anyone tell me why this isn't working "
                    },
                    {
                        "username": "Almas21",
                        "content": "hi, guys!!\\n\\nCan you explain me the algorith on the following test case:\\n\\n| pid | tiv_2015 | tiv_2016 | lat  | lon  |\\n| --- | -------- | -------- | ---- | ---- |\\n| 1   | 224.17   | 952.73   | 32.4 | 20.2 |\\n| 2   | 224.17   | 900.66   | 52.4 | 32.7 |\\n| 3   | 824.61   | 645.13   | 72.4 | 45.2 |\\n| 4   | 424.32   | 323.66   | 12.4 | 7.7  |\\n| 5   | 424.32   | 282.9    | 12.4 | 7.7  |\\n| 6   | 625.05   | 243.53   | 52.5 | 32.8 |\\n| 7   | 424.32   | 968.94   | 72.5 | 45.3 |\\n| 8   | 624.46   | 714.13   | 12.5 | 7.8  |\\n| 9   | 425.49   | 463.85   | 32.5 | 20.3 |\\n| 10  | 624.46   | 776.85   | 12.4 | 7.7  |\\n| 11  | 624.46   | 692.71   | 72.5 | 45.3 |\\n| 12  | 225.93   | 933      | 12.5 | 7.8  |\\n| 13  | 824.61   | 786.86   | 32.6 | 20.3 |\\n| 14  | 824.61   | 935.34   | 52.6 | 32.8 |\\n| 15  | 826.37   | 516.1    | 12.4 | 7.7  |\\n| 16  | 824.61   | 374.5    | 12.6 | 7.9  |\\n| 17  | 824.61   | 924.19   | 32.6 | 20.4 |\\n| 18  | 626.81   | 897.47   | 52.6 | 32.9 |\\n| 19  | 224.76   | 714.79   | 72.6 | 45.4 |\\n| 20  | 224.76   | 681.53   | 12.4 | 7.7  |\\n| 21  | 427.25   | 263.27   | 32.7 | 20.4 |\\n| 22  | 224.76   | 671.8    | 52.7 | 32.9 |\\n| 23  | 424.9    | 769.18   | 72.7 | 45.4 |\\n| 24  | 227.69   | 830.5    | 12.7 | 7.9  |\\n| 25  | 424.9    | 844.97   | 12.4 | 7.7  |\\n| 26  | 424.9    | 733.35   | 52.7 | 32.9 |\\n| 27  | 828.13   | 931.83   | 72.8 | 45.5 |\\n| 28  | 625.05   | 659.13   | 12.8 | 8    |\\n| 29  | 625.05   | 300.16   | 32.8 | 20.5 |\\n\\nI really could not get what is required."
                    },
                    {
                        "username": "Abdur1997",
                        "content": "SELECT ROUND(SUM(a.TIV_2016), 2) AS TIV_2016\nFROM insurance a\nWHERE EXISTS (\n    SELECT 1\n    FROM insurance b\n    WHERE a.PID <> b.PID AND a.TIV_2015 = b.TIV_2015\n)\nAND NOT EXISTS (\n    SELECT 1\n    FROM insurance c\n    WHERE a.PID <> c.PID AND (a.LAT = c.LAT AND a.LON = c.LON)\n)\n"
                    },
                    {
                        "username": "user1448rE",
                        "content": "Could anyone explain what\\'s wrong with this solution? \\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON) AS LONG, COUNT(LON) OVER (PARTITION BY LAT) AS LATI, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND (LONG=1 OR LATI=1)\\n\\nAbove solution doesn\\'t work but when I changed it to the one below it works fine.\\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON,lat) AS LONG, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND LONG=1"
                    },
                    {
                        "username": "srjefers",
                        "content": "I can explain 💡, on your first solution you has been taking the columns of `lat & lon` as separeted values, there are more like a composite key that you need to concatenate to have the real value and know/understand on which cases are they really being duplicated. By applying the concatenation of both of them, something that you did on the second solution with the `partition by`, you would be able to count each of them and remove duplicated values. The `TIV` columns you got it right 👍"
                    }
                ]
            },
            {
                "id": 2075992,
                "content": [
                    {
                        "username": "henryangela",
                        "content": "# Write your MySQL query statement below\\nselect round(sum(TIV_2016),2) as TIV_2016 from insurance\\nwhere TIV_2015 in\\n(select TIV_2015 from insurance group by TIV_2015 having count(TIV_2015) >1)\\nand concat(LAT, LON) not in\\n(select concat(LAT, LON) from insurance group by LAT, LON having count(concat(LAT, LON)) >1)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "why you use concat in here, you can just couple it in parentheses\\n\\n# Write your MySQL query statement below\\n\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom insurance \\nwhere tiv_2015 in (\\n    select tiv_2015\\n    from insurance\\n    group by tiv_2015\\n    having count(*) >1\\n)\\nand (lat,lon) in (\\n    select lat, lon\\n    from insurance \\n    group by lat,lon\\n    having count(*) = 1\\n)"
                    },
                    {
                        "username": "pittchen",
                        "content": "wtf"
                    },
                    {
                        "username": "sunbo199587",
                        "content": "with cte as \\n(select pid, TIV_2015, TIV_2016, count(concat(lat, lon)) over (partition by concat(lat, lon))as cnt1, count(TIV_2015) over(partition by tiv_2015) as cnt\\nfrom insurance)\\n\\nselect sum(TIV_2016) as TIV_2016 from cte where cnt1=1 and cnt!=1"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "While testing queries for this problem on a local server, I encountered \"Insufficient number of values for placeholders in query\" error. I\\'ve spent, like, 2 hours browsing different forums, and found NO help for the situation I have here. Would really appreciate if someone could help me understand what\\'s the deal here, and/or guided to some sort of documentation on this stuff.\\n\\n<b>PLEASE NOTE: LEETCODE DOES NOT HAVE SUCH AN ISSUE, IT\\'S JUST ABOUT MY LOCAL SERVER.</b>\\nCode in question:\\n\\n`SELECT i1.pid AS pid`\\n`    FROM Insurance AS i1`\\n`    INNER JOIN Insurance AS i2`\\n`    ON i1.lat = i2.lat AND i1.lon = i2.lon AND i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nI feel like what\\'s really going on here, is SQL has trouble linking all of the fields, as exactly same issue arised once I separated one of the conditions into consequent WHERE statement:\\n\\n`SELECT i1.pid AS pid`\\n`FROM Insurance AS i1`\\n`INNER JOIN Insurance AS i2`\\n`ON i1.lat = i2.lat AND i1.lon = i2.lon`\\n`WHERE i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nOnce again, would appreciate any help."
                    },
                    {
                        "username": "sannanakbar56",
                        "content": "\"\"\"select sum(tiv_2016) as tiv_2016 from insurance where \\nlat || lon in (select lat || lon\\nfrom insurance\\ngroup by lat || lon\\nhaving count(*) = 1)\\nand tiv_2015 in (select tiv_2015 from insurance group by tiv_2015 having count(*) > 1)\"\"\""
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect sum(a.TIV_2016) as TIV_2016 from insurance a\\nwhere \\na.TIV_2015 in (select b.TIV_2015 from insurance b where a.PID <> b.PID)\\nand \\n(a.LAT, a.LON) not in (select c.LAT, c.LON from insurance c where a.PID <> c.PID)\\n;"
                    },
                    {
                        "username": "__ppt_29",
                        "content": "WITH tiv AS (\n    SELECT tiv_2015, tiv_2016\n    FROM Insurance \n    GROUP BY CONCAT(lat,lon)\n    HAVING COUNT(\\*)= 1\n),\ntiv_sum AS (\n    SELECT tiv_2015, SUM(tiv_2016) AS tiv_2016\n    FROM tiv\n    GROUP BY tiv_2015\n    HAVING COUNT(\\*) >= 2\n)\n\nSELECT ROUND(SUM(tiv_2016),2) AS tiv_2016\nFROM tiv_sum\n\n\ncan anyone tell me why this isn't working "
                    },
                    {
                        "username": "Almas21",
                        "content": "hi, guys!!\\n\\nCan you explain me the algorith on the following test case:\\n\\n| pid | tiv_2015 | tiv_2016 | lat  | lon  |\\n| --- | -------- | -------- | ---- | ---- |\\n| 1   | 224.17   | 952.73   | 32.4 | 20.2 |\\n| 2   | 224.17   | 900.66   | 52.4 | 32.7 |\\n| 3   | 824.61   | 645.13   | 72.4 | 45.2 |\\n| 4   | 424.32   | 323.66   | 12.4 | 7.7  |\\n| 5   | 424.32   | 282.9    | 12.4 | 7.7  |\\n| 6   | 625.05   | 243.53   | 52.5 | 32.8 |\\n| 7   | 424.32   | 968.94   | 72.5 | 45.3 |\\n| 8   | 624.46   | 714.13   | 12.5 | 7.8  |\\n| 9   | 425.49   | 463.85   | 32.5 | 20.3 |\\n| 10  | 624.46   | 776.85   | 12.4 | 7.7  |\\n| 11  | 624.46   | 692.71   | 72.5 | 45.3 |\\n| 12  | 225.93   | 933      | 12.5 | 7.8  |\\n| 13  | 824.61   | 786.86   | 32.6 | 20.3 |\\n| 14  | 824.61   | 935.34   | 52.6 | 32.8 |\\n| 15  | 826.37   | 516.1    | 12.4 | 7.7  |\\n| 16  | 824.61   | 374.5    | 12.6 | 7.9  |\\n| 17  | 824.61   | 924.19   | 32.6 | 20.4 |\\n| 18  | 626.81   | 897.47   | 52.6 | 32.9 |\\n| 19  | 224.76   | 714.79   | 72.6 | 45.4 |\\n| 20  | 224.76   | 681.53   | 12.4 | 7.7  |\\n| 21  | 427.25   | 263.27   | 32.7 | 20.4 |\\n| 22  | 224.76   | 671.8    | 52.7 | 32.9 |\\n| 23  | 424.9    | 769.18   | 72.7 | 45.4 |\\n| 24  | 227.69   | 830.5    | 12.7 | 7.9  |\\n| 25  | 424.9    | 844.97   | 12.4 | 7.7  |\\n| 26  | 424.9    | 733.35   | 52.7 | 32.9 |\\n| 27  | 828.13   | 931.83   | 72.8 | 45.5 |\\n| 28  | 625.05   | 659.13   | 12.8 | 8    |\\n| 29  | 625.05   | 300.16   | 32.8 | 20.5 |\\n\\nI really could not get what is required."
                    },
                    {
                        "username": "Abdur1997",
                        "content": "SELECT ROUND(SUM(a.TIV_2016), 2) AS TIV_2016\nFROM insurance a\nWHERE EXISTS (\n    SELECT 1\n    FROM insurance b\n    WHERE a.PID <> b.PID AND a.TIV_2015 = b.TIV_2015\n)\nAND NOT EXISTS (\n    SELECT 1\n    FROM insurance c\n    WHERE a.PID <> c.PID AND (a.LAT = c.LAT AND a.LON = c.LON)\n)\n"
                    },
                    {
                        "username": "user1448rE",
                        "content": "Could anyone explain what\\'s wrong with this solution? \\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON) AS LONG, COUNT(LON) OVER (PARTITION BY LAT) AS LATI, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND (LONG=1 OR LATI=1)\\n\\nAbove solution doesn\\'t work but when I changed it to the one below it works fine.\\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON,lat) AS LONG, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND LONG=1"
                    },
                    {
                        "username": "srjefers",
                        "content": "I can explain 💡, on your first solution you has been taking the columns of `lat & lon` as separeted values, there are more like a composite key that you need to concatenate to have the real value and know/understand on which cases are they really being duplicated. By applying the concatenation of both of them, something that you did on the second solution with the `partition by`, you would be able to count each of them and remove duplicated values. The `TIV` columns you got it right 👍"
                    }
                ]
            },
            {
                "id": 2067839,
                "content": [
                    {
                        "username": "henryangela",
                        "content": "# Write your MySQL query statement below\\nselect round(sum(TIV_2016),2) as TIV_2016 from insurance\\nwhere TIV_2015 in\\n(select TIV_2015 from insurance group by TIV_2015 having count(TIV_2015) >1)\\nand concat(LAT, LON) not in\\n(select concat(LAT, LON) from insurance group by LAT, LON having count(concat(LAT, LON)) >1)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "why you use concat in here, you can just couple it in parentheses\\n\\n# Write your MySQL query statement below\\n\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom insurance \\nwhere tiv_2015 in (\\n    select tiv_2015\\n    from insurance\\n    group by tiv_2015\\n    having count(*) >1\\n)\\nand (lat,lon) in (\\n    select lat, lon\\n    from insurance \\n    group by lat,lon\\n    having count(*) = 1\\n)"
                    },
                    {
                        "username": "pittchen",
                        "content": "wtf"
                    },
                    {
                        "username": "sunbo199587",
                        "content": "with cte as \\n(select pid, TIV_2015, TIV_2016, count(concat(lat, lon)) over (partition by concat(lat, lon))as cnt1, count(TIV_2015) over(partition by tiv_2015) as cnt\\nfrom insurance)\\n\\nselect sum(TIV_2016) as TIV_2016 from cte where cnt1=1 and cnt!=1"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "While testing queries for this problem on a local server, I encountered \"Insufficient number of values for placeholders in query\" error. I\\'ve spent, like, 2 hours browsing different forums, and found NO help for the situation I have here. Would really appreciate if someone could help me understand what\\'s the deal here, and/or guided to some sort of documentation on this stuff.\\n\\n<b>PLEASE NOTE: LEETCODE DOES NOT HAVE SUCH AN ISSUE, IT\\'S JUST ABOUT MY LOCAL SERVER.</b>\\nCode in question:\\n\\n`SELECT i1.pid AS pid`\\n`    FROM Insurance AS i1`\\n`    INNER JOIN Insurance AS i2`\\n`    ON i1.lat = i2.lat AND i1.lon = i2.lon AND i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nI feel like what\\'s really going on here, is SQL has trouble linking all of the fields, as exactly same issue arised once I separated one of the conditions into consequent WHERE statement:\\n\\n`SELECT i1.pid AS pid`\\n`FROM Insurance AS i1`\\n`INNER JOIN Insurance AS i2`\\n`ON i1.lat = i2.lat AND i1.lon = i2.lon`\\n`WHERE i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nOnce again, would appreciate any help."
                    },
                    {
                        "username": "sannanakbar56",
                        "content": "\"\"\"select sum(tiv_2016) as tiv_2016 from insurance where \\nlat || lon in (select lat || lon\\nfrom insurance\\ngroup by lat || lon\\nhaving count(*) = 1)\\nand tiv_2015 in (select tiv_2015 from insurance group by tiv_2015 having count(*) > 1)\"\"\""
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect sum(a.TIV_2016) as TIV_2016 from insurance a\\nwhere \\na.TIV_2015 in (select b.TIV_2015 from insurance b where a.PID <> b.PID)\\nand \\n(a.LAT, a.LON) not in (select c.LAT, c.LON from insurance c where a.PID <> c.PID)\\n;"
                    },
                    {
                        "username": "__ppt_29",
                        "content": "WITH tiv AS (\n    SELECT tiv_2015, tiv_2016\n    FROM Insurance \n    GROUP BY CONCAT(lat,lon)\n    HAVING COUNT(\\*)= 1\n),\ntiv_sum AS (\n    SELECT tiv_2015, SUM(tiv_2016) AS tiv_2016\n    FROM tiv\n    GROUP BY tiv_2015\n    HAVING COUNT(\\*) >= 2\n)\n\nSELECT ROUND(SUM(tiv_2016),2) AS tiv_2016\nFROM tiv_sum\n\n\ncan anyone tell me why this isn't working "
                    },
                    {
                        "username": "Almas21",
                        "content": "hi, guys!!\\n\\nCan you explain me the algorith on the following test case:\\n\\n| pid | tiv_2015 | tiv_2016 | lat  | lon  |\\n| --- | -------- | -------- | ---- | ---- |\\n| 1   | 224.17   | 952.73   | 32.4 | 20.2 |\\n| 2   | 224.17   | 900.66   | 52.4 | 32.7 |\\n| 3   | 824.61   | 645.13   | 72.4 | 45.2 |\\n| 4   | 424.32   | 323.66   | 12.4 | 7.7  |\\n| 5   | 424.32   | 282.9    | 12.4 | 7.7  |\\n| 6   | 625.05   | 243.53   | 52.5 | 32.8 |\\n| 7   | 424.32   | 968.94   | 72.5 | 45.3 |\\n| 8   | 624.46   | 714.13   | 12.5 | 7.8  |\\n| 9   | 425.49   | 463.85   | 32.5 | 20.3 |\\n| 10  | 624.46   | 776.85   | 12.4 | 7.7  |\\n| 11  | 624.46   | 692.71   | 72.5 | 45.3 |\\n| 12  | 225.93   | 933      | 12.5 | 7.8  |\\n| 13  | 824.61   | 786.86   | 32.6 | 20.3 |\\n| 14  | 824.61   | 935.34   | 52.6 | 32.8 |\\n| 15  | 826.37   | 516.1    | 12.4 | 7.7  |\\n| 16  | 824.61   | 374.5    | 12.6 | 7.9  |\\n| 17  | 824.61   | 924.19   | 32.6 | 20.4 |\\n| 18  | 626.81   | 897.47   | 52.6 | 32.9 |\\n| 19  | 224.76   | 714.79   | 72.6 | 45.4 |\\n| 20  | 224.76   | 681.53   | 12.4 | 7.7  |\\n| 21  | 427.25   | 263.27   | 32.7 | 20.4 |\\n| 22  | 224.76   | 671.8    | 52.7 | 32.9 |\\n| 23  | 424.9    | 769.18   | 72.7 | 45.4 |\\n| 24  | 227.69   | 830.5    | 12.7 | 7.9  |\\n| 25  | 424.9    | 844.97   | 12.4 | 7.7  |\\n| 26  | 424.9    | 733.35   | 52.7 | 32.9 |\\n| 27  | 828.13   | 931.83   | 72.8 | 45.5 |\\n| 28  | 625.05   | 659.13   | 12.8 | 8    |\\n| 29  | 625.05   | 300.16   | 32.8 | 20.5 |\\n\\nI really could not get what is required."
                    },
                    {
                        "username": "Abdur1997",
                        "content": "SELECT ROUND(SUM(a.TIV_2016), 2) AS TIV_2016\nFROM insurance a\nWHERE EXISTS (\n    SELECT 1\n    FROM insurance b\n    WHERE a.PID <> b.PID AND a.TIV_2015 = b.TIV_2015\n)\nAND NOT EXISTS (\n    SELECT 1\n    FROM insurance c\n    WHERE a.PID <> c.PID AND (a.LAT = c.LAT AND a.LON = c.LON)\n)\n"
                    },
                    {
                        "username": "user1448rE",
                        "content": "Could anyone explain what\\'s wrong with this solution? \\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON) AS LONG, COUNT(LON) OVER (PARTITION BY LAT) AS LATI, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND (LONG=1 OR LATI=1)\\n\\nAbove solution doesn\\'t work but when I changed it to the one below it works fine.\\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON,lat) AS LONG, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND LONG=1"
                    },
                    {
                        "username": "srjefers",
                        "content": "I can explain 💡, on your first solution you has been taking the columns of `lat & lon` as separeted values, there are more like a composite key that you need to concatenate to have the real value and know/understand on which cases are they really being duplicated. By applying the concatenation of both of them, something that you did on the second solution with the `partition by`, you would be able to count each of them and remove duplicated values. The `TIV` columns you got it right 👍"
                    }
                ]
            },
            {
                "id": 2054228,
                "content": [
                    {
                        "username": "henryangela",
                        "content": "# Write your MySQL query statement below\\nselect round(sum(TIV_2016),2) as TIV_2016 from insurance\\nwhere TIV_2015 in\\n(select TIV_2015 from insurance group by TIV_2015 having count(TIV_2015) >1)\\nand concat(LAT, LON) not in\\n(select concat(LAT, LON) from insurance group by LAT, LON having count(concat(LAT, LON)) >1)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "why you use concat in here, you can just couple it in parentheses\\n\\n# Write your MySQL query statement below\\n\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom insurance \\nwhere tiv_2015 in (\\n    select tiv_2015\\n    from insurance\\n    group by tiv_2015\\n    having count(*) >1\\n)\\nand (lat,lon) in (\\n    select lat, lon\\n    from insurance \\n    group by lat,lon\\n    having count(*) = 1\\n)"
                    },
                    {
                        "username": "pittchen",
                        "content": "wtf"
                    },
                    {
                        "username": "sunbo199587",
                        "content": "with cte as \\n(select pid, TIV_2015, TIV_2016, count(concat(lat, lon)) over (partition by concat(lat, lon))as cnt1, count(TIV_2015) over(partition by tiv_2015) as cnt\\nfrom insurance)\\n\\nselect sum(TIV_2016) as TIV_2016 from cte where cnt1=1 and cnt!=1"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "While testing queries for this problem on a local server, I encountered \"Insufficient number of values for placeholders in query\" error. I\\'ve spent, like, 2 hours browsing different forums, and found NO help for the situation I have here. Would really appreciate if someone could help me understand what\\'s the deal here, and/or guided to some sort of documentation on this stuff.\\n\\n<b>PLEASE NOTE: LEETCODE DOES NOT HAVE SUCH AN ISSUE, IT\\'S JUST ABOUT MY LOCAL SERVER.</b>\\nCode in question:\\n\\n`SELECT i1.pid AS pid`\\n`    FROM Insurance AS i1`\\n`    INNER JOIN Insurance AS i2`\\n`    ON i1.lat = i2.lat AND i1.lon = i2.lon AND i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nI feel like what\\'s really going on here, is SQL has trouble linking all of the fields, as exactly same issue arised once I separated one of the conditions into consequent WHERE statement:\\n\\n`SELECT i1.pid AS pid`\\n`FROM Insurance AS i1`\\n`INNER JOIN Insurance AS i2`\\n`ON i1.lat = i2.lat AND i1.lon = i2.lon`\\n`WHERE i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nOnce again, would appreciate any help."
                    },
                    {
                        "username": "sannanakbar56",
                        "content": "\"\"\"select sum(tiv_2016) as tiv_2016 from insurance where \\nlat || lon in (select lat || lon\\nfrom insurance\\ngroup by lat || lon\\nhaving count(*) = 1)\\nand tiv_2015 in (select tiv_2015 from insurance group by tiv_2015 having count(*) > 1)\"\"\""
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect sum(a.TIV_2016) as TIV_2016 from insurance a\\nwhere \\na.TIV_2015 in (select b.TIV_2015 from insurance b where a.PID <> b.PID)\\nand \\n(a.LAT, a.LON) not in (select c.LAT, c.LON from insurance c where a.PID <> c.PID)\\n;"
                    },
                    {
                        "username": "__ppt_29",
                        "content": "WITH tiv AS (\n    SELECT tiv_2015, tiv_2016\n    FROM Insurance \n    GROUP BY CONCAT(lat,lon)\n    HAVING COUNT(\\*)= 1\n),\ntiv_sum AS (\n    SELECT tiv_2015, SUM(tiv_2016) AS tiv_2016\n    FROM tiv\n    GROUP BY tiv_2015\n    HAVING COUNT(\\*) >= 2\n)\n\nSELECT ROUND(SUM(tiv_2016),2) AS tiv_2016\nFROM tiv_sum\n\n\ncan anyone tell me why this isn't working "
                    },
                    {
                        "username": "Almas21",
                        "content": "hi, guys!!\\n\\nCan you explain me the algorith on the following test case:\\n\\n| pid | tiv_2015 | tiv_2016 | lat  | lon  |\\n| --- | -------- | -------- | ---- | ---- |\\n| 1   | 224.17   | 952.73   | 32.4 | 20.2 |\\n| 2   | 224.17   | 900.66   | 52.4 | 32.7 |\\n| 3   | 824.61   | 645.13   | 72.4 | 45.2 |\\n| 4   | 424.32   | 323.66   | 12.4 | 7.7  |\\n| 5   | 424.32   | 282.9    | 12.4 | 7.7  |\\n| 6   | 625.05   | 243.53   | 52.5 | 32.8 |\\n| 7   | 424.32   | 968.94   | 72.5 | 45.3 |\\n| 8   | 624.46   | 714.13   | 12.5 | 7.8  |\\n| 9   | 425.49   | 463.85   | 32.5 | 20.3 |\\n| 10  | 624.46   | 776.85   | 12.4 | 7.7  |\\n| 11  | 624.46   | 692.71   | 72.5 | 45.3 |\\n| 12  | 225.93   | 933      | 12.5 | 7.8  |\\n| 13  | 824.61   | 786.86   | 32.6 | 20.3 |\\n| 14  | 824.61   | 935.34   | 52.6 | 32.8 |\\n| 15  | 826.37   | 516.1    | 12.4 | 7.7  |\\n| 16  | 824.61   | 374.5    | 12.6 | 7.9  |\\n| 17  | 824.61   | 924.19   | 32.6 | 20.4 |\\n| 18  | 626.81   | 897.47   | 52.6 | 32.9 |\\n| 19  | 224.76   | 714.79   | 72.6 | 45.4 |\\n| 20  | 224.76   | 681.53   | 12.4 | 7.7  |\\n| 21  | 427.25   | 263.27   | 32.7 | 20.4 |\\n| 22  | 224.76   | 671.8    | 52.7 | 32.9 |\\n| 23  | 424.9    | 769.18   | 72.7 | 45.4 |\\n| 24  | 227.69   | 830.5    | 12.7 | 7.9  |\\n| 25  | 424.9    | 844.97   | 12.4 | 7.7  |\\n| 26  | 424.9    | 733.35   | 52.7 | 32.9 |\\n| 27  | 828.13   | 931.83   | 72.8 | 45.5 |\\n| 28  | 625.05   | 659.13   | 12.8 | 8    |\\n| 29  | 625.05   | 300.16   | 32.8 | 20.5 |\\n\\nI really could not get what is required."
                    },
                    {
                        "username": "Abdur1997",
                        "content": "SELECT ROUND(SUM(a.TIV_2016), 2) AS TIV_2016\nFROM insurance a\nWHERE EXISTS (\n    SELECT 1\n    FROM insurance b\n    WHERE a.PID <> b.PID AND a.TIV_2015 = b.TIV_2015\n)\nAND NOT EXISTS (\n    SELECT 1\n    FROM insurance c\n    WHERE a.PID <> c.PID AND (a.LAT = c.LAT AND a.LON = c.LON)\n)\n"
                    },
                    {
                        "username": "user1448rE",
                        "content": "Could anyone explain what\\'s wrong with this solution? \\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON) AS LONG, COUNT(LON) OVER (PARTITION BY LAT) AS LATI, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND (LONG=1 OR LATI=1)\\n\\nAbove solution doesn\\'t work but when I changed it to the one below it works fine.\\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON,lat) AS LONG, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND LONG=1"
                    },
                    {
                        "username": "srjefers",
                        "content": "I can explain 💡, on your first solution you has been taking the columns of `lat & lon` as separeted values, there are more like a composite key that you need to concatenate to have the real value and know/understand on which cases are they really being duplicated. By applying the concatenation of both of them, something that you did on the second solution with the `partition by`, you would be able to count each of them and remove duplicated values. The `TIV` columns you got it right 👍"
                    }
                ]
            },
            {
                "id": 1573006,
                "content": [
                    {
                        "username": "henryangela",
                        "content": "# Write your MySQL query statement below\\nselect round(sum(TIV_2016),2) as TIV_2016 from insurance\\nwhere TIV_2015 in\\n(select TIV_2015 from insurance group by TIV_2015 having count(TIV_2015) >1)\\nand concat(LAT, LON) not in\\n(select concat(LAT, LON) from insurance group by LAT, LON having count(concat(LAT, LON)) >1)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "why you use concat in here, you can just couple it in parentheses\\n\\n# Write your MySQL query statement below\\n\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom insurance \\nwhere tiv_2015 in (\\n    select tiv_2015\\n    from insurance\\n    group by tiv_2015\\n    having count(*) >1\\n)\\nand (lat,lon) in (\\n    select lat, lon\\n    from insurance \\n    group by lat,lon\\n    having count(*) = 1\\n)"
                    },
                    {
                        "username": "pittchen",
                        "content": "wtf"
                    },
                    {
                        "username": "sunbo199587",
                        "content": "with cte as \\n(select pid, TIV_2015, TIV_2016, count(concat(lat, lon)) over (partition by concat(lat, lon))as cnt1, count(TIV_2015) over(partition by tiv_2015) as cnt\\nfrom insurance)\\n\\nselect sum(TIV_2016) as TIV_2016 from cte where cnt1=1 and cnt!=1"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "While testing queries for this problem on a local server, I encountered \"Insufficient number of values for placeholders in query\" error. I\\'ve spent, like, 2 hours browsing different forums, and found NO help for the situation I have here. Would really appreciate if someone could help me understand what\\'s the deal here, and/or guided to some sort of documentation on this stuff.\\n\\n<b>PLEASE NOTE: LEETCODE DOES NOT HAVE SUCH AN ISSUE, IT\\'S JUST ABOUT MY LOCAL SERVER.</b>\\nCode in question:\\n\\n`SELECT i1.pid AS pid`\\n`    FROM Insurance AS i1`\\n`    INNER JOIN Insurance AS i2`\\n`    ON i1.lat = i2.lat AND i1.lon = i2.lon AND i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nI feel like what\\'s really going on here, is SQL has trouble linking all of the fields, as exactly same issue arised once I separated one of the conditions into consequent WHERE statement:\\n\\n`SELECT i1.pid AS pid`\\n`FROM Insurance AS i1`\\n`INNER JOIN Insurance AS i2`\\n`ON i1.lat = i2.lat AND i1.lon = i2.lon`\\n`WHERE i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nOnce again, would appreciate any help."
                    },
                    {
                        "username": "sannanakbar56",
                        "content": "\"\"\"select sum(tiv_2016) as tiv_2016 from insurance where \\nlat || lon in (select lat || lon\\nfrom insurance\\ngroup by lat || lon\\nhaving count(*) = 1)\\nand tiv_2015 in (select tiv_2015 from insurance group by tiv_2015 having count(*) > 1)\"\"\""
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect sum(a.TIV_2016) as TIV_2016 from insurance a\\nwhere \\na.TIV_2015 in (select b.TIV_2015 from insurance b where a.PID <> b.PID)\\nand \\n(a.LAT, a.LON) not in (select c.LAT, c.LON from insurance c where a.PID <> c.PID)\\n;"
                    },
                    {
                        "username": "__ppt_29",
                        "content": "WITH tiv AS (\n    SELECT tiv_2015, tiv_2016\n    FROM Insurance \n    GROUP BY CONCAT(lat,lon)\n    HAVING COUNT(\\*)= 1\n),\ntiv_sum AS (\n    SELECT tiv_2015, SUM(tiv_2016) AS tiv_2016\n    FROM tiv\n    GROUP BY tiv_2015\n    HAVING COUNT(\\*) >= 2\n)\n\nSELECT ROUND(SUM(tiv_2016),2) AS tiv_2016\nFROM tiv_sum\n\n\ncan anyone tell me why this isn't working "
                    },
                    {
                        "username": "Almas21",
                        "content": "hi, guys!!\\n\\nCan you explain me the algorith on the following test case:\\n\\n| pid | tiv_2015 | tiv_2016 | lat  | lon  |\\n| --- | -------- | -------- | ---- | ---- |\\n| 1   | 224.17   | 952.73   | 32.4 | 20.2 |\\n| 2   | 224.17   | 900.66   | 52.4 | 32.7 |\\n| 3   | 824.61   | 645.13   | 72.4 | 45.2 |\\n| 4   | 424.32   | 323.66   | 12.4 | 7.7  |\\n| 5   | 424.32   | 282.9    | 12.4 | 7.7  |\\n| 6   | 625.05   | 243.53   | 52.5 | 32.8 |\\n| 7   | 424.32   | 968.94   | 72.5 | 45.3 |\\n| 8   | 624.46   | 714.13   | 12.5 | 7.8  |\\n| 9   | 425.49   | 463.85   | 32.5 | 20.3 |\\n| 10  | 624.46   | 776.85   | 12.4 | 7.7  |\\n| 11  | 624.46   | 692.71   | 72.5 | 45.3 |\\n| 12  | 225.93   | 933      | 12.5 | 7.8  |\\n| 13  | 824.61   | 786.86   | 32.6 | 20.3 |\\n| 14  | 824.61   | 935.34   | 52.6 | 32.8 |\\n| 15  | 826.37   | 516.1    | 12.4 | 7.7  |\\n| 16  | 824.61   | 374.5    | 12.6 | 7.9  |\\n| 17  | 824.61   | 924.19   | 32.6 | 20.4 |\\n| 18  | 626.81   | 897.47   | 52.6 | 32.9 |\\n| 19  | 224.76   | 714.79   | 72.6 | 45.4 |\\n| 20  | 224.76   | 681.53   | 12.4 | 7.7  |\\n| 21  | 427.25   | 263.27   | 32.7 | 20.4 |\\n| 22  | 224.76   | 671.8    | 52.7 | 32.9 |\\n| 23  | 424.9    | 769.18   | 72.7 | 45.4 |\\n| 24  | 227.69   | 830.5    | 12.7 | 7.9  |\\n| 25  | 424.9    | 844.97   | 12.4 | 7.7  |\\n| 26  | 424.9    | 733.35   | 52.7 | 32.9 |\\n| 27  | 828.13   | 931.83   | 72.8 | 45.5 |\\n| 28  | 625.05   | 659.13   | 12.8 | 8    |\\n| 29  | 625.05   | 300.16   | 32.8 | 20.5 |\\n\\nI really could not get what is required."
                    },
                    {
                        "username": "Abdur1997",
                        "content": "SELECT ROUND(SUM(a.TIV_2016), 2) AS TIV_2016\nFROM insurance a\nWHERE EXISTS (\n    SELECT 1\n    FROM insurance b\n    WHERE a.PID <> b.PID AND a.TIV_2015 = b.TIV_2015\n)\nAND NOT EXISTS (\n    SELECT 1\n    FROM insurance c\n    WHERE a.PID <> c.PID AND (a.LAT = c.LAT AND a.LON = c.LON)\n)\n"
                    },
                    {
                        "username": "user1448rE",
                        "content": "Could anyone explain what\\'s wrong with this solution? \\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON) AS LONG, COUNT(LON) OVER (PARTITION BY LAT) AS LATI, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND (LONG=1 OR LATI=1)\\n\\nAbove solution doesn\\'t work but when I changed it to the one below it works fine.\\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON,lat) AS LONG, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND LONG=1"
                    },
                    {
                        "username": "srjefers",
                        "content": "I can explain 💡, on your first solution you has been taking the columns of `lat & lon` as separeted values, there are more like a composite key that you need to concatenate to have the real value and know/understand on which cases are they really being duplicated. By applying the concatenation of both of them, something that you did on the second solution with the `partition by`, you would be able to count each of them and remove duplicated values. The `TIV` columns you got it right 👍"
                    }
                ]
            },
            {
                "id": 2037890,
                "content": [
                    {
                        "username": "henryangela",
                        "content": "# Write your MySQL query statement below\\nselect round(sum(TIV_2016),2) as TIV_2016 from insurance\\nwhere TIV_2015 in\\n(select TIV_2015 from insurance group by TIV_2015 having count(TIV_2015) >1)\\nand concat(LAT, LON) not in\\n(select concat(LAT, LON) from insurance group by LAT, LON having count(concat(LAT, LON)) >1)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "why you use concat in here, you can just couple it in parentheses\\n\\n# Write your MySQL query statement below\\n\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom insurance \\nwhere tiv_2015 in (\\n    select tiv_2015\\n    from insurance\\n    group by tiv_2015\\n    having count(*) >1\\n)\\nand (lat,lon) in (\\n    select lat, lon\\n    from insurance \\n    group by lat,lon\\n    having count(*) = 1\\n)"
                    },
                    {
                        "username": "pittchen",
                        "content": "wtf"
                    },
                    {
                        "username": "sunbo199587",
                        "content": "with cte as \\n(select pid, TIV_2015, TIV_2016, count(concat(lat, lon)) over (partition by concat(lat, lon))as cnt1, count(TIV_2015) over(partition by tiv_2015) as cnt\\nfrom insurance)\\n\\nselect sum(TIV_2016) as TIV_2016 from cte where cnt1=1 and cnt!=1"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "While testing queries for this problem on a local server, I encountered \"Insufficient number of values for placeholders in query\" error. I\\'ve spent, like, 2 hours browsing different forums, and found NO help for the situation I have here. Would really appreciate if someone could help me understand what\\'s the deal here, and/or guided to some sort of documentation on this stuff.\\n\\n<b>PLEASE NOTE: LEETCODE DOES NOT HAVE SUCH AN ISSUE, IT\\'S JUST ABOUT MY LOCAL SERVER.</b>\\nCode in question:\\n\\n`SELECT i1.pid AS pid`\\n`    FROM Insurance AS i1`\\n`    INNER JOIN Insurance AS i2`\\n`    ON i1.lat = i2.lat AND i1.lon = i2.lon AND i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nI feel like what\\'s really going on here, is SQL has trouble linking all of the fields, as exactly same issue arised once I separated one of the conditions into consequent WHERE statement:\\n\\n`SELECT i1.pid AS pid`\\n`FROM Insurance AS i1`\\n`INNER JOIN Insurance AS i2`\\n`ON i1.lat = i2.lat AND i1.lon = i2.lon`\\n`WHERE i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nOnce again, would appreciate any help."
                    },
                    {
                        "username": "sannanakbar56",
                        "content": "\"\"\"select sum(tiv_2016) as tiv_2016 from insurance where \\nlat || lon in (select lat || lon\\nfrom insurance\\ngroup by lat || lon\\nhaving count(*) = 1)\\nand tiv_2015 in (select tiv_2015 from insurance group by tiv_2015 having count(*) > 1)\"\"\""
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect sum(a.TIV_2016) as TIV_2016 from insurance a\\nwhere \\na.TIV_2015 in (select b.TIV_2015 from insurance b where a.PID <> b.PID)\\nand \\n(a.LAT, a.LON) not in (select c.LAT, c.LON from insurance c where a.PID <> c.PID)\\n;"
                    },
                    {
                        "username": "__ppt_29",
                        "content": "WITH tiv AS (\n    SELECT tiv_2015, tiv_2016\n    FROM Insurance \n    GROUP BY CONCAT(lat,lon)\n    HAVING COUNT(\\*)= 1\n),\ntiv_sum AS (\n    SELECT tiv_2015, SUM(tiv_2016) AS tiv_2016\n    FROM tiv\n    GROUP BY tiv_2015\n    HAVING COUNT(\\*) >= 2\n)\n\nSELECT ROUND(SUM(tiv_2016),2) AS tiv_2016\nFROM tiv_sum\n\n\ncan anyone tell me why this isn't working "
                    },
                    {
                        "username": "Almas21",
                        "content": "hi, guys!!\\n\\nCan you explain me the algorith on the following test case:\\n\\n| pid | tiv_2015 | tiv_2016 | lat  | lon  |\\n| --- | -------- | -------- | ---- | ---- |\\n| 1   | 224.17   | 952.73   | 32.4 | 20.2 |\\n| 2   | 224.17   | 900.66   | 52.4 | 32.7 |\\n| 3   | 824.61   | 645.13   | 72.4 | 45.2 |\\n| 4   | 424.32   | 323.66   | 12.4 | 7.7  |\\n| 5   | 424.32   | 282.9    | 12.4 | 7.7  |\\n| 6   | 625.05   | 243.53   | 52.5 | 32.8 |\\n| 7   | 424.32   | 968.94   | 72.5 | 45.3 |\\n| 8   | 624.46   | 714.13   | 12.5 | 7.8  |\\n| 9   | 425.49   | 463.85   | 32.5 | 20.3 |\\n| 10  | 624.46   | 776.85   | 12.4 | 7.7  |\\n| 11  | 624.46   | 692.71   | 72.5 | 45.3 |\\n| 12  | 225.93   | 933      | 12.5 | 7.8  |\\n| 13  | 824.61   | 786.86   | 32.6 | 20.3 |\\n| 14  | 824.61   | 935.34   | 52.6 | 32.8 |\\n| 15  | 826.37   | 516.1    | 12.4 | 7.7  |\\n| 16  | 824.61   | 374.5    | 12.6 | 7.9  |\\n| 17  | 824.61   | 924.19   | 32.6 | 20.4 |\\n| 18  | 626.81   | 897.47   | 52.6 | 32.9 |\\n| 19  | 224.76   | 714.79   | 72.6 | 45.4 |\\n| 20  | 224.76   | 681.53   | 12.4 | 7.7  |\\n| 21  | 427.25   | 263.27   | 32.7 | 20.4 |\\n| 22  | 224.76   | 671.8    | 52.7 | 32.9 |\\n| 23  | 424.9    | 769.18   | 72.7 | 45.4 |\\n| 24  | 227.69   | 830.5    | 12.7 | 7.9  |\\n| 25  | 424.9    | 844.97   | 12.4 | 7.7  |\\n| 26  | 424.9    | 733.35   | 52.7 | 32.9 |\\n| 27  | 828.13   | 931.83   | 72.8 | 45.5 |\\n| 28  | 625.05   | 659.13   | 12.8 | 8    |\\n| 29  | 625.05   | 300.16   | 32.8 | 20.5 |\\n\\nI really could not get what is required."
                    },
                    {
                        "username": "Abdur1997",
                        "content": "SELECT ROUND(SUM(a.TIV_2016), 2) AS TIV_2016\nFROM insurance a\nWHERE EXISTS (\n    SELECT 1\n    FROM insurance b\n    WHERE a.PID <> b.PID AND a.TIV_2015 = b.TIV_2015\n)\nAND NOT EXISTS (\n    SELECT 1\n    FROM insurance c\n    WHERE a.PID <> c.PID AND (a.LAT = c.LAT AND a.LON = c.LON)\n)\n"
                    },
                    {
                        "username": "user1448rE",
                        "content": "Could anyone explain what\\'s wrong with this solution? \\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON) AS LONG, COUNT(LON) OVER (PARTITION BY LAT) AS LATI, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND (LONG=1 OR LATI=1)\\n\\nAbove solution doesn\\'t work but when I changed it to the one below it works fine.\\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON,lat) AS LONG, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND LONG=1"
                    },
                    {
                        "username": "srjefers",
                        "content": "I can explain 💡, on your first solution you has been taking the columns of `lat & lon` as separeted values, there are more like a composite key that you need to concatenate to have the real value and know/understand on which cases are they really being duplicated. By applying the concatenation of both of them, something that you did on the second solution with the `partition by`, you would be able to count each of them and remove duplicated values. The `TIV` columns you got it right 👍"
                    }
                ]
            },
            {
                "id": 1575554,
                "content": [
                    {
                        "username": "henryangela",
                        "content": "# Write your MySQL query statement below\\nselect round(sum(TIV_2016),2) as TIV_2016 from insurance\\nwhere TIV_2015 in\\n(select TIV_2015 from insurance group by TIV_2015 having count(TIV_2015) >1)\\nand concat(LAT, LON) not in\\n(select concat(LAT, LON) from insurance group by LAT, LON having count(concat(LAT, LON)) >1)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "why you use concat in here, you can just couple it in parentheses\\n\\n# Write your MySQL query statement below\\n\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom insurance \\nwhere tiv_2015 in (\\n    select tiv_2015\\n    from insurance\\n    group by tiv_2015\\n    having count(*) >1\\n)\\nand (lat,lon) in (\\n    select lat, lon\\n    from insurance \\n    group by lat,lon\\n    having count(*) = 1\\n)"
                    },
                    {
                        "username": "pittchen",
                        "content": "wtf"
                    },
                    {
                        "username": "sunbo199587",
                        "content": "with cte as \\n(select pid, TIV_2015, TIV_2016, count(concat(lat, lon)) over (partition by concat(lat, lon))as cnt1, count(TIV_2015) over(partition by tiv_2015) as cnt\\nfrom insurance)\\n\\nselect sum(TIV_2016) as TIV_2016 from cte where cnt1=1 and cnt!=1"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "While testing queries for this problem on a local server, I encountered \"Insufficient number of values for placeholders in query\" error. I\\'ve spent, like, 2 hours browsing different forums, and found NO help for the situation I have here. Would really appreciate if someone could help me understand what\\'s the deal here, and/or guided to some sort of documentation on this stuff.\\n\\n<b>PLEASE NOTE: LEETCODE DOES NOT HAVE SUCH AN ISSUE, IT\\'S JUST ABOUT MY LOCAL SERVER.</b>\\nCode in question:\\n\\n`SELECT i1.pid AS pid`\\n`    FROM Insurance AS i1`\\n`    INNER JOIN Insurance AS i2`\\n`    ON i1.lat = i2.lat AND i1.lon = i2.lon AND i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nI feel like what\\'s really going on here, is SQL has trouble linking all of the fields, as exactly same issue arised once I separated one of the conditions into consequent WHERE statement:\\n\\n`SELECT i1.pid AS pid`\\n`FROM Insurance AS i1`\\n`INNER JOIN Insurance AS i2`\\n`ON i1.lat = i2.lat AND i1.lon = i2.lon`\\n`WHERE i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nOnce again, would appreciate any help."
                    },
                    {
                        "username": "sannanakbar56",
                        "content": "\"\"\"select sum(tiv_2016) as tiv_2016 from insurance where \\nlat || lon in (select lat || lon\\nfrom insurance\\ngroup by lat || lon\\nhaving count(*) = 1)\\nand tiv_2015 in (select tiv_2015 from insurance group by tiv_2015 having count(*) > 1)\"\"\""
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect sum(a.TIV_2016) as TIV_2016 from insurance a\\nwhere \\na.TIV_2015 in (select b.TIV_2015 from insurance b where a.PID <> b.PID)\\nand \\n(a.LAT, a.LON) not in (select c.LAT, c.LON from insurance c where a.PID <> c.PID)\\n;"
                    },
                    {
                        "username": "__ppt_29",
                        "content": "WITH tiv AS (\n    SELECT tiv_2015, tiv_2016\n    FROM Insurance \n    GROUP BY CONCAT(lat,lon)\n    HAVING COUNT(\\*)= 1\n),\ntiv_sum AS (\n    SELECT tiv_2015, SUM(tiv_2016) AS tiv_2016\n    FROM tiv\n    GROUP BY tiv_2015\n    HAVING COUNT(\\*) >= 2\n)\n\nSELECT ROUND(SUM(tiv_2016),2) AS tiv_2016\nFROM tiv_sum\n\n\ncan anyone tell me why this isn't working "
                    },
                    {
                        "username": "Almas21",
                        "content": "hi, guys!!\\n\\nCan you explain me the algorith on the following test case:\\n\\n| pid | tiv_2015 | tiv_2016 | lat  | lon  |\\n| --- | -------- | -------- | ---- | ---- |\\n| 1   | 224.17   | 952.73   | 32.4 | 20.2 |\\n| 2   | 224.17   | 900.66   | 52.4 | 32.7 |\\n| 3   | 824.61   | 645.13   | 72.4 | 45.2 |\\n| 4   | 424.32   | 323.66   | 12.4 | 7.7  |\\n| 5   | 424.32   | 282.9    | 12.4 | 7.7  |\\n| 6   | 625.05   | 243.53   | 52.5 | 32.8 |\\n| 7   | 424.32   | 968.94   | 72.5 | 45.3 |\\n| 8   | 624.46   | 714.13   | 12.5 | 7.8  |\\n| 9   | 425.49   | 463.85   | 32.5 | 20.3 |\\n| 10  | 624.46   | 776.85   | 12.4 | 7.7  |\\n| 11  | 624.46   | 692.71   | 72.5 | 45.3 |\\n| 12  | 225.93   | 933      | 12.5 | 7.8  |\\n| 13  | 824.61   | 786.86   | 32.6 | 20.3 |\\n| 14  | 824.61   | 935.34   | 52.6 | 32.8 |\\n| 15  | 826.37   | 516.1    | 12.4 | 7.7  |\\n| 16  | 824.61   | 374.5    | 12.6 | 7.9  |\\n| 17  | 824.61   | 924.19   | 32.6 | 20.4 |\\n| 18  | 626.81   | 897.47   | 52.6 | 32.9 |\\n| 19  | 224.76   | 714.79   | 72.6 | 45.4 |\\n| 20  | 224.76   | 681.53   | 12.4 | 7.7  |\\n| 21  | 427.25   | 263.27   | 32.7 | 20.4 |\\n| 22  | 224.76   | 671.8    | 52.7 | 32.9 |\\n| 23  | 424.9    | 769.18   | 72.7 | 45.4 |\\n| 24  | 227.69   | 830.5    | 12.7 | 7.9  |\\n| 25  | 424.9    | 844.97   | 12.4 | 7.7  |\\n| 26  | 424.9    | 733.35   | 52.7 | 32.9 |\\n| 27  | 828.13   | 931.83   | 72.8 | 45.5 |\\n| 28  | 625.05   | 659.13   | 12.8 | 8    |\\n| 29  | 625.05   | 300.16   | 32.8 | 20.5 |\\n\\nI really could not get what is required."
                    },
                    {
                        "username": "Abdur1997",
                        "content": "SELECT ROUND(SUM(a.TIV_2016), 2) AS TIV_2016\nFROM insurance a\nWHERE EXISTS (\n    SELECT 1\n    FROM insurance b\n    WHERE a.PID <> b.PID AND a.TIV_2015 = b.TIV_2015\n)\nAND NOT EXISTS (\n    SELECT 1\n    FROM insurance c\n    WHERE a.PID <> c.PID AND (a.LAT = c.LAT AND a.LON = c.LON)\n)\n"
                    },
                    {
                        "username": "user1448rE",
                        "content": "Could anyone explain what\\'s wrong with this solution? \\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON) AS LONG, COUNT(LON) OVER (PARTITION BY LAT) AS LATI, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND (LONG=1 OR LATI=1)\\n\\nAbove solution doesn\\'t work but when I changed it to the one below it works fine.\\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON,lat) AS LONG, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND LONG=1"
                    },
                    {
                        "username": "srjefers",
                        "content": "I can explain 💡, on your first solution you has been taking the columns of `lat & lon` as separeted values, there are more like a composite key that you need to concatenate to have the real value and know/understand on which cases are they really being duplicated. By applying the concatenation of both of them, something that you did on the second solution with the `partition by`, you would be able to count each of them and remove duplicated values. The `TIV` columns you got it right 👍"
                    }
                ]
            },
            {
                "id": 1934980,
                "content": [
                    {
                        "username": "henryangela",
                        "content": "# Write your MySQL query statement below\\nselect round(sum(TIV_2016),2) as TIV_2016 from insurance\\nwhere TIV_2015 in\\n(select TIV_2015 from insurance group by TIV_2015 having count(TIV_2015) >1)\\nand concat(LAT, LON) not in\\n(select concat(LAT, LON) from insurance group by LAT, LON having count(concat(LAT, LON)) >1)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "why you use concat in here, you can just couple it in parentheses\\n\\n# Write your MySQL query statement below\\n\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom insurance \\nwhere tiv_2015 in (\\n    select tiv_2015\\n    from insurance\\n    group by tiv_2015\\n    having count(*) >1\\n)\\nand (lat,lon) in (\\n    select lat, lon\\n    from insurance \\n    group by lat,lon\\n    having count(*) = 1\\n)"
                    },
                    {
                        "username": "pittchen",
                        "content": "wtf"
                    },
                    {
                        "username": "sunbo199587",
                        "content": "with cte as \\n(select pid, TIV_2015, TIV_2016, count(concat(lat, lon)) over (partition by concat(lat, lon))as cnt1, count(TIV_2015) over(partition by tiv_2015) as cnt\\nfrom insurance)\\n\\nselect sum(TIV_2016) as TIV_2016 from cte where cnt1=1 and cnt!=1"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "While testing queries for this problem on a local server, I encountered \"Insufficient number of values for placeholders in query\" error. I\\'ve spent, like, 2 hours browsing different forums, and found NO help for the situation I have here. Would really appreciate if someone could help me understand what\\'s the deal here, and/or guided to some sort of documentation on this stuff.\\n\\n<b>PLEASE NOTE: LEETCODE DOES NOT HAVE SUCH AN ISSUE, IT\\'S JUST ABOUT MY LOCAL SERVER.</b>\\nCode in question:\\n\\n`SELECT i1.pid AS pid`\\n`    FROM Insurance AS i1`\\n`    INNER JOIN Insurance AS i2`\\n`    ON i1.lat = i2.lat AND i1.lon = i2.lon AND i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nI feel like what\\'s really going on here, is SQL has trouble linking all of the fields, as exactly same issue arised once I separated one of the conditions into consequent WHERE statement:\\n\\n`SELECT i1.pid AS pid`\\n`FROM Insurance AS i1`\\n`INNER JOIN Insurance AS i2`\\n`ON i1.lat = i2.lat AND i1.lon = i2.lon`\\n`WHERE i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nOnce again, would appreciate any help."
                    },
                    {
                        "username": "sannanakbar56",
                        "content": "\"\"\"select sum(tiv_2016) as tiv_2016 from insurance where \\nlat || lon in (select lat || lon\\nfrom insurance\\ngroup by lat || lon\\nhaving count(*) = 1)\\nand tiv_2015 in (select tiv_2015 from insurance group by tiv_2015 having count(*) > 1)\"\"\""
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect sum(a.TIV_2016) as TIV_2016 from insurance a\\nwhere \\na.TIV_2015 in (select b.TIV_2015 from insurance b where a.PID <> b.PID)\\nand \\n(a.LAT, a.LON) not in (select c.LAT, c.LON from insurance c where a.PID <> c.PID)\\n;"
                    },
                    {
                        "username": "__ppt_29",
                        "content": "WITH tiv AS (\n    SELECT tiv_2015, tiv_2016\n    FROM Insurance \n    GROUP BY CONCAT(lat,lon)\n    HAVING COUNT(\\*)= 1\n),\ntiv_sum AS (\n    SELECT tiv_2015, SUM(tiv_2016) AS tiv_2016\n    FROM tiv\n    GROUP BY tiv_2015\n    HAVING COUNT(\\*) >= 2\n)\n\nSELECT ROUND(SUM(tiv_2016),2) AS tiv_2016\nFROM tiv_sum\n\n\ncan anyone tell me why this isn't working "
                    },
                    {
                        "username": "Almas21",
                        "content": "hi, guys!!\\n\\nCan you explain me the algorith on the following test case:\\n\\n| pid | tiv_2015 | tiv_2016 | lat  | lon  |\\n| --- | -------- | -------- | ---- | ---- |\\n| 1   | 224.17   | 952.73   | 32.4 | 20.2 |\\n| 2   | 224.17   | 900.66   | 52.4 | 32.7 |\\n| 3   | 824.61   | 645.13   | 72.4 | 45.2 |\\n| 4   | 424.32   | 323.66   | 12.4 | 7.7  |\\n| 5   | 424.32   | 282.9    | 12.4 | 7.7  |\\n| 6   | 625.05   | 243.53   | 52.5 | 32.8 |\\n| 7   | 424.32   | 968.94   | 72.5 | 45.3 |\\n| 8   | 624.46   | 714.13   | 12.5 | 7.8  |\\n| 9   | 425.49   | 463.85   | 32.5 | 20.3 |\\n| 10  | 624.46   | 776.85   | 12.4 | 7.7  |\\n| 11  | 624.46   | 692.71   | 72.5 | 45.3 |\\n| 12  | 225.93   | 933      | 12.5 | 7.8  |\\n| 13  | 824.61   | 786.86   | 32.6 | 20.3 |\\n| 14  | 824.61   | 935.34   | 52.6 | 32.8 |\\n| 15  | 826.37   | 516.1    | 12.4 | 7.7  |\\n| 16  | 824.61   | 374.5    | 12.6 | 7.9  |\\n| 17  | 824.61   | 924.19   | 32.6 | 20.4 |\\n| 18  | 626.81   | 897.47   | 52.6 | 32.9 |\\n| 19  | 224.76   | 714.79   | 72.6 | 45.4 |\\n| 20  | 224.76   | 681.53   | 12.4 | 7.7  |\\n| 21  | 427.25   | 263.27   | 32.7 | 20.4 |\\n| 22  | 224.76   | 671.8    | 52.7 | 32.9 |\\n| 23  | 424.9    | 769.18   | 72.7 | 45.4 |\\n| 24  | 227.69   | 830.5    | 12.7 | 7.9  |\\n| 25  | 424.9    | 844.97   | 12.4 | 7.7  |\\n| 26  | 424.9    | 733.35   | 52.7 | 32.9 |\\n| 27  | 828.13   | 931.83   | 72.8 | 45.5 |\\n| 28  | 625.05   | 659.13   | 12.8 | 8    |\\n| 29  | 625.05   | 300.16   | 32.8 | 20.5 |\\n\\nI really could not get what is required."
                    },
                    {
                        "username": "Abdur1997",
                        "content": "SELECT ROUND(SUM(a.TIV_2016), 2) AS TIV_2016\nFROM insurance a\nWHERE EXISTS (\n    SELECT 1\n    FROM insurance b\n    WHERE a.PID <> b.PID AND a.TIV_2015 = b.TIV_2015\n)\nAND NOT EXISTS (\n    SELECT 1\n    FROM insurance c\n    WHERE a.PID <> c.PID AND (a.LAT = c.LAT AND a.LON = c.LON)\n)\n"
                    },
                    {
                        "username": "user1448rE",
                        "content": "Could anyone explain what\\'s wrong with this solution? \\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON) AS LONG, COUNT(LON) OVER (PARTITION BY LAT) AS LATI, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND (LONG=1 OR LATI=1)\\n\\nAbove solution doesn\\'t work but when I changed it to the one below it works fine.\\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON,lat) AS LONG, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND LONG=1"
                    },
                    {
                        "username": "srjefers",
                        "content": "I can explain 💡, on your first solution you has been taking the columns of `lat & lon` as separeted values, there are more like a composite key that you need to concatenate to have the real value and know/understand on which cases are they really being duplicated. By applying the concatenation of both of them, something that you did on the second solution with the `partition by`, you would be able to count each of them and remove duplicated values. The `TIV` columns you got it right 👍"
                    }
                ]
            },
            {
                "id": 1574369,
                "content": [
                    {
                        "username": "henryangela",
                        "content": "# Write your MySQL query statement below\\nselect round(sum(TIV_2016),2) as TIV_2016 from insurance\\nwhere TIV_2015 in\\n(select TIV_2015 from insurance group by TIV_2015 having count(TIV_2015) >1)\\nand concat(LAT, LON) not in\\n(select concat(LAT, LON) from insurance group by LAT, LON having count(concat(LAT, LON)) >1)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "why you use concat in here, you can just couple it in parentheses\\n\\n# Write your MySQL query statement below\\n\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom insurance \\nwhere tiv_2015 in (\\n    select tiv_2015\\n    from insurance\\n    group by tiv_2015\\n    having count(*) >1\\n)\\nand (lat,lon) in (\\n    select lat, lon\\n    from insurance \\n    group by lat,lon\\n    having count(*) = 1\\n)"
                    },
                    {
                        "username": "pittchen",
                        "content": "wtf"
                    },
                    {
                        "username": "sunbo199587",
                        "content": "with cte as \\n(select pid, TIV_2015, TIV_2016, count(concat(lat, lon)) over (partition by concat(lat, lon))as cnt1, count(TIV_2015) over(partition by tiv_2015) as cnt\\nfrom insurance)\\n\\nselect sum(TIV_2016) as TIV_2016 from cte where cnt1=1 and cnt!=1"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "While testing queries for this problem on a local server, I encountered \"Insufficient number of values for placeholders in query\" error. I\\'ve spent, like, 2 hours browsing different forums, and found NO help for the situation I have here. Would really appreciate if someone could help me understand what\\'s the deal here, and/or guided to some sort of documentation on this stuff.\\n\\n<b>PLEASE NOTE: LEETCODE DOES NOT HAVE SUCH AN ISSUE, IT\\'S JUST ABOUT MY LOCAL SERVER.</b>\\nCode in question:\\n\\n`SELECT i1.pid AS pid`\\n`    FROM Insurance AS i1`\\n`    INNER JOIN Insurance AS i2`\\n`    ON i1.lat = i2.lat AND i1.lon = i2.lon AND i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nI feel like what\\'s really going on here, is SQL has trouble linking all of the fields, as exactly same issue arised once I separated one of the conditions into consequent WHERE statement:\\n\\n`SELECT i1.pid AS pid`\\n`FROM Insurance AS i1`\\n`INNER JOIN Insurance AS i2`\\n`ON i1.lat = i2.lat AND i1.lon = i2.lon`\\n`WHERE i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nOnce again, would appreciate any help."
                    },
                    {
                        "username": "sannanakbar56",
                        "content": "\"\"\"select sum(tiv_2016) as tiv_2016 from insurance where \\nlat || lon in (select lat || lon\\nfrom insurance\\ngroup by lat || lon\\nhaving count(*) = 1)\\nand tiv_2015 in (select tiv_2015 from insurance group by tiv_2015 having count(*) > 1)\"\"\""
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect sum(a.TIV_2016) as TIV_2016 from insurance a\\nwhere \\na.TIV_2015 in (select b.TIV_2015 from insurance b where a.PID <> b.PID)\\nand \\n(a.LAT, a.LON) not in (select c.LAT, c.LON from insurance c where a.PID <> c.PID)\\n;"
                    },
                    {
                        "username": "__ppt_29",
                        "content": "WITH tiv AS (\n    SELECT tiv_2015, tiv_2016\n    FROM Insurance \n    GROUP BY CONCAT(lat,lon)\n    HAVING COUNT(\\*)= 1\n),\ntiv_sum AS (\n    SELECT tiv_2015, SUM(tiv_2016) AS tiv_2016\n    FROM tiv\n    GROUP BY tiv_2015\n    HAVING COUNT(\\*) >= 2\n)\n\nSELECT ROUND(SUM(tiv_2016),2) AS tiv_2016\nFROM tiv_sum\n\n\ncan anyone tell me why this isn't working "
                    },
                    {
                        "username": "Almas21",
                        "content": "hi, guys!!\\n\\nCan you explain me the algorith on the following test case:\\n\\n| pid | tiv_2015 | tiv_2016 | lat  | lon  |\\n| --- | -------- | -------- | ---- | ---- |\\n| 1   | 224.17   | 952.73   | 32.4 | 20.2 |\\n| 2   | 224.17   | 900.66   | 52.4 | 32.7 |\\n| 3   | 824.61   | 645.13   | 72.4 | 45.2 |\\n| 4   | 424.32   | 323.66   | 12.4 | 7.7  |\\n| 5   | 424.32   | 282.9    | 12.4 | 7.7  |\\n| 6   | 625.05   | 243.53   | 52.5 | 32.8 |\\n| 7   | 424.32   | 968.94   | 72.5 | 45.3 |\\n| 8   | 624.46   | 714.13   | 12.5 | 7.8  |\\n| 9   | 425.49   | 463.85   | 32.5 | 20.3 |\\n| 10  | 624.46   | 776.85   | 12.4 | 7.7  |\\n| 11  | 624.46   | 692.71   | 72.5 | 45.3 |\\n| 12  | 225.93   | 933      | 12.5 | 7.8  |\\n| 13  | 824.61   | 786.86   | 32.6 | 20.3 |\\n| 14  | 824.61   | 935.34   | 52.6 | 32.8 |\\n| 15  | 826.37   | 516.1    | 12.4 | 7.7  |\\n| 16  | 824.61   | 374.5    | 12.6 | 7.9  |\\n| 17  | 824.61   | 924.19   | 32.6 | 20.4 |\\n| 18  | 626.81   | 897.47   | 52.6 | 32.9 |\\n| 19  | 224.76   | 714.79   | 72.6 | 45.4 |\\n| 20  | 224.76   | 681.53   | 12.4 | 7.7  |\\n| 21  | 427.25   | 263.27   | 32.7 | 20.4 |\\n| 22  | 224.76   | 671.8    | 52.7 | 32.9 |\\n| 23  | 424.9    | 769.18   | 72.7 | 45.4 |\\n| 24  | 227.69   | 830.5    | 12.7 | 7.9  |\\n| 25  | 424.9    | 844.97   | 12.4 | 7.7  |\\n| 26  | 424.9    | 733.35   | 52.7 | 32.9 |\\n| 27  | 828.13   | 931.83   | 72.8 | 45.5 |\\n| 28  | 625.05   | 659.13   | 12.8 | 8    |\\n| 29  | 625.05   | 300.16   | 32.8 | 20.5 |\\n\\nI really could not get what is required."
                    },
                    {
                        "username": "Abdur1997",
                        "content": "SELECT ROUND(SUM(a.TIV_2016), 2) AS TIV_2016\nFROM insurance a\nWHERE EXISTS (\n    SELECT 1\n    FROM insurance b\n    WHERE a.PID <> b.PID AND a.TIV_2015 = b.TIV_2015\n)\nAND NOT EXISTS (\n    SELECT 1\n    FROM insurance c\n    WHERE a.PID <> c.PID AND (a.LAT = c.LAT AND a.LON = c.LON)\n)\n"
                    },
                    {
                        "username": "user1448rE",
                        "content": "Could anyone explain what\\'s wrong with this solution? \\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON) AS LONG, COUNT(LON) OVER (PARTITION BY LAT) AS LATI, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND (LONG=1 OR LATI=1)\\n\\nAbove solution doesn\\'t work but when I changed it to the one below it works fine.\\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON,lat) AS LONG, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND LONG=1"
                    },
                    {
                        "username": "srjefers",
                        "content": "I can explain 💡, on your first solution you has been taking the columns of `lat & lon` as separeted values, there are more like a composite key that you need to concatenate to have the real value and know/understand on which cases are they really being duplicated. By applying the concatenation of both of them, something that you did on the second solution with the `partition by`, you would be able to count each of them and remove duplicated values. The `TIV` columns you got it right 👍"
                    }
                ]
            },
            {
                "id": 1572890,
                "content": [
                    {
                        "username": "henryangela",
                        "content": "# Write your MySQL query statement below\\nselect round(sum(TIV_2016),2) as TIV_2016 from insurance\\nwhere TIV_2015 in\\n(select TIV_2015 from insurance group by TIV_2015 having count(TIV_2015) >1)\\nand concat(LAT, LON) not in\\n(select concat(LAT, LON) from insurance group by LAT, LON having count(concat(LAT, LON)) >1)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "why you use concat in here, you can just couple it in parentheses\\n\\n# Write your MySQL query statement below\\n\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom insurance \\nwhere tiv_2015 in (\\n    select tiv_2015\\n    from insurance\\n    group by tiv_2015\\n    having count(*) >1\\n)\\nand (lat,lon) in (\\n    select lat, lon\\n    from insurance \\n    group by lat,lon\\n    having count(*) = 1\\n)"
                    },
                    {
                        "username": "pittchen",
                        "content": "wtf"
                    },
                    {
                        "username": "sunbo199587",
                        "content": "with cte as \\n(select pid, TIV_2015, TIV_2016, count(concat(lat, lon)) over (partition by concat(lat, lon))as cnt1, count(TIV_2015) over(partition by tiv_2015) as cnt\\nfrom insurance)\\n\\nselect sum(TIV_2016) as TIV_2016 from cte where cnt1=1 and cnt!=1"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "While testing queries for this problem on a local server, I encountered \"Insufficient number of values for placeholders in query\" error. I\\'ve spent, like, 2 hours browsing different forums, and found NO help for the situation I have here. Would really appreciate if someone could help me understand what\\'s the deal here, and/or guided to some sort of documentation on this stuff.\\n\\n<b>PLEASE NOTE: LEETCODE DOES NOT HAVE SUCH AN ISSUE, IT\\'S JUST ABOUT MY LOCAL SERVER.</b>\\nCode in question:\\n\\n`SELECT i1.pid AS pid`\\n`    FROM Insurance AS i1`\\n`    INNER JOIN Insurance AS i2`\\n`    ON i1.lat = i2.lat AND i1.lon = i2.lon AND i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nI feel like what\\'s really going on here, is SQL has trouble linking all of the fields, as exactly same issue arised once I separated one of the conditions into consequent WHERE statement:\\n\\n`SELECT i1.pid AS pid`\\n`FROM Insurance AS i1`\\n`INNER JOIN Insurance AS i2`\\n`ON i1.lat = i2.lat AND i1.lon = i2.lon`\\n`WHERE i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nOnce again, would appreciate any help."
                    },
                    {
                        "username": "sannanakbar56",
                        "content": "\"\"\"select sum(tiv_2016) as tiv_2016 from insurance where \\nlat || lon in (select lat || lon\\nfrom insurance\\ngroup by lat || lon\\nhaving count(*) = 1)\\nand tiv_2015 in (select tiv_2015 from insurance group by tiv_2015 having count(*) > 1)\"\"\""
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect sum(a.TIV_2016) as TIV_2016 from insurance a\\nwhere \\na.TIV_2015 in (select b.TIV_2015 from insurance b where a.PID <> b.PID)\\nand \\n(a.LAT, a.LON) not in (select c.LAT, c.LON from insurance c where a.PID <> c.PID)\\n;"
                    },
                    {
                        "username": "__ppt_29",
                        "content": "WITH tiv AS (\n    SELECT tiv_2015, tiv_2016\n    FROM Insurance \n    GROUP BY CONCAT(lat,lon)\n    HAVING COUNT(\\*)= 1\n),\ntiv_sum AS (\n    SELECT tiv_2015, SUM(tiv_2016) AS tiv_2016\n    FROM tiv\n    GROUP BY tiv_2015\n    HAVING COUNT(\\*) >= 2\n)\n\nSELECT ROUND(SUM(tiv_2016),2) AS tiv_2016\nFROM tiv_sum\n\n\ncan anyone tell me why this isn't working "
                    },
                    {
                        "username": "Almas21",
                        "content": "hi, guys!!\\n\\nCan you explain me the algorith on the following test case:\\n\\n| pid | tiv_2015 | tiv_2016 | lat  | lon  |\\n| --- | -------- | -------- | ---- | ---- |\\n| 1   | 224.17   | 952.73   | 32.4 | 20.2 |\\n| 2   | 224.17   | 900.66   | 52.4 | 32.7 |\\n| 3   | 824.61   | 645.13   | 72.4 | 45.2 |\\n| 4   | 424.32   | 323.66   | 12.4 | 7.7  |\\n| 5   | 424.32   | 282.9    | 12.4 | 7.7  |\\n| 6   | 625.05   | 243.53   | 52.5 | 32.8 |\\n| 7   | 424.32   | 968.94   | 72.5 | 45.3 |\\n| 8   | 624.46   | 714.13   | 12.5 | 7.8  |\\n| 9   | 425.49   | 463.85   | 32.5 | 20.3 |\\n| 10  | 624.46   | 776.85   | 12.4 | 7.7  |\\n| 11  | 624.46   | 692.71   | 72.5 | 45.3 |\\n| 12  | 225.93   | 933      | 12.5 | 7.8  |\\n| 13  | 824.61   | 786.86   | 32.6 | 20.3 |\\n| 14  | 824.61   | 935.34   | 52.6 | 32.8 |\\n| 15  | 826.37   | 516.1    | 12.4 | 7.7  |\\n| 16  | 824.61   | 374.5    | 12.6 | 7.9  |\\n| 17  | 824.61   | 924.19   | 32.6 | 20.4 |\\n| 18  | 626.81   | 897.47   | 52.6 | 32.9 |\\n| 19  | 224.76   | 714.79   | 72.6 | 45.4 |\\n| 20  | 224.76   | 681.53   | 12.4 | 7.7  |\\n| 21  | 427.25   | 263.27   | 32.7 | 20.4 |\\n| 22  | 224.76   | 671.8    | 52.7 | 32.9 |\\n| 23  | 424.9    | 769.18   | 72.7 | 45.4 |\\n| 24  | 227.69   | 830.5    | 12.7 | 7.9  |\\n| 25  | 424.9    | 844.97   | 12.4 | 7.7  |\\n| 26  | 424.9    | 733.35   | 52.7 | 32.9 |\\n| 27  | 828.13   | 931.83   | 72.8 | 45.5 |\\n| 28  | 625.05   | 659.13   | 12.8 | 8    |\\n| 29  | 625.05   | 300.16   | 32.8 | 20.5 |\\n\\nI really could not get what is required."
                    },
                    {
                        "username": "Abdur1997",
                        "content": "SELECT ROUND(SUM(a.TIV_2016), 2) AS TIV_2016\nFROM insurance a\nWHERE EXISTS (\n    SELECT 1\n    FROM insurance b\n    WHERE a.PID <> b.PID AND a.TIV_2015 = b.TIV_2015\n)\nAND NOT EXISTS (\n    SELECT 1\n    FROM insurance c\n    WHERE a.PID <> c.PID AND (a.LAT = c.LAT AND a.LON = c.LON)\n)\n"
                    },
                    {
                        "username": "user1448rE",
                        "content": "Could anyone explain what\\'s wrong with this solution? \\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON) AS LONG, COUNT(LON) OVER (PARTITION BY LAT) AS LATI, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND (LONG=1 OR LATI=1)\\n\\nAbove solution doesn\\'t work but when I changed it to the one below it works fine.\\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON,lat) AS LONG, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND LONG=1"
                    },
                    {
                        "username": "srjefers",
                        "content": "I can explain 💡, on your first solution you has been taking the columns of `lat & lon` as separeted values, there are more like a composite key that you need to concatenate to have the real value and know/understand on which cases are they really being duplicated. By applying the concatenation of both of them, something that you did on the second solution with the `partition by`, you would be able to count each of them and remove duplicated values. The `TIV` columns you got it right 👍"
                    }
                ]
            },
            {
                "id": 2076984,
                "content": [
                    {
                        "username": "henryangela",
                        "content": "# Write your MySQL query statement below\\nselect round(sum(TIV_2016),2) as TIV_2016 from insurance\\nwhere TIV_2015 in\\n(select TIV_2015 from insurance group by TIV_2015 having count(TIV_2015) >1)\\nand concat(LAT, LON) not in\\n(select concat(LAT, LON) from insurance group by LAT, LON having count(concat(LAT, LON)) >1)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "why you use concat in here, you can just couple it in parentheses\\n\\n# Write your MySQL query statement below\\n\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom insurance \\nwhere tiv_2015 in (\\n    select tiv_2015\\n    from insurance\\n    group by tiv_2015\\n    having count(*) >1\\n)\\nand (lat,lon) in (\\n    select lat, lon\\n    from insurance \\n    group by lat,lon\\n    having count(*) = 1\\n)"
                    },
                    {
                        "username": "pittchen",
                        "content": "wtf"
                    },
                    {
                        "username": "sunbo199587",
                        "content": "with cte as \\n(select pid, TIV_2015, TIV_2016, count(concat(lat, lon)) over (partition by concat(lat, lon))as cnt1, count(TIV_2015) over(partition by tiv_2015) as cnt\\nfrom insurance)\\n\\nselect sum(TIV_2016) as TIV_2016 from cte where cnt1=1 and cnt!=1"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "While testing queries for this problem on a local server, I encountered \"Insufficient number of values for placeholders in query\" error. I\\'ve spent, like, 2 hours browsing different forums, and found NO help for the situation I have here. Would really appreciate if someone could help me understand what\\'s the deal here, and/or guided to some sort of documentation on this stuff.\\n\\n<b>PLEASE NOTE: LEETCODE DOES NOT HAVE SUCH AN ISSUE, IT\\'S JUST ABOUT MY LOCAL SERVER.</b>\\nCode in question:\\n\\n`SELECT i1.pid AS pid`\\n`    FROM Insurance AS i1`\\n`    INNER JOIN Insurance AS i2`\\n`    ON i1.lat = i2.lat AND i1.lon = i2.lon AND i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nI feel like what\\'s really going on here, is SQL has trouble linking all of the fields, as exactly same issue arised once I separated one of the conditions into consequent WHERE statement:\\n\\n`SELECT i1.pid AS pid`\\n`FROM Insurance AS i1`\\n`INNER JOIN Insurance AS i2`\\n`ON i1.lat = i2.lat AND i1.lon = i2.lon`\\n`WHERE i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nOnce again, would appreciate any help."
                    },
                    {
                        "username": "sannanakbar56",
                        "content": "\"\"\"select sum(tiv_2016) as tiv_2016 from insurance where \\nlat || lon in (select lat || lon\\nfrom insurance\\ngroup by lat || lon\\nhaving count(*) = 1)\\nand tiv_2015 in (select tiv_2015 from insurance group by tiv_2015 having count(*) > 1)\"\"\""
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect sum(a.TIV_2016) as TIV_2016 from insurance a\\nwhere \\na.TIV_2015 in (select b.TIV_2015 from insurance b where a.PID <> b.PID)\\nand \\n(a.LAT, a.LON) not in (select c.LAT, c.LON from insurance c where a.PID <> c.PID)\\n;"
                    },
                    {
                        "username": "__ppt_29",
                        "content": "WITH tiv AS (\n    SELECT tiv_2015, tiv_2016\n    FROM Insurance \n    GROUP BY CONCAT(lat,lon)\n    HAVING COUNT(\\*)= 1\n),\ntiv_sum AS (\n    SELECT tiv_2015, SUM(tiv_2016) AS tiv_2016\n    FROM tiv\n    GROUP BY tiv_2015\n    HAVING COUNT(\\*) >= 2\n)\n\nSELECT ROUND(SUM(tiv_2016),2) AS tiv_2016\nFROM tiv_sum\n\n\ncan anyone tell me why this isn't working "
                    },
                    {
                        "username": "Almas21",
                        "content": "hi, guys!!\\n\\nCan you explain me the algorith on the following test case:\\n\\n| pid | tiv_2015 | tiv_2016 | lat  | lon  |\\n| --- | -------- | -------- | ---- | ---- |\\n| 1   | 224.17   | 952.73   | 32.4 | 20.2 |\\n| 2   | 224.17   | 900.66   | 52.4 | 32.7 |\\n| 3   | 824.61   | 645.13   | 72.4 | 45.2 |\\n| 4   | 424.32   | 323.66   | 12.4 | 7.7  |\\n| 5   | 424.32   | 282.9    | 12.4 | 7.7  |\\n| 6   | 625.05   | 243.53   | 52.5 | 32.8 |\\n| 7   | 424.32   | 968.94   | 72.5 | 45.3 |\\n| 8   | 624.46   | 714.13   | 12.5 | 7.8  |\\n| 9   | 425.49   | 463.85   | 32.5 | 20.3 |\\n| 10  | 624.46   | 776.85   | 12.4 | 7.7  |\\n| 11  | 624.46   | 692.71   | 72.5 | 45.3 |\\n| 12  | 225.93   | 933      | 12.5 | 7.8  |\\n| 13  | 824.61   | 786.86   | 32.6 | 20.3 |\\n| 14  | 824.61   | 935.34   | 52.6 | 32.8 |\\n| 15  | 826.37   | 516.1    | 12.4 | 7.7  |\\n| 16  | 824.61   | 374.5    | 12.6 | 7.9  |\\n| 17  | 824.61   | 924.19   | 32.6 | 20.4 |\\n| 18  | 626.81   | 897.47   | 52.6 | 32.9 |\\n| 19  | 224.76   | 714.79   | 72.6 | 45.4 |\\n| 20  | 224.76   | 681.53   | 12.4 | 7.7  |\\n| 21  | 427.25   | 263.27   | 32.7 | 20.4 |\\n| 22  | 224.76   | 671.8    | 52.7 | 32.9 |\\n| 23  | 424.9    | 769.18   | 72.7 | 45.4 |\\n| 24  | 227.69   | 830.5    | 12.7 | 7.9  |\\n| 25  | 424.9    | 844.97   | 12.4 | 7.7  |\\n| 26  | 424.9    | 733.35   | 52.7 | 32.9 |\\n| 27  | 828.13   | 931.83   | 72.8 | 45.5 |\\n| 28  | 625.05   | 659.13   | 12.8 | 8    |\\n| 29  | 625.05   | 300.16   | 32.8 | 20.5 |\\n\\nI really could not get what is required."
                    },
                    {
                        "username": "Abdur1997",
                        "content": "SELECT ROUND(SUM(a.TIV_2016), 2) AS TIV_2016\nFROM insurance a\nWHERE EXISTS (\n    SELECT 1\n    FROM insurance b\n    WHERE a.PID <> b.PID AND a.TIV_2015 = b.TIV_2015\n)\nAND NOT EXISTS (\n    SELECT 1\n    FROM insurance c\n    WHERE a.PID <> c.PID AND (a.LAT = c.LAT AND a.LON = c.LON)\n)\n"
                    },
                    {
                        "username": "user1448rE",
                        "content": "Could anyone explain what\\'s wrong with this solution? \\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON) AS LONG, COUNT(LON) OVER (PARTITION BY LAT) AS LATI, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND (LONG=1 OR LATI=1)\\n\\nAbove solution doesn\\'t work but when I changed it to the one below it works fine.\\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON,lat) AS LONG, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND LONG=1"
                    },
                    {
                        "username": "srjefers",
                        "content": "I can explain 💡, on your first solution you has been taking the columns of `lat & lon` as separeted values, there are more like a composite key that you need to concatenate to have the real value and know/understand on which cases are they really being duplicated. By applying the concatenation of both of them, something that you did on the second solution with the `partition by`, you would be able to count each of them and remove duplicated values. The `TIV` columns you got it right 👍"
                    }
                ]
            },
            {
                "id": 2075992,
                "content": [
                    {
                        "username": "henryangela",
                        "content": "# Write your MySQL query statement below\\nselect round(sum(TIV_2016),2) as TIV_2016 from insurance\\nwhere TIV_2015 in\\n(select TIV_2015 from insurance group by TIV_2015 having count(TIV_2015) >1)\\nand concat(LAT, LON) not in\\n(select concat(LAT, LON) from insurance group by LAT, LON having count(concat(LAT, LON)) >1)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "why you use concat in here, you can just couple it in parentheses\\n\\n# Write your MySQL query statement below\\n\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom insurance \\nwhere tiv_2015 in (\\n    select tiv_2015\\n    from insurance\\n    group by tiv_2015\\n    having count(*) >1\\n)\\nand (lat,lon) in (\\n    select lat, lon\\n    from insurance \\n    group by lat,lon\\n    having count(*) = 1\\n)"
                    },
                    {
                        "username": "pittchen",
                        "content": "wtf"
                    },
                    {
                        "username": "sunbo199587",
                        "content": "with cte as \\n(select pid, TIV_2015, TIV_2016, count(concat(lat, lon)) over (partition by concat(lat, lon))as cnt1, count(TIV_2015) over(partition by tiv_2015) as cnt\\nfrom insurance)\\n\\nselect sum(TIV_2016) as TIV_2016 from cte where cnt1=1 and cnt!=1"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "While testing queries for this problem on a local server, I encountered \"Insufficient number of values for placeholders in query\" error. I\\'ve spent, like, 2 hours browsing different forums, and found NO help for the situation I have here. Would really appreciate if someone could help me understand what\\'s the deal here, and/or guided to some sort of documentation on this stuff.\\n\\n<b>PLEASE NOTE: LEETCODE DOES NOT HAVE SUCH AN ISSUE, IT\\'S JUST ABOUT MY LOCAL SERVER.</b>\\nCode in question:\\n\\n`SELECT i1.pid AS pid`\\n`    FROM Insurance AS i1`\\n`    INNER JOIN Insurance AS i2`\\n`    ON i1.lat = i2.lat AND i1.lon = i2.lon AND i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nI feel like what\\'s really going on here, is SQL has trouble linking all of the fields, as exactly same issue arised once I separated one of the conditions into consequent WHERE statement:\\n\\n`SELECT i1.pid AS pid`\\n`FROM Insurance AS i1`\\n`INNER JOIN Insurance AS i2`\\n`ON i1.lat = i2.lat AND i1.lon = i2.lon`\\n`WHERE i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nOnce again, would appreciate any help."
                    },
                    {
                        "username": "sannanakbar56",
                        "content": "\"\"\"select sum(tiv_2016) as tiv_2016 from insurance where \\nlat || lon in (select lat || lon\\nfrom insurance\\ngroup by lat || lon\\nhaving count(*) = 1)\\nand tiv_2015 in (select tiv_2015 from insurance group by tiv_2015 having count(*) > 1)\"\"\""
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect sum(a.TIV_2016) as TIV_2016 from insurance a\\nwhere \\na.TIV_2015 in (select b.TIV_2015 from insurance b where a.PID <> b.PID)\\nand \\n(a.LAT, a.LON) not in (select c.LAT, c.LON from insurance c where a.PID <> c.PID)\\n;"
                    },
                    {
                        "username": "__ppt_29",
                        "content": "WITH tiv AS (\n    SELECT tiv_2015, tiv_2016\n    FROM Insurance \n    GROUP BY CONCAT(lat,lon)\n    HAVING COUNT(\\*)= 1\n),\ntiv_sum AS (\n    SELECT tiv_2015, SUM(tiv_2016) AS tiv_2016\n    FROM tiv\n    GROUP BY tiv_2015\n    HAVING COUNT(\\*) >= 2\n)\n\nSELECT ROUND(SUM(tiv_2016),2) AS tiv_2016\nFROM tiv_sum\n\n\ncan anyone tell me why this isn't working "
                    },
                    {
                        "username": "Almas21",
                        "content": "hi, guys!!\\n\\nCan you explain me the algorith on the following test case:\\n\\n| pid | tiv_2015 | tiv_2016 | lat  | lon  |\\n| --- | -------- | -------- | ---- | ---- |\\n| 1   | 224.17   | 952.73   | 32.4 | 20.2 |\\n| 2   | 224.17   | 900.66   | 52.4 | 32.7 |\\n| 3   | 824.61   | 645.13   | 72.4 | 45.2 |\\n| 4   | 424.32   | 323.66   | 12.4 | 7.7  |\\n| 5   | 424.32   | 282.9    | 12.4 | 7.7  |\\n| 6   | 625.05   | 243.53   | 52.5 | 32.8 |\\n| 7   | 424.32   | 968.94   | 72.5 | 45.3 |\\n| 8   | 624.46   | 714.13   | 12.5 | 7.8  |\\n| 9   | 425.49   | 463.85   | 32.5 | 20.3 |\\n| 10  | 624.46   | 776.85   | 12.4 | 7.7  |\\n| 11  | 624.46   | 692.71   | 72.5 | 45.3 |\\n| 12  | 225.93   | 933      | 12.5 | 7.8  |\\n| 13  | 824.61   | 786.86   | 32.6 | 20.3 |\\n| 14  | 824.61   | 935.34   | 52.6 | 32.8 |\\n| 15  | 826.37   | 516.1    | 12.4 | 7.7  |\\n| 16  | 824.61   | 374.5    | 12.6 | 7.9  |\\n| 17  | 824.61   | 924.19   | 32.6 | 20.4 |\\n| 18  | 626.81   | 897.47   | 52.6 | 32.9 |\\n| 19  | 224.76   | 714.79   | 72.6 | 45.4 |\\n| 20  | 224.76   | 681.53   | 12.4 | 7.7  |\\n| 21  | 427.25   | 263.27   | 32.7 | 20.4 |\\n| 22  | 224.76   | 671.8    | 52.7 | 32.9 |\\n| 23  | 424.9    | 769.18   | 72.7 | 45.4 |\\n| 24  | 227.69   | 830.5    | 12.7 | 7.9  |\\n| 25  | 424.9    | 844.97   | 12.4 | 7.7  |\\n| 26  | 424.9    | 733.35   | 52.7 | 32.9 |\\n| 27  | 828.13   | 931.83   | 72.8 | 45.5 |\\n| 28  | 625.05   | 659.13   | 12.8 | 8    |\\n| 29  | 625.05   | 300.16   | 32.8 | 20.5 |\\n\\nI really could not get what is required."
                    },
                    {
                        "username": "Abdur1997",
                        "content": "SELECT ROUND(SUM(a.TIV_2016), 2) AS TIV_2016\nFROM insurance a\nWHERE EXISTS (\n    SELECT 1\n    FROM insurance b\n    WHERE a.PID <> b.PID AND a.TIV_2015 = b.TIV_2015\n)\nAND NOT EXISTS (\n    SELECT 1\n    FROM insurance c\n    WHERE a.PID <> c.PID AND (a.LAT = c.LAT AND a.LON = c.LON)\n)\n"
                    },
                    {
                        "username": "user1448rE",
                        "content": "Could anyone explain what\\'s wrong with this solution? \\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON) AS LONG, COUNT(LON) OVER (PARTITION BY LAT) AS LATI, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND (LONG=1 OR LATI=1)\\n\\nAbove solution doesn\\'t work but when I changed it to the one below it works fine.\\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON,lat) AS LONG, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND LONG=1"
                    },
                    {
                        "username": "srjefers",
                        "content": "I can explain 💡, on your first solution you has been taking the columns of `lat & lon` as separeted values, there are more like a composite key that you need to concatenate to have the real value and know/understand on which cases are they really being duplicated. By applying the concatenation of both of them, something that you did on the second solution with the `partition by`, you would be able to count each of them and remove duplicated values. The `TIV` columns you got it right 👍"
                    }
                ]
            },
            {
                "id": 2067839,
                "content": [
                    {
                        "username": "henryangela",
                        "content": "# Write your MySQL query statement below\\nselect round(sum(TIV_2016),2) as TIV_2016 from insurance\\nwhere TIV_2015 in\\n(select TIV_2015 from insurance group by TIV_2015 having count(TIV_2015) >1)\\nand concat(LAT, LON) not in\\n(select concat(LAT, LON) from insurance group by LAT, LON having count(concat(LAT, LON)) >1)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "why you use concat in here, you can just couple it in parentheses\\n\\n# Write your MySQL query statement below\\n\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom insurance \\nwhere tiv_2015 in (\\n    select tiv_2015\\n    from insurance\\n    group by tiv_2015\\n    having count(*) >1\\n)\\nand (lat,lon) in (\\n    select lat, lon\\n    from insurance \\n    group by lat,lon\\n    having count(*) = 1\\n)"
                    },
                    {
                        "username": "pittchen",
                        "content": "wtf"
                    },
                    {
                        "username": "sunbo199587",
                        "content": "with cte as \\n(select pid, TIV_2015, TIV_2016, count(concat(lat, lon)) over (partition by concat(lat, lon))as cnt1, count(TIV_2015) over(partition by tiv_2015) as cnt\\nfrom insurance)\\n\\nselect sum(TIV_2016) as TIV_2016 from cte where cnt1=1 and cnt!=1"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "While testing queries for this problem on a local server, I encountered \"Insufficient number of values for placeholders in query\" error. I\\'ve spent, like, 2 hours browsing different forums, and found NO help for the situation I have here. Would really appreciate if someone could help me understand what\\'s the deal here, and/or guided to some sort of documentation on this stuff.\\n\\n<b>PLEASE NOTE: LEETCODE DOES NOT HAVE SUCH AN ISSUE, IT\\'S JUST ABOUT MY LOCAL SERVER.</b>\\nCode in question:\\n\\n`SELECT i1.pid AS pid`\\n`    FROM Insurance AS i1`\\n`    INNER JOIN Insurance AS i2`\\n`    ON i1.lat = i2.lat AND i1.lon = i2.lon AND i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nI feel like what\\'s really going on here, is SQL has trouble linking all of the fields, as exactly same issue arised once I separated one of the conditions into consequent WHERE statement:\\n\\n`SELECT i1.pid AS pid`\\n`FROM Insurance AS i1`\\n`INNER JOIN Insurance AS i2`\\n`ON i1.lat = i2.lat AND i1.lon = i2.lon`\\n`WHERE i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nOnce again, would appreciate any help."
                    },
                    {
                        "username": "sannanakbar56",
                        "content": "\"\"\"select sum(tiv_2016) as tiv_2016 from insurance where \\nlat || lon in (select lat || lon\\nfrom insurance\\ngroup by lat || lon\\nhaving count(*) = 1)\\nand tiv_2015 in (select tiv_2015 from insurance group by tiv_2015 having count(*) > 1)\"\"\""
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect sum(a.TIV_2016) as TIV_2016 from insurance a\\nwhere \\na.TIV_2015 in (select b.TIV_2015 from insurance b where a.PID <> b.PID)\\nand \\n(a.LAT, a.LON) not in (select c.LAT, c.LON from insurance c where a.PID <> c.PID)\\n;"
                    },
                    {
                        "username": "__ppt_29",
                        "content": "WITH tiv AS (\n    SELECT tiv_2015, tiv_2016\n    FROM Insurance \n    GROUP BY CONCAT(lat,lon)\n    HAVING COUNT(\\*)= 1\n),\ntiv_sum AS (\n    SELECT tiv_2015, SUM(tiv_2016) AS tiv_2016\n    FROM tiv\n    GROUP BY tiv_2015\n    HAVING COUNT(\\*) >= 2\n)\n\nSELECT ROUND(SUM(tiv_2016),2) AS tiv_2016\nFROM tiv_sum\n\n\ncan anyone tell me why this isn't working "
                    },
                    {
                        "username": "Almas21",
                        "content": "hi, guys!!\\n\\nCan you explain me the algorith on the following test case:\\n\\n| pid | tiv_2015 | tiv_2016 | lat  | lon  |\\n| --- | -------- | -------- | ---- | ---- |\\n| 1   | 224.17   | 952.73   | 32.4 | 20.2 |\\n| 2   | 224.17   | 900.66   | 52.4 | 32.7 |\\n| 3   | 824.61   | 645.13   | 72.4 | 45.2 |\\n| 4   | 424.32   | 323.66   | 12.4 | 7.7  |\\n| 5   | 424.32   | 282.9    | 12.4 | 7.7  |\\n| 6   | 625.05   | 243.53   | 52.5 | 32.8 |\\n| 7   | 424.32   | 968.94   | 72.5 | 45.3 |\\n| 8   | 624.46   | 714.13   | 12.5 | 7.8  |\\n| 9   | 425.49   | 463.85   | 32.5 | 20.3 |\\n| 10  | 624.46   | 776.85   | 12.4 | 7.7  |\\n| 11  | 624.46   | 692.71   | 72.5 | 45.3 |\\n| 12  | 225.93   | 933      | 12.5 | 7.8  |\\n| 13  | 824.61   | 786.86   | 32.6 | 20.3 |\\n| 14  | 824.61   | 935.34   | 52.6 | 32.8 |\\n| 15  | 826.37   | 516.1    | 12.4 | 7.7  |\\n| 16  | 824.61   | 374.5    | 12.6 | 7.9  |\\n| 17  | 824.61   | 924.19   | 32.6 | 20.4 |\\n| 18  | 626.81   | 897.47   | 52.6 | 32.9 |\\n| 19  | 224.76   | 714.79   | 72.6 | 45.4 |\\n| 20  | 224.76   | 681.53   | 12.4 | 7.7  |\\n| 21  | 427.25   | 263.27   | 32.7 | 20.4 |\\n| 22  | 224.76   | 671.8    | 52.7 | 32.9 |\\n| 23  | 424.9    | 769.18   | 72.7 | 45.4 |\\n| 24  | 227.69   | 830.5    | 12.7 | 7.9  |\\n| 25  | 424.9    | 844.97   | 12.4 | 7.7  |\\n| 26  | 424.9    | 733.35   | 52.7 | 32.9 |\\n| 27  | 828.13   | 931.83   | 72.8 | 45.5 |\\n| 28  | 625.05   | 659.13   | 12.8 | 8    |\\n| 29  | 625.05   | 300.16   | 32.8 | 20.5 |\\n\\nI really could not get what is required."
                    },
                    {
                        "username": "Abdur1997",
                        "content": "SELECT ROUND(SUM(a.TIV_2016), 2) AS TIV_2016\nFROM insurance a\nWHERE EXISTS (\n    SELECT 1\n    FROM insurance b\n    WHERE a.PID <> b.PID AND a.TIV_2015 = b.TIV_2015\n)\nAND NOT EXISTS (\n    SELECT 1\n    FROM insurance c\n    WHERE a.PID <> c.PID AND (a.LAT = c.LAT AND a.LON = c.LON)\n)\n"
                    },
                    {
                        "username": "user1448rE",
                        "content": "Could anyone explain what\\'s wrong with this solution? \\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON) AS LONG, COUNT(LON) OVER (PARTITION BY LAT) AS LATI, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND (LONG=1 OR LATI=1)\\n\\nAbove solution doesn\\'t work but when I changed it to the one below it works fine.\\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON,lat) AS LONG, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND LONG=1"
                    },
                    {
                        "username": "srjefers",
                        "content": "I can explain 💡, on your first solution you has been taking the columns of `lat & lon` as separeted values, there are more like a composite key that you need to concatenate to have the real value and know/understand on which cases are they really being duplicated. By applying the concatenation of both of them, something that you did on the second solution with the `partition by`, you would be able to count each of them and remove duplicated values. The `TIV` columns you got it right 👍"
                    }
                ]
            },
            {
                "id": 2054228,
                "content": [
                    {
                        "username": "henryangela",
                        "content": "# Write your MySQL query statement below\\nselect round(sum(TIV_2016),2) as TIV_2016 from insurance\\nwhere TIV_2015 in\\n(select TIV_2015 from insurance group by TIV_2015 having count(TIV_2015) >1)\\nand concat(LAT, LON) not in\\n(select concat(LAT, LON) from insurance group by LAT, LON having count(concat(LAT, LON)) >1)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "why you use concat in here, you can just couple it in parentheses\\n\\n# Write your MySQL query statement below\\n\\nselect round(sum(tiv_2016),2) as tiv_2016\\nfrom insurance \\nwhere tiv_2015 in (\\n    select tiv_2015\\n    from insurance\\n    group by tiv_2015\\n    having count(*) >1\\n)\\nand (lat,lon) in (\\n    select lat, lon\\n    from insurance \\n    group by lat,lon\\n    having count(*) = 1\\n)"
                    },
                    {
                        "username": "pittchen",
                        "content": "wtf"
                    },
                    {
                        "username": "sunbo199587",
                        "content": "with cte as \\n(select pid, TIV_2015, TIV_2016, count(concat(lat, lon)) over (partition by concat(lat, lon))as cnt1, count(TIV_2015) over(partition by tiv_2015) as cnt\\nfrom insurance)\\n\\nselect sum(TIV_2016) as TIV_2016 from cte where cnt1=1 and cnt!=1"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "While testing queries for this problem on a local server, I encountered \"Insufficient number of values for placeholders in query\" error. I\\'ve spent, like, 2 hours browsing different forums, and found NO help for the situation I have here. Would really appreciate if someone could help me understand what\\'s the deal here, and/or guided to some sort of documentation on this stuff.\\n\\n<b>PLEASE NOTE: LEETCODE DOES NOT HAVE SUCH AN ISSUE, IT\\'S JUST ABOUT MY LOCAL SERVER.</b>\\nCode in question:\\n\\n`SELECT i1.pid AS pid`\\n`    FROM Insurance AS i1`\\n`    INNER JOIN Insurance AS i2`\\n`    ON i1.lat = i2.lat AND i1.lon = i2.lon AND i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nI feel like what\\'s really going on here, is SQL has trouble linking all of the fields, as exactly same issue arised once I separated one of the conditions into consequent WHERE statement:\\n\\n`SELECT i1.pid AS pid`\\n`FROM Insurance AS i1`\\n`INNER JOIN Insurance AS i2`\\n`ON i1.lat = i2.lat AND i1.lon = i2.lon`\\n`WHERE i1.pid != i2.pid;`\\n\\n`ClassicSession.run_sql: Insufficient number of values for placeholders in query`\\n\\nOnce again, would appreciate any help."
                    },
                    {
                        "username": "sannanakbar56",
                        "content": "\"\"\"select sum(tiv_2016) as tiv_2016 from insurance where \\nlat || lon in (select lat || lon\\nfrom insurance\\ngroup by lat || lon\\nhaving count(*) = 1)\\nand tiv_2015 in (select tiv_2015 from insurance group by tiv_2015 having count(*) > 1)\"\"\""
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect sum(a.TIV_2016) as TIV_2016 from insurance a\\nwhere \\na.TIV_2015 in (select b.TIV_2015 from insurance b where a.PID <> b.PID)\\nand \\n(a.LAT, a.LON) not in (select c.LAT, c.LON from insurance c where a.PID <> c.PID)\\n;"
                    },
                    {
                        "username": "__ppt_29",
                        "content": "WITH tiv AS (\n    SELECT tiv_2015, tiv_2016\n    FROM Insurance \n    GROUP BY CONCAT(lat,lon)\n    HAVING COUNT(\\*)= 1\n),\ntiv_sum AS (\n    SELECT tiv_2015, SUM(tiv_2016) AS tiv_2016\n    FROM tiv\n    GROUP BY tiv_2015\n    HAVING COUNT(\\*) >= 2\n)\n\nSELECT ROUND(SUM(tiv_2016),2) AS tiv_2016\nFROM tiv_sum\n\n\ncan anyone tell me why this isn't working "
                    },
                    {
                        "username": "Almas21",
                        "content": "hi, guys!!\\n\\nCan you explain me the algorith on the following test case:\\n\\n| pid | tiv_2015 | tiv_2016 | lat  | lon  |\\n| --- | -------- | -------- | ---- | ---- |\\n| 1   | 224.17   | 952.73   | 32.4 | 20.2 |\\n| 2   | 224.17   | 900.66   | 52.4 | 32.7 |\\n| 3   | 824.61   | 645.13   | 72.4 | 45.2 |\\n| 4   | 424.32   | 323.66   | 12.4 | 7.7  |\\n| 5   | 424.32   | 282.9    | 12.4 | 7.7  |\\n| 6   | 625.05   | 243.53   | 52.5 | 32.8 |\\n| 7   | 424.32   | 968.94   | 72.5 | 45.3 |\\n| 8   | 624.46   | 714.13   | 12.5 | 7.8  |\\n| 9   | 425.49   | 463.85   | 32.5 | 20.3 |\\n| 10  | 624.46   | 776.85   | 12.4 | 7.7  |\\n| 11  | 624.46   | 692.71   | 72.5 | 45.3 |\\n| 12  | 225.93   | 933      | 12.5 | 7.8  |\\n| 13  | 824.61   | 786.86   | 32.6 | 20.3 |\\n| 14  | 824.61   | 935.34   | 52.6 | 32.8 |\\n| 15  | 826.37   | 516.1    | 12.4 | 7.7  |\\n| 16  | 824.61   | 374.5    | 12.6 | 7.9  |\\n| 17  | 824.61   | 924.19   | 32.6 | 20.4 |\\n| 18  | 626.81   | 897.47   | 52.6 | 32.9 |\\n| 19  | 224.76   | 714.79   | 72.6 | 45.4 |\\n| 20  | 224.76   | 681.53   | 12.4 | 7.7  |\\n| 21  | 427.25   | 263.27   | 32.7 | 20.4 |\\n| 22  | 224.76   | 671.8    | 52.7 | 32.9 |\\n| 23  | 424.9    | 769.18   | 72.7 | 45.4 |\\n| 24  | 227.69   | 830.5    | 12.7 | 7.9  |\\n| 25  | 424.9    | 844.97   | 12.4 | 7.7  |\\n| 26  | 424.9    | 733.35   | 52.7 | 32.9 |\\n| 27  | 828.13   | 931.83   | 72.8 | 45.5 |\\n| 28  | 625.05   | 659.13   | 12.8 | 8    |\\n| 29  | 625.05   | 300.16   | 32.8 | 20.5 |\\n\\nI really could not get what is required."
                    },
                    {
                        "username": "Abdur1997",
                        "content": "SELECT ROUND(SUM(a.TIV_2016), 2) AS TIV_2016\nFROM insurance a\nWHERE EXISTS (\n    SELECT 1\n    FROM insurance b\n    WHERE a.PID <> b.PID AND a.TIV_2015 = b.TIV_2015\n)\nAND NOT EXISTS (\n    SELECT 1\n    FROM insurance c\n    WHERE a.PID <> c.PID AND (a.LAT = c.LAT AND a.LON = c.LON)\n)\n"
                    },
                    {
                        "username": "user1448rE",
                        "content": "Could anyone explain what\\'s wrong with this solution? \\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON) AS LONG, COUNT(LON) OVER (PARTITION BY LAT) AS LATI, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND (LONG=1 OR LATI=1)\\n\\nAbove solution doesn\\'t work but when I changed it to the one below it works fine.\\n\\nWITH CTE AS (SELECT TIV_2016 AS AD, COUNT(LAT) OVER (PARTITION BY LON,lat) AS LONG, COUNT (PID) OVER (PARTITION BY TIV_2015) AS TIV FROM INSURANCE)\\nSELECT ROUND(SUM(AD)*1.00,2) AS tiv_2016\\nFROM CTE\\nWHERE TIV>1\\nAND LONG=1"
                    },
                    {
                        "username": "srjefers",
                        "content": "I can explain 💡, on your first solution you has been taking the columns of `lat & lon` as separeted values, there are more like a composite key that you need to concatenate to have the real value and know/understand on which cases are they really being duplicated. By applying the concatenation of both of them, something that you did on the second solution with the `partition by`, you would be able to count each of them and remove duplicated values. The `TIV` columns you got it right 👍"
                    }
                ]
            }
        ]
    }
]