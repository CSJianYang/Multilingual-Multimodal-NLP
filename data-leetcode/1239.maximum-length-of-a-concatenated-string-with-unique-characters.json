[
    {
        "title": "Longest Mountain in Array",
        "question_content": "You may recall that an array arr is a mountain array if and only if:\n\n\tarr.length >= 3\n\tThere exists some index i (0-indexed) with 0 < i < arr.length - 1 such that:\n\t\n\t\tarr[0] < arr[1] < ... < arr[i - 1] < arr[i]\n\t\tarr[i] > arr[i + 1] > ... > arr[arr.length - 1]\n\t\n\t\n\nGiven an integer array arr, return the length of the longest subarray, which is a mountain. Return 0 if there is no mountain subarray.\n&nbsp;\nExample 1:\n\nInput: arr = [2,1,4,7,3,2,5]\nOutput: 5\nExplanation: The largest mountain is [1,4,7,3,2] which has length 5.\n\nExample 2:\n\nInput: arr = [2,2,2]\nOutput: 0\nExplanation: There is no mountain.\n\n&nbsp;\nConstraints:\n\n\t1 <= arr.length <= 104\n\t0 <= arr[i] <= 104\n\n&nbsp;\nFollow up:\n\n\tCan you solve it using only one pass?\n\tCan you solve it in O(1) space?",
        "solutions": [
            {
                "id": 135593,
                "title": "c-java-python-1-pass-and-o-1-space",
                "content": "**Intuition**:\\nWe have already many 2-pass or 3-pass problems, like 821. Shortest Distance to a Character.\\nThey have almost the same idea.\\nOne forward pass and one backward pass.\\nMaybe another pass to get the final result, or you can merge it in one previous pass.\\n\\n**Explanation**:\\nIn this problem, we take one forward pass to count up hill length (to every point).\\nWe take another backward pass to count down hill length (from every point).\\nFinally a pass to find max(up[i] + down[i] + 1) where up[i] and down[i] should be positives.\\n\\n\\n**Time Complexity**:\\nO(N)\\n\\n**C++:**\\n```\\n    int longestMountain(vector<int> A) {\\n        int N = A.size(), res = 0;\\n        vector<int> up(N, 0), down(N, 0);\\n        for (int i = N - 2; i >= 0; --i) if (A[i] > A[i + 1]) down[i] = down[i + 1] + 1;\\n        for (int i = 0; i < N; ++i) {\\n            if (i > 0 && A[i] > A[i - 1]) up[i] = up[i - 1] + 1;\\n            if (up[i] && down[i]) res = max(res, up[i] + down[i] + 1);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Java:**\\n```\\n    public int longestMountain(int[] A) {\\n        int N = A.length, res = 0;\\n        int[] up = new int[N], down = new int[N];\\n        for (int i = N - 2; i >= 0; --i) if (A[i] > A[i + 1]) down[i] = down[i + 1] + 1;\\n        for (int i = 0; i < N; ++i) {\\n            if (i > 0 && A[i] > A[i - 1]) up[i] = up[i - 1] + 1;\\n            if (up[i] > 0 && down[i] > 0) res = Math.max(res, up[i] + down[i] + 1);\\n        }\\n        return res;\\n    }\\n```\\n**Python:**\\n```\\n    def longestMountain(self, A):\\n        up, down = [0] * len(A), [0] * len(A)\\n        for i in range(1, len(A)):\\n            if A[i] > A[i - 1]: up[i] = up[i - 1] + 1\\n        for i in range(len(A) - 1)[::-1]:\\n            if A[i] > A[i + 1]: down[i] = down[i + 1] + 1\\n        return max([u + d + 1 for u, d in zip(up, down) if u and d] or [0])\\n```\\n\\n**Follow up**\\n\\nCan you solve this problem with only one pass?\\nCan you solve this problem in O(1) space?\\n\\nIn this solution, I count up length and down length.\\nBoth up and down length are clear to 0 when `A[i - 1] == A[i]` or `down > 0 && A[i - 1] < A[i]`.\\n\\n**C++:**\\n```\\n    int longestMountain(vector<int> A) {\\n        int res = 0, up = 0, down = 0;\\n        for (int i = 1; i < A.size(); ++i) {\\n            if (down && A[i - 1] < A[i] || A[i - 1] == A[i]) up = down = 0;\\n            up += A[i - 1] < A[i];\\n            down += A[i - 1] > A[i];\\n            if (up && down) res = max(res, up + down + 1);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Java:**\\n```\\n    public int longestMountain(int[] A) {\\n        int res = 0, up = 0, down = 0;\\n        for (int i = 1; i < A.length; ++i) {\\n            if (down > 0 && A[i - 1] < A[i] || A[i - 1] == A[i]) up = down = 0;\\n            if (A[i - 1] < A[i]) up++;\\n            if (A[i - 1] > A[i]) down++;\\n            if (up > 0 && down > 0 && up + down + 1 > res) res = up + down + 1;\\n        }\\n        return res;\\n    }\\n```\\n**Python:**\\n```\\n    def longestMountain(self, A):\\n        res = up = down = 0\\n        for i in range(1, len(A)):\\n            if down and A[i - 1] < A[i] or A[i - 1] == A[i]: up = down = 0\\n            up += A[i - 1] < A[i]\\n            down += A[i - 1] > A[i]\\n            if up and down: res = max(res, up + down + 1)\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    int longestMountain(vector<int> A) {\\n        int N = A.size(), res = 0;\\n        vector<int> up(N, 0), down(N, 0);\\n        for (int i = N - 2; i >= 0; --i) if (A[i] > A[i + 1]) down[i] = down[i + 1] + 1;\\n        for (int i = 0; i < N; ++i) {\\n            if (i > 0 && A[i] > A[i - 1]) up[i] = up[i - 1] + 1;\\n            if (up[i] && down[i]) res = max(res, up[i] + down[i] + 1);\\n        }\\n        return res;\\n    }\\n```\n```\\n    public int longestMountain(int[] A) {\\n        int N = A.length, res = 0;\\n        int[] up = new int[N], down = new int[N];\\n        for (int i = N - 2; i >= 0; --i) if (A[i] > A[i + 1]) down[i] = down[i + 1] + 1;\\n        for (int i = 0; i < N; ++i) {\\n            if (i > 0 && A[i] > A[i - 1]) up[i] = up[i - 1] + 1;\\n            if (up[i] > 0 && down[i] > 0) res = Math.max(res, up[i] + down[i] + 1);\\n        }\\n        return res;\\n    }\\n```\n```\\n    def longestMountain(self, A):\\n        up, down = [0] * len(A), [0] * len(A)\\n        for i in range(1, len(A)):\\n            if A[i] > A[i - 1]: up[i] = up[i - 1] + 1\\n        for i in range(len(A) - 1)[::-1]:\\n            if A[i] > A[i + 1]: down[i] = down[i + 1] + 1\\n        return max([u + d + 1 for u, d in zip(up, down) if u and d] or [0])\\n```\n```\\n    int longestMountain(vector<int> A) {\\n        int res = 0, up = 0, down = 0;\\n        for (int i = 1; i < A.size(); ++i) {\\n            if (down && A[i - 1] < A[i] || A[i - 1] == A[i]) up = down = 0;\\n            up += A[i - 1] < A[i];\\n            down += A[i - 1] > A[i];\\n            if (up && down) res = max(res, up + down + 1);\\n        }\\n        return res;\\n    }\\n```\n```\\n    public int longestMountain(int[] A) {\\n        int res = 0, up = 0, down = 0;\\n        for (int i = 1; i < A.length; ++i) {\\n            if (down > 0 && A[i - 1] < A[i] || A[i - 1] == A[i]) up = down = 0;\\n            if (A[i - 1] < A[i]) up++;\\n            if (A[i - 1] > A[i]) down++;\\n            if (up > 0 && down > 0 && up + down + 1 > res) res = up + down + 1;\\n        }\\n        return res;\\n    }\\n```\n```\\n    def longestMountain(self, A):\\n        res = up = down = 0\\n        for i in range(1, len(A)):\\n            if down and A[i - 1] < A[i] or A[i - 1] == A[i]: up = down = 0\\n            up += A[i - 1] < A[i]\\n            down += A[i - 1] > A[i]\\n            if up and down: res = max(res, up + down + 1)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 165667,
                "title": "1-pass-java-two-point-solution",
                "content": "```\\npublic int longestMountain(int[] A) {\\n        int n=A.length;\\n        if(n<3)return 0;\\n        \\n        int left=0;int right;int max=0;\\n        \\n        while(left<n-2){\\n            //skip decending and equal array\\n            while(left<n-1 && A[left]>=A[left+1]){\\n                left++;\\n            }\\n            right=left+1;\\n            //mountain up\\n            while(right<n-1 && A[right]<A[right+1]){\\n                right++;\\n            }\\n            //mountain down\\n            while(right<n-1 && A[right]>A[right+1]){\\n                right++;\\n                //update the max value\\n                max=Math.max(max,right-left+1);\\n            }\\n            left=right;\\n        }\\n        return max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int longestMountain(int[] A) {\\n        int n=A.length;\\n        if(n<3)return 0;\\n        \\n        int left=0;int right;int max=0;\\n        \\n        while(left<n-2){\\n            //skip decending and equal array\\n            while(left<n-1 && A[left]>=A[left+1]){\\n                left++;\\n            }\\n            right=left+1;\\n            //mountain up\\n            while(right<n-1 && A[right]<A[right+1]){\\n                right++;\\n            }\\n            //mountain down\\n            while(right<n-1 && A[right]>A[right+1]){\\n                right++;\\n                //update the max value\\n                max=Math.max(max,right-left+1);\\n            }\\n            left=right;\\n        }\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 271110,
                "title": "easy-to-understand-code-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int maxLength = 0;\\n        int i = 1;\\n        \\n        while (i < A.size()) {\\n            int increasing = 0, decreasing = 0;\\n            \\n            while(i < A.size() && A[i - 1] < A[i]) i++, increasing++;\\n            while(i < A.size() && A[i - 1] > A[i]) i++, decreasing++;\\n            \\n            if (increasing > 0 && decreasing > 0) maxLength = max(maxLength, increasing + decreasing + 1);\\n            \\n            while(i < A.size() && A[i - 1] == A[i]) i++;\\n        }\\n        return maxLength;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int maxLength = 0;\\n        int i = 1;\\n        \\n        while (i < A.size()) {\\n            int increasing = 0, decreasing = 0;\\n            \\n            while(i < A.size() && A[i - 1] < A[i]) i++, increasing++;\\n            while(i < A.size() && A[i - 1] > A[i]) i++, decreasing++;\\n            \\n            if (increasing > 0 && decreasing > 0) maxLength = max(maxLength, increasing + decreasing + 1);\\n            \\n            while(i < A.size() && A[i - 1] == A[i]) i++;\\n        }\\n        return maxLength;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 135631,
                "title": "python-7-lines-concise-o-n-time-o-1-space-solution",
                "content": "```\\nclass Solution:\\n    def longestMountain(self, A, res = 0):\\n        for i in range(1, len(A) - 1):\\n            if A[i + 1] < A[i] > A[i - 1]:\\n                l = r = i\\n                while l and A[l] > A[l - 1]: l -= 1\\n                while r + 1 < len(A) and A[r] > A[r + 1]: r += 1\\n                if r - l + 1 > res: res = r - l + 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, A, res = 0):\\n        for i in range(1, len(A) - 1):\\n            if A[i + 1] < A[i] > A[i - 1]:\\n                l = r = i\\n                while l and A[l] > A[l - 1]: l -= 1\\n                while r + 1 < len(A) and A[r] > A[r + 1]: r += 1\\n                if r - l + 1 > res: res = r - l + 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1215470,
                "title": "c-easy-solution-with-comments-and-algorithm",
                "content": "\\nREMEMBER TO UPVOTE THE ANSWER\\n\\nTime Complexity O(n)\\nSpace Complexity O(1)\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        // 1. IDENTIFY PEAKS\\n        // 2. TRAVERSE BACKWARDS WHILE PREVIOUS ELEMENT -\\n        // - IS SMALLER THAT CURRENT (i.e. GO TO THE START ROOT OF THE MOUNTAIN)\\n        // 3. TRAVERSE FORWARD WHILE NEXT ELEMENT IS SMALLER THAN CURRENT \\n        // (i.e. GO TO THE END ROOT OF THE MOUNTAIN)\\n        // 4 . ADD THEM TO CALCULATE THE MOUNTAIN LENGTH\\n        int max_length = 0;\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if((arr[i] > arr[i-1]) && (arr[i] > arr[i+1])) //PEAK CONDITION\\n            {\\n                int start_root = i;\\n                int end_root = i;\\n                while( start_root>0 && arr[start_root] > arr[start_root-1])\\n                {\\n                    start_root--; //getting start root\\n                    \\n                }\\n                while( end_root<n-1 && arr[end_root] > arr[end_root+1] )\\n                {\\n                    end_root++; //getting end root\\n                }\\n                max_length = max(max_length,(end_root-start_root+1));\\n                i = end_root;\\n            }\\n        }\\n        return max_length;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        // 1. IDENTIFY PEAKS\\n        // 2. TRAVERSE BACKWARDS WHILE PREVIOUS ELEMENT -\\n        // - IS SMALLER THAT CURRENT (i.e. GO TO THE START ROOT OF THE MOUNTAIN)\\n        // 3. TRAVERSE FORWARD WHILE NEXT ELEMENT IS SMALLER THAN CURRENT \\n        // (i.e. GO TO THE END ROOT OF THE MOUNTAIN)\\n        // 4 . ADD THEM TO CALCULATE THE MOUNTAIN LENGTH\\n        int max_length = 0;\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if((arr[i] > arr[i-1]) && (arr[i] > arr[i+1])) //PEAK CONDITION\\n            {\\n                int start_root = i;\\n                int end_root = i;\\n                while( start_root>0 && arr[start_root] > arr[start_root-1])\\n                {\\n                    start_root--; //getting start root\\n                    \\n                }\\n                while( end_root<n-1 && arr[end_root] > arr[end_root+1] )\\n                {\\n                    end_root++; //getting end root\\n                }\\n                max_length = max(max_length,(end_root-start_root+1));\\n                i = end_root;\\n            }\\n        }\\n        return max_length;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937652,
                "title": "python-one-pass-o-1-space-explained",
                "content": "Let us traverse our numbers and keep two variables: `state` and `length`, where:\\n1. `state` is current state of our mountain: it is `0` in the beginning and also means that we can not start our mountain from given index. `state` equal to `1` means, that we are on increasing phase of our mountain and `state` equal `2` means, that we are on decreasing phase of our mountain.\\n2. `length` is current length of mountain built so far.\\n\\nNow, we need to carefully look at our states and see what we need to do in one or another situation:\\n1. If `state` is equal to `0` or `1` and next element is more than current, it means we can continue to build increasing phase of mountain: so, we put `state` equal to `1` and increase `length` by `1`.\\n2. If `state` is equal to `2` and next element is more then curren, it means, that previous mountain just finished and we are currently buildind next mountain, for examle in `0,1,0,2,0`: first mountain is `0,1,0` and second is `0,2,0`. In this case we already build `2` elements of new mountain (mountains have `1` common element), so we put `length = 2` and `state = 1`.\\n3. If `state` is equal to `1` or `2` and next element is less than current, it means that we are on the decreasing phase of mountain: we put `state = 2` and also increase `length` by `1`. Note, that only here we need to update `max_len`, because our mountain is legible on this stage.\\n4. Finally, if we have some other option: it is either next element is equal to current, or we have state `0` and next element is less than previous, we need put our `state` and `length` to values as we just started.\\n\\n**Complexity**: time complexity is `O(n)`, we make one pass over data, space complexity is `O(1)`.\\n\\n```\\nclass Solution:\\n    def longestMountain(self, A):\\n        n, max_len = len(A), 0\\n        state, length = 0, 1\\n        for i in range(n-1):\\n            if state in [0, 1] and A[i+1] > A[i]:\\n                state, length = 1, length + 1\\n            elif state == 2 and A[i+1] > A[i]:\\n                state, length = 1, 2\\n            elif state in [1, 2] and A[i+1] < A[i]:\\n                state, length = 2, length + 1\\n                max_len = max(length, max_len)\\n            else:\\n                state, length = 0, 1\\n                \\n        return max_len\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, A):\\n        n, max_len = len(A), 0\\n        state, length = 0, 1\\n        for i in range(n-1):\\n            if state in [0, 1] and A[i+1] > A[i]:\\n                state, length = 1, length + 1\\n            elif state == 2 and A[i+1] > A[i]:\\n                state, length = 1, 2\\n            elif state in [1, 2] and A[i+1] < A[i]:\\n                state, length = 2, length + 1\\n                max_len = max(length, max_len)\\n            else:\\n                state, length = 0, 1\\n                \\n        return max_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 244213,
                "title": "java-find-peak-and-stretch-easy-to-understand-o-2n",
                "content": "\\n```\\n\\npublic int longestMountain(int[] A) {\\n        if( A == null || A.length <3) \\n            return 0; \\n        int ans = 0; \\n        for(int i = 1; i < A.length - 1; i++ ) {\\n            if(A[i] > A[i-1] && A[i] > A[i+1]) {  // i is a peak\\n                int left = i -1;    // find leftmost of the peak\\n                while(left > 0 && A[left-1] < A[left])\\n                    left--;\\n                \\n                int right= i+1;  // find rightmost of the peak\\n                while(right < A.length - 1 && A[right + 1] < A[right])\\n                    right++;\\n                \\n                ans = Math.max(ans, right - left +1);  // get the width using left and rightmost\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\npublic int longestMountain(int[] A) {\\n        if( A == null || A.length <3) \\n            return 0; \\n        int ans = 0; \\n        for(int i = 1; i < A.length - 1; i++ ) {\\n            if(A[i] > A[i-1] && A[i] > A[i+1]) {  // i is a peak\\n                int left = i -1;    // find leftmost of the peak\\n                while(left > 0 && A[left-1] < A[left])\\n                    left--;\\n                \\n                int right= i+1;  // find rightmost of the peak\\n                while(right < A.length - 1 && A[right + 1] < A[right])\\n                    right++;\\n                \\n                ans = Math.max(ans, right - left +1);  // get the width using left and rightmost\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1494992,
                "title": "easy-to-understand-c-o-n-time-o-1-space-beats-98-code-with-explanation",
                "content": "***If you like my approach,Please upvote this***\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        int i=1;\\n        int upper,lower;\\n        \\n        while(i<n)\\n       {    upper=0;lower=0;                  //Each time after traversing one mountain or not,we have to set upper & lower to 0\\n            while(i<n && arr[i-1]==arr[i])    //   for flat array,where elements are equal\\n              i++;                            //This also handles when we get same adjacent elements\\n            while(i<n && arr[i-1]<arr[i])     //Increasing part of mountain\\n            {  upper++;i++;\\n                \\n            }\\n                    \\n            \\n           while(i<n && arr[i-1]>arr[i])    //Decreasing part of mountain \\n           {\\n               lower++;\\n               i++;    \\n           } \\n          if(upper && lower)       //Mountain only exists if we have both incresing part and decreasing part adjacently\\n           { ans=max(ans,lower+upper+1);\\n           }\\n        \\n        }\\n        \\n        return ans;\\n     \\n    }\\n};\\n```\\n***Another Variation if we need to choose Subsequence not subarray***\\n***                                                                                                                         ***\\n***                                                                                                                         ***\\n```\\n class Solution\\n public:\\n   int longestMountain(vector<int>&arr){          //        This is valid if we are choosing subsequence not subarray.   //  \\n        vector<int> LIS(n,1);\\n        vector<int> LDS(n,1);\\n        for(int i=0;i<n;i++)\\n        {                                   //This is for longest increasing subsequence\\n            for(int j=i-1;j>=0;j--) \\n            {    if(arr[i]>arr[j] && LIS[j]+1>LIS[i])\\n                    LIS[i]=LIS[j]+1;\\n                \\n            }\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {                                     // This is for longest decreasing subsequence from start or Longest increasing from end \\n            for(int j=i+1;j<n;j++)\\n            {    if(arr[i]>arr[j] && LDS[j]+1>LDS[i])\\n                    LDS[i]=LDS[j]+1;\\n                \\n            }\\n        }\\n        int maxx=0;\\n        for(int i=0;i<n;i++)\\n        {  if(LIS[i]>1 && LDS[i]>1)\\n              maxx=max(maxx,LIS[i]+LDS[i]-1);    \\n        }\\n        if(maxx<3)                               // When length is less than 3 means no valid mountain \\n            return -1;\\n        return maxx;\\n  \\n  }\\n  };\\n  ```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        int i=1;\\n        int upper,lower;\\n        \\n        while(i<n)\\n       {    upper=0;lower=0;                  //Each time after traversing one mountain or not,we have to set upper & lower to 0\\n            while(i<n && arr[i-1]==arr[i])    //   for flat array,where elements are equal\\n              i++;                            //This also handles when we get same adjacent elements\\n            while(i<n && arr[i-1]<arr[i])     //Increasing part of mountain\\n            {  upper++;i++;\\n                \\n            }\\n                    \\n            \\n           while(i<n && arr[i-1]>arr[i])    //Decreasing part of mountain \\n           {\\n               lower++;\\n               i++;    \\n           } \\n          if(upper && lower)       //Mountain only exists if we have both incresing part and decreasing part adjacently\\n           { ans=max(ans,lower+upper+1);\\n           }\\n        \\n        }\\n        \\n        return ans;\\n     \\n    }\\n};\\n```\n```\\n class Solution\\n public:\\n   int longestMountain(vector<int>&arr){          //        This is valid if we are choosing subsequence not subarray.   //  \\n        vector<int> LIS(n,1);\\n        vector<int> LDS(n,1);\\n        for(int i=0;i<n;i++)\\n        {                                   //This is for longest increasing subsequence\\n            for(int j=i-1;j>=0;j--) \\n            {    if(arr[i]>arr[j] && LIS[j]+1>LIS[i])\\n                    LIS[i]=LIS[j]+1;\\n                \\n            }\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {                                     // This is for longest decreasing subsequence from start or Longest increasing from end \\n            for(int j=i+1;j<n;j++)\\n            {    if(arr[i]>arr[j] && LDS[j]+1>LDS[i])\\n                    LDS[i]=LDS[j]+1;\\n                \\n            }\\n        }\\n        int maxx=0;\\n        for(int i=0;i<n;i++)\\n        {  if(LIS[i]>1 && LDS[i]>1)\\n              maxx=max(maxx,LIS[i]+LDS[i]-1);    \\n        }\\n        if(maxx<3)                               // When length is less than 3 means no valid mountain \\n            return -1;\\n        return maxx;\\n  \\n  }\\n  };\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 937617,
                "title": "java-short-one-pass-o-n-time-o-1-space-with-comments",
                "content": "```\\n\\tpublic int longestMountain(int[] A) {\\n        int max = 0, inc = 0, dec = 0;\\n        \\n        for(int i=1; i<A.length; i++){\\n            if(A[i] > A[i-1]){       // Current number greater than the previous\\n                if(dec > 0) inc = 0; // Reset inc if we had a decreasing sequence until the previous\\n\\t\\t\\t\\tinc++;               // Increment inc\\n                dec = 0;             // Reset dec\\n            }\\n            else if(A[i] < A[i-1]){  // Current number smaller than the previous\\n                if(inc > 0){         // No need to do anything if we did not have an increasing sequence\\n                    dec++;           // Increment dec\\n                    max = Math.max(max, inc + dec + 1);  // Determine max for the current mountain\\n                }\\n            }\\n            else inc = dec = 0;      // Current number same as the previous, reset inc and dec\\n        }\\n        \\n        return max;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic int longestMountain(int[] A) {\\n        int max = 0, inc = 0, dec = 0;\\n        \\n        for(int i=1; i<A.length; i++){\\n            if(A[i] > A[i-1]){       // Current number greater than the previous\\n                if(dec > 0) inc = 0; // Reset inc if we had a decreasing sequence until the previous\\n\\t\\t\\t\\tinc++;               // Increment inc\\n                dec = 0;             // Reset dec\\n            }\\n            else if(A[i] < A[i-1]){  // Current number smaller than the previous\\n                if(inc > 0){         // No need to do anything if we did not have an increasing sequence\\n                    dec++;           // Increment dec\\n                    max = Math.max(max, inc + dec + 1);  // Determine max for the current mountain\\n                }\\n            }\\n            else inc = dec = 0;      // Current number same as the previous, reset inc and dec\\n        }\\n        \\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 637837,
                "title": "java-3-passes-o-n",
                "content": "`left[i]` means the length of the left part of the mountain whose peak is a[i]\\n`right[i]` means the length of the right part of the mountain whose peak is a[i]\\nIf `left[i]` or `right[i]` is 0, this means that a[i] can\\'t be the peak.\\nThen just traversing again to get the longest mountain length;\\n```\\nclass Solution {\\n    public int longestMountain(int[] a) {\\n        int[] left = new int[a.length]; \\n        for (int i = 0 ; i < a.length; i++) {\\n            if (i != 0) {\\n                if (a[i] > a[i - 1]) {\\n                    left[i] = left[i - 1] + 1;\\n                }\\n            }\\n        }\\n        int[] right = new int[a.length];\\n        for (int i = a.length - 1; i >= 0 ; i--) {\\n            if (i != a.length - 1) {\\n                if (a[i] > a[i + 1]) {\\n                    right[i] = right[i + 1] + 1;\\n                }\\n            }\\n        }\\n        int max = 0;\\n        for (int i = 0 ; i < a.length ; i++) {\\n            if (left[i] != 0 && right[i] != 0) {\\n                max = Math.max(left[i] + right[i] + 1, max);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] a) {\\n        int[] left = new int[a.length]; \\n        for (int i = 0 ; i < a.length; i++) {\\n            if (i != 0) {\\n                if (a[i] > a[i - 1]) {\\n                    left[i] = left[i - 1] + 1;\\n                }\\n            }\\n        }\\n        int[] right = new int[a.length];\\n        for (int i = a.length - 1; i >= 0 ; i--) {\\n            if (i != a.length - 1) {\\n                if (a[i] > a[i + 1]) {\\n                    right[i] = right[i + 1] + 1;\\n                }\\n            }\\n        }\\n        int max = 0;\\n        for (int i = 0 ; i < a.length ; i++) {\\n            if (left[i] != 0 && right[i] != 0) {\\n                max = Math.max(left[i] + right[i] + 1, max);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937743,
                "title": "python-3-explained-solution-video-code",
                "content": "[](https://www.youtube.com/watch?v=FpO3fY-1mj8)\\nhttps://www.youtube.com/watch?v=FpO3fY-1mj8\\n```\\nclass Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        res = 0\\n        \\n        for indx in range(1, len(A) - 1):\\n            if A[indx - 1] < A[indx] > A[indx + 1]:\\n                \\n                l = r = indx\\n                \\n                while l > 0 and A[l] > A[l - 1]:\\n                    l -= 1\\n                \\n                while r + 1 < len(A) and A[r] > A[r + 1]:\\n                    r += 1\\n                \\n                res = max(res, (r - l + 1))\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        res = 0\\n        \\n        for indx in range(1, len(A) - 1):\\n            if A[indx - 1] < A[indx] > A[indx + 1]:\\n                \\n                l = r = indx\\n                \\n                while l > 0 and A[l] > A[l - 1]:\\n                    l -= 1\\n                \\n                while r + 1 < len(A) and A[r] > A[r + 1]:\\n                    r += 1\\n                \\n                res = max(res, (r - l + 1))\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 419003,
                "title": "easy-to-understand-c-solution-20ms-beats-91",
                "content": "Runtime: 20 ms, faster than 91.45% of C++ online submissions for Longest Mountain in Array.\\nMemory Usage: 9.9 MB, less than 100.00% of C++ online submissions for Longest Mountain in Array.\\n\\n```\\nint longestMountain(vector<int>& A) {\\n        \\n        if(A.size() == 0)\\n            return 0;\\n        \\n        int maxLen = 0; \\n        for(int i=1; i<A.size()-1; i++)\\n        {\\n            if(A[i] > A[i+1] && A[i] > A[i-1])\\n            {\\n                int left = i-1;\\n                int right = i+1;\\n                \\n                while(left > 0 && A[left-1] < A[left])\\n                    left--;\\n                while(right < A.size()-1 && A[right+1] < A[right])\\n                    right++;\\n                maxLen = max(maxLen, right-left+1);\\n            }\\n        }\\n        return maxLen;\\n    }",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "Runtime: 20 ms, faster than 91.45% of C++ online submissions for Longest Mountain in Array.\\nMemory Usage: 9.9 MB, less than 100.00% of C++ online submissions for Longest Mountain in Array.\\n\\n```\\nint longestMountain(vector<int>& A) {\\n        \\n        if(A.size() == 0)\\n            return 0;\\n        \\n        int maxLen = 0; \\n        for(int i=1; i<A.size()-1; i++)\\n        {\\n            if(A[i] > A[i+1] && A[i] > A[i-1])\\n            {\\n                int left = i-1;\\n                int right = i+1;\\n                \\n                while(left > 0 && A[left-1] < A[left])\\n                    left--;\\n                while(right < A.size()-1 && A[right+1] < A[right])\\n                    right++;\\n                maxLen = max(maxLen, right-left+1);\\n            }\\n        }\\n        return maxLen;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1107624,
                "title": "6-liner-c-peak-valley-approach",
                "content": "```\\nint longestMountain(vector<int>& arr) {\\n        \\n        int maxl = 0, i = 1;\\n        \\n        while(i < arr.size()) {\\n            \\n            int peak = 0, valley = 0;\\n            while(i < arr.size() && arr[i] > arr[i - 1]) peak++, i++;\\n            while(i < arr.size() && arr[i] < arr[i - 1]) valley++, i++;\\n            if(peak > 0 && valley > 0) maxl = max(maxl, peak + valley + 1);\\n            else if(!peak && !valley) i++;\\n        }\\n        return maxl;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint longestMountain(vector<int>& arr) {\\n        \\n        int maxl = 0, i = 1;\\n        \\n        while(i < arr.size()) {\\n            \\n            int peak = 0, valley = 0;\\n            while(i < arr.size() && arr[i] > arr[i - 1]) peak++, i++;\\n            while(i < arr.size() && arr[i] < arr[i - 1]) valley++, i++;\\n            if(peak > 0 && valley > 0) maxl = max(maxl, peak + valley + 1);\\n            else if(!peak && !valley) i++;\\n        }\\n        return maxl;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 135612,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        if (A.length < 3) return 0;\\n        int[] increase = new int[A.length];\\n        int[] decrease = new int[A.length];\\n        Arrays.fill(increase, 1);\\n        Arrays.fill(decrease, 1);\\n        for (int i = 1; i < A.length; i++) {\\n            if (A[i] > A[i-1]) increase[i] = increase[i-1]+1;\\n        }\\n       \\n        \\n        for (int i = A.length-2; i >= 0; i--) {\\n            if (A[i] > A[i+1]) decrease[i] = decrease[i+1]+1;\\n        }\\n       \\n        int res = Integer.MIN_VALUE;\\n        for (int i = 1; i < A.length - 1; i++) {\\n            if (A[i] > A[i-1] && A[i] > A[i+1]) {\\n                res = Math.max(res, increase[i-1] + decrease[i+1] + 1);\\n            }\\n        }\\n        return res == Integer.MIN_VALUE ? 0 : res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        if (A.length < 3) return 0;\\n        int[] increase = new int[A.length];\\n        int[] decrease = new int[A.length];\\n        Arrays.fill(increase, 1);\\n        Arrays.fill(decrease, 1);\\n        for (int i = 1; i < A.length; i++) {\\n            if (A[i] > A[i-1]) increase[i] = increase[i-1]+1;\\n        }\\n       \\n        \\n        for (int i = A.length-2; i >= 0; i--) {\\n            if (A[i] > A[i+1]) decrease[i] = decrease[i+1]+1;\\n        }\\n       \\n        int res = Integer.MIN_VALUE;\\n        for (int i = 1; i < A.length - 1; i++) {\\n            if (A[i] > A[i-1] && A[i] > A[i+1]) {\\n                res = Math.max(res, increase[i-1] + decrease[i+1] + 1);\\n            }\\n        }\\n        return res == Integer.MIN_VALUE ? 0 : res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 945774,
                "title": "c-linear-solution-explained-100-time-50-space",
                "content": "Nice one I took my time to polish a bit and I had fun thinking about how to optimise reducing the amount of conditions/states we would have to consider.\\n\\nTo solve it, first of all let\\'s get equipped with a few variables:\\n* `res` will store the value of the maximum mountain found so far;\\n* `curr` is the value of the ongoing mountain length;\\n* `len` is the length of the initial input;\\n* `isMountain` and `isDescending` are 2 booleans to store the state, precisely in the guise their name implies.\\n\\nWe will then start looping from index `i == 1` across the whole vector and:\\n* if we are descending we will:\\n\\t* check if we need to reset our range - if either `isDescending` was `true` or `isMountain` was `false` and, in that case, we:\\n\\t\\t* set `isDescending` to `false`;\\n\\t\\t* set `isMountain` to `true`;\\n\\t\\t* reset `curr` to `1` (note: not to `0`, since we count both extremes of the range in its length);\\n\\t* in any case, we increment `curr` by one step;\\n* if we are in a mountain already and only in that case, we will:\\n\\t* if we are descending we will:\\n\\t\\t* flag `isDescending` as `true`;\\n\\t\\t* update `res` to be the maximum between its current value and the incremented value of `curr`;\\n\\t* if instead we reached a plataue, we reset `isMountain` (which in turn will trigger other variables resetting as soon as we start ascending again and only in that case).\\n\\nOnce we are done, we can return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        // support variables\\n        int res = 0, curr = 0, len = arr.size();\\n        bool isMountain = false, isDescending = false;\\n        for (int i = 1; i < len; i++) {\\n            // checking if we are climbing\\n            if (arr[i] > arr[i - 1]) {\\n                // reset conditions: either we were descending or we were\\n                // not yet in a mountain\\n                if (isDescending || !isMountain) {\\n                    isDescending = false;\\n                    isMountain = true;\\n                    curr = 1;\\n                }\\n                curr++;\\n            }\\n            // checking if we are already in a mountain\\n            else if (isMountain) {\\n                // if we start descending\\n                if  (arr[i] < arr[i - 1]) {\\n                    isDescending = true;\\n                    res = max(++curr, res);\\n                }\\n                // if we reach a plateau\\n                else if (arr[i] == arr[i - 1]) isMountain = false;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nSlightly optimised version (I gained 4ms on average running this) in which we update `res` only when either we begin ascending again or we finished the loop while still descending:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        // support variables\\n        int res = 0, curr = 0, len = arr.size();\\n        bool isMountain = false, isDescending = false;\\n        for (int i = 1; i < len; i++) {\\n            // checking if we are climbing\\n            if (arr[i] > arr[i - 1]) {\\n                // reset conditions: either we were descending or we were\\n                // not yet in a mountain\\n                if (isDescending || !isMountain) {\\n                    if (isDescending) res = max(curr, res);\\n                    isDescending = false;\\n                    isMountain = true;\\n                    curr = 1;\\n                }\\n                curr++;\\n            }\\n            // checking if we are already in a mountain\\n            else if (isMountain) {\\n                // if we start descending\\n                if  (arr[i] < arr[i - 1]) {\\n                    isDescending = true;\\n                    curr++;\\n                }\\n                // if we reach a plateau\\n                else if (arr[i] == arr[i - 1]) {\\n                    isMountain = false;\\n                }\\n            }\\n        }\\n        if (isDescending) res = max(curr, res);\\n        return res;\\n    }\\n};\\n```\\n\\nThe first version of my code, which for some reason I have not completely clarified went much slower, taking about double time:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        if (!arr.size()) return 0;\\n        int res = 0, prev = arr[0], len = arr.size() - 1, minPos = -2, maxPos = -1;\\n        for (int i = 0, n; i < len; i++) {\\n            n = arr[i];\\n            // checking for a new min\\n            if (minPos < maxPos && n < arr[i + 1]) {\\n                // updating res if we already met a max\\n                if (maxPos > -1) res = max(res, i - minPos + 1);\\n                minPos = i;\\n                maxPos = -1;\\n            }\\n            // checking for a new max, only after having met a min\\n            else if (n > arr[i + 1] && minPos > maxPos) maxPos = i;\\n            // checking if we encountered a plateau\\n            else if (n == arr[i + 1]) {\\n                // we update res only if we already encountered a max after the last min\\n                // followed by at least another decreasing number\\n                if (minPos < maxPos && minPos > -2 && maxPos > -1) res = max(res, i - minPos + 1);\\n                minPos = -2;\\n                maxPos = -1;\\n            }\\n        }\\n        // one final check to update res with the distance between minPos and the last index\\n        // provided we have encountered a local maximum before\\n        if (maxPos > -1 && arr[len - 1] > arr[len]) res = max(res, len - minPos + 1);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        // support variables\\n        int res = 0, curr = 0, len = arr.size();\\n        bool isMountain = false, isDescending = false;\\n        for (int i = 1; i < len; i++) {\\n            // checking if we are climbing\\n            if (arr[i] > arr[i - 1]) {\\n                // reset conditions: either we were descending or we were\\n                // not yet in a mountain\\n                if (isDescending || !isMountain) {\\n                    isDescending = false;\\n                    isMountain = true;\\n                    curr = 1;\\n                }\\n                curr++;\\n            }\\n            // checking if we are already in a mountain\\n            else if (isMountain) {\\n                // if we start descending\\n                if  (arr[i] < arr[i - 1]) {\\n                    isDescending = true;\\n                    res = max(++curr, res);\\n                }\\n                // if we reach a plateau\\n                else if (arr[i] == arr[i - 1]) isMountain = false;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        // support variables\\n        int res = 0, curr = 0, len = arr.size();\\n        bool isMountain = false, isDescending = false;\\n        for (int i = 1; i < len; i++) {\\n            // checking if we are climbing\\n            if (arr[i] > arr[i - 1]) {\\n                // reset conditions: either we were descending or we were\\n                // not yet in a mountain\\n                if (isDescending || !isMountain) {\\n                    if (isDescending) res = max(curr, res);\\n                    isDescending = false;\\n                    isMountain = true;\\n                    curr = 1;\\n                }\\n                curr++;\\n            }\\n            // checking if we are already in a mountain\\n            else if (isMountain) {\\n                // if we start descending\\n                if  (arr[i] < arr[i - 1]) {\\n                    isDescending = true;\\n                    curr++;\\n                }\\n                // if we reach a plateau\\n                else if (arr[i] == arr[i - 1]) {\\n                    isMountain = false;\\n                }\\n            }\\n        }\\n        if (isDescending) res = max(curr, res);\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        if (!arr.size()) return 0;\\n        int res = 0, prev = arr[0], len = arr.size() - 1, minPos = -2, maxPos = -1;\\n        for (int i = 0, n; i < len; i++) {\\n            n = arr[i];\\n            // checking for a new min\\n            if (minPos < maxPos && n < arr[i + 1]) {\\n                // updating res if we already met a max\\n                if (maxPos > -1) res = max(res, i - minPos + 1);\\n                minPos = i;\\n                maxPos = -1;\\n            }\\n            // checking for a new max, only after having met a min\\n            else if (n > arr[i + 1] && minPos > maxPos) maxPos = i;\\n            // checking if we encountered a plateau\\n            else if (n == arr[i + 1]) {\\n                // we update res only if we already encountered a max after the last min\\n                // followed by at least another decreasing number\\n                if (minPos < maxPos && minPos > -2 && maxPos > -1) res = max(res, i - minPos + 1);\\n                minPos = -2;\\n                maxPos = -1;\\n            }\\n        }\\n        // one final check to update res with the distance between minPos and the last index\\n        // provided we have encountered a local maximum before\\n        if (maxPos > -1 && arr[len - 1] > arr[len]) res = max(res, len - minPos + 1);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937951,
                "title": "c-dp-simplification-from-2pass-to-1-pass",
                "content": "```\\nclass Solution {// DP: two pass\\npublic://Time/Space: O(N); O(N)\\n    int longestMountain(vector<int>& A) {\\n        const int N = A.size();\\n        vector<int> ups(N, 0), downs(N, 0);\\n        for(int i = 1; i < N; i++) if(A[i] > A[i-1]) ups[i] = ups[i-1]+1;\\n        int ans = 0;\\n        for(int i = N - 1; i >= 0; i--){\\n            if(i < N - 1 && A[i] > A[i+1]) downs[i] = downs[i+1]+1;\\n            if(ups[i] && downs[i]) ans = max(ans, ups[i] + downs[i] + 1);            \\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIllustration with Example 1: \\n[2,1,4,7,3,2,5]\\n[1,4,7,3,2] \\n\\n\\nIn this solution, accumulate latest up length and down length.\\nBoth up and down length are reset to 0 when \\ni) A[i - 1] == A[i], which means we are in plateau\\nor\\nii) down > 0 && A[i - 1] < A[i], which means a new up trend begin like the middle point of \\'M\\'\\n\\n\\n```\\nclass Solution { // DP\\uFF1A One Pass\\npublic:// Time/Space: O(N); O(1)\\n    int longestMountain(vector<int>& A) {\\n        int ans = 0, up = 0, down = 0;\\n        for(int i = 1; i < A.size(); i++){\\n            if(down && A[i-1]<A[i] || A[i-1] == A[i]) up = down = 0;\\n            up += A[i-1] < A[i];\\n            down += A[i-1] > A[i];\\n            if(up && down) ans = max(ans, up + down + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nReferece\\n[1]: https://leetcode.com/problems/longest-mountain-in-array/discuss/135593/C%2B%2BJavaPython-1-pass-and-O(1)-space\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {// DP: two pass\\npublic://Time/Space: O(N); O(N)\\n    int longestMountain(vector<int>& A) {\\n        const int N = A.size();\\n        vector<int> ups(N, 0), downs(N, 0);\\n        for(int i = 1; i < N; i++) if(A[i] > A[i-1]) ups[i] = ups[i-1]+1;\\n        int ans = 0;\\n        for(int i = N - 1; i >= 0; i--){\\n            if(i < N - 1 && A[i] > A[i+1]) downs[i] = downs[i+1]+1;\\n            if(ups[i] && downs[i]) ans = max(ans, ups[i] + downs[i] + 1);            \\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution { // DP\\uFF1A One Pass\\npublic:// Time/Space: O(N); O(1)\\n    int longestMountain(vector<int>& A) {\\n        int ans = 0, up = 0, down = 0;\\n        for(int i = 1; i < A.size(); i++){\\n            if(down && A[i-1]<A[i] || A[i-1] == A[i]) up = down = 0;\\n            up += A[i-1] < A[i];\\n            down += A[i-1] > A[i];\\n            if(up && down) ans = max(ans, up + down + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 406481,
                "title": "java-b-f-one-pass-dp-solutions-with-explanations-easy-understand",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/longest-mountain-in-array/)\\nDifficulty: <span class=\"orange\">Medium</span>\\n\\n## Problem\\n\\n> Let\\'s call any (contiguous) subarray B (of A) a mountain if the following properties hold:\\n\\n- B.length >= 3\\n- There exists some `0 < i < B.length - 1` such that `B[0] < B[1] < ... B[i-1] < B[i] > B[i+1] > ... > B[B.length - 1]`\\n\\n(Note that B could be any subarray of A, including the entire array A.)\\n\\n> Given an array A of integers, return the length of the longest mountain. \\n\\n> Return `0` if there is no mountain.\\n\\n**Note:** \\n\\n- 0 <= A.length <= 10000\\n  - Indicate that `O(N^2)` is not okay.\\n- 0 <= A[i] <= 10000\\n\\n**Example:** \\n\\n```java\\nInput: [2,2,2] or [1,2,2]\\nOutput: 0\\nExplanation: There is no mountain.\\n\\nInput: [1,2,3]\\nOutput: 0\\n\\nInput: [2,1,4,7,3,2,5]\\n          --------- 5\\nOutput: 5\\nExplanation: The largest mountain is [1,4,7,3,2] which has length 5.\\n\\nInput: [2,1,4,7,3,2,3,7,6,5,1]\\n          --------- 5\\n                  ----------- 6\\nOutput: 6\\n```\\n\\n**Follow up:** \\n\\n- Can you solve it using only one pass?\\n- Can you solve it in O(1) space?\\n\\n\\n## Analysis\\n\\n### Brute-Force\\n\\nFor an array of size `n`, we compute the mountain lengths for every subarray from size at least `3` to `n`.\\n\\n**Note:** Be very careful about the index update.\\n\\n```java\\npublic int longestMountain(int[] A) {\\n  int n = A.length;\\n  int maxLen = 0;\\n  for (int len = 3; len <= n; ++len) {\\n    for (int i = 0; i + len - 1 < n; ++i) {\\n      int end = i + len - 1;\\n      maxLen = Math.max(maxLen, mountainLen(A, i, end));\\n    }\\n  }\\n  return maxLen;\\n}\\n```\\n\\nIn terms of the mountain length calculation (the mountain should start from the first element), check out the examples in comments. The following code is similar to the one-pointer solution.\\n\\n```java\\nprivate int mountainLen(int[] A, int lo, int hi) {\\n  int n = hi - lo + 1;\\n  if (n < 3) {\\n    return 0;\\n  }\\n  // 5 4 3 2 1    -> no mountain\\n  //   i\\n  // 1 2 3 4 5    -> no mountain\\n  //   i       i\\n  // 1 2 3 2 1    -> returns i = n\\n  //   i   i   i\\n  // 1 2 3 2 1 2  -> returns i = n - 1 (not includes the last element)\\n  //   i   i   i \\n  int i = lo + 1;\\n  while (i <= hi && A[i - 1] < A[i]) {\\n    ++i;\\n  }\\n  if (i == lo + 1 || i == hi + 1) return 0; // no mountain\\n  // i now points to the first element that A[i - 1] > A[i]\\n  while (i <= hi && A[i - 1] > A[i]) {\\n    ++i;\\n  }\\n  return i - lo;\\n}\\n```\\n\\n**Time:** `O(N^3)` (unacceptable)\\n**Space:** `O(1)`\\n\\n\\n\\n### One-Pass (one pointer)\\n\\nBy observation of the example below, we can actually go through the array and get the maximum mountain length in one pass.\\n\\n```java\\n 0 1 2 3 4 5 6 7 8 9 10\\n[2,1,4,7,3,2,3,7,6,5,1]\\n   --------- 5\\n           ----------- 6\\n```\\n\\nIn order to do that, we have to simulate the `going-up` and `going-down` processes in order. For example, while going up, the start point is at `1`, the peek is at `3`, and the end point is at `5`. We cannot go further, so we have a mountain of length 5. We do that for the following mountain until we reach the end of the array.\\n\\nThe idea is not difficult, but the implementation is because of index manipulation and special/corner cases. Try to come up with some small examples and get some invariants.\\n\\n**Note:** \\n\\n- Since we check elements at `A[i]` and `A[i + 1]`, the condition is `i < n - 1`.\\n- Record the starting point in each process, reconstruct a new mountain if `i` does not move at all (which means invalidity).\\n- Go through your code for cases: `[1,2,2]`, `[2]`, `[1,2,3]`, `[3,2,1]`.\\n\\n```java\\npublic int longestMountain(int[] A) {\\n  int n = A.length;\\n  int maxLen = 0;\\n  int i = 0;\\n  while (i < n - 1) {\\n    int upStart = i;\\n    // Go up\\n    while (i < n - 1 && A[i] < A[i + 1]) ++i;\\n    if (i == upStart) { // does not move\\n      ++i; continue;\\n    } // i stops the peek\\n    // Go down\\n    int downStart = i;\\n    while (i < n - 1 && A[i] > A[i + 1]) ++i;\\n    if (i == downStart) {\\n      ++i; continue;\\n    } // i stops at the last in the subarray\\n    // Update length\\n    int len = i - upStart + 1;\\n    maxLen = Math.max(maxLen, len);\\n  }\\n  return maxLen;\\n}\\n```\\n\\n**Time:** `O(N)`\\n**Space:** `O(1)`\\n\\n\\n\\n### DP\\n\\nUse extra two arrays `inc[]` and `dec[]` to store information we need and then go through the array.\\n\\n- **inc[i]**: The maximum increasing length for the subarray ending at `i`. (constructed from left)\\n  - For example: `[1,2,3]` the `inc[i] = [0,1,2]`.\\n- **dec[i]**: The maximum decreasing length for the subarray starting at `i`. (constructed from right)\\n- Both `inc[]` and `dec[]` are initialized with `0`.\\n\\nThen we go through the array from `1` to `n - 1` for each possible peak. We calculate the peak only when `inc[i]` and `dec[i]` are both non-zero.\\n\\n**Note:** The length is `inc[i] + dec[i] + 1`.\\n\\n```java\\n// inc[] and inc[] are initialized with 0\\nindex    0   1   2   3   4   5   6   7   8   9   10\\n------------------------------------------------------\\n         2   1   4   7   3   2   3   7   6   5   1\\ninc[i]   0   0   1   2   0   0   1   2   0   0   0\\ndec[i]   0   0   0   2   1   0   0   3   2   1   0\\n------------------------------------------------------\\nlen          0   0 4+1=5 0   0   0 5+1=6 0   0   0\\n```\\n\\nHere is the code:\\n\\n```java\\npublic int longestMountain(int[] A) {\\n  int n = A.length;\\n  int[] inc = new int[n]; // init with 0\\n  int[] dec = new int[n]; \\n  for (int i = 1, j = n - 2; i < n; ++i, --j) {\\n    if (A[i - 1] < A[i]) inc[i] = inc[i - 1] + 1;\\n    if (A[j] > A[j + 1]) dec[j] = dec[j + 1] + 1;\\n    // otherwise, keep it 0\\n  }\\n  // for each possible peak\\n  int maxLen = 0;\\n  for (int i = 1; i < n - 1; ++i) {\\n    if (inc[i] > 0 && dec[i] > 0) {\\n      maxLen = Math.max(maxLen, inc[i] + dec[i] + 1);\\n    }\\n  }\\n  return maxLen;\\n}\\n```\\n\\n**Time:** `O(N)`\\n**Space:** `O(N)`",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\nInput: [2,2,2] or [1,2,2]\\nOutput: 0\\nExplanation: There is no mountain.\\n\\nInput: [1,2,3]\\nOutput: 0\\n\\nInput: [2,1,4,7,3,2,5]\\n          --------- 5\\nOutput: 5\\nExplanation: The largest mountain is [1,4,7,3,2] which has length 5.\\n\\nInput: [2,1,4,7,3,2,3,7,6,5,1]\\n          --------- 5\\n                  ----------- 6\\nOutput: 6\\n```\n```java\\npublic int longestMountain(int[] A) {\\n  int n = A.length;\\n  int maxLen = 0;\\n  for (int len = 3; len <= n; ++len) {\\n    for (int i = 0; i + len - 1 < n; ++i) {\\n      int end = i + len - 1;\\n      maxLen = Math.max(maxLen, mountainLen(A, i, end));\\n    }\\n  }\\n  return maxLen;\\n}\\n```\n```java\\nprivate int mountainLen(int[] A, int lo, int hi) {\\n  int n = hi - lo + 1;\\n  if (n < 3) {\\n    return 0;\\n  }\\n  // 5 4 3 2 1    -> no mountain\\n  //   i\\n  // 1 2 3 4 5    -> no mountain\\n  //   i       i\\n  // 1 2 3 2 1    -> returns i = n\\n  //   i   i   i\\n  // 1 2 3 2 1 2  -> returns i = n - 1 (not includes the last element)\\n  //   i   i   i \\n  int i = lo + 1;\\n  while (i <= hi && A[i - 1] < A[i]) {\\n    ++i;\\n  }\\n  if (i == lo + 1 || i == hi + 1) return 0; // no mountain\\n  // i now points to the first element that A[i - 1] > A[i]\\n  while (i <= hi && A[i - 1] > A[i]) {\\n    ++i;\\n  }\\n  return i - lo;\\n}\\n```\n```java\\n 0 1 2 3 4 5 6 7 8 9 10\\n[2,1,4,7,3,2,3,7,6,5,1]\\n   --------- 5\\n           ----------- 6\\n```\n```java\\npublic int longestMountain(int[] A) {\\n  int n = A.length;\\n  int maxLen = 0;\\n  int i = 0;\\n  while (i < n - 1) {\\n    int upStart = i;\\n    // Go up\\n    while (i < n - 1 && A[i] < A[i + 1]) ++i;\\n    if (i == upStart) { // does not move\\n      ++i; continue;\\n    } // i stops the peek\\n    // Go down\\n    int downStart = i;\\n    while (i < n - 1 && A[i] > A[i + 1]) ++i;\\n    if (i == downStart) {\\n      ++i; continue;\\n    } // i stops at the last in the subarray\\n    // Update length\\n    int len = i - upStart + 1;\\n    maxLen = Math.max(maxLen, len);\\n  }\\n  return maxLen;\\n}\\n```\n```java\\n// inc[] and inc[] are initialized with 0\\nindex    0   1   2   3   4   5   6   7   8   9   10\\n------------------------------------------------------\\n         2   1   4   7   3   2   3   7   6   5   1\\ninc[i]   0   0   1   2   0   0   1   2   0   0   0\\ndec[i]   0   0   0   2   1   0   0   3   2   1   0\\n------------------------------------------------------\\nlen          0   0 4+1=5 0   0   0 5+1=6 0   0   0\\n```\n```java\\npublic int longestMountain(int[] A) {\\n  int n = A.length;\\n  int[] inc = new int[n]; // init with 0\\n  int[] dec = new int[n]; \\n  for (int i = 1, j = n - 2; i < n; ++i, --j) {\\n    if (A[i - 1] < A[i]) inc[i] = inc[i - 1] + 1;\\n    if (A[j] > A[j + 1]) dec[j] = dec[j + 1] + 1;\\n    // otherwise, keep it 0\\n  }\\n  // for each possible peak\\n  int maxLen = 0;\\n  for (int i = 1; i < n - 1; ++i) {\\n    if (inc[i] > 0 && dec[i] > 0) {\\n      maxLen = Math.max(maxLen, inc[i] + dec[i] + 1);\\n    }\\n  }\\n  return maxLen;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1022776,
                "title": "java-100-faster-one-pass",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int max = 0;\\n        \\n        for(int i = 1; i < arr.length-1; i++) {\\n            if(arr[i-1] < arr[i] && arr[i] > arr[i+1]) {\\n                int left = i-1;\\n                int right = i+1;\\n                \\n                while(left > 0 && arr[left-1] < arr[left]) left--;\\n                while(right < arr.length-1 && arr[right] > arr[right+1]) right++;\\n                \\n                max = Math.max(max, right-left+1);\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int max = 0;\\n        \\n        for(int i = 1; i < arr.length-1; i++) {\\n            if(arr[i-1] < arr[i] && arr[i] > arr[i+1]) {\\n                int left = i-1;\\n                int right = i+1;\\n                \\n                while(left > 0 && arr[left-1] < arr[left]) left--;\\n                while(right < arr.length-1 && arr[right] > arr[right+1]) right++;\\n                \\n                max = Math.max(max, right-left+1);\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938030,
                "title": "longest-mountain-in-array-java",
                "content": "```\\nclass Solution \\n{\\n    /* First scan the array for peaks (i.e. a value where the previous and next value are both \\n     * lower.)  Once a peak is found scan foreword and back to determine how wide this particular\\n     * peak is.  Return the max of the values found.\\n     */\\n    \\n    public int longestMountain(int[] A) \\n    {\\n        int     ret = 0;\\n        int     n   = A.length - 1; \\n        \\n        for( int i = 1; i < n; i++ )\\n        {\\n            if( A[ i - 1 ] < A[ i ] && A[ i ] > A[ i + 1 ] )\\n            {\\n                int     l = i;\\n                \\n                while( l > 0 && A[ l - 1 ] < A[ l ] )       l--;\\n                while( i < n && A[ i + 1 ] < A[ i ] )       i++;\\n                \\n                ret = Math.max( ret, i - l + 1 );\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    /* First scan the array for peaks (i.e. a value where the previous and next value are both \\n     * lower.)  Once a peak is found scan foreword and back to determine how wide this particular\\n     * peak is.  Return the max of the values found.\\n     */\\n    \\n    public int longestMountain(int[] A) \\n    {\\n        int     ret = 0;\\n        int     n   = A.length - 1; \\n        \\n        for( int i = 1; i < n; i++ )\\n        {\\n            if( A[ i - 1 ] < A[ i ] && A[ i ] > A[ i + 1 ] )\\n            {\\n                int     l = i;\\n                \\n                while( l > 0 && A[ l - 1 ] < A[ l ] )       l--;\\n                while( i < n && A[ i + 1 ] < A[ i ] )       i++;\\n                \\n                ret = Math.max( ret, i - l + 1 );\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150136,
                "title": "simple-o-n-one-pass-o-1-space-java-ac-solution-beats-99-05",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        int longestMountain = 0;\\n        for (int i = 1; i < A.length-1; i++) {\\n            if (A[i-1] < A[i] && A[i+1] < A[i]) {\\n                int l = i-1;\\n                int r = i+1;\\n                while(l > 0 && A[l-1] < A[l]) {\\n                    l--;\\n                }\\n                while(r < A.length-1 && A[r+1] < A[r]) {\\n                    r++;\\n                }\\n                longestMountain = Math.max(longestMountain, (r - l + 1));\\n            }\\n        }\\n        return longestMountain;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        int longestMountain = 0;\\n        for (int i = 1; i < A.length-1; i++) {\\n            if (A[i-1] < A[i] && A[i+1] < A[i]) {\\n                int l = i-1;\\n                int r = i+1;\\n                while(l > 0 && A[l-1] < A[l]) {\\n                    l--;\\n                }\\n                while(r < A.length-1 && A[r+1] < A[r]) {\\n                    r++;\\n                }\\n                longestMountain = Math.max(longestMountain, (r - l + 1));\\n            }\\n        }\\n        return longestMountain;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937867,
                "title": "longest-mountain-in-array-c-explained",
                "content": "The question is very similar to https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/ , I highly recommend you to solve first and give a try to this question before going though the solution.\\n\\nThe idea is simple, since a mountain has a rise(slope or upper_tail) and a fall(descent or lower_tail), we keep track of it.\\n\\nNote that if a mountain exists , it should definietly have a non zero upper_tail and a lower_tail.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int result = 0;\\n        int lower_tail, upper_tail;\\n        \\n        for(int i = 0 ; i < A.size();){\\n            lower_tail = upper_tail = 0;\\n            while(i + 1 < A.size() && A[i] < A[i + 1]){\\n                upper_tail++;\\n                i++;\\n            }\\n             while(upper_tail > 0 && i + 1 < A.size() && A[i] > A[i + 1]){\\n                lower_tail++;\\n                i++;\\n            }\\n            if(lower_tail > 0 && upper_tail > 0)\\n                result = max(result, lower_tail + upper_tail + 1);\\n            else if(lower_tail == 0)\\n                i++;\\n        }\\n        return result;\\n    }\\n};\\n```\\nThank you, Have a nice day",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int result = 0;\\n        int lower_tail, upper_tail;\\n        \\n        for(int i = 0 ; i < A.size();){\\n            lower_tail = upper_tail = 0;\\n            while(i + 1 < A.size() && A[i] < A[i + 1]){\\n                upper_tail++;\\n                i++;\\n            }\\n             while(upper_tail > 0 && i + 1 < A.size() && A[i] > A[i + 1]){\\n                lower_tail++;\\n                i++;\\n            }\\n            if(lower_tail > 0 && upper_tail > 0)\\n                result = max(result, lower_tail + upper_tail + 1);\\n            else if(lower_tail == 0)\\n                i++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937588,
                "title": "c-one-pass-in-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& a) \\n    {\\n        int i,n=a.size(),res,l,h,ind,maxi=0;\\n        if(n==0) return 0;\\n        for(i=1;i<n-1;i++)\\n        {\\n            if(a[i-1]<a[i] && a[i]>a[i+1])\\n            {\\n                l=i-1; h=i+1;\\n                while(l>0 && a[l]>a[l-1]) l--;\\n                while(h<n-1 && a[h]>a[h+1]) h++;\\n                maxi=max(maxi,h-l+1);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& a) \\n    {\\n        int i,n=a.size(),res,l,h,ind,maxi=0;\\n        if(n==0) return 0;\\n        for(i=1;i<n-1;i++)\\n        {\\n            if(a[i-1]<a[i] && a[i]>a[i+1])\\n            {\\n                l=i-1; h=i+1;\\n                while(l>0 && a[l]>a[l-1]) l--;\\n                while(h<n-1 && a[h]>a[h+1]) h++;\\n                maxi=max(maxi,h-l+1);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2304129,
                "title": "c-fastest-solution-o-n-tc-sc-lis",
                "content": "TC: O(n)\\nSC: O(n)\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>left(n,1),right(n,1);\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>nums[i-1])\\n                left[i]=left[i-1]+1;\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i]>nums[i+1])\\n                right[i]=right[i+1]+1;\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(left[i]>1 && right[i]>1)ans=max(ans,left[i]+right[i]-1);\\n                \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>left(n,1),right(n,1);\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>nums[i-1])\\n                left[i]=left[i-1]+1;\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i]>nums[i+1])\\n                right[i]=right[i+1]+1;\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(left[i]>1 && right[i]>1)ans=max(ans,left[i]+right[i]-1);\\n                \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2272599,
                "title": "c-java-python-very-easy-to-understand-one-pass-o-1-space-o-n-time",
                "content": "I would suggest a dry run on an example in order to better understand the code.\\n\\nC++:\\n\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int maxMountain = 0, n = arr.size(), idx = 1, up = 0, down = 0;\\n        while (idx < n) {\\n            while(idx < n && arr[idx - 1] == arr[idx])\\n                ++idx;\\n            // start looking further in array for a possible mountain\\n            up = 0;\\n            while(idx < n && arr[idx - 1] < arr[idx])\\n                ++up, ++idx;\\n            down = 0;\\n            while(idx < n && arr[idx - 1] > arr[idx])\\n                ++down, ++idx;\\n            if(up && down)  \\n                // + 1 as we do add the peak itself\\n                maxMountain = max(maxMountain, up + down + 1);\\n        }\\n        return maxMountain;\\n    }\\n};\\n```\\n\\nJava: \\n\\n```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int maxMountain = 0, idx = 1, up = 0, down = 0, n = arr.length;\\n        while(idx < n) {\\n            while(idx < n && arr[idx - 1] == arr[idx])\\n                ++idx;\\n            up = 0;\\n            while(idx < n && arr[idx - 1] < arr[idx]) {\\n                ++up;\\n                ++idx;\\n            }\\n            down = 0;\\n            while(idx < n && arr[idx - 1] > arr[idx]) {\\n                ++down;\\n                ++idx;\\n            }\\n            if(up > 0 && down > 0)\\n                maxMountain = Math.max(maxMountain, up + down + 1);\\n        }\\n        return maxMountain;\\n    }\\n}\\n```\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        idx = 1\\n        up = 0\\n        down = 0\\n        maxMountain = 0\\n        \\n        while idx < n:\\n            while idx < n and arr[idx - 1] == arr[idx]:\\n                idx += 1\\n            up = 0\\n            while idx < n and arr[idx - 1] < arr[idx]:\\n                up += 1\\n                idx += 1\\n            down = 0\\n            while idx < n and arr[idx - 1] > arr[idx]:\\n                down += 1\\n                idx += 1\\n            if up > 0 and down > 0:\\n                maxMountain = max(maxMountain, up + down + 1)\\n                \\n        return \\n```\\n\\nThanks for reading, an upvote would be appreciated! ^_^",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int maxMountain = 0, n = arr.size(), idx = 1, up = 0, down = 0;\\n        while (idx < n) {\\n            while(idx < n && arr[idx - 1] == arr[idx])\\n                ++idx;\\n            // start looking further in array for a possible mountain\\n            up = 0;\\n            while(idx < n && arr[idx - 1] < arr[idx])\\n                ++up, ++idx;\\n            down = 0;\\n            while(idx < n && arr[idx - 1] > arr[idx])\\n                ++down, ++idx;\\n            if(up && down)  \\n                // + 1 as we do add the peak itself\\n                maxMountain = max(maxMountain, up + down + 1);\\n        }\\n        return maxMountain;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int maxMountain = 0, idx = 1, up = 0, down = 0, n = arr.length;\\n        while(idx < n) {\\n            while(idx < n && arr[idx - 1] == arr[idx])\\n                ++idx;\\n            up = 0;\\n            while(idx < n && arr[idx - 1] < arr[idx]) {\\n                ++up;\\n                ++idx;\\n            }\\n            down = 0;\\n            while(idx < n && arr[idx - 1] > arr[idx]) {\\n                ++down;\\n                ++idx;\\n            }\\n            if(up > 0 && down > 0)\\n                maxMountain = Math.max(maxMountain, up + down + 1);\\n        }\\n        return maxMountain;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        idx = 1\\n        up = 0\\n        down = 0\\n        maxMountain = 0\\n        \\n        while idx < n:\\n            while idx < n and arr[idx - 1] == arr[idx]:\\n                idx += 1\\n            up = 0\\n            while idx < n and arr[idx - 1] < arr[idx]:\\n                up += 1\\n                idx += 1\\n            down = 0\\n            while idx < n and arr[idx - 1] > arr[idx]:\\n                down += 1\\n                idx += 1\\n            if up > 0 and down > 0:\\n                maxMountain = max(maxMountain, up + down + 1)\\n                \\n        return \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990230,
                "title": "java-two-pointers-o-n",
                "content": "For each qualified peak, i.e. greater than its left and right element, expand from it to left and right to find the mountain length\\n\\nEach number is visited at most twice because numbers on the slope of a mountain will never be visited twice (as points on the slope doesn\\'t qualify as a peak). Only points on the end of a mountain could be visited twice, since it could be part of the mountain on its left and the mountain on its right.\\n\\n```\\npublic int longestMountain(int[] arr) {\\n    if(arr.length < 3){\\n        return 0;\\n    }\\n    int longest = 0;\\n    for(int i = 1; i < arr.length - 1; i++){\\n        if(arr[i] > arr[i - 1] && arr[i] > arr[i + 1]){\\n            int left = i;\\n            int right = i;\\n            while(left > 0 && arr[left - 1] < arr[left]){\\n                left--;\\n            }\\n            while(right < arr.length - 1 && arr[right + 1] < arr[right]){\\n                right++;\\n            }\\n            longest = Math.max(right - left + 1, longest);\\n        }\\n    }\\n    return longest;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\npublic int longestMountain(int[] arr) {\\n    if(arr.length < 3){\\n        return 0;\\n    }\\n    int longest = 0;\\n    for(int i = 1; i < arr.length - 1; i++){\\n        if(arr[i] > arr[i - 1] && arr[i] > arr[i + 1]){\\n            int left = i;\\n            int right = i;\\n            while(left > 0 && arr[left - 1] < arr[left]){\\n                left--;\\n            }\\n            while(right < arr.length - 1 && arr[right + 1] < arr[right]){\\n                right++;\\n            }\\n            longest = Math.max(right - left + 1, longest);\\n        }\\n    }\\n    return longest;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1436584,
                "title": "c-solution-o-n-easy-to-understand",
                "content": "```\\n// Time Complexity : O(N)\\n// Space Complexity : O(1)\\nclass Solution\\n{\\npublic:\\n    int longestMountain(vector<int> &arr)\\n    {\\n        int i = 1, n = arr.size(), max_mnt = 0;\\n        while (i < n)\\n        {\\n            int upper = 0, down = 0;\\n            while (i < n && arr[i] == arr[i - 1])\\n            {\\n                i++;\\n            }\\n\\n            // Going Up on Mountain\\n            while (i < n && arr[i] > arr[i - 1])\\n            {\\n                i++, upper++;\\n            }\\n\\n            // Going down on Mountain\\n            while (i < n && arr[i] < arr[i - 1])\\n            {\\n                down++, i++;\\n            }\\n\\n            if (upper && down)\\n            {\\n                max_mnt = max(max_mnt, upper + down + 1);\\n            }\\n        }\\n\\n        return max_mnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// Time Complexity : O(N)\\n// Space Complexity : O(1)\\nclass Solution\\n{\\npublic:\\n    int longestMountain(vector<int> &arr)\\n    {\\n        int i = 1, n = arr.size(), max_mnt = 0;\\n        while (i < n)\\n        {\\n            int upper = 0, down = 0;\\n            while (i < n && arr[i] == arr[i - 1])\\n            {\\n                i++;\\n            }\\n\\n            // Going Up on Mountain\\n            while (i < n && arr[i] > arr[i - 1])\\n            {\\n                i++, upper++;\\n            }\\n\\n            // Going down on Mountain\\n            while (i < n && arr[i] < arr[i - 1])\\n            {\\n                down++, i++;\\n            }\\n\\n            if (upper && down)\\n            {\\n                max_mnt = max(max_mnt, upper + down + 1);\\n            }\\n        }\\n\\n        return max_mnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1283245,
                "title": "python-easy-to-understand-o-n-time-o-1-space",
                "content": "**Explanation:**\\nLets divide the problem into 2 parts:\\n1. Finding the peak value of the mountain\\n2. Finding the length of the mountain\\n\\n**1. Find peak value:**\\n*  A value is considered as a peak if the elements adjacent to the peak is strictly less than it\\n*  Keep on iterating through the list until a peak value is found\\n\\n**2. Find length of the mountain**\\n* Once we find the peak value, Iterate through left and right elements to find the length of mountain\\n* Increase rightindex/Decrease left index until the subsequent values are strictly less\\n* Current length of mountain = right index - left index -1\\n* compare it with max_length and assign if max_length<current length\\n\\nIterate through all the elements until list is exhausted to find the max length of the mountain\\n```\\n\\tmaxlength = 0\\n        i = 1\\n        while(i<len(arr)-1):\\n            peak = arr[i]>arr[i-1] and arr[i]>arr[i+1]\\n            if not peak:\\n                i += 1\\n                continue\\n\\n            leftidx = i-2\\n            while(leftidx >= 0 and arr[leftidx]<arr[leftidx+1]):\\n                leftidx -= 1\\n\\n            rightidx = i+2\\n            while(rightidx < len(arr) and arr[rightidx]<arr[rightidx-1]):\\n                rightidx += 1\\n\\n            length = rightidx-leftidx-1\\n            if(length>maxlength):\\n                maxlength = length\\n            i = rightidx\\n        return maxlength\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\n\\tmaxlength = 0\\n        i = 1\\n        while(i<len(arr)-1):\\n            peak = arr[i]>arr[i-1] and arr[i]>arr[i+1]\\n            if not peak:\\n                i += 1\\n                continue\\n\\n            leftidx = i-2\\n            while(leftidx >= 0 and arr[leftidx]<arr[leftidx+1]):\\n                leftidx -= 1\\n\\n            rightidx = i+2\\n            while(rightidx < len(arr) and arr[rightidx]<arr[rightidx-1]):\\n                rightidx += 1\\n\\n            length = rightidx-leftidx-1\\n            if(length>maxlength):\\n                maxlength = length\\n            i = rightidx\\n        return maxlength\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 943750,
                "title": "java-very-simple-solution",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {        \\n        int longest = 0;\\n        int startIndex = 0;\\n        int endIndex = arr.length - 1;\\n                \\n        for(int i = 1; i < endIndex; i++) {\\n            int topIndex = i;\\n            int leftIndex = i - 1;\\n            int rightIndex = i + 1;\\n            \\n            if(arr[leftIndex] >= arr[topIndex] || arr[rightIndex] >= arr[topIndex]) {\\n                continue;\\n            }\\n            \\n            while(leftIndex != startIndex && arr[leftIndex] > arr[leftIndex - 1]) {\\n                leftIndex--;\\n            }\\n            \\n            while(rightIndex != endIndex && arr[rightIndex] > arr[rightIndex + 1]) {\\n                rightIndex++;\\n            }\\n            \\n            longest = Math.max(longest, rightIndex - leftIndex + 1);\\n        }\\n        \\n        return longest;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {        \\n        int longest = 0;\\n        int startIndex = 0;\\n        int endIndex = arr.length - 1;\\n                \\n        for(int i = 1; i < endIndex; i++) {\\n            int topIndex = i;\\n            int leftIndex = i - 1;\\n            int rightIndex = i + 1;\\n            \\n            if(arr[leftIndex] >= arr[topIndex] || arr[rightIndex] >= arr[topIndex]) {\\n                continue;\\n            }\\n            \\n            while(leftIndex != startIndex && arr[leftIndex] > arr[leftIndex - 1]) {\\n                leftIndex--;\\n            }\\n            \\n            while(rightIndex != endIndex && arr[rightIndex] > arr[rightIndex + 1]) {\\n                rightIndex++;\\n            }\\n            \\n            longest = Math.max(longest, rightIndex - leftIndex + 1);\\n        }\\n        \\n        return longest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1812564,
                "title": "python-time-o-n-space-o-1-faster-than-97-76-easy-to-understand-with-comments",
                "content": "![image](https://assets.leetcode.com/users/images/38ae550e-6c35-4a14-a449-ac0786dc2092_1646215938.7846613.png)\\n```\\n# time = O(N)/Space = O(1)\\nclass Solution(object):\\n    def longestMountain(self, arr):\\n        longestHeight = 0\\n        currHeight = 0\\n        \\n        # negelect very first and very last element as an not be peak at any cost\\n        currIdx = 1\\n        while currIdx < len(arr) -1:\\n            # search for peak \\n            isPeak = arr[currIdx] > arr[currIdx -1] and arr[currIdx] > arr[currIdx + 1]\\n            if not isPeak:\\n                #if not peak then continue\\n                currIdx += 1\\n                continue\\n            # if we found peak - now time to expand to left and right to measure height\\n            # start with second adjacent from left and right\\n            leftIdx = currIdx - 2\\n            rightIdx = currIdx + 2\\n            # check bounds\\n            while leftIdx >= 0 and arr[leftIdx] < arr[leftIdx + 1]:\\n                leftIdx -= 1\\n                \\n            while rightIdx < len(arr) and arr[rightIdx] < arr[rightIdx - 1]:\\n                rightIdx += 1\\n            # calculate current height    \\n            currHeight = rightIdx - leftIdx - 1 \\n            longestHeight = max(longestHeight, currHeight)\\n            \\n            currIdx =  rightIdx\\n        return longestHeight\\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\n# time = O(N)/Space = O(1)\\nclass Solution(object):\\n    def longestMountain(self, arr):\\n        longestHeight = 0\\n        currHeight = 0\\n        \\n        # negelect very first and very last element as an not be peak at any cost\\n        currIdx = 1\\n        while currIdx < len(arr) -1:\\n            # search for peak \\n            isPeak = arr[currIdx] > arr[currIdx -1] and arr[currIdx] > arr[currIdx + 1]\\n            if not isPeak:\\n                #if not peak then continue\\n                currIdx += 1\\n                continue\\n            # if we found peak - now time to expand to left and right to measure height\\n            # start with second adjacent from left and right\\n            leftIdx = currIdx - 2\\n            rightIdx = currIdx + 2\\n            # check bounds\\n            while leftIdx >= 0 and arr[leftIdx] < arr[leftIdx + 1]:\\n                leftIdx -= 1\\n                \\n            while rightIdx < len(arr) and arr[rightIdx] < arr[rightIdx - 1]:\\n                rightIdx += 1\\n            # calculate current height    \\n            currHeight = rightIdx - leftIdx - 1 \\n            longestHeight = max(longestHeight, currHeight)\\n            \\n            currIdx =  rightIdx\\n        return longestHeight\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234414,
                "title": "12-lines-c-o-n-dry-run",
                "content": "To understand the code just do dry run believe me just do dry run you will get the code at once otherwise just comment down below will help you to understand (^_^).\\n\\nDry run for these test cases to understand :\\n1. [2,1,4,7,3,2,5]\\n2. [1,2,3,4,5,6,7,8,9]\\n3. [2,3,1,2,3,4,5,6]\\n\\nThese cases are enough for u to understand the logic.\\n\\n``` \\n    int longestMountain(vector<int>& A) {\\n        int res = 0, count = 1; bool flag = 0;\\n        for(int i=1; i<A.size(); i++){\\n            if(A[i] > A[i-1]){\\n                if(flag == 1) flag = 0, count = 1;\\n                count++;\\n            }\\n            else if(count >= 2 and A[i] < A[i-1]){\\n                flag = 1;  count++;\\n                res = max(res, count);\\n            }\\n            else count = 1;\\n        }\\n        return res;\\n    }\\n```\\n\\nIf you liked it do click on the UPVOTE icon.\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "``` \\n    int longestMountain(vector<int>& A) {\\n        int res = 0, count = 1; bool flag = 0;\\n        for(int i=1; i<A.size(); i++){\\n            if(A[i] > A[i-1]){\\n                if(flag == 1) flag = 0, count = 1;\\n                count++;\\n            }\\n            else if(count >= 2 and A[i] < A[i-1]){\\n                flag = 1;  count++;\\n                res = max(res, count);\\n            }\\n            else count = 1;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 937825,
                "title": "easy-to-understand-java-solution-beats-100",
                "content": "The logic behind this solution was very simple. We just need to traverse the array for uphill (ascending order) and downhill (descending order).  \\n\\n\\t//go uphill\\n\\twhile(i<A.length && A[i-1]<A[i]){\\n\\t\\tupHill=true;\\n\\t\\ti++;\\n\\t}\\n\\t//go downhill\\n\\twhile(i<A.length && A[i-1]>A[i]){\\n\\t\\tdownHill=true;\\n\\t\\ti++;\\n\\t}\\n\\n\\nIf we found both uphill and downhill, then get the total length from the start of uphill till now and update the maximum mountain.\\n\\n\\tif(upHill && downHill){\\n\\t\\t//only update when mountain size was equal or greater than 3\\n\\t\\tif(i-start>=3)result = Math.max(i-start,result);\\n\\t}\\n\\nIn case there was no uphill and/or downhill or either, then it wasn\\'t mountain (obviously). Then we just need to ensure that it neither be plain surface (same value). Then, just keep moving\\n\\n\\twhile(i<A.length && A[i-1]==A[i])i++;\\n\\nHere is complete solution with comment.\\n\\n```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        int result = 0;\\n        if(A==null || A.length<3) return result;\\n        int i = 1;\\n        int start = 0;\\n        boolean upHill = false;\\n        boolean downHill = false;\\n        while(i<A.length){\\n            start = i-1;\\n            //go uphill\\n            while(i<A.length && A[i-1]<A[i]){\\n                upHill=true;\\n                i++;\\n            }\\n            //go downhill\\n            while(i<A.length && A[i-1]>A[i]){\\n                downHill=true;\\n                i++;\\n            }\\n\\t\\t\\t\\n            //if found uphill and downhill then there was mountain \\n            if(upHill && downHill){\\n                //only update when mountain size was equal or greater than 3\\n                if(i-start>=3)result = Math.max(i-start,result);\\n            }else{\\n                //if there was no mountain, then ensuring it\\'s not plain surface\\n                while(i<A.length && A[i-1]==A[i])i++;\\n            }\\n            \\n            //update uphill and downhill for next iteration.\\n            upHill = false;\\n            downHill = false;\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\nCode Analysis :\\n\\n\\tTime complexity : O(n)\\n\\tSpace complexity : O(1)\\n\\nAny comments or suggestion are welcome. :)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        int result = 0;\\n        if(A==null || A.length<3) return result;\\n        int i = 1;\\n        int start = 0;\\n        boolean upHill = false;\\n        boolean downHill = false;\\n        while(i<A.length){\\n            start = i-1;\\n            //go uphill\\n            while(i<A.length && A[i-1]<A[i]){\\n                upHill=true;\\n                i++;\\n            }\\n            //go downhill\\n            while(i<A.length && A[i-1]>A[i]){\\n                downHill=true;\\n                i++;\\n            }\\n\\t\\t\\t\\n            //if found uphill and downhill then there was mountain \\n            if(upHill && downHill){\\n                //only update when mountain size was equal or greater than 3\\n                if(i-start>=3)result = Math.max(i-start,result);\\n            }else{\\n                //if there was no mountain, then ensuring it\\'s not plain surface\\n                while(i<A.length && A[i-1]==A[i])i++;\\n            }\\n            \\n            //update uphill and downhill for next iteration.\\n            upHill = false;\\n            downHill = false;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 895623,
                "title": "python-solution-0-n-o-1-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        if len(A) < 3:\\n            return 0\\n        \\n        start = 0 # Ground from where the uphill starts.\\n        _maxPeak = 0\\n        reachedPeak = False\\n        for i in range(1, len(A)-1):\\n            # The uphill starts only if the current ground height is lower to the next ground height.\\n            # This condition is met at both the left side of the peak and the right side of the peak hence the variable reachedPeak to check if the peek has been reached.\\n            if A[i-1] >= A[i] <= A[i+1]:\\n                # if peak had been reached then we are now on the right side of the ground. We need to calucalte the lenght of the mountain.\\n                if reachedPeak:\\n                    reachedPeak = False\\n                    _maxPeak = max(_maxPeak, i - start + 1)\\n                start = i\\n            \\n            # Peak condition.\\n            elif A[i-1] < A[i] > A[i+1]:\\n                reachedPeak = True\\n        \\n        # This is to check if there is only downhill after the peak has been reached.\\n        if reachedPeak:\\n            _maxPeak = max(_maxPeak, len(A) - start)\\n        return _maxPeak\\n            \\n                \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        if len(A) < 3:\\n            return 0\\n        \\n        start = 0 # Ground from where the uphill starts.\\n        _maxPeak = 0\\n        reachedPeak = False\\n        for i in range(1, len(A)-1):\\n            # The uphill starts only if the current ground height is lower to the next ground height.\\n            # This condition is met at both the left side of the peak and the right side of the peak hence the variable reachedPeak to check if the peek has been reached.\\n            if A[i-1] >= A[i] <= A[i+1]:\\n                # if peak had been reached then we are now on the right side of the ground. We need to calucalte the lenght of the mountain.\\n                if reachedPeak:\\n                    reachedPeak = False\\n                    _maxPeak = max(_maxPeak, i - start + 1)\\n                start = i\\n            \\n            # Peak condition.\\n            elif A[i-1] < A[i] > A[i+1]:\\n                reachedPeak = True\\n        \\n        # This is to check if there is only downhill after the peak has been reached.\\n        if reachedPeak:\\n            _maxPeak = max(_maxPeak, len(A) - start)\\n        return _maxPeak\\n            \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 364764,
                "title": "count-points-of-the-mountain-on-both-up-and-down-slope-python",
                "content": "Keep counting points that form up and down slope. Reset when new mountain or flat is found. Record longest mountain for each point.\\n\\n```\\n    def longestMountain(self, A):\\n        increase, decrease, longest_mountain = 0, 0, 0\\n\\n        for i in range(len(A)):\\n            previous, current = A[i-1] if i > 0 else A[i], A[i]\\n \\n            if current == previous or (current > previous and decrease > 0):  \\n                increase, decrease = 1, 0  # reset when flat or new mountain is found\\n\\n            if current < previous: decrease += 1\\n            elif current > previous: increase += 1\\n            \\n            if increase > 1 and decrease > 0:\\n                longest_mountain = max(longest_mountain, increase + decrease)\\n\\n        return longest_mountain \\n```",
                "solutionTags": [],
                "code": "```\\n    def longestMountain(self, A):\\n        increase, decrease, longest_mountain = 0, 0, 0\\n\\n        for i in range(len(A)):\\n            previous, current = A[i-1] if i > 0 else A[i], A[i]\\n \\n            if current == previous or (current > previous and decrease > 0):  \\n                increase, decrease = 1, 0  # reset when flat or new mountain is found\\n\\n            if current < previous: decrease += 1\\n            elif current > previous: increase += 1\\n            \\n            if increase > 1 and decrease > 0:\\n                longest_mountain = max(longest_mountain, increase + decrease)\\n\\n        return longest_mountain \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 190888,
                "title": "one-pass-javascript-solution-without-nested-loops-o-n-time-o-1-space",
                "content": "Uses `dir` to track the trajectory of the \"terrain\", accounting for \"plateaus\" in the values (`1` is an incline, `0` is a plateau, `-1` is a decline). \\n```\\nvar longestMountain = function(A) {\\n    let longest = 0, start = 0, dir = 0\\n    \\n    // Note the <= here because we are doing comparisons with the previous value. Could swap it and do comparisons with the next value, but it\\'s more or less the same idea.\\n    for(var i = 0; i <= A.length; i++) {\\n        let val = A[i], prev = A[i-1]\\n        \\n        // On a decline and we\\'ve either reached the end, a plateau, or an incline\\n        if (dir === -1 && (i === A.length || !(val < prev))) {            \\n            longest = Math.max(i - start, longest)\\n            start = i - 1\\n            dir = val !== undefined && val > prev ? 1 : 0\\n        } else if (dir === 1 && val < prev) { // On an incline and we\\'ve crossed over the peak\\n            dir = -1\\n        } else if (val === prev) { // A plateau (in the case where we\\'re either on an incline or already a plateau\\n          dir = 0  \\n        } else if (val > prev && dir !== 1) { // Reached an incline when we weren\\'t already on one, so lets try to start a mountain\\n            start = i - 1\\n            dir = 1\\n        }\\n    }\\n    \\n    return longest\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar longestMountain = function(A) {\\n    let longest = 0, start = 0, dir = 0\\n    \\n    // Note the <= here because we are doing comparisons with the previous value. Could swap it and do comparisons with the next value, but it\\'s more or less the same idea.\\n    for(var i = 0; i <= A.length; i++) {\\n        let val = A[i], prev = A[i-1]\\n        \\n        // On a decline and we\\'ve either reached the end, a plateau, or an incline\\n        if (dir === -1 && (i === A.length || !(val < prev))) {            \\n            longest = Math.max(i - start, longest)\\n            start = i - 1\\n            dir = val !== undefined && val > prev ? 1 : 0\\n        } else if (dir === 1 && val < prev) { // On an incline and we\\'ve crossed over the peak\\n            dir = -1\\n        } else if (val === prev) { // A plateau (in the case where we\\'re either on an incline or already a plateau\\n          dir = 0  \\n        } else if (val > prev && dir !== 1) { // Reached an incline when we weren\\'t already on one, so lets try to start a mountain\\n            start = i - 1\\n            dir = 1\\n        }\\n    }\\n    \\n    return longest\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 135632,
                "title": "easy-to-understand-find-peaks-and-then-find-max-length-mountain-o-n",
                "content": "**Peak** - A value which is greater than neighboring values. A[i]>A[i-1] and A[i]>A[i+1] for i>0\\nAfter finding all such peaks we go left and right from each peak till the following condition holds - \\nTo the left - A[i-m] .... A[i-2] < A[i-1] < A[i]\\nTo the right - A[i] > A[i+1] > A[i+2] ... A[i+n]\\nLength of the mountain at each peak = m+n+1\\nIn the end we return the mountain with maximum length.\\n\\n**Time Complexity** - \\nFor each peak we are moving in left and right direction which might look like that the algorithm has non-linear complexity. But, the execution is in fact linear. Consider the following example - \\n\\nA = [1,2,1,3,4,6,2,1]\\nPeaks at positions = [1,5]\\nFirst we will go left from peak at index 1 and farthest we can go is till index 0\\nThen we will go right from peak at index 1 and farthest we can go is till index 2 because after index 2 it again starts increasing i.e. A[2]<A[3].\\nSimilarly, we will go left and right from peak at position 5 and we will go till index 3 on left and 7 on right.\\n\\nWhile going left and right from all the peaks none of the indexes are traveresed multiple times  which means we will at most traverse whole array again  (when all mountains share the saddle point). Hence we can say we traversed the array at most 2 times (Finding peaks + Going left and right from each peak = N+N) i.e. 2N which means the algorithm runs in O(N) time complexity.\\n\\n**Space complexity** - \\nFor storing peaks we will need O(N) space.\\nOptimization - We can go left and right as soon as we find a peak and then in the end we return the maximum length.\\n\\n```\\nclass Solution(object):\\n    def longestMountain(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"        \\n        peaks = []\\n        t = len(A)\\n        if t==0:\\n            return 0\\n        \\n        for i in xrange(1,t-1):\\n            if A[i-1]<A[i]>A[i+1]:\\n                peaks.append(i)\\n               \\n        maxLen = -1\\n        for i in peaks:        \\n            curLen=1\\n            j=i\\n            while j>0 and A[j-1]<A[j]:        \\n                j-=1\\n            curLen+=(i-j)\\n            \\n            j=i\\n            while j<t-1 and A[j+1]<A[j]:\\n                j+=1\\n            curLen+=(j-i)\\n            \\n            maxLen = max(curLen, maxLen)\\n        \\n        if maxLen==-1:\\n            return 0\\n        \\n        return maxLen\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def longestMountain(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"        \\n        peaks = []\\n        t = len(A)\\n        if t==0:\\n            return 0\\n        \\n        for i in xrange(1,t-1):\\n            if A[i-1]<A[i]>A[i+1]:\\n                peaks.append(i)\\n               \\n        maxLen = -1\\n        for i in peaks:        \\n            curLen=1\\n            j=i\\n            while j>0 and A[j-1]<A[j]:        \\n                j-=1\\n            curLen+=(i-j)\\n            \\n            j=i\\n            while j<t-1 and A[j+1]<A[j]:\\n                j+=1\\n            curLen+=(j-i)\\n            \\n            maxLen = max(curLen, maxLen)\\n        \\n        if maxLen==-1:\\n            return 0\\n        \\n        return maxLen\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629255,
                "title": "one-pass-solution-with-o-n-time-and-o-1-space",
                "content": "# Intuition\\nso the intution is  we have to form a mountain(which means that it should be a subarray which is strictly increasing and then strictly decreasing).\\n\\n# Approach\\nwe make variables like -->\\n. res--> stores the result to be return \\n\\n. answer--> temporary answer(which is temporay mountain length).\\n\\n. wasInc--> when we are goin down the hill it helps us to know that had we gone up_hill in this contiguous subarray. if we are on the down_hill side , we will update our res only if wasInc==true.\\n\\n. wasIncAndNowDcr--> help us when we are on the up_hill side , this tells that if we are comming from the down_hill side or not...if we are coming from the down hill side then we will have to do a fresh start in search of mountain...else we can continue on the up_hill side as it is as we have not seen down hill side in the contigous subarray\\n\\n**IMPORTANT**\\nwe have to do a fresh start if we encounter a case where (arr[i]==arr[i-1]) as we have to consider the case of strictly increasing or strictly decreasing..\\nif you still have any doubts do let me khow in the comment section.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity:O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n=arr.size(),res=0,answer=0;\\n        bool wasInc=false;\\n        bool wasIncAndNowDcr=false;\\n        for(int i=1;i<n;i++){\\n            if(arr[i] > arr[i-1]){\\n                if(wasIncAndNowDcr==true){\\n                    answer=0;\\n                    wasIncAndNowDcr=false;\\n                }\\n                answer++;\\n                wasInc=true;\\n            } \\n            else if(arr[i] < arr[i-1] && (wasInc || wasIncAndNowDcr)){\\n                answer++;\\n                wasIncAndNowDcr=true;\\n                res=max(res,answer+1);\\n            }\\n            else if(arr[i]==arr[i-1]){\\n                answer=0;\\n                wasIncAndNowDcr=false;\\n                wasInc=false;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n=arr.size(),res=0,answer=0;\\n        bool wasInc=false;\\n        bool wasIncAndNowDcr=false;\\n        for(int i=1;i<n;i++){\\n            if(arr[i] > arr[i-1]){\\n                if(wasIncAndNowDcr==true){\\n                    answer=0;\\n                    wasIncAndNowDcr=false;\\n                }\\n                answer++;\\n                wasInc=true;\\n            } \\n            else if(arr[i] < arr[i-1] && (wasInc || wasIncAndNowDcr)){\\n                answer++;\\n                wasIncAndNowDcr=true;\\n                res=max(res,answer+1);\\n            }\\n            else if(arr[i]==arr[i-1]){\\n                answer=0;\\n                wasIncAndNowDcr=false;\\n                wasInc=false;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3491500,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size(),ans=0,count;\\n        vector<int>peaks;\\n        for(int i=1;i<(n-1);i++){\\n            if(arr[i]>arr[i-1] && arr[i]>arr[i+1]){\\n                peaks.push_back(i);\\n            }\\n        }\\n        int m = peaks.size();\\n        for(int i=0;i<m;i++){\\n            count = 1;\\n            for(int j=peaks[i];j>0;j--){\\n                if(arr[j]>arr[j-1]){\\n                    count++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            for(int j=peaks[i];j<(n-1);j++){\\n                if(arr[j]>arr[j+1]){\\n                    count++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            if(ans<count){\\n                ans = count;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        longest_mountain = 0\\n        cur_mountain = 0\\n        NOTHING = 0\\n        GOING_UP = 1\\n        GOING_DOWN_AFTER_PEAK = 2\\n        state = NOTHING\\n        prev = arr[0]\\n        for a in arr[1:]:\\n            if a > prev:\\n                if state in (NOTHING, GOING_DOWN_AFTER_PEAK):\\n                    state = GOING_UP\\n                    cur_mountain = 1\\n                cur_mountain += 1\\n            elif a < prev:\\n                if state == GOING_UP:\\n                    state = GOING_DOWN_AFTER_PEAK\\n                if state == GOING_DOWN_AFTER_PEAK:\\n                    cur_mountain += 1\\n                    longest_mountain = max(cur_mountain, longest_mountain)\\n            elif a == prev:\\n                state = NOTHING\\n                cur_mountain = 0\\n            prev = a\\n        return longest_mountain\\n```\\n\\n```Java []\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int maxLength = 0, i = 0;\\n        boolean uphill = false, downhill = false;\\n        while (i < arr.length - 1) {\\n            if (arr[i] < arr[i + 1]) {\\n                int start = i;\\n                while (i < arr.length - 1 && arr[i] < arr[i + 1]) {\\n                    i++;\\n                    uphill = true;\\n                }\\n                while (i < arr.length - 1 && arr[i] > arr[i + 1]) {\\n                    i++;\\n                    downhill = true;\\n                }\\n                if (uphill && downhill) {\\n                    maxLength = Math.max(maxLength, i - start + 1);\\n                }\\n                uphill = downhill = false;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return maxLength;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size(),ans=0,count;\\n        vector<int>peaks;\\n        for(int i=1;i<(n-1);i++){\\n            if(arr[i]>arr[i-1] && arr[i]>arr[i+1]){\\n                peaks.push_back(i);\\n            }\\n        }\\n        int m = peaks.size();\\n        for(int i=0;i<m;i++){\\n            count = 1;\\n            for(int j=peaks[i];j>0;j--){\\n                if(arr[j]>arr[j-1]){\\n                    count++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            for(int j=peaks[i];j<(n-1);j++){\\n                if(arr[j]>arr[j+1]){\\n                    count++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            if(ans<count){\\n                ans = count;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        longest_mountain = 0\\n        cur_mountain = 0\\n        NOTHING = 0\\n        GOING_UP = 1\\n        GOING_DOWN_AFTER_PEAK = 2\\n        state = NOTHING\\n        prev = arr[0]\\n        for a in arr[1:]:\\n            if a > prev:\\n                if state in (NOTHING, GOING_DOWN_AFTER_PEAK):\\n                    state = GOING_UP\\n                    cur_mountain = 1\\n                cur_mountain += 1\\n            elif a < prev:\\n                if state == GOING_UP:\\n                    state = GOING_DOWN_AFTER_PEAK\\n                if state == GOING_DOWN_AFTER_PEAK:\\n                    cur_mountain += 1\\n                    longest_mountain = max(cur_mountain, longest_mountain)\\n            elif a == prev:\\n                state = NOTHING\\n                cur_mountain = 0\\n            prev = a\\n        return longest_mountain\\n```\n```Java []\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int maxLength = 0, i = 0;\\n        boolean uphill = false, downhill = false;\\n        while (i < arr.length - 1) {\\n            if (arr[i] < arr[i + 1]) {\\n                int start = i;\\n                while (i < arr.length - 1 && arr[i] < arr[i + 1]) {\\n                    i++;\\n                    uphill = true;\\n                }\\n                while (i < arr.length - 1 && arr[i] > arr[i + 1]) {\\n                    i++;\\n                    downhill = true;\\n                }\\n                if (uphill && downhill) {\\n                    maxLength = Math.max(maxLength, i - start + 1);\\n                }\\n                uphill = downhill = false;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return maxLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284831,
                "title": "c-longest-bitonic-sequence-lis-pattern-dp-striver",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> dp(n, 1), dp2(n, 1);\\n        int ans = 0;\\n        for (int ind=1; ind<n; ind++) {\\n            if (arr[ind] > arr[ind-1]) {\\n                dp[ind] = 1 + dp[ind-1];\\n            }\\n        }\\n        for (int ind=n-2; ind>=0; ind--) {\\n            if (arr[ind] > arr[ind+1]) {\\n                dp2[ind] = 1 + dp2[ind+1];\\n            }\\n        }\\n        for (int i=0; i<n; i++) {\\n            if (dp[i] > 1 && dp2[i] > 1) {\\n                ans = max(dp[i] + dp2[i] - 1, ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> dp(n, 1), dp2(n, 1);\\n        int ans = 0;\\n        for (int ind=1; ind<n; ind++) {\\n            if (arr[ind] > arr[ind-1]) {\\n                dp[ind] = 1 + dp[ind-1];\\n            }\\n        }\\n        for (int ind=n-2; ind>=0; ind--) {\\n            if (arr[ind] > arr[ind+1]) {\\n                dp2[ind] = 1 + dp2[ind+1];\\n            }\\n        }\\n        for (int i=0; i<n; i++) {\\n            if (dp[i] > 1 && dp2[i] > 1) {\\n                ans = max(dp[i] + dp2[i] - 1, ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768573,
                "title": "linear-time-constant-space-c-solution-with-explanation",
                "content": "# Intuition\\nWe just need to find the pattern of mountains.\\n\\n# Approach\\nFirst, find the length of the arr and see if the size if indeed > 3. Now after checking that start with index 0 and inside this for loop, we will go on traversing i, if we have a mountain patter. Hence, if arr[i+1]>arr[i], this is the condition essential for uphill, so we start counting left and also increment i. After we have reached a point that arr[i+1] is no longer > arr[i], meaning there can be 2 conditions arr[i+1]==arr[i] or arr[i+1]<arr[i]. Second condition is basically the start of downhill, I will discuss the first condition later. As we start going downhill, just increment rigth and i too. Now if right!=0 meaning that our bike never went downhill (meaning the first condition where arr[i+1] was arr[i]), we cant consider this as our answer as we ONLY have a mountain if both left and right are >0. So if right!=0, then count the answer, which is maximum of current answer and left+right+1. Why +1? because, notice that left and right are basically lenght of 2 arms of peak, we need to count peak in our answer too (through dry run we can see that left is still 1 when we process arr[1]>arr[0]). \\nNow, dont forget to do i-- here, as this will mean that we start from the next index, but it can happen that we need to start counting from current index and we are doing i++ anyways at the end of the loop, so do i--.\\nAtlast return the answer.\\n\\n# Complexity\\n- Time complexity:\\nO(n), some would be confused as there is while inside a for, but notice that in both the loops we just operate on i, hence, even if the while loop has incremented i, for loop will start from that point in future.\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int ans = 0;\\n        int n = arr.size();\\n        if(n<3)\\n            return 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(i+1<n && arr[i+1]>arr[i])\\n            {\\n                int left=0, right=0;\\n                while(i+1<n and arr[i+1]>arr[i])\\n                {\\n                    left++;\\n                    i++;\\n                }\\n                while(i+1<n and arr[i+1]<arr[i])\\n                {\\n                    right++;\\n                    i++;\\n                }\\n                if(right!=0){\\n                    ans = max(ans, right+left+1);\\n                    i--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int ans = 0;\\n        int n = arr.size();\\n        if(n<3)\\n            return 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(i+1<n && arr[i+1]>arr[i])\\n            {\\n                int left=0, right=0;\\n                while(i+1<n and arr[i+1]>arr[i])\\n                {\\n                    left++;\\n                    i++;\\n                }\\n                while(i+1<n and arr[i+1]<arr[i])\\n                {\\n                    right++;\\n                    i++;\\n                }\\n                if(right!=0){\\n                    ans = max(ans, right+left+1);\\n                    i--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340405,
                "title": "c-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n  int ans=0;\\n    int longestMountain(vector<int>& arr) {\\n     int n=arr.size();\\n      for(int i=1;i<n-1;i++)\\n      {\\n       if((arr[i] > arr[i-1]) && (arr[i] > arr[i+1])) // condition for mountain\\n            {\\n                int left = i;\\n                int right = i;\\n                while( left>0 && arr[left] > arr[left-1]) left--; // for left movement\\n               while( right<n-1 && arr[right] > arr[right+1] )right++;// for right movement\\n              ans = max(ans,(right-left+1));\\n            }\\n     }return ans;\\n    }\\n \\n};\\n```\\n\\nat then end if you are here then you really liked my solution , other solution can be :-\\nintution :- traverse loop from 1 to n-1 and check for every element if it is mountain or not ,if yes then count no. which is smaller \\nin derection of left applying condtn arr[i]>arr[i-1]\\nand vice versa for right side  , than simply add them \\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int ans=0;\\n    int longestMountain(vector<int>& arr) {\\n     int n=arr.size();\\n      for(int i=1;i<n-1;i++)\\n      {\\n       if((arr[i] > arr[i-1]) && (arr[i] > arr[i+1])) // condition for mountain\\n            {\\n                int left = i;\\n                int right = i;\\n                while( left>0 && arr[left] > arr[left-1]) left--; // for left movement\\n               while( right<n-1 && arr[right] > arr[right+1] )right++;// for right movement\\n              ans = max(ans,(right-left+1));\\n            }\\n     }return ans;\\n    }\\n \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113840,
                "title": "c-commented-solution-two-pointer-approach-easy-to-understand-solution",
                "content": "**PLEASE UPVOTE IF YOU LIKE APPROACH AND COMMENT IF YOU HAVE ANY QUESTION**\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& a) \\n    {\\n        int maxlength = 0;\\n            \\n        if(a.size() == 0)  return 0;\\n            \\n            for(int i = 1; i < a.size()-1; i++)\\n            {\\n                    if(a[i] > a[i-1] && a[i] > a[i+1])\\n                            //finding out the middle element or peak in an array/mountain.\\n                    {      \\n                            int left = i-1; //initialize left pointer towards left of peak \\n                     \\n                            int right = i+1; // initialize right pointer towards right to peak.\\n                            \\n                            while(left > 0 && a[left-1] < a[left] )\\n                                    // if next left is smaller then current left move forward;\\n                                    left--;\\n                            \\n                            while(right < a.size()-1 && a[right+1] < a[right])\\n                                    // if next right is smaller then current right move forward\\n                                    right++;\\n                            \\n                            maxlength = max(maxlength, right - left+1);\\n                            //return the maximum length between two pointers right and left.\\n                    }\\n            }\\n            \\n            return maxlength;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& a) \\n    {\\n        int maxlength = 0;\\n            \\n        if(a.size() == 0)  return 0;\\n            \\n            for(int i = 1; i < a.size()-1; i++)\\n            {\\n                    if(a[i] > a[i-1] && a[i] > a[i+1])\\n                            //finding out the middle element or peak in an array/mountain.\\n                    {      \\n                            int left = i-1; //initialize left pointer towards left of peak \\n                     \\n                            int right = i+1; // initialize right pointer towards right to peak.\\n                            \\n                            while(left > 0 && a[left-1] < a[left] )\\n                                    // if next left is smaller then current left move forward;\\n                                    left--;\\n                            \\n                            while(right < a.size()-1 && a[right+1] < a[right])\\n                                    // if next right is smaller then current right move forward\\n                                    right++;\\n                            \\n                            maxlength = max(maxlength, right - left+1);\\n                            //return the maximum length between two pointers right and left.\\n                    }\\n            }\\n            \\n            return maxlength;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1884695,
                "title": "o-n-forward-traversal-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n       int s = 0;\\n       int maxA = 0;\\n        \\n       bool foundPeak = false;\\n        \\n       for (int i = 0; i < arr.size(); i++) {\\n           int prev = i - 1 < 0 ? arr[i] : arr[i - 1];\\n           int curr = arr[i];\\n           int next = i + 1 >= arr.size() ? arr[i] : arr[i + 1];\\n           \\n           if (foundPeak) {\\n               maxA = max(maxA, i - s + 1);\\n           }\\n           \\n           if ((next > curr and prev >= curr) or (prev > curr and next >= curr)) {\\n               s = i;\\n               foundPeak = false;\\n           }\\n           \\n           if (prev < curr and next < curr) {\\n               foundPeak = true;\\n           }\\n       }\\n       return maxA;\\n    }  \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n       int s = 0;\\n       int maxA = 0;\\n        \\n       bool foundPeak = false;\\n        \\n       for (int i = 0; i < arr.size(); i++) {\\n           int prev = i - 1 < 0 ? arr[i] : arr[i - 1];\\n           int curr = arr[i];\\n           int next = i + 1 >= arr.size() ? arr[i] : arr[i + 1];\\n           \\n           if (foundPeak) {\\n               maxA = max(maxA, i - s + 1);\\n           }\\n           \\n           if ((next > curr and prev >= curr) or (prev > curr and next >= curr)) {\\n               s = i;\\n               foundPeak = false;\\n           }\\n           \\n           if (prev < curr and next < curr) {\\n               foundPeak = true;\\n           }\\n       }\\n       return maxA;\\n    }  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1837098,
                "title": "python3-one-pass-o-1-auxiliary-space",
                "content": "```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        increasing = False\\n        increased = False\\n        mx = -math.inf\\n        curr = -math.inf\\n        for i in range(1, len(arr)):\\n            if arr[i] > arr[i-1]:\\n                if increasing:\\n                    curr += 1\\n                    increased = True\\n                else:\\n                    mx = max(curr, mx)\\n                    curr = 2\\n                    increased = True\\n                    increasing = True\\n            elif arr[i] < arr[i-1]:\\n                if increasing:\\n                    increasing = False\\n                curr += 1\\n            else:\\n                if increased and not increasing:\\n                    mx = max(mx, curr)\\n                curr = -math.inf\\n                increased = False\\n                increasing = False\\n        if not increasing and increased:\\n            mx = max(mx, curr)\\n        return 0 if mx == -math.inf else mx\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        increasing = False\\n        increased = False\\n        mx = -math.inf\\n        curr = -math.inf\\n        for i in range(1, len(arr)):\\n            if arr[i] > arr[i-1]:\\n                if increasing:\\n                    curr += 1\\n                    increased = True\\n                else:\\n                    mx = max(curr, mx)\\n                    curr = 2\\n                    increased = True\\n                    increasing = True\\n            elif arr[i] < arr[i-1]:\\n                if increasing:\\n                    increasing = False\\n                curr += 1\\n            else:\\n                if increased and not increasing:\\n                    mx = max(mx, curr)\\n                curr = -math.inf\\n                increased = False\\n                increasing = False\\n        if not increasing and increased:\\n            mx = max(mx, curr)\\n        return 0 if mx == -math.inf else mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1782728,
                "title": "longest-mountain-in-array",
                "content": "class Solution {\\npublic:\\n\\n    int longestMountain(vector<int>& arr)  \\n\\t{\\n        int i = 0, u = 0, d = 0, ml = 0;\\n        int n=arr.size();\\n    while (i < n)\\n    {\\n         u=0;\\n         d=0;\\n        while (i < n - 1 && arr[i] < arr[i + 1])\\n        {\\n            i++;\\n            u++;\\n        }\\n        while (i < n - 1 && arr[i] > arr[i + 1] && u)\\n        {\\n            i++;\\n            d++;\\n        }\\n        if (u && d)\\n            ml = max(ml, u + d + 1);\\n        else\\n            i++;\\n    }\\n        return ml;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int longestMountain(vector<int>& arr)  \\n\\t{\\n        int i = 0, u = 0, d = 0, ml = 0;\\n        int n=arr.size();\\n    while (i < n)\\n    {\\n         u=0;\\n         d=0;\\n        while (i < n - 1 && arr[i] < arr[i + 1])\\n        {\\n            i++;\\n            u++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1718783,
                "title": "python-2-approaches-complexity",
                "content": "\\t# Two Passes - Forward and Backward\\n\\t# Time: O(n)\\n\\t# Space: O(n)\\n\\tclass Solution:\\n\\t\\tdef longestMountain(self, arr: List[int]) -> int:\\n\\t\\t\\tupSide = [0]*len(arr)\\n\\t\\t\\tdownSide = [0]*len(arr)\\n\\t\\t\\tfor i in range(1, len(arr)):\\n\\t\\t\\t\\tif arr[i] > arr[i-1]:\\n\\t\\t\\t\\t\\tupSide[i] = upSide[i-1]+1\\n\\t\\t\\tfor i in range(len(arr)-1)[::-1]:\\n\\t\\t\\t\\tif arr[i] > arr[i+1]:\\n\\t\\t\\t\\t\\tdownSide[i] = downSide[i+1]+1\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i, j in zip(upSide, downSide):\\n\\t\\t\\t\\tif i and j:\\n\\t\\t\\t\\t\\tres = max(res, i+j+1)\\n\\t\\t\\treturn res\\n\\n\\t# One Pass - Only Forward\\n\\t# Time: O(n)\\n\\t# Space: O(1)\\n\\tclass Solution:\\n\\t\\tdef longestMountain(self, arr: List[int]) -> int:\\n\\t\\t\\tup=0\\n\\t\\t\\tdown=0\\n\\t\\t\\tres=0\\n\\t\\t\\tfor i in range(1, len(arr)):\\n\\t\\t\\t\\tif down and arr[i]>arr[i-1] or arr[i-1]==arr[i]:\\n\\t\\t\\t\\t\\tup=down=0\\n\\t\\t\\t\\tup+=arr[i]>arr[i-1]\\n\\t\\t\\t\\tdown+=arr[i]<arr[i-1]\\n\\t\\t\\t\\tif up and down:\\n\\t\\t\\t\\t\\tres=max(res, up+down+1)\\n\\t\\t\\treturn res\\nIf you have any questions, please ask me, and if you like this approach, please **vote it up**!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\t# Two Passes - Forward and Backward\\n\\t# Time: O(n)\\n\\t# Space: O(n)\\n\\tclass Solution:\\n\\t\\tdef longestMountain(self, arr: List[int]) -> int:\\n\\t\\t\\tupSide = [0]*len(arr)\\n\\t\\t\\tdownSide = [0]*len(arr)\\n\\t\\t\\tfor i in range(1, len(arr)):\\n\\t\\t\\t\\tif arr[i] > arr[i-1]:\\n\\t\\t\\t\\t\\tupSide[i] = upSide[i-1]+1\\n\\t\\t\\tfor i in range(len(arr)-1)[::-1]:\\n\\t\\t\\t\\tif arr[i] > arr[i+1]:\\n\\t\\t\\t\\t\\tdownSide[i] = downSide[i+1]+1\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i, j in zip(upSide, downSide):\\n\\t\\t\\t\\tif i and j:\\n\\t\\t\\t\\t\\tres = max(res, i+j+1)\\n\\t\\t\\treturn res\\n\\n\\t# One Pass - Only Forward\\n\\t# Time: O(n)\\n\\t# Space: O(1)\\n\\tclass Solution:\\n\\t\\tdef longestMountain(self, arr: List[int]) -> int:\\n\\t\\t\\tup=0\\n\\t\\t\\tdown=0\\n\\t\\t\\tres=0\\n\\t\\t\\tfor i in range(1, len(arr)):\\n\\t\\t\\t\\tif down and arr[i]>arr[i-1] or arr[i-1]==arr[i]:\\n\\t\\t\\t\\t\\tup=down=0\\n\\t\\t\\t\\tup+=arr[i]>arr[i-1]\\n\\t\\t\\t\\tdown+=arr[i]<arr[i-1]\\n\\t\\t\\t\\tif up and down:\\n\\t\\t\\t\\t\\tres=max(res, up+down+1)\\n\\t\\t\\treturn res\\nIf you have any questions, please ask me, and if you like this approach, please **vote it up**!",
                "codeTag": "Java"
            },
            {
                "id": 1697387,
                "title": "c-dynamic-programming-faster-than-96-online-submission",
                "content": "```\\n int longestMountain(vector<int>& arr) {\\n        int n=arr.size();\\n        if(n==1){\\n            return 0;\\n        }\\n        int ans=0;\\n        vector<int>lis(n,1);\\n        vector<int>lds(n,1);\\n        //for lis\\n        for(int i=1;i<n;i++){\\n            if(arr[i]>arr[i-1]){\\n                lis[i]=lis[i-1]+1;\\n            }\\n        }\\n        //for lds\\n        for(int i=n-2;i>=0;i--){\\n            if(arr[i]>arr[i+1]){\\n                lds[i]=lds[i+1]+1;\\n            }\\n        }\\n        // cout<<\"LIS \"<<endl;\\n        // for(auto it:lis){\\n        //     cout<<it<<\" \";\\n        // }\\n        //  cout<<\"LDS \"<<endl;\\n        // for(auto it:lds){\\n        //     cout<<it<<\" \";\\n        // }\\n        for(int i=1;i<n-1;i++){\\n            if(lis[i]==1||lds[i]==1){\\n                continue;\\n            }\\n            int temp=abs(lis[i]+lds[i]-1);\\n            ans=max(ans,temp);\\n        }\\n        return ans==1?0:ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int longestMountain(vector<int>& arr) {\\n        int n=arr.size();\\n        if(n==1){\\n            return 0;\\n        }\\n        int ans=0;\\n        vector<int>lis(n,1);\\n        vector<int>lds(n,1);\\n        //for lis\\n        for(int i=1;i<n;i++){\\n            if(arr[i]>arr[i-1]){\\n                lis[i]=lis[i-1]+1;\\n            }\\n        }\\n        //for lds\\n        for(int i=n-2;i>=0;i--){\\n            if(arr[i]>arr[i+1]){\\n                lds[i]=lds[i+1]+1;\\n            }\\n        }\\n        // cout<<\"LIS \"<<endl;\\n        // for(auto it:lis){\\n        //     cout<<it<<\" \";\\n        // }\\n        //  cout<<\"LDS \"<<endl;\\n        // for(auto it:lds){\\n        //     cout<<it<<\" \";\\n        // }\\n        for(int i=1;i<n-1;i++){\\n            if(lis[i]==1||lds[i]==1){\\n                continue;\\n            }\\n            int temp=abs(lis[i]+lds[i]-1);\\n            ans=max(ans,temp);\\n        }\\n        return ans==1?0:ans;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1691796,
                "title": "c-simple-and-short-o-n-time-complexity",
                "content": "```\\nint longestMountain(vector<int>& arr) {\\n        int ans = 0, upLength = 0, downLength = 0;\\n\\t\\t\\n        for(int i = 1; i < arr.size(); i++)\\n        {\\n            if(arr[i - 1] == arr[i] || downLength && arr[i - 1] < arr[i])\\n                upLength = downLength = 0;\\n            \\n            upLength += arr[i - 1] < arr[i];\\n            downLength += arr[i - 1] > arr[i];\\n\\n            if(upLength && downLength)\\n                ans = max(ans, upLength + downLength + 1);\\n        }\\n        return ans;\\n    }\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint longestMountain(vector<int>& arr) {\\n        int ans = 0, upLength = 0, downLength = 0;\\n\\t\\t\\n        for(int i = 1; i < arr.size(); i++)\\n        {\\n            if(arr[i - 1] == arr[i] || downLength && arr[i - 1] < arr[i])\\n                upLength = downLength = 0;\\n            \\n            upLength += arr[i - 1] < arr[i];\\n            downLength += arr[i - 1] > arr[i];\\n\\n            if(upLength && downLength)\\n                ans = max(ans, upLength + downLength + 1);\\n        }\\n        return ans;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1668119,
                "title": "c-o-n-o-1-100-fast-easy-soln",
                "content": "```\\n int longestMountain(vector<int>& a) {\\n        int i,ans=0,c=0,n=a.size();\\n        for(i=1;i<n;i++)\\n        {\\n            if(a[i]==a[i-1])  //If nos are same then we skip it\\n                c=0;            \\n            else if(a[i]>a[i-1]) //if next>prev we increase the count\\n                c++;\\n            //Else we first calculate count of next<prev and update the final ans\\n            else if(c>0)           \\n            {\\n                    while(i<n and a[i]<a[i-1])\\n                    {\\n                        c++; i++;\\n                    }\\n                    ans = max(ans,c+1);\\n                    c=0 ;i--;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n int longestMountain(vector<int>& a) {\\n        int i,ans=0,c=0,n=a.size();\\n        for(i=1;i<n;i++)\\n        {\\n            if(a[i]==a[i-1])  //If nos are same then we skip it\\n                c=0;            \\n            else if(a[i]>a[i-1]) //if next>prev we increase the count\\n                c++;\\n            //Else we first calculate count of next<prev and update the final ans\\n            else if(c>0)           \\n            {\\n                    while(i<n and a[i]<a[i-1])\\n                    {\\n                        c++; i++;\\n                    }\\n                    ans = max(ans,c+1);\\n                    c=0 ;i--;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1468928,
                "title": "java-faster-than-100-do-checkout-for-detailed-explanation",
                "content": "**Do vote up if you like it :)**\\nTC : O(N), SC : O(1)\\n```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        \\n        int i = 0, start = -1, end = -1;\\n        boolean peak = false, valley = false;\\n        int largestMountain = 0;\\n        \\n        while(i < arr.length - 1){ \\n            //You expect a continous increase and then a continous decrease\\n            if(arr[i] < arr[i + 1]){                \\n                start = i;\\n                peak = true;\\n                \\n                //Continous increase\\n                while(i < arr.length - 1 && arr[i] < arr[i + 1]){\\n                    i++;\\n                }\\n                \\n                //Continous decrease\\n                while(i < arr.length - 1 && arr[i] > arr[i + 1]){\\n                    valley = true;\\n                    i++;\\n                    end = i;\\n                }\\n                \\n                //If there is continous increase and continous decrease then only it\\'s a mountain\\n                if(peak && valley) largestMountain = Math.max(largestMountain, end - start + 1);\\n                //NOTE: If all the elements would be continously increasing then also it\\'s not a mountain\\n                 \\n                peak = false; valley = false;\\n            }\\n            \\n            //Not a mountain if :\\n            //elements are not strictly increasing(parallel surface)\\n            //or decreasing continously\\n            else i++;\\n        }\\n        return largestMountain;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        \\n        int i = 0, start = -1, end = -1;\\n        boolean peak = false, valley = false;\\n        int largestMountain = 0;\\n        \\n        while(i < arr.length - 1){ \\n            //You expect a continous increase and then a continous decrease\\n            if(arr[i] < arr[i + 1]){                \\n                start = i;\\n                peak = true;\\n                \\n                //Continous increase\\n                while(i < arr.length - 1 && arr[i] < arr[i + 1]){\\n                    i++;\\n                }\\n                \\n                //Continous decrease\\n                while(i < arr.length - 1 && arr[i] > arr[i + 1]){\\n                    valley = true;\\n                    i++;\\n                    end = i;\\n                }\\n                \\n                //If there is continous increase and continous decrease then only it\\'s a mountain\\n                if(peak && valley) largestMountain = Math.max(largestMountain, end - start + 1);\\n                //NOTE: If all the elements would be continously increasing then also it\\'s not a mountain\\n                 \\n                peak = false; valley = false;\\n            }\\n            \\n            //Not a mountain if :\\n            //elements are not strictly increasing(parallel surface)\\n            //or decreasing continously\\n            else i++;\\n        }\\n        return largestMountain;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1401310,
                "title": "java-array-single-pass-t-c-o-n-s-c-o-1",
                "content": "\\n    public int longestMountain(int[] arr) {\\n\\n\\t\\tint len = arr.length, up = 0, down = 0, omax = 0;\\n\\t\\tboolean flag = false;\\n\\n\\t\\tfor (int i = 1; i < len; i++) {\\n\\t\\t\\tif (arr[i] > arr[i - 1]) {\\n\\t\\t\\t\\tif (flag) {\\n\\t\\t\\t\\t\\tflag = false;\\n\\t\\t\\t\\t\\tup = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tup++;\\n                down = 0;\\n\\t\\t\\t} else if (arr[i] < arr[i - 1]) {\\n\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\tif (up == 0)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tdown++;\\n\\t\\t\\t\\tif (up + down + 1 > omax)\\n\\t\\t\\t\\t\\tomax = up + down + 1;\\n\\t\\t\\t} else {\\n                up = 0;\\n                down = 0;\\n            }\\n\\t\\t}\\n\\n\\t\\treturn omax;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    public int longestMountain(int[] arr) {\\n\\n\\t\\tint len = arr.length, up = 0, down = 0, omax = 0;\\n\\t\\tboolean flag = false;\\n\\n\\t\\tfor (int i = 1; i < len; i++) {\\n\\t\\t\\tif (arr[i] > arr[i - 1]) {\\n\\t\\t\\t\\tif (flag) {\\n\\t\\t\\t\\t\\tflag = false;\\n\\t\\t\\t\\t\\tup = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tup++;\\n                down = 0;\\n\\t\\t\\t} else if (arr[i] < arr[i - 1]) {\\n\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\tif (up == 0)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tdown++;\\n\\t\\t\\t\\tif (up + down + 1 > omax)\\n\\t\\t\\t\\t\\tomax = up + down + 1;\\n\\t\\t\\t} else {\\n                up = 0;\\n                down = 0;\\n            }\\n\\t\\t}\\n\\n\\t\\treturn omax;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1271001,
                "title": "easy-to-understand-with-explanation-c-0-n-find-peak-and-stretch-left-and-right",
                "content": "You have to find the Peak ie (arr[i-1] < arr[i] && arr[i] > arr[i+1]) of the mountain , then just traverse to left side and right side to find the length. \\nCompare with maxlen  for every peak.\\n0(n+n) ~ 0(n)\\n\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        int maxLen = 0;\\n        \\n        if(n<3){\\n            return maxLen;\\n        }\\n        \\n        for(int i=1;i<n-1;i++){\\n            \\n            if(arr[i-1] < arr[i] && arr[i] > arr[i+1]) {\\n                \\n                int lidx = i,ridx=i;\\n                int len = 1;\\n                \\n                while(lidx > 0 && arr[lidx] > arr[lidx-1]){\\n                    len++; lidx--;\\n                }\\n                while(ridx+1 < n && arr[ridx] > arr[ridx+1]){\\n                    len++; ridx++;\\n                }\\n                maxLen = max(maxLen,len);\\n            } \\n        }\\n        return maxLen;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        int maxLen = 0;\\n        \\n        if(n<3){\\n            return maxLen;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1248472,
                "title": "easy-c-solution-o-n",
                "content": "int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        int mountain_length =0;\\n        \\n        if(n<3) return 0;     // base case\\n        \\n        for(int i=1;i<n-1; ){\\n            if(arr[i]>arr[i-1] && arr[i]>arr[i+1]){    //To find peak of mountain\\n                int count = 1;\\n                int j = i;\\n                while(j>=1 && arr[j]>arr[j-1]){       // calculating backword length\\n                    j--;\\n                    count++;\\n                }\\n                while(i<n-1 && arr[i]>arr[i+1]){      // calculating forword length\\n                    i++;\\n                    count++;\\n                }\\n                 mountain_length = max(mountain_length,count);\\n            }else{\\n                i++;\\n            }\\n        }\\n        return mountain_length;\\n    }\\n};",
                "solutionTags": [],
                "code": "int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        int mountain_length =0;\\n        \\n        if(n<3) return 0;     // base case\\n        \\n        for(int i=1;i<n-1; ){\\n            if(arr[i]>arr[i-1] && arr[i]>arr[i+1]){    //To find peak of mountain\\n                int count = 1;\\n                int j = i;\\n                while(j>=1 && arr[j]>arr[j-1]){       // calculating backword length\\n                    j--;\\n                    count++;\\n                }\\n                while(i<n-1 && arr[i]>arr[i+1]){      // calculating forword length\\n                    i++;\\n                    count++;\\n                }\\n                 mountain_length = max(mountain_length,count);\\n            }else{\\n                i++;\\n            }\\n        }\\n        return mountain_length;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1236452,
                "title": "c-1-pass-o-1-space-esay-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int max_cnt = 0;\\n        for(int i = 1; i < arr.size() - 1; i++){\\n            if(arr[i] > arr[i-1] and arr[i] > arr[i+1]){\\n                //go backward\\n                int j = i-1, cnt = 3;\\n                while(j-1 >= 0 and arr[j-1] < arr[j]){\\n                    cnt++;\\n                    j--;\\n                }\\n                //go forward\\n                int k = i+1;\\n                while( k + 1 < arr.size() and arr[k+1] < arr[k]){\\n                    cnt++;\\n                    k++;\\n                }\\n                max_cnt = max(max_cnt, cnt);\\n            }\\n        }\\n        return max_cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int max_cnt = 0;\\n        for(int i = 1; i < arr.size() - 1; i++){\\n            if(arr[i] > arr[i-1] and arr[i] > arr[i+1]){\\n                //go backward\\n                int j = i-1, cnt = 3;\\n                while(j-1 >= 0 and arr[j-1] < arr[j]){\\n                    cnt++;\\n                    j--;\\n                }\\n                //go forward\\n                int k = i+1;\\n                while( k + 1 < arr.size() and arr[k+1] < arr[k]){\\n                    cnt++;\\n                    k++;\\n                }\\n                max_cnt = max(max_cnt, cnt);\\n            }\\n        }\\n        return max_cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027675,
                "title": "c-simple-dp-apporach-with-runtime-96-40",
                "content": "**Bitonic Sequence Approach**\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& elements) {\\n        int size=elements.size();\\n        vector<int> lis(size);\\n        lis[0]=1;\\n        \\n        for(int i=1;i<size;i++){\\n            int maxyet=0;\\n            if(elements[i-1]<elements[i]){\\n                maxyet=max(maxyet,lis[i-1]);\\n            }\\n            lis[i]=maxyet+1;\\n        }\\n        \\n        vector<int> ldp(size);\\n        ldp[size-1]=1;\\n        \\n        for(int i=size-2;i>=0;i--){\\n            if(elements[i+1]<elements[i]){\\n                ldp[i]=max(ldp[i],ldp[i+1]);\\n            }\\n            ldp[i]+=1;\\n        }\\n        int ans=0;\\n        for(int i=0;i<size;i++){\\n            if(lis[i]>1 && ldp[i]>1){\\n                ans=max(ans,(lis[i]+ldp[i]-1));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& elements) {\\n        int size=elements.size();\\n        vector<int> lis(size);\\n        lis[0]=1;\\n        \\n        for(int i=1;i<size;i++){\\n            int maxyet=0;\\n            if(elements[i-1]<elements[i]){\\n                maxyet=max(maxyet,lis[i-1]);\\n            }\\n            lis[i]=maxyet+1;\\n        }\\n        \\n        vector<int> ldp(size);\\n        ldp[size-1]=1;\\n        \\n        for(int i=size-2;i>=0;i--){\\n            if(elements[i+1]<elements[i]){\\n                ldp[i]=max(ldp[i],ldp[i+1]);\\n            }\\n            ldp[i]+=1;\\n        }\\n        int ans=0;\\n        for(int i=0;i<size;i++){\\n            if(lis[i]>1 && ldp[i]>1){\\n                ans=max(ans,(lis[i]+ldp[i]-1));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938288,
                "title": "c-single-loop-o-n-time-o-1-space-explained-code-and-cases-in-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        \\n        // base case - mountain must be greater than 3, so there is no mountain\\n        if(A.size() < 3)\\n            return 0;\\n        \\n        int longestMountain = 1;        // current largest mountain in our list\\n        int previousNumber = A[0];      // current number we are looking at\\n        int currentMountain = 1;        // current size of our mountain \\n        bool isAscending = true;        // determine if we are ascending or descending in the mountain\\n        \\n        // There are potentially 4 cases that can occur within this problem\\n            // 1. We are ascending and we keep ascending - increment mountain and continue\\n            // 2. We are ascending, but the current number is smaller than previous - now we descend\\n                // 2a. Ascending, smaller number, but the current mountain is too small or the same\\n                // height, we do not swap to descending but instead reset the height\\n            // 3. We are descending and we keep descending - increment mountain and continue\\n            // 4. We are descending, but the current number is larger than previous - reset\\n            // to set our loop to the current (in case the tailend of this mountain is the start \\n            // to a bigger mountain i.e. [{4, 6, {3}, 4, 5, 7, 5, 3, 2}])\\n        \\n        for(int x = 1; x < A.size(); ++x)\\n        {\\n            if(isAscending)\\n            {\\n                // if the number is larger, then keep ascending\\n                if(A[x] > previousNumber)\\n                {\\n                    ++currentMountain;\\n                }\\n                else\\n                {\\n                    // if the number is smaller, and the current mountain is large enough\\n                    // to start a descent, and the previous number is not the same number,\\n                    // i.e. [2, 2, 2], then begin our descent (!ascending)\\n                    if(currentMountain >= 2 && A[x] != previousNumber)\\n                    {\\n                        isAscending = false;\\n                        ++currentMountain;\\n                        longestMountain = max(currentMountain, longestMountain);\\n                    }\\n                    else\\n                    {\\n                        // either the mountain is too small to descend, or we hit the same\\n                        // height so we never really ascended, so reset to height of 1\\n                        currentMountain = 1;\\n                    }\\n                }\\n                \\n                // move our previous pointer forward \\n                previousNumber = A[x];\\n            }\\n            else\\n            {\\n                // if the number is smaller, then keep descending\\n                if(A[x] < previousNumber)\\n                {\\n                    ++currentMountain;\\n                }\\n                else\\n                {\\n                    // if the number is larger, then we have reached the end of the descent\\n                    // and have finished this mountain, so reset to ascend, set the current height\\n                    // to 1 and move our current loop iterator back in case the end of this mountain\\n                    // is the start to a larger mountain\\n                    isAscending = true;\\n                    currentMountain = 1;\\n                    x--;\\n                }\\n                \\n                // set our max longest mountain each descent in case it grows to our current max\\n                longestMountain = max(currentMountain, longestMountain);\\n                \\n                // move our previous pointer forward\\n                previousNumber = A[x];\\n            }\\n        }\\n        \\n        // if our longest mountain is larger than or equal to 3 (valid mountain)\\n        // then return it\\'s height, else simply return 0 (no valid mountain)\\n        return longestMountain >= 3 ? longestMountain : 0; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        \\n        // base case - mountain must be greater than 3, so there is no mountain\\n        if(A.size() < 3)\\n            return 0;\\n        \\n        int longestMountain = 1;        // current largest mountain in our list\\n        int previousNumber = A[0];      // current number we are looking at\\n        int currentMountain = 1;        // current size of our mountain \\n        bool isAscending = true;        // determine if we are ascending or descending in the mountain\\n        \\n        // There are potentially 4 cases that can occur within this problem\\n            // 1. We are ascending and we keep ascending - increment mountain and continue\\n            // 2. We are ascending, but the current number is smaller than previous - now we descend\\n                // 2a. Ascending, smaller number, but the current mountain is too small or the same\\n                // height, we do not swap to descending but instead reset the height\\n            // 3. We are descending and we keep descending - increment mountain and continue\\n            // 4. We are descending, but the current number is larger than previous - reset\\n            // to set our loop to the current (in case the tailend of this mountain is the start \\n            // to a bigger mountain i.e. [{4, 6, {3}, 4, 5, 7, 5, 3, 2}])\\n        \\n        for(int x = 1; x < A.size(); ++x)\\n        {\\n            if(isAscending)\\n            {\\n                // if the number is larger, then keep ascending\\n                if(A[x] > previousNumber)\\n                {\\n                    ++currentMountain;\\n                }\\n                else\\n                {\\n                    // if the number is smaller, and the current mountain is large enough\\n                    // to start a descent, and the previous number is not the same number,\\n                    // i.e. [2, 2, 2], then begin our descent (!ascending)\\n                    if(currentMountain >= 2 && A[x] != previousNumber)\\n                    {\\n                        isAscending = false;\\n                        ++currentMountain;\\n                        longestMountain = max(currentMountain, longestMountain);\\n                    }\\n                    else\\n                    {\\n                        // either the mountain is too small to descend, or we hit the same\\n                        // height so we never really ascended, so reset to height of 1\\n                        currentMountain = 1;\\n                    }\\n                }\\n                \\n                // move our previous pointer forward \\n                previousNumber = A[x];\\n            }\\n            else\\n            {\\n                // if the number is smaller, then keep descending\\n                if(A[x] < previousNumber)\\n                {\\n                    ++currentMountain;\\n                }\\n                else\\n                {\\n                    // if the number is larger, then we have reached the end of the descent\\n                    // and have finished this mountain, so reset to ascend, set the current height\\n                    // to 1 and move our current loop iterator back in case the end of this mountain\\n                    // is the start to a larger mountain\\n                    isAscending = true;\\n                    currentMountain = 1;\\n                    x--;\\n                }\\n                \\n                // set our max longest mountain each descent in case it grows to our current max\\n                longestMountain = max(currentMountain, longestMountain);\\n                \\n                // move our previous pointer forward\\n                previousNumber = A[x];\\n            }\\n        }\\n        \\n        // if our longest mountain is larger than or equal to 3 (valid mountain)\\n        // then return it\\'s height, else simply return 0 (no valid mountain)\\n        return longestMountain >= 3 ? longestMountain : 0; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937703,
                "title": "python-remember-our-state-o-1",
                "content": "We need to remember what state we are in. It\\'s either plato, ascend or descend.\\n```\\ndef longestMountain(self, A: List[int]) -> int:\\n\\tif len(A) < 3: return 0\\n\\tmaxrange = 0\\n\\tleft = 0\\n\\tmode = \\'plato\\'\\n\\n\\tfor i in range(1, len(A)):\\n\\t\\tif A[i] == A[i-1]: mode = \\'plato\\'\\n\\t\\telif A[i] > A[i-1]:\\n\\t\\t\\tif mode in [\\'plato\\', \\'descend\\']:\\n\\t\\t\\t\\tleft = i - 1\\n\\t\\t\\t\\tmode = \\'ascend\\'\\n\\t\\telif mode in [\\'ascend\\', \\'descend\\']:\\n\\t\\t\\tmaxrange = max(maxrange, i + 1 - left)\\n\\t\\t\\tmode = \\'descend\\'\\n\\n\\treturn maxrange\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef longestMountain(self, A: List[int]) -> int:\\n\\tif len(A) < 3: return 0\\n\\tmaxrange = 0\\n\\tleft = 0\\n\\tmode = \\'plato\\'\\n\\n\\tfor i in range(1, len(A)):\\n\\t\\tif A[i] == A[i-1]: mode = \\'plato\\'\\n\\t\\telif A[i] > A[i-1]:\\n\\t\\t\\tif mode in [\\'plato\\', \\'descend\\']:\\n\\t\\t\\t\\tleft = i - 1\\n\\t\\t\\t\\tmode = \\'ascend\\'\\n\\t\\telif mode in [\\'ascend\\', \\'descend\\']:\\n\\t\\t\\tmaxrange = max(maxrange, i + 1 - left)\\n\\t\\t\\tmode = \\'descend\\'\\n\\n\\treturn maxrange\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 937660,
                "title": "c-two-solutions-o-n-time-o-n-o-1-space",
                "content": "**Approach 1**\\nThe idea is simple, we can maintain an `left[]` and `right[]` array to keep track of `How many elements are smaller than left[i] and right[i]`, going from left and right respectively.\\n\\nThen, we can simple iterate over the array and keep track of `possible peak` of mountain i.e we can check `from index=1 to index = arr.size()-2` which of the elements are `greater than both left and right elements from it`. \\n\\n**Solution 1**\\nTime complexity : O(N)\\nSpace Complexity: O(N)\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        \\n        if(A.size() < 3){ //mountain cannot exist\\n            return 0;\\n        }\\n        \\n        vector<int> left(A.size(), 0);\\n        vector<int> right(A.size(), 0);\\n        //Build Left \\n        for(int i=1;i<A.size();i++){\\n            if(A[i] > A[i-1]){ \\n                left[i] = left[i-1] + 1;\\n            }\\n        }\\n        //Build Right\\n        for(int i=A.size()-2;i>=0;i--){\\n            if(A[i] > A[i+1]){\\n                right[i] = right[i+1] + 1;\\n            }\\n        }\\n        \\n        int mountain = 0;\\n        \\n        for(int i=1;i<A.size()-1;i++){\\n            if(A[i] > A[i-1] && A[i] > A[i+1]){ //Keep track of the highest peak\\n                mountain = max(mountain, left[i]+right[i]+1);\\n            }\\n        }\\n        \\n        return mountain;\\n    }\\n};\\n```\\n\\n**Approach 2 (Follow up)**\\nHere, we can observe from Solution 1 that we should only keep track of `possible peak` that occurs while traversing the array. This can be done by `expanding the size of mountain from a peak`. So, we can keep track of `peak` while traversing the array then we can expand on the peak and store the maximum of all those sizes.\\n\\n**Solution 2**\\nTime Complexity: O(N)\\nSpace Complexity: O(1)\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        \\n        if(A.size() < 3){\\n            return 0;\\n        }\\n\\t\\t\\n        int mountain = 0;\\n        \\n        for(int i=1;i<A.size()-1;i++){\\n            if(A[i] > A[i-1] && A[i] > A[i+1]){ //Possible Peak\\n                \\n\\t\\t\\t\\t//Expanding on left\\n\\t\\t\\t\\tint j = i-1;\\n                int left = 0;\\n                int prev = A[i];\\n                while(j >= 0 && A[j] < prev){\\n                    prev = A[j];\\n                    j--;\\n                    left++;\\n                }\\n\\t\\t\\t\\t\\n                //Expanding on right\\n\\t\\t\\t\\tj = i+1;\\n                prev = A[i];\\n                int right = 0;\\n                while(j < A.size() && A[j] <  prev){\\n                    prev = A[j];\\n                    j++;\\n                    right++;\\n                }\\n                \\n\\t\\t\\t\\t//Store maximum in \\'mountain\\'\\n                mountain = max(mountain, left+right+1);\\n            }\\n        }\\n        \\n        return mountain;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        \\n        if(A.size() < 3){ //mountain cannot exist\\n            return 0;\\n        }\\n        \\n        vector<int> left(A.size(), 0);\\n        vector<int> right(A.size(), 0);\\n        //Build Left \\n        for(int i=1;i<A.size();i++){\\n            if(A[i] > A[i-1]){ \\n                left[i] = left[i-1] + 1;\\n            }\\n        }\\n        //Build Right\\n        for(int i=A.size()-2;i>=0;i--){\\n            if(A[i] > A[i+1]){\\n                right[i] = right[i+1] + 1;\\n            }\\n        }\\n        \\n        int mountain = 0;\\n        \\n        for(int i=1;i<A.size()-1;i++){\\n            if(A[i] > A[i-1] && A[i] > A[i+1]){ //Keep track of the highest peak\\n                mountain = max(mountain, left[i]+right[i]+1);\\n            }\\n        }\\n        \\n        return mountain;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        \\n        if(A.size() < 3){\\n            return 0;\\n        }\\n\\t\\t\\n        int mountain = 0;\\n        \\n        for(int i=1;i<A.size()-1;i++){\\n            if(A[i] > A[i-1] && A[i] > A[i+1]){ //Possible Peak\\n                \\n\\t\\t\\t\\t//Expanding on left\\n\\t\\t\\t\\tint j = i-1;\\n                int left = 0;\\n                int prev = A[i];\\n                while(j >= 0 && A[j] < prev){\\n                    prev = A[j];\\n                    j--;\\n                    left++;\\n                }\\n\\t\\t\\t\\t\\n                //Expanding on right\\n\\t\\t\\t\\tj = i+1;\\n                prev = A[i];\\n                int right = 0;\\n                while(j < A.size() && A[j] <  prev){\\n                    prev = A[j];\\n                    j++;\\n                    right++;\\n                }\\n                \\n\\t\\t\\t\\t//Store maximum in \\'mountain\\'\\n                mountain = max(mountain, left+right+1);\\n            }\\n        }\\n        \\n        return mountain;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937620,
                "title": "java-one-pass-o-n-easy-to-understand",
                "content": "```\\npublic int longestMountain(int[] A) {\\n\\tint result = 0, currentLength = 0;\\n\\tBoolean isIncreasing = null;\\n\\tfor(int i=1;i<A.length;i++)\\n\\t\\tif(A[i-1] < A[i]) {\\n\\t\\t\\tif(isIncreasing == null || !isIncreasing) {\\n\\t\\t\\t\\tisIncreasing = true;\\n\\t\\t\\t\\tcurrentLength = 1;\\n\\t\\t\\t}\\n\\t\\t\\tcurrentLength++;\\n\\t\\t} else if(A[i-1] > A[i] && isIncreasing != null) {\\n\\t\\t\\tisIncreasing = false;\\n\\t\\t\\tcurrentLength++;\\n\\t\\t\\tresult = Math.max(result, currentLength);\\n\\t\\t} else isIncreasing = null;\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int longestMountain(int[] A) {\\n\\tint result = 0, currentLength = 0;\\n\\tBoolean isIncreasing = null;\\n\\tfor(int i=1;i<A.length;i++)\\n\\t\\tif(A[i-1] < A[i]) {\\n\\t\\t\\tif(isIncreasing == null || !isIncreasing) {\\n\\t\\t\\t\\tisIncreasing = true;\\n\\t\\t\\t\\tcurrentLength = 1;\\n\\t\\t\\t}\\n\\t\\t\\tcurrentLength++;\\n\\t\\t} else if(A[i-1] > A[i] && isIncreasing != null) {\\n\\t\\t\\tisIncreasing = false;\\n\\t\\t\\tcurrentLength++;\\n\\t\\t\\tresult = Math.max(result, currentLength);\\n\\t\\t} else isIncreasing = null;\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 791031,
                "title": "845-longest-mountain-in-array",
                "content": "This question can be done by finding a peak at every point where there is possibility of a peak.\\nPossibility means that previous element is smaller than current element and next is also smaller than current element.At that point we will check the length of the left part and right part and return left+right+1.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n\\n//  We\\'ll check the left length and the right length and return 1+left+right which will give the length of the mountain.   \\n    int getPeaklength(vector<int> v,int i)\\n    {\\n        int j=i;\\n        int left_length=0,right_length=0;\\n        while(j-1>=0)\\n        {\\n            if(v[j-1]<v[j])\\n                ++left_length;\\n            else\\n                break;\\n            --j;\\n        }\\n        if(left_length==0)\\n            return 0;\\n        while(i+1<v.size())\\n        {\\n            if(v[i+1]<v[i])\\n                ++right_length; \\n            else\\n                break;\\n            ++i;\\n        }\\n        if(right_length==0)\\n            return 0;\\n        return left_length+right_length+1;\\n    }\\n    \\n    int longestMountain(vector<int>& A) {\\n        if(A.size()<3)\\n            return 0;\\n        int max_len=0;\\n        for(int i=1;i<A.size()-1;++i)\\n        {\\n//          If the left part is smaller and right is also smaller then there is a probability  for a peak.We\\'ll check it \\n            if(A[i+1]<A[i] && A[i-1]<A[i])\\n            {\\n                int cur_length=getPeaklength(A,i);\\n                max_len=max(cur_length,max_len);\\n            }\\n        }\\n        return max_len;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\n//  We\\'ll check the left length and the right length and return 1+left+right which will give the length of the mountain.   \\n    int getPeaklength(vector<int> v,int i)\\n    {\\n        int j=i;\\n        int left_length=0,right_length=0;\\n        while(j-1>=0)\\n        {\\n            if(v[j-1]<v[j])\\n                ++left_length;\\n            else\\n                break;\\n            --j;\\n        }\\n        if(left_length==0)\\n            return 0;\\n        while(i+1<v.size())\\n        {\\n            if(v[i+1]<v[i])\\n                ++right_length; \\n            else\\n                break;\\n            ++i;\\n        }\\n        if(right_length==0)\\n            return 0;\\n        return left_length+right_length+1;\\n    }\\n    \\n    int longestMountain(vector<int>& A) {\\n        if(A.size()<3)\\n            return 0;\\n        int max_len=0;\\n        for(int i=1;i<A.size()-1;++i)\\n        {\\n//          If the left part is smaller and right is also smaller then there is a probability  for a peak.We\\'ll check it \\n            if(A[i+1]<A[i] && A[i-1]<A[i])\\n            {\\n                int cur_length=getPeaklength(A,i);\\n                max_len=max(cur_length,max_len);\\n            }\\n        }\\n        return max_len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 568903,
                "title": "simple-c-solution-with-explanation",
                "content": "1. A point can be a mountain peak, if its left value is lower and right is higher.\\n2. When such point is encountered, we traverse in both direction and find out the length.\\n3. once traverse is done, we update the max_len of mountain.\\n4. Now we can directly jump to right index to check again the peak condition.\\n\\nEach point will be traversed max 2 times. so Time = O(n)\\n\\n```\\n    int longestMountain(vector<int>& arr) {        \\n        int len = arr.size();        \\n        if(len < 3)\\n        {\\n            return 0;\\n        }        \\n        int max_len = 0;\\n        int i = 1;\\n        while(i < len-1)\\n        {\\n            // this is a mountain peak\\n            if(arr[i] > arr[i-1] && arr[i] > arr[i+1])\\n            {\\n                int low = i-1, high = i+1;                \\n                while(low >= 0 && arr[low] < arr[low+1])\\n                {\\n                    low--;\\n                }                            \\n                while(high < len && arr[high] < arr[high-1])\\n                {\\n                    high++;\\n                }                            \\n                max_len = max(max_len, high-low-1);\\n                i = high;\\n            }\\n            else\\n            {\\n                i++;\\n            }                        \\n        }        \\n        return max_len;        \\n    }\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int longestMountain(vector<int>& arr) {        \\n        int len = arr.size();        \\n        if(len < 3)\\n        {\\n            return 0;\\n        }        \\n        int max_len = 0;\\n        int i = 1;\\n        while(i < len-1)\\n        {\\n            // this is a mountain peak\\n            if(arr[i] > arr[i-1] && arr[i] > arr[i+1])\\n            {\\n                int low = i-1, high = i+1;                \\n                while(low >= 0 && arr[low] < arr[low+1])\\n                {\\n                    low--;\\n                }                            \\n                while(high < len && arr[high] < arr[high-1])\\n                {\\n                    high++;\\n                }                            \\n                max_len = max(max_len, high-low-1);\\n                i = high;\\n            }\\n            else\\n            {\\n                i++;\\n            }                        \\n        }        \\n        return max_len;        \\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 540621,
                "title": "java-dp-solution-o-n-time-and-o-n-memory",
                "content": "1. An int array leftIncr: leftIncr[i] denotes length of consecutive increasing subarray and A[i] is not included.\\n2. An int array rightDecr: rightDecr[i] denotes the length of consecutive decreasing subarray starts from A[i + 1];\\n3. The longest mountain array = max of ```leftIncr[i] + rightDecr[i] + 1```. \\n```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        int[] leftIncr = new int[A.length];\\n        int[] rightDecr = new int[A.length];\\n        \\n        for(int i = 1; i < A.length; ++i) {\\n            if(A[i] > A[i - 1]) {\\n                leftIncr[i] = leftIncr[i - 1] + 1;\\n            }\\n            if(A[A.length - 1 - i] > A[A.length - i]) {\\n                rightDecr[A.length - 1 - i] = rightDecr[A.length - i] + 1;\\n            }\\n        }\\n        \\n        int max = 0;\\n        for(int i = 1; i < A.length - 1; ++i) {\\n            if(leftIncr[i] > 0 && rightDecr[i] > 0) {\\n                max = Math.max(max, leftIncr[i] + rightDecr[i] + 1);\\n            }\\n        }\\n        \\n        return max;    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```leftIncr[i] + rightDecr[i] + 1```\n```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        int[] leftIncr = new int[A.length];\\n        int[] rightDecr = new int[A.length];\\n        \\n        for(int i = 1; i < A.length; ++i) {\\n            if(A[i] > A[i - 1]) {\\n                leftIncr[i] = leftIncr[i - 1] + 1;\\n            }\\n            if(A[A.length - 1 - i] > A[A.length - i]) {\\n                rightDecr[A.length - 1 - i] = rightDecr[A.length - i] + 1;\\n            }\\n        }\\n        \\n        int max = 0;\\n        for(int i = 1; i < A.length - 1; ++i) {\\n            if(leftIncr[i] > 0 && rightDecr[i] > 0) {\\n                max = Math.max(max, leftIncr[i] + rightDecr[i] + 1);\\n            }\\n        }\\n        \\n        return max;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484070,
                "title": "the-good-the-bad-and-the-ugly",
                "content": "All solutions use only one loop. I\\'ve pushed a value in the vector, but I pop it back at the end. This could be avoided with additional checks so I did it just for lulz.\\n\\n**Solution 1** (two auxillary variables)\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) \\n    {\\n        if (A.size() < 3)\\n            return 0;        \\n        A.push_back(A.back());\\n        int v=0, m=0;\\n        \\n        for (int i=1; i<A.size(); ++i)\\n        {\\n            if ((A[i-1] <= A[i] && A[i] >= A[i+1]) && !(A[i-1] < A[i] && A[i] > A[i+1]))\\n                v=i+1;\\n                \\n            if (A[i-1] >= A[i]  && A[i] <= A[i+1])\\n            {\\n                if (i>v && A[v+1] > A[v])\\n                    m = max(i-v+1, m);\\n                v = i;\\n            }\\n        }     \\n\\t\\tA.pop_back();\\n        return m;\\n       }\\n};\\n```\\n**Solution 2**(three auxillary variables)\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) \\n    {\\n        if (A.size() < 3)\\n            return 0;        \\n        A.push_back(10001);\\n\\t\\tint p = 0, v = 0, m = 0;\\n\\t\\t\\n        for (int i=1; i<A.size()-1; ++i)\\n        {\\n            p = A[i-1] < A[i] && A[i] > A[i+1] ? i : p;\\n            if (A[i-1] >= A[i] && A[i] <= A[i+1])\\n            {\\n                if (v < p)\\n                    m = max(i - v + 1, m);\\n                v = i;\\n            }\\n        }\\n\\t\\tA.pop_back();\\n        return m;\\n\\t }\\n};\\n```\\n**Solution 3** (two auxillary variables + flag)\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) \\n    {\\n        int p = 0, m = 0;\\n        bool asc = true;\\n                \\n        for (int i=1; i<A.size(); ++i)\\n        {\\n            if (i == p+1 && A[i] <= A[i-1])\\n                p++;\\n            else if (asc) \\n            {\\n                if (A[i] == A[i-1]) \\n                    p=i;\\n                else if (A[i] < A[i-1])                  \\n                    asc = false; \\n            }\\n            else if (A[i] >= A[i-1])\\n            {\\n                asc = true;\\n                m = max(i-p, m);\\n                p = (A[i] >  A[i-1]) ? i-1: i;\\n            }\\n        }\\n            \\n        if (!asc) m = max(int(A.size())-p, m);     \\n        return m;\\n\\t }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) \\n    {\\n        if (A.size() < 3)\\n            return 0;        \\n        A.push_back(A.back());\\n        int v=0, m=0;\\n        \\n        for (int i=1; i<A.size(); ++i)\\n        {\\n            if ((A[i-1] <= A[i] && A[i] >= A[i+1]) && !(A[i-1] < A[i] && A[i] > A[i+1]))\\n                v=i+1;\\n                \\n            if (A[i-1] >= A[i]  && A[i] <= A[i+1])\\n            {\\n                if (i>v && A[v+1] > A[v])\\n                    m = max(i-v+1, m);\\n                v = i;\\n            }\\n        }     \\n\\t\\tA.pop_back();\\n        return m;\\n       }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) \\n    {\\n        if (A.size() < 3)\\n            return 0;        \\n        A.push_back(10001);\\n\\t\\tint p = 0, v = 0, m = 0;\\n\\t\\t\\n        for (int i=1; i<A.size()-1; ++i)\\n        {\\n            p = A[i-1] < A[i] && A[i] > A[i+1] ? i : p;\\n            if (A[i-1] >= A[i] && A[i] <= A[i+1])\\n            {\\n                if (v < p)\\n                    m = max(i - v + 1, m);\\n                v = i;\\n            }\\n        }\\n\\t\\tA.pop_back();\\n        return m;\\n\\t }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) \\n    {\\n        int p = 0, m = 0;\\n        bool asc = true;\\n                \\n        for (int i=1; i<A.size(); ++i)\\n        {\\n            if (i == p+1 && A[i] <= A[i-1])\\n                p++;\\n            else if (asc) \\n            {\\n                if (A[i] == A[i-1]) \\n                    p=i;\\n                else if (A[i] < A[i-1])                  \\n                    asc = false; \\n            }\\n            else if (A[i] >= A[i-1])\\n            {\\n                asc = true;\\n                m = max(i-p, m);\\n                p = (A[i] >  A[i-1]) ? i-1: i;\\n            }\\n        }\\n            \\n        if (!asc) m = max(int(A.size())-p, m);     \\n        return m;\\n\\t }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 285499,
                "title": "java-dp-o-n-easier-to-understand",
                "content": "let\\'s create 2 dp arrays ,\\none for counting length of mountain up from the left side,\\nthe other same purpose from the right side.\\nCodes are a little too much , but this is a very easy way to come up during interview.\\n```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        int result = 0;\\n        int n = A.length;//n stands for array length\\n        \\n        if(n>0){\\n            \\n         int[] left = new int[n];\\n         int[] right = new int[n];\\n         left[0]=0;\\n         right[n-1]=0;\\n            \\n         for(int i = 1;i<n;i++){\\n            if(A[i]>A[i-1]){\\n                left[i]=left[i-1]+1;\\n            }else{\\n                left[i]=0;\\n            }\\n         }\\n        \\n         for(int j = n-2;j>-1;j--){\\n            if(A[j]>A[j+1]){\\n                right[j]=right[j+1]+1;\\n            }else{\\n                right[j]=0;\\n            }\\n         }\\n        \\n        \\n         for(int k = 0;k<n;k++){\\n          if(left[k]>0 && right[k]>0){\\n            result = Math.max(result,left[k]+right[k]+1);      \\n          }   \\n         }\\n            \\n        }\\n        return result;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        int result = 0;\\n        int n = A.length;//n stands for array length\\n        \\n        if(n>0){\\n            \\n         int[] left = new int[n];\\n         int[] right = new int[n];\\n         left[0]=0;\\n         right[n-1]=0;\\n            \\n         for(int i = 1;i<n;i++){\\n            if(A[i]>A[i-1]){\\n                left[i]=left[i-1]+1;\\n            }else{\\n                left[i]=0;\\n            }\\n         }\\n        \\n         for(int j = n-2;j>-1;j--){\\n            if(A[j]>A[j+1]){\\n                right[j]=right[j+1]+1;\\n            }else{\\n                right[j]=0;\\n            }\\n         }\\n        \\n        \\n         for(int k = 0;k<n;k++){\\n          if(left[k]>0 && right[k]>0){\\n            result = Math.max(result,left[k]+right[k]+1);      \\n          }   \\n         }\\n            \\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 285145,
                "title": "java-intuitive-solution-go-uphill-and-downhill",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        int res = 0;\\n        for(int i = 1; i < A.length; ){\\n            if(A[i] > A[i - 1]){\\n                int j = i;\\n                \\n                //go uphill\\n                while(j < A.length && A[j] > A[j - 1]){\\n                    j++;\\n                }\\n                \\n                if(j == A.length)\\n                    break;\\n                if(A[j] == A[j - 1]){\\n                    i = j + 1;\\n                    continue;\\n                }\\t\\t\\t\\t\\t\\n                \\n                //go downhill\\n                while(j < A.length && A[j] < A[j - 1]){\\n                    j++;\\n                }\\n                \\n                if(j - i > 1)\\n                    res = Math.max(res, j - i + 1);\\n                \\n                i = j;\\n            } else \\n                i++;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nThanks fan_zh for point out the duplicate numbers senario.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        int res = 0;\\n        for(int i = 1; i < A.length; ){\\n            if(A[i] > A[i - 1]){\\n                int j = i;\\n                \\n                //go uphill\\n                while(j < A.length && A[j] > A[j - 1]){\\n                    j++;\\n                }\\n                \\n                if(j == A.length)\\n                    break;\\n                if(A[j] == A[j - 1]){\\n                    i = j + 1;\\n                    continue;\\n                }\\t\\t\\t\\t\\t\\n                \\n                //go downhill\\n                while(j < A.length && A[j] < A[j - 1]){\\n                    j++;\\n                }\\n                \\n                if(j - i > 1)\\n                    res = Math.max(res, j - i + 1);\\n                \\n                i = j;\\n            } else \\n                i++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 239625,
                "title": "1-pass-solution-easy-to-understand",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int i = 0;\\n        int start = 0;\\n        int peak = 0;\\n        int end = 0;\\n        int answer = 0;\\n        while(i + 1 < A.size())\\n        {\\n            // go to local min\\n            while(i + 1 < A.size() && A[i] > A[i + 1])\\n            {\\n                i++;\\n            }\\n            // record starting index\\n            start = i;\\n            // going up\\n            while(i + 1 < A.size() && A[i] < A[i + 1])\\n            {\\n                i++;\\n            }\\n            // record peak index\\n            peak = i;\\n            // going down\\n            while(i + 1 < A.size() && A[i] > A[i + 1])\\n            {\\n                i++;\\n            }\\n            //record end index\\n            end = i;\\n            // if start, peak, end, have different index, there is a mountain\\n            if(start != peak && peak != end)\\n            {\\n                answer = max(answer, i + 1 - start);\\n            }\\n            // if is flat, move one step\\n            if(i + 1 < A.size() && A[i] == A[i + 1])\\n            {\\n                i++;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int i = 0;\\n        int start = 0;\\n        int peak = 0;\\n        int end = 0;\\n        int answer = 0;\\n        while(i + 1 < A.size())\\n        {\\n            // go to local min\\n            while(i + 1 < A.size() && A[i] > A[i + 1])\\n            {\\n                i++;\\n            }\\n            // record starting index\\n            start = i;\\n            // going up\\n            while(i + 1 < A.size() && A[i] < A[i + 1])\\n            {\\n                i++;\\n            }\\n            // record peak index\\n            peak = i;\\n            // going down\\n            while(i + 1 < A.size() && A[i] > A[i + 1])\\n            {\\n                i++;\\n            }\\n            //record end index\\n            end = i;\\n            // if start, peak, end, have different index, there is a mountain\\n            if(start != peak && peak != end)\\n            {\\n                answer = max(answer, i + 1 - start);\\n            }\\n            // if is flat, move one step\\n            if(i + 1 < A.size() && A[i] == A[i + 1])\\n            {\\n                i++;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148674,
                "title": "c-one-pass-with-comments",
                "content": "```\\n    int longestMountain(vector<int>& A) {\\n        int s = 0, p = -1, res = 0, n = A.size();\\n        for (int i = 1; i < n; i++) {\\n            if (p != -1) {\\n                // if we are tracking peak and it goes down then update result\\n                // if it does not go down, then reset peak\\n                if (A[i] < A[i-1]) res = max(i-s+1, res);\\n                else p = -1;\\n            }\\n            if ((i < n-1 && A[i] < A[i+1]) && A[i] <= A[i-1]) {\\n                // find starting point of next mountain\\n                s = i;\\n            }\\n            if ((A[i-1] < A[i]) && (i < n-1 && A[i] > A[i+1])) {\\n                // find peak\\n                p = i;\\n            }            \\n        }\\n        return res;\\n    }\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\n    int longestMountain(vector<int>& A) {\\n        int s = 0, p = -1, res = 0, n = A.size();\\n        for (int i = 1; i < n; i++) {\\n            if (p != -1) {\\n                // if we are tracking peak and it goes down then update result\\n                // if it does not go down, then reset peak\\n                if (A[i] < A[i-1]) res = max(i-s+1, res);\\n                else p = -1;\\n            }\\n            if ((i < n-1 && A[i] < A[i+1]) && A[i] <= A[i-1]) {\\n                // find starting point of next mountain\\n                s = i;\\n            }\\n            if ((A[i-1] < A[i]) && (i < n-1 && A[i] > A[i+1])) {\\n                // find peak\\n                p = i;\\n            }            \\n        }\\n        return res;\\n    }\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 135623,
                "title": "kt-js-py3-cpp-mountain-peak",
                "content": "Let each index `k` be the candidate \"peak\" of the mountain.  Let `i` be the index used to traverse the left-downslope of the mountain and let `j` be the index used to traverse the right-downslope of the mountain.  If both `i` and `j` are able to go downwards starting from the peak `k`, then a mountain has been found.  Return the longest mountain from `i..j` inclusive as the `best` answer.\\n\\n---\\n\\n**Runtime:** O(N<sup>2</sup>)\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun longestMountain(A: IntArray): Int {\\n        var best = 0\\n        var N = A.size\\n        for (k in 1 until N - 1) {\\n            var i = k\\n            var j = k\\n            while (0 <= i - 1 && A[i - 1] < A[i]) --i;\\n            while (j + 1 < N  && A[j] > A[j + 1]) ++j;\\n            if (i < k && k < j)\\n                best = Math.max(best, j - i + 1)  // +1 for i..j inclusive\\n        }\\n        return best\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet longestMountain = (A, best = 0) => {\\n    let N = A.length;\\n    for (let k = 1; k + 1 < N; ++k) {\\n        let i = k,\\n            j = k;\\n        while (0 <= i - 1 && A[i - 1] < A[i]) --i;\\n        while (j + 1 < N  && A[j] > A[j + 1]) ++j;\\n        if (i < k && k < j)\\n            best = Math.max(best, j - i + 1);  // +1 for i..j inclusive\\n    }\\n    return best;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def longestMountain(self, A: List[int], best = 0) -> int:\\n        N = len(A)\\n        for k in range(1, N - 1):\\n            i = k\\n            j = k\\n            while 0 <= i - 1 and A[i - 1] < A[i]: i -= 1\\n            while j + 1 < N  and A[j] > A[j + 1]: j += 1\\n            if i < k < j:\\n                best = max(best, j - i + 1)  # +1 for i..j inclusive\\n        return best\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int longestMountain(VI& A, int best = 0) {\\n        int N = A.size();\\n        for (auto k{ 1 }; k + 1 < N; ++k) {\\n            auto i = k,\\n                 j = k;\\n            while (0 <= i - 1 && A[i - 1] < A[i]) --i;\\n            while (j + 1 < N  && A[j] > A[j + 1]) ++j;\\n            if (i < k && k < j)\\n                best = max(best, j - i + 1);  // +1 for i..j inclusive\\n        }\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun longestMountain(A: IntArray): Int {\\n        var best = 0\\n        var N = A.size\\n        for (k in 1 until N - 1) {\\n            var i = k\\n            var j = k\\n            while (0 <= i - 1 && A[i - 1] < A[i]) --i;\\n            while (j + 1 < N  && A[j] > A[j + 1]) ++j;\\n            if (i < k && k < j)\\n                best = Math.max(best, j - i + 1)  // +1 for i..j inclusive\\n        }\\n        return best\\n    }\\n}\\n```\n```\\nlet longestMountain = (A, best = 0) => {\\n    let N = A.length;\\n    for (let k = 1; k + 1 < N; ++k) {\\n        let i = k,\\n            j = k;\\n        while (0 <= i - 1 && A[i - 1] < A[i]) --i;\\n        while (j + 1 < N  && A[j] > A[j + 1]) ++j;\\n        if (i < k && k < j)\\n            best = Math.max(best, j - i + 1);  // +1 for i..j inclusive\\n    }\\n    return best;\\n};\\n```\n```\\nclass Solution:\\n    def longestMountain(self, A: List[int], best = 0) -> int:\\n        N = len(A)\\n        for k in range(1, N - 1):\\n            i = k\\n            j = k\\n            while 0 <= i - 1 and A[i - 1] < A[i]: i -= 1\\n            while j + 1 < N  and A[j] > A[j + 1]: j += 1\\n            if i < k < j:\\n                best = max(best, j - i + 1)  # +1 for i..j inclusive\\n        return best\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int longestMountain(VI& A, int best = 0) {\\n        int N = A.size();\\n        for (auto k{ 1 }; k + 1 < N; ++k) {\\n            auto i = k,\\n                 j = k;\\n            while (0 <= i - 1 && A[i - 1] < A[i]) --i;\\n            while (j + 1 < N  && A[j] > A[j + 1]) ++j;\\n            if (i < k && k < j)\\n                best = max(best, j - i + 1);  // +1 for i..j inclusive\\n        }\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066684,
                "title": "java-easy-one-pass-solution-o-1-memory",
                "content": "```java\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int up = 0, down = 0, result = 0;\\n\\n        for(int i = 1; i < arr.length; ++i) {\\n            if((down > 0 && arr[i - 1] < arr[i]) || arr[i - 1] == arr[i])\\n                up = down = 0;\\n            if(arr[i - 1] < arr[i])\\n                up++;\\n            if(arr[i - 1] > arr[i])\\n                down++;\\n            if(down > 0 && up > 0 && up + down + 1 > result)\\n                result = up + down + 1;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int up = 0, down = 0, result = 0;\\n\\n        for(int i = 1; i < arr.length; ++i) {\\n            if((down > 0 && arr[i - 1] < arr[i]) || arr[i - 1] == arr[i])\\n                up = down = 0;\\n            if(arr[i - 1] < arr[i])\\n                up++;\\n            if(arr[i - 1] > arr[i])\\n                down++;\\n            if(down > 0 && up > 0 && up + down + 1 > result)\\n                result = up + down + 1;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041553,
                "title": "best-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    static int helper(int arr[], int idx){\\n        int ans = 0;\\n\\n        int i = idx-1;\\n        int a = arr[idx];\\n        while(i>=0 && arr[i]<a){\\n            ans++;\\n            a=arr[i];\\n            i--;\\n        }\\n        \\n        i=idx+1;\\n        a=arr[idx];\\n\\n        while(i<arr.length && arr[i]<a){\\n            ans++;\\n            a=arr[i];\\n            i++;\\n        }\\n\\n        return ans+1;\\n    }\\n    public int longestMountain(int[] arr) {\\n        int n = arr.length;\\n\\n        int max = 0;\\n\\n        for(int i=1; i<n-1; i++){\\n            if(arr[i]>arr[i-1] && arr[i]>arr[i+1]){\\n                max = Math.max(max,helper(arr,i));\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    static int helper(int arr[], int idx){\\n        int ans = 0;\\n\\n        int i = idx-1;\\n        int a = arr[idx];\\n        while(i>=0 && arr[i]<a){\\n            ans++;\\n            a=arr[i];\\n            i--;\\n        }\\n        \\n        i=idx+1;\\n        a=arr[idx];\\n\\n        while(i<arr.length && arr[i]<a){\\n            ans++;\\n            a=arr[i];\\n            i++;\\n        }\\n\\n        return ans+1;\\n    }\\n    public int longestMountain(int[] arr) {\\n        int n = arr.length;\\n\\n        int max = 0;\\n\\n        for(int i=1; i<n-1; i++){\\n            if(arr[i]>arr[i-1] && arr[i]>arr[i+1]){\\n                max = Math.max(max,helper(arr,i));\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759339,
                "title": "c-easy-to-understand-solution",
                "content": "# Intuition\\nWe have an array `arr` where two consecutive elements can be either one of these:-\\n1. `arr[i] > arr[i-1]`\\n2. `arr[i] < arr[i-1]`\\n3. `arr[i] == arr[i-1]` `Apparently arr[i] not a part of the mountain array`\\nLooking at our question carefully, we can say for cases with `arr.size() < 3` would  have no mountain array. Whenever the array is increasing first(i.e. 1st condition holds first) there is a possibility of having the required array.But we can\\'t be assured until we encounter 2nd condition at least once. This is the primary logic behind.\\n\\n# Approach\\nWe initialise two variables to check when our array is strictly increasing or strictly decreasing. Next we check the cases where the monotonocity is broken.Cases where 3rd condition mentioned in intuition hold will just be ignored and thus we approach the maximum length of mountain we can encounter.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n// no mountain exists\\n        if(n < 3) return 0;\\n        int ans = 0,temp = 0,checkinc = 0, checkdec = 0;\\n        for(int  i = 1; i < n; i++){\\n            if(arr[i] > arr[i-1]){\\n// the end of the mountain\\n                if(checkdec == 1){\\n                    ans = max(temp,ans);\\n                    checkdec = 0;\\n                    checkinc = 1;\\n                    temp = 2;\\n                }\\n                else{\\n// the start of a new mountain\\n                    if(checkinc == 0){\\n                    temp =2;\\n                    checkinc = 1;\\n                    }\\n//add to the existing mountain\\n                    else\\n                    temp++;\\n                }\\n            }\\n            else if(arr[i] < arr[i-1]){\\n// the peak of the mountain\\n                if(checkinc == 1){\\n                    if(checkdec == 0)\\n                    checkdec =1;\\n//add to the existing mountain\\n                    temp++;\\n                }\\n//no mountain\\n                else{\\n                temp = 0;\\n                checkdec = 0;\\n                checkinc = 0;\\n            }\\n            }\\n            else{\\n// the end of the mountain\\n                if(checkinc == 1 && checkdec == 1)\\n                 ans = max(temp,ans);\\n// no mountain exists here\\n                 checkinc = 0;\\n                 checkdec = 0;\\n                 temp = 0;\\n            }\\n        }\\n// the end of the mountain\\n        if(checkinc == 1 && checkdec == 1)\\n        ans = max(temp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n// no mountain exists\\n        if(n < 3) return 0;\\n        int ans = 0,temp = 0,checkinc = 0, checkdec = 0;\\n        for(int  i = 1; i < n; i++){\\n            if(arr[i] > arr[i-1]){\\n// the end of the mountain\\n                if(checkdec == 1){\\n                    ans = max(temp,ans);\\n                    checkdec = 0;\\n                    checkinc = 1;\\n                    temp = 2;\\n                }\\n                else{\\n// the start of a new mountain\\n                    if(checkinc == 0){\\n                    temp =2;\\n                    checkinc = 1;\\n                    }\\n//add to the existing mountain\\n                    else\\n                    temp++;\\n                }\\n            }\\n            else if(arr[i] < arr[i-1]){\\n// the peak of the mountain\\n                if(checkinc == 1){\\n                    if(checkdec == 0)\\n                    checkdec =1;\\n//add to the existing mountain\\n                    temp++;\\n                }\\n//no mountain\\n                else{\\n                temp = 0;\\n                checkdec = 0;\\n                checkinc = 0;\\n            }\\n            }\\n            else{\\n// the end of the mountain\\n                if(checkinc == 1 && checkdec == 1)\\n                 ans = max(temp,ans);\\n// no mountain exists here\\n                 checkinc = 0;\\n                 checkdec = 0;\\n                 temp = 0;\\n            }\\n        }\\n// the end of the mountain\\n        if(checkinc == 1 && checkdec == 1)\\n        ans = max(temp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626219,
                "title": "longest-bitonic-subsequence-dynamic-programming-c",
                "content": "# Approach :\\nTo solve this problem, we can start by observing that a mountain sequence is essentially a combination of an increasing subsequence followed by a decreasing subsequence. Therefore, we can utilize the concept of the Longest Increasing Subsequence (LIS) to find the longest mountain sequence.\\n\\nWe can maintain two dynamic programming arrays: dp and dp2. The dp array will store the length of the increasing subsequence ending at each index, similar to the LIS problem. The dp2 array will store the length of the decreasing subsequence starting at each index.\\n\\nWe can iterate over the array arr twice. In the first iteration, we calculate the length of the increasing subsequence ending at each index and store it in the dp array. We compare each element with its previous element and if it is greater, we can extend the increasing subsequence length. In the second iteration (reversed), we calculate the length of the decreasing subsequence starting at each index and store it in the dp2 array. We compare each element with its next element and if it is greater, we can extend the decreasing subsequence length.\\n\\nFinally, we iterate over each index and check if both the increasing and decreasing subsequences have lengths greater than 1. If this condition is met at a particular index, we calculate the length of the mountain sequence by summing the lengths of the corresponding subsequences and subtracting 1 (to avoid counting the same element twice). We update a variable ans to keep track of the maximum length found.\\n\\nAt the end of the iteration, we return the value stored in ans, which represents the maximum length of a valid mountain sequence in the input array arr.\\n\\nIn summary, we utilize the concept of the Longest Increasing Subsequence (LIS) to find the longest mountain sequence. By maintaining two dynamic programming arrays and iterating over the array twice, we can calculate the lengths of the increasing and decreasing subsequences. Finally, we find the maximum length of a mountain sequence by summing the lengths of the corresponding subsequences at each index and subtracting 1.\\n\\n**[Link to the detailed Longest Bitonic Subsequence approach](https://takeuforward.org/data-structure/longest-bitonic-subsequence-dp-46/)**\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity :\\n- Time complexity : The time complexity of the given solution is $$O(n)$$, where n is the size of the input array arr. This is because we iterate over the array twice, performing constant-time operations for each element.\\nIn the first iteration, we calculate the length of the increasing subsequence ending at each index. This requires comparing each element with its previous element, resulting in n-1 comparisons. Therefore, the time complexity of this step is $$O(n)$$.\\nIn the second iteration (reversed), we calculate the length of the decreasing subsequence starting at each index. This also requires comparing each element with its next element, resulting in n-1 comparisons. Hence, the time complexity of this step is also $$O(n)$$.\\nFinally, we iterate over each index to find the maximum length of a mountain sequence. This operation takes constant time for each index, resulting in $$O(n)$$ time complexity.\\nOverall, the time complexity of the solution is $$O(n)$$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : The space complexity of the solution is $$O(n)$$ as well. We use two additional arrays, dp and dp2, to store the lengths of the increasing and decreasing subsequences, respectively. Both arrays have a length of n, which is the same as the input array arr. Therefore, the space complexity is linear in terms of the input size.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code :\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> dp(n, 1); // dp[i] stores the length of the increasing subsequence ending at index i\\n        vector<int> dp2(n, 1); // dp2[i] stores the length of the decreasing subsequence starting at index i\\n        int ans = 0; // Variable to store the maximum length of a mountain sequence\\n\\n        // Calculate the length of the increasing subsequence ending at each index\\n        for (int ind = 1; ind < n; ind++) {\\n            if (arr[ind] > arr[ind - 1]) {\\n                // If the element at the current index is greater than the previous element,\\n                // we can extend the increasing subsequence. Increment dp[ind] by 1.\\n                dp[ind] = 1 + dp[ind - 1];\\n            }\\n        }\\n\\n        // Calculate the length of the decreasing subsequence starting at each index\\n        for (int ind = n - 2; ind >= 0; ind--) {\\n            if (arr[ind] > arr[ind + 1]) {\\n                // If the element at the current index is greater than the next element,\\n                // we can extend the decreasing subsequence. Increment dp2[ind] by 1.\\n                dp2[ind] = 1 + dp2[ind + 1];\\n            }\\n        }\\n\\n        // Iterate over each index and find the maximum length of a mountain sequence\\n        for (int i = 0; i < n; i++) {\\n            if (dp[i] > 1 && dp2[i] > 1) {\\n                // If both the increasing and decreasing subsequences have lengths greater than 1 at index i,\\n                // calculate the length of the mountain sequence by summing the lengths of the subsequences\\n                // and subtracting 1 (to avoid counting the same element twice). Update the ans variable.\\n                ans = max(dp[i] + dp2[i] - 1, ans);\\n            }\\n        }\\n\\n        return ans; // Return the maximum length of a mountain sequence\\n    }\\n};\\n```\\n---\\n\\n**PLEASE UPVOTE IF YOU LIKED THE SOLUTION :)**\\n\\n![ezgif.com-optimize.gif](https://assets.leetcode.com/users/images/c7837255-5339-41d8-b699-1dff126e8726_1686500536.441457.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> dp(n, 1); // dp[i] stores the length of the increasing subsequence ending at index i\\n        vector<int> dp2(n, 1); // dp2[i] stores the length of the decreasing subsequence starting at index i\\n        int ans = 0; // Variable to store the maximum length of a mountain sequence\\n\\n        // Calculate the length of the increasing subsequence ending at each index\\n        for (int ind = 1; ind < n; ind++) {\\n            if (arr[ind] > arr[ind - 1]) {\\n                // If the element at the current index is greater than the previous element,\\n                // we can extend the increasing subsequence. Increment dp[ind] by 1.\\n                dp[ind] = 1 + dp[ind - 1];\\n            }\\n        }\\n\\n        // Calculate the length of the decreasing subsequence starting at each index\\n        for (int ind = n - 2; ind >= 0; ind--) {\\n            if (arr[ind] > arr[ind + 1]) {\\n                // If the element at the current index is greater than the next element,\\n                // we can extend the decreasing subsequence. Increment dp2[ind] by 1.\\n                dp2[ind] = 1 + dp2[ind + 1];\\n            }\\n        }\\n\\n        // Iterate over each index and find the maximum length of a mountain sequence\\n        for (int i = 0; i < n; i++) {\\n            if (dp[i] > 1 && dp2[i] > 1) {\\n                // If both the increasing and decreasing subsequences have lengths greater than 1 at index i,\\n                // calculate the length of the mountain sequence by summing the lengths of the subsequences\\n                // and subtracting 1 (to avoid counting the same element twice). Update the ans variable.\\n                ans = max(dp[i] + dp2[i] - 1, ans);\\n            }\\n        }\\n\\n        return ans; // Return the maximum length of a mountain sequence\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462560,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int n=arr.length;\\n        int dp1[]=new int[n];\\n        int dp2[]=new int[n];\\n        Arrays.fill(dp1,1);\\n        Arrays.fill(dp2,1);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(arr[i-1]<arr[i])\\n                dp1[i]=dp1[i-1]+1;\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(arr[i+1]<arr[i])\\n                dp2[i]=dp2[i+1]+1;\\n        }\\n        int max=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            System.out.println(dp1[i]+\" \"+dp2[i]);\\n            if(dp1[i]>1 && dp2[i]>1)\\n                max=(int)Math.max(max,dp1[i]+dp2[i]-1);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int n=arr.length;\\n        int dp1[]=new int[n];\\n        int dp2[]=new int[n];\\n        Arrays.fill(dp1,1);\\n        Arrays.fill(dp2,1);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(arr[i-1]<arr[i])\\n                dp1[i]=dp1[i-1]+1;\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(arr[i+1]<arr[i])\\n                dp2[i]=dp2[i+1]+1;\\n        }\\n        int max=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            System.out.println(dp1[i]+\" \"+dp2[i]);\\n            if(dp1[i]>1 && dp2[i]>1)\\n                max=(int)Math.max(max,dp1[i]+dp2[i]-1);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161657,
                "title": "prefix-and-suffix-sum-easy-to-understand",
                "content": "```\\nclass Solution {\\n    int prefix[10001],suffix[10001];\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        map<int,int> mp;\\n        for(auto it:arr) mp[it]++;\\n        if(mp.size()==1) return 0;\\n        int n=arr.size();\\n       int ckt=1;\\n        prefix[0]=ckt;\\n        for(int i=1;i<n;i++){\\n          if(arr[i-1]<arr[i]){\\n              ckt++;\\n          }\\n        else ckt=1;\\n          prefix[i]=ckt;\\n        }\\n        // similarly for suffix\\n        ckt=1;\\n        suffix[n-1]=ckt;\\n        for(int i=n-2;i>=0;i--){\\n            if(arr[i]>arr[i+1]) ckt++;\\n            else ckt=1;\\n            suffix[i]=ckt;\\n        }\\n        for(int i=0;i<n;i++){\\n            cout<<prefix[i]<<\" \";\\n        }\\n        cout<<endl;\\n        for(int i=0;i<n;i++){\\n            cout<<suffix[i]<<\" \";\\n        }\\n        int maxi=0;\\n        for(int i=0;i<n;i++){\\n            int sum=prefix[i]+suffix[i]-1;\\n            if(prefix[i]!=1 && suffix[i]!=1) maxi=max(maxi,sum);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    int prefix[10001],suffix[10001];\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        map<int,int> mp;\\n        for(auto it:arr) mp[it]++;\\n        if(mp.size()==1) return 0;\\n        int n=arr.size();\\n       int ckt=1;\\n        prefix[0]=ckt;\\n        for(int i=1;i<n;i++){\\n          if(arr[i-1]<arr[i]){\\n              ckt++;\\n          }\\n        else ckt=1;\\n          prefix[i]=ckt;\\n        }\\n        // similarly for suffix\\n        ckt=1;\\n        suffix[n-1]=ckt;\\n        for(int i=n-2;i>=0;i--){\\n            if(arr[i]>arr[i+1]) ckt++;\\n            else ckt=1;\\n            suffix[i]=ckt;\\n        }\\n        for(int i=0;i<n;i++){\\n            cout<<prefix[i]<<\" \";\\n        }\\n        cout<<endl;\\n        for(int i=0;i<n;i++){\\n            cout<<suffix[i]<<\" \";\\n        }\\n        int maxi=0;\\n        for(int i=0;i<n;i++){\\n            int sum=prefix[i]+suffix[i]-1;\\n            if(prefix[i]!=1 && suffix[i]!=1) maxi=max(maxi,sum);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3047278,
                "title": "two-python-solution-with-o-n-time-o-n-space-and-second-with-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        # n = len(arr)\\n        # incre, decre = [0]* n, [0]*n\\n\\n        # for i in range(1, n):\\n        #     if arr[i] > arr[i-1]:\\n        #         incre[i] = incre[i-1] + 1\\n\\n        # for i in range(n-1)[::-1]:\\n        #     if arr[i] > arr[i+1]:\\n        #         decre[i] = decre[i+1] + 1\\n        # maxi = 0   \\n        # for i in range(1, n):\\n        #     if incre[i] and decre[i]:\\n        #         maxi = max(maxi, incre[i] + decre[i] + 1)\\n        # return maxi\\n        # if len(arr) < 3:\\n        #     return 0\\n\\n        # In constant O(1) space\\n        incre,decre,ans = 0,0,0\\n        for i in range(1, len(arr)):\\n            if (decre and arr[i-1] < arr[i]) or arr[i-1] == arr[i]:\\n                incre,decre = 0, 0\\n            incre += arr[i-1] < arr[i]\\n            decre += arr[i-1] > arr[i]\\n\\n            if incre  and decre:\\n                ans = max(ans, incre + decre + 1)\\n        return ans    \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        # n = len(arr)\\n        # incre, decre = [0]* n, [0]*n\\n\\n        # for i in range(1, n):\\n        #     if arr[i] > arr[i-1]:\\n        #         incre[i] = incre[i-1] + 1\\n\\n        # for i in range(n-1)[::-1]:\\n        #     if arr[i] > arr[i+1]:\\n        #         decre[i] = decre[i+1] + 1\\n        # maxi = 0   \\n        # for i in range(1, n):\\n        #     if incre[i] and decre[i]:\\n        #         maxi = max(maxi, incre[i] + decre[i] + 1)\\n        # return maxi\\n        # if len(arr) < 3:\\n        #     return 0\\n\\n        # In constant O(1) space\\n        incre,decre,ans = 0,0,0\\n        for i in range(1, len(arr)):\\n            if (decre and arr[i-1] < arr[i]) or arr[i-1] == arr[i]:\\n                incre,decre = 0, 0\\n            incre += arr[i-1] < arr[i]\\n            decre += arr[i-1] > arr[i]\\n\\n            if incre  and decre:\\n                ans = max(ans, incre + decre + 1)\\n        return ans    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2883947,
                "title": "java-without-using-dp",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int n = arr.length;\\n        \\n        int ans= 0;\\n        for(int i =1;i<n-1;){\\n            if(arr[i-1]<arr[i] && arr[i]>arr[i+1]){\\n                int j=i;\\n                int count = 1;\\n                 while( j>0 && arr[j] > arr[j-1] ){ \\n// if your condition is  arr[j] > arr[j-1] && j>0,\\n// it\\'ll throw error cz it, first check code which \\n//are in first, so then arr[j-1] try to find and \\n//check the condition, so it\\'ll throw error \\n                    j--;\\n                    count++;\\n                }\\n                while( i < n-1 && arr[i] > arr[i+1] ){\\n                    i++;\\n                    count++;\\n                }\\n                ans = Math.max(count,ans);\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int n = arr.length;\\n        \\n        int ans= 0;\\n        for(int i =1;i<n-1;){\\n            if(arr[i-1]<arr[i] && arr[i]>arr[i+1]){\\n                int j=i;\\n                int count = 1;\\n                 while( j>0 && arr[j] > arr[j-1] ){ \\n// if your condition is  arr[j] > arr[j-1] && j>0,\\n// it\\'ll throw error cz it, first check code which \\n//are in first, so then arr[j-1] try to find and \\n//check the condition, so it\\'ll throw error \\n                    j--;\\n                    count++;\\n                }\\n                while( i < n-1 && arr[i] > arr[i+1] ){\\n                    i++;\\n                    count++;\\n                }\\n                ans = Math.max(count,ans);\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2610920,
                "title": "c-fastest-submission-tc-o-n-sc-o-1-dp",
                "content": "TC: O(N)\\nSC: O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        int i=0;\\n        int maxi=0;\\n        \\n        while(i<n){\\n            \\n            int up=1;\\n            //upside\\n            while(i+1<n && arr[i]<arr[i+1]){\\n                i++;\\n                up++;\\n            }\\n            \\n            int down=0;\\n            //downside\\n            while(i+1<n && arr[i]>arr[i+1]){\\n                i++;\\n                down++;\\n            }\\n            \\n\\t\\t\\t//check for valid mountain array\\n            if(up>1 && down >0){\\n                maxi= maxi < up + down ? up+down : maxi;\\n                    \\n            }\\n    \\t/*\\n\\t        if there is  down means the break point will be at arr[i] <= arr[i+1] in this case arr[i] \\n\\t\\t\\tcan be part of new mountrain array in upside so we will miss one element in further \\n\\t\\t\\tcreation . thats why if(down!=0) we will again start from same index i, else we can take\\n\\t\\t\\tnew i+1\\n\\t\\t*/\\n            if(down==0)\\n                i++;\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        int i=0;\\n        int maxi=0;\\n        \\n        while(i<n){\\n            \\n            int up=1;\\n            //upside\\n            while(i+1<n && arr[i]<arr[i+1]){\\n                i++;\\n                up++;\\n            }\\n            \\n            int down=0;\\n            //downside\\n            while(i+1<n && arr[i]>arr[i+1]){\\n                i++;\\n                down++;\\n            }\\n            \\n\\t\\t\\t//check for valid mountain array\\n            if(up>1 && down >0){\\n                maxi= maxi < up + down ? up+down : maxi;\\n                    \\n            }\\n    \\t/*\\n\\t        if there is  down means the break point will be at arr[i] <= arr[i+1] in this case arr[i] \\n\\t\\t\\tcan be part of new mountrain array in upside so we will miss one element in further \\n\\t\\t\\tcreation . thats why if(down!=0) we will again start from same index i, else we can take\\n\\t\\t\\tnew i+1\\n\\t\\t*/\\n            if(down==0)\\n                i++;\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588163,
                "title": "scan-left-then-right",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& a) {\\n        \\n        int n = a.size();\\n        int i=1;\\n        \\n        int res = 0;\\n        while(i<n)\\n        {\\n            while(i<n && a[i]==a[i-1])\\n                i++;\\n            \\n            int up=0;\\n            while(i<n && a[i]>a[i-1]){\\n                up++;\\n                i++;\\n            }\\n            \\n            int down=0;\\n            while(i<n && a[i]<a[i-1])\\n            {\\n                down++;\\n                i++;    \\n            }\\n            \\n            if(down && up)\\n            {\\n                res = max(res,up+down+1);\\n            }\\n            \\n            \\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& a) {\\n        \\n        int n = a.size();\\n        int i=1;\\n        \\n        int res = 0;\\n        while(i<n)\\n        {\\n            while(i<n && a[i]==a[i-1])\\n                i++;\\n            \\n            int up=0;\\n            while(i<n && a[i]>a[i-1]){\\n                up++;\\n                i++;\\n            }\\n            \\n            int down=0;\\n            while(i<n && a[i]<a[i-1])\\n            {\\n                down++;\\n                i++;    \\n            }\\n            \\n            if(down && up)\\n            {\\n                res = max(res,up+down+1);\\n            }\\n            \\n            \\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549874,
                "title": "python-easy-to-understand-dp",
                "content": "```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        dp = [0] * len(arr)\\n        for i in range(1, len(arr)):\\n            if arr[i] > arr[i-1]:\\n                dp[i] = dp[i-1] + 1\\n        print(dp)\\n        dp2 = [0] * len(arr)\\n        for i in range(len(arr)-2, -1, -1):\\n            if arr[i] > arr[i+1]:\\n                dp2[i] = dp2[i+1] + 1\\n        print(dp2)\\n        res = 0\\n        for i in range(len(arr)):\\n            if dp[i] > 0 and dp2[i] > 0:\\n                res = max(res, dp[i] + dp2[i] + 1)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        dp = [0] * len(arr)\\n        for i in range(1, len(arr)):\\n            if arr[i] > arr[i-1]:\\n                dp[i] = dp[i-1] + 1\\n        print(dp)\\n        dp2 = [0] * len(arr)\\n        for i in range(len(arr)-2, -1, -1):\\n            if arr[i] > arr[i+1]:\\n                dp2[i] = dp2[i+1] + 1\\n        print(dp2)\\n        res = 0\\n        for i in range(len(arr)):\\n            if dp[i] > 0 and dp2[i] > 0:\\n                res = max(res, dp[i] + dp2[i] + 1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522458,
                "title": "c-easy-short-clean-code",
                "content": "![image](https://assets.leetcode.com/users/images/8b9f5a80-42ca-4be7-b3d2-568d3395eeb9_1662187875.807191.png)\\n\\n**T->O(n) &&& S->O(n)**\\n\\n***This question is the extension of longest Bitonic/Mountain subsequence. In that we compare with all the prevoius elements and store the max on dp[i] but since we want a consecutive Subsequence that we just have compare with the last element. Rest of the code is same as finding the longest mountain subsequence!***\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint longestMountain(vector<int>& arr) {\\n\\t\\t\\tint n=arr.size();\\n\\t\\t\\tvector<int> dp1(n,1),dp2(n,1),sum(n,0);\\n\\t\\t\\tfor(int i=1;i<n;i++){\\n\\t\\t\\t\\tif(arr[i]>arr[i-1] && 1+dp1[i-1]>dp1[i]) dp1[i]=1+dp1[i-1];\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=n-2;i>=0;i--){\\n\\t\\t\\t\\tif(arr[i]>arr[i+1] && 1+dp2[i+1]>dp2[i]) dp2[i]=1+dp2[i+1];\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tif(dp1[i]!=1 && dp2[i]!=1) sum[i]=dp1[i]+dp2[i];\\n\\t\\t\\t}  \\n\\t\\t\\tint ans=*max_element(sum.begin(),sum.end());\\n\\t\\t\\tif(ans) ans-=1;\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint longestMountain(vector<int>& arr) {\\n\\t\\t\\tint n=arr.size();\\n\\t\\t\\tvector<int> dp1(n,1),dp2(n,1),sum(n,0);\\n\\t\\t\\tfor(int i=1;i<n;i++){\\n\\t\\t\\t\\tif(arr[i]>arr[i-1] && 1+dp1[i-1]>dp1[i]) dp1[i]=1+dp1[i-1];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2509007,
                "title": "java-easy",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        // if (arr.length < 3) return 0;\\n\\n        int maxLength = 0, i = 0;\\n        boolean uphill = false, downhill = false;\\n\\n        while (i < arr.length - 1) {\\n            if (arr[i] < arr[i + 1]) {\\n                int start = i;\\n\\n                while (i < arr.length - 1 && arr[i] < arr[i + 1]) {\\n                    i++;\\n                    uphill = true;\\n                }\\n\\n                while (i < arr.length - 1 && arr[i] > arr[i + 1]) {\\n                    i++;\\n                    downhill = true;\\n                }\\n\\n                if (uphill && downhill) {\\n                    maxLength = Math.max(maxLength, i - start + 1);\\n                }\\n\\n                uphill = downhill = false;\\n\\t\\t\\t\\t\\n            } else {\\n                i++;\\n            }\\n        }\\n\\n        return maxLength;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        // if (arr.length < 3) return 0;\\n\\n        int maxLength = 0, i = 0;\\n        boolean uphill = false, downhill = false;\\n\\n        while (i < arr.length - 1) {\\n            if (arr[i] < arr[i + 1]) {\\n                int start = i;\\n\\n                while (i < arr.length - 1 && arr[i] < arr[i + 1]) {\\n                    i++;\\n                    uphill = true;\\n                }\\n\\n                while (i < arr.length - 1 && arr[i] > arr[i + 1]) {\\n                    i++;\\n                    downhill = true;\\n                }\\n\\n                if (uphill && downhill) {\\n                    maxLength = Math.max(maxLength, i - start + 1);\\n                }\\n\\n                uphill = downhill = false;\\n\\t\\t\\t\\t\\n            } else {\\n                i++;\\n            }\\n        }\\n\\n        return maxLength;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461948,
                "title": "python-2-pass-dp-solution",
                "content": "```\\ndp1 is the forward increasing subarry ending at index i (left of mountain)\\ndp2 is the backward increasing subarry ending at index i (right of mountain)\\nThe length of moutain as peak at index i is dp1[i]+dp2[i]-1\\n```\\n\\n```\\ndef longestMountain(self, nums: List[int]) -> int:\\n\\tdp1 = [1]+[0]*(len(nums)-1)\\n\\tfor i in range(1, len(nums)):\\n\\t\\tif nums[i-1]<nums[i]:\\n\\t\\t\\tdp1[i] = dp1[i-1]+1\\n\\t\\telse:\\n\\t\\t\\tdp1[i] = 1\\n\\tdp2 = [0]*(len(nums)-1)+[1]\\n\\tfor i in range(len(nums)-2, -1, -1):\\n\\t\\tif nums[i]>nums[i+1]:\\n\\t\\t\\tdp2[i] = dp2[i+1]+1\\n\\t\\telse:\\n\\t\\t\\tdp2[i] = 1\\n\\tans = max([dp1[i]+dp2[i]-1 for i in range(1, len(nums)-1) if dp1[i]>1 and dp2[i]>1] or [0]) \\n\\treturn ans if ans>=3 else 0\\n```",
                "solutionTags": [],
                "code": "```\\ndp1 is the forward increasing subarry ending at index i (left of mountain)\\ndp2 is the backward increasing subarry ending at index i (right of mountain)\\nThe length of moutain as peak at index i is dp1[i]+dp2[i]-1\\n```\n```\\ndef longestMountain(self, nums: List[int]) -> int:\\n\\tdp1 = [1]+[0]*(len(nums)-1)\\n\\tfor i in range(1, len(nums)):\\n\\t\\tif nums[i-1]<nums[i]:\\n\\t\\t\\tdp1[i] = dp1[i-1]+1\\n\\t\\telse:\\n\\t\\t\\tdp1[i] = 1\\n\\tdp2 = [0]*(len(nums)-1)+[1]\\n\\tfor i in range(len(nums)-2, -1, -1):\\n\\t\\tif nums[i]>nums[i+1]:\\n\\t\\t\\tdp2[i] = dp2[i+1]+1\\n\\t\\telse:\\n\\t\\t\\tdp2[i] = 1\\n\\tans = max([dp1[i]+dp2[i]-1 for i in range(1, len(nums)-1) if dp1[i]>1 and dp2[i]>1] or [0]) \\n\\treturn ans if ans>=3 else 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2452384,
                "title": "c-highly-commented-code-o-n-time-and-o-1-space",
                "content": "For complexity analysis and other stuff, go [here](https://garmadon.notion.site/Longest-Bitonic-Subarray-76cd76ecd7464f4da5c1d61382d8c1e8).\\n\\n```\\n//works successfully on leetcode!\\n\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n\\n    //constraint given in the question\\n    if(arr.size() < 3)\\n        return 0;\\n        \\n    //start travelling from the beginning of the array\\n    int traveller = 0;\\n    int mountainStart, mountainPeak, mountainLength=0; //answer will be 0 when no mountain exists\\n\\n    //travel till the end of the array\\n    while(traveller < arr.size())\\n    {\\n        //set the starting point of the current mountain \\n        mountainStart = traveller;\\n\\n        //climb the mountain (if an ascending slope exists)\\n        while(traveller + 1 < arr.size() and arr.at(traveller) < arr.at(traveller+1))\\n        {\\n            traveller++;\\n        }\\n\\n        //if there was a descending slope, the traveller would be standing at the same place\\n        //hence start travelling from the next step\\n        if(traveller == mountainStart)\\n        {\\n            traveller++;\\n            continue;\\n        }\\n\\n        //traveller is now standing on the mountain peak\\n        mountainPeak = traveller;\\n\\n        //climb down the mountain (if an descending slope exists)\\n        while(traveller + 1 < arr.size() and arr.at(traveller) > arr.at(traveller+1))\\n        {\\n            traveller++;\\n        }\\n\\n        //if it\\'s a plain surface the traveller must not have moved\\n        //so take one step ahead and start finding the mountain again\\n        if(traveller == mountainPeak)\\n        {\\n            traveller++;\\n            continue;\\n        }\\n\\n        //Find the longest mountain throughout the trip\\n        mountainLength = max(mountainLength, traveller - mountainStart + 1);\\n    }\\n\\n    return mountainLength;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n//works successfully on leetcode!\\n\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n\\n    //constraint given in the question\\n    if(arr.size() < 3)\\n        return 0;\\n        \\n    //start travelling from the beginning of the array\\n    int traveller = 0;\\n    int mountainStart, mountainPeak, mountainLength=0; //answer will be 0 when no mountain exists\\n\\n    //travel till the end of the array\\n    while(traveller < arr.size())\\n    {\\n        //set the starting point of the current mountain \\n        mountainStart = traveller;\\n\\n        //climb the mountain (if an ascending slope exists)\\n        while(traveller + 1 < arr.size() and arr.at(traveller) < arr.at(traveller+1))\\n        {\\n            traveller++;\\n        }\\n\\n        //if there was a descending slope, the traveller would be standing at the same place\\n        //hence start travelling from the next step\\n        if(traveller == mountainStart)\\n        {\\n            traveller++;\\n            continue;\\n        }\\n\\n        //traveller is now standing on the mountain peak\\n        mountainPeak = traveller;\\n\\n        //climb down the mountain (if an descending slope exists)\\n        while(traveller + 1 < arr.size() and arr.at(traveller) > arr.at(traveller+1))\\n        {\\n            traveller++;\\n        }\\n\\n        //if it\\'s a plain surface the traveller must not have moved\\n        //so take one step ahead and start finding the mountain again\\n        if(traveller == mountainPeak)\\n        {\\n            traveller++;\\n            continue;\\n        }\\n\\n        //Find the longest mountain throughout the trip\\n        mountainLength = max(mountainLength, traveller - mountainStart + 1);\\n    }\\n\\n    return mountainLength;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430580,
                "title": "one-pass-o-1-space-jugad",
                "content": "```\\nint longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        if(n<3) return 0;\\n        int longest = 0;\\n        bool check = false;\\n        int len = 0;\\n        if(arr[1]>arr[0])   check = true;\\n        for(int i=0;i<n;i++) {\\n            if(i!=0&&arr[i]==arr[i-1])   {\\n                check = false;\\n                len = 0;\\n            }\\n            if(i!=0&&i!=n-1&&arr[i-1]>=arr[i]&&arr[i+1]>=arr[i]) {\\n                len++;\\n                longest = max(longest,len);\\n                len = 1;\\n                check = true;\\n            }\\n            else if(check)  len++;\\n            \\n        }\\n        if(arr[n-1]<arr[n-2])   longest = max(longest,len);\\n        return longest>=3?longest:0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        if(n<3) return 0;\\n        int longest = 0;\\n        bool check = false;\\n        int len = 0;\\n        if(arr[1]>arr[0])   check = true;\\n        for(int i=0;i<n;i++) {\\n            if(i!=0&&arr[i]==arr[i-1])   {\\n                check = false;\\n                len = 0;\\n            }\\n            if(i!=0&&i!=n-1&&arr[i-1]>=arr[i]&&arr[i+1]>=arr[i]) {\\n                len++;\\n                longest = max(longest,len);\\n                len = 1;\\n                check = true;\\n            }\\n            else if(check)  len++;\\n            \\n        }\\n        if(arr[n-1]<arr[n-2])   longest = max(longest,len);\\n        return longest>=3?longest:0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2421729,
                "title": "java-one-pass-tc-o-n-sc-o-1-2-ms-faster-than-100-00",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        \\n        int maxLen = 0, count = 1; //coz we included 1st element\\n        boolean inc = false, dsc = false; //maintain if we first increased and then decreased\\n        \\n        int i = 1;\\n        \\n        while (i < arr.length) {\\n            \\n            inc = false; dsc = false;\\n            count = 1;\\n \\n            //increasing\\n            while (i < arr.length && arr[i] > arr[i-1]) {\\n                count++;\\n                i++;\\n                inc = true;\\n            }\\n            \\n            //decreasing, we will calculate only when we have increased flg is true\\n            while (inc && i < arr.length && arr[i] < arr[i-1]) {\\n                count++;\\n                i++;\\n                dsc = true;\\n            }\\n            \\n            //if values increased and decreased\\n            if (inc && dsc) {\\n                maxLen = Math.max(maxLen, count);\\n                count= 1;\\n                \\n            }else i++;\\n            \\n        }\\n        return maxLen>=3 ? maxLen : 0;     \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        \\n        int maxLen = 0, count = 1; //coz we included 1st element\\n        boolean inc = false, dsc = false; //maintain if we first increased and then decreased\\n        \\n        int i = 1;\\n        \\n        while (i < arr.length) {\\n            \\n            inc = false; dsc = false;\\n            count = 1;\\n \\n            //increasing\\n            while (i < arr.length && arr[i] > arr[i-1]) {\\n                count++;\\n                i++;\\n                inc = true;\\n            }\\n            \\n            //decreasing, we will calculate only when we have increased flg is true\\n            while (inc && i < arr.length && arr[i] < arr[i-1]) {\\n                count++;\\n                i++;\\n                dsc = true;\\n            }\\n            \\n            //if values increased and decreased\\n            if (inc && dsc) {\\n                maxLen = Math.max(maxLen, count);\\n                count= 1;\\n                \\n            }else i++;\\n            \\n        }\\n        return maxLen>=3 ? maxLen : 0;     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323939,
                "title": "c-easy-to-understand",
                "content": "```\\nint longestMountain(vector<int>& arr) {\\n       \\n        int n = arr.size();\\n        int i=1, lgst=0;\\n        \\n        while(i<n-1){\\n            \\n            if(arr[i] > arr[i-1] and arr[i] > arr[i+1]){ //peak found\\n                \\n                int j = i, cnt = 1;\\n                \\n                while(j>0 and arr[j-1] < arr[j]) cnt++, j--; //ele on left of peak\\n                \\n                while(i<n-1 and arr[i] > arr[i+1]) i++, cnt++; //ele on right of peak\\n                \\n                lgst = max(lgst, cnt);\\n            }\\n            else \\n                i++;      \\n        }\\n        \\n        return lgst; \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint longestMountain(vector<int>& arr) {\\n       \\n        int n = arr.size();\\n        int i=1, lgst=0;\\n        \\n        while(i<n-1){\\n            \\n            if(arr[i] > arr[i-1] and arr[i] > arr[i+1]){ //peak found\\n                \\n                int j = i, cnt = 1;\\n                \\n                while(j>0 and arr[j-1] < arr[j]) cnt++, j--; //ele on left of peak\\n                \\n                while(i<n-1 and arr[i] > arr[i+1]) i++, cnt++; //ele on right of peak\\n                \\n                lgst = max(lgst, cnt);\\n            }\\n            else \\n                i++;      \\n        }\\n        \\n        return lgst; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2309853,
                "title": "c-solution-dp",
                "content": "```\\n   int longestMountain(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>left(n,1),right(n,1);\\n        for(int i=1;i<n;i++){\\n            if(arr[i-1]<arr[i]){\\n                left[i]=left[i-1]+1;\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(arr[i]>arr[i+1]){\\n                right[i]=right[i+1]+1;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(left[i]>1 && right[i]>1){\\n                ans = max(ans,right[i]+left[i]-1);\\n            }\\n        }\\n    }\\n```\\nFor More LeetCode Problem\\'s Solution(Topic-Wise)Please Check Out;\\nhttps://github.com/Ariyanlaskar/DSA/tree/master/LeetCode",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n   int longestMountain(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>left(n,1),right(n,1);\\n        for(int i=1;i<n;i++){\\n            if(arr[i-1]<arr[i]){\\n                left[i]=left[i-1]+1;\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(arr[i]>arr[i+1]){\\n                right[i]=right[i+1]+1;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(left[i]>1 && right[i]>1){\\n                ans = max(ans,right[i]+left[i]-1);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2307197,
                "title": "java-3-ms-easy-to-understand-code",
                "content": "class Solution {\\n    public int longestMountain(int[] A) {\\n        int result = 0;\\n        if(A==null || A.length<3) return result;\\n        int i = 1;\\n        int start = 0;\\n        boolean upHill = false;\\n        boolean downHill = false;\\n        while(i<A.length){\\n            start = i-1;\\n            //go uphill\\n            while(i<A.length && A[i-1]<A[i]){\\n                upHill=true;\\n                i++;\\n            }\\n            //go downhill\\n            while(i<A.length && A[i-1]>A[i]){\\n                downHill=true;\\n                i++;\\n            }\\n\\t\\t\\t\\n            //if found uphill and downhill then there was mountain \\n            if(upHill && downHill){\\n                //only update when mountain size was equal or greater than 3\\n                if(i-start>=3)result = Math.max(i-start,result);\\n            }else{\\n                //if there was no mountain, then ensuring it\\'s not plain surface\\n                while(i<A.length && A[i-1]==A[i])i++;\\n            }\\n            \\n            //update uphill and downhill for next iteration.\\n            upHill = false;\\n            downHill = false;\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int longestMountain(int[] A) {\\n        int result = 0;\\n        if(A==null || A.length<3) return result;\\n        int i = 1;\\n        int start = 0;\\n        boolean upHill = false;\\n        boolean downHill = false;\\n        while(i<A.length){\\n            start = i-1;\\n            //go uphill\\n            while(i<A.length && A[i-1]<A[i]){\\n                upHill=true;\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2289642,
                "title": "simple-c-code-o-n",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> LISFront(n,1);\\n        vector<int> LISBack(n,1);\\n        int i = 1, j = n-2;\\n        for(int i = 1; i < n; i++)\\n        {\\n            int snd = 1;\\n            if(nums[i-1]< nums[i])\\n            {\\n                snd = max(snd, LISFront[i-1]+1);\\n            }\\n            LISFront[i] = snd;\\n            snd = 1;\\n            if(nums[j+1] < nums[j])\\n            {\\n                snd = max(snd, LISBack[j+1]+1);\\n            }\\n            LISBack[j] = snd;\\n            j--;\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(LISBack[i] == 1 || LISFront[i] == 1) continue;\\n            ans = max(ans, LISBack[i]+LISFront[i]-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> LISFront(n,1);\\n        vector<int> LISBack(n,1);\\n        int i = 1, j = n-2;\\n        for(int i = 1; i < n; i++)\\n        {\\n            int snd = 1;\\n            if(nums[i-1]< nums[i])\\n            {\\n                snd = max(snd, LISFront[i-1]+1);\\n            }\\n            LISFront[i] = snd;\\n            snd = 1;\\n            if(nums[j+1] < nums[j])\\n            {\\n                snd = max(snd, LISBack[j+1]+1);\\n            }\\n            LISBack[j] = snd;\\n            j--;\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(LISBack[i] == 1 || LISFront[i] == 1) continue;\\n            ans = max(ans, LISBack[i]+LISFront[i]-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2247437,
                "title": "c-simple-solution-time-o-n-space-o-1-beats-99",
                "content": "```\\n    int longestMountain(vector<int> &arr)\\n    {\\n        int n = arr.size();\\n        int ans = 0, cnt = 0;\\n        for (int l = 1; l < n - 1; l++)\\n        {\\n            if (arr[l] > arr[l - 1] && arr[l] > arr[l + 1])\\n            {\\n\\n                int j = l - 1, k = l + 1;\\n                cnt = 3;\\n                while (j - 1 >= 0 && arr[j] > arr[j - 1])\\n                    j--, cnt++;\\n                while (k + 1 < n && arr[k] > arr[k + 1])\\n                    k++, cnt++;\\n                ans = max(ans, cnt);\\n                l=k-1;\\n            }\\n          \\n        }\\n\\n        ans = max(ans, cnt);\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n    int longestMountain(vector<int> &arr)\\n    {\\n        int n = arr.size();\\n        int ans = 0, cnt = 0;\\n        for (int l = 1; l < n - 1; l++)\\n        {\\n            if (arr[l] > arr[l - 1] && arr[l] > arr[l + 1])\\n            {\\n\\n                int j = l - 1, k = l + 1;\\n                cnt = 3;\\n                while (j - 1 >= 0 && arr[j] > arr[j - 1])\\n                    j--, cnt++;\\n                while (k + 1 < n && arr[k] > arr[k + 1])\\n                    k++, cnt++;\\n                ans = max(ans, cnt);\\n                l=k-1;\\n            }\\n          \\n        }\\n\\n        ans = max(ans, cnt);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2246185,
                "title": "c-simple-colution-prefix-suffic-technique",
                "content": "```\\n int longestMountain(vector<int>& arr) {\\n        \\n        int i,j,maxi=0,n=arr.size();\\n        int inc[n],dec[n];\\n        inc[0] = 0;\\n        dec[n-1] = 0;\\n        for(i=1;i<n;i++)\\n        {\\n            if(arr[i]>arr[i-1])\\n            {\\n                inc[i]  = inc[i-1] + 1;\\n            }\\n            else{\\n                inc[i]  = 0;\\n            }\\n        }\\n        for(i=n-2;i>=0;i--)\\n        {\\n            if(arr[i]>arr[i+1])\\n            {\\n                dec[i] = dec[i+1] + 1;\\n            }\\n            else{\\n                dec[i] = 0;\\n            }\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            if(inc[i]!=0 && dec[i]!=0)\\n            {\\n                maxi = max(maxi,inc[i] + dec[i]+1);\\n            }\\n           \\n        }\\n        if(maxi<3)\\n        {\\n            return 0;\\n        }\\n        else{\\n            \\n            return maxi;\\n        }\\n",
                "solutionTags": [
                    "Suffix Array"
                ],
                "code": "```\\n int longestMountain(vector<int>& arr) {\\n        \\n        int i,j,maxi=0,n=arr.size();\\n        int inc[n],dec[n];\\n        inc[0] = 0;\\n        dec[n-1] = 0;\\n        for(i=1;i<n;i++)\\n        {\\n            if(arr[i]>arr[i-1])\\n            {\\n                inc[i]  = inc[i-1] + 1;\\n            }\\n            else{\\n                inc[i]  = 0;\\n            }\\n        }\\n        for(i=n-2;i>=0;i--)\\n        {\\n            if(arr[i]>arr[i+1])\\n            {\\n                dec[i] = dec[i+1] + 1;\\n            }\\n            else{\\n                dec[i] = 0;\\n            }\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            if(inc[i]!=0 && dec[i]!=0)\\n            {\\n                maxi = max(maxi,inc[i] + dec[i]+1);\\n            }\\n           \\n        }\\n        if(maxi<3)\\n        {\\n            return 0;\\n        }\\n        else{\\n            \\n            return maxi;\\n        }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2069011,
                "title": "easy-c-commented-o-n-solution-in-one-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        // ic 1 means we are looking for increasing sequence ic 0 means we are looking for decreasing sequence\\n        \\n// intially we want increasing sequence starting form i=0\\n        int ic=1,l=1,a=0;          \\n        for(int i=1;i<arr.size();i++){\\n            if(arr[i]>arr[i-1]){   // numbers in increasing sequence\\n                if(ic==1)l++;   // if we were looking for incresing then we found another number to add to our answer\\n                else{\\n                    \\n/*\\n\\n\\n         /\\\\\\n        /  \\\\  /\\n            \\\\/\\n             this point here marks the end of mountain\\n             what this means is that we were hoping this number to be less than the previous  one\\n\\t\\t\\t but we found it greater than the prevoius one. \\n\\t\\t\\t this marks the end of our  current mountain and start of new mountain\\n*/\\n                  a=max(a,l); \\n                    l=2;\\n                    ic=1;\\n                }\\n            }else if(arr[i]<arr[i-1]){\\n                if(ic==0)l++,a=max(a,l);\\n                else{\\n/*\\n\\n\\n          /\\\\\\n         /  this point here marks the peak of the mountain.\\n            we wanted to continue going up hill but instead we found a slope.\\n            this makes this a mountain we check if this suitable( max ) answer and then we continue hoping to go downhill.\\n            \\n            \\\\                                               /\\\\\\n              this is not a peak                           this is a peak\\n                            we need atleast 3 numbers including current one \\n*/     \\n                    \\n                    \\n                    \\n                    if(l>1)l++,ic=0,a=max(a,l);\\n                    else l=1,ic=1;\\n                     \\n                }\\n            }else{\\n                l=1;\\n                ic=1;\\n            }\\n            \\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        // ic 1 means we are looking for increasing sequence ic 0 means we are looking for decreasing sequence\\n        \\n// intially we want increasing sequence starting form i=0\\n        int ic=1,l=1,a=0;          \\n        for(int i=1;i<arr.size();i++){\\n            if(arr[i]>arr[i-1]){   // numbers in increasing sequence\\n                if(ic==1)l++;   // if we were looking for incresing then we found another number to add to our answer\\n                else{\\n                    \\n/*\\n\\n\\n         /\\\\\\n        /  \\\\  /\\n            \\\\/\\n             this point here marks the end of mountain\\n             what this means is that we were hoping this number to be less than the previous  one\\n\\t\\t\\t but we found it greater than the prevoius one. \\n\\t\\t\\t this marks the end of our  current mountain and start of new mountain\\n*/\\n                  a=max(a,l); \\n                    l=2;\\n                    ic=1;\\n                }\\n            }else if(arr[i]<arr[i-1]){\\n                if(ic==0)l++,a=max(a,l);\\n                else{\\n/*\\n\\n\\n          /\\\\\\n         /  this point here marks the peak of the mountain.\\n            we wanted to continue going up hill but instead we found a slope.\\n            this makes this a mountain we check if this suitable( max ) answer and then we continue hoping to go downhill.\\n            \\n            \\\\                                               /\\\\\\n              this is not a peak                           this is a peak\\n                            we need atleast 3 numbers including current one \\n*/     \\n                    \\n                    \\n                    \\n                    if(l>1)l++,ic=0,a=max(a,l);\\n                    else l=1,ic=1;\\n                     \\n                }\\n            }else{\\n                l=1;\\n                ic=1;\\n            }\\n            \\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007291,
                "title": "preprocessing-left-and-right-monotonicity-simple",
                "content": "```\\nint longestMountain(vector<int>& arr) {\\n    int n = arr.size();\\n    vector<int>left_inc(n, 0);\\n    vector<int>right_inc(n, 0);\\n    int ans = INT_MIN;\\n    \\n    for(int i=1;i<n;i++)\\n        if(arr[i] > arr[i-1])\\n            left_inc[i] = 1 + left_inc[i-1];\\n    \\n    for(int i=(n-2);i>=0;i--)\\n        if(arr[i] > arr[i+1])\\n            right_inc[i] = 1 + right_inc[i+1];        \\n    \\n    for(int i=0;i<n;i++)\\n        if(left_inc[i]>0 && right_inc[i]>0)\\n            ans = max(ans, (left_inc[i]+right_inc[i]));\\n    \\n    if(ans!=INT_MIN)\\n        return ans+1;\\n    else\\n        return 0;\\n    \\n}",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint longestMountain(vector<int>& arr) {\\n    int n = arr.size();\\n    vector<int>left_inc(n, 0);\\n    vector<int>right_inc(n, 0);\\n    int ans = INT_MIN;\\n    \\n    for(int i=1;i<n;i++)\\n        if(arr[i] > arr[i-1])\\n            left_inc[i] = 1 + left_inc[i-1];\\n    \\n    for(int i=(n-2);i>=0;i--)\\n        if(arr[i] > arr[i+1])\\n            right_inc[i] = 1 + right_inc[i+1];        \\n    \\n    for(int i=0;i<n;i++)\\n        if(left_inc[i]>0 && right_inc[i]>0)\\n            ans = max(ans, (left_inc[i]+right_inc[i]));\\n    \\n    if(ans!=INT_MIN)\\n        return ans+1;\\n    else\\n        return 0;\\n    \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1971664,
                "title": "c-very-easy-simple-solution",
                "content": "\\tpublic:\\n\\t\\tint longestMountain(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        vector<int>left_inc(n, 0);\\n        vector<int>right_inc(n, 0);\\n        int ans = INT_MIN;\\n        \\n        for(int i=1;i<n;i++)\\n            if(arr[i] > arr[i-1])\\n                left_inc[i] = 1 + left_inc[i-1];\\n        \\n        for(int i=(n-2);i>=0;i--)\\n            if(arr[i] > arr[i+1])\\n                right_inc[i] = 1 + right_inc[i+1];\\n        \\n        for(int i=0;i<n;i++)\\n            if(left_inc[i]>0 && right_inc[i]>0)\\n                ans = max(ans, (left_inc[i]+right_inc[i]));\\n        \\n        if(ans!=INT_MIN)\\n            return ans+1;\\n        else\\n            return 0;\\n        \\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tpublic:\\n\\t\\tint longestMountain(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        vector<int>left_inc(n, 0);\\n        vector<int>right_inc(n, 0);\\n        int ans = INT_MIN;\\n        \\n        for(int i=1;i<n;i++)\\n            if(arr[i] > arr[i-1])\\n                left_inc[i] = 1 + left_inc[i-1];\\n        \\n        for(int i=(n-2);i>=0;i--)\\n            if(arr[i] > arr[i+1])\\n                right_inc[i] = 1 + right_inc[i+1];\\n        \\n        for(int i=0;i<n;i++)\\n            if(left_inc[i]>0 && right_inc[i]>0)\\n                ans = max(ans, (left_inc[i]+right_inc[i]));\\n        \\n        if(ans!=INT_MIN)\\n            return ans+1;\\n        else\\n            return 0;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1956860,
                "title": "java-1-pass-o-1-space-easy-to-understand",
                "content": "We will look for the peak and will expand to both sides from there till we reach bottom of the mountain. Once a mountain has been found, look for the peak of the next moutain and expand from there and so on.\\n\\n```\\n public int longestMountain(int[] arr) {\\n        int longest = 0; // longest Mountain\\n        for (int i = 1; i < arr.length - 1; ) {\\n            if (arr[i] > arr[i - 1] && arr[i] > arr[i + 1]) { // peak of the current mountain starts from here. Will expand from here to both side just like HIMALAYAS\\n                int k = i - 1;\\n                int j = i + 1;\\n                while (k > 0 && arr[k] > arr[k - 1]) {\\n                    k--;\\n                }\\n                // reached left bottom of the mountain\\n                while (j < arr.length - 1 && arr[j] > arr[j + 1]) {\\n                    j++;\\n                }\\n                // reached right bottom of the mountain\\n                longest = Math.max(longest, j - k + 1); // compare current mountain length with the longest\\n                i = j + 1;  // look for next moutain peak from two index after the right bottom of the current mountain\\n            } else\\n                i++;\\n        }\\n        return longest;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int longestMountain(int[] arr) {\\n        int longest = 0; // longest Mountain\\n        for (int i = 1; i < arr.length - 1; ) {\\n            if (arr[i] > arr[i - 1] && arr[i] > arr[i + 1]) { // peak of the current mountain starts from here. Will expand from here to both side just like HIMALAYAS\\n                int k = i - 1;\\n                int j = i + 1;\\n                while (k > 0 && arr[k] > arr[k - 1]) {\\n                    k--;\\n                }\\n                // reached left bottom of the mountain\\n                while (j < arr.length - 1 && arr[j] > arr[j + 1]) {\\n                    j++;\\n                }\\n                // reached right bottom of the mountain\\n                longest = Math.max(longest, j - k + 1); // compare current mountain length with the longest\\n                i = j + 1;  // look for next moutain peak from two index after the right bottom of the current mountain\\n            } else\\n                i++;\\n        }\\n        return longest;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1903129,
                "title": "longest-mountain-in-array",
                "content": "```\\n**# CHECK FOR THE ELEMENT WHICH IS GREATER THAN FROM IT\\'S RIGHT AND LEFT BOTH. (NUMS[I-1]<NUMS[I] && NUMS[I]>NUMS[I+1])\\n# IF THIS CONDITION IS CORRECT CHECK ALL ITS LEFT TILL THEY FOLLOW DECREASING ORDER \\n# SIMILIARLY CHECK ALL IT\\'S RIGHT TILL THEY FOLLOW DECREASING ORDER AS WELL.\\n# AFTER GETTING THE INDEX\\'S TILL THEY ARE FOLLOWING DECREASING ORDER FROM LEFT AND RIGHT\\n# (CONSIDERING BOUNDRY SHOULD NOT VOILETED) =>FIND MAX IF ANY MOUNTAIN HAS BEEN FOUND BEFORE AND NOW. ANS=MAX(ANS,RIGHT-LEFT+1)\\n# THANK YOU.\\n# PLEASE UPVOTE IF YOU FIND IT HELPFUL**\\n```\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        int res=0;\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(nums[i-1]<nums[i] && nums[i]>nums[i+1])\\n            {\\n                int j=i;\\n                int k=i;\\n                while(j>0)\\n                {\\n                    if(nums[j]>nums[j-1])\\n                        j--;\\n                    else\\n                        break;\\n                }\\n                while(k<n-1)\\n                {\\n                    if(nums[k]>nums[k+1])\\n                        k++;\\n                    else\\n                        break;\\n                }\\n                res=max(res,k-j+1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n**# CHECK FOR THE ELEMENT WHICH IS GREATER THAN FROM IT\\'S RIGHT AND LEFT BOTH. (NUMS[I-1]<NUMS[I] && NUMS[I]>NUMS[I+1])\\n# IF THIS CONDITION IS CORRECT CHECK ALL ITS LEFT TILL THEY FOLLOW DECREASING ORDER \\n# SIMILIARLY CHECK ALL IT\\'S RIGHT TILL THEY FOLLOW DECREASING ORDER AS WELL.\\n# AFTER GETTING THE INDEX\\'S TILL THEY ARE FOLLOWING DECREASING ORDER FROM LEFT AND RIGHT\\n# (CONSIDERING BOUNDRY SHOULD NOT VOILETED) =>FIND MAX IF ANY MOUNTAIN HAS BEEN FOUND BEFORE AND NOW. ANS=MAX(ANS,RIGHT-LEFT+1)\\n# THANK YOU.\\n# PLEASE UPVOTE IF YOU FIND IT HELPFUL**\\n```\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        int res=0;\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(nums[i-1]<nums[i] && nums[i]>nums[i+1])\\n            {\\n                int j=i;\\n                int k=i;\\n                while(j>0)\\n                {\\n                    if(nums[j]>nums[j-1])\\n                        j--;\\n                    else\\n                        break;\\n                }\\n                while(k<n-1)\\n                {\\n                    if(nums[k]>nums[k+1])\\n                        k++;\\n                    else\\n                        break;\\n                }\\n                res=max(res,k-j+1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1819288,
                "title": "c-easy-implementation",
                "content": "```\\n int longestMountain(vector<int>& arr) \\n    {\\n        int n=arr.size();\\n        int res=0;\\n        \\n        for(int i=1; i<n-1; i++)\\n        {\\n            if(arr[i]>arr[i-1]&&arr[i]>arr[i+1])\\n            {\\n                int start=i;\\n                int end=i;\\n                \\n                while(start>0&&arr[start]>arr[start-1])\\n                    start--;\\n                while(end<n-1&&arr[end]>arr[end+1])\\n                    end++;\\n                res=max(res, end-start+1);\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n int longestMountain(vector<int>& arr) \\n    {\\n        int n=arr.size();\\n        int res=0;\\n        \\n        for(int i=1; i<n-1; i++)\\n        {\\n            if(arr[i]>arr[i-1]&&arr[i]>arr[i+1])\\n            {\\n                int start=i;\\n                int end=i;\\n                \\n                while(start>0&&arr[start]>arr[start-1])\\n                    start--;\\n                while(end<n-1&&arr[end]>arr[end+1])\\n                    end++;\\n                res=max(res, end-start+1);\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1816679,
                "title": "java-two-solutions-with-extra-space-using-array-and-without-extra-space-using-two-pointers",
                "content": "```\\n// brute force\\n// from each index find the longest decreasing sequence starting from that index toward left , and find the longest  continuous  decreasing sequence starting from that index to the right, TC O(n) , space complexity O(n)\\n//Runtime: 3 ms, faster than 73.85% of Java online submissions for Longest Mountain in Array.\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        if(arr.length < 3){\\n            return 0;\\n        }\\n        int n = arr.length;\\n        int[] decr = new int[n];\\n        // no decreasing number from the 0-index\\n        decr[0] = 0;\\n        int count = 0;\\n        for(int i=1; i< n ; i++){\\n            if(arr[i] <= arr[i-1]){\\n\\t\\t\\t  // this mean there can not be  continuous decreasing sequence  starting from this i-th index\\n                count =0;\\n                decr[i] = 0;\\n                continue;\\n            }\\n             count++;\\n            decr[i] = count;\\n        }\\n        \\n        count = 0;\\n        int res = Integer.MIN_VALUE;\\n        for(int i=n-2; i>=0  ; i--){\\n            if(arr[i] <= arr[i+1]){\\n\\t\\t\\t//  this mean there can not be  continuous increasing sequence  starting from this i-th index\\n                count =0;\\n                continue;\\n            }\\n            count++;\\n            if(decr[i] >0){\\n\\t\\t\\t// update res only if there was at least one decreasing number , add 1 to cover the number at i-th index it self\\n              res = Math.max(res, count + decr[i]+1); \\n            }\\n        \\n        }\\n        \\n        return Math.max(res, 0);\\n    }\\n}\\n```\\n\\n// solution without extra space\\n// the idea is to find all the continuous increasing sequence from the i-th index  untill we reach the peak element for the sequence, after we found the peak element , we just need to count all the continous decreasing sequence starting from the peak element, we just need to be sure that at least we have 2 elements, TC O(n) since each element will be visited at most two times, and SC O(1)\\n```\\n\\n//Runtime: 2 ms, faster than 94.44% of Java online submissions for Longest Mountain in Array.\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        if(arr.length < 3){\\n            return 0;\\n        }\\n        int res = 0,  left = 0;\\n        int i =0;\\n        while( i< arr.length){\\n            int incr = 0;\\n            while( i + 1 < arr.length && arr[i] < arr[i+1]){\\n                incr++;\\n                i++;\\n            }\\n            if(incr == 0){\\n                i++;\\n                continue;\\n            }\\n            int decr = 0;\\n            while( i + 1 < arr.length && arr[i] > arr[i+1]){\\n                decr++;\\n                i++;\\n            }\\n            if(decr == 0){\\n                continue;\\n            }\\n\\n            res = Math.max(res, incr + decr + 1);\\n\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n// brute force\\n// from each index find the longest decreasing sequence starting from that index toward left , and find the longest  continuous  decreasing sequence starting from that index to the right, TC O(n) , space complexity O(n)\\n//Runtime: 3 ms, faster than 73.85% of Java online submissions for Longest Mountain in Array.\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        if(arr.length < 3){\\n            return 0;\\n        }\\n        int n = arr.length;\\n        int[] decr = new int[n];\\n        // no decreasing number from the 0-index\\n        decr[0] = 0;\\n        int count = 0;\\n        for(int i=1; i< n ; i++){\\n            if(arr[i] <= arr[i-1]){\\n\\t\\t\\t  // this mean there can not be  continuous decreasing sequence  starting from this i-th index\\n                count =0;\\n                decr[i] = 0;\\n                continue;\\n            }\\n             count++;\\n            decr[i] = count;\\n        }\\n        \\n        count = 0;\\n        int res = Integer.MIN_VALUE;\\n        for(int i=n-2; i>=0  ; i--){\\n            if(arr[i] <= arr[i+1]){\\n\\t\\t\\t//  this mean there can not be  continuous increasing sequence  starting from this i-th index\\n                count =0;\\n                continue;\\n            }\\n            count++;\\n            if(decr[i] >0){\\n\\t\\t\\t// update res only if there was at least one decreasing number , add 1 to cover the number at i-th index it self\\n              res = Math.max(res, count + decr[i]+1); \\n            }\\n        \\n        }\\n        \\n        return Math.max(res, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1792146,
                "title": "easy-beginners-friendly-approach-java",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] a) {\\n        int largest = 0;\\n        int n=a.length;\\n        for(int i=1;i<n-1;){\\n            //for founding the peaks\\n            if(a[i]>a[i-1] && a[i]>a[i+1]){\\n                int count =1;\\n                int j=i;\\n                //for count in the backwards\\n                while(j>=1 && a[j]>a[j-1]){\\n                    j--;\\n                    count++;\\n                }\\n                 //for count in the forwards\\n                while(i<n-1 && a[i]>a[i+1]){\\n                    i++;\\n                    count++;\\n                }\\n                //checking if it is the largest peak;\\n                largest = Math.max(largest,count);\\n            }\\n            else\\n                i++;\\n        }\\n        return largest;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] a) {\\n        int largest = 0;\\n        int n=a.length;\\n        for(int i=1;i<n-1;){\\n            //for founding the peaks\\n            if(a[i]>a[i-1] && a[i]>a[i+1]){\\n                int count =1;\\n                int j=i;\\n                //for count in the backwards\\n                while(j>=1 && a[j]>a[j-1]){\\n                    j--;\\n                    count++;\\n                }\\n                 //for count in the forwards\\n                while(i<n-1 && a[i]>a[i+1]){\\n                    i++;\\n                    count++;\\n                }\\n                //checking if it is the largest peak;\\n                largest = Math.max(largest,count);\\n            }\\n            else\\n                i++;\\n        }\\n        return largest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785329,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        int largest=0;\\n        for(int i=1;i<=n-2;){\\n            if(arr[i]>arr[i-1] and arr[i]>arr[i+1]){\\n                \\n                int cnt=1;\\n                int j=i;\\n                \\n                //backward count\\n                while(j>=1 and arr[j]>arr[j-1]){\\n                    cnt++;\\n                    j--;\\n                }\\n                \\n                //forward direction\\n                \\n                while(i<=n-2 and arr[i]>arr[i+1]){\\n                    cnt++;\\n                    i++;\\n                }\\n                \\n                 largest=max(largest,cnt);\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return largest;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        int largest=0;\\n        for(int i=1;i<=n-2;){\\n            if(arr[i]>arr[i-1] and arr[i]>arr[i+1]){\\n                \\n                int cnt=1;\\n                int j=i;\\n                \\n                //backward count\\n                while(j>=1 and arr[j]>arr[j-1]){\\n                    cnt++;\\n                    j--;\\n                }\\n                \\n                //forward direction\\n                \\n                while(i<=n-2 and arr[i]>arr[i+1]){\\n                    cnt++;\\n                    i++;\\n                }\\n                \\n                 largest=max(largest,cnt);\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return largest;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1745280,
                "title": "c-o-n-100-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        int i = 0, j = 0, ans = 0, x = 1;\\n        while(j<n)\\n        {\\n            if(j<n-1 && arr[j]<arr[j+1])\\n            {\\n               while(j<n-1 && arr[j] < arr[j+1])\\n               {\\n                    x++;\\n                    j++;\\n               }\\n                int y = x;\\n               while(j<n-1 && arr[j] > arr[j+1])\\n               {\\n                   x++;\\n                   j++;\\n               }\\n                if(y == x)\\n                    x = 0;\\n            }\\n            else\\n                 j++;\\n           ans = max(ans, x);\\n           x = 1;\\n        }\\n        return ans == 1?0:ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        int i = 0, j = 0, ans = 0, x = 1;\\n        while(j<n)\\n        {\\n            if(j<n-1 && arr[j]<arr[j+1])\\n            {\\n               while(j<n-1 && arr[j] < arr[j+1])\\n               {\\n                    x++;\\n                    j++;\\n               }\\n                int y = x;\\n               while(j<n-1 && arr[j] > arr[j+1])\\n               {\\n                   x++;\\n                   j++;\\n               }\\n                if(y == x)\\n                    x = 0;\\n            }\\n            else\\n                 j++;\\n           ans = max(ans, x);\\n           x = 1;\\n        }\\n        return ans == 1?0:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1727552,
                "title": "simple-java-solution-100-faster",
                "content": "**Upvote if you Got It** \\uD83D\\uDE42 \\nclass Solution {\\n\\n    public int longestMountain(int[] arr) {\\n        int s = 0;\\n        for(int i=1;i<arr.length-1;i++) {\\n            if(arr[i]>arr[i-1] && arr[i]>arr[i+1]) {\\n                int j=i,tem=1;\\n                while(j>0 && arr[j]>arr[j-1]){\\n                    j--;tem++;\\n                }\\n                j=i;\\n                while(j<arr.length-1 && arr[j]>arr[j+1]) {\\n                    j++;tem++;\\n                }\\n                s=Math.max(s,tem);\\n                i=j;\\n            }\\n        }\\n        return s;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int longestMountain(int[] arr) {\\n        int s = 0;\\n        for(int i=1;i<arr.length-1;i++) {\\n            if(arr[i]>arr[i-1] && arr[i]>arr[i+1]) {\\n                int j=i,tem=1;\\n                while(j>0 && arr[j]>arr[j-1]){\\n                    j--;tem++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1715077,
                "title": "c-1-pass-o-1-space-two-pointer-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& nums) {\\n        int low{0},res{0};\\n        for(int i=1;i<nums.size(); )\\n        {\\n            bool increasing{false},decreasing{false};\\n            while(i<nums.size() and nums[i]>nums[i-1] ) \\n            {\\n                increasing=true;\\n                i++;\\n            }\\n            while(i<nums.size() and nums[i]<nums[i-1] and increasing)\\n            {\\n                decreasing=true;\\n                i++;\\n            }\\n            if(increasing and decreasing)\\n            {\\n                res=max(res,(i-1)-low+1);\\n                low=i-1;\\n            }\\n            else\\n            {\\n                low=i;\\n                i++;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& nums) {\\n        int low{0},res{0};\\n        for(int i=1;i<nums.size(); )\\n        {\\n            bool increasing{false},decreasing{false};\\n            while(i<nums.size() and nums[i]>nums[i-1] ) \\n            {\\n                increasing=true;\\n                i++;\\n            }\\n            while(i<nums.size() and nums[i]<nums[i-1] and increasing)\\n            {\\n                decreasing=true;\\n                i++;\\n            }\\n            if(increasing and decreasing)\\n            {\\n                res=max(res,(i-1)-low+1);\\n                low=i-1;\\n            }\\n            else\\n            {\\n                low=i;\\n                i++;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677513,
                "title": "python-o-n-time-o-1-space-solution-no-shortcuts-direct-solution",
                "content": "I am open to other solutions also. Kindly comment your ideas and PoVs. Thank you!\\n```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        maxlen = 0\\n        n = len( arr)\\n        maxi = 0\\n        tp = 0\\n        incFlag = 0\\n        decFlag = 0\\n        if n < 3:\\n            return 0\\n\\n        for i in range (2,n):\\n            prev = arr[i-1]    \\n            prevprev = arr[i-2]    \\n            # print( tp)\\n            if prevprev < prev and prev < arr[i]:\\n                if tp == 0:\\n                    tp = 2\\n                tp += 1\\n                incFlag = 1\\n            elif decFlag != 1 and prevprev < prev and prev > arr[i]:\\n                if incFlag == 0:\\n                    incFlag = 1\\n                    tp += 2\\n                tp += 1\\n                decFlag = 1\\n                # if incFlag == 1 and decFlag == 1:\\n                maxlen = max( maxlen, tp)\\n            elif incFlag == 1 and decFlag == 1 and prevprev > prev and prev > arr[i]:\\n                tp += 1\\n                # decFlag = 1\\n                # if incFlag == 1 and decFlag == 1:\\n                maxlen = max( maxlen, tp)\\n            else:\\n                incFlag = 0\\n                decFlag = 0\\n                tp = 0\\n            print( tp)\\n        return maxlen\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        maxlen = 0\\n        n = len( arr)\\n        maxi = 0\\n        tp = 0\\n        incFlag = 0\\n        decFlag = 0\\n        if n < 3:\\n            return 0\\n\\n        for i in range (2,n):\\n            prev = arr[i-1]    \\n            prevprev = arr[i-2]    \\n            # print( tp)\\n            if prevprev < prev and prev < arr[i]:\\n                if tp == 0:\\n                    tp = 2\\n                tp += 1\\n                incFlag = 1\\n            elif decFlag != 1 and prevprev < prev and prev > arr[i]:\\n                if incFlag == 0:\\n                    incFlag = 1\\n                    tp += 2\\n                tp += 1\\n                decFlag = 1\\n                # if incFlag == 1 and decFlag == 1:\\n                maxlen = max( maxlen, tp)\\n            elif incFlag == 1 and decFlag == 1 and prevprev > prev and prev > arr[i]:\\n                tp += 1\\n                # decFlag = 1\\n                # if incFlag == 1 and decFlag == 1:\\n                maxlen = max( maxlen, tp)\\n            else:\\n                incFlag = 0\\n                decFlag = 0\\n                tp = 0\\n            print( tp)\\n        return maxlen\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672869,
                "title": "longest-mountain-in-array-c-code-without-dp-easy-approach",
                "content": "\\n\\n\\n\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int count,j,mx=0,n=arr.size();\\n        bool flag;\\n        for(int i=1;i<n;i++){\\n            j=i;\\n            count=1;\\n            flag=false;\\n            \\n            //increasing sequence\\n            while(j<n && arr[j]>arr[j-1]){\\n                count++;\\n                j++;\\n            }\\n            \\n            //decreasing sequence\\n            while(i!=j && j<n && arr[j]<arr[j-1]){\\n                count++;\\n                j++;\\n                flag=true;\\n            }\\n            \\n            //length is max or not\\n            if(i!=j && flag && count>=3){\\n                mx=max(mx,count);\\n                j--;\\n            }\\n            \\n            i=j;\\n        }\\n        return mx;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int count,j,mx=0,n=arr.size();\\n        bool flag;\\n        for(int i=1;i<n;i++){\\n            j=i;\\n            count=1;\\n            flag=false;\\n            \\n            //increasing sequence\\n            while(j<n && arr[j]>arr[j-1]){\\n                count++;\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1642862,
                "title": "clean-and-clearly-understandable-java-solution",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int res = 0;\\n        if(arr.length < 2) return 0;\\n        for(int i=1; i<arr.length-1;i++){\\n            boolean isPeak = false;\\n            if(arr[i] > arr[i-1] && arr[i] > arr[i+1]){\\n                isPeak = true;\\n            }\\n            if(isPeak){   \\n                int j =i-1;\\n                int currPeak = 1;\\n                while(j>=0 && arr[j+1]>arr[j]){\\n                    currPeak++;\\n                    j--;\\n                }\\n                j=i+1;\\n                while(j<arr.length && arr[j-1] > arr[j]){\\n                    currPeak++;\\n                    j++;\\n                }\\n                 res = Math.max(currPeak,res);\\n            }  \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int res = 0;\\n        if(arr.length < 2) return 0;\\n        for(int i=1; i<arr.length-1;i++){\\n            boolean isPeak = false;\\n            if(arr[i] > arr[i-1] && arr[i] > arr[i+1]){\\n                isPeak = true;\\n            }\\n            if(isPeak){   \\n                int j =i-1;\\n                int currPeak = 1;\\n                while(j>=0 && arr[j+1]>arr[j]){\\n                    currPeak++;\\n                    j--;\\n                }\\n                j=i+1;\\n                while(j<arr.length && arr[j-1] > arr[j]){\\n                    currPeak++;\\n                    j++;\\n                }\\n                 res = Math.max(currPeak,res);\\n            }  \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1511677,
                "title": "java-o-n-pre-compute",
                "content": "1. For each index precompute number of contiguous minimum numbers on left and right side.\\n2. For each index i calcuate ans=left[i] + 1 + right[i] => if left[i] and right[i] is > 0.\\n\\n```\\nclass Solution {\\n    public int longestMountain(int[] a) {\\n        int n=a.length;\\n        int[] left=new int[n];\\n        for(int i=1; i<n; i++)\\n        {\\n            if(a[i]>a[i-1])\\n            {\\n                left[i]=left[i-1]+1;\\n            }\\n            else if(a[i]<a[i-1])\\n            {\\n                left[i]=0;\\n            }\\n        }\\n        int[] right=new int[n];\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            if(a[i]>a[i+1])\\n            {\\n                right[i]=right[i+1]+1;\\n            }\\n            else if(a[i]<a[i+1])\\n            {\\n                right[i]=0;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(left[i]>0 && right[i]>0)\\n            {\\n                ans=Math.max(ans, left[i]+right[i]+1);   \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] a) {\\n        int n=a.length;\\n        int[] left=new int[n];\\n        for(int i=1; i<n; i++)\\n        {\\n            if(a[i]>a[i-1])\\n            {\\n                left[i]=left[i-1]+1;\\n            }\\n            else if(a[i]<a[i-1])\\n            {\\n                left[i]=0;\\n            }\\n        }\\n        int[] right=new int[n];\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            if(a[i]>a[i+1])\\n            {\\n                right[i]=right[i+1]+1;\\n            }\\n            else if(a[i]<a[i+1])\\n            {\\n                right[i]=0;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(left[i]>0 && right[i]>0)\\n            {\\n                ans=Math.max(ans, left[i]+right[i]+1);   \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1505656,
                "title": "prefix-suffix-array-simple-solution",
                "content": "class Solution {\\npublic:\\n    int longestMountain(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        \\n        vector<int> pre(n,1);\\n        vector<int> suf(n,1);\\n\\n        int sol = INT_MIN;\\n\\n        for(int i=1;i<n;i++){\\n            \\n            if(nums[i-1]<nums[i]){\\n                \\n                pre[i]=pre[i-1]+1;\\n            }\\n        }\\n\\n        \\n        for(int i=n-2;i>=0;i--){\\n            \\n            if(nums[i+1]<nums[i]){\\n                \\n                suf[i]=suf[i+1]+1;\\n            }\\n            \\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            \\n            if(pre[i] > 1 && suf[i] > 1)\\n            {\\n                sol = max(sol , pre[i] + suf[i]-1);\\n            }\\n           \\n        }\\n        \\n        \\n        if(sol==INT_MIN){\\n            return 0;\\n        }\\n        \\n        else{\\n            return sol;\\n        }\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Suffix Array"
                ],
                "code": "class Solution {\\npublic:\\n    int longestMountain(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        \\n        vector<int> pre(n,1);\\n        vector<int> suf(n,1);\\n\\n        int sol = INT_MIN;\\n\\n        for(int i=1;i<n;i++){\\n            \\n            if(nums[i-1]<nums[i]){\\n                \\n                pre[i]=pre[i-1]+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1504390,
                "title": "c-clean-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        vector<int> dp(arr.size());\\n           vector<int> dp1(arr.size());\\n    \\n        for(int i=1;i<arr.size()-1;i++){\\n            if(arr[i-1]<arr[i]){\\n                dp[i]=dp[i-1]+1;\\n            }\\n        }\\n         for(int i=arr.size()-2;i>=1;i--){\\n            if(arr[i+1]<arr[i]){\\n                dp1[i]=dp1[i+1]+1;\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<dp.size();i++){\\n            if(dp[i]!=0&&dp1[i]!=0){\\n                ans=max(ans,dp[i]+dp1[i]+1);\\n            }\\n        }\\n        return ((ans==INT_MIN)?0:ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        vector<int> dp(arr.size());\\n           vector<int> dp1(arr.size());\\n    \\n        for(int i=1;i<arr.size()-1;i++){\\n            if(arr[i-1]<arr[i]){\\n                dp[i]=dp[i-1]+1;\\n            }\\n        }\\n         for(int i=arr.size()-2;i>=1;i--){\\n            if(arr[i+1]<arr[i]){\\n                dp1[i]=dp1[i+1]+1;\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<dp.size();i++){\\n            if(dp[i]!=0&&dp1[i]!=0){\\n                ans=max(ans,dp[i]+dp1[i]+1);\\n            }\\n        }\\n        return ((ans==INT_MIN)?0:ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426271,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int start = 0;\\n        int res = 0;\\n        \\n        while(start < arr.size())\\n        {\\n            int end = start; // init end to be the same position as start\\n            bool walked_up = false;\\n            bool walked_down = false;\\n            while(end + 1 < arr.size() && arr[end + 1] > arr[end]) // we can walk up if the next value is greater\\n            {\\n                walked_up = true; // we actually walked up.\\n                end++;\\n            }\\n            while(end + 1 < arr.size() && arr[end + 1] < arr[end]) // now we walk down\\n            {\\n                walked_down = true; // we actually walked down\\n                end++;\\n            }\\n            if (walked_up && walked_down) // it is only a valid mountain if we walked up and down.\\n            {\\n                res = max(res, end - start + 1);\\n            }\\n            start = max(end, start + 1); // the next index we look at is either the end of a mountain, or simply the next index.\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int start = 0;\\n        int res = 0;\\n        \\n        while(start < arr.size())\\n        {\\n            int end = start; // init end to be the same position as start\\n            bool walked_up = false;\\n            bool walked_down = false;\\n            while(end + 1 < arr.size() && arr[end + 1] > arr[end]) // we can walk up if the next value is greater\\n            {\\n                walked_up = true; // we actually walked up.\\n                end++;\\n            }\\n            while(end + 1 < arr.size() && arr[end + 1] < arr[end]) // now we walk down\\n            {\\n                walked_down = true; // we actually walked down\\n                end++;\\n            }\\n            if (walked_up && walked_down) // it is only a valid mountain if we walked up and down.\\n            {\\n                res = max(res, end - start + 1);\\n            }\\n            start = max(end, start + 1); // the next index we look at is either the end of a mountain, or simply the next index.\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419207,
                "title": "one-pass-93-speed",
                "content": "![image](https://assets.leetcode.com/users/images/d36ec6e4-bac9-427e-b67c-95b779bd8d16_1629623535.5961733.png)\\n```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        len_mountain = slope = 0\\n        start = -1\\n        arr.append(arr[-1])    # to trigger len_mountain check in the loop\\n        for i, (a, b) in enumerate(zip(arr, arr[1:])):\\n            if b > a:\\n                if slope < 1:\\n                    if slope == -1 and start > -1:\\n                        len_mountain = max(len_mountain, i + 1 - start)\\n                    start = i\\n                    slope = 1\\n            elif b < a:\\n                if slope == 1:\\n                    slope = -1\\n            else:\\n                if slope == -1:\\n                    if start > -1:\\n                        len_mountain = max(len_mountain, i + 1 - start)\\n                slope = 0\\n                start = -1\\n        return len_mountain\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        len_mountain = slope = 0\\n        start = -1\\n        arr.append(arr[-1])    # to trigger len_mountain check in the loop\\n        for i, (a, b) in enumerate(zip(arr, arr[1:])):\\n            if b > a:\\n                if slope < 1:\\n                    if slope == -1 and start > -1:\\n                        len_mountain = max(len_mountain, i + 1 - start)\\n                    start = i\\n                    slope = 1\\n            elif b < a:\\n                if slope == 1:\\n                    slope = -1\\n            else:\\n                if slope == -1:\\n                    if start > -1:\\n                        len_mountain = max(len_mountain, i + 1 - start)\\n                slope = 0\\n                start = -1\\n        return len_mountain\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1409639,
                "title": "c-one-pass-o-n-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        if(n<3) return 0;\\n        int lm = 0, m = 0;\\n        bool gu = false; // going up flag\\n        for(int i = 0; i < n-1; i++) {\\n            if(arr[i]<arr[i+1] && (gu || m==0)) { // going up the mountain at end of array\\n                m++;\\n                gu = true;\\n            } else if(arr[i]>arr[i+1] && (gu || m>0)) { // going down the mountain\\n                m++;\\n                gu = false;\\n                if(i==n-2) lm = max(lm,m); // end of mountain\\n            } else if(arr[i]<arr[i+1] && !gu && m>0) { // end of current mountain and start of probable new mountain\\n                lm = max(lm,m);\\n                m = 1;\\n                gu = true;\\n            } else { // interruption in current mountain (equal values)\\n                if(!gu) lm = max(lm,m); // counted as a mountain if descent had started\\n                m = 0;\\n                gu = false;\\n            }\\n        }\\n        return lm>=2 ? lm+1 : 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        if(n<3) return 0;\\n        int lm = 0, m = 0;\\n        bool gu = false; // going up flag\\n        for(int i = 0; i < n-1; i++) {\\n            if(arr[i]<arr[i+1] && (gu || m==0)) { // going up the mountain at end of array\\n                m++;\\n                gu = true;\\n            } else if(arr[i]>arr[i+1] && (gu || m>0)) { // going down the mountain\\n                m++;\\n                gu = false;\\n                if(i==n-2) lm = max(lm,m); // end of mountain\\n            } else if(arr[i]<arr[i+1] && !gu && m>0) { // end of current mountain and start of probable new mountain\\n                lm = max(lm,m);\\n                m = 1;\\n                gu = true;\\n            } else { // interruption in current mountain (equal values)\\n                if(!gu) lm = max(lm,m); // counted as a mountain if descent had started\\n                m = 0;\\n                gu = false;\\n            }\\n        }\\n        return lm>=2 ? lm+1 : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1382513,
                "title": "c-solution-12-ms-96-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    /* The logic behind this is until finding the peak value the array should be in \\n       strictly increasing order and after finding the peak the values should be in \\n       strictly decreasing order \\n    */\\n       int longestMountain(vector<int>& arr) {\\n        int start=0,end=1;\\n        int max_val=0;\\n        bool peak_found=false;\\n        while(end<arr.size()){\\n            if(arr[end]>arr[end-1] && !peak_found){\\n                if(end+1<arr.size() && arr[end]>arr[end+1]){ // checking for peak value\\n                   peak_found=true; \\n                }\\n            }\\n            else if(arr[end]<=arr[end-1] && !peak_found){\\n                start=end; // if value in decreasing order before finding peak shift start to end\\n            }\\n            else if(arr[end]>=arr[end-1] && peak_found){\\n                max_val=max(max_val,end-start);//if value in increasing order after finding the peak  calculate the maxlength shift start to end-1                                                          \\n                start=end-1;\\n                peak_found=false;\\n                continue;\\n            }\\n            end++;\\n        }``\\n        if(peak_found){\\n            max_val=max(max_val,end-start);\\n        }\\n        return max_val;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    /* The logic behind this is until finding the peak value the array should be in \\n       strictly increasing order and after finding the peak the values should be in \\n       strictly decreasing order \\n    */\\n       int longestMountain(vector<int>& arr) {\\n        int start=0,end=1;\\n        int max_val=0;\\n        bool peak_found=false;\\n        while(end<arr.size()){\\n            if(arr[end]>arr[end-1] && !peak_found){\\n                if(end+1<arr.size() && arr[end]>arr[end+1]){ // checking for peak value\\n                   peak_found=true; \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1356525,
                "title": "sum-of-lis-and-lds",
                "content": "```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        \\n        lis=[0]*len(arr)\\n        \\n        for i in range(1,len(arr)):\\n            if arr[i-1]<arr[i]:\\n                lis[i]=lis[i-1]+1\\n            else:\\n                lis[i]=0\\n        \\n        lds=[0]*len(arr)\\n        \\n        for i in  range(len(arr)-2,-1,-1):\\n            if arr[i+1]<arr[i]:\\n                lds[i]=lds[i+1]+1\\n            else:\\n                lds[i]=0\\n        ans=0\\n        for i in range(1,len(arr)-1):\\n            if lis[i]!=0 and lds[i]!=0:\\n                ans=max(ans,lds[i]+lis[i])\\n        #print(lis)\\n        #print(lds)\\n        return ans+1 if ans!=0 else 0\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        \\n        lis=[0]*len(arr)\\n        \\n        for i in range(1,len(arr)):\\n            if arr[i-1]<arr[i]:\\n                lis[i]=lis[i-1]+1\\n            else:\\n                lis[i]=0\\n        \\n        lds=[0]*len(arr)\\n        \\n        for i in  range(len(arr)-2,-1,-1):\\n            if arr[i+1]<arr[i]:\\n                lds[i]=lds[i+1]+1\\n            else:\\n                lds[i]=0\\n        ans=0\\n        for i in range(1,len(arr)-1):\\n            if lis[i]!=0 and lds[i]!=0:\\n                ans=max(ans,lds[i]+lis[i])\\n        #print(lis)\\n        #print(lds)\\n        return ans+1 if ans!=0 else 0\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355415,
                "title": "java-single-pass",
                "content": "```\\npublic static int longestMountain(int[] arr) {\\n    int maxPeakLength = 0;\\n\\n\\tint i = 1;\\n\\twhile (i < arr.length) {\\n\\t\\t// Go on increasing(till mountain)\\n\\t\\tint increasingLength = increase(i, arr);\\n\\t\\tif (increasingLength == 0) {\\n\\t\\t\\ti++;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\ti = i + increasingLength;\\n\\t\\t\\n\\t\\t// Go on decreasing\\n\\t\\tint decreasingLength = decrease(i, arr);\\n\\t\\tif (decreasingLength == 0) {\\n\\t\\t\\ti++;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\ti = i + decreasingLength;\\n\\n\\t\\t// Added 1 because peak number is not counted in both increasingLength/decreasingLength.\\n\\t\\tint peakLength = increasingLength + decreasingLength + 1;\\n\\t\\tif (peakLength > maxPeakLength) {\\n\\t\\t\\tmaxPeakLength = peakLength;\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxPeakLength;\\n}\\n\\npublic static int increase(int index, int[] arr) {\\n\\tint initialValue = index;\\n\\twhile (index < arr.length && arr[index - 1] < arr[index]) {\\n\\t\\tindex++;\\n\\t}\\n\\n\\treturn index - initialValue;\\n}\\n\\npublic static int decrease(int index, int[] arr) {\\n\\tint initialValue = index;\\n\\twhile (index < arr.length && arr[index - 1] > arr[index]) {\\n\\t\\tindex++;\\n\\t}\\n\\n\\treturn index - initialValue;\\n}\\n```\\n\\nTime Complexity: O(n)",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\npublic static int longestMountain(int[] arr) {\\n    int maxPeakLength = 0;\\n\\n\\tint i = 1;\\n\\twhile (i < arr.length) {\\n\\t\\t// Go on increasing(till mountain)\\n\\t\\tint increasingLength = increase(i, arr);\\n\\t\\tif (increasingLength == 0) {\\n\\t\\t\\ti++;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\ti = i + increasingLength;\\n\\t\\t\\n\\t\\t// Go on decreasing\\n\\t\\tint decreasingLength = decrease(i, arr);\\n\\t\\tif (decreasingLength == 0) {\\n\\t\\t\\ti++;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\ti = i + decreasingLength;\\n\\n\\t\\t// Added 1 because peak number is not counted in both increasingLength/decreasingLength.\\n\\t\\tint peakLength = increasingLength + decreasingLength + 1;\\n\\t\\tif (peakLength > maxPeakLength) {\\n\\t\\t\\tmaxPeakLength = peakLength;\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxPeakLength;\\n}\\n\\npublic static int increase(int index, int[] arr) {\\n\\tint initialValue = index;\\n\\twhile (index < arr.length && arr[index - 1] < arr[index]) {\\n\\t\\tindex++;\\n\\t}\\n\\n\\treturn index - initialValue;\\n}\\n\\npublic static int decrease(int index, int[] arr) {\\n\\tint initialValue = index;\\n\\twhile (index < arr.length && arr[index - 1] > arr[index]) {\\n\\t\\tindex++;\\n\\t}\\n\\n\\treturn index - initialValue;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1275264,
                "title": "python3-solution-with-no-if-operators-just-for-fun",
                "content": "```\\nclass State:\\n    def __init__(self):\\n        self.best = self.up = self.down = 0\\n        self.process_value = self.process_first\\n        self.process_up = self.process_just_up\\n        self.process_down = self.process_just_down\\n    def process_eq(self):\\n        self.up = self.down = 0\\n        self.process_up = self.process_just_up\\n        self.process_down = self.process_just_down\\n    def process_down_then_up(self):\\n        self.up = 1\\n        self.down = 0        \\n        self.process_down = self.process_up_then_down\\n        self.process_up = self.process_just_up\\n    def process_just_up(self):\\n        self.up += 1\\n        self.process_down = self.process_up_then_down\\n    def process_up_then_down(self):\\n        self.down += 1\\n        self.best = max(self.best, self.up+self.down+1)\\n        self.process_up = self.process_down_then_up\\n    def process_just_down(self):\\n        pass\\n    def process_first(self, v):\\n        self.prev = v\\n        self.process_value = self.process_next\\n    def process_next(self, v):\\n        p =  self.prev\\n        self.prev = v\\n        [self.process_down,self.process_eq,self.process_up][int(v>p)+1-int(v<p)]()\\n    def get_result(self):\\n        return self.best\\n        \\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        S = State()\\n        for v in arr: S.process_value(v)\\n        return S.get_result()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass State:\\n    def __init__(self):\\n        self.best = self.up = self.down = 0\\n        self.process_value = self.process_first\\n        self.process_up = self.process_just_up\\n        self.process_down = self.process_just_down\\n    def process_eq(self):\\n        self.up = self.down = 0\\n        self.process_up = self.process_just_up\\n        self.process_down = self.process_just_down\\n    def process_down_then_up(self):\\n        self.up = 1\\n        self.down = 0        \\n        self.process_down = self.process_up_then_down\\n        self.process_up = self.process_just_up\\n    def process_just_up(self):\\n        self.up += 1\\n        self.process_down = self.process_up_then_down\\n    def process_up_then_down(self):\\n        self.down += 1\\n        self.best = max(self.best, self.up+self.down+1)\\n        self.process_up = self.process_down_then_up\\n    def process_just_down(self):\\n        pass\\n    def process_first(self, v):\\n        self.prev = v\\n        self.process_value = self.process_next\\n    def process_next(self, v):\\n        p =  self.prev\\n        self.prev = v\\n        [self.process_down,self.process_eq,self.process_up][int(v>p)+1-int(v<p)]()\\n    def get_result(self):\\n        return self.best\\n        \\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        S = State()\\n        for v in arr: S.process_value(v)\\n        return S.get_result()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1265918,
                "title": "cpp-time-o-n-space-o-1-single-pass-exactly-n-operations",
                "content": "class Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        \\n        if(arr.size()<3)\\n            return 0;\\n        //find all the peak\\n        int left =1;\\n        int max =0;\\n        for(int i=1;i<arr.size()-1;){\\n            //skip 1st downhill/plateau\\n            if(i==1)\\n            while(i<=arr.size()-1 && arr[i]<=arr[i-1]){\\n                i++;\\n            }\\n            //check if  peak and count downhill\\n            if(i<arr.size()-1 && arr[i]>arr[i-1]&&arr[i]>arr[i+1]){\\n                int right =0;\\n                i++;\\n                while(i<=arr.size()-1 &&arr[i]<arr[i-1]){\\n                    right++;\\n                    i++;\\n                }\\n                if(max<left+right+1)\\n                    max = left+right+1;\\n                //reset left\\n                left =1;  \\n            }\\n            //check uphill till peak\\n            else{\\n                if(i<=arr.size()-1 && arr[i]>arr[i-1])\\n                left++;\\n                else\\n                    left =1;// reset for plateau\\n                i++;\\n            }\\n        }\\n        return max;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        \\n        if(arr.size()<3)\\n            return 0;\\n        //find all the peak\\n        int left =1;\\n        int max =0;\\n        for(int i=1;i<arr.size()-1;){\\n            //skip 1st downhill/plateau\\n            if(i==1)\\n            while(i<=arr.size()-1 && arr[i]<=arr[i-1]){\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1220179,
                "title": "c-time-o-n-space-o-1-modular-solution-proper-naming",
                "content": "```\\nclass Solution {\\npublic:\\n    int goLeft(int idx, vector<int>& arr, int n){\\n        int cc = 0;\\n        while(idx-1>=0 and arr[idx]>arr[idx-1])\\n            cc++,idx--;\\n        return cc;\\n    }\\n\\t\\n    int goRight(int idx, vector<int>& arr, int n){\\n        int cc = 0;\\n        while(idx+1<n and arr[idx]>arr[idx+1])\\n            cc++,idx++;\\n        return cc;\\n    }\\n\\t\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        int ans = 0;\\n        for(int i=1; i<n-1; i++){\\n            int left = goLeft(i, arr, n);\\n            int right = goRight(i, arr, n);\\n            if(left>0 and right>0)\\n                ans = max(ans, left+right+1);\\n            i+=right;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int goLeft(int idx, vector<int>& arr, int n){\\n        int cc = 0;\\n        while(idx-1>=0 and arr[idx]>arr[idx-1])\\n            cc++,idx--;\\n        return cc;\\n    }\\n\\t\\n    int goRight(int idx, vector<int>& arr, int n){\\n        int cc = 0;\\n        while(idx+1<n and arr[idx]>arr[idx+1])\\n            cc++,idx++;\\n        return cc;\\n    }\\n\\t\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        int ans = 0;\\n        for(int i=1; i<n-1; i++){\\n            int left = goLeft(i, arr, n);\\n            int right = goRight(i, arr, n);\\n            if(left>0 and right>0)\\n                ans = max(ans, left+right+1);\\n            i+=right;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195315,
                "title": "java-1ms-beats-100",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n\\n        int res = 0, start, j;\\n        boolean up=false,down=false;\\n\\n        for (int i = 1; i < arr.length; i++) {\\n            if (arr[i] > arr[i - 1]) {\\n                start = i - 1;\\n                j = i-1;\\n\\n                while ((start + 1) < arr.length && arr[start] < arr[start + 1]) {\\n                    start++;\\n                    up = true;\\n                }\\n\\n                while ((start + 1) < arr.length && arr[start] > arr[start + 1]) {\\n                    start++;\\n                    down = true;\\n                }\\n\\n                if (up && down) {\\n                    res = Math.max(res, start - j + 1);\\n                }\\n                i = start;\\n                up = false;\\n                down = false;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n\\n        int res = 0, start, j;\\n        boolean up=false,down=false;\\n\\n        for (int i = 1; i < arr.length; i++) {\\n            if (arr[i] > arr[i - 1]) {\\n                start = i - 1;\\n                j = i-1;\\n\\n                while ((start + 1) < arr.length && arr[start] < arr[start + 1]) {\\n                    start++;\\n                    up = true;\\n                }\\n\\n                while ((start + 1) < arr.length && arr[start] > arr[start + 1]) {\\n                    start++;\\n                    down = true;\\n                }\\n\\n                if (up && down) {\\n                    res = Math.max(res, start - j + 1);\\n                }\\n                i = start;\\n                up = false;\\n                down = false;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1181214,
                "title": "c-one-pass-space-complexity-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int j = 0;\\n        int i = 0;\\n        int n = arr.size();\\n        int ans = 0;\\n        while(j<n)\\n        {\\n            j = i;\\n            if(j+1<n && arr[j+1]>arr[j])\\n            {\\n                while(j+1<n && arr[j+1]>arr[j])\\n                {\\n                    j++;\\n                }\\n                if(j+1<n && arr[j]>arr[j+1])\\n                {\\n                    while(j+1<n && arr[j]>arr[j+1])\\n                    {\\n                        j++;\\n                    }\\n                    ans = max(ans,j-i+1);\\n                }\\n            }\\n            i = max(i+1,j);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int j = 0;\\n        int i = 0;\\n        int n = arr.size();\\n        int ans = 0;\\n        while(j<n)\\n        {\\n            j = i;\\n            if(j+1<n && arr[j+1]>arr[j])\\n            {\\n                while(j+1<n && arr[j+1]>arr[j])\\n                {\\n                    j++;\\n                }\\n                if(j+1<n && arr[j]>arr[j+1])\\n                {\\n                    while(j+1<n && arr[j]>arr[j+1])\\n                    {\\n                        j++;\\n                    }\\n                    ans = max(ans,j-i+1);\\n                }\\n            }\\n            i = max(i+1,j);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1176112,
                "title": "one-pass-space-complexity-o-1",
                "content": "A simple solution to keep track of rising and going down with a boolean flag and solving it using in one single pass\\nThere are three scenarios which can happen when we are traversing the array\\n\\n```\\n\\npublic int longestMountain(int[] arr) {\\n\\tint max = 0;\\n\\n\\tint increaseStart = Integer.MAX_VALUE;\\n\\tboolean increase = false;\\n\\n\\tfor (int i = 1; i < arr.length; i++) {\\n\\t\\tif (arr[i] >= arr[i - 1] && !increase) { //Mountain has started to ascend. Hence we need to mark the mountain start with variables increaseStart.\\n\\t\\t\\tincreaseStart = i - 1;\\n\\t\\t\\tincrease = true;\\n\\t\\t}\\n\\t\\tif (arr[i] == arr[i - 1]) {\\n\\t\\t\\tincreaseStart = Integer.MAX_VALUE;//If the mountain remains flat then ignore the previous mountain start, as by definition it has to be strictly increasing.\\n\\t\\t\\tincrease = false;\\n\\t\\t}\\n\\n\\t\\tif (arr[i] < arr[i - 1]) {\\n\\t\\t\\tincrease = false; //The mountain is decending hence continously mark our mountain length and check with our max.\\n\\t\\t\\tmax = Math.max(max, i - increaseStart + 1);\\n\\t\\t}\\n\\t}\\n\\n\\treturn max;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\npublic int longestMountain(int[] arr) {\\n\\tint max = 0;\\n\\n\\tint increaseStart = Integer.MAX_VALUE;\\n\\tboolean increase = false;\\n\\n\\tfor (int i = 1; i < arr.length; i++) {\\n\\t\\tif (arr[i] >= arr[i - 1] && !increase) { //Mountain has started to ascend. Hence we need to mark the mountain start with variables increaseStart.\\n\\t\\t\\tincreaseStart = i - 1;\\n\\t\\t\\tincrease = true;\\n\\t\\t}\\n\\t\\tif (arr[i] == arr[i - 1]) {\\n\\t\\t\\tincreaseStart = Integer.MAX_VALUE;//If the mountain remains flat then ignore the previous mountain start, as by definition it has to be strictly increasing.\\n\\t\\t\\tincrease = false;\\n\\t\\t}\\n\\n\\t\\tif (arr[i] < arr[i - 1]) {\\n\\t\\t\\tincrease = false; //The mountain is decending hence continously mark our mountain length and check with our max.\\n\\t\\t\\tmax = Math.max(max, i - increaseStart + 1);\\n\\t\\t}\\n\\t}\\n\\n\\treturn max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1123097,
                "title": "java-two-pointers-one-pass",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        if (arr == null || arr.length == 0) return 0;\\n        int max = 0;\\n        for (int i = 1; i < arr.length - 1; i++) {\\n            int left = i, right = i;\\n            if (arr[i] > arr[i - 1] && arr[i] > arr[i + 1]) {\\n                left--;\\n                right++;\\n                while (left >= 1 && arr[left] > arr[left - 1]) left--;\\n                while (right < arr.length - 1 && arr[right] > arr[right + 1]) right++;\\n                max = Math.max(max, right - left + 1);\\n            }\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int longestMountain(int[] arr) {\\n        if (arr == null || arr.length == 0) return 0;\\n        int max = 0;\\n        for (int i = 1; i < arr.length - 1; i++) {\\n            int left = i, right = i;\\n            if (arr[i] > arr[i - 1] && arr[i] > arr[i + 1]) {\\n                left--;\\n                right++;\\n                while (left >= 1 && arr[left] > arr[left - 1]) left--;\\n                while (right < arr.length - 1 && arr[right] > arr[right + 1]) right++;\\n                max = Math.max(max, right - left + 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1085155,
                "title": "java-linear-scan-o-n",
                "content": "The first approach came to mind immediately is expand from center, which will go to O(n^2).\\nAfter sumbitting I realized that there has to be an O(n) solution.\\n## Linear Scan, O(n)\\nI view a mountain as left-top-right.\\n```\\n    public int longestMountain(int[] arr) {\\n        int ans = 0;\\n        int left = 0;\\n        while (left < arr.length - 2) {\\n            int top = left;\\n            while (top + 1 < arr.length && arr[top + 1] > arr[top]) top++;\\n            int right = top;\\n            while (right + 1 < arr.length && arr[right + 1] < arr[right]) right++;\\n            if (left < top && top < right) ans = Math.max(ans, right - left + 1);\\n            left = Math.max(left + 1, right);\\n        }\\n        return ans;\\n    }\\n```\\n\\n## Expand From Center, O(n^2)\\n```\\n    public int longestMountain(int[] arr) {\\n        int ans = 0;\\n        for (int i = 0; i < arr.length; i++) ans = Math.max(ans, expandFromCenter(i, arr));\\n        return ans;\\n    }\\n\\n    private int expandFromCenter(int center, int[] a) {\\n        int left = center;\\n        int right = center;\\n        while (left - 1 >= 0 && a[left - 1] < a[left]) left--;\\n        while (right + 1 < a.length && a[right + 1] < a[right]) right++;\\n        return left == center || right == center ? 0 : right - left + 1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int longestMountain(int[] arr) {\\n        int ans = 0;\\n        int left = 0;\\n        while (left < arr.length - 2) {\\n            int top = left;\\n            while (top + 1 < arr.length && arr[top + 1] > arr[top]) top++;\\n            int right = top;\\n            while (right + 1 < arr.length && arr[right + 1] < arr[right]) right++;\\n            if (left < top && top < right) ans = Math.max(ans, right - left + 1);\\n            left = Math.max(left + 1, right);\\n        }\\n        return ans;\\n    }\\n```\n```\\n    public int longestMountain(int[] arr) {\\n        int ans = 0;\\n        for (int i = 0; i < arr.length; i++) ans = Math.max(ans, expandFromCenter(i, arr));\\n        return ans;\\n    }\\n\\n    private int expandFromCenter(int center, int[] a) {\\n        int left = center;\\n        int right = center;\\n        while (left - 1 >= 0 && a[left - 1] < a[left]) left--;\\n        while (right + 1 < a.length && a[right + 1] < a[right]) right++;\\n        return left == center || right == center ? 0 : right - left + 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 974108,
                "title": "python3-1-pass-o-1-space-solution-longest-mountain-in-array",
                "content": "```\\nclass Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        ans, start = 0, None\\n        for i in range(1, len(A)):\\n            if A[i] > A[i-1] and (i == 1 or A[i-1] <= A[i-2]):\\n                start = i - 1\\n            elif A[i] == A[i-1]:\\n                start = None \\n            elif A[i] < A[i-1] and start is not None:\\n                ans = max(ans, i - start + 1)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        ans, start = 0, None\\n        for i in range(1, len(A)):\\n            if A[i] > A[i-1] and (i == 1 or A[i-1] <= A[i-2]):\\n                start = i - 1\\n            elif A[i] == A[i-1]:\\n                start = None \\n            elif A[i] < A[i-1] and start is not None:\\n                ans = max(ans, i - start + 1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 955919,
                "title": "beats-99-41-of-people-c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int max=0,i=0;\\n        while(i<arr.size()-1){\\n           // cout<<i<<\" \";\\n            int x=i;\\n            bool a=true,b=true;\\n            while(x<arr.size()-1){\\n                if(arr[x]>=arr[x+1])\\n                    break;\\n                a=false;\\n                x++;\\n            }\\n            if(!a){\\n                while(x<arr.size()-1){\\n                    if(arr[x]<=arr[x+1])\\n                        break;\\n                    x++;\\n                    b=false;\\n                }\\n            }\\n            else\\n                x++;\\n            if(!b){\\n                   max = max<(x-i+1)?(x-i+1):max;\\n            }\\n            i=x;\\n \\n        }\\n        return max;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int max=0,i=0;\\n        while(i<arr.size()-1){\\n           // cout<<i<<\" \";\\n            int x=i;\\n            bool a=true,b=true;\\n            while(x<arr.size()-1){\\n                if(arr[x]>=arr[x+1])\\n                    break;\\n                a=false;\\n                x++;\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 954738,
                "title": "java-dp-solution-by-traversing-from-both-ends-with-explanation",
                "content": "Step 1 : Create a dp1 array and store Length of increasing substring moving left to right.\\nStep 2 : Create a dp2 array and store Length of increasing substring moving right to left.\\nStep 3 : Find the Mountain combining both dp arrays.\\n\\nFeel free to ask questions.\\n\\n```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        if(arr.length<3){\\n            return 0;\\n        }\\n        int dp1[] = new int[arr.length];\\n        int dp2[] = new int[arr.length];\\n        \\n        dp1[0]=0;\\n        for(int i=1; i<dp1.length; i++){\\n            if(arr[i]>arr[i-1]){\\n                dp1[i] = dp1[i-1] +1;\\n            }    \\n            else{\\n                dp1[i] = 0;\\n            }\\n        }\\n        dp2[dp2.length-1] = 0;\\n        \\n        for(int j=dp2.length-2; j>=0; j--){\\n            if(arr[j]>arr[j+1]){\\n                dp2[j]=dp2[j+1] + 1; \\n            }else{\\n                dp2[j] = 0;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0; i<arr.length; i++){\\n            if(dp1[i]>0 && dp2[i]>0){\\n            {  \\n                ans = Math.max(ans, dp1[i] + dp2[i] + 1);\\n            }\\n          }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        if(arr.length<3){\\n            return 0;\\n        }\\n        int dp1[] = new int[arr.length];\\n        int dp2[] = new int[arr.length];\\n        \\n        dp1[0]=0;\\n        for(int i=1; i<dp1.length; i++){\\n            if(arr[i]>arr[i-1]){\\n                dp1[i] = dp1[i-1] +1;\\n            }    \\n            else{\\n                dp1[i] = 0;\\n            }\\n        }\\n        dp2[dp2.length-1] = 0;\\n        \\n        for(int j=dp2.length-2; j>=0; j--){\\n            if(arr[j]>arr[j+1]){\\n                dp2[j]=dp2[j+1] + 1; \\n            }else{\\n                dp2[j] = 0;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0; i<arr.length; i++){\\n            if(dp1[i]>0 && dp2[i]>0){\\n            {  \\n                ans = Math.max(ans, dp1[i] + dp2[i] + 1);\\n            }\\n          }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 947350,
                "title": "javascript-o-n-time-o-1-space-straight-forward-approach",
                "content": "```\\nfunction longestPeak(array) {\\n\\tlet maxLength = 0\\n\\tfor(let i = 1; i < array.length; i++) {\\n\\t\\tconst isPeak = array[i] > array[i - 1] && array[i] > array[i + 1]\\n    if(!isPeak) {\\n      continue\\n    }\\n\\n     let left = i - 1,\\n        right = i + 1;\\n    while(left >= 0 && array[left] > array[left - 1]) {\\n      left--\\n    }\\n\\n    while(right < array.length && array[right] > array[right + 1]) {\\n      right++\\n    }\\n\\n    maxLength = Math.max(maxLength, right - left + 1)\\n\\t\\t\\n\\t}\\n\\n  return maxLength\\n}",
                "solutionTags": [],
                "code": "```\\nfunction longestPeak(array) {\\n\\tlet maxLength = 0\\n\\tfor(let i = 1; i < array.length; i++) {\\n\\t\\tconst isPeak = array[i] > array[i - 1] && array[i] > array[i + 1]\\n    if(!isPeak) {\\n      continue\\n    }\\n\\n     let left = i - 1,\\n        right = i + 1;\\n    while(left >= 0 && array[left] > array[left - 1]) {\\n      left--\\n    }\\n\\n    while(right < array.length && array[right] > array[right + 1]) {\\n      right++\\n    }\\n\\n    maxLength = Math.max(maxLength, right - left + 1)\\n\\t\\t\\n\\t}\\n\\n  return maxLength\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 939845,
                "title": "java-one-pass-with-o-1-space",
                "content": "```\\n public int longestMountain(int[] A) {\\n        if (A == null || A.length == 0) return 0;\\n        int up = 0, down = 0, maxLen = 0;\\n        for (int i = 1; i < A.length; i++) {\\n            if (A[i] > A[i - 1]) {\\n                if (down != 0) {\\n                    down = 0;\\n                    up = 0;\\n                }\\n                up++;\\n            } else if (A[i] < A[i - 1]) {\\n                if (up != 0) {\\n                    down++;\\n                    maxLen = Math.max(maxLen, down + up + 1);\\n                }\\n            } else {\\n                up = 0;\\n                down = 0;\\n            }\\n        }\\n        return maxLen;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int longestMountain(int[] A) {\\n        if (A == null || A.length == 0) return 0;\\n        int up = 0, down = 0, maxLen = 0;\\n        for (int i = 1; i < A.length; i++) {\\n            if (A[i] > A[i - 1]) {\\n                if (down != 0) {\\n                    down = 0;\\n                    up = 0;\\n                }\\n                up++;\\n            } else if (A[i] < A[i - 1]) {\\n                if (up != 0) {\\n                    down++;\\n                    maxLen = Math.max(maxLen, down + up + 1);\\n                }\\n            } else {\\n                up = 0;\\n                down = 0;\\n            }\\n        }\\n        return maxLen;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 938967,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int ans=0;\\n        \\n        int i=0;\\n        while(i<A.size())\\n        {\\n            int j=i+1;\\n            int temp_ans=0;\\n            \\n            while(j<A.size() && A[j]>A[j-1])\\n            {\\n                j++;\\n                temp_ans++;\\n            }\\n            \\n            if(j==i+1 || j==A.size())\\n            {\\n                i=j;\\n                continue;\\n            }\\n            int k = j;\\n            while(j<A.size() && A[j]<A[j-1])\\n            {\\n                temp_ans++;\\n                j++;\\n            }\\n            if(j==k)\\n            {\\n                i=j;\\n                continue;\\n            }\\n            ans = max(ans,temp_ans+1);\\n            i=j-1;\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int ans=0;\\n        \\n        int i=0;\\n        while(i<A.size())\\n        {\\n            int j=i+1;\\n            int temp_ans=0;\\n            \\n            while(j<A.size() && A[j]>A[j-1])\\n            {\\n                j++;\\n                temp_ans++;\\n            }\\n            \\n            if(j==i+1 || j==A.size())\\n            {\\n                i=j;\\n                continue;\\n            }\\n            int k = j;\\n            while(j<A.size() && A[j]<A[j-1])\\n            {\\n                temp_ans++;\\n                j++;\\n            }\\n            if(j==k)\\n            {\\n                i=j;\\n                continue;\\n            }\\n            ans = max(ans,temp_ans+1);\\n            i=j-1;\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938770,
                "title": "python3-solution-with-comment",
                "content": "```\\nclass Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        res, n = 0, len(A)\\n\\t\\t\\n        if n < 3:  return 0\\n        \\n        for i in range(1, n-1):\\n\\t\\t\\t\\n\\t\\t\\t#if we find the peak, we start to count the length\\n            if A[i - 1] < A[i] > A[i + 1]:\\n\\t\\t\\t\\n\\t\\t\\t\\t#set up the left and right pointer\\n                l, r = i, i\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t#left part and right part\\n                lcur, rcur = 0, 0\\n                \\n\\t\\t\\t\\t#count the length of left part\\n                while l != 0:\\n                    if A[l-1] < A[l]:\\n                        lcur += 1\\n                        l -= 1\\n                    else: \\n                        break\\n\\n\\t\\t\\t\\t#count the length of right part\\n                while r != n - 1:\\n                    if A[r] > A[r + 1]:\\n                        rcur += 1\\n                        r += 1\\n                    else: \\n                        break\\n                 \\n\\t\\t\\t\\t#do not forget to add the peak, so here the total length = (left part + right part + 1)\\n                res = max(res, lcur + rcur + 1)\\n        \\n        return res \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        res, n = 0, len(A)\\n\\t\\t\\n        if n < 3:  return 0\\n        \\n        for i in range(1, n-1):\\n\\t\\t\\t\\n\\t\\t\\t#if we find the peak, we start to count the length\\n            if A[i - 1] < A[i] > A[i + 1]:\\n\\t\\t\\t\\n\\t\\t\\t\\t#set up the left and right pointer\\n                l, r = i, i\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t#left part and right part\\n                lcur, rcur = 0, 0\\n                \\n\\t\\t\\t\\t#count the length of left part\\n                while l != 0:\\n                    if A[l-1] < A[l]:\\n                        lcur += 1\\n                        l -= 1\\n                    else: \\n                        break\\n\\n\\t\\t\\t\\t#count the length of right part\\n                while r != n - 1:\\n                    if A[r] > A[r + 1]:\\n                        rcur += 1\\n                        r += 1\\n                    else: \\n                        break\\n                 \\n\\t\\t\\t\\t#do not forget to add the peak, so here the total length = (left part + right part + 1)\\n                res = max(res, lcur + rcur + 1)\\n        \\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 938498,
                "title": "longest-mountain-in-array-python-3",
                "content": "```\\n    def longestMountain(self, A: List[int]) -> int:\\n        lsize = 1\\n        rsize = 0\\n        mtnsize = 0\\n\\n        for idx in range(1, len(A)):\\n            if A[idx] > A[idx-1]:\\n                if rsize > 0:\\n                    mtnsize = max(mtnsize, lsize+rsize)\\n                    lsize = 1\\n                    rsize = 0\\n                lsize += 1\\n            elif lsize > 1 and A[idx] < A[idx-1]:\\n                rsize += 1\\n            else:\\n                if lsize > 1 and rsize >= 1:\\n                    mtnsize = max(mtnsize, lsize+rsize)\\n                lsize = 1\\n                rsize = 0\\n                    \\n        return max(mtnsize, lsize + rsize) if rsize > 0 else mtnsize\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def longestMountain(self, A: List[int]) -> int:\\n        lsize = 1\\n        rsize = 0\\n        mtnsize = 0\\n\\n        for idx in range(1, len(A)):\\n            if A[idx] > A[idx-1]:\\n                if rsize > 0:\\n                    mtnsize = max(mtnsize, lsize+rsize)\\n                    lsize = 1\\n                    rsize = 0\\n                lsize += 1\\n            elif lsize > 1 and A[idx] < A[idx-1]:\\n                rsize += 1\\n            else:\\n                if lsize > 1 and rsize >= 1:\\n                    mtnsize = max(mtnsize, lsize+rsize)\\n                lsize = 1\\n                rsize = 0\\n                    \\n        return max(mtnsize, lsize + rsize) if rsize > 0 else mtnsize\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 938198,
                "title": "java-clean-easy-to-understand-o-n-two-pass-solution",
                "content": "The idea is to check  if current index is a peak of mountain and then stretch to left and right to find the length of indexes included in this mountain.\\n**Upvote** if helpful :) \\n\\n``` \\npublic int longestMountain(int[] a) {\\n        int ans =0;\\n        if(a.length<3)\\n            return 0;\\n       for(int i=1;i<a.length-1;i++){\\n           if(a[i] > a[i-1] && a[i] > a[i+1]){  // Check if this index is a peak \\n             int left = leftDownHillLength(a,i-1);\\n             int right = rightDownHillLength(a,i+1);\\n             ans = Math.max(ans, 1+left+right);    \\n           }   \\n       }\\n       return ans; \\n    }\\n    \\n    \\n    public int leftDownHillLength(int[] a, int i){\\n        int count=0;\\n        while(i>=0 && a[i] < a[i+1]){\\n            count++;\\n            i--;\\n        }\\n        return count;\\n    }\\n    \\n    public int rightDownHillLength(int[] a, int i){\\n        int count=0;\\n        int n=a.length-1;\\n        while(i<=n && a[i-1] > a[i]){\\n            count++;\\n            i++;\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "The idea is to check  if current index is a peak of mountain and then stretch to left and right to find the length of indexes included in this mountain.\\n**Upvote** if helpful :) \\n\\n``` \\npublic int longestMountain(int[] a) {\\n        int ans =0;\\n        if(a.length<3)\\n            return 0;\\n       for(int i=1;i<a.length-1;i++){\\n           if(a[i] > a[i-1] && a[i] > a[i+1]){  // Check if this index is a peak \\n             int left = leftDownHillLength(a,i-1);\\n             int right = rightDownHillLength(a,i+1);\\n             ans = Math.max(ans, 1+left+right);    \\n           }   \\n       }\\n       return ans; \\n    }\\n    \\n    \\n    public int leftDownHillLength(int[] a, int i){\\n        int count=0;\\n        while(i>=0 && a[i] < a[i+1]){\\n            count++;\\n            i--;\\n        }\\n        return count;\\n    }\\n    \\n    public int rightDownHillLength(int[] a, int i){\\n        int count=0;\\n        int n=a.length-1;\\n        while(i<=n && a[i-1] > a[i]){\\n            count++;\\n            i++;\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 938147,
                "title": "c-real-one-pass-no-extra-while-s",
                "content": "I see most solutions that claim to be one-pass contain actually a \"while\" inside the main \"for\". While complexity is still O(n) I think the code is more difficult to follow than this solution.\\nThe idea is very similar to this python solution which contains a nice explanation: https://leetcode.com/explore/featured/card/november-leetcoding-challenge/566/week-3-november-15th-november-21st/3533/discuss/937652/Python-one-pass-O(1)-space-explained\\n\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int ans = 0;\\n        for (int i = 1, left = 0, status = \\'flat\\'; i < A.size(); i++) {\\n            if (A[i] > A[i - 1]) {\\n                if (status == \\'desc\\' || status == \\'flat\\') left = i - 1, status = \\'asc\\';\\n            } else if (A[i] < A[i - 1]) {\\n                if (status == \\'asc\\' || status == \\'desc\\') ans = max(ans, i - left + 1), status = \\'desc\\';\\n            } else {\\n                status = \\'flat\\';\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int ans = 0;\\n        for (int i = 1, left = 0, status = \\'flat\\'; i < A.size(); i++) {\\n            if (A[i] > A[i - 1]) {\\n                if (status == \\'desc\\' || status == \\'flat\\') left = i - 1, status = \\'asc\\';\\n            } else if (A[i] < A[i - 1]) {\\n                if (status == \\'asc\\' || status == \\'desc\\') ans = max(ans, i - left + 1), status = \\'desc\\';\\n            } else {\\n                status = \\'flat\\';\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937955,
                "title": "easier-solution-faster-than-92-28-python-with-complete-explanation",
                "content": "Runtime: **156 ms**, faster than **92.28%** of Python3 online submissions. \\n\\n**Complete Explanation of code through comments**\\n```\\nclass Solution:\\n    def longestMountain(self, a: List[int]) -> int:\\n        n = len(a) \\n        ind = 0 \\n        max_dist = 0\\n        flag = False # to determine whether the array ends with upwards hill or downwards hill \\n        while ind < n-1:\\n            if a[ind] < a[ind+1]: #check whether its the starting point of mountain\\n                start = ind\\n                # loops till the peak of the mountain\\n                while ind<n-1 and a[ind]<a[ind+1]: \\n                    ind+=1 \\n                    flag = False\\n                # loops from the peak to the ending of the hill \\n                while ind<n-1 and a[ind]>a[ind+1]:\\n                    ind+=1 \\n                    flag = True\\n                if flag: # incase of termination of array check whether the hill is downwards\\n                    dist = ind-start+1 \\n                    max_dist = max(max_dist, dist) #compare\\n            else:\\n                ind+=1\\n        return max_dist        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, a: List[int]) -> int:\\n        n = len(a) \\n        ind = 0 \\n        max_dist = 0\\n        flag = False # to determine whether the array ends with upwards hill or downwards hill \\n        while ind < n-1:\\n            if a[ind] < a[ind+1]: #check whether its the starting point of mountain\\n                start = ind\\n                # loops till the peak of the mountain\\n                while ind<n-1 and a[ind]<a[ind+1]: \\n                    ind+=1 \\n                    flag = False\\n                # loops from the peak to the ending of the hill \\n                while ind<n-1 and a[ind]>a[ind+1]:\\n                    ind+=1 \\n                    flag = True\\n                if flag: # incase of termination of array check whether the hill is downwards\\n                    dist = ind-start+1 \\n                    max_dist = max(max_dist, dist) #compare\\n            else:\\n                ind+=1\\n        return max_dist        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 937918,
                "title": "longestmountain-python3-one-pass-o-1-space",
                "content": "```python\\nclass Solution:\\n    def longestMountain(self, A: [int]) -> int:\\n        ret, cur, up = 0, 1, True\\n        for i in range(len(A) - 1):\\n            if A[i+1] == A[i]:\\n                ret, cur, up = max(cur, ret) if not up else ret, 1, True\\n                continue\\n            if up:\\n                cur += 1 if A[i+1] > A[i] else 0\\n                if cur <= 1:\\n                    continue\\n                if A[i+1] < A[i]:\\n                    cur, up = cur + 1, False\\n                    continue\\n            else:\\n                if A[i+1] > A[i]:\\n                    ret, cur, up = max(cur, ret), 1, True\\n                cur += 1\\n        return ret if (ret := max(ret, cur) if not up else ret) >= 3 else 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def longestMountain(self, A: [int]) -> int:\\n        ret, cur, up = 0, 1, True\\n        for i in range(len(A) - 1):\\n            if A[i+1] == A[i]:\\n                ret, cur, up = max(cur, ret) if not up else ret, 1, True\\n                continue\\n            if up:\\n                cur += 1 if A[i+1] > A[i] else 0\\n                if cur <= 1:\\n                    continue\\n                if A[i+1] < A[i]:\\n                    cur, up = cur + 1, False\\n                    continue\\n            else:\\n                if A[i+1] > A[i]:\\n                    ret, cur, up = max(cur, ret), 1, True\\n                cur += 1\\n        return ret if (ret := max(ret, cur) if not up else ret) >= 3 else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937906,
                "title": "java-using-direction-variable-o-n-tc-o-1-space",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        if(arr.length == 0) return 0;\\n        \\n        int max = 0;\\n        \\n        int currMax = 0;\\n        int prev = arr[0];\\n        \\n        int dir = 0;\\n        \\n        for(int i = 1; i < arr.length; i++){\\n            if(dir == -1 && (prev < arr[i] || prev == arr[i])){\\n                max = Math.max(max, currMax+1);\\n                currMax = 0;\\n            }\\n            \\n            if(prev == arr[i]){\\n                dir = 0;\\n                currMax = 0;\\n            }\\n            \\n            if(prev < arr[i]){\\n                dir = 1;\\n                currMax++;\\n            }\\n            \\n            if(dir != 0 && prev > arr[i]){\\n                dir = -1;\\n                currMax++;\\n            }\\n            \\n            prev = arr[i];\\n        }\\n        \\n        if(dir == -1){\\n            max = Math.max(max, currMax+1);\\n        }\\n        \\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        if(arr.length == 0) return 0;\\n        \\n        int max = 0;\\n        \\n        int currMax = 0;\\n        int prev = arr[0];\\n        \\n        int dir = 0;\\n        \\n        for(int i = 1; i < arr.length; i++){\\n            if(dir == -1 && (prev < arr[i] || prev == arr[i])){\\n                max = Math.max(max, currMax+1);\\n                currMax = 0;\\n            }\\n            \\n            if(prev == arr[i]){\\n                dir = 0;\\n                currMax = 0;\\n            }\\n            \\n            if(prev < arr[i]){\\n                dir = 1;\\n                currMax++;\\n            }\\n            \\n            if(dir != 0 && prev > arr[i]){\\n                dir = -1;\\n                currMax++;\\n            }\\n            \\n            prev = arr[i];\\n        }\\n        \\n        if(dir == -1){\\n            max = Math.max(max, currMax+1);\\n        }\\n        \\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937853,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn longest_mountain(a: Vec<i32>) -> i32 {\\n        let mut answer = 0;\\n        let mut i = 1;\\n        while i < a.len() {\\n            let (mut inc, mut dec) = (0, 0);\\n            while i < a.len() && a[i - 1] < a[i] {\\n                i += 1;\\n                inc += 1;\\n            }\\n            while i < a.len() && a[i - 1] > a[i] {\\n                i += 1;\\n                dec += 1;\\n            }\\n            if inc > 0 && dec > 0 {\\n                answer = std::cmp::max(answer, inc + dec + 1);\\n            }\\n            while i < a.len() && a[i - 1] == a[i] {\\n                i += 1;\\n            }\\n        }\\n        answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn longest_mountain(a: Vec<i32>) -> i32 {\\n        let mut answer = 0;\\n        let mut i = 1;\\n        while i < a.len() {\\n            let (mut inc, mut dec) = (0, 0);\\n            while i < a.len() && a[i - 1] < a[i] {\\n                i += 1;\\n                inc += 1;\\n            }\\n            while i < a.len() && a[i - 1] > a[i] {\\n                i += 1;\\n                dec += 1;\\n            }\\n            if inc > 0 && dec > 0 {\\n                answer = std::cmp::max(answer, inc + dec + 1);\\n            }\\n            while i < a.len() && a[i - 1] == a[i] {\\n                i += 1;\\n            }\\n        }\\n        answer\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 937818,
                "title": "java-find-peak-and-move-down",
                "content": "If you liked my solution, **please upvote my post**\\n\\n```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n\\t\\t// peak chould be at least 3 points\\n        if (A == null || A.length <= 2) return 0;\\n        \\n        int max = 0;\\n\\t\\t// starting from second and finishing pre-last\\n        for (int i = 1; i < A.length - 1; i++) {\\n            if (isPeak(i, A)) {\\n                int l = i - 1;\\n                int r = i + 1;\\n                int count = 3;\\n\\t\\t\\t\\t// move to left and count length\\n                while (l > 0) {\\n                    if (A[l] > A[l - 1]) {\\n                        l--;\\n                        count++;\\n                        continue;\\n                    }\\n                    break;\\n                }\\n\\t\\t\\t\\t// move to right and count length\\n                while (r < A.length - 1) {\\n                    if (A[r] > A[r + 1]) {\\n                        r++;\\n                        count++;\\n                        continue;\\n                    }\\n                    break;\\n                }\\n                max = Math.max(max, count);\\n                // not to check right side of the mountain again on the peak\\n                i = r;\\n            }\\n        }\\n        return max;\\n    }\\n\\t// check condition if point is peak\\n    private boolean isPeak(int i, int[] A) {\\n        return A[i - 1] < A[i] && A[i + 1] < A[i];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n\\t\\t// peak chould be at least 3 points\\n        if (A == null || A.length <= 2) return 0;\\n        \\n        int max = 0;\\n\\t\\t// starting from second and finishing pre-last\\n        for (int i = 1; i < A.length - 1; i++) {\\n            if (isPeak(i, A)) {\\n                int l = i - 1;\\n                int r = i + 1;\\n                int count = 3;\\n\\t\\t\\t\\t// move to left and count length\\n                while (l > 0) {\\n                    if (A[l] > A[l - 1]) {\\n                        l--;\\n                        count++;\\n                        continue;\\n                    }\\n                    break;\\n                }\\n\\t\\t\\t\\t// move to right and count length\\n                while (r < A.length - 1) {\\n                    if (A[r] > A[r + 1]) {\\n                        r++;\\n                        count++;\\n                        continue;\\n                    }\\n                    break;\\n                }\\n                max = Math.max(max, count);\\n                // not to check right side of the mountain again on the peak\\n                i = r;\\n            }\\n        }\\n        return max;\\n    }\\n\\t// check condition if point is peak\\n    private boolean isPeak(int i, int[] A) {\\n        return A[i - 1] < A[i] && A[i + 1] < A[i];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937774,
                "title": "longest-mountain-in-array-o-n-time-o-1-space-java",
                "content": "```\\npublic int longestMountain(int[] A) {\\n        int res = 0;\\n        int iCount = 0;\\n        int dCount = 0;\\n        for (int i = 0; i < A.length - 1; i++) {\\n            if (dCount > 0 && A[i] < A[i + 1] || A[i] == A[i + 1]) {\\n                iCount = dCount = 0;\\n            }\\n            if (A[i] < A[i + 1]) {\\n                iCount++;\\n            }\\n            if (A[i] > A[i + 1]) {\\n                dCount++;\\n            }\\n            if (iCount > 0 && dCount > 0 ){\\n              res = Math.max(res, iCount + dCount + 1);  \\n            } \\n        }\\n        return res;\\n        \\n    }",
                "solutionTags": [],
                "code": "```\\npublic int longestMountain(int[] A) {\\n        int res = 0;\\n        int iCount = 0;\\n        int dCount = 0;\\n        for (int i = 0; i < A.length - 1; i++) {\\n            if (dCount > 0 && A[i] < A[i + 1] || A[i] == A[i + 1]) {\\n                iCount = dCount = 0;\\n            }\\n            if (A[i] < A[i + 1]) {\\n                iCount++;\\n            }\\n            if (A[i] > A[i + 1]) {\\n                dCount++;\\n            }\\n            if (iCount > 0 && dCount > 0 ){\\n              res = Math.max(res, iCount + dCount + 1);  \\n            } \\n        }\\n        return res;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 937734,
                "title": "java-easy-one-pass-solution-o-1-space",
                "content": "```\\n   public int longestMountain(int[] nums) {\\n        int len = nums.length;\\n        if(len <= 2) return 0;\\n        int left = 1;\\n        int res = 0;\\n        while(left < len){\\n            if(nums[left] <= nums[left - 1]){\\n                left++;\\n                continue;\\n            }\\n            int cur = left - 1;\\n            while(left < len && nums[left] > nums[left - 1]){\\n                left++;\\n            }\\n            boolean isMountain = false;\\n            while(left < len && nums[left] < nums[left - 1]){\\n                isMountain = true;\\n                left++;\\n            }\\n            if(isMountain) res = Math.max(left - cur, res);       \\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n   public int longestMountain(int[] nums) {\\n        int len = nums.length;\\n        if(len <= 2) return 0;\\n        int left = 1;\\n        int res = 0;\\n        while(left < len){\\n            if(nums[left] <= nums[left - 1]){\\n                left++;\\n                continue;\\n            }\\n            int cur = left - 1;\\n            while(left < len && nums[left] > nums[left - 1]){\\n                left++;\\n            }\\n            boolean isMountain = false;\\n            while(left < len && nums[left] < nums[left - 1]){\\n                isMountain = true;\\n                left++;\\n            }\\n            if(isMountain) res = Math.max(left - cur, res);       \\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 937687,
                "title": "longest-mountain-in-array-with-constrain-and-without-constrain-both-solutions",
                "content": "Without the constraints. dp solution\\n\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        if(!A.size()) return 0;\\n        int ans = 0;\\n        vector<int> forw(A.size(), 0), back(A.size(), 0);\\n        for(int i=1;i<A.size();i++) if(A[i] > A[i-1]) back[i] = 1 + back[i-1];\\n        for(int i=A.size()-2;i>=0;i--) if(A[i] > A[i+1]) forw[i] = 1 + forw[i+1];\\n        for(int i=1;i<A.size()-1;i++){\\n            if(back[i] > 0 && forw[i] > 0) ans = max(ans, back[i] + forw[i] +1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nWith constraint O(1) space and 1 traversal solution:\\n\\n```\\nclass Solution {\\npublic:\\n    int increasing(vector<int>& A, int index){\\n        for(;index<A.size()-1;index++) if(A[index+1] <= A[index]) break;\\n        return index;\\n    }\\n    int decreasing(vector<int>& A, int index){\\n        for(;index<A.size()-1;index++) if(A[index+1] >= A[index]) break;\\n        return index;\\n    }\\n    int longestMountain(vector<int>& A) {\\n        int i = 0;\\n        int ans = 0;\\n        bool up = true;\\n        int increasingElements = 0;\\n        int newIndex = 0;\\n        while(i<A.size()){\\n            if(up){\\n                newIndex = increasing(A, i);\\n                increasingElements = newIndex - i;\\n                if(increasingElements) up^=1;\\n                else newIndex++;\\n            } else{\\n                newIndex = decreasing(A, i);\\n                if((newIndex - i)) ans = max(ans, (newIndex - i + increasingElements +1));\\n                increasingElements = 0;\\n                up^=1;\\n            }\\n            i = newIndex;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        if(!A.size()) return 0;\\n        int ans = 0;\\n        vector<int> forw(A.size(), 0), back(A.size(), 0);\\n        for(int i=1;i<A.size();i++) if(A[i] > A[i-1]) back[i] = 1 + back[i-1];\\n        for(int i=A.size()-2;i>=0;i--) if(A[i] > A[i+1]) forw[i] = 1 + forw[i+1];\\n        for(int i=1;i<A.size()-1;i++){\\n            if(back[i] > 0 && forw[i] > 0) ans = max(ans, back[i] + forw[i] +1);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int increasing(vector<int>& A, int index){\\n        for(;index<A.size()-1;index++) if(A[index+1] <= A[index]) break;\\n        return index;\\n    }\\n    int decreasing(vector<int>& A, int index){\\n        for(;index<A.size()-1;index++) if(A[index+1] >= A[index]) break;\\n        return index;\\n    }\\n    int longestMountain(vector<int>& A) {\\n        int i = 0;\\n        int ans = 0;\\n        bool up = true;\\n        int increasingElements = 0;\\n        int newIndex = 0;\\n        while(i<A.size()){\\n            if(up){\\n                newIndex = increasing(A, i);\\n                increasingElements = newIndex - i;\\n                if(increasingElements) up^=1;\\n                else newIndex++;\\n            } else{\\n                newIndex = decreasing(A, i);\\n                if((newIndex - i)) ans = max(ans, (newIndex - i + increasingElements +1));\\n                increasingElements = 0;\\n                up^=1;\\n            }\\n            i = newIndex;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 932167,
                "title": "not-the-shortest-but-intuitive-one-single-pass-o-n",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] a) {\\n        int end=0,begin=0;\\n        int maxm = Integer.MIN_VALUE;\\n        //find the first rising point\\n        while(begin < a.length-1 &&  a[begin]>=a[begin+1]){\\n            begin++;\\n        }\\n        end = begin;\\n        //To handle if list of duplicates only\\n        if(end>=a.length-1)\\n            return 0;\\n        //Variables to check if mountain condition satisfied\\n        boolean up = false, down=false;\\n        while(end < a.length-1){\\n            up=false;down=false;\\n            // time to check a mountain\\n            if(a[end] < a[end+1]){\\n               while(end<a.length-1 && a[end]<a[end+1]) {end++;up=true;}\\n               while(end<a.length-1  && a[end]>a[end+1]) {end++;down=true;}\\n               if(up==true && down==true){\\n                   maxm = Math.max(maxm,end-begin+1);\\n                    up=false;down=false;\\n                }\\n                begin=end;\\n            }\\n            else{\\n                end++;\\n                begin++;\\n            }\\n        }\\n         if(up==true && down==true){\\n              maxm=Math.max(maxm,end-begin+1);\\n         }\\n        return (maxm == Integer.MIN_VALUE || maxm<3)?0 : maxm;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] a) {\\n        int end=0,begin=0;\\n        int maxm = Integer.MIN_VALUE;\\n        //find the first rising point\\n        while(begin < a.length-1 &&  a[begin]>=a[begin+1]){\\n            begin++;\\n        }\\n        end = begin;\\n        //To handle if list of duplicates only\\n        if(end>=a.length-1)\\n            return 0;\\n        //Variables to check if mountain condition satisfied\\n        boolean up = false, down=false;\\n        while(end < a.length-1){\\n            up=false;down=false;\\n            // time to check a mountain\\n            if(a[end] < a[end+1]){\\n               while(end<a.length-1 && a[end]<a[end+1]) {end++;up=true;}\\n               while(end<a.length-1  && a[end]>a[end+1]) {end++;down=true;}\\n               if(up==true && down==true){\\n                   maxm = Math.max(maxm,end-begin+1);\\n                    up=false;down=false;\\n                }\\n                begin=end;\\n            }\\n            else{\\n                end++;\\n                begin++;\\n            }\\n        }\\n         if(up==true && down==true){\\n              maxm=Math.max(maxm,end-begin+1);\\n         }\\n        return (maxm == Integer.MIN_VALUE || maxm<3)?0 : maxm;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887801,
                "title": "1-pass-python-o-1-space",
                "content": "```class Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        j,k=0,0\\n        ans=0\\n        for i in range(1,len(A)):\\n            if(A[i]-A[i-1]>0):\\n                if(k>0):\\n                    ans=max(ans,j+k+1)\\n                    j=1\\n                    k=0\\n                else:\\n                    j+=1\\n            elif(A[i]-A[i-1]<0):\\n                if(j>0):\\n                    k+=1\\n            else:\\n                if(k!=0 and j!=0):\\n                    ans=max(ans,j+k+1)\\n                j=0\\n                k=0\\n        if(k!=0 and j!=0):\\n            ans=max(ans,j+k+1)\\n        return ans\\n",
                "solutionTags": [],
                "code": "```class Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        j,k=0,0\\n        ans=0\\n        for i in range(1,len(A)):\\n            if(A[i]-A[i-1]>0):\\n                if(k>0):\\n                    ans=max(ans,j+k+1)\\n                    j=1\\n                    k=0\\n                else:\\n                    j+=1\\n            elif(A[i]-A[i-1]<0):\\n                if(j>0):\\n                    k+=1\\n            else:\\n                if(k!=0 and j!=0):\\n                    ans=max(ans,j+k+1)\\n                j=0\\n                k=0\\n        if(k!=0 and j!=0):\\n            ans=max(ans,j+k+1)\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 881817,
                "title": "simple-c-approach-91-5",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int n=A.size(); \\n        if(n==0)return 0;\\n        int inc[n];\\n        int dec[n];\\n        //inc[i] stores length of increasing subarray till index i;\\n        inc[0]=1;\\n        for(int i=1;i<n;i++){\\n            inc[i]=A[i]>A[i-1]?inc[i-1]+1:1;\\n        }\\n          //dec[i] stores the length of decreasing subarray starting at index i\\n        dec[n-1]=1;\\n        for(int i=n-2;i>=0;i--){\\n            dec[i]=A[i]>A[i+1]?dec[i+1]+1:1;\\n        }\\n        \\n        int len=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            if(dec[i]>1 && inc[i]>1 && len<dec[i]+inc[i]-1) len=inc[i]+dec[i]-1;\\n        }\\n        \\n        cout<<len<<endl;\\n        return len<3?0:len;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int n=A.size(); \\n        if(n==0)return 0;\\n        int inc[n];\\n        int dec[n];\\n        //inc[i] stores length of increasing subarray till index i;\\n        inc[0]=1;\\n        for(int i=1;i<n;i++){\\n            inc[i]=A[i]>A[i-1]?inc[i-1]+1:1;\\n        }\\n          //dec[i] stores the length of decreasing subarray starting at index i\\n        dec[n-1]=1;\\n        for(int i=n-2;i>=0;i--){\\n            dec[i]=A[i]>A[i+1]?dec[i+1]+1:1;\\n        }\\n        \\n        int len=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            if(dec[i]>1 && inc[i]>1 && len<dec[i]+inc[i]-1) len=inc[i]+dec[i]-1;\\n        }\\n        \\n        cout<<len<<endl;\\n        return len<3?0:len;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 857132,
                "title": "naive-c-1-pass-and-o-1-space",
                "content": "```\\npublic class Solution {\\n    public int LongestMountain(int[] A) {\\n        var max = 0;\\n        var up = 0;\\n        var mountainLength = 0;\\n        \\n        for(var i = 1; i < A.Length; i++)\\n        {\\n            if(A[i] > A[i-1])\\n            {\\n                mountainLength = ++up;\\n                continue;\\n            }\\n            if(A[i] < A[i-1])\\n            {\\n                if(mountainLength == 0)\\n                    continue;\\n                mountainLength++;\\n            }\\n            else{\\n                mountainLength = 0;\\n            }\\n            up = 0;\\n            max = Math.Max(max, mountainLength > 0 && up == 0 ? mountainLength + 1 : 0);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int LongestMountain(int[] A) {\\n        var max = 0;\\n        var up = 0;\\n        var mountainLength = 0;\\n        \\n        for(var i = 1; i < A.Length; i++)\\n        {\\n            if(A[i] > A[i-1])\\n            {\\n                mountainLength = ++up;\\n                continue;\\n            }\\n            if(A[i] < A[i-1])\\n            {\\n                if(mountainLength == 0)\\n                    continue;\\n                mountainLength++;\\n            }\\n            else{\\n                mountainLength = 0;\\n            }\\n            up = 0;\\n            max = Math.Max(max, mountainLength > 0 && up == 0 ? mountainLength + 1 : 0);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 852833,
                "title": "c-solution-one-pass-two-pointer",
                "content": "Runtime: 40 ms, faster than 86.10% of C++ online submissions for Longest Mountain in Array.\\nMemory Usage: 18.5 MB, less than 75.29% of C++ online submissions for Longest Mountain in Array.\\n\\nhttps://leetcode.com/problems/longest-mountain-in-array/discuss/773237/C++-Two-pointer-solution\\n\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n\\n        int n = A.size();\\n        if(n<3) return 0;\\n        \\n        int maxL = 0;\\n        int i = 0;\\n        int up = 0;\\n        int down = 0;\\n        while(i<n)\\n        {\\n            // track the up and down scenario  in the mountain\\n            up = 0; down = 0;\\n            \\n            // check if we can go up and count up length\\n            while(i<n-1 && A[i]<A[i+1])i++,up++;\\n            \\n            // check if we can go down and also check if up is valid and count down length\\n            while(i<n-1 && A[i]>A[i+1] && up)i++,down++;\\n            \\n            // if there is a up and down then count length as up+down+1 (including peek)\\n            if(up && down)\\n                maxL  = max(maxL,up + down + 1);\\n            else\\n                i++;\\n        }\\n        \\n        return maxL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n\\n        int n = A.size();\\n        if(n<3) return 0;\\n        \\n        int maxL = 0;\\n        int i = 0;\\n        int up = 0;\\n        int down = 0;\\n        while(i<n)\\n        {\\n            // track the up and down scenario  in the mountain\\n            up = 0; down = 0;\\n            \\n            // check if we can go up and count up length\\n            while(i<n-1 && A[i]<A[i+1])i++,up++;\\n            \\n            // check if we can go down and also check if up is valid and count down length\\n            while(i<n-1 && A[i]>A[i+1] && up)i++,down++;\\n            \\n            // if there is a up and down then count length as up+down+1 (including peek)\\n            if(up && down)\\n                maxL  = max(maxL,up + down + 1);\\n            else\\n                i++;\\n        }\\n        \\n        return maxL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 830281,
                "title": "java-bitonic",
                "content": "public int longestMountain(int[] A) {\\n        //extension of bitonic array \\n        \\n    /*  2  1  4  7  3  2  5\\n        0  0  1  2  0  0  1 //increasing from left to right pass(khud se start kru ya purane k saath add hu)\\n                          \\n        1  0  0  2  1  0  0//increasing from right to left\\n        \\n        2  -  2  5  2  -  - //add both+1 */\\n            \\n      int[] lefttoright=new int[A.length];\\n      int[] righttoleft=new int[A.length];\\n        int max=0;\\n        for(int start=1;start<=A.length-1;start++){\\n            if(A[start]>A[start-1]){\\n            lefttoright[start]=lefttoright[start-1]+1;\\n            }else{\\n                lefttoright[start]=0;\\n            }\\n        }\\n        for(int end=A.length-2;end>=0;end--){\\n           if(A[end]>A[end+1]){\\n                righttoleft[end]=righttoleft[end+1]+1;\\n            }else{\\n                righttoleft[end]=0;\\n            } \\n        }\\n        //calculate max(sum)+1 (Now include element if only it increasing from both side)\\n        for(int s=0;s<A.length;s++){\\n            if(lefttoright[s]>0 && righttoleft[s]>0){\\n            int ans=lefttoright[s]+righttoleft[s]+1;\\n            max=Math.max(ans,max);\\n            }\\n        }\\n    return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "public int longestMountain(int[] A) {\\n        //extension of bitonic array \\n        \\n    /*  2  1  4  7  3  2  5\\n        0  0  1  2  0  0  1 //increasing from left to right pass(khud se start kru ya purane k saath add hu)\\n                          \\n        1  0  0  2  1  0  0//increasing from right to left\\n        \\n        2  -  2  5  2  -  - //add both+1 */\\n            \\n      int[] lefttoright=new int[A.length];\\n      int[] righttoleft=new int[A.length];\\n        int max=0;\\n        for(int start=1;start<=A.length-1;start++){\\n            if(A[start]>A[start-1]){\\n            lefttoright[start]=lefttoright[start-1]+1;\\n            }else{\\n                lefttoright[start]=0;\\n            }\\n        }\\n        for(int end=A.length-2;end>=0;end--){\\n           if(A[end]>A[end+1]){\\n                righttoleft[end]=righttoleft[end+1]+1;\\n            }else{\\n                righttoleft[end]=0;\\n            } \\n        }\\n        //calculate max(sum)+1 (Now include element if only it increasing from both side)\\n        for(int s=0;s<A.length;s++){\\n            if(lefttoright[s]>0 && righttoleft[s]>0){\\n            int ans=lefttoright[s]+righttoleft[s]+1;\\n            max=Math.max(ans,max);\\n            }\\n        }\\n    return max;\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 796410,
                "title": "well-commented-c-code-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& a) {\\n        int n=a.size();\\n        int i=0,start=0,top=-1,len=0;\\n        while(i<n-1)\\n        {\\n            while(i<n-1 and a[i]>=a[i+1]) i++,start++;  //checking where the hill starts\\n            if(i==n-1) break;   //if hill doesn\\'t start eg. 2 2 2\\n            while(i<n-1 and a[i]<a[i+1]) i++,top=i; //incrementing untill we find a hill top\\n            while(i<n-1 and a[i]>a[i+1]) i++;   //going downhill after finding a top\\n            if(top<i) len = max(len,i-start+1); //checking if a value exists after hill top\\n            start=i;    //staring from this position for the next hill\\n        }\\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& a) {\\n        int n=a.size();\\n        int i=0,start=0,top=-1,len=0;\\n        while(i<n-1)\\n        {\\n            while(i<n-1 and a[i]>=a[i+1]) i++,start++;  //checking where the hill starts\\n            if(i==n-1) break;   //if hill doesn\\'t start eg. 2 2 2\\n            while(i<n-1 and a[i]<a[i+1]) i++,top=i; //incrementing untill we find a hill top\\n            while(i<n-1 and a[i]>a[i+1]) i++;   //going downhill after finding a top\\n            if(top<i) len = max(len,i-start+1); //checking if a value exists after hill top\\n            start=i;    //staring from this position for the next hill\\n        }\\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796409,
                "title": "c-1-pass-solution-o-n-time-o-1-space-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& a) {\\n        int n=a.size();int i=0,start=0,top=-1,len=0;\\n        while(i<n)\\n        {   //find the start of mountain\\n            while(i<n-1 and a[i]>=a[i+1]) i++,start++;\\n            if(i==n-1) break;\\n            //see if the peak is really the peak\\n            while(i<n-1 and a[i]<a[i+1]) i++,top=i;\\n            //find the end of mountain\\n            while(i<n-1 and a[i]>a[i+1]) i++;\\n            //calculate the total length\\n            if(top<i) len=max(len,i-start+1);\\n            start=i;\\n        }\\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& a) {\\n        int n=a.size();int i=0,start=0,top=-1,len=0;\\n        while(i<n)\\n        {   //find the start of mountain\\n            while(i<n-1 and a[i]>=a[i+1]) i++,start++;\\n            if(i==n-1) break;\\n            //see if the peak is really the peak\\n            while(i<n-1 and a[i]<a[i+1]) i++,top=i;\\n            //find the end of mountain\\n            while(i<n-1 and a[i]>a[i+1]) i++;\\n            //calculate the total length\\n            if(top<i) len=max(len,i-start+1);\\n            start=i;\\n        }\\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760497,
                "title": "detailed-explanation-with-java-o-n-time-and-o-1-space",
                "content": "\\n```\\n public int longestMountain(int[] array) {\\n        int longestLength = 0;\\n        int i = 1;\\n        while(i < array.length - 1){\\n            boolean isPeak = array[i - 1] < array[i] && array[i] > array[i + 1];\\n            \\n            if(!isPeak){\\n                i++;\\n                continue;\\n            }\\n            \\n            int leftIdx = i - 2;\\n            while(leftIdx >=0 && array[leftIdx] < array[leftIdx + 1]){\\n                leftIdx--;\\n            }\\n            \\n            int rightIdx = i + 2;\\n            while(rightIdx < array.length && array[rightIdx - 1] > array[rightIdx]){\\n                rightIdx++;\\n            }\\n            \\n            int currentLength = rightIdx - leftIdx - 1;\\n            if(currentLength > longestLength){\\n                longestLength = currentLength;\\n            }\\n            i = rightIdx;\\n        }\\n        return longestLength;\\n    }\\n```\\n\\n\\n**Intuition**:\\nFirst you have to know if a number is a peak. Once you know the peak you need to expand to its both directions and calulate its length along the way. Keep updating the length by comparing it with length of other peaks and choose the longest length.\\n\\n\\n**Algorithm**:\\nSo we first have to know if the current number is the peak. Start traversing the array from left to right. If a current value satisfies the peak condition then store the boolean result in a variable call it \\'isPeak\\'. Note that traversal will start from the second element, because it doesnt make sense to check if the first element is a peak, because it cant be, according to the definition of a peak.\\n\\nCondition: array[ i - 1 ] < array[ i ] && array[ i ] > array[ i + 1 ]\\n\\nThe reason to use a boolean variable is just for simplying the code. Otherwise you can directly write a peak condition inside the if construct.\\n\\nLets move on, \\n\\nIf the current value is not a peak then we dont do anything in this iteration, simply increment the iterator \\'i\\' and just continue with the search for a peak on to the next element.\\n\\nIf we have the peak:\\nThen we have to expand to the right and left, so long as we have strictly decreasing integers in either directions.\\n\\n**Lets expand to the left first:**\\nWe already know the left( i - 1 ) of the current element (i) is smaller. So we dont have to check that again. We start from i - 2. Hence we define a variable leftIdx initialized to i - 2\\n\\nNow we iterate through the left part backwords. As long as our leftIdx is in the bounds and array[leftIdx] < array[leftIdx + 1] . Keep decrementing the leftIdx. So that we can keep checking all values to the left. At the end leftIdx, will hold the index of the element from where the peak began.\\n\\n\\n**Lets expand to the right now:**\\nWe already know that the right ( i + 1 ) of the current element ( i ) is greater. So we dont have to check that again. We start from i + 2\\n\\nNow iterate through the right part forwards. As long as our rightIdx is in the bounds and array[ rightIdx - 1 ]  >  array[ i ]. Keep increamenting the rightIdx.  So that we can keep checking all values to the right. At the end rightIdx, will hold the index of the element to where the peak ends.\\n\\nNow get the currentPeakLength by doing rightIdx - leftIdx - 1 \\nAnd compare it with the longestPeakLength,  and return the longest amongst them.\\n\\n\\nTo increment the iteration variable i, do this:\\ni = rightIdx\\n\\nWhy it works ?. The rightIdx holds the location of a and end of a peak. All the element between a peak and this rightIdx, were in a strictly decreasing manner. So it doesnt make a sense to check values before the rightIdx.\\n\\n\\n**Complexity Analysis**\\n\\nTime: O(n), How many times do we visit every element in the array ? There are few cases to consider. Lets say you have strictly increasing or strictly decreasing or a flat array. Then there is no peak. In all these three cases you visit each element once. But when we find a peak, we have to expand to left and right. There can be multiple peaks to expand. All these expansion is also a visit. So in this case too we are visiting each element for once at least. And then we visit every element at most 2-3 times. It converges to O(N)\\n\\n*Please correct me if you find that I misunderstood something in the explaination*",
                "solutionTags": [],
                "code": "```\\n public int longestMountain(int[] array) {\\n        int longestLength = 0;\\n        int i = 1;\\n        while(i < array.length - 1){\\n            boolean isPeak = array[i - 1] < array[i] && array[i] > array[i + 1];\\n            \\n            if(!isPeak){\\n                i++;\\n                continue;\\n            }\\n            \\n            int leftIdx = i - 2;\\n            while(leftIdx >=0 && array[leftIdx] < array[leftIdx + 1]){\\n                leftIdx--;\\n            }\\n            \\n            int rightIdx = i + 2;\\n            while(rightIdx < array.length && array[rightIdx - 1] > array[rightIdx]){\\n                rightIdx++;\\n            }\\n            \\n            int currentLength = rightIdx - leftIdx - 1;\\n            if(currentLength > longestLength){\\n                longestLength = currentLength;\\n            }\\n            i = rightIdx;\\n        }\\n        return longestLength;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 749845,
                "title": "python-3-explanation",
                "content": "* Iterate through `A` and look for a mountain \\'peak\\', that is, where the numbers **either side of the current number** are less than the current number.\\n* Once we find a peak, we set two pointers `left` and `right` to start from the current index `i`.\\n\\t* These two pointers will \\'descend\\' down the mountain until either:\\n\\t1. They go out of range of `A`.\\n\\t2. The downward slope of the mountain stops.\\n* Once we have gotten to the base of the current mountain spanning outwards from index `i`, we find the `mountainLength` by taking the difference of `right` and `left` and add one to count the peak as well.\\n```\\nclass Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        if len(A) < 3:\\n            return 0\\n        \\n        longestMountain = 0\\n\\n        for i in range(1, len(A) - 1):\\n            # Index i denotes a \\'peak\\' in the mountain.\\n            if A[i - 1] < A[i] > A[i + 1]:\\n                left = right = i\\n                \\n                # Traverse left and down the mountain from i until there is no longer a downwards slope.\\n                while left > 0 and A[left - 1] < A[left]:\\n                    left -= 1\\n                                \\n                # Traverse right and down the mountain from i until there is no longer a downwards slope.\\n                while right + 1 < len(A) and A[right + 1] < A[right]:\\n                    right += 1\\n                    \\n                # The length of the mountain will be the distance from left and right (+ 1 to factor in the peak).\\n                mountainLength = right - left + 1\\n                longestMountain = max(longestMountain, mountainLength)\\n        \\n        return longestMountain\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        if len(A) < 3:\\n            return 0\\n        \\n        longestMountain = 0\\n\\n        for i in range(1, len(A) - 1):\\n            # Index i denotes a \\'peak\\' in the mountain.\\n            if A[i - 1] < A[i] > A[i + 1]:\\n                left = right = i\\n                \\n                # Traverse left and down the mountain from i until there is no longer a downwards slope.\\n                while left > 0 and A[left - 1] < A[left]:\\n                    left -= 1\\n                                \\n                # Traverse right and down the mountain from i until there is no longer a downwards slope.\\n                while right + 1 < len(A) and A[right + 1] < A[right]:\\n                    right += 1\\n                    \\n                # The length of the mountain will be the distance from left and right (+ 1 to factor in the peak).\\n                mountainLength = right - left + 1\\n                longestMountain = max(longestMountain, mountainLength)\\n        \\n        return longestMountain\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1773841,
                "content": [
                    {
                        "username": "om_golhani",
                        "content": "Tip : Try to think it as Longest Biotonic Subarray.\\nUse the concept of Longest Increasing Subarray and Longest Decreasing Subarray to find the longest mountain in array."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "So hard... edge cases are SOOOO annoying..."
                    },
                    {
                        "username": "Sakettiwari",
                        "content": "Check these cases !\nThank me later ;)\nUPVOTE IF IT HELPED\n\n[0,2,0,0,2,0,2,1,1,0,2,1,0,0,1,0,2,1,2,0,1,1,0,2,2,1,2,2,0,0,0,1,0,2,0,0,1,2,0,1,0,2,0,2,0,0,0,0,2,1,0,0,0,0,1,0,2,1,2,2,1,0,0,1,0,2,0,0,0,2,1,0,1,2,1,0,1,0,2,1,0,2,0,2,1,1,2,0,1,0,1,1,1,1,2,1,2,2,2,0]\n\n\n[0,1,2,0]\n\n[875,884,239,731,723,685]\n\n[2,3,1,2,3,4,5,6]\n\n[0]\n\n[1,2,3,4,5]\n\n[5,4,3,2,1]\n\n[0,1,2,3,4,5,4,3,2,1,0]\n"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Nice work"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "The edge cases were a bit tedious to address but I\\'m surprised I managed to solve the initial code relatively quickly!"
                    },
                    {
                        "username": "HARSH_252525",
                        "content": "just traverse an array/vector and check for lower and greater conditions given in question(check for mountain) and simply take two counters one for each subarray that satisfy given condition and one for final answer"
                    },
                    {
                        "username": "spookie886",
                        "content": "Hate to be that guy but this should be an easy problem"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Try these :- \\n\\n[0,1,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,1,1,1,0,0,0,1,0,1,1]\\n\\n[5770,9921,1853,441,6808,8847,9186,3091,1524,2415]\\n\\n[0,2,0,2,1,2,3,4,4,1]"
                    }
                ]
            },
            {
                "id": 1737004,
                "content": [
                    {
                        "username": "om_golhani",
                        "content": "Tip : Try to think it as Longest Biotonic Subarray.\\nUse the concept of Longest Increasing Subarray and Longest Decreasing Subarray to find the longest mountain in array."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "So hard... edge cases are SOOOO annoying..."
                    },
                    {
                        "username": "Sakettiwari",
                        "content": "Check these cases !\nThank me later ;)\nUPVOTE IF IT HELPED\n\n[0,2,0,0,2,0,2,1,1,0,2,1,0,0,1,0,2,1,2,0,1,1,0,2,2,1,2,2,0,0,0,1,0,2,0,0,1,2,0,1,0,2,0,2,0,0,0,0,2,1,0,0,0,0,1,0,2,1,2,2,1,0,0,1,0,2,0,0,0,2,1,0,1,2,1,0,1,0,2,1,0,2,0,2,1,1,2,0,1,0,1,1,1,1,2,1,2,2,2,0]\n\n\n[0,1,2,0]\n\n[875,884,239,731,723,685]\n\n[2,3,1,2,3,4,5,6]\n\n[0]\n\n[1,2,3,4,5]\n\n[5,4,3,2,1]\n\n[0,1,2,3,4,5,4,3,2,1,0]\n"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Nice work"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "The edge cases were a bit tedious to address but I\\'m surprised I managed to solve the initial code relatively quickly!"
                    },
                    {
                        "username": "HARSH_252525",
                        "content": "just traverse an array/vector and check for lower and greater conditions given in question(check for mountain) and simply take two counters one for each subarray that satisfy given condition and one for final answer"
                    },
                    {
                        "username": "spookie886",
                        "content": "Hate to be that guy but this should be an easy problem"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Try these :- \\n\\n[0,1,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,1,1,1,0,0,0,1,0,1,1]\\n\\n[5770,9921,1853,441,6808,8847,9186,3091,1524,2415]\\n\\n[0,2,0,2,1,2,3,4,4,1]"
                    }
                ]
            },
            {
                "id": 1801992,
                "content": [
                    {
                        "username": "om_golhani",
                        "content": "Tip : Try to think it as Longest Biotonic Subarray.\\nUse the concept of Longest Increasing Subarray and Longest Decreasing Subarray to find the longest mountain in array."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "So hard... edge cases are SOOOO annoying..."
                    },
                    {
                        "username": "Sakettiwari",
                        "content": "Check these cases !\nThank me later ;)\nUPVOTE IF IT HELPED\n\n[0,2,0,0,2,0,2,1,1,0,2,1,0,0,1,0,2,1,2,0,1,1,0,2,2,1,2,2,0,0,0,1,0,2,0,0,1,2,0,1,0,2,0,2,0,0,0,0,2,1,0,0,0,0,1,0,2,1,2,2,1,0,0,1,0,2,0,0,0,2,1,0,1,2,1,0,1,0,2,1,0,2,0,2,1,1,2,0,1,0,1,1,1,1,2,1,2,2,2,0]\n\n\n[0,1,2,0]\n\n[875,884,239,731,723,685]\n\n[2,3,1,2,3,4,5,6]\n\n[0]\n\n[1,2,3,4,5]\n\n[5,4,3,2,1]\n\n[0,1,2,3,4,5,4,3,2,1,0]\n"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Nice work"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "The edge cases were a bit tedious to address but I\\'m surprised I managed to solve the initial code relatively quickly!"
                    },
                    {
                        "username": "HARSH_252525",
                        "content": "just traverse an array/vector and check for lower and greater conditions given in question(check for mountain) and simply take two counters one for each subarray that satisfy given condition and one for final answer"
                    },
                    {
                        "username": "spookie886",
                        "content": "Hate to be that guy but this should be an easy problem"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Try these :- \\n\\n[0,1,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,1,1,1,0,0,0,1,0,1,1]\\n\\n[5770,9921,1853,441,6808,8847,9186,3091,1524,2415]\\n\\n[0,2,0,2,1,2,3,4,4,1]"
                    }
                ]
            },
            {
                "id": 1970341,
                "content": [
                    {
                        "username": "om_golhani",
                        "content": "Tip : Try to think it as Longest Biotonic Subarray.\\nUse the concept of Longest Increasing Subarray and Longest Decreasing Subarray to find the longest mountain in array."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "So hard... edge cases are SOOOO annoying..."
                    },
                    {
                        "username": "Sakettiwari",
                        "content": "Check these cases !\nThank me later ;)\nUPVOTE IF IT HELPED\n\n[0,2,0,0,2,0,2,1,1,0,2,1,0,0,1,0,2,1,2,0,1,1,0,2,2,1,2,2,0,0,0,1,0,2,0,0,1,2,0,1,0,2,0,2,0,0,0,0,2,1,0,0,0,0,1,0,2,1,2,2,1,0,0,1,0,2,0,0,0,2,1,0,1,2,1,0,1,0,2,1,0,2,0,2,1,1,2,0,1,0,1,1,1,1,2,1,2,2,2,0]\n\n\n[0,1,2,0]\n\n[875,884,239,731,723,685]\n\n[2,3,1,2,3,4,5,6]\n\n[0]\n\n[1,2,3,4,5]\n\n[5,4,3,2,1]\n\n[0,1,2,3,4,5,4,3,2,1,0]\n"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Nice work"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "The edge cases were a bit tedious to address but I\\'m surprised I managed to solve the initial code relatively quickly!"
                    },
                    {
                        "username": "HARSH_252525",
                        "content": "just traverse an array/vector and check for lower and greater conditions given in question(check for mountain) and simply take two counters one for each subarray that satisfy given condition and one for final answer"
                    },
                    {
                        "username": "spookie886",
                        "content": "Hate to be that guy but this should be an easy problem"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Try these :- \\n\\n[0,1,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,1,1,1,0,0,0,1,0,1,1]\\n\\n[5770,9921,1853,441,6808,8847,9186,3091,1524,2415]\\n\\n[0,2,0,2,1,2,3,4,4,1]"
                    }
                ]
            },
            {
                "id": 1959957,
                "content": [
                    {
                        "username": "om_golhani",
                        "content": "Tip : Try to think it as Longest Biotonic Subarray.\\nUse the concept of Longest Increasing Subarray and Longest Decreasing Subarray to find the longest mountain in array."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "So hard... edge cases are SOOOO annoying..."
                    },
                    {
                        "username": "Sakettiwari",
                        "content": "Check these cases !\nThank me later ;)\nUPVOTE IF IT HELPED\n\n[0,2,0,0,2,0,2,1,1,0,2,1,0,0,1,0,2,1,2,0,1,1,0,2,2,1,2,2,0,0,0,1,0,2,0,0,1,2,0,1,0,2,0,2,0,0,0,0,2,1,0,0,0,0,1,0,2,1,2,2,1,0,0,1,0,2,0,0,0,2,1,0,1,2,1,0,1,0,2,1,0,2,0,2,1,1,2,0,1,0,1,1,1,1,2,1,2,2,2,0]\n\n\n[0,1,2,0]\n\n[875,884,239,731,723,685]\n\n[2,3,1,2,3,4,5,6]\n\n[0]\n\n[1,2,3,4,5]\n\n[5,4,3,2,1]\n\n[0,1,2,3,4,5,4,3,2,1,0]\n"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Nice work"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "The edge cases were a bit tedious to address but I\\'m surprised I managed to solve the initial code relatively quickly!"
                    },
                    {
                        "username": "HARSH_252525",
                        "content": "just traverse an array/vector and check for lower and greater conditions given in question(check for mountain) and simply take two counters one for each subarray that satisfy given condition and one for final answer"
                    },
                    {
                        "username": "spookie886",
                        "content": "Hate to be that guy but this should be an easy problem"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Try these :- \\n\\n[0,1,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,1,1,1,0,0,0,1,0,1,1]\\n\\n[5770,9921,1853,441,6808,8847,9186,3091,1524,2415]\\n\\n[0,2,0,2,1,2,3,4,4,1]"
                    }
                ]
            },
            {
                "id": 1950953,
                "content": [
                    {
                        "username": "om_golhani",
                        "content": "Tip : Try to think it as Longest Biotonic Subarray.\\nUse the concept of Longest Increasing Subarray and Longest Decreasing Subarray to find the longest mountain in array."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "So hard... edge cases are SOOOO annoying..."
                    },
                    {
                        "username": "Sakettiwari",
                        "content": "Check these cases !\nThank me later ;)\nUPVOTE IF IT HELPED\n\n[0,2,0,0,2,0,2,1,1,0,2,1,0,0,1,0,2,1,2,0,1,1,0,2,2,1,2,2,0,0,0,1,0,2,0,0,1,2,0,1,0,2,0,2,0,0,0,0,2,1,0,0,0,0,1,0,2,1,2,2,1,0,0,1,0,2,0,0,0,2,1,0,1,2,1,0,1,0,2,1,0,2,0,2,1,1,2,0,1,0,1,1,1,1,2,1,2,2,2,0]\n\n\n[0,1,2,0]\n\n[875,884,239,731,723,685]\n\n[2,3,1,2,3,4,5,6]\n\n[0]\n\n[1,2,3,4,5]\n\n[5,4,3,2,1]\n\n[0,1,2,3,4,5,4,3,2,1,0]\n"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Nice work"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "The edge cases were a bit tedious to address but I\\'m surprised I managed to solve the initial code relatively quickly!"
                    },
                    {
                        "username": "HARSH_252525",
                        "content": "just traverse an array/vector and check for lower and greater conditions given in question(check for mountain) and simply take two counters one for each subarray that satisfy given condition and one for final answer"
                    },
                    {
                        "username": "spookie886",
                        "content": "Hate to be that guy but this should be an easy problem"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Try these :- \\n\\n[0,1,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,1,1,1,0,0,0,1,0,1,1]\\n\\n[5770,9921,1853,441,6808,8847,9186,3091,1524,2415]\\n\\n[0,2,0,2,1,2,3,4,4,1]"
                    }
                ]
            },
            {
                "id": 1861077,
                "content": [
                    {
                        "username": "om_golhani",
                        "content": "Tip : Try to think it as Longest Biotonic Subarray.\\nUse the concept of Longest Increasing Subarray and Longest Decreasing Subarray to find the longest mountain in array."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "So hard... edge cases are SOOOO annoying..."
                    },
                    {
                        "username": "Sakettiwari",
                        "content": "Check these cases !\nThank me later ;)\nUPVOTE IF IT HELPED\n\n[0,2,0,0,2,0,2,1,1,0,2,1,0,0,1,0,2,1,2,0,1,1,0,2,2,1,2,2,0,0,0,1,0,2,0,0,1,2,0,1,0,2,0,2,0,0,0,0,2,1,0,0,0,0,1,0,2,1,2,2,1,0,0,1,0,2,0,0,0,2,1,0,1,2,1,0,1,0,2,1,0,2,0,2,1,1,2,0,1,0,1,1,1,1,2,1,2,2,2,0]\n\n\n[0,1,2,0]\n\n[875,884,239,731,723,685]\n\n[2,3,1,2,3,4,5,6]\n\n[0]\n\n[1,2,3,4,5]\n\n[5,4,3,2,1]\n\n[0,1,2,3,4,5,4,3,2,1,0]\n"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Nice work"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "The edge cases were a bit tedious to address but I\\'m surprised I managed to solve the initial code relatively quickly!"
                    },
                    {
                        "username": "HARSH_252525",
                        "content": "just traverse an array/vector and check for lower and greater conditions given in question(check for mountain) and simply take two counters one for each subarray that satisfy given condition and one for final answer"
                    },
                    {
                        "username": "spookie886",
                        "content": "Hate to be that guy but this should be an easy problem"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Try these :- \\n\\n[0,1,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,1,1,1,0,0,0,1,0,1,1]\\n\\n[5770,9921,1853,441,6808,8847,9186,3091,1524,2415]\\n\\n[0,2,0,2,1,2,3,4,4,1]"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Length of a Concatenated String with Unique Characters",
        "question_content": "<p>You are given an array of strings <code>arr</code>. A string <code>s</code> is formed by the <strong>concatenation</strong> of a <strong>subsequence</strong> of <code>arr</code> that has <strong>unique characters</strong>.</p>\n\n<p>Return <em>the <strong>maximum</strong> possible length</em> of <code>s</code>.</p>\n\n<p>A <strong>subsequence</strong> is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> All the valid concatenations are:\n- &quot;&quot;\n- &quot;un&quot;\n- &quot;iq&quot;\n- &quot;ue&quot;\n- &quot;uniq&quot; (&quot;un&quot; + &quot;iq&quot;)\n- &quot;ique&quot; (&quot;iq&quot; + &quot;ue&quot;)\nMaximum length is 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [&quot;cha&quot;,&quot;r&quot;,&quot;act&quot;,&quot;ers&quot;]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> Possible longest valid concatenations are &quot;chaers&quot; (&quot;cha&quot; + &quot;ers&quot;) and &quot;acters&quot; (&quot;act&quot; + &quot;ers&quot;).\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [&quot;abcdefghijklmnopqrstuvwxyz&quot;]\n<strong>Output:</strong> 26\n<strong>Explanation:</strong> The only string in arr has all 26 characters.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 16</code></li>\n\t<li><code>1 &lt;= arr[i].length &lt;= 26</code></li>\n\t<li><code>arr[i]</code> contains only lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 414172,
                "title": "python-c-java-set-solution",
                "content": "## **Explanation**\\n\\n0. Initial the result `res` to include the case of empty string `\"\"`.\\n`res` include all possible combinations we find during we iterate the input.\\n\\n1. Itearte the the input strings,\\nbut skip the word that have duplicate characters.\\nThe examples is kind of misleading,\\nbut the input string can have duplicate characters,\\nno need to considerate these strings.\\n\\n3. For each string,\\nwe check if it\\'s conflit with the combination that we found.\\nIf they have intersection of characters, we skip it.\\nIf not, we append this new combination to result.\\n\\n4. return the maximum length from all combinations.\\n<br>\\n\\n**Python:**\\n```python\\n    def maxLength(self, A):\\n        dp = [set()]\\n        for a in A:\\n            if len(set(a)) < len(a): continue\\n            a = set(a)\\n            for c in dp[:]:\\n                if a & c: continue\\n                dp.append(a | c)\\n        return max(len(a) for a in dp)\\n```\\n**C++**\\nbased on @savvadia\\n```C++\\n    int maxLength(vector<string>& A) {\\n        vector<bitset<26>> dp = {bitset<26>()};\\n        int res = 0;\\n        for (auto& s : A) {\\n            bitset<26> a;\\n            for (char c : s)\\n                a.set(c - \\'a\\');\\n            int n = a.count();\\n            if (n < s.size()) continue;\\n\\n            for (int i = dp.size() - 1; i >= 0; --i) {\\n                bitset c = dp[i];\\n                if ((c & a).any()) continue;\\n                dp.push_back(c | a);\\n                res = max(res, (int)c.count() + n);\\n            }\\n        }\\n        return res;\\n    }\\n```\\n**Java**\\n```java\\n    public int maxLength(List<String> A) {\\n        List<Integer> dp = new ArrayList<>();\\n        dp.add(0);\\n        int res = 0;\\n        for (String s : A) {\\n            int a = 0, dup = 0;\\n            for (char c : s.toCharArray()) {\\n                dup |= a & (1 << (c - \\'a\\'));\\n                a |= 1 << (c - \\'a\\');\\n            }\\n            if (dup > 0) continue;\\n            for (int i = dp.size() - 1; i >= 0; --i) {\\n                if ((dp.get(i) & a) > 0) continue;\\n                dp.add(dp.get(i) | a);\\n                res = Math.max(res, Integer.bitCount(dp.get(i) | a));\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```python\\n    def maxLength(self, A):\\n        dp = [set()]\\n        for a in A:\\n            if len(set(a)) < len(a): continue\\n            a = set(a)\\n            for c in dp[:]:\\n                if a & c: continue\\n                dp.append(a | c)\\n        return max(len(a) for a in dp)\\n```\n```C++\\n    int maxLength(vector<string>& A) {\\n        vector<bitset<26>> dp = {bitset<26>()};\\n        int res = 0;\\n        for (auto& s : A) {\\n            bitset<26> a;\\n            for (char c : s)\\n                a.set(c - \\'a\\');\\n            int n = a.count();\\n            if (n < s.size()) continue;\\n\\n            for (int i = dp.size() - 1; i >= 0; --i) {\\n                bitset c = dp[i];\\n                if ((c & a).any()) continue;\\n                dp.push_back(c | a);\\n                res = max(res, (int)c.count() + n);\\n            }\\n        }\\n        return res;\\n    }\\n```\n```java\\n    public int maxLength(List<String> A) {\\n        List<Integer> dp = new ArrayList<>();\\n        dp.add(0);\\n        int res = 0;\\n        for (String s : A) {\\n            int a = 0, dup = 0;\\n            for (char c : s.toCharArray()) {\\n                dup |= a & (1 << (c - \\'a\\'));\\n                a |= 1 << (c - \\'a\\');\\n            }\\n            if (dup > 0) continue;\\n            for (int i = dp.size() - 1; i >= 0; --i) {\\n                if ((dp.get(i) & a) > 0) continue;\\n                dp.add(dp.get(i) | a);\\n                res = Math.max(res, Integer.bitCount(dp.get(i) | a));\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 414180,
                "title": "clean-java-javascript-dfs-solution",
                "content": "I think you can optimize a bit by adding memory to it. Time was limited during the contest, I didn\\'t have time to optimized it.\\n\\n```\\nclass Solution {\\n    private int result = 0;\\n\\n    public int maxLength(List<String> arr) {\\n        if (arr == null || arr.size() == 0) {\\n            return 0;\\n        }\\n\\n        dfs(arr, \"\", 0);\\n\\n        return result;\\n    }\\n\\n    private void dfs(List<String> arr, String path, int idx) {\\n        boolean isUniqueChar = isUniqueChars(path);\\n        \\n        if (isUniqueChar) {\\n            result = Math.max(path.length(), result);\\n        }\\n\\n        if (idx == arr.size() || !isUniqueChar) {\\n            return;\\n        }\\n        \\n        for (int i = idx; i < arr.size(); i++) {\\n            dfs(arr, path + arr.get(i), i + 1);\\n        }\\n    }\\n\\n    private boolean isUniqueChars(String s) {\\n        Set<Character> set = new HashSet<>();\\n\\n        for (char c : s.toCharArray()) {\\n            if (set.contains(c)) {\\n                return false;\\n            }\\n            set.add(c);\\n        }\\n        return true;\\n    }\\n}\\n\\n```\\n\\nJavaScript solution using memorization DFS from @jitendra8911 in the comment.\\n\\n```\\nvar maxLength = function(arr) {\\n    let maxLen = 0;\\n    let listOfStrs = [];\\n    arr = arr.filter(isUnique);\\n    let mem = {};\\n    maxLen = dfs(arr, \"\", 0, maxLen, mem);\\n    \\n    return maxLen;\\n};\\n\\nfunction dfs(arr, path, i, maxLen, mem) {\\n    if (mem[path]) return mem[path];\\n    let pathIsUnique = isUnique(path);\\n    if (pathIsUnique) {\\n        maxLen = Math.max(path.length, maxLen);\\n    } \\n    if (i === arr.length || !pathIsUnique) {\\n        mem[path] = maxLen;\\n        return maxLen;\\n    }\\n    for (let j = i; j < arr.length; j++) {\\n        maxLen = dfs(arr, path + arr[j], j + 1, maxLen, mem);\\n    }\\n\\n\\n    mem[path] = maxLen;\\n    return maxLen;\\n}\\n\\nfunction isUnique(str) {\\n    const map = {}\\n    for (let i = 0; i < str.length; i++) {\\n        if (map[str[i]]) return false;\\n        map[str[i]] = 1;\\n    }\\n    \\n    return true;\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int result = 0;\\n\\n    public int maxLength(List<String> arr) {\\n        if (arr == null || arr.size() == 0) {\\n            return 0;\\n        }\\n\\n        dfs(arr, \"\", 0);\\n\\n        return result;\\n    }\\n\\n    private void dfs(List<String> arr, String path, int idx) {\\n        boolean isUniqueChar = isUniqueChars(path);\\n        \\n        if (isUniqueChar) {\\n            result = Math.max(path.length(), result);\\n        }\\n\\n        if (idx == arr.size() || !isUniqueChar) {\\n            return;\\n        }\\n        \\n        for (int i = idx; i < arr.size(); i++) {\\n            dfs(arr, path + arr.get(i), i + 1);\\n        }\\n    }\\n\\n    private boolean isUniqueChars(String s) {\\n        Set<Character> set = new HashSet<>();\\n\\n        for (char c : s.toCharArray()) {\\n            if (set.contains(c)) {\\n                return false;\\n            }\\n            set.add(c);\\n        }\\n        return true;\\n    }\\n}\\n\\n```\n```\\nvar maxLength = function(arr) {\\n    let maxLen = 0;\\n    let listOfStrs = [];\\n    arr = arr.filter(isUnique);\\n    let mem = {};\\n    maxLen = dfs(arr, \"\", 0, maxLen, mem);\\n    \\n    return maxLen;\\n};\\n\\nfunction dfs(arr, path, i, maxLen, mem) {\\n    if (mem[path]) return mem[path];\\n    let pathIsUnique = isUnique(path);\\n    if (pathIsUnique) {\\n        maxLen = Math.max(path.length, maxLen);\\n    } \\n    if (i === arr.length || !pathIsUnique) {\\n        mem[path] = maxLen;\\n        return maxLen;\\n    }\\n    for (let j = i; j < arr.length; j++) {\\n        maxLen = dfs(arr, path + arr[j], j + 1, maxLen, mem);\\n    }\\n\\n\\n    mem[path] = maxLen;\\n    return maxLen;\\n}\\n\\nfunction isUnique(str) {\\n    const map = {}\\n    for (let i = 0; i < str.length; i++) {\\n        if (map[str[i]]) return false;\\n        map[str[i]] = 1;\\n    }\\n    \\n    return true;\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 414806,
                "title": "c-dfs-clean-and-concise-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxLength(vector<string>& arr, string str = \"\", int index = 0) {\\n\\t    //Use set to check if the string contains all unique characters\\n        unordered_set<char>s(str.begin(), str.end());\\n        if (s.size() != ((int)str.length())) \\n            return 0;\\n        \\n        int ret = str.length();\\n        for (int i = index; i < arr.size(); i++)\\n            ret = max(ret, maxLength(arr, str+arr[i], i+1));\\n\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLength(vector<string>& arr, string str = \"\", int index = 0) {\\n\\t    //Use set to check if the string contains all unique characters\\n        unordered_set<char>s(str.begin(), str.end());\\n        if (s.size() != ((int)str.length())) \\n            return 0;\\n        \\n        int ret = str.length();\\n        for (int i = index; i < arr.size(); i++)\\n            ret = max(ret, maxLength(arr, str+arr[i], i+1));\\n\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737493,
                "title": "python-c-java-rust-0-ms-bit-set-operations-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs bit & set operations. Time complexity is exponential: **O(expN)**. Space complexity is exponential: **O(expN)**. \\n\\n| **Language** | [**Python**](https://leetcode.com/submissions/detail/828975733/) | [**C++**](https://leetcode.com/submissions/detail/828974283/) | [**Java**](https://leetcode.com/submissions/detail/829255644/) | [**Rust**](https://leetcode.com/submissions/detail/828985984/) | \\n|---|---|---|---|---|\\n| **Runtime** | **78 ms (98.70%)** | **0 ms (100.00%)** | **10 ms (90.18%)** | **0 ms (100.00%)** |\\n| **Memory** | **51.9 MB  (11.15%)** | **9.7 MB (74.27%)** | **42.1 MB  (88.06%)** | **2.2 MB  (33.33%)** |\\n\\n<iframe src=\"https://leetcode.com/playground/75txHQDx/shared\" frameBorder=\"0\" width=\"800\" height=\"660\"></iframe>",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Rust"
                ],
                "code": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs bit & set operations. Time complexity is exponential: **O(expN)**. Space complexity is exponential: **O(expN)**. \\n\\n| **Language** | [**Python**](https://leetcode.com/submissions/detail/828975733/) | [**C++**](https://leetcode.com/submissions/detail/828974283/) | [**Java**](https://leetcode.com/submissions/detail/829255644/) | [**Rust**](https://leetcode.com/submissions/detail/828985984/) | \\n|---|---|---|---|---|\\n| **Runtime** | **78 ms (98.70%)** | **0 ms (100.00%)** | **10 ms (90.18%)** | **0 ms (100.00%)** |\\n| **Memory** | **51.9 MB  (11.15%)** | **9.7 MB (74.27%)** | **42.1 MB  (88.06%)** | **2.2 MB  (33.33%)** |\\n\\n<iframe src=\"https://leetcode.com/playground/75txHQDx/shared\" frameBorder=\"0\" width=\"800\" height=\"660\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 1478384,
                "title": "c-python-simple-bitmasking-clean-concise",
                "content": "**Idea**\\n- The idea is that we try all possible subset of `arr` by using Bitmasking, same with **[78. Subsets](https://leetcode.com/problems/subsets/)**.\\n- Let `mask` represent the appearance of `arr[i]`, ith bit of mask = 1 means there exists `arr[i]`.\\n- There are total `2^n` bitmasking states: `0..000`, `0..001`, `0..010`, ..., `1..111`.\\n- For each subsets of `arr`, we check if it can form a valid string? If we can form then we update the maximum length so far.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        n = len(arr)\\n        ans = 0\\n        for mask in range(1 << n):\\n            seen = set()\\n            isValid = True\\n            strSize = 0\\n            for i in range(n):\\n                if (mask >> i) & 1 == 0: continue\\n                for c in arr[i]:\\n                    if c in seen:   # If c is already existed then it\\'s invalid subsequence.\\n                        isValid = False\\n                        break\\n                    seen.add(c)  # mark as character `c` is already seen\\n                    strSize += 1\\n                if not isValid: break  # prune when there is a duplicate\\n            if isValid and strSize > ans:\\n                ans = strSize\\n        return ans\\n```\\n\\n**C++**\\n```c++\\nclass Solution { // 36 ms, faster than 66.95%\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n = arr.size(), allMask = 1 << n, ans = 0;\\n        for (int mask = 0; mask < allMask; ++mask) {\\n            int strSize = 0;\\n            int seen = 0; // the mask to check duplicate chars when forming string\\n            bool isValid = true;\\n            for (int i = 0; i < n; ++i) {\\n                if (((mask >> i) & 1) == 0) continue;\\n                for (char c : arr[i]) {\\n                    int j = c - \\'a\\';\\n                    if ((seen >> j) & 1) { // If c is already existed then it\\'s invalid subsequence.\\n                        isValid = false;\\n                        break;\\n                    }\\n                    seen = seen | (1 << j); // mark as character `c` is already seen\\n                    strSize += 1;\\n                }\\n                if (!isValid) break; //  prune when there is a duplicate\\n            }\\n            if (isValid && strSize > ans) ans = strSize;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nComplexity:\\n- Time: `O(2^n * (26 + n))`, where `n <= 16` is length of `arr` array.\\n\\t- There is `2^n` bitmask states.\\n\\t- There are up to 26 distinct characters we can form.\\n- Space: `O(26)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        n = len(arr)\\n        ans = 0\\n        for mask in range(1 << n):\\n            seen = set()\\n            isValid = True\\n            strSize = 0\\n            for i in range(n):\\n                if (mask >> i) & 1 == 0: continue\\n                for c in arr[i]:\\n                    if c in seen:   # If c is already existed then it\\'s invalid subsequence.\\n                        isValid = False\\n                        break\\n                    seen.add(c)  # mark as character `c` is already seen\\n                    strSize += 1\\n                if not isValid: break  # prune when there is a duplicate\\n            if isValid and strSize > ans:\\n                ans = strSize\\n        return ans\\n```\n```c++\\nclass Solution { // 36 ms, faster than 66.95%\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n = arr.size(), allMask = 1 << n, ans = 0;\\n        for (int mask = 0; mask < allMask; ++mask) {\\n            int strSize = 0;\\n            int seen = 0; // the mask to check duplicate chars when forming string\\n            bool isValid = true;\\n            for (int i = 0; i < n; ++i) {\\n                if (((mask >> i) & 1) == 0) continue;\\n                for (char c : arr[i]) {\\n                    int j = c - \\'a\\';\\n                    if ((seen >> j) & 1) { // If c is already existed then it\\'s invalid subsequence.\\n                        isValid = false;\\n                        break;\\n                    }\\n                    seen = seen | (1 << j); // mark as character `c` is already seen\\n                    strSize += 1;\\n                }\\n                if (!isValid) break; //  prune when there is a duplicate\\n            }\\n            if (isValid && strSize > ans) ans = strSize;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737457,
                "title": "java-clean-easy-to-understand-backtracking",
                "content": "```\\nPlease upvote if you find it helpful\\n```\\n```\\nclass Solution {\\n    int max =0;\\n    public int maxLength(List<String> arr) {\\n        backTrack(arr,\"\",0);\\n        return max;\\n    }\\n    \\n    private void backTrack(List<String> arr, String current, int start){\\n        if(max<current.length())\\n            max =current.length();\\n        for(int i=start; i<arr.size();i++){\\n            if(!isValid(current,arr.get(i))) continue;\\n            backTrack(arr,current+arr.get(i),i+1);\\n        }\\n    }\\n    \\n    private boolean isValid(String currentString, String newString){\\n        int[] array = new int[26];\\n        for(int i=0;i<newString.length();i++){\\n            if(++array[newString.charAt(i)-\\'a\\'] == 2) return false;  //to handle if the newString has duplicates then it\\'s not valid\\n            if(currentString.contains(newString.charAt(i)+\"\")) // check if the currentString contains each char from newString\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nPlease upvote if you find it helpful\\n```\n```\\nclass Solution {\\n    int max =0;\\n    public int maxLength(List<String> arr) {\\n        backTrack(arr,\"\",0);\\n        return max;\\n    }\\n    \\n    private void backTrack(List<String> arr, String current, int start){\\n        if(max<current.length())\\n            max =current.length();\\n        for(int i=start; i<arr.size();i++){\\n            if(!isValid(current,arr.get(i))) continue;\\n            backTrack(arr,current+arr.get(i),i+1);\\n        }\\n    }\\n    \\n    private boolean isValid(String currentString, String newString){\\n        int[] array = new int[26];\\n        for(int i=0;i<newString.length();i++){\\n            if(++array[newString.charAt(i)-\\'a\\'] == 2) return false;  //to handle if the newString has duplicates then it\\'s not valid\\n            if(currentString.contains(newString.charAt(i)+\"\")) // check if the currentString contains each char from newString\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 631245,
                "title": "python-3-easy-code-intutive-solution",
                "content": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        \\n        uniqELements = [\\'\\']\\n        maximum = 0\\n        for i in range(len(arr)):\\n            sz = len(uniqELements)\\n            for j in range(sz):\\n                x=arr[i]+uniqELements[j]\\n                if (len(x)==len(set(x))):\\n                    uniqELements.append(x)\\n                    maximum = max(maximum,len(x))\\n        #print(uniqELements)\\n        return maximum\\n\\t\\t",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        \\n        uniqELements = [\\'\\']\\n        maximum = 0\\n        for i in range(len(arr)):\\n            sz = len(uniqELements)\\n            for j in range(sz):\\n                x=arr[i]+uniqELements[j]\\n                if (len(x)==len(set(x))):\\n                    uniqELements.append(x)\\n                    maximum = max(maximum,len(x))\\n        #print(uniqELements)\\n        return maximum\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 513327,
                "title": "simple-backtracking-solution",
                "content": "```\\nclass Solution {\\n    int max = 0;\\n    public int maxLength(List<String> arr) {\\n        dfs(0, arr, \"\");\\n        return max;\\n    }\\n    \\n    public void dfs(int start, List<String> arr, String str){\\n        if(!isUnique(str)){\\n            return;\\n        }\\n        max = Math.max(max, str.length());\\n        \\n        for(int i=start; i<arr.size();i++){\\n            String s = arr.get(i);\\n            dfs(i+1, arr, str + s);\\n        }\\n    }\\n    \\n    public static boolean isUnique(String s){\\n        Set<Character> set = new HashSet<Character>();\\n        \\n        for(char ch: s.toCharArray()){\\n            if(set.contains(ch)){\\n                return false;\\n            }\\n            set.add(ch);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int max = 0;\\n    public int maxLength(List<String> arr) {\\n        dfs(0, arr, \"\");\\n        return max;\\n    }\\n    \\n    public void dfs(int start, List<String> arr, String str){\\n        if(!isUnique(str)){\\n            return;\\n        }\\n        max = Math.max(max, str.length());\\n        \\n        for(int i=start; i<arr.size();i++){\\n            String s = arr.get(i);\\n            dfs(i+1, arr, str + s);\\n        }\\n    }\\n    \\n    public static boolean isUnique(String s){\\n        Set<Character> set = new HashSet<Character>();\\n        \\n        for(char ch: s.toCharArray()){\\n            if(set.contains(ch)){\\n                return false;\\n            }\\n            set.add(ch);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 782788,
                "title": "explained-my-c-solution-using-backtracking",
                "content": "```\\nclass Solution {\\n    int len{0};\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        checkLen(\"\", arr, 0);\\n        return len;\\n    }\\n    \\n    void checkLen(string str, vector<string> &arr, int itr) {\\n        if (!isUnique(str)) return;\\n        if (str.size() > len) len = str.size();\\n        for (int i = itr; i < arr.size(); i++)\\n            checkLen(str+arr[i], arr, i+1);\\n    }\\n    \\n    bool isUnique(string word) {\\n        set<char> st;\\n        for (auto ele : word) {\\n            if (st.find(ele) != st.end()) return false;\\n            st.insert(ele);\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\nthe logic behind solution is straight-forward, for each possible combination of two or more (given) array elements check if \\n\\t1. all the elements are unique.\\n\\t2. the length is longest",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int len{0};\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        checkLen(\"\", arr, 0);\\n        return len;\\n    }\\n    \\n    void checkLen(string str, vector<string> &arr, int itr) {\\n        if (!isUnique(str)) return;\\n        if (str.size() > len) len = str.size();\\n        for (int i = itr; i < arr.size(); i++)\\n            checkLen(str+arr[i], arr, i+1);\\n    }\\n    \\n    bool isUnique(string word) {\\n        set<char> st;\\n        for (auto ele : word) {\\n            if (st.find(ele) != st.end()) return false;\\n            st.insert(ele);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1478456,
                "title": "python-dp-on-subsets-explained",
                "content": "This problem is medium, not hard, because given constraints it is possible to do just bruteforce solution: check for every one of `2^16` subsets if concatenation have all different symbols. However we can do better.\\n\\nFirst of all, number of letters in alphabet is not big: only `26`, so we can use the idea of bitmask: encode every word with number. For example for word `dab`, we can use mask `1011` (we start from end).\\n\\n1. First of all, we take only words with different letters, and remove all others.\\n2. Next step is for every word evaluate its mask and also number of letters. We keep tuple. For example `d[1<<i] = (1011, 3)` for word `dab`, where `i` is index of this word. Why we use `1<<i`, not just `i`? You will see it later.\\n3. `dp(m)` is maximum answer we can have if we use bitmask of **words indexes** `m`. Notice, it is another bitmask, not what we discussed previously. For example, if we have `arr = [ab, cd, ef, gh]`, then `m = 1011` means that we take `ab, cd, gh` as our solution. `dp(m)` will return two values: bitmask of used letters and number of used letters.\\n4. How we can find `dp(m)`? If `m == 0`, we return `(0, 0)`. Next we find the last `1` in our `m`, usint `m & (m-1)` trick. Then we check if `m_last & d[m - prev][0] != 0`. If it is the case, it means that we have some letters repeated, so we return `(0, -10000)` in this case where `-10000` represents minus infinity. In the opposite case we return `(m_last | d[m - prev][0], bits_last + d[m - prev][1])`, because we need to turn on bits `d[m - prev][0]` in mask `m_last` and number of bits is ` bits_last + d[m - prev][1]`. Notice that we can keep in fact only one value and evaluate the second on flight, but it will not be true `O(1)`.\\n5. In the end we just check all masks `dp(x)` and return one with the biggest number of letters on.\\n\\n#### Complexity\\nIt is `O(2^n)` for time and `O(2^n)` for space.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def maxLength(self, arr):\\n        arr = [word for word in arr if len(set(word)) == len(word)]\\n        \\n        d = {}\\n        for i, word in enumerate(arr):\\n            d[1<<i] = (sum(1<<(ord(w) - 97) for w in word), len(word))\\n\\n        @lru_cache(None)\\n        def dp(m):\\n            if m == 0: return (0, 0)\\n            prev = m & (m - 1)\\n            m_last, bits_last = dp(prev)\\n            if m_last & d[m - prev][0] != 0: return (0, -10000)\\n            return (m_last | d[m - prev][0], bits_last + d[m - prev][1])\\n        \\n        return max(dp(x)[1] for x in range(1<<len(arr)))\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def maxLength(self, arr):\\n        arr = [word for word in arr if len(set(word)) == len(word)]\\n        \\n        d = {}\\n        for i, word in enumerate(arr):\\n            d[1<<i] = (sum(1<<(ord(w) - 97) for w in word), len(word))\\n\\n        @lru_cache(None)\\n        def dp(m):\\n            if m == 0: return (0, 0)\\n            prev = m & (m - 1)\\n            m_last, bits_last = dp(prev)\\n            if m_last & d[m - prev][0] != 0: return (0, -10000)\\n            return (m_last | d[m - prev][0], bits_last + d[m - prev][1])\\n        \\n        return max(dp(x)[1] for x in range(1<<len(arr)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737783,
                "title": "python-s-simple-and-easy-to-understand-solution-99-faster",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        n = len(arr)\\n        res = [\"\"]\\n        op = 0\\n        \\n        for word in arr:\\n            for r in res:\\n                newRes = r+word\\n                if len(newRes)!=len(set(newRes)): continue\\n                res.append(newRes)\\n                op = max(op, len(newRes))\\n        return op\\n```\\n**Visit this blog to learn Python tips and techniques and to find a Leetcode solution with an explanation:  https://www.python-techs.com/**\\n\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        n = len(arr)\\n        res = [\"\"]\\n        op = 0\\n        \\n        for word in arr:\\n            for r in res:\\n                newRes = r+word\\n                if len(newRes)!=len(set(newRes)): continue\\n                res.append(newRes)\\n                op = max(op, len(newRes))\\n        return op\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1478666,
                "title": "two-approach-well-explained-97-faster",
                "content": "## IDEA:\\nSince Constraint is very less we can use O(n^2).\\n\\n### Using Recurssion :\\n*In this we will store each unique lenght substring separetly and will compare with all the possible permutation.*\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def maxLength(self,arr):\\n        \\n        unique = [\\'\\']\\n        res = 0\\n        for i in range(len(arr)):\\n            for j in range(len(unique)):\\n                local = arr[i]+unique[j]\\n                if len(local)==len(set(local)):\\n                    unique.append(local)\\n                    res=max(res,len(local))\\n        \\n        return res\\n        \\n\\n### Using Backtracking :\\n*In this we will join all coming strings with the present one and every time measure the length of formed **unique** substring.*\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tres = 0 \\n\\t\\tdef maxLength(self,arr):\\n\\t\\t\\tself.backtrack(arr,0,\"\")\\n\\t\\t\\treturn self.res\\n\\n\\t\\tdef backtrack(self,arr,ind,local):\\n\\t\\t\\tif len(local)!=len(set(local)):\\n\\t\\t\\t\\treturn\\n\\t\\t\\t\\t\\n\\t\\t\\tself.res = max(self.res,len(local))\\n\\t\\t\\tfor i in range(ind,len(arr)):\\n\\t\\t\\t\\tself.backtrack(arr,i+1,local+arr[i])\\n\\n#### Thanks and **Upvote** if you got any help or like the solutions !!\\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "## IDEA:\\nSince Constraint is very less we can use O(n^2).\\n\\n### Using Recurssion :\\n*In this we will store each unique lenght substring separetly and will compare with all the possible permutation.*\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def maxLength(self,arr):\\n        \\n        unique = [\\'\\']\\n        res = 0\\n        for i in range(len(arr)):\\n            for j in range(len(unique)):\\n                local = arr[i]+unique[j]\\n                if len(local)==len(set(local)):\\n                    unique.append(local)\\n                    res=max(res,len(local))\\n        \\n        return res\\n        \\n\\n### Using Backtracking :\\n*In this we will join all coming strings with the present one and every time measure the length of formed **unique** substring.*\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tres = 0 \\n\\t\\tdef maxLength(self,arr):\\n\\t\\t\\tself.backtrack(arr,0,\"\")\\n\\t\\t\\treturn self.res\\n\\n\\t\\tdef backtrack(self,arr,ind,local):\\n\\t\\t\\tif len(local)!=len(set(local)):\\n\\t\\t\\t\\treturn\\n\\t\\t\\t\\t\\n\\t\\t\\tself.res = max(self.res,len(local))\\n\\t\\t\\tfor i in range(ind,len(arr)):\\n\\t\\t\\t\\tself.backtrack(arr,i+1,local+arr[i])\\n\\n#### Thanks and **Upvote** if you got any help or like the solutions !!\\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 2737644,
                "title": "c-backtracking-easy-to-understand",
                "content": "* ***Backtracking***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxi = 0;\\n    \\n    // function for checking uniqueness of the string\\n    \\n    bool is_unique(string& str)\\n    {\\n        int n = str.size();\\n        \\n        // mp will store the count of all the characters in string\\n        \\n        vector<int> mp(26, 0);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[str[i] - \\'a\\']++;\\n            \\n            // if we found duplicates return false\\n            \\n            if(mp[str[i] - \\'a\\'] > 1)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    void helper(vector<string>& arr, int i, int n, string curr)\\n    {\\n        // if we have got duplicate int our result then simply return\\n        \\n        if(is_unique(curr) == false)\\n            return;\\n        \\n        // base case\\n        \\n        if(i == n)\\n        {\\n            // update maxi\\n            \\n            if(curr.size() > maxi)\\n            {\\n                int size = curr.size();\\n                \\n                maxi = max(maxi, size);\\n            }\\n            \\n            return;\\n        }\\n        \\n        // we have two options either include the curr string or exclude\\n        \\n        // include the curr string\\n        \\n        helper(arr, i + 1, n, curr + arr[i]);\\n        \\n        // exclude the curr string\\n        \\n        helper(arr, i + 1, n, curr);\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        // call helper function\\n        \\n        helper(arr, 0, n, \"\");\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maxi = 0;\\n    \\n    // function for checking uniqueness of the string\\n    \\n    bool is_unique(string& str)\\n    {\\n        int n = str.size();\\n        \\n        // mp will store the count of all the characters in string\\n        \\n        vector<int> mp(26, 0);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[str[i] - \\'a\\']++;\\n            \\n            // if we found duplicates return false\\n            \\n            if(mp[str[i] - \\'a\\'] > 1)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    void helper(vector<string>& arr, int i, int n, string curr)\\n    {\\n        // if we have got duplicate int our result then simply return\\n        \\n        if(is_unique(curr) == false)\\n            return;\\n        \\n        // base case\\n        \\n        if(i == n)\\n        {\\n            // update maxi\\n            \\n            if(curr.size() > maxi)\\n            {\\n                int size = curr.size();\\n                \\n                maxi = max(maxi, size);\\n            }\\n            \\n            return;\\n        }\\n        \\n        // we have two options either include the curr string or exclude\\n        \\n        // include the curr string\\n        \\n        helper(arr, i + 1, n, curr + arr[i]);\\n        \\n        // exclude the curr string\\n        \\n        helper(arr, i + 1, n, curr);\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        // call helper function\\n        \\n        helper(arr, 0, n, \"\");\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737382,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\n// BIT MANIPULATION SOLUTION\\nclass Solution {\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int maxlength=0;\\n        int n=arr.size();\\n        int nos=pow(2,n)-1;\\n        for(int num=0;num<=nos;num++)\\n        {\\n            vector<string> temp;\\n            for(int i=0;i<n;i++)\\n            {\\n                int bit=(num&(1<<i));\\n                if(bit) temp.push_back(arr[i]);\\n            }\\n            string s1=\"\";\\n            for(int i=0;i<temp.size();i++)\\n            {\\n                s1+=temp[i];\\n            }\\n            int freq[26]={0};\\n            for(int i=0;i<s1.size();i++)\\n            {\\n                freq[s1[i]-\\'a\\']++;\\n            }\\n            int cnt=0;\\n            for(int i=0;i<26;i++)\\n            {\\n                if(freq[i]==1)\\n                {\\n                    cnt++;\\n                }\\n                else if(freq[i]>1)\\n                {\\n                    cnt=0;\\n                    break;\\n                }\\n            }\\n            maxlength=max(maxlength,cnt);            \\n        }\\n        return maxlength;\\n    }\\n};\\n```\\n```\\n//BACKTRACKING SOLUTION\\nclass Solution {\\npublic:\\n    void fun(int idx,vector<string>& arr,vector<string>& temp,int& maxlength)\\n    {\\n        if(idx==arr.size())\\n        {\\n            string s1=\"\";\\n            for(int i=0;i<temp.size();i++)\\n            {\\n                s1+=temp[i];\\n            }\\n            int freq[26]={0};\\n            for(int i=0;i<s1.size();i++)\\n            {\\n                freq[s1[i]-\\'a\\']++;\\n            }\\n            int cnt=0;\\n            for(int i=0;i<26;i++)\\n            {\\n                if(freq[i]==1)\\n                {\\n                    cnt++;\\n                }\\n                else if(freq[i]>1)\\n                {\\n                    cnt=0;\\n                    return;\\n                }\\n            }\\n            maxlength=max(maxlength,cnt);\\n            return;\\n        }\\n        temp.push_back(arr[idx]);\\n        fun(idx+1,arr,temp,maxlength);\\n        temp.pop_back();\\n        fun(idx+1,arr,temp,maxlength);\\n    }\\n    int maxLength(vector<string>& arr) {\\n        vector<string> temp;\\n        int maxlength=0;\\n        fun(0,arr,temp,maxlength);\\n        return maxlength;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\n// BIT MANIPULATION SOLUTION\\nclass Solution {\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int maxlength=0;\\n        int n=arr.size();\\n        int nos=pow(2,n)-1;\\n        for(int num=0;num<=nos;num++)\\n        {\\n            vector<string> temp;\\n            for(int i=0;i<n;i++)\\n            {\\n                int bit=(num&(1<<i));\\n                if(bit) temp.push_back(arr[i]);\\n            }\\n            string s1=\"\";\\n            for(int i=0;i<temp.size();i++)\\n            {\\n                s1+=temp[i];\\n            }\\n            int freq[26]={0};\\n            for(int i=0;i<s1.size();i++)\\n            {\\n                freq[s1[i]-\\'a\\']++;\\n            }\\n            int cnt=0;\\n            for(int i=0;i<26;i++)\\n            {\\n                if(freq[i]==1)\\n                {\\n                    cnt++;\\n                }\\n                else if(freq[i]>1)\\n                {\\n                    cnt=0;\\n                    break;\\n                }\\n            }\\n            maxlength=max(maxlength,cnt);            \\n        }\\n        return maxlength;\\n    }\\n};\\n```\n```\\n//BACKTRACKING SOLUTION\\nclass Solution {\\npublic:\\n    void fun(int idx,vector<string>& arr,vector<string>& temp,int& maxlength)\\n    {\\n        if(idx==arr.size())\\n        {\\n            string s1=\"\";\\n            for(int i=0;i<temp.size();i++)\\n            {\\n                s1+=temp[i];\\n            }\\n            int freq[26]={0};\\n            for(int i=0;i<s1.size();i++)\\n            {\\n                freq[s1[i]-\\'a\\']++;\\n            }\\n            int cnt=0;\\n            for(int i=0;i<26;i++)\\n            {\\n                if(freq[i]==1)\\n                {\\n                    cnt++;\\n                }\\n                else if(freq[i]>1)\\n                {\\n                    cnt=0;\\n                    return;\\n                }\\n            }\\n            maxlength=max(maxlength,cnt);\\n            return;\\n        }\\n        temp.push_back(arr[idx]);\\n        fun(idx+1,arr,temp,maxlength);\\n        temp.pop_back();\\n        fun(idx+1,arr,temp,maxlength);\\n    }\\n    int maxLength(vector<string>& arr) {\\n        vector<string> temp;\\n        int maxlength=0;\\n        fun(0,arr,temp,maxlength);\\n        return maxlength;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 469555,
                "title": "javascript-simple-solution-15-lines",
                "content": "Beat 75%, not the most optimal but simple enough.\\n\\n```\\n/**\\n * @param {string[]} arr\\n * @return {number}\\n */\\nvar maxLength = function (arr) {\\n    let res = 0;\\n\\n    let solve = (start, curr) => {\\n        if (curr.length !== new Set(curr.split(\\'\\')).size) {\\n            return;\\n        }\\n        \\n        res = Math.max(res, curr.length);\\n\\n        for (let i = start; i < arr.length; i++) {\\n            solve(i + 1, `${curr}${arr[i]}`);\\n        }\\n    }\\n\\n    solve(0, \\'\\');\\n\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} arr\\n * @return {number}\\n */\\nvar maxLength = function (arr) {\\n    let res = 0;\\n\\n    let solve = (start, curr) => {\\n        if (curr.length !== new Set(curr.split(\\'\\')).size) {\\n            return;\\n        }\\n        \\n        res = Math.max(res, curr.length);\\n\\n        for (let i = start; i < arr.length; i++) {\\n            solve(i + 1, `${curr}${arr[i]}`);\\n        }\\n    }\\n\\n    solve(0, \\'\\');\\n\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1478533,
                "title": "c-very-easy-backtracking-sol-4ms-runtime",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    //Used to map characters\\n    int m[26];\\n    \\n    //Storing ans globally\\n    int ans=0;\\n    \\n    void fun(vector<string>& v,int st,int n)\\n    {\\n        //Used to store temp ans upto index st in vector v.\\n        int res=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            //If any character appears more than 1 time, just return and try next possibilities\\n            if(m[i]>1)return;\\n            if(m[i]==1)res++;\\n        }\\n        \\n        //Updating ans\\n        ans=max(ans,res);\\n        for(int i=st;i<n;i++)\\n        {\\n            //Including string v[i] and then calling the function again with starting index as i+1.\\n            for(char ch:v[i])m[ch-\\'a\\']++;\\n            fun(v,i+1,n);\\n            //After the function call excluding string v[i]\\n            for(char ch:v[i])m[ch-\\'a\\']--;\\n        }\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        memset(m,0,sizeof(m));\\n        ans=0;\\n        fun(arr,0,arr.size());\\n        return ans;\\n    }\\n};\\n```\\n**Please Upvote if ypu like the Sol.**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //Used to map characters\\n    int m[26];\\n    \\n    //Storing ans globally\\n    int ans=0;\\n    \\n    void fun(vector<string>& v,int st,int n)\\n    {\\n        //Used to store temp ans upto index st in vector v.\\n        int res=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            //If any character appears more than 1 time, just return and try next possibilities\\n            if(m[i]>1)return;\\n            if(m[i]==1)res++;\\n        }\\n        \\n        //Updating ans\\n        ans=max(ans,res);\\n        for(int i=st;i<n;i++)\\n        {\\n            //Including string v[i] and then calling the function again with starting index as i+1.\\n            for(char ch:v[i])m[ch-\\'a\\']++;\\n            fun(v,i+1,n);\\n            //After the function call excluding string v[i]\\n            for(char ch:v[i])m[ch-\\'a\\']--;\\n        }\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        memset(m,0,sizeof(m));\\n        ans=0;\\n        fun(arr,0,arr.size());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696020,
                "title": "a-really-easy-java-dfs-solution",
                "content": "First step: build a function to check a string if is a unique string-----> isUnique();\\nSecond step:think the backtrack step, **can it be optimized by memo array/map ? my answer is no.** Because this is a top-bottom way, which means we have to detect the answer one by one, and the previous temporary answers are not exactly useful for the next ones in later computation.\\n\\nFor example:\\n[un,iq,ue]: un\\'s answer is 2, and we can simply compute it by un.length(), there does not need a map or array to memo it...\\n\\nIf you want to use memo, I guess you may need to compute it bottom-up, which likes DP answer...\\n\\nStep 3: to write the dfs and backtrack procedures:\\n1.when index is equal to the length, then return.\\n2.After that, we check the current string cur and adding the next one to it, one by one, which is str, then continue to dfs it.\\n3. we get the maximum result ,and return it.\\n\\n\\n```\\nclass Solution {    \\n    public int maxLength(List<String> arr) {\\n        return helper(arr,0,\"\");\\n    }\\n    \\n    private int helper(List<String> arr,int index,String cur){        \\n        if(index==arr.size()){\\n            return cur.length();\\n        }     \\n        \\n        int res=cur.length();\\n        for(int i=index;i<arr.size();i++){\\n            String str=cur+arr.get(i);           \\n            if(isUnique(str)){\\n                res=Math.max(res,helper(arr,i+1,str)); \\n            }\\n            \\n        }\\n        return res;\\n    }\\n    \\n    private boolean isUnique(String s){\\n        Set<Character> set=new HashSet<>();\\n        for(char c:s.toCharArray()){\\n            if(!set.add(c)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {    \\n    public int maxLength(List<String> arr) {\\n        return helper(arr,0,\"\");\\n    }\\n    \\n    private int helper(List<String> arr,int index,String cur){        \\n        if(index==arr.size()){\\n            return cur.length();\\n        }     \\n        \\n        int res=cur.length();\\n        for(int i=index;i<arr.size();i++){\\n            String str=cur+arr.get(i);           \\n            if(isUnique(str)){\\n                res=Math.max(res,helper(arr,i+1,str)); \\n            }\\n            \\n        }\\n        return res;\\n    }\\n    \\n    private boolean isUnique(String s){\\n        Set<Character> set=new HashSet<>();\\n        for(char c:s.toCharArray()){\\n            if(!set.add(c)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2318567,
                "title": "c-backtracking-hashing-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    bool isunique(string &s)\\n    {\\n        vector<int> v(26,0);\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(v[s[i]-\\'a\\']==1)\\n            {\\n                return false;\\n            }\\n            v[s[i]-\\'a\\']++;\\n        }\\n        return true;\\n    }\\n    void backtrack(vector<string>& arr,int idx,string curr_s)\\n    {\\n\\n        \\n        if(!isunique(curr_s))\\n            return;\\n        int temp=curr_s.size();\\n        ans=max(ans,temp);\\n        if(idx>=arr.size())\\n            return;\\n            \\n        \\n        backtrack(arr,idx+1,curr_s+arr[idx]);\\n        backtrack(arr,idx+1,curr_s);\\n            \\n    }\\n    int maxLength(vector<string>& arr) \\n    {\\n        backtrack(arr,0,\"\");\\n        return ans;\\n        \\n    }\\n};\\n// if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    int ans=0;\\n    bool isunique(string &s)\\n    {\\n        vector<int> v(26,0);\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(v[s[i]-\\'a\\']==1)\\n            {\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 895232,
                "title": "python-dfs-solution-with-explaination",
                "content": "Think in terms of graph. \\nINPUT: [\"cha\", \"r\", \"act\", \"ers\"]\\n\\nMake a graph for paths starting from each word in input\\n\\n\\n```\\n1.           \"cha\"\\n\\t\\t\\t/  |  \\\\\\n\\t     \"r\" \"act\" \"ers\"\\n\\t\\t /\\\\     \\\\\\n\\t\"act\" \"ers\" \"ers\"\\n\\t\\n\\tPATHS (sub-sequences): \\n\\tcha            - No Duplicates OK : max_len = 3\\n\\tcha-r          - No Duplicates OK: max_len = 4\\n\\tcha-r-act      - Duplicate char \\'a\\' NOTOK\\n\\tcha-r-ers      - Duplicate char \\'r\\' NOTOK\\n\\tcha-act        - Duplicate char \\'a\\' NOTOK\\n\\tcha-act-ers    - Duplicate char \\'a\\',\\'c\\' NOTOK\\n\\tcha-ers        - No Duplicates OK: max_len = 6\\n```\\t\\t \\n\\nSimilarly for other paths starting with \"r\", \"act\", \"ers\"\\n```\\n2.\\t      \"r\"\\n\\t\\t  /  \\\\\\n\\t  \"act\"   \"ers\"\\n\\t  /\\n\\t  \"ers\"\\n```\\n\\n\\n```\\n3.\\t  \"act\"\\n\\t    |\\n\\t  \"ers\"\\n```\\n\\n```\\n4.\\t  \"ers\"\\n\\t  \\n```\\n\\n\\nSo, basically you just have to dfs on all words and treat them as starting word of a subsequence.\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.max_len = 0\\n        \\n    def dfs(self, arr, curr_subseq, idx):\\n        # return if duplicate characters\\n        if len(curr_subseq) != len(set(curr_subseq)):\\n            return\\n        \\n        # update max_len if  curr_subseq is maximal\\n        self.max_len = max(len(curr_subseq), self.max_len)\\n        \\n        # dfs on next subseq(s) starting from curr_subseq\\n        for i in range(idx, len(arr)):\\n            self.dfs(arr, curr_subseq+arr[i], i+1)\\n\\n    def maxLength(self, arr: List[str]) -> int:\\n        if not arr:\\n            return 0        \\n        \\n        self.dfs(arr, \"\", 0)\\n        \\n        return self.max_len\\n\\n    \\n\\n```",
                "solutionTags": [],
                "code": "```\\n1.           \"cha\"\\n\\t\\t\\t/  |  \\\\\\n\\t     \"r\" \"act\" \"ers\"\\n\\t\\t /\\\\     \\\\\\n\\t\"act\" \"ers\" \"ers\"\\n\\t\\n\\tPATHS (sub-sequences): \\n\\tcha            - No Duplicates OK : max_len = 3\\n\\tcha-r          - No Duplicates OK: max_len = 4\\n\\tcha-r-act      - Duplicate char \\'a\\' NOTOK\\n\\tcha-r-ers      - Duplicate char \\'r\\' NOTOK\\n\\tcha-act        - Duplicate char \\'a\\' NOTOK\\n\\tcha-act-ers    - Duplicate char \\'a\\',\\'c\\' NOTOK\\n\\tcha-ers        - No Duplicates OK: max_len = 6\\n```\n```\\n2.\\t      \"r\"\\n\\t\\t  /  \\\\\\n\\t  \"act\"   \"ers\"\\n\\t  /\\n\\t  \"ers\"\\n```\n```\\n3.\\t  \"act\"\\n\\t    |\\n\\t  \"ers\"\\n```\n```\\n4.\\t  \"ers\"\\n\\t  \\n```\n```\\nclass Solution:\\n    def __init__(self):\\n        self.max_len = 0\\n        \\n    def dfs(self, arr, curr_subseq, idx):\\n        # return if duplicate characters\\n        if len(curr_subseq) != len(set(curr_subseq)):\\n            return\\n        \\n        # update max_len if  curr_subseq is maximal\\n        self.max_len = max(len(curr_subseq), self.max_len)\\n        \\n        # dfs on next subseq(s) starting from curr_subseq\\n        for i in range(idx, len(arr)):\\n            self.dfs(arr, curr_subseq+arr[i], i+1)\\n\\n    def maxLength(self, arr: List[str]) -> int:\\n        if not arr:\\n            return 0        \\n        \\n        self.dfs(arr, \"\", 0)\\n        \\n        return self.max_len\\n\\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738434,
                "title": "shortest-recursive-solution-super-clear",
                "content": "Please upvote if you like it:\\n```csharp\\npublic int MaxLength(IList<string> arr, int i = 0, string s = \"\")\\n{\\n\\tif (s.Distinct().Count() < s.Length) return 0;\\n\\n\\tif (arr.Count == i) return s.Length;\\n\\n\\treturn Math.Max(\\n\\t\\tMaxLength(arr, i + 1, s),\\n\\t\\tMaxLength(arr, i + 1, s + arr[i])\\n\\t);\\n}\\n```\\n\\nAnd of course, we can put it all on one line, although we really shouldn\\'t:\\n```csharp\\npublic int MaxLength(IList<string> arr, int i = 0, string s = \"\") =>\\n\\ts.Distinct().Count() < s.Length ? 0 : arr.Count == i ? s.Length : Math.Max(MaxLength(arr, i + 1, s), MaxLength(arr, i + 1, s + arr[i]));\\n```",
                "solutionTags": [
                    "C#",
                    "Recursion"
                ],
                "code": "```csharp\\npublic int MaxLength(IList<string> arr, int i = 0, string s = \"\")\\n{\\n\\tif (s.Distinct().Count() < s.Length) return 0;\\n\\n\\tif (arr.Count == i) return s.Length;\\n\\n\\treturn Math.Max(\\n\\t\\tMaxLength(arr, i + 1, s),\\n\\t\\tMaxLength(arr, i + 1, s + arr[i])\\n\\t);\\n}\\n```\n```csharp\\npublic int MaxLength(IList<string> arr, int i = 0, string s = \"\") =>\\n\\ts.Distinct().Count() < s.Length ? 0 : arr.Count == i ? s.Length : Math.Max(MaxLength(arr, i + 1, s), MaxLength(arr, i + 1, s + arr[i]));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2738251,
                "title": "python-elegant-short-dp",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n^2)\\n    Memory: O(n^2)\\n    \"\"\"\\n\\n    def maxLength(self, sequences: List[str]) -> int:\\n        dp = [set()]\\n\\n        for seq in sequences:\\n            chars = set(seq)\\n\\n            if len(chars) < len(seq):\\n                continue\\n\\n            dp.extend(chars | other for other in dp if not (chars & other))\\n\\n        return max(map(len, dp))\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n^2)\\n    Memory: O(n^2)\\n    \"\"\"\\n\\n    def maxLength(self, sequences: List[str]) -> int:\\n        dp = [set()]\\n\\n        for seq in sequences:\\n            chars = set(seq)\\n\\n            if len(chars) < len(seq):\\n                continue\\n\\n            dp.extend(chars | other for other in dp if not (chars & other))\\n\\n        return max(map(len, dp))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737648,
                "title": "java-recursion",
                "content": "Steps:\\n1. This is a standard **Take** and **Not take** Recursion Problem.\\n2. At each instance when the index reaches the list size, we need to check whether the **soFar** string formed is Valid or not(Check its Uniqueness);\\n3. Return the Max of Take and Not Take.\\n```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        return solve(arr, 0, \"\");\\n    }\\n    \\n    \\n    public int solve(List<String> arr, int i, String soFar)\\n    {\\n        if(i == arr.size())\\n        {\\n            if(isValid(soFar))\\n            {\\n                return soFar.length();\\n            }\\n            return 0;\\n        }\\n        \\n        int size1 = solve(arr, i+1, soFar);\\n        int size2 = solve(arr, i+1, soFar+arr.get(i));\\n        \\n        return Math.max(size1, size2);\\n\\n    }\\n    \\n    \\n    public boolean isValid(String s)\\n    {\\n        int[] freq = new int[26];\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            int val = s.charAt(i) - \\'a\\';\\n            freq[val]++;\\n            \\n            if(freq[val]>1)\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        return solve(arr, 0, \"\");\\n    }\\n    \\n    \\n    public int solve(List<String> arr, int i, String soFar)\\n    {\\n        if(i == arr.size())\\n        {\\n            if(isValid(soFar))\\n            {\\n                return soFar.length();\\n            }\\n            return 0;\\n        }\\n        \\n        int size1 = solve(arr, i+1, soFar);\\n        int size2 = solve(arr, i+1, soFar+arr.get(i));\\n        \\n        return Math.max(size1, size2);\\n\\n    }\\n    \\n    \\n    public boolean isValid(String s)\\n    {\\n        int[] freq = new int[26];\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            int val = s.charAt(i) - \\'a\\';\\n            freq[val]++;\\n            \\n            if(freq[val]>1)\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 637935,
                "title": "java-share-my-2-ms-solution-with-bitmap",
                "content": "The intuition is that since we only care about 26 letters, we can simply use an integer as a set.\\nIf we take bitwise and between two integers, we will get 0 if there is no duplicate.\\nAlso, we can just use bitwise OR to combine the previous strings. \\nBy this trick, we can avoid string add operation as well as faster inquiry for if all characters in current string is unique. \\n```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        int n = arr.size();\\n        int[] ans = new int[1];\\n        int[][] bitMap = new int[n][2];\\n        for (int i = 0; i < n; ++i) {\\n            int a = 0;\\n            for (char ch: arr.get(i).toCharArray()) {\\n                int bit = ch - \\'a\\';\\n                if (((a >> bit) & 1) == 1) {\\n                    a = 0;\\n                    break;\\n                }\\n                a |= (1 << bit);\\n            }\\n            bitMap[i][0] = a;\\n            bitMap[i][1] = a == 0 ? 0 : arr.get(i).length();\\n        }\\n        dfs(arr, bitMap, ans, 0, 0, 0);\\n        return ans[0];\\n    }\\n    \\n    private void dfs(List<String> arr, int[][] bitMap, int[] ans, int start, int curLen, int curBit) {\\n        if (ans[0] < curLen) ans[0] = curLen;\\n        for (int i = start; i < arr.size(); ++i) {\\n            if ((curBit & bitMap[i][0]) != 0) continue;\\n            dfs(arr, bitMap, ans, i + 1, curLen + bitMap[i][1], curBit | bitMap[i][0]);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        int n = arr.size();\\n        int[] ans = new int[1];\\n        int[][] bitMap = new int[n][2];\\n        for (int i = 0; i < n; ++i) {\\n            int a = 0;\\n            for (char ch: arr.get(i).toCharArray()) {\\n                int bit = ch - \\'a\\';\\n                if (((a >> bit) & 1) == 1) {\\n                    a = 0;\\n                    break;\\n                }\\n                a |= (1 << bit);\\n            }\\n            bitMap[i][0] = a;\\n            bitMap[i][1] = a == 0 ? 0 : arr.get(i).length();\\n        }\\n        dfs(arr, bitMap, ans, 0, 0, 0);\\n        return ans[0];\\n    }\\n    \\n    private void dfs(List<String> arr, int[][] bitMap, int[] ans, int start, int curLen, int curBit) {\\n        if (ans[0] < curLen) ans[0] = curLen;\\n        for (int i = start; i < arr.size(); ++i) {\\n            if ((curBit & bitMap[i][0]) != 0) continue;\\n            dfs(arr, bitMap, ans, i + 1, curLen + bitMap[i][1], curBit | bitMap[i][0]);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 808791,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef maxLength(self, arr: List[str]) -> int:\\n\\t\\t\\ts = [\"\"]\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i in arr:\\n\\t\\t\\t\\tif len(set(i)) == len(i):\\n\\t\\t\\t\\t\\tfor j in s[:]:\\n\\t\\t\\t\\t\\t\\tif len(i) + len(j) == len(set(i + j)):\\n\\t\\t\\t\\t\\t\\t\\ts.append(i + j)\\n\\t\\t\\t\\t\\t\\t\\tif len(i + j) > res:\\n\\t\\t\\t\\t\\t\\t\\t\\tres = len(i + j)\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef maxLength(self, arr: List[str]) -> int:\\n\\t\\t\\ts = [\"\"]\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i in arr:\\n\\t\\t\\t\\tif len(set(i)) == len(i):\\n\\t\\t\\t\\t\\tfor j in s[:]:\\n\\t\\t\\t\\t\\t\\tif len(i) + len(j) == len(set(i + j)):\\n\\t\\t\\t\\t\\t\\t\\ts.append(i + j)\\n\\t\\t\\t\\t\\t\\t\\tif len(i + j) > res:\\n\\t\\t\\t\\t\\t\\t\\t\\tres = len(i + j)\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 2741390,
                "title": "clean-easy-recursive-solution-fully-explained-with-comments",
                "content": "```\\nclass Solution\\n{\\n    public:\\n    int ans = 0;\\t//to calculate the length of the final target string \\n    string temp = \"\";\\n    /*we are using global variable to maintain states of the string used in recursive dfs\\n    WHY? because passing string copies in the recursive calls takes space and memory which can lead to TLE, hence\\n    we\\'re avoiding that by pushing on nd popping off the global string as required to explore all states\\n                                 DONT WORRY...explained below*/\\n\\n    void dfs(int i, vector<string> &arr)\\n    {\\n        if (i == arr.size())\\n        {\\n            /*BASE case, read this after reading below the recursive calls*/\\n            /*after all exploration we hav reached the end of the vector of strings, no new strings to add, hence we check the length of\\n            our final target string satisfying all criteria which we got this path of exploration\\n            we will get different target strings due to different paths of recursive exploration, we store the maximum of all target strings*/\\n            if (ans < temp.size()) ans = temp.size();\\n            return;\\t// we return coz no more strings in vector of strings to add\\n        }\\n        /*say we are standing at i\\'th index of vector of string....means we are standing at some string which \\n        we can add to our temp string*/\\n\\n        /*now there can be 2 possibilties, we can add the i\\'th string or not add move to the i+1\\'th string in recursive call\\n        let us explore both, starting with add case */\\n\\n        /*but lets check wether such addition is valid or not and then we add*/\\n        if (check(temp + arr[i]))\\n        {\\n            /*so now we add, that to our temp string and use that for later recursive calls, but wait we should save\\n            state of temp, WHY? I\\'ll explain do it now*/\\n            string t = temp;\\n            temp += arr[i];\\n            dfs(i + 1, arr);\\t//using new temp for exploration in the recursive calls\\n            /*now we have returned from the recursive exploration, so now we have to explore the not add case, where we dont consider the i\\'th string\\n            but we need the old temp string for that exploration, not the new temp we used for add case...hence we reassign temp to its old value \\n            and use it for not add case */\\n            temp = t;\\n        }\\n        dfs(i + 1, arr);\\t//exploring not add case\\n    }\\n\\t\\n\\tbool check(string s)\\n    {\\n        /*say we concat two strings as per question....but we need to check wether that new string  is valid or     \\n        not, hence we use a vector to maintain frequency of the alphabets, anytime we encounter a character already\\n        having frequncy 1, means we have previously encountered, hence return false */\\n        vector<int> hash(26, 0);\\n        for (auto &i: s) if (hash[i - \\'a\\']++) return false;\\n        return true;\\t//otherwise its valid string\\n    }\\n\\t\\n    int maxLength(vector<string> &arr)\\n    {\\n       \\t//recursive call to explore all possibilities of addition to the global empty string temp\\n        dfs(0, arr);\\n        return ans;\\t//after the call, our answer is stored in ans variable\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n    int ans = 0;\\t//to calculate the length of the final target string \\n    string temp = \"\";\\n    /*we are using global variable to maintain states of the string used in recursive dfs\\n    WHY? because passing string copies in the recursive calls takes space and memory which can lead to TLE, hence\\n    we\\'re avoiding that by pushing on nd popping off the global string as required to explore all states\\n                                 DONT WORRY...explained below*/\\n\\n    void dfs(int i, vector<string> &arr)\\n    {\\n        if (i == arr.size())\\n        {\\n            /*BASE case, read this after reading below the recursive calls*/\\n            /*after all exploration we hav reached the end of the vector of strings, no new strings to add, hence we check the length of\\n            our final target string satisfying all criteria which we got this path of exploration\\n            we will get different target strings due to different paths of recursive exploration, we store the maximum of all target strings*/\\n            if (ans < temp.size()) ans = temp.size();\\n            return;\\t// we return coz no more strings in vector of strings to add\\n        }\\n        /*say we are standing at i\\'th index of vector of string....means we are standing at some string which \\n        we can add to our temp string*/\\n\\n        /*now there can be 2 possibilties, we can add the i\\'th string or not add move to the i+1\\'th string in recursive call\\n        let us explore both, starting with add case */\\n\\n        /*but lets check wether such addition is valid or not and then we add*/\\n        if (check(temp + arr[i]))\\n        {\\n            /*so now we add, that to our temp string and use that for later recursive calls, but wait we should save\\n            state of temp, WHY? I\\'ll explain do it now*/\\n            string t = temp;\\n            temp += arr[i];\\n            dfs(i + 1, arr);\\t//using new temp for exploration in the recursive calls\\n            /*now we have returned from the recursive exploration, so now we have to explore the not add case, where we dont consider the i\\'th string\\n            but we need the old temp string for that exploration, not the new temp we used for add case...hence we reassign temp to its old value \\n            and use it for not add case */\\n            temp = t;\\n        }\\n        dfs(i + 1, arr);\\t//exploring not add case\\n    }\\n\\t\\n\\tbool check(string s)\\n    {\\n        /*say we concat two strings as per question....but we need to check wether that new string  is valid or     \\n        not, hence we use a vector to maintain frequency of the alphabets, anytime we encounter a character already\\n        having frequncy 1, means we have previously encountered, hence return false */\\n        vector<int> hash(26, 0);\\n        for (auto &i: s) if (hash[i - \\'a\\']++) return false;\\n        return true;\\t//otherwise its valid string\\n    }\\n\\t\\n    int maxLength(vector<string> &arr)\\n    {\\n       \\t//recursive call to explore all possibilities of addition to the global empty string temp\\n        dfs(0, arr);\\n        return ans;\\t//after the call, our answer is stored in ans variable\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738368,
                "title": "c-bit-manipulation-fast-0ms-clean-code",
                "content": "Time permitting I\\'ll write up some other solutions for this problem as well, e.g. backtracking would be a common approach to take.\\n\\n# Approach 1: bitmasking and generating valid subsets (0ms)\\n\\nWe are turn the input array into bitmasks. Each character ```\\'a\\' ... \\'z\\'``` gets it\\'s own bit. With that we can quickly check with ```and``` if there is a conflict and then expand the match with ```or```. Once we have bitmasks for each element in ```arr``` we are expanding the set of possible solutions and then just look for the largest one.\\n\\n```cpp\\n    static int maxLength(const vector<string>& arr) {\\n        // Turn |arr| into bitmasks.\\n        vector<int> bms;\\n        bms.reserve(arr.size());\\n        for (const string& a : arr) {\\n            const int m = bitmask(a);\\n            if (m != -1) bms.push_back(m);\\n        }\\n        \\n        // Expand the bitmasks if there is no conflict.\\n        vector<int> as;\\n        for (int bm : bms) {\\n            int as_size = as.size();\\n            for (int i = 0; i < as_size; ++i)\\n                if (!(as[i] & bm)) as.push_back(as[i] | bm);\\n            as.push_back(bm);\\n        }\\n        \\n        // Look for the bitmask with the most bits set.\\n        int ans = 0;\\n        for (int a : as) ans = max(ans, __builtin_popcount(a));\\n        return ans;\\n    }\\n    \\n    // Turns |a| into a bitmask for each character present.\\n    //   Returns -1 if the characters are not unique.\\n    static int bitmask(const string& a) {\\n        int ans = 0;\\n        for (char ch : a) {\\n            const int mask = 1 << (ch - \\'a\\');\\n            if (ans & mask) return -1;\\n            ans |= mask;\\n        }\\n        return ans;\\n    }\\n```\\n\\nPicking up an idea from @stanislav-iablokov\\'s solution to make the conversion into a bitmask shorter, we end up this:\\n\\n```cpp\\n    static int maxLength(const vector<string>& arr) {\\n        // Turn |arr| into bitmasks.\\n        vector<int> bms;\\n        bms.reserve(arr.size());\\n        for (const string& a : arr) {\\n            int m = 0;\\n            for (char ch : a) m |= 1 << (ch - \\'a\\');\\n            // Are all the characters in |a| unique?\\n            if (__builtin_popcount(m) == size(a))\\n                bms.push_back(m);\\n        }\\n        \\n        // Expand the bitmasks if there is no conflict.\\n        vector<int> as;\\n        for (int bm : bms) {\\n            int as_size = as.size();\\n            for (int i = 0; i < as_size; ++i)\\n                if (!(as[i] & bm)) as.push_back(as[i] | bm);\\n            as.push_back(bm);\\n        }\\n        \\n        // Look for the bitmask with the most bits set.\\n        int ans = 0;\\n        for (int a : as) ans = max(ans, __builtin_popcount(a));\\n        return ans;\\n    }\\n```\\n\\nOther thing I like about @stanislav-iablokov\\'s solution is how it handles iterating over the existing part of all combinations while expanding it, instead of:\\n\\n```cpp\\n            int as_size = as.size();\\n            for (int i = 0; i < as_size; ++i)\\n                if (!(as[i] & bm)) as.push_back(as[i] | bm);\\n```\\n\\nIt does:\\n\\n```cpp\\n            for (int i = size(as) - 1; i >= 0; --i)\\n                if (!(as[i] & bm)) as.push_back(as[i] | bm);\\n```\\n\\nIt avoids the temporary variable and the order in which we look at the elements doens\\'t matter anyway.\\n\\nTODO(heder): We could consider an early exit if ```__builtin_popcount(x) == 26```, as we can not improve further.\\n\\n**Complexity Analsysis**\\nIf $$n$$ is the size of ```arr``` then the \\n  * Time complexity is $$O(2^n)$$ as we potentially creating the full powerset of ```arr```, and the same is true for the\\n  * Space complexity which is also $$O(2^n)$$.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\'a\\' ... \\'z\\'```\n```and```\n```or```\n```arr```\n```cpp\\n    static int maxLength(const vector<string>& arr) {\\n        // Turn |arr| into bitmasks.\\n        vector<int> bms;\\n        bms.reserve(arr.size());\\n        for (const string& a : arr) {\\n            const int m = bitmask(a);\\n            if (m != -1) bms.push_back(m);\\n        }\\n        \\n        // Expand the bitmasks if there is no conflict.\\n        vector<int> as;\\n        for (int bm : bms) {\\n            int as_size = as.size();\\n            for (int i = 0; i < as_size; ++i)\\n                if (!(as[i] & bm)) as.push_back(as[i] | bm);\\n            as.push_back(bm);\\n        }\\n        \\n        // Look for the bitmask with the most bits set.\\n        int ans = 0;\\n        for (int a : as) ans = max(ans, __builtin_popcount(a));\\n        return ans;\\n    }\\n    \\n    // Turns |a| into a bitmask for each character present.\\n    //   Returns -1 if the characters are not unique.\\n    static int bitmask(const string& a) {\\n        int ans = 0;\\n        for (char ch : a) {\\n            const int mask = 1 << (ch - \\'a\\');\\n            if (ans & mask) return -1;\\n            ans |= mask;\\n        }\\n        return ans;\\n    }\\n```\n```cpp\\n    static int maxLength(const vector<string>& arr) {\\n        // Turn |arr| into bitmasks.\\n        vector<int> bms;\\n        bms.reserve(arr.size());\\n        for (const string& a : arr) {\\n            int m = 0;\\n            for (char ch : a) m |= 1 << (ch - \\'a\\');\\n            // Are all the characters in |a| unique?\\n            if (__builtin_popcount(m) == size(a))\\n                bms.push_back(m);\\n        }\\n        \\n        // Expand the bitmasks if there is no conflict.\\n        vector<int> as;\\n        for (int bm : bms) {\\n            int as_size = as.size();\\n            for (int i = 0; i < as_size; ++i)\\n                if (!(as[i] & bm)) as.push_back(as[i] | bm);\\n            as.push_back(bm);\\n        }\\n        \\n        // Look for the bitmask with the most bits set.\\n        int ans = 0;\\n        for (int a : as) ans = max(ans, __builtin_popcount(a));\\n        return ans;\\n    }\\n```\n```cpp\\n            int as_size = as.size();\\n            for (int i = 0; i < as_size; ++i)\\n                if (!(as[i] & bm)) as.push_back(as[i] | bm);\\n```\n```cpp\\n            for (int i = size(as) - 1; i >= 0; --i)\\n                if (!(as[i] & bm)) as.push_back(as[i] | bm);\\n```\n```__builtin_popcount(x) == 26```\n```arr```\n```arr```",
                "codeTag": "Unknown"
            },
            {
                "id": 2738068,
                "title": "python-simple-solution-iterate-over-all-possible-valid-combinations-beats-88",
                "content": "EDIT: We can add ```if len(string ) == len(set(string)): ```  after ``` for string in arr:``` to save some extra computations by discarding the parts which have duplicate letters. Thanks for @RezaTalebzadeh for pointing that out!\\n\\n```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        sz, combinedWords, maxLength = len(arr), [\\'\\'], 0\\n        # Iterate over every string present in arr\\n        for string in arr:\\n            # combinedWords contains all possible combinations of the strings present in arr\\n            # combinedWords array is incrementally built upon by adding the current string\\n            # in arr to all the present combinations already present in combinedWords\\n            for word in combinedWords:\\n                # add the present string to present combination\\n                resultantWord = word + string\\n                # if the combination contains duplicates, discard it\\n                if len(resultantWord) != len(set(resultantWord)):\\n                    continue\\n                # append the new combination in the list of combinations\\n                combinedWords.append(resultantWord)\\n                # update the maximum length\\n                maxLength = max(maxLength, len(resultantWord))\\n        return maxLength\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```if len(string ) == len(set(string)): ```\n``` for string in arr:```\n```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        sz, combinedWords, maxLength = len(arr), [\\'\\'], 0\\n        # Iterate over every string present in arr\\n        for string in arr:\\n            # combinedWords contains all possible combinations of the strings present in arr\\n            # combinedWords array is incrementally built upon by adding the current string\\n            # in arr to all the present combinations already present in combinedWords\\n            for word in combinedWords:\\n                # add the present string to present combination\\n                resultantWord = word + string\\n                # if the combination contains duplicates, discard it\\n                if len(resultantWord) != len(set(resultantWord)):\\n                    continue\\n                # append the new combination in the list of combinations\\n                combinedWords.append(resultantWord)\\n                # update the maximum length\\n                maxLength = max(maxLength, len(resultantWord))\\n        return maxLength\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1950304,
                "title": "java-solution-81-faster",
                "content": "**One of Microsoft\\'s most asked question**\\n\\n**Upvote if u like the post**\\n```\\n\\n// create a list to store all the combination of word formed by concatenation, also include the string of arr\\n\\n// Before adding a string in the list check if the string has unique characters or not \\n\\n// Keep track of the maxLength concatenated string added in the list\\n\\nclass Solution {\\n    \\n    // check duplicacy\\n    \\n    private boolean checkUnique(String x)\\n    {\\n        int[] fq=new int[26];\\n        \\n        for(char c:x.toCharArray())\\n        {\\n            if(++fq[c-\\'a\\']>1)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    public int maxLength(List<String> arr) \\n    {\\n        List<String> list=new ArrayList<>();\\n        int ans=0;\\n        for(String str:arr)\\n        {\\n            List<String> tmp=new ArrayList<>();\\n            if(!checkUnique(str))\\n                continue;\\n            tmp.add(str); // store all combination of strings formed\\n            ans=Math.max(ans,str.length());\\n            for(String s:list)\\n            {\\n                String cur=s+str;  // combination\\n                if(checkUnique(cur))\\n                {\\n                    tmp.add(cur);\\n                    ans=Math.max(ans,cur.length());\\n                }\\n            }\\n            list.addAll(tmp);  // Main list  \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n\\n// create a list to store all the combination of word formed by concatenation, also include the string of arr\\n\\n// Before adding a string in the list check if the string has unique characters or not \\n\\n// Keep track of the maxLength concatenated string added in the list\\n\\nclass Solution {\\n    \\n    // check duplicacy\\n    \\n    private boolean checkUnique(String x)\\n    {\\n        int[] fq=new int[26];\\n        \\n        for(char c:x.toCharArray())\\n        {\\n            if(++fq[c-\\'a\\']>1)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    public int maxLength(List<String> arr) \\n    {\\n        List<String> list=new ArrayList<>();\\n        int ans=0;\\n        for(String str:arr)\\n        {\\n            List<String> tmp=new ArrayList<>();\\n            if(!checkUnique(str))\\n                continue;\\n            tmp.add(str); // store all combination of strings formed\\n            ans=Math.max(ans,str.length());\\n            for(String s:list)\\n            {\\n                String cur=s+str;  // combination\\n                if(checkUnique(cur))\\n                {\\n                    tmp.add(cur);\\n                    ans=Math.max(ans,cur.length());\\n                }\\n            }\\n            list.addAll(tmp);  // Main list  \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1479346,
                "title": "c-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int maxUniqueChar(string s) {  // CHECKER FUNCTION\\n        int count[26] = {0};\\n        for(int i = 0; i < s.size(); i++)\\n            if(count[s[i] - \\'a\\']++ > 0) return 0;\\n        return s.size();\\n    }\\n    \\n    void solve(vector<string> &arr, int index, string curr, int &ans) {\\n        if(index == arr.size()) {            // BASE CONDITION\\n            if(maxUniqueChar(curr) > ans) {\\n            ans = curr.size();\\n            }\\n            return;\\n        }\\n        solve(arr, index+1, curr, ans); \\n        solve(arr, index+1, curr+arr[index], ans);\\n    }\\n    \\n    int maxLength(vector<string> &arr) {\\n        int ans = 0;\\n        solve(arr, 0, \"\", ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maxUniqueChar(string s) {  // CHECKER FUNCTION\\n        int count[26] = {0};\\n        for(int i = 0; i < s.size(); i++)\\n            if(count[s[i] - \\'a\\']++ > 0) return 0;\\n        return s.size();\\n    }\\n    \\n    void solve(vector<string> &arr, int index, string curr, int &ans) {\\n        if(index == arr.size()) {            // BASE CONDITION\\n            if(maxUniqueChar(curr) > ans) {\\n            ans = curr.size();\\n            }\\n            return;\\n        }\\n        solve(arr, index+1, curr, ans); \\n        solve(arr, index+1, curr+arr[index], ans);\\n    }\\n    \\n    int maxLength(vector<string> &arr) {\\n        int ans = 0;\\n        solve(arr, 0, \"\", ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1478746,
                "title": "100-faster-0ms-c-solution-with-explanation",
                "content": "* we need to consider alphabets to be set bits in an integer\\n* if a word contains \\'a\\' then first bit would be set ....001 similarly if a word contains both \\'a\\' and \\'b\\' then the integer would be .....011\\n* so I pushed all the integers formed in the vector v\\n* recursively checking whether I can include that particular integer\\n* so if all the bits are different in two integers then **(a^b == a|b)** so we can include that else proceed to next number\\n```\\nvector<int>v;\\nint n;\\nint ans;\\nvoid check(int ind,int cur)\\n{\\n    if(ind==n)\\n    {\\n        return ;\\n    }\\n    if((cur^v[ind])==(cur|v[ind]))\\n    {\\n        // cout<<\"hi\";\\n        ans = max(ans,__builtin_popcount(cur|v[ind]));\\n        check(ind+1,cur|v[ind]);\\n    }\\n    check(ind+1,cur);\\n}\\nclass Solution {\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        v = {};\\n        ans = 0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            int cur = 0;\\n            for(int j=0;j<arr[i].size();j++)\\n            {\\n                if((cur>>(arr[i][j]-\\'a\\'))&1)\\n                {\\n                    cur=0;\\n                    break;\\n                }\\n                else\\n                {\\n                    cur = cur|(1<<(arr[i][j]-\\'a\\'));\\n                }\\n            }\\n            if(cur)\\n            {\\n                // cout<<cur<<\" \";\\n                v.push_back(cur);\\n            }\\n        }\\n        n = v.size();\\n        if(n==0)\\n        {\\n            return 0;\\n        }\\n        check(0,0);\\n        \\n        // cout<<\"here\"<<(133&131072);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvector<int>v;\\nint n;\\nint ans;\\nvoid check(int ind,int cur)\\n{\\n    if(ind==n)\\n    {\\n        return ;\\n    }\\n    if((cur^v[ind])==(cur|v[ind]))\\n    {\\n        // cout<<\"hi\";\\n        ans = max(ans,__builtin_popcount(cur|v[ind]));\\n        check(ind+1,cur|v[ind]);\\n    }\\n    check(ind+1,cur);\\n}\\nclass Solution {\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        v = {};\\n        ans = 0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            int cur = 0;\\n            for(int j=0;j<arr[i].size();j++)\\n            {\\n                if((cur>>(arr[i][j]-\\'a\\'))&1)\\n                {\\n                    cur=0;\\n                    break;\\n                }\\n                else\\n                {\\n                    cur = cur|(1<<(arr[i][j]-\\'a\\'));\\n                }\\n            }\\n            if(cur)\\n            {\\n                // cout<<cur<<\" \";\\n                v.push_back(cur);\\n            }\\n        }\\n        n = v.size();\\n        if(n==0)\\n        {\\n            return 0;\\n        }\\n        check(0,0);\\n        \\n        // cout<<\"here\"<<(133&131072);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 546637,
                "title": "java-simple-dfs",
                "content": "```\\nclass Solution {\\n    int res = 0;\\n    public int maxLength(List<String> arr) {\\n        dfs(arr, 0, \"\");\\n        return res;\\n    }\\n    \\n    private void dfs(List<String> l, int idx, String s) {\\n        if (unique(s)) res = Math.max(res, s.length());\\n        else return;\\n        for (int i = idx; i < l.size(); i++) {  // start with idx;\\n            if (unique(l.get(i))) dfs(l, i + 1, s + l.get(i));\\n        }\\n    }\\n    \\n    private boolean unique(String s) {\\n        int[] cnt = new int[26];\\n        for (char c : s.toCharArray()) {\\n            if (++cnt[c - \\'a\\'] > 1) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\nref: https://leetcode.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/discuss/414180/Clean-JavaJavaScript-DFS-solution",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int res = 0;\\n    public int maxLength(List<String> arr) {\\n        dfs(arr, 0, \"\");\\n        return res;\\n    }\\n    \\n    private void dfs(List<String> l, int idx, String s) {\\n        if (unique(s)) res = Math.max(res, s.length());\\n        else return;\\n        for (int i = idx; i < l.size(); i++) {  // start with idx;\\n            if (unique(l.get(i))) dfs(l, i + 1, s + l.get(i));\\n        }\\n    }\\n    \\n    private boolean unique(String s) {\\n        int[] cnt = new int[26];\\n        for (char c : s.toCharArray()) {\\n            if (++cnt[c - \\'a\\'] > 1) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 497943,
                "title": "backtracking-concise-and-clean-for-interviews",
                "content": "\\t  private int maxLen = 0;\\n\\n\\t  public int maxLength(List<String> arr) {\\n\\t\\tmaxLen = 0;\\n\\n\\t\\tSet<Character> set = new HashSet<>();\\n\\t\\thelper(set, arr, 0);\\n\\n\\t\\treturn maxLen;\\n\\t  }\\n\\n\\t  private void helper(Set<Character> set, List<String> arr, int index) {\\n\\t\\tif (index == arr.size()) {\\n\\t\\t  return;\\n\\t\\t}\\n\\n\\t\\tchar[] s = arr.get(index).toCharArray();\\n\\n\\t\\tboolean unique = true;\\n\\n\\t\\tSet<Character> chars = new HashSet<>();\\n\\t\\tfor (char ch : s) {\\n\\t\\t  if (chars.contains(ch) || set.contains(ch)) {\\n\\t\\t\\tunique = false;\\n\\t\\t\\tbreak;\\n\\t\\t  }\\n\\n\\t\\t  chars.add(ch);\\n\\t\\t}\\n\\n\\t\\thelper(set, arr, index + 1);\\n\\n\\t\\tif (unique) {\\n\\t\\t  maxLen = Math.max(maxLen, set.size() + s.length);\\n\\n\\t\\t  set.addAll(chars);\\n\\t\\t  helper(set, arr, index + 1);\\n\\t\\t  set.removeAll(chars);\\n\\t\\t}\\n\\t  }",
                "solutionTags": [
                    "Java",
                    "String",
                    "Backtracking",
                    "Ordered Set"
                ],
                "code": "\\t  private int maxLen = 0;\\n\\n\\t  public int maxLength(List<String> arr) {\\n\\t\\tmaxLen = 0;\\n\\n\\t\\tSet<Character> set = new HashSet<>();\\n\\t\\thelper(set, arr, 0);\\n\\n\\t\\treturn maxLen;\\n\\t  }\\n\\n\\t  private void helper(Set<Character> set, List<String> arr, int index) {\\n\\t\\tif (index == arr.size()) {\\n\\t\\t  return;\\n\\t\\t}\\n\\n\\t\\tchar[] s = arr.get(index).toCharArray();\\n\\n\\t\\tboolean unique = true;\\n\\n\\t\\tSet<Character> chars = new HashSet<>();\\n\\t\\tfor (char ch : s) {\\n\\t\\t  if (chars.contains(ch) || set.contains(ch)) {\\n\\t\\t\\tunique = false;\\n\\t\\t\\tbreak;\\n\\t\\t  }\\n\\n\\t\\t  chars.add(ch);\\n\\t\\t}\\n\\n\\t\\thelper(set, arr, index + 1);\\n\\n\\t\\tif (unique) {\\n\\t\\t  maxLen = Math.max(maxLen, set.size() + s.length);\\n\\n\\t\\t  set.addAll(chars);\\n\\t\\t  helper(set, arr, index + 1);\\n\\t\\t  set.removeAll(chars);\\n\\t\\t}\\n\\t  }",
                "codeTag": "Unknown"
            },
            {
                "id": 3099091,
                "title": "c-backtracking-recursion-approach-very-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple approach is backtracking ,to generate all the combinations like subsets of array.The only thing here is to compare strings just check if they contain duplicates or their combination has duplicate if yes return ,if not the keep adding them in chain to make answer maximum as possible.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo just do a simple recursion and egenearte all the combiantions possible and return if duplicate found (beacuse that will not lead to the answer,WE DONT WANT DUPLICATE CONCATENATION)\\n# Complexity\\n- Time complexity:$$O(n*n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$ Don\\'t take the recursive stack that is $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int ans=0;\\n   bool isUnique(string s){\\n       set<char>st;\\n       for(auto x:s)st.insert(x);\\n       if(s.size()==st.size())return true;\\n       return false;\\n   }\\n   void backtrack(vector<string>&arr,string temp,int start){\\n        if(!isUnique(temp) )return ;\\n        ans=max(ans,(int)temp.size());\\n         for(int i=start;i<arr.size();i++)\\n          backtrack(arr,temp+arr[i],i+1);\\n           \\n   }\\n    int maxLength(vector<string>& arr) {\\n        string s=\"\";\\n        backtrack(arr,s,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int ans=0;\\n   bool isUnique(string s){\\n       set<char>st;\\n       for(auto x:s)st.insert(x);\\n       if(s.size()==st.size())return true;\\n       return false;\\n   }\\n   void backtrack(vector<string>&arr,string temp,int start){\\n        if(!isUnique(temp) )return ;\\n        ans=max(ans,(int)temp.size());\\n         for(int i=start;i<arr.size();i++)\\n          backtrack(arr,temp+arr[i],i+1);\\n           \\n   }\\n    int maxLength(vector<string>& arr) {\\n        string s=\"\";\\n        backtrack(arr,s,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738276,
                "title": "c-use-recursion-easy-to-understand",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    \\n    bool check(string &a, string &b)\\n    {\\n        vector<int> vis(26, 0);\\n        for(auto it:a)\\n            vis[it-\\'a\\']++;\\n        \\n\\t\\t//comparing each char of string a with every char of string b\\n        for(int i=0; i<a.size(); i++)\\n        {\\n            if(vis[a[i]-\\'a\\'] > 1) return false; //check whether string a contains duplicate characters\\n            for(int j=0; j<b.size(); j++)\\n            {\\n                if(a[i]==b[j]) return false; //check whether string a and b have same characters\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int f(int i, vector<string>& arr, string str)\\n    {\\n        if(i==0)\\n        {\\n            if(check(arr[0], str))\\n                return arr[0].size();\\n            return 0;\\n        }\\n        \\n        int take=0, not_take=0;\\n        \\n        not_take = 0 + f(i-1, arr, str);\\n        \\n        if(check(arr[i], str))\\n            take = arr[i].size() + f(i-1, arr, str+arr[i]);\\n        \\n        return max(not_take, take);\\n    }\\n    \\n    int maxLength(vector<string>& arr) \\n    {\\n        return f(arr.size()-1, arr, \"\");\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    \\n    bool check(string &a, string &b)\\n    {\\n        vector<int> vis(26, 0);\\n        for(auto it:a)\\n            vis[it-\\'a\\']++;\\n        \\n\\t\\t//comparing each char of string a with every char of string b\\n        for(int i=0; i<a.size(); i++)\\n        {\\n            if(vis[a[i]-\\'a\\'] > 1) return false; //check whether string a contains duplicate characters\\n            for(int j=0; j<b.size(); j++)\\n            {\\n                if(a[i]==b[j]) return false; //check whether string a and b have same characters\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int f(int i, vector<string>& arr, string str)\\n    {\\n        if(i==0)\\n        {\\n            if(check(arr[0], str))\\n                return arr[0].size();\\n            return 0;\\n        }\\n        \\n        int take=0, not_take=0;\\n        \\n        not_take = 0 + f(i-1, arr, str);\\n        \\n        if(check(arr[i], str))\\n            take = arr[i].size() + f(i-1, arr, str+arr[i]);\\n        \\n        return max(not_take, take);\\n    }\\n    \\n    int maxLength(vector<string>& arr) \\n    {\\n        return f(arr.size()-1, arr, \"\");\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737788,
                "title": "c-bit-manipulation-10ms-well-commented-easy-solution",
                "content": "Upvote if you find this helpful. Comment if you have any doubts. \\n```\\nclass Solution {\\npublic:\\n    int solve(vector<string> &arr,int i,int vis){\\n        if(i==arr.size()){\\n            return 0 ;\\n        }\\n        int n1 = solve(arr,i+1,vis);\\n        int n2 = INT_MIN;\\n        bool flag = 0;\\n        for(int j = 0;j<arr[i].size();j++){\\n            // check if any of the character in ith string is already in the ans using bit manipulation\\n            if((vis & (1<<(arr[i][j]-\\'a\\'))) == (1<<(arr[i][j]-\\'a\\'))){\\n                flag=1;\\n                break;\\n            }\\n            // we include the particular alphabet in the ans\\n            else{\\n                vis |= (1<<(arr[i][j]-\\'a\\'));\\n            }\\n        }\\n        // if any of the ith string character is already in the ans, we cannot include that string\\n        if(flag){\\n            return n1;\\n        }\\n        // if no characters of ith string are in the ans, we take maximum of including and not including it and return max\\n        \\n        n2 = arr[i].size()+solve(arr,i+1,vis);\\n        return max(n1,n2);\\n    }\\n    int maxLength(vector<string>& arr) {\\n        return solve(arr,0,0);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<string> &arr,int i,int vis){\\n        if(i==arr.size()){\\n            return 0 ;\\n        }\\n        int n1 = solve(arr,i+1,vis);\\n        int n2 = INT_MIN;\\n        bool flag = 0;\\n        for(int j = 0;j<arr[i].size();j++){\\n            // check if any of the character in ith string is already in the ans using bit manipulation\\n            if((vis & (1<<(arr[i][j]-\\'a\\'))) == (1<<(arr[i][j]-\\'a\\'))){\\n                flag=1;\\n                break;\\n            }\\n            // we include the particular alphabet in the ans\\n            else{\\n                vis |= (1<<(arr[i][j]-\\'a\\'));\\n            }\\n        }\\n        // if any of the ith string character is already in the ans, we cannot include that string\\n        if(flag){\\n            return n1;\\n        }\\n        // if no characters of ith string are in the ans, we take maximum of including and not including it and return max\\n        \\n        n2 = arr[i].size()+solve(arr,i+1,vis);\\n        return max(n1,n2);\\n    }\\n    int maxLength(vector<string>& arr) {\\n        return solve(arr,0,0);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1475426,
                "title": "java-simple-backtracking-using-sets-with-explanation",
                "content": "In a real interview, I would have asked for clarification: \"Can a certain string contain duplicate characters by itself?\". They should have made it clear in the sample test cases or in the description. I\\'d like to point out that in this problem, duplicate characters are allowed in input strings. For example, [\"aa\",\"bc\",\"ac\"] is a valid input.\\n\\nThe time complexity will be **O(2^n)** because I choose or not choose each string for every previous choice.\\nThe space complexity will be **O(n)** because I will keep a set of all string characters, and the longest set at any point will contain atmost 26 characters (constant).\\n\\n```\\nclass Solution {\\n        List<Set<Character>> sets = new ArrayList<>();\\n        int maxLength = 0;\\n    public int maxLength(List<String> arr) {\\n        // to make sure that terms with existing letters are not considered\\n        // keep track of seen letters\\n        // because all need to be unique, use a set\\n        // if two sets are disjoint, then combine them, or not\\n        for(String a : arr){\\n            Set<Character> curr = new HashSet<>();\\n            for(char c : a.toCharArray()){\\n                curr.add(c);\\n            }\\n            sets.add(curr);\\n        }\\n        tryConcatenations(arr, 0, new HashSet<>());\\n        \\n        return maxLength;\\n    }\\n    \\n    private void tryConcatenations(List<String> arr, int index, Set<Character> currentSet){\\n        // update maxLength to current if greater\\n\\t\\t// if any string is added, this recursive function will always be called with i+1 as index\\n\\t\\t// so, maxlength will always be updated whenever a new set of characters is added to the result\\n        maxLength = Math.max(maxLength, currentSet.size());\\n        \\n        for(int i = index; i < arr.size(); i++){\\n            // check if the string itself contains repeated characters\\n            if(arr.get(i).length() != sets.get(i).size())\\n                continue;\\n            // take this string and split its characters (done in global \"sets\")\\n            // if there is any character in current sequence then don\\'t add\\n            boolean repeats = false;\\n            for(char c : sets.get(i)){\\n                if(currentSet.contains(c)){\\n                    repeats = true;\\n                    break;\\n                }\\n            }\\n            // if unique characters then proceed\\n            if(!repeats){\\n                Set<Character> nextSet = new HashSet<>(currentSet);\\n                nextSet.addAll(sets.get(i));\\n\\t\\t\\t\\t// calling the function with the current string added\\n                tryConcatenations(arr, i+1, nextSet);\\n            }\\n        }\\n        // the case where the current string is not added will be considered in all further iterations of this loop\\n    }\\n}\\n```\\n**Please upvote if you found the solution helpful.**",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n        List<Set<Character>> sets = new ArrayList<>();\\n        int maxLength = 0;\\n    public int maxLength(List<String> arr) {\\n        // to make sure that terms with existing letters are not considered\\n        // keep track of seen letters\\n        // because all need to be unique, use a set\\n        // if two sets are disjoint, then combine them, or not\\n        for(String a : arr){\\n            Set<Character> curr = new HashSet<>();\\n            for(char c : a.toCharArray()){\\n                curr.add(c);\\n            }\\n            sets.add(curr);\\n        }\\n        tryConcatenations(arr, 0, new HashSet<>());\\n        \\n        return maxLength;\\n    }\\n    \\n    private void tryConcatenations(List<String> arr, int index, Set<Character> currentSet){\\n        // update maxLength to current if greater\\n\\t\\t// if any string is added, this recursive function will always be called with i+1 as index\\n\\t\\t// so, maxlength will always be updated whenever a new set of characters is added to the result\\n        maxLength = Math.max(maxLength, currentSet.size());\\n        \\n        for(int i = index; i < arr.size(); i++){\\n            // check if the string itself contains repeated characters\\n            if(arr.get(i).length() != sets.get(i).size())\\n                continue;\\n            // take this string and split its characters (done in global \"sets\")\\n            // if there is any character in current sequence then don\\'t add\\n            boolean repeats = false;\\n            for(char c : sets.get(i)){\\n                if(currentSet.contains(c)){\\n                    repeats = true;\\n                    break;\\n                }\\n            }\\n            // if unique characters then proceed\\n            if(!repeats){\\n                Set<Character> nextSet = new HashSet<>(currentSet);\\n                nextSet.addAll(sets.get(i));\\n\\t\\t\\t\\t// calling the function with the current string added\\n                tryConcatenations(arr, i+1, nextSet);\\n            }\\n        }\\n        // the case where the current string is not added will be considered in all further iterations of this loop\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1128271,
                "title": "swift-solution",
                "content": "```swift\\nclass Solution {\\n    func maxLength(_ arr: [String]) -> Int {\\n        var map = [String: Set<Character>](), ans = 0\\n        for str in arr {\\n            let chars = Set<Character>(str)\\n            if chars.count == str.count {\\n                for (key, existedChars) in map {\\n                    if existedChars.intersection(chars).isEmpty {\\n                        let str = \"\"  + key  + str\\n                        map[str] = existedChars.union(chars)\\n                        ans = max(ans, str.count)\\n                    }\\n                }\\n                map[str] = chars\\n                ans = max(ans, str.count)\\n                if ans == 26 { return 26 }\\n            }\\n        }\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func maxLength(_ arr: [String]) -> Int {\\n        var map = [String: Set<Character>](), ans = 0\\n        for str in arr {\\n            let chars = Set<Character>(str)\\n            if chars.count == str.count {\\n                for (key, existedChars) in map {\\n                    if existedChars.intersection(chars).isEmpty {\\n                        let str = \"\"  + key  + str\\n                        map[str] = existedChars.union(chars)\\n                        ans = max(ans, str.count)\\n                    }\\n                }\\n                map[str] = chars\\n                ans = max(ans, str.count)\\n                if ans == 26 { return 26 }\\n            }\\n        }\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 885317,
                "title": "python-really-simple-backtracking-solution",
                "content": "\\t\\tdef maxLength(self, arr):\\n\\t\\t\\tself.maximum = 0\\n\\n\\t\\t\\tdef backtrack(start,array,s):\\n\\t\\t\\t\\tif len(s)==len(set(s)):\\n\\t\\t\\t\\t\\tself.maximum = max(self.maximum,len(s))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tfor i in range(start,len(array)):\\n\\t\\t\\t\\t\\tbacktrack(i+1,array,s + array[i])\\n\\n\\t\\t\\tbacktrack(0,arr,\"\")\\n\\t\\t\\treturn self.maximum\\n\\t\\t\\t\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "\\t\\tdef maxLength(self, arr):\\n\\t\\t\\tself.maximum = 0\\n\\n\\t\\t\\tdef backtrack(start,array,s):\\n\\t\\t\\t\\tif len(s)==len(set(s)):\\n\\t\\t\\t\\t\\tself.maximum = max(self.maximum,len(s))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tfor i in range(start,len(array)):\\n\\t\\t\\t\\t\\tbacktrack(i+1,array,s + array[i])\\n\\n\\t\\t\\tbacktrack(0,arr,\"\")\\n\\t\\t\\treturn self.maximum\\n\\t\\t\\t\\n",
                "codeTag": "Python3"
            },
            {
                "id": 540096,
                "title": "c-100-time-100-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxlen = 0;\\n    void backtrack(vector<int>& maskArr, vector<int>& sizeArr, int mask, int len, int pos) {\\n      if (pos == maskArr.size()) {\\n        maxlen = max(len, maxlen);\\n        return;\\n      }\\n      backtrack(maskArr, sizeArr, mask, len, pos + 1);\\n      if ((mask & maskArr[pos]) == 0) {\\n        backtrack(maskArr, sizeArr, mask | maskArr[pos], len + sizeArr[pos], pos + 1);\\n      }\\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        vector<int> maskArr;\\n        vector<int> sizeArr;\\n        int i;\\n        for (i = 0; i < arr.size(); i++) {\\n            string s = arr[i];\\n            int mask = 0;\\n            for (char c : s) {\\n                if (mask & (1 << (c - \\'a\\'))){\\n                    mask = -1;\\n                    break;\\n                }\\n                mask |= (1 << (c - \\'a\\'));\\n            }\\n            if (mask == -1)\\n                continue;\\n            maskArr.push_back(mask);\\n            sizeArr.push_back(s.size());\\n        }\\n        backtrack(maskArr, sizeArr, 0, 0, 0);\\n        return maxlen;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxlen = 0;\\n    void backtrack(vector<int>& maskArr, vector<int>& sizeArr, int mask, int len, int pos) {\\n      if (pos == maskArr.size()) {\\n        maxlen = max(len, maxlen);\\n        return;\\n      }\\n      backtrack(maskArr, sizeArr, mask, len, pos + 1);\\n      if ((mask & maskArr[pos]) == 0) {\\n        backtrack(maskArr, sizeArr, mask | maskArr[pos], len + sizeArr[pos], pos + 1);\\n      }\\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        vector<int> maskArr;\\n        vector<int> sizeArr;\\n        int i;\\n        for (i = 0; i < arr.size(); i++) {\\n            string s = arr[i];\\n            int mask = 0;\\n            for (char c : s) {\\n                if (mask & (1 << (c - \\'a\\'))){\\n                    mask = -1;\\n                    break;\\n                }\\n                mask |= (1 << (c - \\'a\\'));\\n            }\\n            if (mask == -1)\\n                continue;\\n            maskArr.push_back(mask);\\n            sizeArr.push_back(s.size());\\n        }\\n        backtrack(maskArr, sizeArr, 0, 0, 0);\\n        return maxlen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775767,
                "title": "easy-java-solution-recursion-backtracking",
                "content": "```\\n1. First Approach :- BruteForce Approach\\nStep1 :- generate all subsequences\\nstep2 :- check each subsequences has unique character or not\\nstep3 :- maintain max variable for length of each subsequence which has unique character\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        List<String> temp = new ArrayList();\\n        List<String> store = new ArrayList();\\n        getSubsequence(arr,0,store,temp);\\n\\n        return maxLen(store,0);\\n    }\\n    void getSubsequence(List<String> arr, int index,List<String> store,List<String> temp){\\n        if(index==arr.size()){\\n            String sum = \"\";\\n            for(String s:temp){\\n                sum+=s;\\n            }\\n            store.add(sum);\\n            return;\\n        }\\n        //include\\n        temp.add(arr.get(index));\\n        getSubsequence(arr,index+1,store,temp);\\n        \\n        //exclude\\n        temp.remove(temp.size()-1);\\n        getSubsequence(arr,index+1,store,temp);\\n        \\n    }\\n    int maxLen(List<String> store, int max){\\n        int map[] = new int[26];\\n         for(int i=0; i<store.size(); i++){\\n            if(getMax(store.get(i),map)){\\n                String p = store.get(i);\\n                max = Math.max(max,p.length());\\n            }\\n        }\\n        return max;\\n    }\\n    boolean getMax(String string, int[] map){\\n        map = new int[26];\\n        for(int i=0; i<string.length(); i++){\\n            if(map[string.charAt(i)-\\'a\\']==1)return false;\\n            else\\n                map[string.charAt(i)-\\'a\\'] = 1;\\n        }\\n        return true;\\n    }\\n}\\nT.C :- 2^n(for generating subsequences) * k(max length of subsequence i.e. loop for adding each string e.g. un+iq+ue)  + 2^n(checking each subsequnce for unique character) * k(max length of subsequence)\\n      \\n2. Second Approach :- removing extra O(2^n * k) we are not first generating all subsequence this time\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        \\n        int visited[] = new int[26];\\n        return helper(arr,visited,0,0);\\n    }\\n    \\n    boolean checking(int[] visited, String CurrentString)\\n    {\\n        \\n        //self check for current string having repeated character or not\\n        int[] self = new int[26];\\n        for(int i=0; i<CurrentString.length(); i++)\\n        {\\n            if(self[CurrentString.charAt(i)-\\'a\\']==1)\\n                return false;\\n            self[CurrentString.charAt(i)-\\'a\\'] = 1;\\n        }\\n        \\n        //for checking character of Current string is present in previous String or not\\n        for(int i=0; i<CurrentString.length(); i++)\\n        {\\n            if(visited[CurrentString.charAt(i)-\\'a\\']==1)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    \\n    int helper(List<String> arr,int[] visited,int index,int length)\\n    {\\n          if(index==arr.size())\\n            return length;\\n        \\n        String CurrentString = arr.get(index);\\n        \\n//checking current string each character is previously contained or not if contain simply call for next string\\n        if(!checking(visited,CurrentString))\\n            return helper(arr,visited,index+1,length);\\n//if current string\\'s characters are not previously visited we have two option 1.pick this string for calculating length 2. not pick \\n        else{\\n            \\n            //include\\n            //first of all mark 1 in visited array for each character\\n            for(int i=0; i<CurrentString.length(); i++)\\n            {\\n                visited[CurrentString.charAt(i)-\\'a\\'] = 1;\\n            }\\n            //add that current string length into length\\n            length +=CurrentString.length();\\n            //call recursion for remaining task\\n            int ans1 = helper(arr,visited,index+1,length);\\n            \\n            //exclude\\n            //undo all changes we made\\n            for(int i=0; i<CurrentString.length(); i++)\\n            {\\n                visited[CurrentString.charAt(i)-\\'a\\'] = 0;\\n            }\\n            length-=CurrentString.length();\\n            int ans2 = helper(arr,visited,index+1,length);\\n            \\n            return Math.max(ans1,ans2);\\n            \\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n1. First Approach :- BruteForce Approach\\nStep1 :- generate all subsequences\\nstep2 :- check each subsequences has unique character or not\\nstep3 :- maintain max variable for length of each subsequence which has unique character\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        List<String> temp = new ArrayList();\\n        List<String> store = new ArrayList();\\n        getSubsequence(arr,0,store,temp);\\n\\n        return maxLen(store,0);\\n    }\\n    void getSubsequence(List<String> arr, int index,List<String> store,List<String> temp){\\n        if(index==arr.size()){\\n            String sum = \"\";\\n            for(String s:temp){\\n                sum+=s;\\n            }\\n            store.add(sum);\\n            return;\\n        }\\n        //include\\n        temp.add(arr.get(index));\\n        getSubsequence(arr,index+1,store,temp);\\n        \\n        //exclude\\n        temp.remove(temp.size()-1);\\n        getSubsequence(arr,index+1,store,temp);\\n        \\n    }\\n    int maxLen(List<String> store, int max){\\n        int map[] = new int[26];\\n         for(int i=0; i<store.size(); i++){\\n            if(getMax(store.get(i),map)){\\n                String p = store.get(i);\\n                max = Math.max(max,p.length());\\n            }\\n        }\\n        return max;\\n    }\\n    boolean getMax(String string, int[] map){\\n        map = new int[26];\\n        for(int i=0; i<string.length(); i++){\\n            if(map[string.charAt(i)-\\'a\\']==1)return false;\\n            else\\n                map[string.charAt(i)-\\'a\\'] = 1;\\n        }\\n        return true;\\n    }\\n}\\nT.C :- 2^n(for generating subsequences) * k(max length of subsequence i.e. loop for adding each string e.g. un+iq+ue)  + 2^n(checking each subsequnce for unique character) * k(max length of subsequence)\\n      \\n2. Second Approach :- removing extra O(2^n * k) we are not first generating all subsequence this time\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        \\n        int visited[] = new int[26];\\n        return helper(arr,visited,0,0);\\n    }\\n    \\n    boolean checking(int[] visited, String CurrentString)\\n    {\\n        \\n        //self check for current string having repeated character or not\\n        int[] self = new int[26];\\n        for(int i=0; i<CurrentString.length(); i++)\\n        {\\n            if(self[CurrentString.charAt(i)-\\'a\\']==1)\\n                return false;\\n            self[CurrentString.charAt(i)-\\'a\\'] = 1;\\n        }\\n        \\n        //for checking character of Current string is present in previous String or not\\n        for(int i=0; i<CurrentString.length(); i++)\\n        {\\n            if(visited[CurrentString.charAt(i)-\\'a\\']==1)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    \\n    int helper(List<String> arr,int[] visited,int index,int length)\\n    {\\n          if(index==arr.size())\\n            return length;\\n        \\n        String CurrentString = arr.get(index);\\n        \\n//checking current string each character is previously contained or not if contain simply call for next string\\n        if(!checking(visited,CurrentString))\\n            return helper(arr,visited,index+1,length);\\n//if current string\\'s characters are not previously visited we have two option 1.pick this string for calculating length 2. not pick \\n        else{\\n            \\n            //include\\n            //first of all mark 1 in visited array for each character\\n            for(int i=0; i<CurrentString.length(); i++)\\n            {\\n                visited[CurrentString.charAt(i)-\\'a\\'] = 1;\\n            }\\n            //add that current string length into length\\n            length +=CurrentString.length();\\n            //call recursion for remaining task\\n            int ans1 = helper(arr,visited,index+1,length);\\n            \\n            //exclude\\n            //undo all changes we made\\n            for(int i=0; i<CurrentString.length(); i++)\\n            {\\n                visited[CurrentString.charAt(i)-\\'a\\'] = 0;\\n            }\\n            length-=CurrentString.length();\\n            int ans2 = helper(arr,visited,index+1,length);\\n            \\n            return Math.max(ans1,ans2);\\n            \\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738530,
                "title": "c-recursion-easy-solution-concise-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool compare(vector<int> &selected,string &currString){\\n        vector<int> selfCheck(26,0);\\n        for(int i=0;i<currString.size();i++){\\n            if(selfCheck[currString[i] - \\'a\\'] == 1) return false;\\n            selfCheck[currString[i] - \\'a\\'] = 1;\\n        }\\n        for(int i=0;i<currString.size();i++){\\n            if(selected[currString[i]-\\'a\\'] == 1) return false;\\n        }\\n        return true;\\n    }\\n    int f(int i,vector<string> &arr,vector<int> &selected,int len){\\n        if(i == arr.size()){\\n            return len;\\n        }\\n        string currString = arr[i];\\n        if(compare(selected,currString) == false){\\n            return f(i+1,arr,selected,len);\\n        }\\n        else\\n        {\\n            //pick\\n            for(int j=0;j<currString.size();j++){\\n                selected[currString[j]-\\'a\\'] = 1;\\n            }\\n            len += currString.size();\\n            int op1 = f(i+1,arr,selected,len);\\n            \\n            //skip\\n            for(int j=0;j<currString.size();j++){\\n                selected[currString[j]-\\'a\\'] = 0;\\n            }\\n            len -= currString.size();\\n            int op2 = f(i+1,arr,selected,len);\\n            \\n            return max(op1,op2);\\n        }\\n    }\\n    int maxLength(vector<string>& arr) {\\n        vector<int> selected(26,0);\\n        return f(0,arr,selected,0);\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool compare(vector<int> &selected,string &currString){\\n        vector<int> selfCheck(26,0);\\n        for(int i=0;i<currString.size();i++){\\n            if(selfCheck[currString[i] - \\'a\\'] == 1) return false;\\n            selfCheck[currString[i] - \\'a\\'] = 1;\\n        }\\n        for(int i=0;i<currString.size();i++){\\n            if(selected[currString[i]-\\'a\\'] == 1) return false;\\n        }\\n        return true;\\n    }\\n    int f(int i,vector<string> &arr,vector<int> &selected,int len){\\n        if(i == arr.size()){\\n            return len;\\n        }\\n        string currString = arr[i];\\n        if(compare(selected,currString) == false){\\n            return f(i+1,arr,selected,len);\\n        }\\n        else\\n        {\\n            //pick\\n            for(int j=0;j<currString.size();j++){\\n                selected[currString[j]-\\'a\\'] = 1;\\n            }\\n            len += currString.size();\\n            int op1 = f(i+1,arr,selected,len);\\n            \\n            //skip\\n            for(int j=0;j<currString.size();j++){\\n                selected[currString[j]-\\'a\\'] = 0;\\n            }\\n            len -= currString.size();\\n            int op2 = f(i+1,arr,selected,len);\\n            \\n            return max(op1,op2);\\n        }\\n    }\\n    int maxLength(vector<string>& arr) {\\n        vector<int> selected(26,0);\\n        return f(0,arr,selected,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738388,
                "title": "java-easy-to-read-code-explained",
                "content": "The code is self explanatory and written modular in functions.\\n\\n# Intuition\\n1. Sanitize input for duplicate words and bad words (word that contains duplicate characters)\\n2. Backtrack and find the largest possible solution\\n\\nWe can expand the backtrack search only if adding the word at the current index `i` doesn\\'t cause a duplicate letter to appear. This is done efficiently by casting the strings `s1` and `s2` to sets and checking the intersection.\\n\\n# Code\\n```\\nimport java.util.*;\\nimport java.util.stream.Collectors;\\n\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        // Remove duplicate words and words with duplicate letters\\n        List<String> sanitizedArr = Set.copyOf(arr)\\n                        .stream()\\n                        .filter(this::wordWithDuplicateLetter)\\n                        .toList();\\n\\n        return maxLengthBacktrack(sanitizedArr, 0, \"\");\\n    }\\n\\n    private boolean wordWithDuplicateLetter(String s) {\\n        int[] letter = new int[26];\\n        for (char chr : s.toCharArray()) {\\n            letter[chr - \\'a\\']++;\\n            if (letter[chr - \\'a\\'] > 1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private int maxLengthBacktrack(List<String> source, int index, String runningConcatenation) {\\n        if (index == source.size()) {\\n            return runningConcatenation.length();\\n        }\\n\\n        int maxLength = 1;\\n\\n        // Option 1: don\\'t concatenate\\n        maxLength = Math.max(maxLength, maxLengthBacktrack(source, index + 1, runningConcatenation));\\n\\n        // Option 2: concatenate if you can\\n        String currentWord = source.get(index);\\n        if (!hasSharedCharacters(runningConcatenation.toString(), currentWord)) {\\n            maxLength = Math.max(maxLength, maxLengthBacktrack(source, index + 1, runningConcatenation + currentWord));\\n        }\\n\\n        return maxLength;\\n    }\\n\\n    /**\\n     * We want to make this operation O(|S1| + |S2|) and not O(|S1|*|S2|) therefore working with sets is easier as it is O(1) lookup\\n     */\\n    private boolean hasSharedCharacters(String s1, String s2) {\\n        Set<String> setS1 = s1.chars().boxed().map(Character::toString).collect(Collectors.toSet());\\n        Set<String> setS2 = s2.chars().boxed().map(Character::toString).collect(Collectors.toSet());\\n        return setS1\\n                .stream()\\n                .anyMatch(setS2::contains);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nimport java.util.stream.Collectors;\\n\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        // Remove duplicate words and words with duplicate letters\\n        List<String> sanitizedArr = Set.copyOf(arr)\\n                        .stream()\\n                        .filter(this::wordWithDuplicateLetter)\\n                        .toList();\\n\\n        return maxLengthBacktrack(sanitizedArr, 0, \"\");\\n    }\\n\\n    private boolean wordWithDuplicateLetter(String s) {\\n        int[] letter = new int[26];\\n        for (char chr : s.toCharArray()) {\\n            letter[chr - \\'a\\']++;\\n            if (letter[chr - \\'a\\'] > 1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private int maxLengthBacktrack(List<String> source, int index, String runningConcatenation) {\\n        if (index == source.size()) {\\n            return runningConcatenation.length();\\n        }\\n\\n        int maxLength = 1;\\n\\n        // Option 1: don\\'t concatenate\\n        maxLength = Math.max(maxLength, maxLengthBacktrack(source, index + 1, runningConcatenation));\\n\\n        // Option 2: concatenate if you can\\n        String currentWord = source.get(index);\\n        if (!hasSharedCharacters(runningConcatenation.toString(), currentWord)) {\\n            maxLength = Math.max(maxLength, maxLengthBacktrack(source, index + 1, runningConcatenation + currentWord));\\n        }\\n\\n        return maxLength;\\n    }\\n\\n    /**\\n     * We want to make this operation O(|S1| + |S2|) and not O(|S1|*|S2|) therefore working with sets is easier as it is O(1) lookup\\n     */\\n    private boolean hasSharedCharacters(String s1, String s2) {\\n        Set<String> setS1 = s1.chars().boxed().map(Character::toString).collect(Collectors.toSet());\\n        Set<String> setS2 = s2.chars().boxed().map(Character::toString).collect(Collectors.toSet());\\n        return setS1\\n                .stream()\\n                .anyMatch(setS2::contains);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737338,
                "title": "daily-leetcoding-challenge-october-day-24",
                "content": "This problem is the Daily LeetCoding Challenge for October, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1916333,
                "title": "c-backtracking-bitmasking",
                "content": "Since ther number of letters are all lower case i.e. only 26 letters, we can mask these letters with the help of an integer and find out if there is any letter in the string which is being previously used. If the answer is true we will not use that string and look for another string.\\n\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int ans = 0;\\n    //valid finds out if the letters in the current string are used before or not \\n    bool valid(int &mask, string s)\\n\\t{\\n        for(auto x: s)\\n\\t\\t{\\n\\t\\t\\t//if we find ther letter is being used we will return false\\n            if(mask&(1<<(x - \\'a\\'))) return false;\\n\\t\\t\\t//since we are using call by refrece for mask we are simultaneously calculating the new mask\\n            mask=mask|(1<<(x-\\'a\\'));\\n        }\\n        return true;\\n    }\\n    \\n    void rec(vector<string>& arr, int idx, int mask, int length)\\n\\t{\\n\\t\\t//checking if we have encountered a larger string\\n        ans = max(length, ans);\\n\\t\\t\\n        if(idx >= arr.size()) return;\\n\\t\\t\\n        for(int i = idx; i < arr.size(); i++)\\n\\t\\t{\\n            int nmask = mask;\\n\\t\\t\\t//if the string is a valid string we will use that string and calculate further\\n            if(valid(nmask, arr[i]))\\n\\t\\t\\t{\\n                rec(arr, i+1, nmask, length+arr[i].size());\\n\\t\\t\\t}\\n        }\\n    }\\n    int maxLength(vector<string>& arr) {\\n        rec(arr, 0, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int ans = 0;\\n    //valid finds out if the letters in the current string are used before or not \\n    bool valid(int &mask, string s)\\n\\t{\\n        for(auto x: s)\\n\\t\\t{\\n\\t\\t\\t//if we find ther letter is being used we will return false\\n            if(mask&(1<<(x - \\'a\\'))) return false;\\n\\t\\t\\t//since we are using call by refrece for mask we are simultaneously calculating the new mask\\n            mask=mask|(1<<(x-\\'a\\'));\\n        }\\n        return true;\\n    }\\n    \\n    void rec(vector<string>& arr, int idx, int mask, int length)\\n\\t{\\n\\t\\t//checking if we have encountered a larger string\\n        ans = max(length, ans);\\n\\t\\t\\n        if(idx >= arr.size()) return;\\n\\t\\t\\n        for(int i = idx; i < arr.size(); i++)\\n\\t\\t{\\n            int nmask = mask;\\n\\t\\t\\t//if the string is a valid string we will use that string and calculate further\\n            if(valid(nmask, arr[i]))\\n\\t\\t\\t{\\n                rec(arr, i+1, nmask, length+arr[i].size());\\n\\t\\t\\t}\\n        }\\n    }\\n    int maxLength(vector<string>& arr) {\\n        rec(arr, 0, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1375290,
                "title": "javascript-solution-backtracking-approach",
                "content": "```\\nvar maxLength = function(arr) {\\n    const n = arr.length;\\n    let maxLen = 0;\\n    \\n    backtrack(0, \"\");\\n    \\n    return maxLen;\\n    \\n    function backtrack(start, prevStr) {\\n        maxLen = Math.max(maxLen, prevStr.length);\\n        \\n        if (start === n) return; \\n        \\n        for (let i = start; i < n; i++) {\\n            const word = arr[i];\\n            \\n            if (isUnique(prevStr + word)) backtrack(i + 1, prevStr + word);\\n        }\\n    }\\n    \\n    function isUnique(str) {\\n        let bits = 0 | 0;\\n\\n        for (const char of str) {\\n            const index = char.charCodeAt(0) - 97;\\n            \\n            if (bits & (1 << index)) return false;\\n            bits |= (1 << index);\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar maxLength = function(arr) {\\n    const n = arr.length;\\n    let maxLen = 0;\\n    \\n    backtrack(0, \"\");\\n    \\n    return maxLen;\\n    \\n    function backtrack(start, prevStr) {\\n        maxLen = Math.max(maxLen, prevStr.length);\\n        \\n        if (start === n) return; \\n        \\n        for (let i = start; i < n; i++) {\\n            const word = arr[i];\\n            \\n            if (isUnique(prevStr + word)) backtrack(i + 1, prevStr + word);\\n        }\\n    }\\n    \\n    function isUnique(str) {\\n        let bits = 0 | 0;\\n\\n        for (const char of str) {\\n            const index = char.charCodeAt(0) - 97;\\n            \\n            if (bits & (1 << index)) return false;\\n            bits |= (1 << index);\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 692435,
                "title": "worst-to-best-all-solutions-368ms-to-4-ms-c",
                "content": "368 ms sol\\n====================\\n\\tinline int max(int a,int b)\\n\\t{\\n\\t\\treturn (a>b)?a:b;\\n\\t}\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tunsigned int maxVal;\\n\\t\\tbool checkunique(string& str)\\n\\t\\t{\\n\\t\\t\\tvector<int> vec(26, 0);\\n\\t\\t\\tfor (int i = 0; str[i] != \\'\\\\0\\'; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (vec[str[i] - \\'a\\'] == 1)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\tvec[str[i] - \\'a\\'] = 1;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tint maxLength(vector<string>& arr) {\\n\\t\\t\\tmaxVal = 0;\\n\\t\\t\\tint loop_count = pow(2, arr.size());\\n\\t\\t\\tstring str;\\n\\t\\t\\tint idx = 0,j,flag;\\n\\t\\t\\tbool vec[26];\\n\\t\\t\\tfor (int i = 1; i < loop_count; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tidx = 0;\\n\\t\\t\\t\\tstr = \"\";\\n\\t\\t\\t\\tj = i;\\n\\t\\t\\t\\tflag = 0;\\n\\t\\t\\t\\tfor (int k = 0; k < 26; k++)\\n\\t\\t\\t\\t\\tvec[k] = 0;\\n\\t\\t\\t\\twhile (j)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (j & 1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tstr += arr[idx];\\n\\t\\t\\t\\t\\t\\tfor (int k = 0; arr[idx][k]; k++)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif (vec[arr[idx][k] - \\'a\\'])\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tflag = 1;\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tvec[arr[idx][k] - \\'a\\'] = 1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (flag)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tidx++;\\n\\t\\t\\t\\t\\tj >>= 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (flag == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmaxVal = max(maxVal, str.size());\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn maxVal;\\n\\t\\t}\\n\\t};\\n\\n76 ms Sol\\n============\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxVal;\\n\\t\\tbool checkunique(string& str)\\n\\t\\t{\\n\\t\\t\\tvector<int> vec(26, 0);\\n\\t\\t\\tfor (int i = 0; str[i] != \\'\\\\0\\'; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (vec[str[i] - \\'a\\'] == 1)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\tvec[str[i] - \\'a\\'] = 1;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tvoid fun(vector<string>& arr, int idx, string str)\\n\\t\\t{\\n\\t\\t\\tif (maxVal < str.size())\\n\\t\\t\\t\\tmaxVal = str.size();\\n\\t\\t\\tif (idx == arr.size())\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tstring str_included = str + arr[idx];\\n\\t\\t\\tif (checkunique(str_included))\\n\\t\\t\\t{\\n\\t\\t\\t\\tfun(arr, idx+1, str_included);\\n\\t\\t\\t}\\n\\t\\t\\t// not include\\n\\t\\t\\tfun(arr, idx + 1, str);\\n\\t\\t}\\n\\t\\tint maxLength(vector<string>& arr) {\\n\\t\\t\\tmaxVal = 0;\\n\\t\\t\\tint sz = arr.size();\\n\\t\\t\\tvector<string> new_arr;\\n\\t\\t\\tfor (int i = 0; i < sz; i++)\\n\\t\\t\\t\\tif (checkunique(arr[i]))\\n\\t\\t\\t\\t\\tnew_arr.push_back(arr[i]);\\n\\t\\t\\tfun(new_arr, 0, \"\");\\n\\t\\t\\treturn maxVal;\\n\\t\\t}\\n\\t};\\n\\t\\n52 ms Sol\\n=============\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxVal;\\n\\t\\tbool checkunique(string & str)\\n\\t\\t{\\n\\t\\t\\tvector<int> vec(26,0);\\n\\t\\t\\tfor(int i = 0 ; str[i]!= \\'\\\\0\\' ; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(vec[str[i]-\\'a\\'] ==1)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\tvec[str[i]-\\'a\\'] =1;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tvoid fun(vector<string>&arr,int idx,string str)\\n\\t\\t{\\n\\t\\t\\tif(!checkunique(str))\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tif(maxVal < str.size())\\n\\t\\t\\t\\tmaxVal = str.size();\\n\\n\\t\\t\\tfor(int i = idx+1 ; i < arr.size() ; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfun(arr,i,str+arr[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint maxLength(vector<string>& arr) {\\n\\t\\t\\tmaxVal = 0;\\n\\t\\t\\t//string str = arr[0];\\n\\t\\t\\tfor(int i = 0 ; i < arr.size() ; i++)\\n\\t\\t\\t\\tfun(arr,i,arr[i]);\\n\\t\\t\\treturn maxVal;\\n\\t\\t}\\n\\t};\\n28 ms Sol (whole iterative)\\n================\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tunsigned int maxVal;\\n\\t\\tint maxLength(vector<string>& arr) {\\n\\t\\t\\tmaxVal = 0;\\n\\t\\t\\tint sz = arr.size();\\n\\t\\t\\tint loop_count = pow(2, arr.size());\\n\\t\\t\\tstring str;\\n\\t\\t\\tint idx = 0,j,flag;\\n\\n\\t\\t\\tvector<int> encoded_arr(sz, 0);\\n\\t\\t\\tfor (int i = 0; i < sz; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (int j = 0; arr[i][j]; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint bit_val = (1 << (arr[i][j] - \\'a\\'));\\n\\t\\t\\t\\t\\tif ((encoded_arr[i] & bit_val) != 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tencoded_arr[i] = -1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tencoded_arr[i] |= bit_val;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor (int i = 1; i < loop_count; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tidx = 0;\\n\\t\\t\\t\\tint curr_sz = 0;\\n\\t\\t\\t\\tj = i;\\n\\t\\t\\t\\tflag = 0;\\n\\t\\t\\t\\tint encoded_local = 0;\\n\\t\\t\\t\\twhile (j)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (j & 1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tcurr_sz += arr[idx].size();\\n\\t\\t\\t\\t\\t\\tif (encoded_arr[idx] == -1 || encoded_local & encoded_arr[idx])\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tflag = 1;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tencoded_local |= encoded_arr[idx];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tidx++;\\n\\t\\t\\t\\t\\tj >>= 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (flag == 0 && maxVal < curr_sz)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmaxVal = curr_sz;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn maxVal;\\n\\t\\t}\\n\\t};\\n4 ms Sol\\n==========\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxVal;\\n\\t\\tvoid fun(vector<string>& arr, int idx, int curr_sz, vector<int>& encoded_arr, int encoded_val)\\n\\t\\t{\\n\\t\\t\\tif (maxVal < curr_sz)\\n\\t\\t\\t\\tmaxVal = curr_sz;\\n\\t\\t\\tif (idx == arr.size())\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tint new_sz = curr_sz + arr[idx].size();\\n\\t\\t\\tif (encoded_arr[idx] != -1 && (encoded_val & encoded_arr[idx]) == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfun(arr, idx + 1, new_sz, encoded_arr, encoded_val | encoded_arr[idx]);\\n\\t\\t\\t}\\n\\t\\t\\t// not include\\n\\t\\t\\tfun(arr, idx + 1, curr_sz, encoded_arr, encoded_val);\\n\\t\\t}\\n\\t\\tint maxLength(vector<string>& arr) {\\n\\t\\t\\tmaxVal = 0;\\n\\t\\t\\tint sz = arr.size();\\n\\n\\t\\t\\tvector<int> encoded_arr(sz, 0);\\n\\t\\t\\tfor (int i = 0; i < sz; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (int j = 0; arr[i][j]; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint bit_val = (1 << (arr[i][j] - \\'a\\'));\\n\\t\\t\\t\\t\\tif ((encoded_arr[i] & bit_val) != 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tencoded_arr[i] = -1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tencoded_arr[i] |= bit_val;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfun(arr, 0, 0, encoded_arr, 0);\\n\\t\\t\\treturn maxVal;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tunsigned int maxVal;\\n\\t\\tbool checkunique(string& str)\\n\\t\\t{\\n\\t\\t\\tvector<int> vec(26, 0);\\n\\t\\t\\tfor (int i = 0; str[i] != \\'\\\\0\\'; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (vec[str[i] - \\'a\\'] == 1)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\tvec[str[i] - \\'a\\'] = 1;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 560423,
                "title": "java-dfs",
                "content": "```\\n\\nint max = Integer.MIN_VALUE;\\n    \\n    public int maxLength(List<String> arr) {\\n        \\n        dfs(arr,\"\",0);\\n        \\n        return max;\\n    }\\n    \\n    public void dfs(List<String> arr,String res,int index){\\n        \\n        if(unique(res)){\\n            max=Math.max(max,res.length());\\n        }\\n        else{\\n            return;\\n        }\\n        \\n        for(int i=index;i<arr.size();i++){\\n            dfs(arr,res+arr.get(i),i+1);\\n        }\\n    }\\n    \\n    \\n    public boolean unique(String res){\\n        char[] ch = new char[128];\\n        \\n        for(int i=0;i<res.length();i++){\\n            ++ch[res.charAt(i)];\\n            if(ch[res.charAt(i)]>1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\nint max = Integer.MIN_VALUE;\\n    \\n    public int maxLength(List<String> arr) {\\n        \\n        dfs(arr,\"\",0);\\n        \\n        return max;\\n    }\\n    \\n    public void dfs(List<String> arr,String res,int index){\\n        \\n        if(unique(res)){\\n            max=Math.max(max,res.length());\\n        }\\n        else{\\n            return;\\n        }\\n        \\n        for(int i=index;i<arr.size();i++){\\n            dfs(arr,res+arr.get(i),i+1);\\n        }\\n    }\\n    \\n    \\n    public boolean unique(String res){\\n        char[] ch = new char[128];\\n        \\n        for(int i=0;i<res.length();i++){\\n            ++ch[res.charAt(i)];\\n            if(ch[res.charAt(i)]>1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 436428,
                "title": "python-backtracking-solution-beats-100",
                "content": "```\\nclass Solution(object):\\n    def __init__(self):\\n        self.high = 0\\n        \\n    def maxLength(self, arr):\\n        self.backtrack([],0, arr)\\n        return self.high\\n    \\n    def backtrack(self,res, start, arr):\\n        self.high = max(self.high, len(\"\".join(res)))\\n        \\n        for i in range(start, len(arr)):\\n            res.append(arr[i])\\n            temp = \"\".join(res)\\n            if len(set(temp)) == len(temp):\\n                self.backtrack(res, i+1, arr )\\n            res.pop()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def __init__(self):\\n        self.high = 0\\n        \\n    def maxLength(self, arr):\\n        self.backtrack([],0, arr)\\n        return self.high\\n    \\n    def backtrack(self,res, start, arr):\\n        self.high = max(self.high, len(\"\".join(res)))\\n        \\n        for i in range(start, len(arr)):\\n            res.append(arr[i])\\n            temp = \"\".join(res)\\n            if len(set(temp)) == len(temp):\\n                self.backtrack(res, i+1, arr )\\n            res.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737867,
                "title": "java-simple-code-easy-understanding",
                "content": "Technique used here taking or not taking the particular string on the basis of some conditions.\\n```\\nclass Solution {\\n    int ans = 0;\\n    public int maxLength(List<String> arr) {\\n        HashSet<Character> hs = new HashSet<>();    // storing unique characters in it\\n        helper(arr, 0, 0, hs);\\n        return ans;\\n    }\\n    \\n    public int helper(List<String> arr, int idx, int count, HashSet<Character> hs){  // count variable store the length of unique concatenated string\\n        if(idx == arr.size()){\\n            return count;\\n        }\\n        for(int i = idx; i < arr.size(); i++){\\n            boolean flag = true;\\n            HashSet<Character> temp = new HashSet<>();\\n            for(int j = 0; j < arr.get(i).length(); j++){\\n                if(hs.contains(arr.get(i).charAt(j))){                 // if the ith string has any character which occured before in previous string then made flag false and break the loop\\n                    flag = false;\\n                    break;\\n                }\\n                temp.add(arr.get(i).charAt(j));              // here we are adding all characters in different hashset to check that any character in ith string occured 2 or more times or not.\\n                \\n            }\\n            if(flag == true && temp.size() == arr.get(i).length()){   // if ith string does not contains any character which occured before and in ith string also does not have any character which occured 2 or more times.\\n                for(int j = 0; j < arr.get(i).length(); j++){\\n                    hs.add(arr.get(i).charAt(j));\\n                }\\n                ans = Math.max(ans, helper(arr, i + 1, count + arr.get(i).length(), hs));  // if ith string  does not contains any same character then add the length of ith string in count and move to the next string \\n                for(int j = 0; j < arr.get(i).length(); j++){\\n                    hs.remove(arr.get(i).charAt(j));      // in back tracking remove those characters which we have added before\\n                }\\n            }else{\\n                ans = Math.max(ans, helper(arr, i + 1, count, hs));    // if ith string containing any same character then we move on to the next index without including the ith string.\\n            }\\n            \\n        }\\n        return ans;   // return maximum concatenated unique character string\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    public int maxLength(List<String> arr) {\\n        HashSet<Character> hs = new HashSet<>();    // storing unique characters in it\\n        helper(arr, 0, 0, hs);\\n        return ans;\\n    }\\n    \\n    public int helper(List<String> arr, int idx, int count, HashSet<Character> hs){  // count variable store the length of unique concatenated string\\n        if(idx == arr.size()){\\n            return count;\\n        }\\n        for(int i = idx; i < arr.size(); i++){\\n            boolean flag = true;\\n            HashSet<Character> temp = new HashSet<>();\\n            for(int j = 0; j < arr.get(i).length(); j++){\\n                if(hs.contains(arr.get(i).charAt(j))){                 // if the ith string has any character which occured before in previous string then made flag false and break the loop\\n                    flag = false;\\n                    break;\\n                }\\n                temp.add(arr.get(i).charAt(j));              // here we are adding all characters in different hashset to check that any character in ith string occured 2 or more times or not.\\n                \\n            }\\n            if(flag == true && temp.size() == arr.get(i).length()){   // if ith string does not contains any character which occured before and in ith string also does not have any character which occured 2 or more times.\\n                for(int j = 0; j < arr.get(i).length(); j++){\\n                    hs.add(arr.get(i).charAt(j));\\n                }\\n                ans = Math.max(ans, helper(arr, i + 1, count + arr.get(i).length(), hs));  // if ith string  does not contains any same character then add the length of ith string in count and move to the next string \\n                for(int j = 0; j < arr.get(i).length(); j++){\\n                    hs.remove(arr.get(i).charAt(j));      // in back tracking remove those characters which we have added before\\n                }\\n            }else{\\n                ans = Math.max(ans, helper(arr, i + 1, count, hs));    // if ith string containing any same character then we move on to the next index without including the ith string.\\n            }\\n            \\n        }\\n        return ans;   // return maximum concatenated unique character string\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737442,
                "title": "java-solution-super-easy-1-ms-runtime-upvote-if-helpful",
                "content": "# Looking for Contribution in Hacktoberfest\\n## You are welcomed to contribute in my Repos:-\\n# GITHUB LINK --> [Yaduttam95](https://github.com/Yaduttam95)\\n# All PRs are getting accepted...\\n\\n# Please upvote if Helpful\\n```\\nclass Solution {\\n    public int solve(String strs[], int no, int a[], int index, int c) {\\n        if(index==c)\\n            return 0;\\n        int x=no & a[index];\\n        if(x==0)        \\n            return Math.max(strs[index].length()+solve(strs,no^a[index],a,index+1,c),solve(strs,no,a,index+1,c));\\n        else\\n            return solve(strs,no,a,index+1,c);\\n    }\\n    public int maxLength(List<String> arr) {\\n        int a[]=new int[arr.size()];int c=0;String strs[]=new String[a.length];\\n        for(String s:arr) {\\n            int x=0,fl=0;\\n            for(char ch:s.toCharArray()) \\n            {\\n                int z=x|(1<<(ch-96));\\n                if(x==z)\\n                {\\n                    fl=1;break;                \\n                }\\n                x=z;\\n            }\\n            if(fl==0)\\n            {\\n                a[c]=x;\\n                strs[c++]=s;\\n            }\\n        }\\n        return solve(strs,0,a,0,c);\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/7a44dbe0-7232-440d-99cc-d17f06ddf9ec_1666495619.2304356.png)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int solve(String strs[], int no, int a[], int index, int c) {\\n        if(index==c)\\n            return 0;\\n        int x=no & a[index];\\n        if(x==0)        \\n            return Math.max(strs[index].length()+solve(strs,no^a[index],a,index+1,c),solve(strs,no,a,index+1,c));\\n        else\\n            return solve(strs,no,a,index+1,c);\\n    }\\n    public int maxLength(List<String> arr) {\\n        int a[]=new int[arr.size()];int c=0;String strs[]=new String[a.length];\\n        for(String s:arr) {\\n            int x=0,fl=0;\\n            for(char ch:s.toCharArray()) \\n            {\\n                int z=x|(1<<(ch-96));\\n                if(x==z)\\n                {\\n                    fl=1;break;                \\n                }\\n                x=z;\\n            }\\n            if(fl==0)\\n            {\\n                a[c]=x;\\n                strs[c++]=s;\\n            }\\n        }\\n        return solve(strs,0,a,0,c);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2160080,
                "title": "python-easy-to-read-and-understand-recursion",
                "content": "```\\nclass Solution:\\n    def solve(self, words, index, word):\\n        if len(word) != len(set(word)):\\n            return\\n        self.ans = max(self.ans, len(word))\\n        if index == len(words):\\n            return\\n        for i in range(index, len(words)):\\n            self.solve(words, i+1, word+words[i])\\n    \\n    def maxLength(self, arr: List[str]) -> int:\\n        self.ans = 0\\n        self.solve(arr, 0, \\'\\')\\n        return self.ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def solve(self, words, index, word):\\n        if len(word) != len(set(word)):\\n            return\\n        self.ans = max(self.ans, len(word))\\n        if index == len(words):\\n            return\\n        for i in range(index, len(words)):\\n            self.solve(words, i+1, word+words[i])\\n    \\n    def maxLength(self, arr: List[str]) -> int:\\n        self.ans = 0\\n        self.solve(arr, 0, \\'\\')\\n        return self.ans",
                "codeTag": "Java"
            },
            {
                "id": 1686938,
                "title": "c-clean-and-precise-code-83-29-faster-and-98-13-less-memory-usage",
                "content": "```\\nint sol=0;\\n    void solve(vector<string>& arr, vector<int>& count, int i, int &ans)\\n    {\\n        if(i==arr.size())\\n        {\\n            sol=max(sol, ans);\\n            return;\\n        }\\n        //recursive without adding string\\n        solve(arr, count, i+1, ans);\\n        \\n        //adding string\\n        for(int k=0; k<arr[i].length(); k++)\\n        {\\n            if(count[arr[i][k]-\\'a\\']>0)\\n            {\\n                //deleting the previous added elements from count\\n                for(int j=0; j<k; j++)\\n                    count[arr[i][j]-\\'a\\']--;\\n                return;\\n            }\\n            count[arr[i][k]-\\'a\\']++;\\n        }\\n        ans+=arr[i].length();\\n        \\n        //recursive with added string\\n        solve(arr, count, i+1, ans);\\n        \\n        //backtracking\\n        ans-=arr[i].length();\\n        for(int k=0; k<arr[i].length(); k++)\\n        {\\n            count[arr[i][k]-\\'a\\']--;\\n        }\\n    }\\n    int maxLength(vector<string>& arr) {\\n        sol=0;\\n        int ans=0;\\n        //vector to store count of elements\\n        vector<int> count(26, 0);\\n        solve(arr, count, 0, ans);\\n        return sol;\\n    }",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nint sol=0;\\n    void solve(vector<string>& arr, vector<int>& count, int i, int &ans)\\n    {\\n        if(i==arr.size())\\n        {\\n            sol=max(sol, ans);\\n            return;\\n        }\\n        //recursive without adding string\\n        solve(arr, count, i+1, ans);\\n        \\n        //adding string\\n        for(int k=0; k<arr[i].length(); k++)\\n        {\\n            if(count[arr[i][k]-\\'a\\']>0)\\n            {\\n                //deleting the previous added elements from count\\n                for(int j=0; j<k; j++)\\n                    count[arr[i][j]-\\'a\\']--;\\n                return;\\n            }\\n            count[arr[i][k]-\\'a\\']++;\\n        }\\n        ans+=arr[i].length();\\n        \\n        //recursive with added string\\n        solve(arr, count, i+1, ans);\\n        \\n        //backtracking\\n        ans-=arr[i].length();\\n        for(int k=0; k<arr[i].length(); k++)\\n        {\\n            count[arr[i][k]-\\'a\\']--;\\n        }\\n    }\\n    int maxLength(vector<string>& arr) {\\n        sol=0;\\n        int ans=0;\\n        //vector to store count of elements\\n        vector<int> count(26, 0);\\n        solve(arr, count, 0, ans);\\n        return sol;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1021128,
                "title": "python-dfs-explained-w-comments",
                "content": "```\\ndef maxLength(self, arr):\\n\\t# Check if the concatenated-string has unique characters or not\\n\\tdef isValid(s):\\n\\t\\tunique = [False]*26\\n\\t\\tfor i in range(len(s)):\\n\\t\\t\\tif not unique[ord(s[i])-ord(\\'a\\')]: unique[ord(s[i])-ord(\\'a\\')] = True\\n\\t\\t\\telse: return False\\n\\t\\treturn True\\n\\n\\t# Do a DFS on all the individual array elements\\n\\tdef dfs(path, l, r):\\n\\t\\t# If path has non-zero length then that means this is a potential solution\\n\\t\\tif path:\\n\\t\\t\\tself.ans = max(self.ans, len(path))\\n\\n\\t\\tfor i in range(l ,r):\\n\\t\\t\\tif isValid(path+arr[i]):\\n\\t\\t\\t\\tdfs(path+arr[i], i+1, r)\\n\\n\\tself.ans = float(\\'-inf\\')\\n\\tdfs(\"\", 0, len(arr))\\n\\n\\treturn self.ans if self.ans != float(\\'-inf\\') else 0\\n```\\n\\n**A smal note**: If you are new to backtracking questions, this can be a good question for you to practice. This questions is one solid implementation of a very common pattern which you will find in a lot of backtracking questions. I was not good at backtracking because I couldn\\'t think what should be done for such type of questions. Answer is, to find a template -- everyone has a unqiue one in their mind. You will get one imprinted too if you practice.",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\ndef maxLength(self, arr):\\n\\t# Check if the concatenated-string has unique characters or not\\n\\tdef isValid(s):\\n\\t\\tunique = [False]*26\\n\\t\\tfor i in range(len(s)):\\n\\t\\t\\tif not unique[ord(s[i])-ord(\\'a\\')]: unique[ord(s[i])-ord(\\'a\\')] = True\\n\\t\\t\\telse: return False\\n\\t\\treturn True\\n\\n\\t# Do a DFS on all the individual array elements\\n\\tdef dfs(path, l, r):\\n\\t\\t# If path has non-zero length then that means this is a potential solution\\n\\t\\tif path:\\n\\t\\t\\tself.ans = max(self.ans, len(path))\\n\\n\\t\\tfor i in range(l ,r):\\n\\t\\t\\tif isValid(path+arr[i]):\\n\\t\\t\\t\\tdfs(path+arr[i], i+1, r)\\n\\n\\tself.ans = float(\\'-inf\\')\\n\\tdfs(\"\", 0, len(arr))\\n\\n\\treturn self.ans if self.ans != float(\\'-inf\\') else 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 972089,
                "title": "c-dfs-bit-masking-o-2-n-trick-to-find-duplicate-characters-with-xor-and-or",
                "content": "*Observation*\\n**If two binary representations do not contain any common bit then their XOR should be equal to their OR**\\n\\n```\\nExample\\n10101 and 01010 \\nXOR and OR are both equal [11111] , say we have 101 and 100 then its clear that XOR !=OR \\n```\\n\\n**CODE**\\n```\\n    int ans=0;\\n    void dfs(string curr,int index,vector<string> &arr,int bit){\\n        if(index==arr.size()) { \\n            ans=max(ans,(int)curr.length()); return; \\n        }\\n        dfs(curr,index+1,arr,bit); //we dont include the current string\\n        int mask=0;\\n        for(auto x:arr[index]) {\\n            if((mask&(1<<(x-\\'a\\')))!=0) return; //checks duplicates within the string like [\"aa\",\"xyx\"]\\n            mask|=1<<(x-\\'a\\');\\n        }\\n        if((mask^bit)==(mask|bit)){\\n            dfs(curr+arr[index],index+1,arr,mask|bit); //we choose the string \\n        }\\n    }\\n    int maxLength(vector<string>& arr) {\\n        dfs(\"\",0,arr,0);\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search",
                    "Bitmask"
                ],
                "code": "```\\nExample\\n10101 and 01010 \\nXOR and OR are both equal [11111] , say we have 101 and 100 then its clear that XOR !=OR \\n```\n```\\n    int ans=0;\\n    void dfs(string curr,int index,vector<string> &arr,int bit){\\n        if(index==arr.size()) { \\n            ans=max(ans,(int)curr.length()); return; \\n        }\\n        dfs(curr,index+1,arr,bit); //we dont include the current string\\n        int mask=0;\\n        for(auto x:arr[index]) {\\n            if((mask&(1<<(x-\\'a\\')))!=0) return; //checks duplicates within the string like [\"aa\",\"xyx\"]\\n            mask|=1<<(x-\\'a\\');\\n        }\\n        if((mask^bit)==(mask|bit)){\\n            dfs(curr+arr[index],index+1,arr,mask|bit); //we choose the string \\n        }\\n    }\\n    int maxLength(vector<string>& arr) {\\n        dfs(\"\",0,arr,0);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 687348,
                "title": "java-backtracking-simple-easy-understanding",
                "content": "Github link please start the repo :  https://github.com/chiranjeevisaride/leetcode/blob/master/1239.%20Maximum%20Length%20of%20a%20Concatenated%20String%20with%20Unique%20Characters.java\\nTime - O(n*2^n) Space: O(n)\\n\\n```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        int[] result = new int[1];\\n        getMaxLength(0, arr, \"\", result); \\n        return result[0];\\n    }\\n    \\n    public void getMaxLength(int index, List<String> arr, String currentStr, int[] maxLenth) {\\n        if(index == arr.size()) {\\n            if(uniqueCharCount(currentStr) > maxLenth[0])\\n                maxLenth[0] = currentStr.length();\\n            return;\\n        }\\n       \\n        getMaxLength(index + 1, arr, currentStr + arr.get(index), maxLenth);\\n        getMaxLength(index + 1, arr, currentStr, maxLenth);\\n    }\\n    \\n    public int uniqueCharCount(String currentStr) {\\n      int[] count = new int[26];\\n        for(char c : currentStr.toCharArray()) \\n            if(count[ c - \\'a\\']++ > 0) return -1;\\n           return currentStr.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        int[] result = new int[1];\\n        getMaxLength(0, arr, \"\", result); \\n        return result[0];\\n    }\\n    \\n    public void getMaxLength(int index, List<String> arr, String currentStr, int[] maxLenth) {\\n        if(index == arr.size()) {\\n            if(uniqueCharCount(currentStr) > maxLenth[0])\\n                maxLenth[0] = currentStr.length();\\n            return;\\n        }\\n       \\n        getMaxLength(index + 1, arr, currentStr + arr.get(index), maxLenth);\\n        getMaxLength(index + 1, arr, currentStr, maxLenth);\\n    }\\n    \\n    public int uniqueCharCount(String currentStr) {\\n      int[] count = new int[26];\\n        for(char c : currentStr.toCharArray()) \\n            if(count[ c - \\'a\\']++ > 0) return -1;\\n           return currentStr.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685942,
                "title": "python-short-dp-solution",
                "content": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        dp=[\\'\\']\\n        res=0\\n        for s in arr:\\n            for prev in dp:\\n                if len(set(s+prev))==len(s)+len(prev):\\n                    dp.append(s+prev)\\n                    res=max(len(s+prev),res)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        dp=[\\'\\']\\n        res=0\\n        for s in arr:\\n            for prev in dp:\\n                if len(set(s+prev))==len(s)+len(prev):\\n                    dp.append(s+prev)\\n                    res=max(len(s+prev),res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502458,
                "title": "python3-backtracking",
                "content": "\\n```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        \"\"\"\\n        []\\n        un                              iq           ue    \\n        iq              ue(duplicate)\\n        ue(duplicate)\\n        we don\\'t want to going deep after we already find a duplicate\\n        \"\"\"\\n        self.output = 0\\n        self.backtracking([],arr,0)\\n        return self.output\\n    def backtracking(self,subset,arr,start):\\n        concatenate = \\'\\'.join(subset)\\n        #print(start,concatenate)\\n        if len(concatenate) == len(set(concatenate)):\\n            self.output = max(self.output, len(concatenate))\\n        for i in range(start,len(arr)):\\n            if len(concatenate) > len(set(concatenate)):\\n                break\\n            subset.append(arr[i])\\n            self.backtracking(subset,arr,i+1)\\n            subset.pop()\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        \"\"\"\\n        []\\n        un                              iq           ue    \\n        iq              ue(duplicate)\\n        ue(duplicate)\\n        we don\\'t want to going deep after we already find a duplicate\\n        \"\"\"\\n        self.output = 0\\n        self.backtracking([],arr,0)\\n        return self.output\\n    def backtracking(self,subset,arr,start):\\n        concatenate = \\'\\'.join(subset)\\n        #print(start,concatenate)\\n        if len(concatenate) == len(set(concatenate)):\\n            self.output = max(self.output, len(concatenate))\\n        for i in range(start,len(arr)):\\n            if len(concatenate) > len(set(concatenate)):\\n                break\\n            subset.append(arr[i])\\n            self.backtracking(subset,arr,i+1)\\n            subset.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2743241,
                "title": "java-complex-but-understandable-solution",
                "content": "```\\nclass Solution {\\n  public int maxLength(List<String> arr) {\\n        List<Integer> result = new ArrayList<>();\\n    result.add(0);\\n    int res = 0;\\n    for (String s : arr) {\\n      int a = 0, dup = 0;\\n      for (char c : s.toCharArray()) {\\n        dup |= a & (1 << (c - \\'a\\'));\\n        a |= 1 << (c - \\'a\\');\\n      }\\n      if (dup > 0)    continue;\\n      for (int i = result.size() - 1; i >= 0; i--) {\\n        if ((result.get(i) & a) > 0) continue;\\n        result.add(result.get(i) | a);\\n        res = Math.max(res, Integer.bitCount(result.get(i) | a));\\n      }\\n    }\\n    return res;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int maxLength(List<String> arr) {\\n        List<Integer> result = new ArrayList<>();\\n    result.add(0);\\n    int res = 0;\\n    for (String s : arr) {\\n      int a = 0, dup = 0;\\n      for (char c : s.toCharArray()) {\\n        dup |= a & (1 << (c - \\'a\\'));\\n        a |= 1 << (c - \\'a\\');\\n      }\\n      if (dup > 0)    continue;\\n      for (int i = result.size() - 1; i >= 0; i--) {\\n        if ((result.get(i) & a) > 0) continue;\\n        result.add(result.get(i) | a);\\n        res = Math.max(res, Integer.bitCount(result.get(i) | a));\\n      }\\n    }\\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739985,
                "title": "very-very-easy-solution-no-dp-only-map",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // GYAAN LEARNT BY US..\\n\\t\\n    // ZARURI NHI H KI HUM DP ME HI VALUE STORE KARVAAYE.. HUM USKI JAGAH MAP BHI USE KAR SKTE HAI .. \\n    // 2->  TLE REMOVE KARNE KI TRY KARO ..HAR STEP PAR .. JAIESE ISH QUESTIONS ME PEHLE HI CHECK KARVA LIYA KI WHTHER IT WAS VALID OR NOT .. IT HELP IN DECRING THE TIME COMPLEXITY \\n    \\n    // AND WE CANNOT USE DP IN VOID FUCNTIONS \\n    // IF QUESTIONS IF OF DP ..THEN DONT TRY TO DO IT IN VOID FUNCTIONS \\n    \\n    \\n    int maxi=0;\\n    bool check(string &s1, string &s2){\\n        string s= s1+s2;\\n        map<char, int>m;\\n        \\n        for(int i=0;i<s.length();i++){\\n            m[s[i]]++;\\n            if(m[s[i]]>1){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    int solve(int i , string s, vector<string>&arr, unordered_map<string, int>&mp){\\n        \\n        \\n        if(i>=arr.size()){\\n            \\n            int size= s.size();\\n            if(maxi<size){\\n                maxi=size;\\n            }\\n            return maxi;\\n            \\n        }\\n        \\n        \\n        if(mp.find(s) != mp.end()) return mp[s];\\n        \\n        int notTake= solve(i+1,s, arr, mp);\\n        \\n        int take=-1;\\n        if(check(s,arr[i])){\\n            take=solve(i+1, s+arr[i],arr,mp);\\n        }\\n        \\n        return max(take, notTake);\\n    }\\n    \\n    \\n    int maxLength(vector<string>& arr) {\\n        string s=\"\";\\n        \\n       \\n        unordered_map<string, int>mp;\\n        return solve(0, s, arr,mp);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // GYAAN LEARNT BY US..\\n\\t\\n    // ZARURI NHI H KI HUM DP ME HI VALUE STORE KARVAAYE.. HUM USKI JAGAH MAP BHI USE KAR SKTE HAI .. \\n    // 2->  TLE REMOVE KARNE KI TRY KARO ..HAR STEP PAR .. JAIESE ISH QUESTIONS ME PEHLE HI CHECK KARVA LIYA KI WHTHER IT WAS VALID OR NOT .. IT HELP IN DECRING THE TIME COMPLEXITY \\n    \\n    // AND WE CANNOT USE DP IN VOID FUCNTIONS \\n    // IF QUESTIONS IF OF DP ..THEN DONT TRY TO DO IT IN VOID FUNCTIONS \\n    \\n    \\n    int maxi=0;\\n    bool check(string &s1, string &s2){\\n        string s= s1+s2;\\n        map<char, int>m;\\n        \\n        for(int i=0;i<s.length();i++){\\n            m[s[i]]++;\\n            if(m[s[i]]>1){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    int solve(int i , string s, vector<string>&arr, unordered_map<string, int>&mp){\\n        \\n        \\n        if(i>=arr.size()){\\n            \\n            int size= s.size();\\n            if(maxi<size){\\n                maxi=size;\\n            }\\n            return maxi;\\n            \\n        }\\n        \\n        \\n        if(mp.find(s) != mp.end()) return mp[s];\\n        \\n        int notTake= solve(i+1,s, arr, mp);\\n        \\n        int take=-1;\\n        if(check(s,arr[i])){\\n            take=solve(i+1, s+arr[i],arr,mp);\\n        }\\n        \\n        return max(take, notTake);\\n    }\\n    \\n    \\n    int maxLength(vector<string>& arr) {\\n        string s=\"\";\\n        \\n       \\n        unordered_map<string, int>mp;\\n        return solve(0, s, arr,mp);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739599,
                "title": "simple-java-solution-recursion-backtracking",
                "content": "```\\nIF YOU LIKE THE SOLUTION PLEASE UPVOTE IT\\n```\\n```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        return solve(arr,\"\",0);\\n    }\\n    \\n    private int solve(List<String> arr,String ans,int ind){\\n        \\n        if(ind==arr.size()){\\n            return ans.length();\\n        };\\n        \\n        char alphabet[]=new char[26];\\n        \\n        for(int i=0;i<ans.length();i++){\\n            alphabet[ans.charAt(i)-\\'a\\']++;\\n            if(alphabet[ans.charAt(i)-\\'a\\']>1) return 0;\\n        }\\n        \\n        int finalans=ans.length();\\n        \\n        for(int i=ind;i<arr.size();i++){\\n            String str=arr.get(i);\\n            \\n            boolean check=true;\\n            char temp_alphabet[]=new char[26];\\n            for(int j=0;j<str.length();j++){\\n                if(alphabet[str.charAt(j)-\\'a\\']>0 || temp_alphabet[str.charAt(j)-\\'a\\']>0){\\n                    check=false;\\n                    break;\\n                }\\n                temp_alphabet[str.charAt(j)-\\'a\\']++;\\n                \\n            }\\n            \\n            if(check){\\n                ans+=str;\\n                // System.out.println(ans);\\n                finalans=Math.max(finalans,solve(arr,ans,i+1));\\n                ans=ans.substring(0,(ans.length()-str.length()));\\n            }\\n            \\n        }\\n        return finalans;\\n        \\n        \\n        \\n    }\\n}\\n```\\n\\t",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nIF YOU LIKE THE SOLUTION PLEASE UPVOTE IT\\n```\n```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        return solve(arr,\"\",0);\\n    }\\n    \\n    private int solve(List<String> arr,String ans,int ind){\\n        \\n        if(ind==arr.size()){\\n            return ans.length();\\n        };\\n        \\n        char alphabet[]=new char[26];\\n        \\n        for(int i=0;i<ans.length();i++){\\n            alphabet[ans.charAt(i)-\\'a\\']++;\\n            if(alphabet[ans.charAt(i)-\\'a\\']>1) return 0;\\n        }\\n        \\n        int finalans=ans.length();\\n        \\n        for(int i=ind;i<arr.size();i++){\\n            String str=arr.get(i);\\n            \\n            boolean check=true;\\n            char temp_alphabet[]=new char[26];\\n            for(int j=0;j<str.length();j++){\\n                if(alphabet[str.charAt(j)-\\'a\\']>0 || temp_alphabet[str.charAt(j)-\\'a\\']>0){\\n                    check=false;\\n                    break;\\n                }\\n                temp_alphabet[str.charAt(j)-\\'a\\']++;\\n                \\n            }\\n            \\n            if(check){\\n                ans+=str;\\n                // System.out.println(ans);\\n                finalans=Math.max(finalans,solve(arr,ans,i+1));\\n                ans=ans.substring(0,(ans.length()-str.length()));\\n            }\\n            \\n        }\\n        return finalans;\\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739345,
                "title": "easy-c-solution-90-faster-90-space",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(vector<string>&arr, vector<int>&taken, int pos, int &ans){\\n        if(pos==arr.size()){\\n            ans = max(ans, accumulate(taken.begin(),taken.end(),0));\\n            return ;\\n        }\\n        \\n        solve(arr,taken,pos+1,ans);\\n        \\n        int i=0;\\n        for(; i<arr[pos].size(); ++i){\\n            if(taken[arr[pos][i]-\\'a\\']) break;\\n            ++taken[arr[pos][i]-\\'a\\'];\\n        }\\n        \\n        if(i<arr[pos].size()){\\n           for(--i; i>=0; --i) --taken[arr[pos][i]-\\'a\\'];\\n            return;\\n        }\\n        \\n        solve(arr,taken,pos+1,ans);\\n        \\n        for(auto a:arr[pos])\\n            --taken[a-\\'a\\'];\\n    }\\n    int maxLength(vector<string>& arr) {\\n        int ans=0;\\n        vector<int> taken(26,0);\\n        solve(arr,taken,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<string>&arr, vector<int>&taken, int pos, int &ans){\\n        if(pos==arr.size()){\\n            ans = max(ans, accumulate(taken.begin(),taken.end(),0));\\n            return ;\\n        }\\n        \\n        solve(arr,taken,pos+1,ans);\\n        \\n        int i=0;\\n        for(; i<arr[pos].size(); ++i){\\n            if(taken[arr[pos][i]-\\'a\\']) break;\\n            ++taken[arr[pos][i]-\\'a\\'];\\n        }\\n        \\n        if(i<arr[pos].size()){\\n           for(--i; i>=0; --i) --taken[arr[pos][i]-\\'a\\'];\\n            return;\\n        }\\n        \\n        solve(arr,taken,pos+1,ans);\\n        \\n        for(auto a:arr[pos])\\n            --taken[a-\\'a\\'];\\n    }\\n    int maxLength(vector<string>& arr) {\\n        int ans=0;\\n        vector<int> taken(26,0);\\n        solve(arr,taken,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738242,
                "title": "rust-iterative-dfs-with-comments",
                "content": "Build bitsets of all strings that do not contain duplicate characters. Perform a DFS to find the union of non-overlapping bitsets with the highest bit count.\\n\\nImplementation details:\\n* I like early returns when possible, so the body of the `filter_map` becomes a little bulkier than computing the bitset as the full union first and then checking if the number of bits of the bitset is equal to the string length.\\n* I prefer iterative solutions over recursion, and in this case it is pretty straight-forward. We split the search tree into one branch that includes the current set (`sets[i]`) if we can (if we can\\'t, we don\\'t branch, and that prunes the search), and one branch that doesn\\'t.\\n\\n```\\nimpl Solution {\\n    pub fn max_length(arr: Vec<String>) -> i32 {\\n        let sets = arr.into_iter().filter_map(|s| {\\n            let mut bitset = 0;\\n            for bm in s.bytes().map(|b| 1 << (b - b\\'a\\')) {\\n                if bitset & bm != 0 {\\n                    return None;\\n                } else {\\n                    bitset |= bm;\\n                }\\n            }\\n            Some(bitset)\\n        }).collect::<Vec<_>>();\\n\\n        let mut stack = vec![(0_i32, 0)];\\n        let mut rez = 0;\\n\\n        while let Some((bitset, i)) = stack.pop() {\\n            if i == sets.len() {\\n                rez = rez.max(bitset.count_ones());\\n            } else {\\n                if bitset & sets[i] == 0 {\\n                    stack.push((bitset | sets[i], i + 1));\\n                }\\n                stack.push((bitset, i + 1));\\n            }\\n        }\\n        rez as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_length(arr: Vec<String>) -> i32 {\\n        let sets = arr.into_iter().filter_map(|s| {\\n            let mut bitset = 0;\\n            for bm in s.bytes().map(|b| 1 << (b - b\\'a\\')) {\\n                if bitset & bm != 0 {\\n                    return None;\\n                } else {\\n                    bitset |= bm;\\n                }\\n            }\\n            Some(bitset)\\n        }).collect::<Vec<_>>();\\n\\n        let mut stack = vec![(0_i32, 0)];\\n        let mut rez = 0;\\n\\n        while let Some((bitset, i)) = stack.pop() {\\n            if i == sets.len() {\\n                rez = rez.max(bitset.count_ones());\\n            } else {\\n                if bitset & sets[i] == 0 {\\n                    stack.push((bitset | sets[i], i + 1));\\n                }\\n                stack.push((bitset, i + 1));\\n            }\\n        }\\n        rez as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2738013,
                "title": "c-recursion-memo-simple",
                "content": "```\\n//YOUTUBE VIDEO : https://www.youtube.com/watch?v=MqMvkrkerIY\\nclass Solution {\\npublic:\\n    bool hasCommon(string &s1, string& s2) {\\n        int arr[26] = {0};\\n        \\n        for(char &ch : s1) {\\n            if(arr[ch-\\'a\\'] > 0)\\n                return true;\\n            arr[ch-\\'a\\']++;\\n        }\\n        \\n        for(char &ch : s2) {\\n            if(arr[ch-\\'a\\'] > 0)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    unordered_map<string, int> mp;\\n    \\n    int solve(int idx, vector<string>& arr, string temp, int n) {\\n        if(idx >= n)\\n            return temp.length();\\n        \\n        if(mp.find(temp) != mp.end())\\n            return mp[temp];\\n        \\n        int include = 0;\\n        int exclude = 0;\\n        if(hasCommon(arr[idx], temp)) {\\n            exclude = solve(idx+1, arr, temp, n);\\n        } else {\\n            exclude = solve(idx+1, arr, temp, n);\\n            temp += arr[idx];\\n            include = solve(idx+1, arr, temp, n);\\n        }\\n        \\n        return mp[temp] = max(include, exclude);\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        string temp = \"\";\\n        mp.clear();\\n        int n = arr.size();\\n        \\n        return solve(0, arr, temp, n);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n//YOUTUBE VIDEO : https://www.youtube.com/watch?v=MqMvkrkerIY\\nclass Solution {\\npublic:\\n    bool hasCommon(string &s1, string& s2) {\\n        int arr[26] = {0};\\n        \\n        for(char &ch : s1) {\\n            if(arr[ch-\\'a\\'] > 0)\\n                return true;\\n            arr[ch-\\'a\\']++;\\n        }\\n        \\n        for(char &ch : s2) {\\n            if(arr[ch-\\'a\\'] > 0)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    unordered_map<string, int> mp;\\n    \\n    int solve(int idx, vector<string>& arr, string temp, int n) {\\n        if(idx >= n)\\n            return temp.length();\\n        \\n        if(mp.find(temp) != mp.end())\\n            return mp[temp];\\n        \\n        int include = 0;\\n        int exclude = 0;\\n        if(hasCommon(arr[idx], temp)) {\\n            exclude = solve(idx+1, arr, temp, n);\\n        } else {\\n            exclude = solve(idx+1, arr, temp, n);\\n            temp += arr[idx];\\n            include = solve(idx+1, arr, temp, n);\\n        }\\n        \\n        return mp[temp] = max(include, exclude);\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        string temp = \"\";\\n        mp.clear();\\n        int n = arr.size();\\n        \\n        return solve(0, arr, temp, n);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737986,
                "title": "easy-solution-in-c-o-1-sc-bit-manupulation",
                "content": "# Code\\n**Please Upvote if u liked my Solution**\\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    int maxi=0;\\n    bool checkRepeat(string s){\\n        int check=0;\\n        for(auto it:s){\\n            int i=it-\\'a\\';\\n            if((check & 1<<i))\\n                return true;\\n            check^=1<<i;\\n        }\\n        return false;\\n    }\\n    void maxPossibleLength(int ind,int size,string s,vector<string>& arr){\\n        if(checkRepeat(s))\\n            return;\\n        if(ind==size){\\n            int n=s.size();\\n            maxi=max(maxi,n);\\n            return;\\n        }\\n        maxPossibleLength(ind+1,size,s+arr[ind],arr);\\n        maxPossibleLength(ind+1,size,s,arr);\\n    }\\n    int maxLength(vector<string>& arr) {\\n        int size=arr.size();\\n        maxPossibleLength(0,size,\"\",arr);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxi=0;\\n    bool checkRepeat(string s){\\n        int check=0;\\n        for(auto it:s){\\n            int i=it-\\'a\\';\\n            if((check & 1<<i))\\n                return true;\\n            check^=1<<i;\\n        }\\n        return false;\\n    }\\n    void maxPossibleLength(int ind,int size,string s,vector<string>& arr){\\n        if(checkRepeat(s))\\n            return;\\n        if(ind==size){\\n            int n=s.size();\\n            maxi=max(maxi,n);\\n            return;\\n        }\\n        maxPossibleLength(ind+1,size,s+arr[ind],arr);\\n        maxPossibleLength(ind+1,size,s,arr);\\n    }\\n    int maxLength(vector<string>& arr) {\\n        int size=arr.size();\\n        maxPossibleLength(0,size,\"\",arr);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737599,
                "title": "c-easy-solution-using-set-explained-with-comments-backtracking",
                "content": "# C++ Code:\\n\\n```\\nclass Solution {\\npublic:\\n    /* app 1: using hashset & bakctracking\\n    \\n    use backtracking to try all possible combn of string that we can form\\n    input str can also have dup letters\\n    for each str. that we add to our ans,make sure all chars are unique\\n    else, skip that string (not add that str to our ans)\\n    */\\n    bool unique(string &ans){\\n        unordered_set<char> st;\\n        for(char ch: ans){\\n            //dup char exists in ans string\\n            if(st.find(ch) != st.end()){\\n                return false;\\n            }\\n            st.insert(ch);\\n        }\\n        return true;\\n    }\\n    \\n    int f(int idx,vector<string>& arr,string ans){\\n        //check if ans contains unique chars or not\\n        if(unique(ans) == false){\\n            return 0;  //skip adding this \"str\" to ans..return and stop;\\n        }\\n        \\n        int res = ans.length(); //cur. length of our \"ans\" string\\n        for(int i=idx; i<arr.size(); i++){\\n            //fun call on termination implicitly backtrack or removes the added str arr[i]\\n            res = max(res, f(i+1,arr,ans + arr[i]));\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        return f(0,arr,\"\");\\n    }\\n};\\n```\\n\\ncomment and let me know if you understood the solution!!\\u2705\\u2705\\n**Please Upvote if this post been any help to you!**\\uD83D\\uDE80\\uD83D\\uDE80\\nHappy Diwali & happy coding :)\\uD83D\\uDE0A\\uD83D\\uDE0A",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    /* app 1: using hashset & bakctracking\\n    \\n    use backtracking to try all possible combn of string that we can form\\n    input str can also have dup letters\\n    for each str. that we add to our ans,make sure all chars are unique\\n    else, skip that string (not add that str to our ans)\\n    */\\n    bool unique(string &ans){\\n        unordered_set<char> st;\\n        for(char ch: ans){\\n            //dup char exists in ans string\\n            if(st.find(ch) != st.end()){\\n                return false;\\n            }\\n            st.insert(ch);\\n        }\\n        return true;\\n    }\\n    \\n    int f(int idx,vector<string>& arr,string ans){\\n        //check if ans contains unique chars or not\\n        if(unique(ans) == false){\\n            return 0;  //skip adding this \"str\" to ans..return and stop;\\n        }\\n        \\n        int res = ans.length(); //cur. length of our \"ans\" string\\n        for(int i=idx; i<arr.size(); i++){\\n            //fun call on termination implicitly backtrack or removes the added str arr[i]\\n            res = max(res, f(i+1,arr,ans + arr[i]));\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        return f(0,arr,\"\");\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737461,
                "title": "javascript-using-new-set-unoptimised-solution",
                "content": "Idea is to create all possible combination and calculate the max string which is having all unique characters in it without messing up the **order**\\n\\nCode:\\n```\\n/**\\n * @param {string[]} arr\\n * @return {number}\\n */\\nvar maxLength = function(arr) {\\n    const set = new Set([\\'\\']);\\n    let max = 0;\\n    let str;\\n    \\n    for(let i = 0; i < arr.length; i++) {\\n        const values = [...set.values()];\\n        \\n        for(let j = 0; j < values.length; j++) {     \\n            str = `${values[j]}${arr[i]}`;\\n            set.add(str);\\n            let newStr = [...new Set(str).values()].join(\\'\\');\\n            \\n            if (str === newStr) {\\n                max = Math.max(str.length, max);    \\n            }            \\n        }\\n    }\\n    \\n    return max;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} arr\\n * @return {number}\\n */\\nvar maxLength = function(arr) {\\n    const set = new Set([\\'\\']);\\n    let max = 0;\\n    let str;\\n    \\n    for(let i = 0; i < arr.length; i++) {\\n        const values = [...set.values()];\\n        \\n        for(let j = 0; j < values.length; j++) {     \\n            str = `${values[j]}${arr[i]}`;\\n            set.add(str);\\n            let newStr = [...new Set(str).values()].join(\\'\\');\\n            \\n            if (str === newStr) {\\n                max = Math.max(str.length, max);    \\n            }            \\n        }\\n    }\\n    \\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2737436,
                "title": "easy-java-solution-100-faster",
                "content": "# Looking for Contribution in Hacktoberfest\\n## You are welcomed to contribute in my Repos:-\\n# GITHUB LINK --> [Yaduttam95](https://github.com/Yaduttam95)\\n# All PRs are getting accepted...\\n\\n# Please upvote if Helpful\\n```\\nclass Solution {\\n    public int solve(String strs[], int no, int a[], int index, int c) {\\n        if(index==c)\\n            return 0;\\n        int x=no & a[index];\\n        if(x==0)        \\n            return Math.max(strs[index].length()+solve(strs,no^a[index],a,index+1,c),solve(strs,no,a,index+1,c));\\n        else\\n            return solve(strs,no,a,index+1,c);\\n    }\\n    public int maxLength(List<String> arr) {\\n        int a[]=new int[arr.size()];int c=0;String strs[]=new String[a.length];\\n        for(String s:arr) {\\n            int x=0,fl=0;\\n            for(char ch:s.toCharArray()) \\n            {\\n                int z=x|(1<<(ch-96));\\n                if(x==z)\\n                {\\n                    fl=1;break;                \\n                }\\n                x=z;\\n            }\\n            if(fl==0)\\n            {\\n                a[c]=x;\\n                strs[c++]=s;\\n            }\\n        }\\n        return solve(strs,0,a,0,c);\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/7a44dbe0-7232-440d-99cc-d17f06ddf9ec_1666495619.2304356.png)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int solve(String strs[], int no, int a[], int index, int c) {\\n        if(index==c)\\n            return 0;\\n        int x=no & a[index];\\n        if(x==0)        \\n            return Math.max(strs[index].length()+solve(strs,no^a[index],a,index+1,c),solve(strs,no,a,index+1,c));\\n        else\\n            return solve(strs,no,a,index+1,c);\\n    }\\n    public int maxLength(List<String> arr) {\\n        int a[]=new int[arr.size()];int c=0;String strs[]=new String[a.length];\\n        for(String s:arr) {\\n            int x=0,fl=0;\\n            for(char ch:s.toCharArray()) \\n            {\\n                int z=x|(1<<(ch-96));\\n                if(x==z)\\n                {\\n                    fl=1;break;                \\n                }\\n                x=z;\\n            }\\n            if(fl==0)\\n            {\\n                a[c]=x;\\n                strs[c++]=s;\\n            }\\n        }\\n        return solve(strs,0,a,0,c);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440232,
                "title": "c-simple-c-code-98-time-92-space",
                "content": "\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    int n;\\n    int dfs(vector<int> &bitidx, vector<string>& arr, int idx, int bitmaps)\\n    {\\n        if(idx == n)\\n            return 0;\\n        int val = dfs(bitidx, arr, idx+1, bitmaps);\\n        if(bitidx[idx] != -1 && !(bitidx[idx]&bitmaps))\\n        {\\n            int k = arr[idx].size() + dfs(bitidx, arr, idx+1, bitmaps|bitidx[idx]);\\n            val = max(k, val);\\n        }\\n        return val;\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        n = arr.size();\\n        vector<int> bitidx(n,0);\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(char &ch : arr[i])\\n            {\\n                if(bitidx[i] & (1 << (ch-\\'a\\')))\\n                {\\n                    bitidx[i] = -1;\\n                    break;\\n                }\\n                else\\n                {\\n                    bitidx[i] = bitidx[i] | (1 << (ch-\\'a\\'));\\n                }\\n            }\\n        }\\n        return dfs(bitidx, arr, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Bit Manipulation",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int n;\\n    int dfs(vector<int> &bitidx, vector<string>& arr, int idx, int bitmaps)\\n    {\\n        if(idx == n)\\n            return 0;\\n        int val = dfs(bitidx, arr, idx+1, bitmaps);\\n        if(bitidx[idx] != -1 && !(bitidx[idx]&bitmaps))\\n        {\\n            int k = arr[idx].size() + dfs(bitidx, arr, idx+1, bitmaps|bitidx[idx]);\\n            val = max(k, val);\\n        }\\n        return val;\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        n = arr.size();\\n        vector<int> bitidx(n,0);\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(char &ch : arr[i])\\n            {\\n                if(bitidx[i] & (1 << (ch-\\'a\\')))\\n                {\\n                    bitidx[i] = -1;\\n                    break;\\n                }\\n                else\\n                {\\n                    bitidx[i] = bitidx[i] | (1 << (ch-\\'a\\'));\\n                }\\n            }\\n        }\\n        return dfs(bitidx, arr, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2255645,
                "title": "easy-c-backtracking-solution-for-beginners-with-comments",
                "content": "This solution runs on same path as generating all the subsequences of a string with only condition of having all unique characters. \\n\\n```\\nint ans=INT_MIN;    //global answer variable\\n    \\n    bool unique(string s)         //function to find unique characters in a string\\n    {\\n        vector<int>freq(26);     // 26 size for all lowercase alphabets\\n        \\n        for(auto x:s)            // counting frequency of each character in the string.\\n        {\\n            freq[x-\\'a\\']++;       //  if x==\\'b\\'  then x-\\'a\\' will increase the value of freq[1];\\n        }\\n        \\n        for(auto x: freq)\\n        {\\n            if(x>1)                  // if frequency of any alphabet is > 1 then return false.\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n        void backtrack(vector<string>&arr,string s,int j)  \\n        {\\n            if(j==arr.size())\\n            {\\n                if(unique(s))                         //if string contains all unique characters then we\\'ll store the maximum length of the string in ans variable\\n                ans= max(ans,(int)s.size());\\n        \\n                return;\\n            }\\n        \\n        \\n            backtrack(arr,s,j+1);       // not including the current arr[j].\\n            \\n            if(unique(s))                  // only including arr[j] if it contains all unique characters.\\n            {\\n                s+=arr[j];\\n                backtrack(arr,s,j+1);  // call for the next step\\n            }\\n        }\\n    \\n    int maxLength(vector<string>& arr) {\\n        \\n        backtrack(arr,\"\",0);     //function call \\n        \\n        return ans;\\n    }\\n```\\n\\nUpvote if you really find this helpful. Thankyou \\uD83D\\uDE00\\uD83D\\uDE00.",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nint ans=INT_MIN;    //global answer variable\\n    \\n    bool unique(string s)         //function to find unique characters in a string\\n    {\\n        vector<int>freq(26);     // 26 size for all lowercase alphabets\\n        \\n        for(auto x:s)            // counting frequency of each character in the string.\\n        {\\n            freq[x-\\'a\\']++;       //  if x==\\'b\\'  then x-\\'a\\' will increase the value of freq[1];\\n        }\\n        \\n        for(auto x: freq)\\n        {\\n            if(x>1)                  // if frequency of any alphabet is > 1 then return false.\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n        void backtrack(vector<string>&arr,string s,int j)  \\n        {\\n            if(j==arr.size())\\n            {\\n                if(unique(s))                         //if string contains all unique characters then we\\'ll store the maximum length of the string in ans variable\\n                ans= max(ans,(int)s.size());\\n        \\n                return;\\n            }\\n        \\n        \\n            backtrack(arr,s,j+1);       // not including the current arr[j].\\n            \\n            if(unique(s))                  // only including arr[j] if it contains all unique characters.\\n            {\\n                s+=arr[j];\\n                backtrack(arr,s,j+1);  // call for the next step\\n            }\\n        }\\n    \\n    int maxLength(vector<string>& arr) {\\n        \\n        backtrack(arr,\"\",0);     //function call \\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2222821,
                "title": "c-simple-backtracking-solution-explained",
                "content": "* Note that the input string can have duplicate characters too\\n\\t* example: arr = [\"accd\"]\\n* take an empty string\\n* start adding strings from the array\\n* if the resulting string is unique \\n\\t* then update the ans(ans = max length that can be obtained)\\n\\t* append next string\\n* if not backtrack\\n\\n**Code:**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int ans = 0;\\n    bool isUnique(string s)\\n    {\\n        set<char> st(s.begin(), s.end());\\n        return (st.size() == s.length());\\n    }\\n    void solve(int index, string s, vector<string> &arr)\\n    {\\n        if (!isUnique(s))\\n            return;\\n        ans = max(ans, (int)s.length());\\n        for (int i = index; i < arr.size(); i++)\\n        {\\n            solve(i + 1, s + arr[i], arr);\\n        }\\n    }\\n    int maxLength(vector<string> &arr)\\n    {\\n        solve(0, \"\", arr);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int ans = 0;\\n    bool isUnique(string s)\\n    {\\n        set<char> st(s.begin(), s.end());\\n        return (st.size() == s.length());\\n    }\\n    void solve(int index, string s, vector<string> &arr)\\n    {\\n        if (!isUnique(s))\\n            return;\\n        ans = max(ans, (int)s.length());\\n        for (int i = index; i < arr.size(); i++)\\n        {\\n            solve(i + 1, s + arr[i], arr);\\n        }\\n    }\\n    int maxLength(vector<string> &arr)\\n    {\\n        solve(0, \"\", arr);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1482790,
                "title": "c-solution",
                "content": "```\\nclass Solution\\n{\\n    public:\\n    int maxLength(vector<string>& arr) \\n    {\\n        vector<bitset<26>> m; \\n        int res=0;\\n        for(auto& s : arr)\\n        {\\n            bitset<26> bits;\\n            for(char c:s) bits.set(c-\\'a\\');\\n            int n = bits.count();\\n            if(n != s.size()) continue;\\n            for(int i=m.size()-1; i>=0; i--) \\n            {\\n                auto& b = m[i];\\n                if((b & bits).any())\\n                    continue;\\n                res = max<int>(res, b.count() + n);\\n                m.push_back(b | bits);\\n            }\\n            m.push_back(bits);\\n            res=max<int>(res, n);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n    int maxLength(vector<string>& arr) \\n    {\\n        vector<bitset<26>> m; \\n        int res=0;\\n        for(auto& s : arr)\\n        {\\n            bitset<26> bits;\\n            for(char c:s) bits.set(c-\\'a\\');\\n            int n = bits.count();\\n            if(n != s.size()) continue;\\n            for(int i=m.size()-1; i>=0; i--) \\n            {\\n                auto& b = m[i];\\n                if((b & bits).any())\\n                    continue;\\n                res = max<int>(res, b.count() + n);\\n                m.push_back(b | bits);\\n            }\\n            m.push_back(bits);\\n            res=max<int>(res, n);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480103,
                "title": "simple-and-brief-c-solution-using-recursive",
                "content": "```\\nbool checkDupChar(char * s){\\n    int count[26] = {0};\\n    for(int i = 0; i<strlen(s); i++)\\n    {\\n        if(count[s[i] - \\'a\\'] > 0) return false;\\n        count[s[i] - \\'a\\']++;\\n    }\\n    return true;\\n}\\n\\nvoid helper(char ** arr, int arrSize, int idx, char * s, int * out){\\n    if(checkDupChar(s)) *out = *out > strlen(s) ? *out : strlen(s);\\n    if(idx == arrSize) return;\\n    char * temp = malloc(strlen(s)+strlen(arr[idx])+1);\\n    sprintf(temp, \"%s%s\", s, arr[idx]);\\n    helper(arr, arrSize, idx + 1, s, out);\\n    helper(arr, arrSize, idx + 1, temp, out);\\n}\\n\\nint maxLength(char ** arr, int arrSize){\\n    int result = 0;\\n    helper(arr, arrSize, 0, \"\", &result);\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool checkDupChar(char * s){\\n    int count[26] = {0};\\n    for(int i = 0; i<strlen(s); i++)\\n    {\\n        if(count[s[i] - \\'a\\'] > 0) return false;\\n        count[s[i] - \\'a\\']++;\\n    }\\n    return true;\\n}\\n\\nvoid helper(char ** arr, int arrSize, int idx, char * s, int * out){\\n    if(checkDupChar(s)) *out = *out > strlen(s) ? *out : strlen(s);\\n    if(idx == arrSize) return;\\n    char * temp = malloc(strlen(s)+strlen(arr[idx])+1);\\n    sprintf(temp, \"%s%s\", s, arr[idx]);\\n    helper(arr, arrSize, idx + 1, s, out);\\n    helper(arr, arrSize, idx + 1, temp, out);\\n}\\n\\nint maxLength(char ** arr, int arrSize){\\n    int result = 0;\\n    helper(arr, arrSize, 0, \"\", &result);\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1479768,
                "title": "c-bitwise-maps-backtracking-dfs-solution-explained-100-time-95-space",
                "content": "Nice problem about combinations with a specific rule; and we know this kind of problems (at least for the relatively small amount of strings provided to us) can be tackled using a DFS approach; a backtracking on and on top of that, to avoid duplicate effort, we will also use a support array with bitmasks to tell us what characters are used in each string.\\n\\nTo do so, we will declare at class level a few support variables:\\n* `bits` is a pointer to the array we will create containing all the bitmasks equivalent to the provided strings;\\n* `pos`  will be the pointer we will use to write on `bits` and ultimately also the value of its size - initially set to `0`;\\n* `res` will be our usual accumulator variable, storing the longest combination found so far, with initial value of `0`;\\n* `curr` and `currBits` will store the values of our current string length and its composed bitmaks, respectively - both again pre-set to `0`.\\n\\nIn the main function, we will first of all initialise `bits` to be an appropriately sized array and the we will parse each string `s` in `arr` and:\\n* declare `bit` with initial value of `0` and `tmp` to help us in our parsing computations;\\n* for each character `c` in `s`, we will:\\n\\t* compute `tmp` as the `1` raised to the `c - \\'a\\'`th power of `2`, using bitwise shifting;\\n\\t* check if `bit & tmp`, which means we have already encountered a character like `c` in `s`, in which case we will:\\n\\t\\t* reset `bit` to `0`;\\n\\t\\t* `break` out of the inner loop;\\n\\t* alternatively, we will add `tmp` to `bit` with a binary OR;\\n* finally, we will write `bit` into `bits` and move `pos` forward.\\n\\nWe can now move the action to our helper function dfs`, that we will call passing just `arr` (as a reference, of course).\\n\\nThis helper function will also take an extra parameter, `start`, that we will default to `0` and:\\n* check first of all if we already encountered the maximum obtainable value (`26`), in which case no point in continuining and we can stop the call here with a `return`;\\n* alternatively it will update `res` to be the maximum between its current value and `curr`;\\n* another end case to consider now is when `start == pos`, meaning we are done parsing and we can just `return` (a bit reduntant given the following loop, but I just find it cleaner);\\n* we will then loop with `i` from `start` to `pos` (excluded) and:\\n\\t* check if `bits[i]` is not `0` and if we can add the `i`th string to `curr`, not having duplicate characters (ie: `(currBit & bits[i]) == 0`) and, if so:\\n\\t\\t* increase `curr` by `arr[i].size()`\\n\\t\\t* add the bit flags in `bits[i]` to `currBit`;\\n\\t\\t* call the function recursively, passing `arr` again and `i + 1` as a second parameter (ie: we will try to check all the possible permutations with other strings after the `start`th one);\\n\\t\\t* decrease `curr` by `arr[i].size()`\\n\\t\\t* remove the bit flags in `bits[i]` to `currBit`.\\n\\nOnce done, we can just `return` `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\n    // support variables\\n    int *bits, pos = 0, res = 0, curr = 0, currBit = 0;\\n    void dfs(vector<string>& arr, int start = 0) {\\n        // end case: max value achieved\\n        if (res == 26) return;\\n        res = max(res, curr);\\n        // end case: no more combinations to check\\n        if (start == pos) {\\n            return;\\n        }\\n        for (int i = start; i < pos; i++) {\\n            if (bits[i] && (currBit & bits[i]) == 0) {\\n                // updating curr and currBits\\n                curr += arr[i].size();\\n                currBit ^= bits[i];\\n                dfs(arr, i + 1);\\n                // backtracking curr\\n                curr -= arr[i].size();\\n                currBit ^= bits[i];\\n            }\\n            \\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        // preparing bits\\n        bits = new int[arr.size()];\\n        for (auto &s: arr) {\\n            int bit = 0, tmp;\\n            for (char c: s) {\\n                // updating the new bit flag\\n                tmp = 1 << (c - \\'a\\');\\n                // checking if s has duplicate words\\n                if (bit & tmp) {\\n                    bit = 0;\\n                    break;\\n                }\\n                bit |= tmp;\\n            }\\n            // writing bit into bits, if we found no duplicates\\n            bits[pos++] = bit;\\n        }\\n        // comparing strings\\n        dfs(arr);\\n        return res;\\n    }\\n};\\n```\\n\\nAlternative version, removing words with duplicated characters from both `arr` and `bits`:\\n\\n```cpp\\nclass Solution {\\n    // support variables\\n    int *bits, pos = 0, res = 0, curr = 0, currBit = 0;\\n    void dfs(vector<string>& arr, int start = 0) {\\n        // end case: max value achieved\\n        if (res == 26) return;\\n        res = max(res, curr);\\n        // end case: no more combinations to check\\n        if (start == pos) {\\n            return;\\n        }\\n        for (int i = start; i < pos; i++) {\\n            if ((currBit & bits[i]) == 0) {\\n                // updating curr and currBits\\n                curr += arr[i].size();\\n                currBit ^= bits[i];\\n                dfs(arr, i + 1);\\n                // backtracking curr\\n                curr -= arr[i].size();\\n                currBit ^= bits[i];\\n            }\\n            \\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        // preparing bits\\n        bits = new int[arr.size()];\\n        for (auto &s: arr) {\\n            int bit = 0, tmp;\\n            for (char c: s) {\\n                // updating the new bit flag\\n                tmp = 1 << (c - \\'a\\');\\n                // checking if s has duplicate words\\n                if (bit & tmp) {\\n                    bit = 0;\\n                    break;\\n                }\\n                bit |= tmp;\\n            }\\n            // writing bit into bits, if we found no duplicates\\n            bits[pos++] = bit;\\n        }\\n        // moving strings with duplicate characters past pos\\n        pos--;\\n        for (int i = 0; i <= pos; i++) {\\n            if (bits[i]) continue;\\n            swap(arr[i], arr[pos]);\\n            swap(bits[i--], bits[pos--]);\\n        }\\n        pos++;\\n        // comparing strings\\n        dfs(arr);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\n    // support variables\\n    int *bits, pos = 0, res = 0, curr = 0, currBit = 0;\\n    void dfs(vector<string>& arr, int start = 0) {\\n        // end case: max value achieved\\n        if (res == 26) return;\\n        res = max(res, curr);\\n        // end case: no more combinations to check\\n        if (start == pos) {\\n            return;\\n        }\\n        for (int i = start; i < pos; i++) {\\n            if (bits[i] && (currBit & bits[i]) == 0) {\\n                // updating curr and currBits\\n                curr += arr[i].size();\\n                currBit ^= bits[i];\\n                dfs(arr, i + 1);\\n                // backtracking curr\\n                curr -= arr[i].size();\\n                currBit ^= bits[i];\\n            }\\n            \\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        // preparing bits\\n        bits = new int[arr.size()];\\n        for (auto &s: arr) {\\n            int bit = 0, tmp;\\n            for (char c: s) {\\n                // updating the new bit flag\\n                tmp = 1 << (c - \\'a\\');\\n                // checking if s has duplicate words\\n                if (bit & tmp) {\\n                    bit = 0;\\n                    break;\\n                }\\n                bit |= tmp;\\n            }\\n            // writing bit into bits, if we found no duplicates\\n            bits[pos++] = bit;\\n        }\\n        // comparing strings\\n        dfs(arr);\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\n    // support variables\\n    int *bits, pos = 0, res = 0, curr = 0, currBit = 0;\\n    void dfs(vector<string>& arr, int start = 0) {\\n        // end case: max value achieved\\n        if (res == 26) return;\\n        res = max(res, curr);\\n        // end case: no more combinations to check\\n        if (start == pos) {\\n            return;\\n        }\\n        for (int i = start; i < pos; i++) {\\n            if ((currBit & bits[i]) == 0) {\\n                // updating curr and currBits\\n                curr += arr[i].size();\\n                currBit ^= bits[i];\\n                dfs(arr, i + 1);\\n                // backtracking curr\\n                curr -= arr[i].size();\\n                currBit ^= bits[i];\\n            }\\n            \\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        // preparing bits\\n        bits = new int[arr.size()];\\n        for (auto &s: arr) {\\n            int bit = 0, tmp;\\n            for (char c: s) {\\n                // updating the new bit flag\\n                tmp = 1 << (c - \\'a\\');\\n                // checking if s has duplicate words\\n                if (bit & tmp) {\\n                    bit = 0;\\n                    break;\\n                }\\n                bit |= tmp;\\n            }\\n            // writing bit into bits, if we found no duplicates\\n            bits[pos++] = bit;\\n        }\\n        // moving strings with duplicate characters past pos\\n        pos--;\\n        for (int i = 0; i <= pos; i++) {\\n            if (bits[i]) continue;\\n            swap(arr[i], arr[pos]);\\n            swap(bits[i--], bits[pos--]);\\n        }\\n        pos++;\\n        // comparing strings\\n        dfs(arr);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1479299,
                "title": "javascript-95-dp",
                "content": "Posting solutions for all dailies.\\n\\n```\\nconst maxLength = arr => {\\n  let res = 0;\\n\\n  const dp = (idx, cur) => {\\n    res = Math.max(res, cur.length);\\n    for (let i = idx; i < arr.length; i++) {\\n      ((cur+arr[i]).length === new Set([...cur,...arr[i]]).size) && \\n        dp(i + 1, cur + arr[i]);\\n    }\\n  }\\n\\n  dp(0, \\'\\');\\n  return res;\\n};\\n```\\n\\nAlternate method to check for duplicates.  Including because it\\'s a more versatile approach and can be used \\nto determine which chars are duplicates if modified, etc.  Not necessary for this problem though.\\n```\\nconst maxLength = arr => {\\n  let res = 0;\\n\\n  const dp = (idx, cur) => {\\n    res = Math.max(res, cur.length);\\n    \\n    for (let i = idx; i < arr.length; i++) {\\n      \\n      const unique = !!([...cur, ...arr[i]].reduce((set, char) => {\\n        if (!set || set.has(char)) return false;\\n        return set.add(char)\\n      }, new Set())); \\n      \\n      if (unique) dp(i + 1, cur + arr[i]);\\n    }\\n  }\\n\\n  dp(0, \\'\\');\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst maxLength = arr => {\\n  let res = 0;\\n\\n  const dp = (idx, cur) => {\\n    res = Math.max(res, cur.length);\\n    for (let i = idx; i < arr.length; i++) {\\n      ((cur+arr[i]).length === new Set([...cur,...arr[i]]).size) && \\n        dp(i + 1, cur + arr[i]);\\n    }\\n  }\\n\\n  dp(0, \\'\\');\\n  return res;\\n};\\n```\n```\\nconst maxLength = arr => {\\n  let res = 0;\\n\\n  const dp = (idx, cur) => {\\n    res = Math.max(res, cur.length);\\n    \\n    for (let i = idx; i < arr.length; i++) {\\n      \\n      const unique = !!([...cur, ...arr[i]].reduce((set, char) => {\\n        if (!set || set.has(char)) return false;\\n        return set.add(char)\\n      }, new Set())); \\n      \\n      if (unique) dp(i + 1, cur + arr[i]);\\n    }\\n  }\\n\\n  dp(0, \\'\\');\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1478675,
                "title": "java-solution-using-maintaining-list-and-size",
                "content": "```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        \\n        List<String> resultSet = new ArrayList<>();\\n        resultSet.add(\"\");\\n        int len = 0;\\n        \\n        for(String str : arr){\\n            \\n            List<String> tempList = new ArrayList<>();\\n            \\n            for(String res : resultSet){\\n                String tempStr = res + str;\\n                \\n                if(isUnique(tempStr)){\\n                    tempList.add(tempStr);\\n                    len = Math.max(len, tempStr.length());\\n                }\\n            }\\n            \\n            resultSet.addAll(tempList); // adding tempList contents to resultSet\\n        }\\n        return len;\\n    }\\n    \\n    public boolean isUnique(String str){\\n        if(str.length()>26) return false;\\n        \\n        int[] freq = new int[26];\\n        \\n        for(int i=0;i<str.length();i++){\\n            char ch = str.charAt(i);\\n            freq[ch-\\'a\\']++;\\n            \\n            if(freq[ch-\\'a\\']>1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        \\n        List<String> resultSet = new ArrayList<>();\\n        resultSet.add(\"\");\\n        int len = 0;\\n        \\n        for(String str : arr){\\n            \\n            List<String> tempList = new ArrayList<>();\\n            \\n            for(String res : resultSet){\\n                String tempStr = res + str;\\n                \\n                if(isUnique(tempStr)){\\n                    tempList.add(tempStr);\\n                    len = Math.max(len, tempStr.length());\\n                }\\n            }\\n            \\n            resultSet.addAll(tempList); // adding tempList contents to resultSet\\n        }\\n        return len;\\n    }\\n    \\n    public boolean isUnique(String str){\\n        if(str.length()>26) return false;\\n        \\n        int[] freq = new int[26];\\n        \\n        for(int i=0;i<str.length();i++){\\n            char ch = str.charAt(i);\\n            freq[ch-\\'a\\']++;\\n            \\n            if(freq[ch-\\'a\\']>1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1478572,
                "title": "javascript-recursive-solution-simple-and-commented",
                "content": "```\\n/**\\n * @param {string[]} arr\\n * @return {number}\\n */\\nvar maxLength = function(arr) {\\n  return recurse(0, \\'\\', arr);\\n};\\n\\nfunction recurse(index, string, arr) {\\n  // termination condition\\n  \\n  // if we reached the last element of the array\\n  // we check if we have a valid string, return its length if yes,\\n  // otherwise zero\\n  if(index === arr.length) {\\n    return isValid(string) ? string.length : 0;\\n  }\\n  \\n  // We can either pick the current word in the array, or we can leave it\\n  // so there are two recursion path. We return then one that gives us the max\\n  // value\\n  let pick = recurse(index + 1, string + arr[index], arr);\\n  let notPick = recurse(index + 1, string, arr);\\n  \\n  return Math.max(pick, notPick);\\n}\\n\\nfunction isValid(string) {\\n  let hash = {};\\n  for(let char of string) {\\n    if(hash[char]) {\\n      return false;\\n    }\\n    hash[char] = true;\\n  }\\n  return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {string[]} arr\\n * @return {number}\\n */\\nvar maxLength = function(arr) {\\n  return recurse(0, \\'\\', arr);\\n};\\n\\nfunction recurse(index, string, arr) {\\n  // termination condition\\n  \\n  // if we reached the last element of the array\\n  // we check if we have a valid string, return its length if yes,\\n  // otherwise zero\\n  if(index === arr.length) {\\n    return isValid(string) ? string.length : 0;\\n  }\\n  \\n  // We can either pick the current word in the array, or we can leave it\\n  // so there are two recursion path. We return then one that gives us the max\\n  // value\\n  let pick = recurse(index + 1, string + arr[index], arr);\\n  let notPick = recurse(index + 1, string, arr);\\n  \\n  return Math.max(pick, notPick);\\n}\\n\\nfunction isValid(string) {\\n  let hash = {};\\n  for(let char of string) {\\n    if(hash[char]) {\\n      return false;\\n    }\\n    hash[char] = true;\\n  }\\n  return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1364598,
                "title": "c-solution-using-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxUniqueChar(string s){\\n        int count[26] = {0};\\n        for(int i = 0; i < s.size(); i++)\\n            if(count[s[i] - \\'a\\']++ > 0) return -1;\\n        \\n        return s.size();\\n    }\\n    void solve(vector<string>& arr, int index, string curr, vector<int>&ans){\\n        if(index == arr.size() && maxUniqueChar(curr) > ans[0]){\\n            ans[0] = curr.size();\\n            return;\\n        }\\n        if(index == arr.size()) return;\\n        \\n        solve(arr, index+1, curr, ans);\\n        solve(arr, index+1, curr+arr[index], ans);\\n    }\\n    int maxLength(vector<string>& arr) {\\n        vector<int>ans(1);\\n        solve(arr, 0, \"\", ans);\\n        return ans[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxUniqueChar(string s){\\n        int count[26] = {0};\\n        for(int i = 0; i < s.size(); i++)\\n            if(count[s[i] - \\'a\\']++ > 0) return -1;\\n        \\n        return s.size();\\n    }\\n    void solve(vector<string>& arr, int index, string curr, vector<int>&ans){\\n        if(index == arr.size() && maxUniqueChar(curr) > ans[0]){\\n            ans[0] = curr.size();\\n            return;\\n        }\\n        if(index == arr.size()) return;\\n        \\n        solve(arr, index+1, curr, ans);\\n        solve(arr, index+1, curr+arr[index], ans);\\n    }\\n    int maxLength(vector<string>& arr) {\\n        vector<int>ans(1);\\n        solve(arr, 0, \"\", ans);\\n        return ans[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1312449,
                "title": "easy-backtracking-solution-c",
                "content": "```\\nclass Solution {\\n    int max{0};\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        findmax(\"\",arr,0);\\n        return max;\\n    }\\n    \\n    void findmax(string str,vector<string> &arr,int itr){\\n        if(!checkUnique(str)) return;\\n        \\n        if(str.size() > max) max = str.size();\\n       \\n        for(int i = itr;i<arr.size();i++){\\n        findmax(str + arr[i],arr,i+1);\\n       }\\n    }\\n    \\n    bool checkUnique(string word){\\n          set<char> st;\\n        for (auto ele : word) {\\n            if (st.find(ele) != st.end()) return false;\\n            st.insert(ele);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int max{0};\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        findmax(\"\",arr,0);\\n        return max;\\n    }\\n    \\n    void findmax(string str,vector<string> &arr,int itr){\\n        if(!checkUnique(str)) return;\\n        \\n        if(str.size() > max) max = str.size();\\n       \\n        for(int i = itr;i<arr.size();i++){\\n        findmax(str + arr[i],arr,i+1);\\n       }\\n    }\\n    \\n    bool checkUnique(string word){\\n          set<char> st;\\n        for (auto ele : word) {\\n            if (st.find(ele) != st.end()) return false;\\n            st.insert(ele);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1165688,
                "title": "simple-python-dfs-code",
                "content": "An easy optimization to make with this DFS traversal is to return once your path is no longer unique. \\n```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        self.max_length = 0\\n        def traverse(i, path):\\n            if len(path) == len(set(path)):\\n                self.max_length = max(self.max_length, len(path))\\n            else:\\n                return\\n        \\n            for j in range(i, len(arr)):\\n                traverse(j, path + arr[j])\\n                \\n        traverse(0, \"\")\\n        return self.max_length\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        self.max_length = 0\\n        def traverse(i, path):\\n            if len(path) == len(set(path)):\\n                self.max_length = max(self.max_length, len(path))\\n            else:\\n                return\\n        \\n            for j in range(i, len(arr)):\\n                traverse(j, path + arr[j])\\n                \\n        traverse(0, \"\")\\n        return self.max_length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121206,
                "title": "c-recursion",
                "content": "The idea is to compute all of the combinationations. and to find out if they are unique or not.\\n\\n1. In order to understand if a string if unique or not we can use a set ( I used hashset, we can use any other represntation)\\n2. In order to compute all combinationation we use.. recursion... if you think of for loops.. how many of those do you need...? we don\\'t know ... so we use recurssion...\\n3. in the recurs=sion we have the option to take a gives string or not... that\\'s it.\\n\\n\\n```\\npublic class Solution {\\n    public int MaxLength(IList<string> arr) \\n    {\\n       return MaxUnique(arr, 0, \"\");\\n    }\\n    \\n    private int MaxUnique(IList<string> arr, int index, string curr)\\n    {\\n        if(index == arr.Count)\\n        {\\n            return IsUnique(curr);\\n        }\\n        if(IsUnique(curr)==-1)\\n        {\\n            return -1;\\n        }\\n        int res = MaxUnique(arr, index+1, curr);        \\n        int res2 = MaxUnique(arr, index+1, curr+arr[index]);\\n        return Math.Max(res, res2);\\n        \\n    }\\n    \\n     \\n    private int IsUnique(string str)\\n    {\\n        HashSet<char> set = new HashSet<char>();\\n        foreach(var c in str)\\n        {\\n            if(set.Contains(c))\\n            {\\n                return -1;\\n            }\\n            set.Add(c);\\n        }\\n        return str.Length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxLength(IList<string> arr) \\n    {\\n       return MaxUnique(arr, 0, \"\");\\n    }\\n    \\n    private int MaxUnique(IList<string> arr, int index, string curr)\\n    {\\n        if(index == arr.Count)\\n        {\\n            return IsUnique(curr);\\n        }\\n        if(IsUnique(curr)==-1)\\n        {\\n            return -1;\\n        }\\n        int res = MaxUnique(arr, index+1, curr);        \\n        int res2 = MaxUnique(arr, index+1, curr+arr[index]);\\n        return Math.Max(res, res2);\\n        \\n    }\\n    \\n     \\n    private int IsUnique(string str)\\n    {\\n        HashSet<char> set = new HashSet<char>();\\n        foreach(var c in str)\\n        {\\n            if(set.Contains(c))\\n            {\\n                return -1;\\n            }\\n            set.Add(c);\\n        }\\n        return str.Length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 979910,
                "title": "python-clear-way-to-understand-the-time-complexity-o-2-n",
                "content": "**Intuition**\\nAt each recursion stack, you need to check for 2 things:\\n1. If there is a duplicate within the word.\\n2. If the index reached the end of the array.\\n\\ta. Update max length.\\n\\nThen, split into 2 branches:\\n1. Append the current index\\'s word.\\n2. Don\\'t append the current index\\'s word.\\n\\nYou can easily see that at each recursion stack, there are 2 additional recursion calls happening, so the complexity naturally becomes 2^N.\\n\\n```\\n    def maxLength(self, arr: List[str]) -> int:\\n        length = 0\\n        \\n        def recurse(index, word):\\n            if len(set(word)) != len(word):\\n                return\\n            \\n            if index == len(arr):\\n                nonlocal length\\n                length = max(length, len(word))\\n                return\\n            \\n            recurse(index + 1, word + arr[index])\\n            recurse(index + 1, word)\\n        \\n        recurse(0, \\'\\')\\n        return length\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def maxLength(self, arr: List[str]) -> int:\\n        length = 0\\n        \\n        def recurse(index, word):\\n            if len(set(word)) != len(word):\\n                return\\n            \\n            if index == len(arr):\\n                nonlocal length\\n                length = max(length, len(word))\\n                return\\n            \\n            recurse(index + 1, word + arr[index])\\n            recurse(index + 1, word)\\n        \\n        recurse(0, \\'\\')\\n        return length\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 919959,
                "title": "python-dp-40ms-beats-99-33",
                "content": "\\tclass Solution:\\n\\t\\tdef maxLength(self, arr: List[str]) -> int:\\n\\n\\t\\t\\tarr = [s for s in arr if len(set(s)) == len(s)] # remove wrong elements\\n\\t\\t\\tarr = tuple(sorted(arr)) # use tuple to make it hashable\\n\\t\\t\\t\\n\\t\\t\\t@functools.lru_cache(None)\\n\\t\\t\\tdef intesect(s1, s2):\\n\\t\\t\\t\\treturn not not set(s1).intersection(set(s2))\\n\\n\\t\\t\\t@functools.lru_cache(None)\\n\\t\\t\\tdef dp(arr):\\n\\t\\t\\t\\tif len(arr) == 0: return 0\\n\\t\\t\\t\\t# with/without arr[0]\\n\\t\\t\\t\\twt_arr0 = tuple([arr[i] for i in range(1, len(arr)) if not intesect(arr[i],arr[0]) ])\\n\\t\\t\\t\\two_arr0 = tuple(arr[1:])\\n\\t\\t\\t\\treturn max(len(arr[0]) + dp(wt_arr0), dp(wo_arr0))\\n\\n\\t\\t\\treturn dp(arr)\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef maxLength(self, arr: List[str]) -> int:\\n\\n\\t\\t\\tarr = [s for s in arr if len(set(s)) == len(s)] # remove wrong elements\\n\\t\\t\\tarr = tuple(sorted(arr)) # use tuple to make it hashable\\n\\t\\t\\t\\n\\t\\t\\t@functools.lru_cache(None)\\n\\t\\t\\tdef intesect(s1, s2):\\n\\t\\t\\t\\treturn not not set(s1).intersection(set(s2))\\n\\n\\t\\t\\t@functools.lru_cache(None)\\n\\t\\t\\tdef dp(arr):\\n\\t\\t\\t\\tif len(arr) == 0: return 0\\n\\t\\t\\t\\t# with/without arr[0]\\n\\t\\t\\t\\twt_arr0 = tuple([arr[i] for i in range(1, len(arr)) if not intesect(arr[i],arr[0]) ])\\n\\t\\t\\t\\two_arr0 = tuple(arr[1:])\\n\\t\\t\\t\\treturn max(len(arr[0]) + dp(wt_arr0), dp(wo_arr0))\\n\\n\\t\\t\\treturn dp(arr)\\n",
                "codeTag": "Java"
            },
            {
                "id": 879390,
                "title": "c-8ms-faster-than-91-35-using-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    int Bitset[256];\\n    int maxLength(vector<string>& arr) {\\n        \\n        Bitset[0]=0;\\n\\t\\t// This is a way to count the bits via lookup table\\n\\t\\t// refer https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetTable\\n        for(int i = 0;i<256;i++)\\n            Bitset[i]= (i&1)+Bitset[i/2];\\n       vector<int> a(arr.size());\\n\\t   \\n\\t   //IDEA :- The effort is towards finding the maximum size of the string which can be made by unique characters\\n\\t   // by using the strings in the array.\\n\\t   // Lets say each character is represented by a bit in a 32 bit number (you will be using 26 characters( as a-z))\\n\\t   // so a string \"un\" is represented by setting the bits 20th bit and 13th bit in a number\\n\\t   // similarly \"iq\" will be represented by setting 8th bit and 16th bit\\n\\t   // Note : I am staring from 0th bit\\n        for(int i = 0;i<arr.size();i++)\\n        {\\n            int k = 0;\\n            for(int j = 0;j<arr[i].size();j++)\\n            {\\n\\t\\t\\t//Bit of k is set as per Each letter of the string \\n                k|=(1<<(arr[i][j]-\\'a\\'));\\n                a[i]=k;\\n            }\\n\\t\\t\\t//This following step is essential to check whether letters are repeated within a string or not\\n\\t\\t\\t// If unique letters then no of bits set should be equal to the size of the string\\n            if(countbits(a[i])!=arr[i].size())\\n                a[i]=0;\\n        }\\n        int maxm=0;\\n        int temp = 0;\\n\\t\\t// Here it is a simple combination helper function\\n        helper(a,0,temp,maxm);\\n        return maxm;\\n    }\\n    \\n    void helper(vector<int>& arr, int i,int& temp, int& maxm)\\n    {\\n        if(i>arr.size()-1)\\n            return;\\n        int c = temp;\\n        if((temp&arr[i]) == 0) //This condition will be satisfied if both of the strings ANDed don\\'t have same bits set\\n        {\\n            c|=arr[i]; // As unique characters so safe to OR or join \\n            maxm=max(countbits(c),maxm); // check the length\\n            helper(arr,i+1,c,maxm); // this is the call to helper again including the present string\\n        }\\n        //The following is the call to helper without including the current string \\n        helper(arr,i+1,temp,maxm);\\n    }\\n    \\n\\t//Function to count bits using the look up table populated in the beginning of maxLength()\\n    int countbits(int c)\\n    {\\n\\t// Bitset[c&0xff] - calculating no of bits set in 0-7 bits\\n\\t// Bitset[(c>>8)&0xff] - calculating no of bits set in lower 8-15 bits\\n\\t// similarly the rest as i am shifting by 8 bits \\n        return (Bitset[c&0xff] + Bitset[(c>>8)&0xff] + Bitset[(c>>16)&0xff] + Bitset[c>>24]);\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int Bitset[256];\\n    int maxLength(vector<string>& arr) {\\n        \\n        Bitset[0]=0;\\n\\t\\t// This is a way to count the bits via lookup table\\n\\t\\t// refer https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetTable\\n        for(int i = 0;i<256;i++)\\n            Bitset[i]= (i&1)+Bitset[i/2];\\n       vector<int> a(arr.size());\\n\\t   \\n\\t   //IDEA :- The effort is towards finding the maximum size of the string which can be made by unique characters\\n\\t   // by using the strings in the array.\\n\\t   // Lets say each character is represented by a bit in a 32 bit number (you will be using 26 characters( as a-z))\\n\\t   // so a string \"un\" is represented by setting the bits 20th bit and 13th bit in a number\\n\\t   // similarly \"iq\" will be represented by setting 8th bit and 16th bit\\n\\t   // Note : I am staring from 0th bit\\n        for(int i = 0;i<arr.size();i++)\\n        {\\n            int k = 0;\\n            for(int j = 0;j<arr[i].size();j++)\\n            {\\n\\t\\t\\t//Bit of k is set as per Each letter of the string \\n                k|=(1<<(arr[i][j]-\\'a\\'));\\n                a[i]=k;\\n            }\\n\\t\\t\\t//This following step is essential to check whether letters are repeated within a string or not\\n\\t\\t\\t// If unique letters then no of bits set should be equal to the size of the string\\n            if(countbits(a[i])!=arr[i].size())\\n                a[i]=0;\\n        }\\n        int maxm=0;\\n        int temp = 0;\\n\\t\\t// Here it is a simple combination helper function\\n        helper(a,0,temp,maxm);\\n        return maxm;\\n    }\\n    \\n    void helper(vector<int>& arr, int i,int& temp, int& maxm)\\n    {\\n        if(i>arr.size()-1)\\n            return;\\n        int c = temp;\\n        if((temp&arr[i]) == 0) //This condition will be satisfied if both of the strings ANDed don\\'t have same bits set\\n        {\\n            c|=arr[i]; // As unique characters so safe to OR or join \\n            maxm=max(countbits(c),maxm); // check the length\\n            helper(arr,i+1,c,maxm); // this is the call to helper again including the present string\\n        }\\n        //The following is the call to helper without including the current string \\n        helper(arr,i+1,temp,maxm);\\n    }\\n    \\n\\t//Function to count bits using the look up table populated in the beginning of maxLength()\\n    int countbits(int c)\\n    {\\n\\t// Bitset[c&0xff] - calculating no of bits set in 0-7 bits\\n\\t// Bitset[(c>>8)&0xff] - calculating no of bits set in lower 8-15 bits\\n\\t// similarly the rest as i am shifting by 8 bits \\n        return (Bitset[c&0xff] + Bitset[(c>>8)&0xff] + Bitset[(c>>16)&0xff] + Bitset[c>>24]);\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 838743,
                "title": "c-easy-to-understand-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(string a,string b)\\n    {\\n        unordered_set<char> map;\\n        for(int i=0;i<a.length();i++)\\n        {\\n            if(map.find(a[i])!=map.end())\\n                return false;\\n            map.insert(a[i]);\\n        }\\n        for(int i=0;i<b.length();i++)\\n        {\\n            if(map.find(b[i])!=map.end())\\n                return false;\\n        }\\n        return true;\\n    }\\n    int maxLength(vector<string>& arr) {\\n        vector<string> ans;\\n        ans.push_back(\"\");\\n        int res=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            int n=ans.size();\\n            for(int j=0;j<n;j++)\\n            {\\n                if(check(arr[i],ans[j]))\\n                {\\n                    ans.push_back(arr[i]+ans[j]);\\n                    res=max(res,(int)(arr[i].length()+ans[j].length()));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string a,string b)\\n    {\\n        unordered_set<char> map;\\n        for(int i=0;i<a.length();i++)\\n        {\\n            if(map.find(a[i])!=map.end())\\n                return false;\\n            map.insert(a[i]);\\n        }\\n        for(int i=0;i<b.length();i++)\\n        {\\n            if(map.find(b[i])!=map.end())\\n                return false;\\n        }\\n        return true;\\n    }\\n    int maxLength(vector<string>& arr) {\\n        vector<string> ans;\\n        ans.push_back(\"\");\\n        int res=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            int n=ans.size();\\n            for(int j=0;j<n;j++)\\n            {\\n                if(check(arr[i],ans[j]))\\n                {\\n                    ans.push_back(arr[i]+ans[j]);\\n                    res=max(res,(int)(arr[i].length()+ans[j].length()));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 766200,
                "title": "python-144-ms-dfs-very-easy-to-understand",
                "content": "Code is concise and very easy.\\n\\n```\\nclass Solution:\\n    maximum_concat = 0\\n    \\n    def maxLength(self, arr: List[str]) -> int:\\n        def is_unique_concat(concat):\\n            if not concat: return True\\n            return len(concat) == len(set(concat))\\n        \\n        def create_concatenation(cur_concat = \"\", arr_loc_index = 0):  \\n            self.maximum_concat = max(self.maximum_concat, len(cur_concat))\\n            \\n            if arr_loc_index == len(arr):\\n                return\\n            \\n            if is_unique_concat(cur_concat + arr[arr_loc_index]):\\n                create_concatenation(cur_concat + arr[arr_loc_index], arr_loc_index + 1)\\n            create_concatenation(cur_concat, arr_loc_index + 1)\\n            \\n        create_concatenation()\\n        return self.maximum_concat\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    maximum_concat = 0\\n    \\n    def maxLength(self, arr: List[str]) -> int:\\n        def is_unique_concat(concat):\\n            if not concat: return True\\n            return len(concat) == len(set(concat))\\n        \\n        def create_concatenation(cur_concat = \"\", arr_loc_index = 0):  \\n            self.maximum_concat = max(self.maximum_concat, len(cur_concat))\\n            \\n            if arr_loc_index == len(arr):\\n                return\\n            \\n            if is_unique_concat(cur_concat + arr[arr_loc_index]):\\n                create_concatenation(cur_concat + arr[arr_loc_index], arr_loc_index + 1)\\n            create_concatenation(cur_concat, arr_loc_index + 1)\\n            \\n        create_concatenation()\\n        return self.maximum_concat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558589,
                "title": "go-golang-0ms-solutions",
                "content": ">Runtime: 4 ms, faster than 58.82% of Go online submissions for Maximum Length of a Concatenated String with Unique Characters.\\nMemory Usage: 2 MB, less than 100.00% of Go online submissions for Maximum Length of a Concatenated String with Unique Characters.\\n\\n```go\\nfunc maxLength(arr []string) int {\\n    if len(arr) == 1 { return len(arr[0]) }\\n    max := 0\\n    dfs(arr, 0, \"\", &max)\\n    return max\\n}\\n\\nfunc dfs(arr []string, index int, cur string, max *int) {\\n    if index == len(arr) && uniqueCharCount(cur) > *max { *max = len(cur); return }\\n    if index == len(arr) { return }\\n    if uniqueCharCount(cur) == - 1 { return }\\n    dfs(arr, index + 1, cur + arr[index], max)\\n    dfs(arr, index + 1, cur, max)\\n}\\n\\nfunc uniqueCharCount(s string) int {\\n    chars := make([]int, 26)\\n    for _, c := range s {\\n        if chars[c - \\'a\\'] == 1 { return -1 }\\n        chars[c - \\'a\\']++\\n    }\\n    return len(s)\\n}\\n```\\n\\n>Runtime: 0 ms, faster than 100.00% of Go online submissions for Maximum Length of a Concatenated String with Unique Characters.\\nMemory Usage: 2 MB, less than 100.00% of Go online submissions for Maximum Length of a Concatenated String with Unique Characters.\\n\\n```go\\nfunc maxLength(arr []string) int {\\n    c := []uint32{}\\n    max := 0\\n    for _, s := range arr {\\n        var mask uint32\\n        for _, c := range s {\\n            mask = mask | 1 << (c - \\'a\\')\\n        }\\n        if len(s) != bits.OnesCount32(mask) { continue }\\n        c = append(c, mask)\\n    }\\n    dfs(c, 0, 0, &max)\\n    return max\\n}\\n\\nfunc dfs(c []uint32, index int, mask uint32, max *int) {\\n    *max = Max(*max, bits.OnesCount32(mask))\\n    for i := index; i < len(c); i++ {\\n        if mask & c[i] == 0 {\\n            dfs(c, i + 1, mask | c[i], max)\\n        }\\n    }\\n    return\\n}\\n\\nfunc Max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc maxLength(arr []string) int {\\n    if len(arr) == 1 { return len(arr[0]) }\\n    max := 0\\n    dfs(arr, 0, \"\", &max)\\n    return max\\n}\\n\\nfunc dfs(arr []string, index int, cur string, max *int) {\\n    if index == len(arr) && uniqueCharCount(cur) > *max { *max = len(cur); return }\\n    if index == len(arr) { return }\\n    if uniqueCharCount(cur) == - 1 { return }\\n    dfs(arr, index + 1, cur + arr[index], max)\\n    dfs(arr, index + 1, cur, max)\\n}\\n\\nfunc uniqueCharCount(s string) int {\\n    chars := make([]int, 26)\\n    for _, c := range s {\\n        if chars[c - \\'a\\'] == 1 { return -1 }\\n        chars[c - \\'a\\']++\\n    }\\n    return len(s)\\n}\\n```\n```go\\nfunc maxLength(arr []string) int {\\n    c := []uint32{}\\n    max := 0\\n    for _, s := range arr {\\n        var mask uint32\\n        for _, c := range s {\\n            mask = mask | 1 << (c - \\'a\\')\\n        }\\n        if len(s) != bits.OnesCount32(mask) { continue }\\n        c = append(c, mask)\\n    }\\n    dfs(c, 0, 0, &max)\\n    return max\\n}\\n\\nfunc dfs(c []uint32, index int, mask uint32, max *int) {\\n    *max = Max(*max, bits.OnesCount32(mask))\\n    for i := index; i < len(c); i++ {\\n        if mask & c[i] == 0 {\\n            dfs(c, i + 1, mask | c[i], max)\\n        }\\n    }\\n    return\\n}\\n\\nfunc Max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 442238,
                "title": "simple-java-backtracking-solution",
                "content": "\\tint max = 0;\\n    public int maxLength(List<String> arr) {\\n        int[] count = new int[256];\\n        backtracking(arr,count,0,\"\");\\n        return max;\\n    }\\n    \\n    private void backtracking(List<String> arr, int[] count, int index, String str){\\n        if(index == count.length) return;\\n        for(int i = index; i < arr.size(); i++){\\n            char[] array = arr.get(i).toCharArray();\\n            boolean foundDuplicate = false;\\n            for(int k = 0; k < array.length; k++){\\n                char c = array[k];\\n                if(count[(int)c] == 1){\\n                    for(int j = 0; j < k; j++){\\n                        count[(int)(array[j])]--;\\n                    }\\n                    foundDuplicate = true;\\n                    break;\\n                }\\n                count[(int)c]++;\\n            }\\n            if(!foundDuplicate){\\n                max = Math.max(max,str.length()+array.length);\\n                backtracking(arr,count,i+1,str+arr.get(i));\\n                for(char c : array){\\n                    count[(int)c]--;\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "\\tint max = 0;\\n    public int maxLength(List<String> arr) {\\n        int[] count = new int[256];\\n        backtracking(arr,count,0,\"\");\\n        return max;\\n    }\\n    \\n    private void backtracking(List<String> arr, int[] count, int index, String str){\\n        if(index == count.length) return;\\n        for(int i = index; i < arr.size(); i++){\\n            char[] array = arr.get(i).toCharArray();\\n            boolean foundDuplicate = false;\\n            for(int k = 0; k < array.length; k++){\\n                char c = array[k];\\n                if(count[(int)c] == 1){\\n                    for(int j = 0; j < k; j++){\\n                        count[(int)(array[j])]--;\\n                    }\\n                    foundDuplicate = true;\\n                    break;\\n                }\\n                count[(int)c]++;\\n            }\\n            if(!foundDuplicate){\\n                max = Math.max(max,str.length()+array.length);\\n                backtracking(arr,count,i+1,str+arr.get(i));\\n                for(char c : array){\\n                    count[(int)c]--;\\n                }\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 414208,
                "title": "java-solution-explained-with-comment",
                "content": "```\\npublic static int maxLength(List<String> arr) {\\n        int len = 0;\\n        for (int i = 0; i < arr.size(); i++) { // this loop check whether i\\'th string itself has repeating char\\n            HashSet<Character> seen = new HashSet<>();\\n            boolean has = true;\\n            for (char c : arr.get(i).toCharArray()) {\\n                if (seen.contains(c)) {\\n                    has = false;\\n                    break;\\n                }\\n                seen.add(c);\\n            }\\n            if (!has)// if it\\'s has repeating char continue to next i\\n                continue;\\n\\n            len = Math.max(len, seen.size());\\n            for (int j = 0; j < arr.size(); j++) { // this loop check with all other strings in arr\\n                has = true;\\n                if (i == j) continue;\\n                HashSet<Character> data = new HashSet<>();\\n                for (char c : arr.get(j).toCharArray()) {\\n                    if (seen.contains(c) || data.contains(c)) {\\n                        has = false;\\n                        break;\\n                    }\\n                    data.add(c);\\n                }\\n                if (has) { // if everthing is diff then concat it to i\\'th string\\n                    seen.addAll(data);\\n                }\\n                len = Math.max(len, seen.size());// always check if there is update in it \\n            }\\n       \\n```\\n\\nHope you will understand :P",
                "solutionTags": [],
                "code": "```\\npublic static int maxLength(List<String> arr) {\\n        int len = 0;\\n        for (int i = 0; i < arr.size(); i++) { // this loop check whether i\\'th string itself has repeating char\\n            HashSet<Character> seen = new HashSet<>();\\n            boolean has = true;\\n            for (char c : arr.get(i).toCharArray()) {\\n                if (seen.contains(c)) {\\n                    has = false;\\n                    break;\\n                }\\n                seen.add(c);\\n            }\\n            if (!has)// if it\\'s has repeating char continue to next i\\n                continue;\\n\\n            len = Math.max(len, seen.size());\\n            for (int j = 0; j < arr.size(); j++) { // this loop check with all other strings in arr\\n                has = true;\\n                if (i == j) continue;\\n                HashSet<Character> data = new HashSet<>();\\n                for (char c : arr.get(j).toCharArray()) {\\n                    if (seen.contains(c) || data.contains(c)) {\\n                        has = false;\\n                        break;\\n                    }\\n                    data.add(c);\\n                }\\n                if (has) { // if everthing is diff then concat it to i\\'th string\\n                    seen.addAll(data);\\n                }\\n                len = Math.max(len, seen.size());// always check if there is update in it \\n            }\\n       \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4018220,
                "title": "239-maximum-length-of-a-concatenated-string-with-unique-characters-medium",
                "content": "# Maximum Length of a Concatenated String with Unique Characters\\n\\nThis repository contains a C++ solution to find the maximum length of a string that can be formed by concatenating non-duplicate strings from a given vector of strings.\\n\\n## Approach\\n\\nThe approach employed in this solution involves recursive exploration of all possible combinations of strings from the input vector `arr`. The primary steps of the approach are as follows:\\n\\n1. Define a recursive function `solve` that takes three parameters:\\n   - `arr`: The vector of strings.\\n   - `i`: The index of the string in `arr` that we are currently looking at.\\n   - `mask`: A bitmask that represents the characters that have been added to the current string. If the 0-th bit in the mask is set, it means that \"a\" has been added to the current string.\\n\\n2. In the `solve` function, check for base cases:\\n   - If the index `i` exceeds the size of the input vector `arr`, return 0.\\n\\n3. Skip concatenating the current string (`arr[i]`) and recursively call `solve` with the next index `i+1` and the same `mask`. This is done to calculate the maximum length without including the current string.\\n\\n4. Use a bitmask `mask` to keep track of characters that have been added to the current string. Check whether any character in `arr[i]` is present in the current string by using bitwise operations. If any existing character\\'s bit is set, return the result without adding `arr[i]` to the current string.\\n\\n5. Maintain a character mask `curMask` to prevent concatenation if `arr[i]` itself has duplicate characters. After checking for duplicate characters, update the `mask` to include all the bits set in `curMask` to indicate that these characters are part of the current string.\\n\\n6. Make a recursive call to `solve` with the updated `mask` and the length of `arr[i]` added to the current result.\\n\\n7. The `maxLength` function serves as the entry point, initializing the `solve` function with the input vector `arr`, starting at index 0, and with an initial `mask` of 0.\\n\\n## Intuition\\n\\nThe intuition behind this approach is to explore all possible combinations of strings from the input vector `arr` while keeping track of characters that have been added to the current string using a bitmask. By avoiding concatenation when duplicate characters are encountered and considering both scenarios (concatenation and skipping) for each string, the code identifies the maximum length of a unique character string that can be formed.\\n\\n## Complexity Analysis\\n\\n- Time Complexity: The code explores all possible combinations of strings from the vector `arr`, resulting in a worst-case time complexity of O(2^n), where \\'n\\' is the number of strings in the input vector `arr`. Dynamic programming techniques could be applied to improve the time complexity.\\n- Space Complexity: The space complexity is O(n), where \\'n\\' is the number of characters in the input vector `arr`. This space is used for the recursion call stack and the `mask` and `curMask` variables.\\n\\n## Usage\\n\\nTo find the maximum length of a string that can be formed by concatenating non-duplicate strings from a vector of strings, use the `maxLength` function by providing your input vector `arr`.\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<string> &arr, int i, int mask) {\\n        int n = arr.size();\\n        if (i >= n){\\n            return 0;\\n        }\\n\\n        int curRes = solve(arr, i+1, mask);\\n\\t\\tint curMask = 0;\\n        for (char &c: arr[i]) {\\n            if (mask & (1 << (c - \\'a\\'))){\\n                return curRes;\\n            }\\n            \\n            if (curMask & (1 << (c - \\'a\\'))){\\n                return curRes;\\n            }\\n            \\n            curMask |= (1 << (c - \\'a\\'));\\n        }\\n        mask |= curMask;\\n        curRes = max(curRes, (int) arr[i].length() + solve(arr, i+1, mask));\\n        return curRes;\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        return solve(arr, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<string> &arr, int i, int mask) {\\n        int n = arr.size();\\n        if (i >= n){\\n            return 0;\\n        }\\n\\n        int curRes = solve(arr, i+1, mask);\\n\\t\\tint curMask = 0;\\n        for (char &c: arr[i]) {\\n            if (mask & (1 << (c - \\'a\\'))){\\n                return curRes;\\n            }\\n            \\n            if (curMask & (1 << (c - \\'a\\'))){\\n                return curRes;\\n            }\\n            \\n            curMask |= (1 << (c - \\'a\\'));\\n        }\\n        mask |= curMask;\\n        curRes = max(curRes, (int) arr[i].length() + solve(arr, i+1, mask));\\n        return curRes;\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        return solve(arr, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337903,
                "title": "backtracking-approach-2-ways",
                "content": "# Code\\n```java []\\n    public int maxLength(List<String> arr) {\\n        int select[] = new int[26];\\n        return solve(0,0,select,arr);\\n    }\\n    int solve(int p,int len,int select[],List<String> arr){\\n        if(p==arr.size()) return len;\\n        if(isValid(arr.get(p),select)){\\n            String str =arr.get(p);\\n            len+=str.length();\\n            markOne(str,select);\\n            int l1= solve(p+1,len,select,arr);\\n            markZero(str,select);\\n            len-=str.length();\\n            int l2=solve(p+1,len,select,arr);\\n            return Math.max(l1,l2);\\n        }else return solve(p+1,len,select,arr);\\n    }\\n    void markOne(String s,int select[]){\\n        for(char c:s.toCharArray()) select[c-\\'a\\']=1;\\n    }\\n    void markZero(String s,int select[]){\\n        for(char v:s.toCharArray()) select[v-\\'a\\']=0;\\n    }\\n    boolean isValid(String s,int fre[]){\\n        if(s.length()>26) return false;\\n        boolean c[] = new boolean[26];\\n        for(char ch:s.toCharArray()){\\n            if(c[ch-\\'a\\']) return false;\\n            if(fre[ch-\\'a\\']==1) return false;\\n            c[ch-\\'a\\']=true;\\n        }return true;\\n    }\\n```\\n```java [2]\\npublic int maxLength1(List<String> arr) {\\n        HashSet<String> A = new HashSet<String>();\\n        A.add(\"\");\\n        for (String s : arr) {\\n            if (!isUnique(s)) continue;\\n            HashSet<String> t = new HashSet<String>();\\n            for (String c : A) {\\n                String temp = c + s;\\n                if (isUnique(temp)) t.add(temp);\\n            }\\n            A.addAll(t);\\n        }\\n       return A.stream().max(Comparator.comparing(String::length)).get().length();\\n    }\\n boolean isUnique(String st) {\\n        if (st.length() > 26) return false;\\n        boolean A[] = new boolean[26];\\n        for(char c:st.toCharArray()){\\n            if(A[c-\\'a\\']) return false;\\n            A[c-\\'a\\']=true;\\n        }return true;\\n    }\\n```\\n\\n\\n# Complexity\\n- Time complexity: o(n*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![meme2.png](https://assets.leetcode.com/users/images/c6d0d334-f51e-4eaa-bd6b-4e3dcb34d33c_1679716889.1266408.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Backtracking"
                ],
                "code": "```java []\\n    public int maxLength(List<String> arr) {\\n        int select[] = new int[26];\\n        return solve(0,0,select,arr);\\n    }\\n    int solve(int p,int len,int select[],List<String> arr){\\n        if(p==arr.size()) return len;\\n        if(isValid(arr.get(p),select)){\\n            String str =arr.get(p);\\n            len+=str.length();\\n            markOne(str,select);\\n            int l1= solve(p+1,len,select,arr);\\n            markZero(str,select);\\n            len-=str.length();\\n            int l2=solve(p+1,len,select,arr);\\n            return Math.max(l1,l2);\\n        }else return solve(p+1,len,select,arr);\\n    }\\n    void markOne(String s,int select[]){\\n        for(char c:s.toCharArray()) select[c-\\'a\\']=1;\\n    }\\n    void markZero(String s,int select[]){\\n        for(char v:s.toCharArray()) select[v-\\'a\\']=0;\\n    }\\n    boolean isValid(String s,int fre[]){\\n        if(s.length()>26) return false;\\n        boolean c[] = new boolean[26];\\n        for(char ch:s.toCharArray()){\\n            if(c[ch-\\'a\\']) return false;\\n            if(fre[ch-\\'a\\']==1) return false;\\n            c[ch-\\'a\\']=true;\\n        }return true;\\n    }\\n```\n```java [2]\\npublic int maxLength1(List<String> arr) {\\n        HashSet<String> A = new HashSet<String>();\\n        A.add(\"\");\\n        for (String s : arr) {\\n            if (!isUnique(s)) continue;\\n            HashSet<String> t = new HashSet<String>();\\n            for (String c : A) {\\n                String temp = c + s;\\n                if (isUnique(temp)) t.add(temp);\\n            }\\n            A.addAll(t);\\n        }\\n       return A.stream().max(Comparator.comparing(String::length)).get().length();\\n    }\\n boolean isUnique(String st) {\\n        if (st.length() > 26) return false;\\n        boolean A[] = new boolean[26];\\n        for(char c:st.toCharArray()){\\n            if(A[c-\\'a\\']) return false;\\n            A[c-\\'a\\']=true;\\n        }return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2983439,
                "title": "simple-self-explanatory-code",
                "content": "# Complexity\\n- Time complexity: O(2 ^ n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int max = 0;\\n    public int maxLength(List<String> arr) {\\n        rec(arr, 0, \"\");\\n        return max;\\n    }\\n    private void rec (List<String> arr, int idx, String cur) {\\n        if (idx == arr.size()){\\n            if(cur.length() > max && uniqueCharacters(cur)) {\\n                max = cur.length();\\n            }\\n            return;\\n        }\\n        rec(arr, idx + 1, cur);\\n        rec(arr, idx + 1, cur + arr.get(idx));\\n    }\\n    private boolean uniqueCharacters(String cur) {\\n        int[] res = new int[26];\\n        for (char c : cur.toCharArray()) {\\n            if (res[c - \\'a\\'] > 0) {\\n                return false;\\n            }\\n            res[c - \\'a\\']++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int max = 0;\\n    public int maxLength(List<String> arr) {\\n        rec(arr, 0, \"\");\\n        return max;\\n    }\\n    private void rec (List<String> arr, int idx, String cur) {\\n        if (idx == arr.size()){\\n            if(cur.length() > max && uniqueCharacters(cur)) {\\n                max = cur.length();\\n            }\\n            return;\\n        }\\n        rec(arr, idx + 1, cur);\\n        rec(arr, idx + 1, cur + arr.get(idx));\\n    }\\n    private boolean uniqueCharacters(String cur) {\\n        int[] res = new int[26];\\n        for (char c : cur.toCharArray()) {\\n            if (res[c - \\'a\\'] > 0) {\\n                return false;\\n            }\\n            res[c - \\'a\\']++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2982690,
                "title": "easy-to-understand-brutefore-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans = INT_MIN;\\n    bool check(vector<int> &v){\\n        for(auto &i: v)\\n        if(i>1)return false;\\n    return true;\\n    }\\n    void solve(int s,vector<string> &arr,vector<int> &v,int k){\\n        ans = max(ans,k);\\n        if(s>=arr.size())return;\\n        vector<int> tmp = v;\\n        for(auto &i: arr[s]){\\n            tmp[i-\\'a\\']++;\\n        }\\n        if(check(tmp))\\n            solve(s+1,arr,tmp,k+arr[s].length());\\n        solve(s+1,arr,v,k);\\n    }\\n    int maxLength(vector<string>& arr) {\\n        vector<int> v(26,0);\\n        solve(0,arr,v,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = INT_MIN;\\n    bool check(vector<int> &v){\\n        for(auto &i: v)\\n        if(i>1)return false;\\n    return true;\\n    }\\n    void solve(int s,vector<string> &arr,vector<int> &v,int k){\\n        ans = max(ans,k);\\n        if(s>=arr.size())return;\\n        vector<int> tmp = v;\\n        for(auto &i: arr[s]){\\n            tmp[i-\\'a\\']++;\\n        }\\n        if(check(tmp))\\n            solve(s+1,arr,tmp,k+arr[s].length());\\n        solve(s+1,arr,v,k);\\n    }\\n    int maxLength(vector<string>& arr) {\\n        vector<int> v(26,0);\\n        solve(0,arr,v,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2743052,
                "title": "java-easy-to-understand-backtracking-bitmasks",
                "content": "https://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeJava/src/main/java/leetcode/medium/backtracking/MaxLengthConcatenation.java",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2741028,
                "title": "c-basic-recursion-explanation",
                "content": "Basic Recursion like how we write subsequence solution.\\nor can say **\"take\"** or **\"not take\"** approach\\n\\n```\\n\\t int ans = -1;\\n     void find(vector<string>& arr,vector<int> &v,int idx){\\n         \\n        if(idx==arr.size()){\\n            int sum=0;\\n            for(auto &i: v) sum+=i;\\n            ans = max(ans,sum);\\n            return;\\n        }\\n        \\n         int flag=1;\\n         for(auto &i: arr[idx]){\\n             v[i-\\'a\\']++;\\n             if(v[i-\\'a\\']>1){ \\n                flag=0;\\n             }\\n         }\\n         if(flag==1) \\n             find(arr,v,idx+1); //  \"take\" only if all char are unique\\n         \\n         for(auto &i: arr[idx]){\\n             v[i-\\'a\\']--;\\n         }\\n\\t\\t \\n         find(arr,v,idx+1); // always have the choice \"not to take\"     \\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        vector<int> s(26,0);\\n        int idx = 0;\\n        find(arr,s,idx);\\n        return ans;\\n    }\\n```\\n\\n**Do upvote it it helps!!**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n\\t int ans = -1;\\n     void find(vector<string>& arr,vector<int> &v,int idx){\\n         \\n        if(idx==arr.size()){\\n            int sum=0;\\n            for(auto &i: v) sum+=i;\\n            ans = max(ans,sum);\\n            return;\\n        }\\n        \\n         int flag=1;\\n         for(auto &i: arr[idx]){\\n             v[i-\\'a\\']++;\\n             if(v[i-\\'a\\']>1){ \\n                flag=0;\\n             }\\n         }\\n         if(flag==1) \\n             find(arr,v,idx+1); //  \"take\" only if all char are unique\\n         \\n         for(auto &i: arr[idx]){\\n             v[i-\\'a\\']--;\\n         }\\n\\t\\t \\n         find(arr,v,idx+1); // always have the choice \"not to take\"     \\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        vector<int> s(26,0);\\n        int idx = 0;\\n        find(arr,s,idx);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2740898,
                "title": "c-backtracking-bit-masking-explained-5ms",
                "content": "```\\nclass Solution {\\npublic:\\n    // i: arr[i] we are currently looking at\\n\\t// mask: Bitmask that represents all the characters that have been added to the current string\\n\\t// If 0-th bit in mask is set, it means that we have added \"a\" in the current string\\n    int solve(vector<string> &arr, int i, int mask) {\\n        int n = arr.size();\\n        \\n        if (i >= n)\\n            return 0;\\n        \\n        // Skip concatenating arr[i]\\n        int curRes = solve(arr, i+1, mask)\\n\\t\\t\\n\\t\\t// Mask to keep track of the characters that are present in arr[i]\\n\\t\\tint curMask = 0;\\n        \\n        // Check whether any character in arr[i] is present in current string, i.e. \\n\\t\\t// Check whether (arr[i]-\\'a\\')-th bit is set in mask\\n        // If any existing character\\'s bit is set, it means that we cannot concatenate arr[i]\\n        // to the given string and so return curRes only which contains the result of skipping arr[i]\\n        // Also, use curMask to maintain the characters in arr[i] that have been seen.\\n\\t\\t// It is possible that arr[i] itself has duplicate characters in which case, we will not be able to concatenate arr[i]\\n        // So check whether (c-\\'a\\')-th bit is set in curMask and after that set the (c-\\'a\\')-th bit in curMask\\n        for (char &c: arr[i]) {\\n            if (mask & (1 << (c - \\'a\\')))\\n                return curRes;\\n            \\n            if (curMask & (1 << (c - \\'a\\')))\\n                return curRes;\\n            \\n            curMask |= (1 << (c - \\'a\\'));\\n        }\\n        \\n        // All the bits that were set in curMask will be now set in mask, \\n\\t\\t// in order to add all characters of arr[i] to the current string\\n        mask |= curMask;\\n        \\n        // We make a call to i+1 with the updated mask and arr[i]\\'s length being added\\n        curRes = max(curRes, (int) arr[i].length() + solve(arr, i+1, mask));\\n        return curRes;\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        return solve(arr, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // i: arr[i] we are currently looking at\\n\\t// mask: Bitmask that represents all the characters that have been added to the current string\\n\\t// If 0-th bit in mask is set, it means that we have added \"a\" in the current string\\n    int solve(vector<string> &arr, int i, int mask) {\\n        int n = arr.size();\\n        \\n        if (i >= n)\\n            return 0;\\n        \\n        // Skip concatenating arr[i]\\n        int curRes = solve(arr, i+1, mask)\\n\\t\\t\\n\\t\\t// Mask to keep track of the characters that are present in arr[i]\\n\\t\\tint curMask = 0;\\n        \\n        // Check whether any character in arr[i] is present in current string, i.e. \\n\\t\\t// Check whether (arr[i]-\\'a\\')-th bit is set in mask\\n        // If any existing character\\'s bit is set, it means that we cannot concatenate arr[i]\\n        // to the given string and so return curRes only which contains the result of skipping arr[i]\\n        // Also, use curMask to maintain the characters in arr[i] that have been seen.\\n\\t\\t// It is possible that arr[i] itself has duplicate characters in which case, we will not be able to concatenate arr[i]\\n        // So check whether (c-\\'a\\')-th bit is set in curMask and after that set the (c-\\'a\\')-th bit in curMask\\n        for (char &c: arr[i]) {\\n            if (mask & (1 << (c - \\'a\\')))\\n                return curRes;\\n            \\n            if (curMask & (1 << (c - \\'a\\')))\\n                return curRes;\\n            \\n            curMask |= (1 << (c - \\'a\\'));\\n        }\\n        \\n        // All the bits that were set in curMask will be now set in mask, \\n\\t\\t// in order to add all characters of arr[i] to the current string\\n        mask |= curMask;\\n        \\n        // We make a call to i+1 with the updated mask and arr[i]\\'s length being added\\n        curRes = max(curRes, (int) arr[i].length() + solve(arr, i+1, mask));\\n        return curRes;\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        return solve(arr, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2740035,
                "title": "clique-search",
                "content": "This problem can be reduced into a clique search problem in linear time.\\n\\nG = (V, E) where the vertices are the strings, and edges exist between vertices iff the two strings do not have any common letters.  If a string has a repeating lett er, its vertex removed from the graph.  Each vertex is labeled with the length of the string.\\n\\nThis problem, then, becomes a clique search problem.\\n\\n\\n```\\nstruct Graph<const MAX_SIZE: usize> {\\n    adjmat: [[bool; MAX_SIZE]; MAX_SIZE],\\n    degree: [u8; MAX_SIZE],\\n    word_scores: [u32; MAX_SIZE],\\n    n: usize,\\n}\\n\\nimpl<const MAX_SIZE: usize> Graph<MAX_SIZE> {\\n    pub fn new(arr: Vec<String>) -> Self {\\n        let n = arr.len();\\n        let n = n.min(MAX_SIZE);\\n        let arr: Vec<Option<u32>> = arr.iter().map(|s| {\\n            let mut v = 0;\\n            for c in s.chars() {\\n                let d = c as u8;\\n                let d = d - (\\'a\\' as u8);\\n                let d = 1 << d;\\n                if (v & d) != 0 {\\n                    return None;\\n                }\\n                v |= d;\\n            }\\n            Some(v)\\n        }).collect();\\n\\n        let mut nodes = vec![];\\n        for x in arr.iter() {\\n            match x {\\n                None => {},\\n                Some(x) => {nodes.push(*x);}\\n            }\\n        }\\n        std::mem::drop(&arr);\\n        let mut adjmat = [[false; MAX_SIZE]; MAX_SIZE];\\n\\n        let mut degree = [0; MAX_SIZE];\\n        let mut word_scores = [0; MAX_SIZE];\\n\\n        for i in 0..nodes.len() {\\n            let x = nodes[i];\\n            adjmat[i][i] = true;\\n            degree[i] += 1;\\n            word_scores[i] = x.count_ones();\\n            for j in i+1..nodes.len() {\\n                let y = nodes[j];\\n                if 0 == x & y {\\n                    adjmat[i][j] = true;\\n                    adjmat[j][i] = true;\\n                    degree[i] += 1;\\n                    degree[j] += 1;\\n                }\\n            }\\n        }\\n        Self {\\n            adjmat,\\n            degree,\\n            word_scores,\\n            n\\n        }\\n    }\\n\\n    /// Returns true if node n is connected to each node in clique\\n    fn is_clique(&self, clique: &Vec<u8>, n: usize) -> bool {\\n        if (self.degree[n] as usize) < (1 + clique.len()) {\\n            false\\n        } else {\\n            for &nbor in clique.iter() {\\n                let b = self.adjmat[nbor as usize][n as usize];\\n                if b == false  {\\n                    return false;\\n                }\\n            }\\n            true\\n        }\\n    }\\n\\n    pub fn search_cliques(&self) -> u32 {\\n        let mut clique = vec![];\\n        let idx = 0;\\n        let cur_score = 0;\\n        self.search_cliques_rec(&mut clique, idx, cur_score)\\n    }\\n\\n    fn search_cliques_rec(&self,\\n        clique: &mut Vec<u8>,\\n        idx: usize,\\n        cur_score: u32) -> u32 {\\n        let mut best = cur_score;\\n        for i in idx..self.n {\\n            let score = self.word_scores[i];\\n            if self.is_clique(&clique, i) {\\n                clique.push(i as u8);\\n                let res = self.search_cliques_rec(clique, i+1, cur_score+score);\\n                if res > best {\\n                    best = res;\\n                }\\n                clique.pop();\\n            }\\n        }\\n        best\\n    }\\n}\\n\\nstruct Solution;\\nimpl Solution {\\n\\n    // each string of arr contains only lowercase English letters\\n    pub fn max_length(arr: Vec<String>) -> i32 {\\n        let graph = Graph::<16>::new(arr);\\n        let k = graph.search_cliques() as i32;\\n        println!(\"{}\", k);\\n        graph.search_cliques() as i32\\n    }\\n}\\n\\n\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn t1() {\\n        assert!(4 == Solution::max_length(vec![\\n            String::from(\"un\"),\\n            String::from(\"iq\"),\\n            String::from(\"ue\"),\\n        ]));\\n    }\\n\\n    #[test]\\n    fn t2() {\\n        assert!(6 == Solution::max_length(vec![\\n            String::from(\"cha\"),\\n            String::from(\"r\"),\\n            String::from(\"act\"),\\n            String::from(\"ers\"),\\n        ]));\\n    }\\n\\n    #[test]\\n    fn t3() {\\n        assert!(26 == Solution::max_length(vec![\\n            String::from(\"abcdefghijklmnopqrstuvwxyz\"),\\n        ]));\\n    }\\n\\n    #[test]\\n    fn t4() {\\n        assert!(0 == Solution::max_length(vec![\\n        ]));\\n    }\\n\\n\\n    #[test]\\n    fn t6() {\\n        assert!(0 == Solution::max_length(vec![String::from(\"aabcdefg\")]));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Graph"
                ],
                "code": "```\\nstruct Graph<const MAX_SIZE: usize> {\\n    adjmat: [[bool; MAX_SIZE]; MAX_SIZE],\\n    degree: [u8; MAX_SIZE],\\n    word_scores: [u32; MAX_SIZE],\\n    n: usize,\\n}\\n\\nimpl<const MAX_SIZE: usize> Graph<MAX_SIZE> {\\n    pub fn new(arr: Vec<String>) -> Self {\\n        let n = arr.len();\\n        let n = n.min(MAX_SIZE);\\n        let arr: Vec<Option<u32>> = arr.iter().map(|s| {\\n            let mut v = 0;\\n            for c in s.chars() {\\n                let d = c as u8;\\n                let d = d - (\\'a\\' as u8);\\n                let d = 1 << d;\\n                if (v & d) != 0 {\\n                    return None;\\n                }\\n                v |= d;\\n            }\\n            Some(v)\\n        }).collect();\\n\\n        let mut nodes = vec![];\\n        for x in arr.iter() {\\n            match x {\\n                None => {},\\n                Some(x) => {nodes.push(*x);}\\n            }\\n        }\\n        std::mem::drop(&arr);\\n        let mut adjmat = [[false; MAX_SIZE]; MAX_SIZE];\\n\\n        let mut degree = [0; MAX_SIZE];\\n        let mut word_scores = [0; MAX_SIZE];\\n\\n        for i in 0..nodes.len() {\\n            let x = nodes[i];\\n            adjmat[i][i] = true;\\n            degree[i] += 1;\\n            word_scores[i] = x.count_ones();\\n            for j in i+1..nodes.len() {\\n                let y = nodes[j];\\n                if 0 == x & y {\\n                    adjmat[i][j] = true;\\n                    adjmat[j][i] = true;\\n                    degree[i] += 1;\\n                    degree[j] += 1;\\n                }\\n            }\\n        }\\n        Self {\\n            adjmat,\\n            degree,\\n            word_scores,\\n            n\\n        }\\n    }\\n\\n    /// Returns true if node n is connected to each node in clique\\n    fn is_clique(&self, clique: &Vec<u8>, n: usize) -> bool {\\n        if (self.degree[n] as usize) < (1 + clique.len()) {\\n            false\\n        } else {\\n            for &nbor in clique.iter() {\\n                let b = self.adjmat[nbor as usize][n as usize];\\n                if b == false  {\\n                    return false;\\n                }\\n            }\\n            true\\n        }\\n    }\\n\\n    pub fn search_cliques(&self) -> u32 {\\n        let mut clique = vec![];\\n        let idx = 0;\\n        let cur_score = 0;\\n        self.search_cliques_rec(&mut clique, idx, cur_score)\\n    }\\n\\n    fn search_cliques_rec(&self,\\n        clique: &mut Vec<u8>,\\n        idx: usize,\\n        cur_score: u32) -> u32 {\\n        let mut best = cur_score;\\n        for i in idx..self.n {\\n            let score = self.word_scores[i];\\n            if self.is_clique(&clique, i) {\\n                clique.push(i as u8);\\n                let res = self.search_cliques_rec(clique, i+1, cur_score+score);\\n                if res > best {\\n                    best = res;\\n                }\\n                clique.pop();\\n            }\\n        }\\n        best\\n    }\\n}\\n\\nstruct Solution;\\nimpl Solution {\\n\\n    // each string of arr contains only lowercase English letters\\n    pub fn max_length(arr: Vec<String>) -> i32 {\\n        let graph = Graph::<16>::new(arr);\\n        let k = graph.search_cliques() as i32;\\n        println!(\"{}\", k);\\n        graph.search_cliques() as i32\\n    }\\n}\\n\\n\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn t1() {\\n        assert!(4 == Solution::max_length(vec![\\n            String::from(\"un\"),\\n            String::from(\"iq\"),\\n            String::from(\"ue\"),\\n        ]));\\n    }\\n\\n    #[test]\\n    fn t2() {\\n        assert!(6 == Solution::max_length(vec![\\n            String::from(\"cha\"),\\n            String::from(\"r\"),\\n            String::from(\"act\"),\\n            String::from(\"ers\"),\\n        ]));\\n    }\\n\\n    #[test]\\n    fn t3() {\\n        assert!(26 == Solution::max_length(vec![\\n            String::from(\"abcdefghijklmnopqrstuvwxyz\"),\\n        ]));\\n    }\\n\\n    #[test]\\n    fn t4() {\\n        assert!(0 == Solution::max_length(vec![\\n        ]));\\n    }\\n\\n\\n    #[test]\\n    fn t6() {\\n        assert!(0 == Solution::max_length(vec![String::from(\"aabcdefg\")]));\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2739821,
                "title": "memoization-using-map-as-dp-runtime-136ms-memoization-recursion-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkUnique(string &s){\\n        int hash[26]={0};\\n        for(int i=0; i<s.size(); i++){\\n            hash[s[i]-97]++;\\n        }\\n        for(int i=0; i<26; i++){\\n            if(hash[i]>1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    int cal(int ind, string s, vector<string> &v, map<string,int> &dp){\\n        if(!checkUnique(s)){\\n            return 0;\\n        }\\n        if(ind<0){\\n            return s.size();\\n        }\\n        \\n        if(dp.find(s)!=dp.end()){\\n            return dp[s];\\n        }\\n        \\n        return dp[s]=max(cal(ind-1,s+v[ind],v,dp),cal(ind-1,s,v,dp));\\n    }\\n\\n    int maxLength(vector<string>& v) {\\n        int n=v.size();\\n        map<string,int> dp;\\n        return cal(n-1,\"\",v,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkUnique(string &s){\\n        int hash[26]={0};\\n        for(int i=0; i<s.size(); i++){\\n            hash[s[i]-97]++;\\n        }\\n        for(int i=0; i<26; i++){\\n            if(hash[i]>1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    int cal(int ind, string s, vector<string> &v, map<string,int> &dp){\\n        if(!checkUnique(s)){\\n            return 0;\\n        }\\n        if(ind<0){\\n            return s.size();\\n        }\\n        \\n        if(dp.find(s)!=dp.end()){\\n            return dp[s];\\n        }\\n        \\n        return dp[s]=max(cal(ind-1,s+v[ind],v,dp),cal(ind-1,s,v,dp));\\n    }\\n\\n    int maxLength(vector<string>& v) {\\n        int n=v.size();\\n        map<string,int> dp;\\n        return cal(n-1,\"\",v,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738630,
                "title": "go-solution-backtracking-with-recursion",
                "content": "```\\nfunc duplicates(s string) bool {\\n\\tvar (\\n\\t\\tm = make(map[rune]bool)\\n\\t)\\n\\tfor _, r := range s {\\n\\t\\tif m[r] {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tm[r] = true\\n\\t}\\n\\treturn false\\n}\\n\\nfunc backtracking(arr []string, begging int, result string, skip []int, max int) int {\\n\\tfor i := begging; i < len(arr); i++ {\\n\\t\\tif skip[i] == 1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif !strings.ContainsAny(result, arr[i]) {\\n\\t\\t\\tskip[i] = 1\\n\\t\\t\\tif newMax := len(result) + len(arr[i]); newMax > max {\\n\\t\\t\\t\\tmax = newMax\\n\\t\\t\\t}\\n\\t\\t\\tmax = backtracking(arr, i, result+arr[i], skip, max)\\n\\t\\t\\tskip[i] = 0\\n\\t\\t}\\n\\t}\\n\\treturn max\\n}\\n\\nfunc maxLength(arr []string) int {\\n\\tvar (\\n\\t\\tskip   = make([]int, len(arr))\\n\\t\\tresult string\\n\\t\\tmax    int\\n\\t)\\n\\t// Set duplicates strings to skip\\n\\tfor i := 0; i < len(arr); i++ {\\n\\t\\tif duplicates(arr[i]) {\\n\\t\\t\\tskip[i] = 1\\n\\t\\t}\\n\\t}\\n\\treturn backtracking(arr, 0, result, skip, max)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc duplicates(s string) bool {\\n\\tvar (\\n\\t\\tm = make(map[rune]bool)\\n\\t)\\n\\tfor _, r := range s {\\n\\t\\tif m[r] {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tm[r] = true\\n\\t}\\n\\treturn false\\n}\\n\\nfunc backtracking(arr []string, begging int, result string, skip []int, max int) int {\\n\\tfor i := begging; i < len(arr); i++ {\\n\\t\\tif skip[i] == 1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif !strings.ContainsAny(result, arr[i]) {\\n\\t\\t\\tskip[i] = 1\\n\\t\\t\\tif newMax := len(result) + len(arr[i]); newMax > max {\\n\\t\\t\\t\\tmax = newMax\\n\\t\\t\\t}\\n\\t\\t\\tmax = backtracking(arr, i, result+arr[i], skip, max)\\n\\t\\t\\tskip[i] = 0\\n\\t\\t}\\n\\t}\\n\\treturn max\\n}\\n\\nfunc maxLength(arr []string) int {\\n\\tvar (\\n\\t\\tskip   = make([]int, len(arr))\\n\\t\\tresult string\\n\\t\\tmax    int\\n\\t)\\n\\t// Set duplicates strings to skip\\n\\tfor i := 0; i < len(arr); i++ {\\n\\t\\tif duplicates(arr[i]) {\\n\\t\\t\\tskip[i] = 1\\n\\t\\t}\\n\\t}\\n\\treturn backtracking(arr, 0, result, skip, max)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2738254,
                "title": "java-recursion-solution-7ms-faster-than-93-48",
                "content": "```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        return helper(arr, 0, 0);\\n    }\\n    \\n    public int helper(List<String> arr, int i, int bit){\\n        if(i >= arr.size())\\n            return 0;\\n        \\n        int dupl = 0;\\n        for(char c : arr.get(i).toCharArray()){\\n            int j = c - \\'a\\';\\n            // check for duplicate within string\\n            if((dupl & (1<<j)) > 0) {\\n                return helper(arr, i+1, bit);\\n            }\\n            dupl = dupl | (1<<j);\\n        }\\n        \\n        // check if duplicate with new string and old string\\n        if((bit & dupl) > 0) return helper(arr, i+1, bit);\\n                \\n        return Math.max(helper(arr, i+1, bit), arr.get(i).length() + helper(arr, i+1, bit | dupl));\\n    }\\n}\\n```\\n\\nYou can also add memoization.",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        return helper(arr, 0, 0);\\n    }\\n    \\n    public int helper(List<String> arr, int i, int bit){\\n        if(i >= arr.size())\\n            return 0;\\n        \\n        int dupl = 0;\\n        for(char c : arr.get(i).toCharArray()){\\n            int j = c - \\'a\\';\\n            // check for duplicate within string\\n            if((dupl & (1<<j)) > 0) {\\n                return helper(arr, i+1, bit);\\n            }\\n            dupl = dupl | (1<<j);\\n        }\\n        \\n        // check if duplicate with new string and old string\\n        if((bit & dupl) > 0) return helper(arr, i+1, bit);\\n                \\n        return Math.max(helper(arr, i+1, bit), arr.get(i).length() + helper(arr, i+1, bit | dupl));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738164,
                "title": "easy-c-recursion-backtracking-with-comments",
                "content": "```\\nclass Solution {\\nprivate:\\n    \\nbool isValid(vector<int> &taken, string &curr){//to check repeated characters using repeatedCheck vector\\n    \\n    vector<int> repeatedCheck(26, 0); \\n    \\n    for(int i=0; i<curr.size(); i++){\\n        // curr[i] - \\'a\\' maps every character to a corresponding index        \\n        if (repeatedCheck[curr[i]-\\'a\\']==1){ \\n            return false ; //has repeated characters\\n        }\\n        repeatedCheck[curr[i]-\\'a\\']=1; //else mark all chars as 1\\n    }\\n\\n    //to check chars have been taken/selected or not    \\n    for(int i=0; i<curr.size(); i++){\\n        //if already selected, we cannot take the current str\\n        if (taken[curr[i]-\\'a\\']==1)\\n            return false;\\n    }\\n    \\n    //if no repeated chars and not selected\\n    return true;\\n}\\n\\n\\nint recursive(int ind, vector<string> &arr, vector<int> &taken, int len){    \\n    if(ind==arr.size()){//base condition\\n        return len;\\n    }\\n\\n    string curr=arr[ind];\\n    if(isValid(taken, curr)==false){    // if not valid -> skip curr str and move to next index\\n        return recursive(ind+1, arr, taken, len) ;\\n    }\\n    else{//2 options -> pick or not pick(skip)\\n        \\n        for(int j=0; j<curr.size(); j++){\\n            taken[curr[j]-\\'a\\']=1; // pick - mark char in selected as taken\\n        }\\n        \\n        len+=curr.size();\\n        int pick=recursive(ind+1, arr, taken, len); //pick \\n\\n        for(int j=0; j<curr.size(); j++){\\n            taken[curr[j]-\\'a\\']=0; //backtrack and mark all chars as not taken\\n        }\\n        \\n        len-=curr.size() ; //not pick        \\n        int notpick=recursive(ind+1, arr, taken, len);\\n\\n        return max(pick, notpick); //longest length\\n    }\\n}\\n\\npublic:\\n    int maxLength(vector<string>& arr) {\\n    vector<int> taken(26, 0); //keep track of chars taken/not taken\\n    return recursive(0, arr, taken, 0);    \\n    }\\n};\\n\\n//TC : O(n*2^N) exponential\\n//where max value of n can be 26\\n//SC : O(N)\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    \\nbool isValid(vector<int> &taken, string &curr){//to check repeated characters using repeatedCheck vector\\n    \\n    vector<int> repeatedCheck(26, 0); \\n    \\n    for(int i=0; i<curr.size(); i++){\\n        // curr[i] - \\'a\\' maps every character to a corresponding index        \\n        if (repeatedCheck[curr[i]-\\'a\\']==1){ \\n            return false ; //has repeated characters\\n        }\\n        repeatedCheck[curr[i]-\\'a\\']=1; //else mark all chars as 1\\n    }\\n\\n    //to check chars have been taken/selected or not    \\n    for(int i=0; i<curr.size(); i++){\\n        //if already selected, we cannot take the current str\\n        if (taken[curr[i]-\\'a\\']==1)\\n            return false;\\n    }\\n    \\n    //if no repeated chars and not selected\\n    return true;\\n}\\n\\n\\nint recursive(int ind, vector<string> &arr, vector<int> &taken, int len){    \\n    if(ind==arr.size()){//base condition\\n        return len;\\n    }\\n\\n    string curr=arr[ind];\\n    if(isValid(taken, curr)==false){    // if not valid -> skip curr str and move to next index\\n        return recursive(ind+1, arr, taken, len) ;\\n    }\\n    else{//2 options -> pick or not pick(skip)\\n        \\n        for(int j=0; j<curr.size(); j++){\\n            taken[curr[j]-\\'a\\']=1; // pick - mark char in selected as taken\\n        }\\n        \\n        len+=curr.size();\\n        int pick=recursive(ind+1, arr, taken, len); //pick \\n\\n        for(int j=0; j<curr.size(); j++){\\n            taken[curr[j]-\\'a\\']=0; //backtrack and mark all chars as not taken\\n        }\\n        \\n        len-=curr.size() ; //not pick        \\n        int notpick=recursive(ind+1, arr, taken, len);\\n\\n        return max(pick, notpick); //longest length\\n    }\\n}\\n\\npublic:\\n    int maxLength(vector<string>& arr) {\\n    vector<int> taken(26, 0); //keep track of chars taken/not taken\\n    return recursive(0, arr, taken, 0);    \\n    }\\n};\\n\\n//TC : O(n*2^N) exponential\\n//where max value of n can be 26\\n//SC : O(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738104,
                "title": "java-2-approaches-iterative-recursive",
                "content": "### **Please Upvote** :D\\n##### 1. Iterative approach:\\n```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        List<String> ans = new ArrayList<>();\\n        ans.add(\"\");\\n\\n        int max = 0;\\n\\n        for (String s : arr) {\\n            if (!checkIfUnique(s)) continue;\\n            List<String> newStrs = new ArrayList<>();\\n\\n            for (String str : ans) {\\n                String temp = str + s;\\n\\t\\t\\t\\t\\n                if (checkIfUnique(temp)) {\\n                    newStrs.add(temp);\\n                    max = Math.max(max, temp.length());\\n                }\\n            }\\n\\t\\t\\t\\n            ans.addAll(newStrs);\\n        }\\n\\n        return max;\\n    }\\n\\n    public boolean checkIfUnique(String s) {\\n        if (s.length() > 26) return false;\\n        int[] freq = new int[26];\\n\\n        for (char c : s.toCharArray()) {\\n            freq[c - \\'a\\']++;\\n            if (freq[c - \\'a\\'] > 1) return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(n^2 * k), SC: O(n)\\n// n -> size of given input list\\n// k -> size of individula strings in given list\\n```\\n##### 2. Recursive approach:\\n```\\nclass Solution {\\n    int max = 0;\\n    public int maxLength(List<String> arr) {\\n        maxUnique(arr, 0, \"\");\\n        return max;\\n    }\\n\\n    public void maxUnique(List<String> arr, int index, String curr) {\\n        if (index == arr.size() && uniqueCharCount(curr) > max) {\\n            max = curr.length();\\n            return;\\n        }\\n\\n        if (index == arr.size()) return;\\n\\n        maxUnique(arr, index + 1, curr);\\n        maxUnique(arr, index + 1, curr + arr.get(index));\\n    }\\n\\n    public int uniqueCharCount(String s) {\\n        int[] freq = new int[26];\\n\\n        for (char c : s.toCharArray()) {\\n            if (freq[c - \\'a\\']++ > 0) {\\n                return 0;\\n            }\\n        }\\n\\n        return s.length();\\n    }\\n}\\n\\n// TC: O(2^n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        List<String> ans = new ArrayList<>();\\n        ans.add(\"\");\\n\\n        int max = 0;\\n\\n        for (String s : arr) {\\n            if (!checkIfUnique(s)) continue;\\n            List<String> newStrs = new ArrayList<>();\\n\\n            for (String str : ans) {\\n                String temp = str + s;\\n\\t\\t\\t\\t\\n                if (checkIfUnique(temp)) {\\n                    newStrs.add(temp);\\n                    max = Math.max(max, temp.length());\\n                }\\n            }\\n\\t\\t\\t\\n            ans.addAll(newStrs);\\n        }\\n\\n        return max;\\n    }\\n\\n    public boolean checkIfUnique(String s) {\\n        if (s.length() > 26) return false;\\n        int[] freq = new int[26];\\n\\n        for (char c : s.toCharArray()) {\\n            freq[c - \\'a\\']++;\\n            if (freq[c - \\'a\\'] > 1) return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(n^2 * k), SC: O(n)\\n// n -> size of given input list\\n// k -> size of individula strings in given list\\n```\n```\\nclass Solution {\\n    int max = 0;\\n    public int maxLength(List<String> arr) {\\n        maxUnique(arr, 0, \"\");\\n        return max;\\n    }\\n\\n    public void maxUnique(List<String> arr, int index, String curr) {\\n        if (index == arr.size() && uniqueCharCount(curr) > max) {\\n            max = curr.length();\\n            return;\\n        }\\n\\n        if (index == arr.size()) return;\\n\\n        maxUnique(arr, index + 1, curr);\\n        maxUnique(arr, index + 1, curr + arr.get(index));\\n    }\\n\\n    public int uniqueCharCount(String s) {\\n        int[] freq = new int[26];\\n\\n        for (char c : s.toCharArray()) {\\n            if (freq[c - \\'a\\']++ > 0) {\\n                return 0;\\n            }\\n        }\\n\\n        return s.length();\\n    }\\n}\\n\\n// TC: O(2^n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737996,
                "title": "easy-java-solution",
                "content": "\\nclass Solution {\\n\\n    int maxLen;\\n    public int maxLength(List<String> arr) {\\n        if(arr==null || arr.size()==0) return 0;\\n\\n        helperDFS(arr,\"\",0);\\n        return maxLen;\\n    }\\n\\n    public int helperDFS(List<String> arr, String path , int index){\\n    \\n        if(isStringWithUniqueChar(path))\\n            maxLen=Math.max(maxLen,path.length());\\n\\n        if(index==arr.size() || !isStringWithUniqueChar(path)){\\n            return;\\n        }\\n\\n        for (int i = index; i < arr.size() ; i++) {\\n            helperDFS(arr,path+arr.get(i),i+1);\\n        }\\n        \\n    }\\n\\n\\n    public boolean isStringWithUniqueChar(String s){\\n        int[] freq=new int[26];\\n\\n        for(int i=0;i<s.length();i++)\\n            freq[s.charAt(i)-\\'a\\']++;\\n\\n        for(int i=0;i<freq.length;i++)\\n            if(freq[i]>1) return false;\\n\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    int maxLen;\\n    public int maxLength(List<String> arr) {\\n        if(arr==null || arr.size()==0) return 0;\\n\\n        helperDFS(arr,\"\",0);\\n        return maxLen;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2737650,
                "title": "recursion-simple-pick-and-not-pick-approach",
                "content": "class Solution {\\npublic:\\n    \\n    int solve(int i, vector<string>& arr, string s)\\n    {\\n        if(i == arr.size()) return s.size();\\n        \\n        int pick = 0, x = 0;\\n        for(int j=0; j<arr[i].size(); j++)\\n        {\\n            for(int k =0; k<s.size(); k++)\\n            {\\n                if(s[k] == arr[i][j]) {x++; break;}\\n            }\\n        }\\n        \\n        if(!x) pick = solve(i+1, arr, s+arr[i]);\\n        int not_pick = solve(i+1, arr, s);\\n        \\n        return max(pick , not_pick);\\n    }\\n    \\n    int maxLength(vector<string>& arr)\\n    {\\n        vector<string>arr1;\\n        int n = arr.size();\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            unordered_map<char,int>mp; int x = 0;\\n            for(int j=0; j<arr[i].size();j++)\\n            {\\n                mp[arr[i][j]]++;\\n                if(mp[arr[i][j]] == 2) {x++; break;}\\n            }\\n            if(!x) arr1.push_back(arr[i]);          \\n        }\\n        \\n        return solve(0, arr1, \"\");\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int solve(int i, vector<string>& arr, string s)\\n    {\\n        if(i == arr.size()) return s.size();\\n        \\n        int pick = 0, x = 0;\\n        for(int j=0; j<arr[i].size(); j++)\\n        {\\n            for(int k =0; k<s.size(); k++)\\n            {\\n                if(s[k] == arr[i][j]) {x++; break;}",
                "codeTag": "Java"
            },
            {
                "id": 2558699,
                "title": "c-bitmasks-store-the-wrong-mask",
                "content": "```cpp\\nint maxLength(vector<string>& arr) {\\n        int N = arr.size();\\n        int ans = 0;\\n        vector<int> wrongMask;\\n\\t\\t\\n        // Enumerate every mask\\n        for(int mask = 0; mask < (1 << N); mask++) {\\n            \\n            bool notPossible = false;\\n\\t\\t\\t// We will store wrong masks in this wrongMask vector, if any two string are not valid,\\n\\t\\t\\t// then any mask which contains those two strings will be invalid. (Solves TLE)\\n            for(auto a : wrongMask) {\\n                if(__builtin_popcount(mask & a) > 1) {\\n                    notPossible = true;\\n                    break;\\n                } \\n            }\\n            \\n            if(notPossible) continue;\\n            \\n            unordered_map<char, int> M;\\n            for(int i = 0; i < N; i++) {\\n                if(mask >> i & 1) {\\n                    for(char c : arr[i]) {\\n                        if(M.count(c)) {\\n\\t\\t\\t\\t\\t\\t\\t// If map contains a duplicate character, push this mask in wrongMask\\n\\t\\t\\t\\t\\t\\t\\t// then directly jump to next mask.\\n                            wrongMask.push_back(mask);\\n                            goto nextMask;\\n                        }\\n                        M[c]++;\\n                    }\\n                }\\n            }\\n            ans = max(ans,(int)M.size());\\n            nextMask:;\\n            \\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```cpp\\nint maxLength(vector<string>& arr) {\\n        int N = arr.size();\\n        int ans = 0;\\n        vector<int> wrongMask;\\n\\t\\t\\n        // Enumerate every mask\\n        for(int mask = 0; mask < (1 << N); mask++) {\\n            \\n            bool notPossible = false;\\n\\t\\t\\t// We will store wrong masks in this wrongMask vector, if any two string are not valid,\\n\\t\\t\\t// then any mask which contains those two strings will be invalid. (Solves TLE)\\n            for(auto a : wrongMask) {\\n                if(__builtin_popcount(mask & a) > 1) {\\n                    notPossible = true;\\n                    break;\\n                } \\n            }\\n            \\n            if(notPossible) continue;\\n            \\n            unordered_map<char, int> M;\\n            for(int i = 0; i < N; i++) {\\n                if(mask >> i & 1) {\\n                    for(char c : arr[i]) {\\n                        if(M.count(c)) {\\n\\t\\t\\t\\t\\t\\t\\t// If map contains a duplicate character, push this mask in wrongMask\\n\\t\\t\\t\\t\\t\\t\\t// then directly jump to next mask.\\n                            wrongMask.push_back(mask);\\n                            goto nextMask;\\n                        }\\n                        M[c]++;\\n                    }\\n                }\\n            }\\n            ans = max(ans,(int)M.size());\\n            nextMask:;\\n            \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2371121,
                "title": "very-simple-and-easy-to-understand-c-solution",
                "content": "<b> UP Vote if you like this approach and if you have learnt something\\n\\n```\\n/*\\n1. Create a integer vector, where each integer\\'s bits represent, if a particular char is present or not\\n2. Loop each word in the array and set each bit, create bit map of each word\\n3. Use recursion to add each word with take once and not to take once type dp recursion \\n4. A word can only be taken if its bits are not overlaping with the current string\\'s bit status\\n   - to do this, we need to check if there sum is equal to bit wise andding of them, \\n     if eaual then there is no overlaping, if not equal then there is overlaping\\n5. Also we don\\'t have to take the word which has repeted char ( if we have set it to INT_MAX )\\n6. Finally if i is less then 0, check the size of the s with the ans and take maximum\\n*/\\n\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void solve(vector<int>& v, vector<string>& arr, int i, string s, int status){\\n        if(i < 0) { \\n            ans = max(ans, (int)s.size());\\n        }else{\\n            solve(v, arr, i-1, s, status);\\n            if( (v[i] != INT_MAX ) && ( (v[i] + status) == (v[i] | status)) ){ \\n                solve(v, arr, i-1, s+arr[i], status  | v[i]);\\n            }\\n        }\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        vector<int> v(arr.size());\\n        for(int i= 0; i < arr.size(); ++i){\\n            for(auto c: arr[i]) {\\n                if((v[i] >> (c - \\'a\\'))& 1){ //if already bit is set, then set value to INT_MAX\\n                    v[i] = INT_MAX;\\n                }else{                      // if not set, then set it to 1\\n                    v[i] = v[i] | (1 << (c - \\'a\\'));\\n                }\\n            }\\n        }\\n        string s = \"\";\\n        solve(v, arr, arr.size()-1, s, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\n/*\\n1. Create a integer vector, where each integer\\'s bits represent, if a particular char is present or not\\n2. Loop each word in the array and set each bit, create bit map of each word\\n3. Use recursion to add each word with take once and not to take once type dp recursion \\n4. A word can only be taken if its bits are not overlaping with the current string\\'s bit status\\n   - to do this, we need to check if there sum is equal to bit wise andding of them, \\n     if eaual then there is no overlaping, if not equal then there is overlaping\\n5. Also we don\\'t have to take the word which has repeted char ( if we have set it to INT_MAX )\\n6. Finally if i is less then 0, check the size of the s with the ans and take maximum\\n*/\\n\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void solve(vector<int>& v, vector<string>& arr, int i, string s, int status){\\n        if(i < 0) { \\n            ans = max(ans, (int)s.size());\\n        }else{\\n            solve(v, arr, i-1, s, status);\\n            if( (v[i] != INT_MAX ) && ( (v[i] + status) == (v[i] | status)) ){ \\n                solve(v, arr, i-1, s+arr[i], status  | v[i]);\\n            }\\n        }\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        vector<int> v(arr.size());\\n        for(int i= 0; i < arr.size(); ++i){\\n            for(auto c: arr[i]) {\\n                if((v[i] >> (c - \\'a\\'))& 1){ //if already bit is set, then set value to INT_MAX\\n                    v[i] = INT_MAX;\\n                }else{                      // if not set, then set it to 1\\n                    v[i] = v[i] | (1 << (c - \\'a\\'));\\n                }\\n            }\\n        }\\n        string s = \"\";\\n        solve(v, arr, arr.size()-1, s, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1975572,
                "title": "java-recursion",
                "content": "You either select the string or you dont, compute the answer accordingly.\\n```\\nclass Solution {\\n    public int isApplicable(String res){\\n        int[] cnt = new int[26];\\n        for(int i = 0 ; i < res.length() ; i++)\\n            cnt[res.charAt(i) - \\'a\\']++;\\n        for(int i = 0 ; i < 26 ; i++)\\n            if(cnt[i] > 1) return 0;\\n        return res.length();\\n    }\\n    public int solve(List<String> arr , int idx, String res){\\n        if(idx == arr.size()){\\n            return isApplicable(res);\\n        }\\n        \\n        int len  = res.length();\\n        res += (arr.get(idx));\\n        int size1 = solve(arr , idx + 1 , res);\\n        int size2 = solve(arr , idx + 1 , res.substring(0,len));\\n        return Math.max(size1, size2);\\n    }\\n    \\n    public int maxLength(List<String> arr) {\\n        return solve(arr , 0 ,\"\");\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int isApplicable(String res){\\n        int[] cnt = new int[26];\\n        for(int i = 0 ; i < res.length() ; i++)\\n            cnt[res.charAt(i) - \\'a\\']++;\\n        for(int i = 0 ; i < 26 ; i++)\\n            if(cnt[i] > 1) return 0;\\n        return res.length();\\n    }\\n    public int solve(List<String> arr , int idx, String res){\\n        if(idx == arr.size()){\\n            return isApplicable(res);\\n        }\\n        \\n        int len  = res.length();\\n        res += (arr.get(idx));\\n        int size1 = solve(arr , idx + 1 , res);\\n        int size2 = solve(arr , idx + 1 , res.substring(0,len));\\n        return Math.max(size1, size2);\\n    }\\n    \\n    public int maxLength(List<String> arr) {\\n        return solve(arr , 0 ,\"\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1819363,
                "title": "backtracking-clean-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int ans=0;\\n    \\n    void backtrack(int ind, string curr, vector<string>& arr){\\n        if(ind==n){\\n            int v=curr.size();\\n            cout<<curr<<\" \";\\n            ans=max(ans, v);\\n            return;\\n        }\\n        int v=arr[ind].size();\\n        unordered_map<char, int> m;\\n        for(auto &x: curr){\\n            m[x]++;\\n        }\\n        bool f=true; //check if we can add this string to curr\\n        for(auto &x: arr[ind]){\\n            if(m.count(x))\\n            {\\n                f=false;\\n                break;\\n            }\\n            m[x]++;\\n        }\\n        if(f){ //since we can add it, now we have two options - to add it or to not add it\\n            curr+=arr[ind];\\n            backtrack(ind+1, curr, arr);\\n            curr=curr.substr(0, curr.size()-v);\\n            backtrack(ind+1, curr, arr);\\n        }\\n        else{ //we can\\'t add it\\n            backtrack(ind+1, curr, arr);\\n        }\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        n=arr.size();\\n        string curr=\"\";\\n        backtrack(0, curr, arr);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int ans=0;\\n    \\n    void backtrack(int ind, string curr, vector<string>& arr){\\n        if(ind==n){\\n            int v=curr.size();\\n            cout<<curr<<\" \";\\n            ans=max(ans, v);\\n            return;\\n        }\\n        int v=arr[ind].size();\\n        unordered_map<char, int> m;\\n        for(auto &x: curr){\\n            m[x]++;\\n        }\\n        bool f=true; //check if we can add this string to curr\\n        for(auto &x: arr[ind]){\\n            if(m.count(x))\\n            {\\n                f=false;\\n                break;\\n            }\\n            m[x]++;\\n        }\\n        if(f){ //since we can add it, now we have two options - to add it or to not add it\\n            curr+=arr[ind];\\n            backtrack(ind+1, curr, arr);\\n            curr=curr.substr(0, curr.size()-v);\\n            backtrack(ind+1, curr, arr);\\n        }\\n        else{ //we can\\'t add it\\n            backtrack(ind+1, curr, arr);\\n        }\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        n=arr.size();\\n        string curr=\"\";\\n        backtrack(0, curr, arr);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1798498,
                "title": "c-recursive-and-bit-manipulation-solution",
                "content": "DO \\u2B06\\uFE0F UPVOTE IF IT HELPS YOU IN ANYWAY\\n\\nRECURSIVE SOLUTION (In case it gives TLE try passing ans string by reference) :\\n\\n\\tclass Solution {\\n\\t\\t\\t\\t int res=0;\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tbool isunique(string &s){\\n\\t\\t\\t\\t\\tvector<int> v(26,0);\\n\\t\\t\\t\\t\\tfor(auto &it: s){\\n\\t\\t\\t\\t\\t\\tif(v[it-\\'a\\']==0)\\n\\t\\t\\t\\t\\t\\t\\t v[it-\\'a\\']++;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint max(int a,int b){\\n\\t\\t\\t\\t\\treturn (a>b)?a:b;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvoid helper(vector<string> &arr,string ans, int i){\\n\\t\\t\\t\\t\\tif(i==arr.size()){\\n\\t\\t\\t\\t\\t\\tif(isunique(ans)){\\n\\t\\t\\t\\t\\t\\t\\tres=max(res,ans.length());\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\thelper(arr,ans+arr[i],i+1);\\n\\t\\t\\t\\t\\thelper(arr,ans,i+1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint maxLength(vector<string>& arr) {\\n\\t\\t\\t\\t\\t   string ans=\"\";\\n\\t\\t\\t\\t\\t\\thelper(arr,ans,0);\\n\\t\\t\\t\\t\\t  return res;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\nOPTIMISED USING BIT MANIPULATION :\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isunique(string &s){\\n\\t\\t\\tvector<int> v(26,0);\\n\\t\\t\\tfor(auto &it: s){\\n\\t\\t\\t\\tif(v[it-\\'a\\']==0)\\n\\t\\t\\t\\t\\t v[it-\\'a\\']++;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tint max(int a,int b){\\n\\t\\t\\treturn (a>b)?a:b;\\n\\t\\t}\\n\\t\\tint maxLength(vector<string>& arr) {\\n\\t\\t\\t\\t int res=0;\\n\\n\\t\\t\\t\\tfor(int i=0;i<(1<<arr.size());i++){\\n\\t\\t\\t\\t\\t string ans;\\n\\t\\t\\t\\t\\tfor(int j=0;j<arr.size();j++){\\n\\t\\t\\t\\t\\t\\t\\t  if(i&(1<<j)){\\n\\t\\t\\t\\t\\t\\t\\t\\t  ans+=arr[j];\\n\\t\\t\\t\\t\\t\\t\\t  }    \\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif(isunique(ans)){\\n\\t\\t\\t\\t\\t\\tres=max(res,ans.length());\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t  return res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\t\\t\\t int res=0;\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tbool isunique(string &s){\\n\\t\\t\\t\\t\\tvector<int> v(26,0);\\n\\t\\t\\t\\t\\tfor(auto &it: s){\\n\\t\\t\\t\\t\\t\\tif(v[it-\\'a\\']==0)\\n\\t\\t\\t\\t\\t\\t\\t v[it-\\'a\\']++;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1780983,
                "title": "java-based-queue-approach-easy-and-simple-to-understand",
                "content": "```\\nclass Solution {\\n    \\n    public int maxLength(List<String> arr) {\\n\\t\\n        int n = arr.size();\\n\\t\\t\\n        int [] result = new int[1];\\n        \\n        maxLengthUnique(arr,result,0,\"\");\\n\\t\\t\\n        return result[0];\\n    }\\n    \\n    private void maxLengthUnique(List<String> arr,int []result,\\n                                 int index,String current){\\n\\t\\t\\t\\t\\t\\t\\t\\t \\n\\t\\tint i = 0, n = arr.size();\\n\\t\\t\\n\\t\\t// We use queue to store all the combinations possible!\\n        Queue<String> q = new LinkedList<>();\\n        q.add(\"\");\\n\\t\\t\\n\\t\\t//Loop for all the strings in array.\\n        while(i < n){\\n            int size = q.size();\\n            \\n\\t\\t\\t//Loop till all the elements in Queue are appended with \"\" and the string \\'str\\'\\n            for(int loop = 0;loop < size; loop++){\\n                String temp = q.poll();    // temp = \"\" \\n                String dontConsider = temp; // dontConsider = \"\"\\n                String consider = temp + arr.get(i); // consider = \"un\" --> Aboe 3 steps Repeated till the last element.\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Function call to calculate the unique characters\\n                if(uniqueCharacters(dontConsider) > result[0]){\\n                    result[0] = dontConsider.length();\\n                }\\n\\t\\t\\t\\t// Function call to calculate the unique characters\\n                if(uniqueCharacters(consider) > result[0]){\\n                    result[0] = consider.length();\\n                }\\n\\t\\t\\t\\t// Adding the new strings to our queue again.\\n                q.add(dontConsider);\\n                q.add(consider);\\n            }\\n            i++;\\n        }\\n        \\n    }\\n    \\n    private int uniqueCharacters(String string){\\n        char[] alpha = new char[26];\\n        \\n        for(char character : string.toCharArray())\\n            if(alpha[character - \\'a\\']++ > 0) \\n                return -1;\\n        \\n        return string.length();\\n    } \\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int maxLength(List<String> arr) {\\n\\t\\n        int n = arr.size();\\n\\t\\t\\n        int [] result = new int[1];\\n        \\n        maxLengthUnique(arr,result,0,\"\");\\n\\t\\t\\n        return result[0];\\n    }\\n    \\n    private void maxLengthUnique(List<String> arr,int []result,\\n                                 int index,String current){\\n\\t\\t\\t\\t\\t\\t\\t\\t \\n\\t\\tint i = 0, n = arr.size();\\n\\t\\t\\n\\t\\t// We use queue to store all the combinations possible!\\n        Queue<String> q = new LinkedList<>();\\n        q.add(\"\");\\n\\t\\t\\n\\t\\t//Loop for all the strings in array.\\n        while(i < n){\\n            int size = q.size();\\n            \\n\\t\\t\\t//Loop till all the elements in Queue are appended with \"\" and the string \\'str\\'\\n            for(int loop = 0;loop < size; loop++){\\n                String temp = q.poll();    // temp = \"\" \\n                String dontConsider = temp; // dontConsider = \"\"\\n                String consider = temp + arr.get(i); // consider = \"un\" --> Aboe 3 steps Repeated till the last element.\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Function call to calculate the unique characters\\n                if(uniqueCharacters(dontConsider) > result[0]){\\n                    result[0] = dontConsider.length();\\n                }\\n\\t\\t\\t\\t// Function call to calculate the unique characters\\n                if(uniqueCharacters(consider) > result[0]){\\n                    result[0] = consider.length();\\n                }\\n\\t\\t\\t\\t// Adding the new strings to our queue again.\\n                q.add(dontConsider);\\n                q.add(consider);\\n            }\\n            i++;\\n        }\\n        \\n    }\\n    \\n    private int uniqueCharacters(String string){\\n        char[] alpha = new char[26];\\n        \\n        for(char character : string.toCharArray())\\n            if(alpha[character - \\'a\\']++ > 0) \\n                return -1;\\n        \\n        return string.length();\\n    } \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1743841,
                "title": "easy-solution-using-python3-and-backtracking",
                "content": "\\tclass Solution:\\n\\t\\tdef maxLength(self, arr: List[str]) -> int:\\n\\t\\t\\tself.m = 0\\n\\t\\t\\tdef solve(com,arr):\\n\\t\\t\\t\\tif(len(com) == len(set(com))):\\n\\t\\t\\t\\t\\tself.m = max(self.m,len(com))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tfor i in range(len(arr)):\\n\\t\\t\\t\\t\\tsolve(com+\"\".join(arr[i]),arr[i+1:])\\n\\t\\t\\tsolve(\"\",arr)\\n\\t\\t\\treturn self.m",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef maxLength(self, arr: List[str]) -> int:\\n\\t\\t\\tself.m = 0\\n\\t\\t\\tdef solve(com,arr):\\n\\t\\t\\t\\tif(len(com) == len(set(com))):\\n\\t\\t\\t\\t\\tself.m = max(self.m,len(com))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tfor i in range(len(arr)):\\n\\t\\t\\t\\t\\tsolve(com+\"\".join(arr[i]),arr[i+1:])\\n\\t\\t\\tsolve(\"\",arr)\\n\\t\\t\\treturn self.m",
                "codeTag": "Java"
            },
            {
                "id": 1562918,
                "title": "c-easy-backtracking-solution",
                "content": "![image](https://assets.leetcode.com/users/images/65c35f2a-4bac-4c28-aa6e-42bfeb23bc46_1636212918.9591146.png)\\n\\n```\\nclass Solution {\\n    bool isUnique(vector<string>& arr){\\n        vector<bool> visited(26, false);\\n        for(string word : arr){\\n            for(char ch : word){\\n                if(visited[ch - \\'a\\']){\\n                    return false;\\n                }\\n                visited[ch - \\'a\\'] = true;\\n            }\\n        }\\n        return true;\\n    }\\n    void dfs(vector<string>& arr, int index, int n, vector<string>& temp, int& maxLen){\\n        for(int i = index; i < n; i++){\\n            temp.push_back(arr[i]);\\n            if(isUnique(temp)){\\n                int len = 0;\\n                for(string word : temp){\\n                    len += word.size();\\n                }\\n                maxLen = max(maxLen, len);\\n                dfs(arr, i + 1, n, temp, maxLen);\\n            }\\n            temp.pop_back();\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int maxLen = 0;\\n        vector<string> temp;\\n        int n = arr.size();\\n        dfs(arr, 0, n, temp, maxLen);\\n        return maxLen;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool isUnique(vector<string>& arr){\\n        vector<bool> visited(26, false);\\n        for(string word : arr){\\n            for(char ch : word){\\n                if(visited[ch - \\'a\\']){\\n                    return false;\\n                }\\n                visited[ch - \\'a\\'] = true;\\n            }\\n        }\\n        return true;\\n    }\\n    void dfs(vector<string>& arr, int index, int n, vector<string>& temp, int& maxLen){\\n        for(int i = index; i < n; i++){\\n            temp.push_back(arr[i]);\\n            if(isUnique(temp)){\\n                int len = 0;\\n                for(string word : temp){\\n                    len += word.size();\\n                }\\n                maxLen = max(maxLen, len);\\n                dfs(arr, i + 1, n, temp, maxLen);\\n            }\\n            temp.pop_back();\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int maxLen = 0;\\n        vector<string> temp;\\n        int n = arr.size();\\n        dfs(arr, 0, n, temp, maxLen);\\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1562364,
                "title": "c-bit-manipulation-solution-100-faster",
                "content": "# Bit Manipulation Solution\\nReplaced the strings with their corresponding 32-bit integer number where the bits set are the characters in the string using the function `f(x) = x - 97`.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxLength(vector<string> &arr) {\\n        vector<int> nums;\\n        for(string &i: arr) {\\n            int num = 0;\\n            bool flag = true;\\n            \\n            for(char &j: i) {\\n                int x = 1 << (j - \\'a\\');\\n                \\n                if(num & x)\\n                    flag = false;\\n                num |= x;\\n            }\\n            \\n            if(flag)\\n                nums.push_back(num);\\n        }\\n        \\n        return solve(nums, 0, 0);\\n    }\\n    \\nprivate:\\n    int solve(vector<int> &nums, int k,  int i) {\\n        int res = __builtin_popcount(k);\\n        for(int j = i; j < nums.size(); j++)\\n            if((k & nums[j]) == 0)\\n                res = max(res, solve(nums, k | nums[j], j + 1));\\n        return res;\\n    }\\n};\\n```\\n\\n**Toss an upvote to your coder :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLength(vector<string> &arr) {\\n        vector<int> nums;\\n        for(string &i: arr) {\\n            int num = 0;\\n            bool flag = true;\\n            \\n            for(char &j: i) {\\n                int x = 1 << (j - \\'a\\');\\n                \\n                if(num & x)\\n                    flag = false;\\n                num |= x;\\n            }\\n            \\n            if(flag)\\n                nums.push_back(num);\\n        }\\n        \\n        return solve(nums, 0, 0);\\n    }\\n    \\nprivate:\\n    int solve(vector<int> &nums, int k,  int i) {\\n        int res = __builtin_popcount(k);\\n        for(int j = i; j < nums.size(); j++)\\n            if((k & nums[j]) == 0)\\n                res = max(res, solve(nums, k | nums[j], j + 1));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480739,
                "title": "kotlin-bit-mask-recursive-and-dp-solutions-with-comments",
                "content": "Recursive Solution: \\n```\\nclass Solution {\\n    fun maxLength(arr: List<String>): Int {\\n        // Transform all strings in arr into map(mask, length)\\n        // e.g. \"abd\" -> (0...01011, 3)\\n        // e.g. \"xzda\" -> (1010...01001, 4)\\n        // e.g. \"aaa\" -> skip\\n        val subs = arr.fold(mutableMapOf<Int, Int>()) { acc, s ->\\n            var mask = 0\\n            s.forEach { c ->\\n                val bit = 1 shl c - \\'a\\'\\n                if (mask and bit == 0) { // Only accept strings without duplicated characters\\n                    mask = mask or bit\\n                } else {\\n                    return@fold acc // Skip strings with duplicated characters\\n                }\\n            }\\n            acc.also { it[mask] = s.length }\\n        }.entries.toList()\\n        \\n        var res = 0\\n        val maxMask = (1 shl 27) - 1\\n        \\n        fun findConcatenationFrom(index: Int, currentMask: Int, currentRes: Int) {\\n            if (index == subs.size || currentMask == maxMask) {\\n                res = maxOf(res, currentRes)\\n                return\\n            }\\n            // Try add subs[index] if no duplicated characters\\n            if (currentMask and subs[index].key == 0) {\\n                findConcatenationFrom(index + 1, currentMask or subs[index].key, currentRes + subs[index].value)\\n            }\\n            // Always try skip subs[index]\\n            findConcatenationFrom(index + 1, currentMask, currentRes)\\n        }\\n        findConcatenationFrom(0, 0, 0)        \\n        \\n        return res\\n    }\\n}\\n```\\n\\nDP Solution:\\n```\\nclass Solution {\\n    fun maxLength(arr: List<String>): Int {\\n        // Transform all strings in arr into map(mask, length)\\n        // e.g. \"abd\" -> (0...01011, 3)\\n        // e.g. \"xzda\" -> (1010...01001, 4)\\n        // e.g. \"aaa\" -> skip\\n        val subs = arr.fold(mutableMapOf<Int, Int>()) { acc, s ->\\n            var mask = 0\\n            s.forEach { c ->\\n                val bit = 1 shl c - \\'a\\'\\n                if (mask and bit == 0) { // Only accept strings without duplicated characters\\n                    mask = mask or bit\\n                } else {\\n                    return@fold acc // Skip strings with duplicated characters\\n                }\\n            }\\n            acc.also { it[mask] = s.length }\\n        }.map { it.key to it.value }.toSet()\\n        \\n        var res = subs.fold(0) { acc, (_, length) -> maxOf(acc, length) } // Init with the max length in subs\\n        val validSubs = mutableSetOf<Pair<Int, Int>>().apply { addAll(subs) } // Init with subs\\n        \\n        subs.forEach { (mask, length) ->\\n            val newValidSubs = mutableSetOf<Pair<Int, Int>>()\\n            validSubs.forEach { // Try concate with all valid sub-sequences we\\'ve met so far\\n                if (it.first and mask == 0) {\\n                    res = maxOf(res, it.second + length)\\n                    newValidSubs.add(it.first or mask to it.second + length)\\n                }\\n            }\\n            validSubs.addAll(newValidSubs) // Add all new valid sub-sequences\\n        }     \\n        \\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    fun maxLength(arr: List<String>): Int {\\n        // Transform all strings in arr into map(mask, length)\\n        // e.g. \"abd\" -> (0...01011, 3)\\n        // e.g. \"xzda\" -> (1010...01001, 4)\\n        // e.g. \"aaa\" -> skip\\n        val subs = arr.fold(mutableMapOf<Int, Int>()) { acc, s ->\\n            var mask = 0\\n            s.forEach { c ->\\n                val bit = 1 shl c - \\'a\\'\\n                if (mask and bit == 0) { // Only accept strings without duplicated characters\\n                    mask = mask or bit\\n                } else {\\n                    return@fold acc // Skip strings with duplicated characters\\n                }\\n            }\\n            acc.also { it[mask] = s.length }\\n        }.entries.toList()\\n        \\n        var res = 0\\n        val maxMask = (1 shl 27) - 1\\n        \\n        fun findConcatenationFrom(index: Int, currentMask: Int, currentRes: Int) {\\n            if (index == subs.size || currentMask == maxMask) {\\n                res = maxOf(res, currentRes)\\n                return\\n            }\\n            // Try add subs[index] if no duplicated characters\\n            if (currentMask and subs[index].key == 0) {\\n                findConcatenationFrom(index + 1, currentMask or subs[index].key, currentRes + subs[index].value)\\n            }\\n            // Always try skip subs[index]\\n            findConcatenationFrom(index + 1, currentMask, currentRes)\\n        }\\n        findConcatenationFrom(0, 0, 0)        \\n        \\n        return res\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun maxLength(arr: List<String>): Int {\\n        // Transform all strings in arr into map(mask, length)\\n        // e.g. \"abd\" -> (0...01011, 3)\\n        // e.g. \"xzda\" -> (1010...01001, 4)\\n        // e.g. \"aaa\" -> skip\\n        val subs = arr.fold(mutableMapOf<Int, Int>()) { acc, s ->\\n            var mask = 0\\n            s.forEach { c ->\\n                val bit = 1 shl c - \\'a\\'\\n                if (mask and bit == 0) { // Only accept strings without duplicated characters\\n                    mask = mask or bit\\n                } else {\\n                    return@fold acc // Skip strings with duplicated characters\\n                }\\n            }\\n            acc.also { it[mask] = s.length }\\n        }.map { it.key to it.value }.toSet()\\n        \\n        var res = subs.fold(0) { acc, (_, length) -> maxOf(acc, length) } // Init with the max length in subs\\n        val validSubs = mutableSetOf<Pair<Int, Int>>().apply { addAll(subs) } // Init with subs\\n        \\n        subs.forEach { (mask, length) ->\\n            val newValidSubs = mutableSetOf<Pair<Int, Int>>()\\n            validSubs.forEach { // Try concate with all valid sub-sequences we\\'ve met so far\\n                if (it.first and mask == 0) {\\n                    res = maxOf(res, it.second + length)\\n                    newValidSubs.add(it.first or mask to it.second + length)\\n                }\\n            }\\n            validSubs.addAll(newValidSubs) // Add all new valid sub-sequences\\n        }     \\n        \\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1479786,
                "title": "python3-one-liner-solution-using-a-pseudo-powerset-method",
                "content": "I will preface this by saying that I recognize that one-liners in python are pretty useless and create code that is unreadable. However, it is fun to try and see how much can be packed into one line. Also it helps practice becoming more pythonic.\\n\\nThe method I used to solve this problem is pretty much the same as in #78, subsets. The solutioin can be found by just creating a powerset; however, during the creation of the powerset, only allow a new subset to be created if the letters will be unique:\\n\\n```\\nreturn len(max(reduce(lambda x,y: x+[i+y for i in x if len(i+y)==len(set(i+y))], arr, [\\'\\']), key= lambda x: len(x)))\\n```\\n\\nBreaking down the oneliner into parts--\\nThis creates the powerset, the if statement filters out the sets that would have duplicate letters\\n```\\nreduce(lambda x,y: x+[i+y for i in x if len(i+y)==len(set(i+y))], arr, [\\'\\'])\\n```\\nThis finds the max length subset:\\n```\\nlen(max( (previous line) ), key= lambda x: len(x)))\\n```\\n![image](https://assets.leetcode.com/users/images/65e151e5-22e0-40b1-87b3-27373d7a6b22_1632346807.056603.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nreturn len(max(reduce(lambda x,y: x+[i+y for i in x if len(i+y)==len(set(i+y))], arr, [\\'\\']), key= lambda x: len(x)))\\n```\n```\\nreduce(lambda x,y: x+[i+y for i in x if len(i+y)==len(set(i+y))], arr, [\\'\\'])\\n```\n```\\nlen(max( (previous line) ), key= lambda x: len(x)))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1479769,
                "title": "java-dfs-beat-98",
                "content": "```\\nclass Solution {\\n    boolean[] forbidden = new boolean[1];\\n    boolean[][] letters = new boolean[1][1];\\n    boolean finished = false;\\n    int result = 0;\\n    int distinctLetters = 0;\\n    public int maxLength(List<String> list) {\\n        forbidden = new boolean[list.size()];\\n        letters = new boolean[list.size()][26];\\n        boolean[] uniqueLetters = new boolean[26];\\n        for (int i = 0; i < list.size(); i++) {\\n            String element = list.get(i);\\n            for (int j = 0; j < element.length(); j++) {\\n                int charIndex = element.charAt(j) - \\'a\\';\\n                if (letters[i][charIndex]) {\\n                    forbidden[i] = true;\\n                }\\n                letters[i][charIndex] = true;\\n                if (!uniqueLetters[charIndex]) {\\n                    uniqueLetters[charIndex] = true;\\n                    distinctLetters++;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < list.size(); i++) {\\n            if (!forbidden[i]) {\\n                boolean[] used = new boolean[26];\\n                char[] curLetters = list.get(i).toCharArray();\\n                for (int j = 0; j < curLetters.length; j++) {\\n                    int charIndex = curLetters[j] - \\'a\\';\\n                    used[charIndex] = true;\\n                }         \\n                dfs(list, used, list.get(i).length());\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private void dfs(List<String> list, boolean[] used, int size) {\\n        result = Math.max(result, size);\\n        if (size == distinctLetters) {\\n            finished = true;\\n        }\\n        if (finished) return;\\n\\n        for (int i = 0; i < list.size(); i++) {\\n            boolean[] curLetters = letters[i];\\n            if (!forbidden[i] && canVisit(curLetters, used)) {\\n                markAsVisited(curLetters, used);\\n                dfs(list, used, size + list.get(i).length());\\n                removeFromVisited(curLetters, used);\\n            }\\n        }\\n    }\\n\\n     private void markAsVisited(boolean[] curLetters, boolean[] used) {\\n        for (int j = 0; j < 26; j++) {\\n            if (curLetters[j]) {\\n                used[j] = true;\\n            }\\n        }\\n    }\\n    \\n    private void removeFromVisited(boolean[] curLetters, boolean[] used) {\\n        for (int j = 0; j < 26; j++) {\\n            if (curLetters[j]) {\\n                used[j] = false;\\n            }\\n        }\\n    }\\n    \\n    private boolean canVisit(boolean[] curLetters, boolean[] used) {\\n        boolean canVisit = true;\\n        for (int j = 0; j < 26; j++) {\\n            if (curLetters[j] && used[j]) {\\n                canVisit = false;\\n                break;\\n            }\\n        }\\n        return canVisit;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    boolean[] forbidden = new boolean[1];\\n    boolean[][] letters = new boolean[1][1];\\n    boolean finished = false;\\n    int result = 0;\\n    int distinctLetters = 0;\\n    public int maxLength(List<String> list) {\\n        forbidden = new boolean[list.size()];\\n        letters = new boolean[list.size()][26];\\n        boolean[] uniqueLetters = new boolean[26];\\n        for (int i = 0; i < list.size(); i++) {\\n            String element = list.get(i);\\n            for (int j = 0; j < element.length(); j++) {\\n                int charIndex = element.charAt(j) - \\'a\\';\\n                if (letters[i][charIndex]) {\\n                    forbidden[i] = true;\\n                }\\n                letters[i][charIndex] = true;\\n                if (!uniqueLetters[charIndex]) {\\n                    uniqueLetters[charIndex] = true;\\n                    distinctLetters++;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < list.size(); i++) {\\n            if (!forbidden[i]) {\\n                boolean[] used = new boolean[26];\\n                char[] curLetters = list.get(i).toCharArray();\\n                for (int j = 0; j < curLetters.length; j++) {\\n                    int charIndex = curLetters[j] - \\'a\\';\\n                    used[charIndex] = true;\\n                }         \\n                dfs(list, used, list.get(i).length());\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private void dfs(List<String> list, boolean[] used, int size) {\\n        result = Math.max(result, size);\\n        if (size == distinctLetters) {\\n            finished = true;\\n        }\\n        if (finished) return;\\n\\n        for (int i = 0; i < list.size(); i++) {\\n            boolean[] curLetters = letters[i];\\n            if (!forbidden[i] && canVisit(curLetters, used)) {\\n                markAsVisited(curLetters, used);\\n                dfs(list, used, size + list.get(i).length());\\n                removeFromVisited(curLetters, used);\\n            }\\n        }\\n    }\\n\\n     private void markAsVisited(boolean[] curLetters, boolean[] used) {\\n        for (int j = 0; j < 26; j++) {\\n            if (curLetters[j]) {\\n                used[j] = true;\\n            }\\n        }\\n    }\\n    \\n    private void removeFromVisited(boolean[] curLetters, boolean[] used) {\\n        for (int j = 0; j < 26; j++) {\\n            if (curLetters[j]) {\\n                used[j] = false;\\n            }\\n        }\\n    }\\n    \\n    private boolean canVisit(boolean[] curLetters, boolean[] used) {\\n        boolean canVisit = true;\\n        for (int j = 0; j < 26; j++) {\\n            if (curLetters[j] && used[j]) {\\n                canVisit = false;\\n                break;\\n            }\\n        }\\n        return canVisit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1478724,
                "title": "java-bit-manipulation-with-recursion",
                "content": "I think i have a pretty straightforward solution here using a mask to count the character frequency.\\n\\n```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        return findMax(arr, 0, 0);\\n    }\\n    int findMax(List<String> arr, int currentIndex, int mask) {\\n        if(currentIndex == arr.size()) return Integer.bitCount(mask);\\n    \\n\\t\\t// Skip the current item, and analyze the next one\\n        int count = findMax(arr, currentIndex + 1, mask);\\n        \\n\\t\\t// Now look at the current item so far and see if any of the characters in the mask overlap.\\n        var item = arr.get(currentIndex);\\n        \\n        int newMask = mask;\\n        for(var c: item.toCharArray()) {\\n\\t\\t\\t// return the previous count if you see any characters that are present in the map\\n            if((newMask & (1 << c - \\'a\\')) != 0) return count;\\n\\t\\t\\t// otherwise modify the mask and set the appropriate bit for the character index\\n            newMask |= (1 << (c -\\'a\\'));    \\n        }\\n\\t\\t// the max count is the max of both the count determined by skipping the current element, and the count from including the element.\\n        return Math.max(count, findMax(arr, currentIndex + 1, newMask));\\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        return findMax(arr, 0, 0);\\n    }\\n    int findMax(List<String> arr, int currentIndex, int mask) {\\n        if(currentIndex == arr.size()) return Integer.bitCount(mask);\\n    \\n\\t\\t// Skip the current item, and analyze the next one\\n        int count = findMax(arr, currentIndex + 1, mask);\\n        \\n\\t\\t// Now look at the current item so far and see if any of the characters in the mask overlap.\\n        var item = arr.get(currentIndex);\\n        \\n        int newMask = mask;\\n        for(var c: item.toCharArray()) {\\n\\t\\t\\t// return the previous count if you see any characters that are present in the map\\n            if((newMask & (1 << c - \\'a\\')) != 0) return count;\\n\\t\\t\\t// otherwise modify the mask and set the appropriate bit for the character index\\n            newMask |= (1 << (c -\\'a\\'));    \\n        }\\n\\t\\t// the max count is the max of both the count determined by skipping the current element, and the count from including the element.\\n        return Math.max(count, findMax(arr, currentIndex + 1, newMask));\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1478613,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn max_length(arr: Vec<String>) -> i32 {\\n        let arr = arr\\n            .iter()\\n            .filter_map(|s| {\\n                let u = s.bytes().map(|u| 1 << (u - b\\'a\\')).sum::<u32>();\\n                if u.count_ones() == s.len() as u32 {\\n                    Some(u)\\n                } else {\\n                    None\\n                }\\n            })\\n            .collect::<Vec<_>>();\\n        (0..1 << arr.len())\\n            .filter_map(|i| {\\n                (0..arr.len())\\n                    .filter(|&j| i & 1 << j != 0)\\n                    .try_fold(0, |acc, j| {\\n                        if acc & arr[j] == 0 {\\n                            Some(acc | arr[j])\\n                        } else {\\n                            None\\n                        }\\n                    })\\n                    .map(|u| u.count_ones())\\n            })\\n            .max()\\n            .unwrap() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn max_length(arr: Vec<String>) -> i32 {\\n        let arr = arr\\n            .iter()\\n            .filter_map(|s| {\\n                let u = s.bytes().map(|u| 1 << (u - b\\'a\\')).sum::<u32>();\\n                if u.count_ones() == s.len() as u32 {\\n                    Some(u)\\n                } else {\\n                    None\\n                }\\n            })\\n            .collect::<Vec<_>>();\\n        (0..1 << arr.len())\\n            .filter_map(|i| {\\n                (0..arr.len())\\n                    .filter(|&j| i & 1 << j != 0)\\n                    .try_fold(0, |acc, j| {\\n                        if acc & arr[j] == 0 {\\n                            Some(acc | arr[j])\\n                        } else {\\n                            None\\n                        }\\n                    })\\n                    .map(|u| u.count_ones())\\n            })\\n            .max()\\n            .unwrap() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1352187,
                "title": "4ms-clean-easy-code-c-dfs-no-real-concatenation-maintaining-frequency-array",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dfs(vector<string> &arr, int index, int *freq) {\\n        if(index >= arr.size()) return 0;\\n        \\n        for(char c:arr[index]){ \\n            freq[c-\\'a\\'] += 1;\\n        }\\n        \\n        for(char c:arr[index]){ \\n            if(freq[c-\\'a\\'] > 1) {\\n                for(char c: arr[index]) freq[c-\\'a\\'] -= 1;\\n                return 0;\\n            }\\n        }\\n        \\n        int ans = arr[index].size();\\n        \\n        for(int i=index+1; i<arr.size(); i++) {\\n            ans = max(ans, (int)arr[index].length() + dfs(arr, i, freq));\\n        }\\n        \\n        for(char c: arr[index]) freq[c-\\'a\\'] -= 1;\\n        \\n        return ans;\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        int ans = 0;\\n        for(int i=0; i<arr.size(); i++) {\\n            int freq[26] = {0};\\n            ans = max(ans, dfs(arr, i, freq));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dfs(vector<string> &arr, int index, int *freq) {\\n        if(index >= arr.size()) return 0;\\n        \\n        for(char c:arr[index]){ \\n            freq[c-\\'a\\'] += 1;\\n        }\\n        \\n        for(char c:arr[index]){ \\n            if(freq[c-\\'a\\'] > 1) {\\n                for(char c: arr[index]) freq[c-\\'a\\'] -= 1;\\n                return 0;\\n            }\\n        }\\n        \\n        int ans = arr[index].size();\\n        \\n        for(int i=index+1; i<arr.size(); i++) {\\n            ans = max(ans, (int)arr[index].length() + dfs(arr, i, freq));\\n        }\\n        \\n        for(char c: arr[index]) freq[c-\\'a\\'] -= 1;\\n        \\n        return ans;\\n    }\\n    \\n    int maxLength(vector<string>& arr) {\\n        int ans = 0;\\n        for(int i=0; i<arr.size(); i++) {\\n            int freq[26] = {0};\\n            ans = max(ans, dfs(arr, i, freq));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1273162,
                "title": "python-backtracking-with-set",
                "content": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        charSet = [set(s) for s in arr if len(s) == len(set(s))] # obviate duplicates\\n\\n        def dfs(chars, i):\\n            if i == len(charSet):\\n                return len(chars)\\n            if not chars.intersection(charSet[i]): # disjoint\\n                return max(dfs(chars.union(charSet[i]), i + 1), # choose set[i]\\n                           dfs(chars, i + 1)) # not choose set[i]\\n            else:\\n                return dfs(chars, i + 1)\\n            \\n        return dfs(set(), 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        charSet = [set(s) for s in arr if len(s) == len(set(s))] # obviate duplicates\\n\\n        def dfs(chars, i):\\n            if i == len(charSet):\\n                return len(chars)\\n            if not chars.intersection(charSet[i]): # disjoint\\n                return max(dfs(chars.union(charSet[i]), i + 1), # choose set[i]\\n                           dfs(chars, i + 1)) # not choose set[i]\\n            else:\\n                return dfs(chars, i + 1)\\n            \\n        return dfs(set(), 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1269888,
                "title": "java-backtracking-solution",
                "content": "```\\nclass Solution {\\n    int count=0;\\n    public int maxLength(List<String> a1) {\\n        \\n        count=0;\\n        solve(a1,0,\"\");\\n        return count;\\n    }\\n    public void solve(List<String> s1,int index,String res)\\n    {\\n        if(index==s1.size())\\n        {\\n            if(checkIt(res)==true)\\n            {\\n                count=Math.max(count,res.length());\\n            }                        \\n            return;\\n        }        \\n        solve(s1,index+1,res);\\n        solve(s1,index+1,res+s1.get(index));\\n    }\\n    public boolean checkIt(String res)\\n    {\\n        int []count =new int[26];\\n        for(int i=0;i<res.length();i++)\\n        {\\n            char ch1=res.charAt(i);\\n            count[ch1-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(count[i]>1)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int count=0;\\n    public int maxLength(List<String> a1) {\\n        \\n        count=0;\\n        solve(a1,0,\"\");\\n        return count;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1186501,
                "title": "python-dfs",
                "content": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        self.max_l = 0\\n        \\n        self.dfs(arr, \\'\\', set(), 0)\\n        \\n        return self.max_l\\n    \\n    def dfs(self, arr, cur_s, visited, idx):\\n        if idx == len(arr):\\n            return \\n        \\n        for i in range(idx, len(arr)):\\n            if i in visited:\\n                continue\\n            if len(cur_s) + len(arr[i]) != len(set(cur_s + arr[i])):\\n                continue\\n            \\n            self.max_l = max(self.max_l, len(cur_s) + len(arr[i]))\\n            \\n            visited.add(i)\\n            self.dfs(arr, cur_s + arr[i], visited, i + 1)\\n            visited.remove(i)\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        self.max_l = 0\\n        \\n        self.dfs(arr, \\'\\', set(), 0)\\n        \\n        return self.max_l\\n    \\n    def dfs(self, arr, cur_s, visited, idx):\\n        if idx == len(arr):\\n            return \\n        \\n        for i in range(idx, len(arr)):\\n            if i in visited:\\n                continue\\n            if len(cur_s) + len(arr[i]) != len(set(cur_s + arr[i])):\\n                continue\\n            \\n            self.max_l = max(self.max_l, len(cur_s) + len(arr[i]))\\n            \\n            visited.add(i)\\n            self.dfs(arr, cur_s + arr[i], visited, i + 1)\\n            visited.remove(i)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1181254,
                "title": "python3-power-set-solution-beats-98",
                "content": "The idea is to generate a power set of input string array but allow only strings with unique characters in it. After that, it is pretty straightforward to find the longest string and return it\\'s length.\\n\\n```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        powerset = [\"\"]\\n        \\n        for word in arr:\\n            powerset += [subset + word for subset in powerset if self.hasUniqueChars(subset + word)]\\n            \\n        return len(max(powerset, key=len))\\n    \\n    def hasUniqueChars(self, word):\\n        return len(word) == len(set(word))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        powerset = [\"\"]\\n        \\n        for word in arr:\\n            powerset += [subset + word for subset in powerset if self.hasUniqueChars(subset + word)]\\n            \\n        return len(max(powerset, key=len))\\n    \\n    def hasUniqueChars(self, word):\\n        return len(word) == len(set(word))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138265,
                "title": "python-with-dp",
                "content": "based on lee215\\'s solution \\n```\\n    def maxLength_concat_str(self, arr: List[str]) -> int:\\n        ## like dynamic programmic, store previous values \\n        dp = [set()]\\n        for str_arr in arr:\\n            ## skip the str that have duplicate characters\\n            if len(set(str_arr)) < len(str_arr):\\n                continue\\n            ## convert str to set, to use python operator & and |\\n            str_arr = set(str_arr)\\n            for str_dp in dp[:]:\\n                ## we could have same strings appear together, skip them\\n                ## any common strings, skip them\\n                ## & Binary AND\\tOperator copies a bit to the result if it exists in both operands\\n                if str_arr & str_dp: \\n                    continue\\n                ## combint both the strings and append to dp\\n                ## | Binary OR\\tIt copies a bit if it exists in either operand.\\n                dp.append(str_arr | str_dp)\\n                print(dp)\\n        return max(len(str_dp) for str_dp in dp)\\n```\\n\\n",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\n    def maxLength_concat_str(self, arr: List[str]) -> int:\\n        ## like dynamic programmic, store previous values \\n        dp = [set()]\\n        for str_arr in arr:\\n            ## skip the str that have duplicate characters\\n            if len(set(str_arr)) < len(str_arr):\\n                continue\\n            ## convert str to set, to use python operator & and |\\n            str_arr = set(str_arr)\\n            for str_dp in dp[:]:\\n                ## we could have same strings appear together, skip them\\n                ## any common strings, skip them\\n                ## & Binary AND\\tOperator copies a bit to the result if it exists in both operands\\n                if str_arr & str_dp: \\n                    continue\\n                ## combint both the strings and append to dp\\n                ## | Binary OR\\tIt copies a bit if it exists in either operand.\\n                dp.append(str_arr | str_dp)\\n                print(dp)\\n        return max(len(str_dp) for str_dp in dp)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1099018,
                "title": "java-backtracking-faster-than-100-and-less-than-96-with-explanation",
                "content": "You can find explanation here: https://www.tipeca.com/learning/leetcode-1239-maximum-length-of-a-concatenated-string-with-unique-characters/\\n\\n```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        Str[] strs = new Str[arr.size()];\\n        for (int i = 0; i < strs.length; i++) {\\n            strs[i] = new Str(arr.get(i));\\n        }\\n        \\n        int max = 0;\\n        for (int i = 0; i < strs.length; i++) {\\n            max = Math.max(search(strs, i, 0), max);\\n        }\\n        return max;\\n    }\\n    \\n    private int search(Str[] str, int idx, int acc) {\\n        if (idx == str.length) return 0;\\n        if (!str[idx].usable || (acc & str[idx].key) != 0) return 0;\\n        int max = 0;\\n        int key = str[idx].key | acc;\\n        for (int i = idx + 1; i < str.length; i++) {\\n            max = Math.max(search(str, i, key), max);\\n        }\\n        return str[idx].len + max;\\n    }\\n    \\n    class Str {\\n        int key = 0;\\n        int len = 0;\\n        boolean usable = true;\\n        \\n        public Str (String s) {\\n            for (char c : s.toCharArray()) {\\n                int bit = (1 << (c - \\'a\\'));\\n                if ((bit & key) != 0) {\\n                    usable = false;\\n                    break;\\n                }\\n                key = key | (1 << (c - \\'a\\'));\\n            }\\n            len = s.length();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        Str[] strs = new Str[arr.size()];\\n        for (int i = 0; i < strs.length; i++) {\\n            strs[i] = new Str(arr.get(i));\\n        }\\n        \\n        int max = 0;\\n        for (int i = 0; i < strs.length; i++) {\\n            max = Math.max(search(strs, i, 0), max);\\n        }\\n        return max;\\n    }\\n    \\n    private int search(Str[] str, int idx, int acc) {\\n        if (idx == str.length) return 0;\\n        if (!str[idx].usable || (acc & str[idx].key) != 0) return 0;\\n        int max = 0;\\n        int key = str[idx].key | acc;\\n        for (int i = idx + 1; i < str.length; i++) {\\n            max = Math.max(search(str, i, key), max);\\n        }\\n        return str[idx].len + max;\\n    }\\n    \\n    class Str {\\n        int key = 0;\\n        int len = 0;\\n        boolean usable = true;\\n        \\n        public Str (String s) {\\n            for (char c : s.toCharArray()) {\\n                int bit = (1 << (c - \\'a\\'));\\n                if ((bit & key) != 0) {\\n                    usable = false;\\n                    break;\\n                }\\n                key = key | (1 << (c - \\'a\\'));\\n            }\\n            len = s.length();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1089007,
                "title": "pure-bit-manipulation-beats-93",
                "content": "\\n```\\n/**\\n * Assuming Integer a and b represent String S and P.\\n * a | b => join String S and P\\n * a & b => 0 means no duplicates between S and P, otherwise there are duplicates.\\n*/\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        return maxLen(arr, 0, 0);\\n    }\\n\\n    private int maxLen(List<String> arr, int i, int path) {\\n        if (i == arr.size()) return 0;\\n        int without_i = maxLen(arr, i + 1, path);\\n        String s = arr.get(i);\\n        int bits = str2bits(s.toCharArray());\\n        int with_i = (bits < 0 || (bits & path) > 0) ? 0 : maxLen(arr, i + 1, bits | path) + s.length();; \\n        return Math.max(without_i, with_i);\\n    }\\n\\n    private int str2bits(char[] a) {\\n        int n = 0;\\n        for (int i = 0; n >= 0 && i < a.length; i++) {\\n            int mask = 1 << (a[i] - \\'a\\');\\n            n = (n & mask) > 0 ? -1 : (n | mask);\\n        }\\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Assuming Integer a and b represent String S and P.\\n * a | b => join String S and P\\n * a & b => 0 means no duplicates between S and P, otherwise there are duplicates.\\n*/\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        return maxLen(arr, 0, 0);\\n    }\\n\\n    private int maxLen(List<String> arr, int i, int path) {\\n        if (i == arr.size()) return 0;\\n        int without_i = maxLen(arr, i + 1, path);\\n        String s = arr.get(i);\\n        int bits = str2bits(s.toCharArray());\\n        int with_i = (bits < 0 || (bits & path) > 0) ? 0 : maxLen(arr, i + 1, bits | path) + s.length();; \\n        return Math.max(without_i, with_i);\\n    }\\n\\n    private int str2bits(char[] a) {\\n        int n = 0;\\n        for (int i = 0; n >= 0 && i < a.length; i++) {\\n            int mask = 1 << (a[i] - \\'a\\');\\n            n = (n & mask) > 0 ? -1 : (n | mask);\\n        }\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1042827,
                "title": "c-backtracking-solution-using-hashset-functions-overlaps-unionwith-exceptwith",
                "content": "\\n\\n```\\npublic class Solution {\\n    \\n    int max = 0;\\n    \\n    public int MaxLength(IList<string> arr) {\\n        \\n        if(arr == null)            \\n            return 0;\\n        \\n        Backtrack(arr, new HashSet<char>(), 0);\\n        return max;\\n    }\\n    \\n    private void Backtrack(IList<string> arr, HashSet<char> letters, int start)\\n    {        \\n        max = Math.Max(max, letters.Count);\\n        if(start == arr.Count)\\n            return;\\n            \\n        for(int i = start; i < arr.Count; i++)\\n        {\\n            HashSet<char> temp = new HashSet<char>();\\n            temp.UnionWith(arr[i]);\\n                \\n            if(letters.Overlaps(arr[i]) || temp.Count != arr[i].Length)\\n                continue;\\n                        \\n            letters.UnionWith(arr[i]); \\n            Backtrack(arr, letters, i + 1);\\n            letters.ExceptWith(arr[i]);\\n             \\n        }\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    int max = 0;\\n    \\n    public int MaxLength(IList<string> arr) {\\n        \\n        if(arr == null)            \\n            return 0;\\n        \\n        Backtrack(arr, new HashSet<char>(), 0);\\n        return max;\\n    }\\n    \\n    private void Backtrack(IList<string> arr, HashSet<char> letters, int start)\\n    {        \\n        max = Math.Max(max, letters.Count);\\n        if(start == arr.Count)\\n            return;\\n            \\n        for(int i = start; i < arr.Count; i++)\\n        {\\n            HashSet<char> temp = new HashSet<char>();\\n            temp.UnionWith(arr[i]);\\n                \\n            if(letters.Overlaps(arr[i]) || temp.Count != arr[i].Length)\\n                continue;\\n                        \\n            letters.UnionWith(arr[i]); \\n            Backtrack(arr, letters, i + 1);\\n            letters.ExceptWith(arr[i]);\\n             \\n        }\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1042662,
                "title": "c-dfs-two-choices-select-skip",
                "content": "Jan. 30, 2021\\nIt is one of leetcode premium mock onsite algorithm. It is the second one. I do believe that it is important for me to write a working solution instead of thinking optimal solution in terms of time complexity. \\n\\nI will review my solution later. Stay tuned. \\n\\n```\\npublic class Solution {\\n    public int MaxLength(IList<string> arr) {\\n        if(arr == null || arr.Count == 0)\\n            return 0; \\n        \\n        var length = arr.Count; \\n        \\n        // Run DFS \\n        var maxLength = 0 ; \\n        var set = new HashSet<char>(); \\n        \\n        runDFS(arr, 0, set, ref maxLength ); \\n        \\n        return maxLength; \\n    }\\n    \\n    private void runDFS(IList<string> arr, int index, HashSet<char> set, ref int maxLength)\\n    {\\n        if(index >= arr.Count || set.Count == 26)\\n        {\\n            if(set.Count > maxLength)\\n                maxLength = set.Count; \\n            \\n            return; \\n        }\\n        \\n        var current = arr[index];\\n        var currentSet = new HashSet<char>(current);\\n        \\n        currentSet.UnionWith(set);\\n        if(currentSet.Count == current.Length + set.Count)\\n        {\\n            runDFS(arr, index, currentSet, ref maxLength);\\n        }\\n        \\n        // skip the current element\\n        runDFS(arr, index + 1, set, ref maxLength);        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaxLength(IList<string> arr) {\\n        if(arr == null || arr.Count == 0)\\n            return 0; \\n        \\n        var length = arr.Count; \\n        \\n        // Run DFS \\n        var maxLength = 0 ; \\n        var set = new HashSet<char>(); \\n        \\n        runDFS(arr, 0, set, ref maxLength ); \\n        \\n        return maxLength; \\n    }\\n    \\n    private void runDFS(IList<string> arr, int index, HashSet<char> set, ref int maxLength)\\n    {\\n        if(index >= arr.Count || set.Count == 26)\\n        {\\n            if(set.Count > maxLength)\\n                maxLength = set.Count; \\n            \\n            return; \\n        }\\n        \\n        var current = arr[index];\\n        var currentSet = new HashSet<char>(current);\\n        \\n        currentSet.UnionWith(set);\\n        if(currentSet.Count == current.Length + set.Count)\\n        {\\n            runDFS(arr, index, currentSet, ref maxLength);\\n        }\\n        \\n        // skip the current element\\n        runDFS(arr, index + 1, set, ref maxLength);        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1040284,
                "title": "c-solution-using-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxPossibleLen = 0;\\n    void checkCombination(vector<string> arr, int start, string &res) {\\n        if (res.length() > maxPossibleLen)\\n            maxPossibleLen = res.length();\\n        if (start == arr.size())\\n            return;\\n        for (int i = start; i < arr.size(); i++) {\\n            string temp = res + arr[i];\\n            bool mask[27] = {false};\\n            for (char c: res)\\n                mask[c-\\'a\\'] = true;\\n            bool unique_chars = true;\\n            for (char c: arr[i]) {\\n                if (mask[c-\\'a\\']) {\\n                    unique_chars = false;\\n                    break;\\n                }\\n                mask[c-\\'a\\'] = true;\\n            }\\n            if (unique_chars)\\n                checkCombination(arr, i + 1, temp);\\n        }\\n    }\\n    int maxLength(vector<string>& arr) {\\n        string res;\\n        checkCombination(arr, 0, res);\\n        return maxPossibleLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPossibleLen = 0;\\n    void checkCombination(vector<string> arr, int start, string &res) {\\n        if (res.length() > maxPossibleLen)\\n            maxPossibleLen = res.length();\\n        if (start == arr.size())\\n            return;\\n        for (int i = start; i < arr.size(); i++) {\\n            string temp = res + arr[i];\\n            bool mask[27] = {false};\\n            for (char c: res)\\n                mask[c-\\'a\\'] = true;\\n            bool unique_chars = true;\\n            for (char c: arr[i]) {\\n                if (mask[c-\\'a\\']) {\\n                    unique_chars = false;\\n                    break;\\n                }\\n                mask[c-\\'a\\'] = true;\\n            }\\n            if (unique_chars)\\n                checkCombination(arr, i + 1, temp);\\n        }\\n    }\\n    int maxLength(vector<string>& arr) {\\n        string res;\\n        checkCombination(arr, 0, res);\\n        return maxPossibleLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030178,
                "title": "super-simple-code-for-backtracking-python",
                "content": "Super simple code for backtracking.\\n\\n    def maxLength(self, arr: List[str]) -> int:\\n        self.ans = 0\\n        self.helper(arr, \\'\\', 0)\\n        return self.ans\\n    \\n    def helper(self, arr, comb, start):\\n        if len(set(list(comb))) == len(comb): # or len(set(comb)) == len(comb)\\n            self.ans = max(self.ans, len(comb))\\n        else: # has duplicates\\n            return\\n        \\n        for i in range(start, len(arr)):\\n            self.helper(arr, comb + arr[i], i + 1)\\n",
                "solutionTags": [],
                "code": "Super simple code for backtracking.\\n\\n    def maxLength(self, arr: List[str]) -> int:\\n        self.ans = 0\\n        self.helper(arr, \\'\\', 0)\\n        return self.ans\\n    \\n    def helper(self, arr, comb, start):\\n        if len(set(list(comb))) == len(comb): # or len(set(comb)) == len(comb)\\n            self.ans = max(self.ans, len(comb))\\n        else: # has duplicates\\n            return\\n        \\n        for i in range(start, len(arr)):\\n            self.helper(arr, comb + arr[i], i + 1)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 881754,
                "title": "just-a-modified-subset-problem",
                "content": "So my first intuition was to generate all the possible subsets of the given array and then check for the validity mentioned in the question. \\nMeanwhile when i am checking the validity the maxlength is also updated.\\n\\nThis solution is quite easy to understand works like charm.\\n\\n***Please upvote if found helpful***\\n```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        m=0\\n        \\n        def ok(curr):   # checks the validity of the generated subset and updates max length of unique word\\n            nonlocal m\\n            s=[i for i in \"\".join(i for i in curr)]\\n            if len(set(s))==len(s):\\n                m=max(m,len(s))\\n                \\n        def fun(idx,arr,curr):  # generates subsets through recursion\\n            ok(curr.copy())\\n            for i in range(idx,len(arr)):\\n                curr.append(arr[i])\\n                fun(i+1,arr,curr)\\n                curr.pop()        \\n        fun(0,arr,[])\\n        return m\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        m=0\\n        \\n        def ok(curr):   # checks the validity of the generated subset and updates max length of unique word\\n            nonlocal m\\n            s=[i for i in \"\".join(i for i in curr)]\\n            if len(set(s))==len(s):\\n                m=max(m,len(s))\\n                \\n        def fun(idx,arr,curr):  # generates subsets through recursion\\n            ok(curr.copy())\\n            for i in range(idx,len(arr)):\\n                curr.append(arr[i])\\n                fun(i+1,arr,curr)\\n                curr.pop()        \\n        fun(0,arr,[])\\n        return m\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 872596,
                "title": "python-3-3-8-backtracking-set-union-walrus-operator-explanation",
                "content": "I think it\\'s totally reasonable if you don\\'t like or not familiar with Walrus operator (`:=`), but it does help to make the code shorter. Also, it\\'s not too hard to understand.\\n\\n### Explanation\\n- Basic idea is to turn `arr` to `[(set(word), len(word))]` if word has no repeat letter\\n- Then we can use union (`&`) operation to check whether length of set after union is same as the sum of two size\\n\\t- `if (union_len:=len(union:=arr[i][0] | cur_s)) == arr[i][1] + cur_l]`\\n\\t- `if len(arr[i][0] | cur_s) == arr[i][1] + cur_l` same as above\\n- Due to the small data sacle (max length of `arr` is 16), use backtracking to try out all possbilities\\n- Maintain a maximum length with `ans`\\n### Implementation\\n```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        arr = [(s, l) for word in arr if (l:=len(s:=set(word))) == len(word)]\\n        ans, n = 0, len(arr)\\n        def dfs(arr, cur_s, cur_l, idx):\\n            nonlocal ans, n\\n            ans = max(ans, cur_l)\\n            if idx == n: return \\n            [dfs(arr, union, union_len, i+1) for i in range(idx, n) if (union_len:=len(union:=arr[i][0] | cur_s)) == arr[i][1] + cur_l]\\n        dfs(arr, set(), 0, 0)                    \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        arr = [(s, l) for word in arr if (l:=len(s:=set(word))) == len(word)]\\n        ans, n = 0, len(arr)\\n        def dfs(arr, cur_s, cur_l, idx):\\n            nonlocal ans, n\\n            ans = max(ans, cur_l)\\n            if idx == n: return \\n            [dfs(arr, union, union_len, i+1) for i in range(idx, n) if (union_len:=len(union:=arr[i][0] | cur_s)) == arr[i][1] + cur_l]\\n        dfs(arr, set(), 0, 0)                    \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 859260,
                "title": "java-set-backtracking",
                "content": "Use a set to maintain uniqueness.\\nAdd characters of each list element into the set if uniqueness is gauranteed and then recurse to add the subsequent list elements.\\nIf uniqueness is not maintained then don\\'t recurse.\\nBacktrack to see all paths.\\n\\n```\\nclass Solution {\\n    \\n    int answer = 0;\\n    \\n    public int maxLength(List<String> arr) {\\n        maxPossibleLength(arr, new HashSet<>(), 0);\\n        return answer;\\n    }\\n    \\n    public void maxPossibleLength(List<String> arr, Set<Character> set, int start) {\\n\\n        answer = Math.max(answer, set.size());\\n        \\n        for(int i=start; i<arr.size(); i++) {\\n            \\n            boolean duplicatePresent = false;\\n            int clearTill = arr.get(i).length() - 1;\\n            \\n            for(int j=0; j<arr.get(i).length(); j++) {\\n                if(!set.contains(arr.get(i).charAt(j))) {\\n                    set.add(arr.get(i).charAt(j));\\n                } else {\\n                    duplicatePresent = true;\\n                    clearTill = j-1;\\n                    break;\\n                }\\n            }\\n            \\n            if(!duplicatePresent) {\\n                maxPossibleLength(arr, set, i+1);\\n            }\\n            \\n            for(int j=0; j<=clearTill; j++) {\\n                set.remove(arr.get(i).charAt(j));\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int answer = 0;\\n    \\n    public int maxLength(List<String> arr) {\\n        maxPossibleLength(arr, new HashSet<>(), 0);\\n        return answer;\\n    }\\n    \\n    public void maxPossibleLength(List<String> arr, Set<Character> set, int start) {\\n\\n        answer = Math.max(answer, set.size());\\n        \\n        for(int i=start; i<arr.size(); i++) {\\n            \\n            boolean duplicatePresent = false;\\n            int clearTill = arr.get(i).length() - 1;\\n            \\n            for(int j=0; j<arr.get(i).length(); j++) {\\n                if(!set.contains(arr.get(i).charAt(j))) {\\n                    set.add(arr.get(i).charAt(j));\\n                } else {\\n                    duplicatePresent = true;\\n                    clearTill = j-1;\\n                    break;\\n                }\\n            }\\n            \\n            if(!duplicatePresent) {\\n                maxPossibleLength(arr, set, i+1);\\n            }\\n            \\n            for(int j=0; j<=clearTill; j++) {\\n                set.remove(arr.get(i).charAt(j));\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 646024,
                "title": "java-straightforward-approach-power-set",
                "content": "```\\n\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        \\n        int total= 1 << arr.size(), max_len= 0;\\n        \\n        for(int i = 0; i < total; i++) {\\n            \\n            HashSet<Character> set= new HashSet<>();\\n            int curr_len= 0;\\n            \\n            for(int j = 0; j < arr.size(); j++) {\\n                \\n                boolean flag= false;\\n                \\n                if((i & (1 << j)) > 0) {\\n                    \\n                    if(curr_len + arr.get(j).length() > 26)\\n                        continue;\\n                    \\n                    for(int k = 0; k < arr.get(j).length(); k++) {\\n                        \\n                        if(set.contains(arr.get(j).charAt(k))) {\\n                            flag= true;\\n                            break;\\n                        }\\n                        set.add(arr.get(j).charAt(k));\\n                        \\n                    }\\n                    \\n                    if(!flag) {\\n                        curr_len += arr.get(j).length();\\n                        max_len= Math.max(curr_len, max_len);\\n                    }\\n                    if(max_len == 26)\\n                        return max_len;\\n                }\\n                \\n            }\\n        }\\n        \\n        return max_len;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        \\n        int total= 1 << arr.size(), max_len= 0;\\n        \\n        for(int i = 0; i < total; i++) {\\n            \\n            HashSet<Character> set= new HashSet<>();\\n            int curr_len= 0;\\n            \\n            for(int j = 0; j < arr.size(); j++) {\\n                \\n                boolean flag= false;\\n                \\n                if((i & (1 << j)) > 0) {\\n                    \\n                    if(curr_len + arr.get(j).length() > 26)\\n                        continue;\\n                    \\n                    for(int k = 0; k < arr.get(j).length(); k++) {\\n                        \\n                        if(set.contains(arr.get(j).charAt(k))) {\\n                            flag= true;\\n                            break;\\n                        }\\n                        set.add(arr.get(j).charAt(k));\\n                        \\n                    }\\n                    \\n                    if(!flag) {\\n                        curr_len += arr.get(j).length();\\n                        max_len= Math.max(curr_len, max_len);\\n                    }\\n                    if(max_len == 26)\\n                        return max_len;\\n                }\\n                \\n            }\\n        }\\n        \\n        return max_len;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 638320,
                "title": "java-easy-to-understand-dfs-solution",
                "content": "```\\nclass Solution {\\n    private int ans = 0;\\n    \\n    public int maxLength(List<String> arr) {\\n        Set<Character> visited = new HashSet<>();\\n        for (int i = 0; i < arr.size(); i++) {\\n            dfs(i, arr, visited);\\n            visited.clear();\\n        }\\n        return ans;\\n    }\\n    \\n    private void dfs(int idx, List<String> arr, Set<Character> visited) {\\n        String word = arr.get(idx);\\n        Set<Character> wordSet = new HashSet<>();\\n        for (char c : word.toCharArray()) {\\n            if (visited.contains(c) || wordSet.contains(c)) {\\n                ans = Math.max(ans, visited.size());\\n                return;\\n            } else {\\n                wordSet.add(c);\\n            }\\n        }\\n        visited.addAll(wordSet);\\n        if (idx == arr.size() - 1) {\\n            ans = Math.max(ans, visited.size());\\n        } else {\\n            for (int i = idx + 1; i < arr.size(); i++) {\\n                Set<Character> copy_visited = new HashSet<>(visited);\\n                dfs(i, arr, copy_visited);\\n            } \\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int ans = 0;\\n    \\n    public int maxLength(List<String> arr) {\\n        Set<Character> visited = new HashSet<>();\\n        for (int i = 0; i < arr.size(); i++) {\\n            dfs(i, arr, visited);\\n            visited.clear();\\n        }\\n        return ans;\\n    }\\n    \\n    private void dfs(int idx, List<String> arr, Set<Character> visited) {\\n        String word = arr.get(idx);\\n        Set<Character> wordSet = new HashSet<>();\\n        for (char c : word.toCharArray()) {\\n            if (visited.contains(c) || wordSet.contains(c)) {\\n                ans = Math.max(ans, visited.size());\\n                return;\\n            } else {\\n                wordSet.add(c);\\n            }\\n        }\\n        visited.addAll(wordSet);\\n        if (idx == arr.size() - 1) {\\n            ans = Math.max(ans, visited.size());\\n        } else {\\n            for (int i = idx + 1; i < arr.size(); i++) {\\n                Set<Character> copy_visited = new HashSet<>(visited);\\n                dfs(i, arr, copy_visited);\\n            } \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 619689,
                "title": "c-solution-using-dfs-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        if (arr.empty()) return 0;\\n        if (arr.size() == 1) return arr[0].size();\\n        int res = 0;\\n        bitset<26> visited(0);\\n        DFS(arr, 0, visited, res);\\n        return res;\\n    }\\nprivate:\\n    void DFS(vector<string>& arr, int start, bitset<26>& visited, int &res) {\\n        for (int i = start; i < arr.size(); ++i) {\\n            bitset<26> tmp = visited;\\n            if (isRepeat(tmp, arr[i])) continue;\\n            res = max(res, (int)tmp.count());\\n            DFS(arr, i + 1, tmp, res);\\n        }\\n    }\\n    bool isRepeat(bitset<26> &visited, string &str) {\\n        for (auto c : str) {\\n            if (visited[c - \\'a\\']) return true;\\n            visited[c - \\'a\\'] = 1;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        if (arr.empty()) return 0;\\n        if (arr.size() == 1) return arr[0].size();\\n        int res = 0;\\n        bitset<26> visited(0);\\n        DFS(arr, 0, visited, res);\\n        return res;\\n    }\\nprivate:\\n    void DFS(vector<string>& arr, int start, bitset<26>& visited, int &res) {\\n        for (int i = start; i < arr.size(); ++i) {\\n            bitset<26> tmp = visited;\\n            if (isRepeat(tmp, arr[i])) continue;\\n            res = max(res, (int)tmp.count());\\n            DFS(arr, i + 1, tmp, res);\\n        }\\n    }\\n    bool isRepeat(bitset<26> &visited, string &str) {\\n        for (auto c : str) {\\n            if (visited[c - \\'a\\']) return true;\\n            visited[c - \\'a\\'] = 1;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 599094,
                "title": "java-backtrack-solution-with-comments",
                "content": "\\tclass Solution {\\n\\t\\tprivate int ans = 0;\\n\\n\\t\\tpublic int maxLength(List<String> arr){\\n\\t\\t\\t// start from each word in arr\\n\\t\\t\\tfor(int i = 0; i < arr.size(); i++)\\n\\t\\t\\t\\thelper(arr, i, 0, new HashMap<>());\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\n\\t\\tprivate void helper(List<String> arr, int index, int res, Map<Character, Integer> used){\\n\\n\\t\\t\\tString cur = arr.get(index);\\n\\t\\t\\t// put all the character in a hashmap\\n\\t\\t\\tfor(int i = 0; i < cur.length(); i++){\\n\\t\\t\\t\\tused.put(cur.charAt(i), used.getOrDefault(cur.charAt(i), 0) + 1);\\n\\t\\t\\t}\\n\\t\\t\\t// if value of certain character > 1, means duplicate\\n\\t\\t\\tfor(int i: used.values()){\\n\\t\\t\\t\\tif(i > 1)\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// update result\\n\\t\\t\\tres += cur.length();\\n\\t\\t\\tans = Math.max(ans, res);\\n\\n\\t\\t\\tfor(int i = index + 1; i < arr.size(); i++){\\n\\t\\t\\t\\thelper(arr, i, res, used);\\n\\t\\t\\t\\t// backtrack the hashmap\\n\\t\\t\\t\\tfor(int j = arr.get(i).length() - 1; j >= 0; j--){\\n\\t\\t\\t\\t\\tused.put(arr.get(i).charAt(j), used.get(arr.get(i).charAt(j)) - 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "class Solution {\\n\\t\\tprivate int ans = 0;\\n\\n\\t\\tpublic int maxLength(List<String> arr){\\n\\t\\t\\t// start from each word in arr\\n\\t\\t\\tfor(int i = 0; i < arr.size(); i++)\\n\\t\\t\\t\\thelper(arr, i, 0, new HashMap<>());\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 590086,
                "title": "javascript-sets-solution",
                "content": "```js\\nconst maxLength = function(strings) {\\n  let max = 0;\\n  let sets = [new Set(\\'\\')];\\n  \\n  strings.forEach(string => {\\n    const current = new Set(string);\\n    if (string.length === current.size)  {\\n    // if the string itself has duplicates, skip\\n      \\n      sets.forEach(set => {\\n        const intersection = [...set].filter(c => current.has(c));\\n        // for currently valid string sets, if the current string does not overlap, push it to the sets\\n        if (intersection.length === 0) {\\n          const newSet = new Set([...current, ...set]);\\n          sets.push(newSet);\\n          max = Math.max(newSet.size, max); \\n        }\\n      });\\n    }\\n  });\\n  \\n  return max;\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nconst maxLength = function(strings) {\\n  let max = 0;\\n  let sets = [new Set(\\'\\')];\\n  \\n  strings.forEach(string => {\\n    const current = new Set(string);\\n    if (string.length === current.size)  {\\n    // if the string itself has duplicates, skip\\n      \\n      sets.forEach(set => {\\n        const intersection = [...set].filter(c => current.has(c));\\n        // for currently valid string sets, if the current string does not overlap, push it to the sets\\n        if (intersection.length === 0) {\\n          const newSet = new Set([...current, ...set]);\\n          sets.push(newSet);\\n          max = Math.max(newSet.size, max); \\n        }\\n      });\\n    }\\n  });\\n  \\n  return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 566389,
                "title": "commented-python-3-solution",
                "content": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        result = [float(\\'-inf\\')]\\n    \\n        self.unique_char(\"\", arr, 0, result)\\n\\n        if not result[0] == float(\\'-inf\\'):\\n            return result[0]\\n        return 0\\n    \\n    \\n    def unique_char(self, cur, arr, index, result):\\n        # End of the array\\n        if index == len(arr):\\n            return\\n\\n        # Iteracting from the current word to the end of the array\\n        for index in range(index,len(arr)):\\n\\n            #If my current word + next word have all unique characters\\n            if len(set(cur + arr[index])) == len(list(cur + arr[index])):    \\n                #I\\'m gonna compare the actual lenth with the previous max\\n                result[0] = max(result[0],len(cur + arr[index]))\\n                # Make a new call with concatenate words\\n                self.unique_char(cur + arr[index], arr, index + 1,result)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        result = [float(\\'-inf\\')]\\n    \\n        self.unique_char(\"\", arr, 0, result)\\n\\n        if not result[0] == float(\\'-inf\\'):\\n            return result[0]\\n        return 0\\n    \\n    \\n    def unique_char(self, cur, arr, index, result):\\n        # End of the array\\n        if index == len(arr):\\n            return\\n\\n        # Iteracting from the current word to the end of the array\\n        for index in range(index,len(arr)):\\n\\n            #If my current word + next word have all unique characters\\n            if len(set(cur + arr[index])) == len(list(cur + arr[index])):    \\n                #I\\'m gonna compare the actual lenth with the previous max\\n                result[0] = max(result[0],len(cur + arr[index]))\\n                # Make a new call with concatenate words\\n                self.unique_char(cur + arr[index], arr, index + 1,result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533011,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int res = 0;\\n        string s = \"\";\\n        for(int i = 0; i < arr.size(); i++)\\n           res = max(res ,backtrack(arr, s, i));\\n        \\n        return res;\\n        \\n    }\\n    \\n    int backtrack(vector<string>& arr, string str,  int start){\\n        \\n        unordered_set<char>s(str.begin(), str.end());\\n        if (s.size() != ((int)str.length())) \\n            return 0;\\n        \\n        int ret = str.length();\\n        for (int i = start; i < arr.size(); i++)\\n            ret = max(ret, backtrack(arr, str+arr[i], i+1));\\n\\n        return ret;\\n    }\\n    \\n};\\n```\\n------------------------------------------------------\\n\\n```\\nclass Solution {\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        vector<bitset<26>> bits; \\n        for (auto s : arr) {\\n            bitset<26> a;\\n            for (char c : s) a.set(c - \\'a\\');\\n            if (a.count() == s.size()) bits.push_back(a);\\n        }\\n        return maxLength(bits, bitset<26>(), 0);\\n    }\\n    \\n    int maxLength(vector<bitset<26>>& bits, bitset<26> bs, int index) {\\n        int res = bs.count();\\n        for (int i = index; i < bits.size(); i++) \\n            if ((bits[i] & bs).none()) res = max(res, maxLength(bits, bs | bits[i], i+1));\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int res = 0;\\n        string s = \"\";\\n        for(int i = 0; i < arr.size(); i++)\\n           res = max(res ,backtrack(arr, s, i));\\n        \\n        return res;\\n        \\n    }\\n    \\n    int backtrack(vector<string>& arr, string str,  int start){\\n        \\n        unordered_set<char>s(str.begin(), str.end());\\n        if (s.size() != ((int)str.length())) \\n            return 0;\\n        \\n        int ret = str.length();\\n        for (int i = start; i < arr.size(); i++)\\n            ret = max(ret, backtrack(arr, str+arr[i], i+1));\\n\\n        return ret;\\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        vector<bitset<26>> bits; \\n        for (auto s : arr) {\\n            bitset<26> a;\\n            for (char c : s) a.set(c - \\'a\\');\\n            if (a.count() == s.size()) bits.push_back(a);\\n        }\\n        return maxLength(bits, bitset<26>(), 0);\\n    }\\n    \\n    int maxLength(vector<bitset<26>>& bits, bitset<26> bs, int index) {\\n        int res = bs.count();\\n        for (int i = index; i < bits.size(); i++) \\n            if ((bits[i] & bs).none()) res = max(res, maxLength(bits, bs | bits[i], i+1));\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 507635,
                "title": "easy-java-backtracking-solution",
                "content": "```\\nclass Solution {\\n    int max = 0;\\n    public int maxLength(List<String> arr) {\\n        if(arr == null || arr.size() == 0) {\\n            return 0;\\n        }\\n        backtrack(arr, 0, \"\");\\n        return max;\\n    }\\n    void backtrack(List<String> arr, int index, String current){\\n        max = Math.max(max, current.length());\\n        if(index == arr.size()) return;\\n        \\n        for(int i = index; i< arr.size();i++){\\n            if(hasNoDuplicates(current+arr.get(i))){\\n                backtrack(arr,i,current+arr.get(i));\\n            }\\n        }\\n    }\\n    /*Function to check if the string has dupliacte characters */\\n    boolean hasNoDuplicates(String s){\\n        boolean[] map = new boolean[26];\\n        for(char ch:s.toCharArray()){\\n            if(map[ch-\\'a\\']){\\n                return false;\\n            }\\n            map[ch-\\'a\\'] = true;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int max = 0;\\n    public int maxLength(List<String> arr) {\\n        if(arr == null || arr.size() == 0) {\\n            return 0;\\n        }\\n        backtrack(arr, 0, \"\");\\n        return max;\\n    }\\n    void backtrack(List<String> arr, int index, String current){\\n        max = Math.max(max, current.length());\\n        if(index == arr.size()) return;\\n        \\n        for(int i = index; i< arr.size();i++){\\n            if(hasNoDuplicates(current+arr.get(i))){\\n                backtrack(arr,i,current+arr.get(i));\\n            }\\n        }\\n    }\\n    /*Function to check if the string has dupliacte characters */\\n    boolean hasNoDuplicates(String s){\\n        boolean[] map = new boolean[26];\\n        for(char ch:s.toCharArray()){\\n            if(map[ch-\\'a\\']){\\n                return false;\\n            }\\n            map[ch-\\'a\\'] = true;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 473402,
                "title": "c-4ms-dfs-solution-with-bit-manipulation",
                "content": "\\tclass Solution {\\n\\t\\tprivate:\\n\\t\\tint ans=0;\\n\\tpublic:\\n\\t\\tvoid dfs(int index,int mask,vector<int>& cnt){\\n\\t\\t\\tans=max(ans,__builtin_popcount(mask));\\n\\t\\t\\tfor(int i=index;i<cnt.size();i++){\\n\\t\\t\\t\\tif((cnt[i]&mask)==0){//if there is no duplicate character\\n\\t\\t\\t\\t\\tdfs(i+1,cnt[i]|mask,cnt);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint maxLength(vector<string>& arr) {\\n\\t\\t\\tvector<int> cnt;\\n\\t\\t\\tfor(auto x:arr){\\n\\t\\t\\t\\tint mask=0;\\n\\t\\t\\t\\tfor(auto c:x){\\n\\t\\t\\t\\t\\tmask|=2<<(c-\\'a\\');//change the position of c-\\'a\\' to 1\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint len=__builtin_popcount(mask);//count number of one bit in mask\\n\\t\\t\\t\\tif(len!=x.size()) continue;//if the string itself has repeated characters, skip\\n\\t\\t\\t\\tcnt.push_back(mask);//push all available string into cnt\\n\\t\\t\\t}\\n\\t\\t\\tdfs(0,0,cnt);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\t\\tprivate:\\n\\t\\tint ans=0;\\n\\tpublic:\\n\\t\\tvoid dfs(int index,int mask,vector<int>& cnt){\\n\\t\\t\\tans=max(ans,__builtin_popcount(mask));\\n\\t\\t\\tfor(int i=index;i<cnt.size();i++){\\n\\t\\t\\t\\tif((cnt[i]&mask)==0){//if there is no duplicate character\\n\\t\\t\\t\\t\\tdfs(i+1,cnt[i]|mask,cnt);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 439990,
                "title": "python-beat-75-100ms-solution",
                "content": "```\\ndef maxLength(arr):\\n\\tlst, m = [\"\"], 0\\n\\tfor s in arr:\\n\\t\\tfor i in range(len(lst)):\\n\\t\\t\\tt = s + lst[i]\\n\\t\\t\\tl = len(t)\\n\\t\\t\\tif l == len(set(t)):\\n\\t\\t\\t\\tlst.append(t)\\n\\t\\t\\t\\tm = max(m, l)\\n\\treturn m\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxLength(arr):\\n\\tlst, m = [\"\"], 0\\n\\tfor s in arr:\\n\\t\\tfor i in range(len(lst)):\\n\\t\\t\\tt = s + lst[i]\\n\\t\\t\\tl = len(t)\\n\\t\\t\\tif l == len(set(t)):\\n\\t\\t\\t\\tlst.append(t)\\n\\t\\t\\t\\tm = max(m, l)\\n\\treturn m\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 432902,
                "title": "clean-backtracking-solution-in-java-using-stringbuilder-apis",
                "content": "```\\n\\tprivate int maxLen;\\n    private boolean isUniq(String s) {\\n        HashSet<String> set = new HashSet<>();\\n        for (char c : s.toCharArray()) {\\n            if (set.contains(String.valueOf(c)))\\n                return false;\\n            set.add(String.valueOf(c));\\n        }\\n        return true;\\n    }\\n    private void explore(List<String> arr, StringBuilder sb, int idx) {\\n        int len = sb.length();\\n        maxLen = Math.max(maxLen, len);\\n        if (idx == arr.size())\\n            return;\\n        for (int i = idx; i < arr.size(); i++) {\\n            sb.append(arr.get(i));\\n            if (isUniq(sb.toString())) {\\n                explore(arr, sb, i + 1);\\n            }\\n            sb.setLength(len);\\n        }\\n    }\\n    public int maxLength(List<String> arr) {\\n        maxLen = Integer.MIN_VALUE;\\n        explore(arr, new StringBuilder(), 0);\\n        return maxLen == Integer.MIN_VALUE? 0 : maxLen;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tprivate int maxLen;\\n    private boolean isUniq(String s) {\\n        HashSet<String> set = new HashSet<>();\\n        for (char c : s.toCharArray()) {\\n            if (set.contains(String.valueOf(c)))\\n                return false;\\n            set.add(String.valueOf(c));\\n        }\\n        return true;\\n    }\\n    private void explore(List<String> arr, StringBuilder sb, int idx) {\\n        int len = sb.length();\\n        maxLen = Math.max(maxLen, len);\\n        if (idx == arr.size())\\n            return;\\n        for (int i = idx; i < arr.size(); i++) {\\n            sb.append(arr.get(i));\\n            if (isUniq(sb.toString())) {\\n                explore(arr, sb, i + 1);\\n            }\\n            sb.setLength(len);\\n        }\\n    }\\n    public int maxLength(List<String> arr) {\\n        maxLen = Integer.MIN_VALUE;\\n        explore(arr, new StringBuilder(), 0);\\n        return maxLen == Integer.MIN_VALUE? 0 : maxLen;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 421705,
                "title": "python-dfs-dp-bits",
                "content": "```\\n    def maxLength(self, arr: List[str]) -> int:\\n        if not arr: return 0\\n        end_state = (1 << 27) - 1\\n        def get_state(w):\\n            state = 0\\n            for c in w:\\n                idx = ord(c) - ord(\\'a\\')\\n                if state & 1 << idx != 0:\\n                    return end_state\\n                state = state | 1 << idx\\n            return state\\n        states = [get_state(w) for w in arr]\\n\\n\\n        memo = dict()\\n        def recur(i, state):\\n            if state & states[i] != 0: return 0\\n            elif states[i] == end_state: return 0\\n            if (i, state) in memo: return memo[i, state]\\n\\n            state = state | states[i]\\n            if i != len(arr) - 1:\\n                max_value = max(recur(j, state) for j in range(i + 1, len(arr)))\\n            else: max_value = 0\\n            return max_value + len(arr[i])\\n        return max(recur(i, 0) for i in range(len(arr)))\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxLength(self, arr: List[str]) -> int:\\n        if not arr: return 0\\n        end_state = (1 << 27) - 1\\n        def get_state(w):\\n            state = 0\\n            for c in w:\\n                idx = ord(c) - ord(\\'a\\')\\n                if state & 1 << idx != 0:\\n                    return end_state\\n                state = state | 1 << idx\\n            return state\\n        states = [get_state(w) for w in arr]\\n\\n\\n        memo = dict()\\n        def recur(i, state):\\n            if state & states[i] != 0: return 0\\n            elif states[i] == end_state: return 0\\n            if (i, state) in memo: return memo[i, state]\\n\\n            state = state | states[i]\\n            if i != len(arr) - 1:\\n                max_value = max(recur(j, state) for j in range(i + 1, len(arr)))\\n            else: max_value = 0\\n            return max_value + len(arr[i])\\n        return max(recur(i, 0) for i in range(len(arr)))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 416367,
                "title": "c-a-solution-with-readable-code-using-dfs",
                "content": "Oct. 25, 2019\\nIt is the algorithm which can be solved using depth first search. I like to practice and also make the code easy to write and readable. \\n\\nHere are highlights:\\n1. Design depth first search and recursive function with four arguments;\\n2. default empty string is considered as a unique string with my defined isUnique function;\\n3. Depth first search algorithm is to go through all possible paths starting from a list from 0 to length - 1; \\n4. isUnique function is implemented to compare a hashSet\\'s count to string\\'s length. \\n\\n**Follow up**\\nI did not come out the solution in weekly contest 160 on Oct. 26, 2019. It is a simple brute force DFS solution. I will look into how to improve performance on weekly contest. \\n\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1239_maximujm_length\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n        }\\n\\n        /// <summary>\\n        /// Oct. 29, 2019\\n        /// study code\\n        /// 1239 Maximum length of concatenated string with unique characters\\n        /// My ideal solution is to write a DFS solution which can easily be understandable, \\n        /// and also it can be written in less than 15 minutes. \\n        /// </summary>\\n        /// <param name=\"arr\"></param>\\n        /// <returns></returns>\\n        public int MaxLength(IList<string> arr)\\n        {\\n            var maxLength = 0;\\n\\n            runDFS(arr, ref maxLength, 0, \"\");\\n\\n            return maxLength; \\n        }\\n\\n        private static void runDFS(IList<string> array, ref int maxLength, int index, string path)\\n        {\\n            if (!isUnique(path))\\n            {\\n                return;\\n            }\\n\\n            var current = path.Length;\\n            maxLength = current > maxLength ? current : maxLength;\\n\\n            for (int i = index; i < array.Count; i++)\\n            {\\n                runDFS(array, ref maxLength, i + 1, path + array[i]);\\n            }\\n        }\\n\\n        private static bool isUnique(string path)\\n        {\\n            var hashSet = new HashSet<char>(path);\\n            return path.Length == hashSet.Count(); \\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1239_maximujm_length\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n        }\\n\\n        /// <summary>\\n        /// Oct. 29, 2019\\n        /// study code\\n        /// 1239 Maximum length of concatenated string with unique characters\\n        /// My ideal solution is to write a DFS solution which can easily be understandable, \\n        /// and also it can be written in less than 15 minutes. \\n        /// </summary>\\n        /// <param name=\"arr\"></param>\\n        /// <returns></returns>\\n        public int MaxLength(IList<string> arr)\\n        {\\n            var maxLength = 0;\\n\\n            runDFS(arr, ref maxLength, 0, \"\");\\n\\n            return maxLength; \\n        }\\n\\n        private static void runDFS(IList<string> array, ref int maxLength, int index, string path)\\n        {\\n            if (!isUnique(path))\\n            {\\n                return;\\n            }\\n\\n            var current = path.Length;\\n            maxLength = current > maxLength ? current : maxLength;\\n\\n            for (int i = index; i < array.Count; i++)\\n            {\\n                runDFS(array, ref maxLength, i + 1, path + array[i]);\\n            }\\n        }\\n\\n        private static bool isUnique(string path)\\n        {\\n            var hashSet = new HashSet<char>(path);\\n            return path.Length == hashSet.Count(); \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 415536,
                "title": "python-backtracking",
                "content": "```python\\ndef maxLength(self, arr: List[str]) -> int:\\n        # time complexity 2 ^ n\\n        # n is the length of arr\\n        # find all the subsets that meet the requirements, i.e. no common characters\\n        # then return the max length\\n        \\n        # back tracking\\n        # keep the curr concatenated string\\n        def backTrack(i, curr):\\n            if i == len(arr):\\n                self.res = max(self.res, len(curr))\\n                return\\n            if len(set(arr[i])) == len(arr[i]):\\n                if all(c not in curr for c in arr[i]):\\n                    backTrack(i + 1, curr + arr[i])\\n                \\n            backTrack(i + 1, curr)\\n        \\n        self.res = 0\\n        backTrack(0, \\'\\')\\n        return self.res",
                "solutionTags": [],
                "code": "```python\\ndef maxLength(self, arr: List[str]) -> int:\\n        # time complexity 2 ^ n\\n        # n is the length of arr\\n        # find all the subsets that meet the requirements, i.e. no common characters\\n        # then return the max length\\n        \\n        # back tracking\\n        # keep the curr concatenated string\\n        def backTrack(i, curr):\\n            if i == len(arr):\\n                self.res = max(self.res, len(curr))\\n                return\\n            if len(set(arr[i])) == len(arr[i]):\\n                if all(c not in curr for c in arr[i]):\\n                    backTrack(i + 1, curr + arr[i])\\n                \\n            backTrack(i + 1, curr)\\n        \\n        self.res = 0\\n        backTrack(0, \\'\\')\\n        return self.res",
                "codeTag": "Python3"
            },
            {
                "id": 414659,
                "title": "bit-mask-dfs-dp-solutions",
                "content": "\\'\\'\\'\\nclass Solution:\\n\\n    # Solution 1 dp\\n    def maxLength(self, arr: List[str]) -> int:\\n        dp=collections.defaultdict(int)\\n        dp[\"\"]=0\\n        for word in arr:\\n            for word2 in list(dp.keys()):\\n                if len(word)!=len(set(word)): break\\n                if len(set(word+word2))==len(word)+len(word2):\\n                    dp[word+word2]=max(dp[word+word2],len(word)+len(word2))\\n        return max(dp.values())\\n    \\n    # Solution 2 bit mask + dfs\\n    def maxLength(self, words) -> int:\\n        memo={}\\n        for word in words:\\n            if len(set(word))!=len(word):\\n                continue\\n            mask=0\\n            for c in word:\\n                mask|=1<<(ord(c)-97)\\n            memo[mask]=max(memo.get(mask,0),len(word))\\n        masks=list(memo.keys())\\n        N=len(masks)\\n        self.ans=0\\n        def dfs(curM,curC,start):\\n            self.ans=max(self.ans,curC)\\n            for i in range(start,N):\\n                if not curM&masks[i]:\\n                    dfs(curM|masks[i],curC+memo[masks[i]],i+1)\\n        dfs(0,0,0)\\n        return self.ans\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    # Solution 1 dp\\n    def maxLength(self, arr: List[str]) -> int:\\n        dp=collections.defaultdict(int)\\n        dp[\"\"]=0\\n        for word in arr:\\n            for word2 in list(dp.keys()):\\n                if len(word)!=len(set(word)): break\\n                if len(set(word+word2))==len(word)+len(word2):\\n                    dp[word+word2]=max(dp[word+word2],len(word)+len(word2))\\n        return max(dp.values())\\n    \\n    # Solution 2 bit mask + dfs\\n    def maxLength(self, words) -> int:\\n        memo={}",
                "codeTag": "Java"
            },
            {
                "id": 414388,
                "title": "python3-4-liner",
                "content": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        bfs = [\\'\\']\\n        for b in filter(lambda x: len(x) == len(set(x)), arr):\\n            bfs += [a + b for a in bfs if not set(a) & set(b)]\\n        return max(map(len, bfs))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxLength(self, arr: List[str]) -> int:\\n        bfs = [\\'\\']\\n        for b in filter(lambda x: len(x) == len(set(x)), arr):\\n            bfs += [a + b for a in bfs if not set(a) & set(b)]\\n        return max(map(len, bfs))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004433,
                "title": "recursive-solution-beginner-friendly-java",
                "content": "# Intuition\\nIf we need to find all possible combinations, we should think of recursion\\n\\n# Approach\\nIt is a classic pick or not pick problem. At every index, we\\'ll either pick it or not pick, and once we reach the end of the input array, we\\'ll check if our concatenated string is valid or not. If it is valid, we\\'ll return the length, and store the maximum valid length with us.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        return solve(0, arr, \"\");\\n    }\\n    public int solve(int index, List<String> arr, String input){\\n        if (index == arr.size()){\\n            if (isValid(input)){\\n                return input.length();\\n            }\\n            return 0;\\n        }\\n        int take = solve(index+1, arr, input+arr.get(index));\\n        int notTake = solve(index+1, arr, input);\\n        return Math.max(take, notTake);\\n    }\\n    public boolean isValid(String s){\\n        int [] freq = new int[26];\\n        for(int i=0; i<s.length(); i++){\\n            int val = s.charAt(i)-\\'a\\';\\n            freq[val]++;\\n            if (freq[val] > 1)  return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxLength(List<String> arr) {\\n        return solve(0, arr, \"\");\\n    }\\n    public int solve(int index, List<String> arr, String input){\\n        if (index == arr.size()){\\n            if (isValid(input)){\\n                return input.length();\\n            }\\n            return 0;\\n        }\\n        int take = solve(index+1, arr, input+arr.get(index));\\n        int notTake = solve(index+1, arr, input);\\n        return Math.max(take, notTake);\\n    }\\n    public boolean isValid(String s){\\n        int [] freq = new int[26];\\n        for(int i=0; i<s.length(); i++){\\n            int val = s.charAt(i)-\\'a\\';\\n            freq[val]++;\\n            if (freq[val] > 1)  return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969616,
                "title": "simple-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2^n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int maxCount = Integer.MIN_VALUE;\\n    public int maxLength(List<String> arr) {\\n        for (int i = 0; i < arr.size(); i++) {\\n            helper(arr, i, new StringBuilder());\\n        }\\n        return maxCount;\\n    }\\n\\n    private void helper(List<String> arr, int index, StringBuilder str) {\\n        if (index == arr.size()) {\\n            return;\\n        }\\n        int oriLen = str.length();\\n        str.append(arr.get(index));\\n        if (checker(str)) {\\n            maxCount = Math.max(maxCount, str.length());\\n        }\\n        helper(arr, index + 1, str);\\n        str.delete(oriLen, str.length());\\n        if (checker(str)) {\\n            maxCount = Math.max(maxCount, str.length());\\n        }\\n        helper(arr, index + 1, str);\\n    }\\n\\n    private boolean checker(StringBuilder str) {\\n        HashSet<Character> hs = new HashSet<>();\\n        for (int i = 0; i < str.length(); i++) {\\n            if (hs.contains(str.charAt(i))) {\\n                return false;\\n            }\\n            hs.add(str.charAt(i));\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int maxCount = Integer.MIN_VALUE;\\n    public int maxLength(List<String> arr) {\\n        for (int i = 0; i < arr.size(); i++) {\\n            helper(arr, i, new StringBuilder());\\n        }\\n        return maxCount;\\n    }\\n\\n    private void helper(List<String> arr, int index, StringBuilder str) {\\n        if (index == arr.size()) {\\n            return;\\n        }\\n        int oriLen = str.length();\\n        str.append(arr.get(index));\\n        if (checker(str)) {\\n            maxCount = Math.max(maxCount, str.length());\\n        }\\n        helper(arr, index + 1, str);\\n        str.delete(oriLen, str.length());\\n        if (checker(str)) {\\n            maxCount = Math.max(maxCount, str.length());\\n        }\\n        helper(arr, index + 1, str);\\n    }\\n\\n    private boolean checker(StringBuilder str) {\\n        HashSet<Character> hs = new HashSet<>();\\n        for (int i = 0; i < str.length(); i++) {\\n            if (hs.contains(str.charAt(i))) {\\n                return false;\\n            }\\n            hs.add(str.charAt(i));\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566617,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1656950,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1986946,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2016289,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1657239,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1657275,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2066303,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2053419,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2037653,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1955044,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1566617,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1656950,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1986946,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2016289,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1657239,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1657275,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2066303,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2053419,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2037653,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1955044,
                "content": [
                    {
                        "username": "someone_hire_me",
                        "content": "Hello all. I was wondering in anyobe had a good way to look at problems like this and identify that it is a backtracking problem. For me, when I see words like \"Maximum\" I start immediately thinking that dynamic programming is a good approach. What makes DP impossible/non-optimal here and what\\'s the giveaway?"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "The first thing that came in mind is to store a list of all possible combinations before filtering the desired result. I think it is normal reflex, lol."
                    },
                    {
                        "username": "_h_a_w_k_",
                        "content": "it can be solved by backtracking...and this will come into picture when we will maintain a visited array!"
                    },
                    {
                        "username": "sameet_11",
                        "content": "If you see that there are change in parameters of different data-type in the recursive function."
                    },
                    {
                        "username": "souravsinha",
                        "content": "The easiest way to identify these in OA is look at the constraints. If they are too less then surely it\\'s a backtracking problem."
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the brute force approach. It consists of building a set of all the solutions incrementally. Since a problem would have constraints, the solutions that fail to satisfy them will be removed."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\n\n```\n[\"fui\", \"lo\", \"yr\", \"i\", \"hxo\", \"rou\", \"q\", \"spu\", \"d\", \"lo\", \"p\", \"xjb\", \"idm\", \"bwj\", \"s\", \"ec\"]\n```\n\n```\n[\"dw\", \"q\", \"ux\", \"j\", \"he\", \"ev\", \"ly\", \"zix\", \"tth\", \"x\", \"t\", \"r\", \"ty\", \"n\", \"sei\", \"mb\"]\n```\n\n```\n[\"z\", \"chgtccakarmgp\", \"ieyfhzxtcczjhs\", \"i\", \"kxowcdbynshauqikgg\", \"aklbjxkczzjiqldciekn\", \"cvabiynubojuwa\", \"ctmszammcjwdkyigd\", \"vswykwxueeo\", \"ua\", \"rmwest\", \"jmjivmbnoexaat\", \"obbar\", \"cyek\", \"vvfxooaacpxdjzsstzbn\", \"t\"]\n```\n\nPython script to generate test cases\n\n```\nimport random\nimport json\nimport pyperclip\n\nn = 16\nm = 26\narr = list()\nfor i in range(n):\n    arr.append(\"\".join([chr(random.randint(97, 122))\n               for _ in range(random.randint(1, m))]))\njson_str = json.dumps(arr)\nprint(json_str)\npyperclip.copy(json_str)\n```"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "Can someone explain why \"un\" + \"iq\" + \"e\" is not a valid solution"
                    },
                    {
                        "username": "dspavankumar0569",
                        "content": "[@East_Bound](/East_Bound) Thanks"
                    },
                    {
                        "username": "East_Bound",
                        "content": "We are taking a subsequence of the array of elements, not a subsequence of the individual elements of the array, this confused me as well at first."
                    },
                    {
                        "username": "carlosabcs",
                        "content": "Give a look at the examples again and try to understand this, at each position:\\n- You include the current string to your local solution, only if including it doesn\\'t provoke repeated characters\\n- You exclude the current string because maybe there will be a better option in the remaining strings, considering that each time you include a string you \"kill\" those characters for being included again."
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"]\\n\\nHow the output is 16?"
                    },
                    {
                        "username": "Kaychub",
                        "content": "Because you can concatenate the entire list together to get \"abcdefghijklmnop\". You can concatenate more than once -- even though the examples only show one concat."
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Maybe because one of the constrains is 1 <= arr.length <= 16."
                    },
                    {
                        "username": "user2929vk",
                        "content": "Based on the wording of the problem, I assumed that the sub-sequences themselves would have unique characters.\\n `the concatenation of a subsequence of arr that has unique characters.`\\nMight just be me though."
                    },
                    {
                        "username": "2vedMadhava",
                        "content": "why is this code is giving 4 instead of 6 for the following code \\n\\n#include <algorithm>\\n#include <unordered_set>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int f(int i, unordered_set<char>& st, vector<string>& arr) {\\n        \\n        if (i >arr.size()) return 0;\\n\\n        int maxAns = 0;\\n        for (int j = i; j < arr.size(); j++) {\\n            string temp = arr[j];\\n            bool flag = true;\\n            for (int k = 0; k < temp.size(); k++) {\\n                if (st.empty() || st.find(temp[k]) == st.end()) {\\n                    st.insert(temp[k]);\\n                } else {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                maxAns = std::max(maxAns, static_cast<int>(temp.size()) + f(j + 1, st, arr));\\n                for (char c : temp) st.erase(c);\\n            }\\n        }\\n        return maxAns; \\n    }\\n\\n    int maxLength(vector<string>& arr) {\\n        unordered_set<char> st;\\n        return f(0, st, arr);\\n    }\\n};\\n"
                    },
                    {
                        "username": "who_rules",
                        "content": "Can a single string have repeating chars? It would be the first question would ask on the interview. The problem statement must be clear\nP.s. the answer is yes - a string can have repeating chars"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Here is my code, it is giving correct output for every input, still i am getting tle\\nclass Solution {\\n    void solve(vector<string>& arr,int i,map<char,int>& m,string l,int n,int& ans){\\n        \\n        if(i>=n){\\n            cout<<l<<\" \";\\n            if(ans<l.length()) ans=l.length(); return;\\n        }\\n        cout<<l<<\" \";\\n        if(l.length()>ans) ans=l.length();\\n        for(int p=i;p<n;p++){\\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]++;\\n            }\\n            if(m.size()==(l+arr[p]).length()){\\n                solve(arr,i+1,m,(l+arr[p]),n,ans);\\n            } \\n            for(int k=0;k<arr[p].length();k++){\\n                m[arr[p][k]]--; if(m[arr[p][k]]==0) m.erase(arr[p][k]);\\n            }\\n        }\\n    }\\npublic:\\n    int maxLength(vector<string>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            string l=arr[i];\\n             map<char,int> m;\\n            for(int w=0;w<l.length();w++){\\n                m[l[w]]++;\\n            }\\n            if(m.size()==l.length()){\\n                solve(arr,i+1,m,l,n,ans);\\n            }\\n             for(int w=0;w<l.length();w++){\\n                m[l[w]]--; if(m[l[w]]==0) m.erase(l[w]);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            }
        ]
    }
]