[
    {
        "title": "Encrypt and Decrypt Strings",
        "question_content": "You are given a character array keys containing unique characters and a string array values containing strings of length 2. You are also given another string array dictionary that contains all permitted original strings after decryption. You should implement a data structure that can encrypt or decrypt a 0-indexed string.\nA string is encrypted with the following process:\n\n\tFor each character c in the string, we find the index i satisfying keys[i] == c in keys.\n\tReplace c with values[i] in the string.\n\nNote that in case a character of the string is not present in keys, the encryption process cannot be carried out, and an empty string \"\" is returned.\nA string is decrypted with the following process:\n\n\tFor each substring s of length 2 occurring at an even index in the string, we find an i such that values[i] == s. If there are multiple valid i, we choose any one of them. This means a string could have multiple possible strings it can decrypt to.\n\tReplace s with keys[i] in the string.\n\nImplement the Encrypter class:\n\n\tEncrypter(char[] keys, String[] values, String[] dictionary) Initializes the Encrypter class with keys, values, and dictionary.\n\tString encrypt(String word1) Encrypts word1 with the encryption process described above and returns the encrypted string.\n\tint decrypt(String word2) Returns the number of possible strings word2 could decrypt to that also appear in dictionary.\n\n&nbsp;\nExample 1:\n\nInput\n[\"Encrypter\", \"encrypt\", \"decrypt\"]\n[[['a', 'b', 'c', 'd'], [\"ei\", \"zf\", \"ei\", \"am\"], [\"abcd\", \"acbd\", \"adbc\", \"badc\", \"dacb\", \"cadb\", \"cbda\", \"abad\"]], [\"abcd\"], [\"eizfeiam\"]]\nOutput\n[null, \"eizfeiam\", 2]\nExplanation\nEncrypter encrypter = new Encrypter([['a', 'b', 'c', 'd'], [\"ei\", \"zf\", \"ei\", \"am\"], [\"abcd\", \"acbd\", \"adbc\", \"badc\", \"dacb\", \"cadb\", \"cbda\", \"abad\"]);\nencrypter.encrypt(\"abcd\"); // return \"eizfeiam\". \n&nbsp;                          // 'a' maps to \"ei\", 'b' maps to \"zf\", 'c' maps to \"ei\", and 'd' maps to \"am\".\nencrypter.decrypt(\"eizfeiam\"); // return 2. \n                              // \"ei\" can map to 'a' or 'c', \"zf\" maps to 'b', and \"am\" maps to 'd'. \n                              // Thus, the possible strings after decryption are \"abad\", \"cbad\", \"abcd\", and \"cbcd\". \n                              // 2 of those strings, \"abad\" and \"abcd\", appear in dictionary, so the answer is 2.\n\n&nbsp;\nConstraints:\n\n\t1 <= keys.length == values.length <= 26\n\tvalues[i].length == 2\n\t1 <= dictionary.length <= 100\n\t1 <= dictionary[i].length <= 100\n\tAll keys[i] and dictionary[i] are unique.\n\t1 <= word1.length <= 2000\n\t1 <= word2.length <= 200\n\tAll word1[i] appear in keys.\n\tword2.length is even.\n\tkeys, values[i], dictionary[i], word1, and word2 only contain lowercase English letters.\n\tAt most 200 calls will be made to encrypt and decrypt in total.",
        "solutions": [
            {
                "id": 1909025,
                "title": "java-c-python-two-hashmaps-with-explanation",
                "content": "# **Explanation**\\nThe hashmap `enc` help binding each paire of `keys[i]` and `values[i]`,\\nso that we can encrypt a char to the string in `O(1)`\\n\\n`count` counts the frequency of words in `dictionary` after `encrypt`,\\nthen we can used in `decrypt` in `O(1)`.\\n<br>\\n\\n# **Complexity**\\n`Encrypter`  Time `O(n)`      Space `O(n)`\\n`encrypt`    Time `O(word1)`  Space `O(word1)`\\n`decrypt`    Time `O(1)`      Space `O(1)`\\n<br>\\n\\n# **Note**\\nNot all word can be \"encrypt\", \\nFor character `c`, if we can\\'t find the index `i` satisfying `keys[i] == c` in keys.\\nThe behavior are **NOT** clearly defined.\\n\\nIn my opinion we should do nothing but keep the original character, \\n(the standard solution of OJ doesn\\'t work as I suggest)\\n\\nThese kind of test cases are not present in the original test cases set,\\nbut recedntly blindly added to the test cases.\\n\\nThe descrption of probelm should be fixed, not blindly add an appropriat test cases.\\n\\nIt\\'s like, a bug is reported and not guarded by tests, \\nthen LC adds a test but not fix anything at all.\\n\\n\\n**Java**\\n```java\\n    Map<Character, String> enc;\\n    Map<String, Integer> count;\\n    \\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        enc = new HashMap<>();\\n        for (int i = 0; i < keys.length; ++i)\\n            enc.put(keys[i], values[i]);\\n        \\n        count = new HashMap<>();\\n        for (String w : dictionary) {\\n            String e = encrypt(w);\\n            count.put(e, count.getOrDefault(e, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder res = new StringBuilder();\\n        for (int i = 0; i < word1.length(); ++i)\\n            res.append(enc.getOrDefault(word1.charAt(i), \"#\"));\\n        return res.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return count.getOrDefault(word2, 0);\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    unordered_map<char, string> enc;\\n    unordered_map<string, int> count;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i)\\n            enc[keys[i]] = values[i];\\n        for (string& w: dictionary)\\n            count[encrypt(w)]++;\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res = \"\";\\n        for (char c: word1) {\\n        \\tif (!enc.count(c)) return \"\";\\n            res += enc[c];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return count[word2];\\n    }\\n```\\n\\n**Python**\\n3-lines Python.\\n`decrypt` method is not missing, `defined` in `init`\\nI remoded unnecessay code from default template.\\n```py\\nclass Encrypter(object):\\n\\n    def __init__(self, keys, values, dictionary):\\n        self.enc = {k: v for k,v in zip(keys, values)}\\n        self.decrypt = collections.Counter(self.encrypt(w) for w in dictionary).__getitem__\\n\\n    def encrypt(self, word1):\\n        return \\'\\'.join(self.enc.get(c, \\'#\\') for c in word1)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    Map<Character, String> enc;\\n    Map<String, Integer> count;\\n    \\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        enc = new HashMap<>();\\n        for (int i = 0; i < keys.length; ++i)\\n            enc.put(keys[i], values[i]);\\n        \\n        count = new HashMap<>();\\n        for (String w : dictionary) {\\n            String e = encrypt(w);\\n            count.put(e, count.getOrDefault(e, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder res = new StringBuilder();\\n        for (int i = 0; i < word1.length(); ++i)\\n            res.append(enc.getOrDefault(word1.charAt(i), \"#\"));\\n        return res.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return count.getOrDefault(word2, 0);\\n    }\\n```\n```cpp\\n    unordered_map<char, string> enc;\\n    unordered_map<string, int> count;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i)\\n            enc[keys[i]] = values[i];\\n        for (string& w: dictionary)\\n            count[encrypt(w)]++;\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res = \"\";\\n        for (char c: word1) {\\n        \\tif (!enc.count(c)) return \"\";\\n            res += enc[c];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return count[word2];\\n    }\\n```\n```py\\nclass Encrypter(object):\\n\\n    def __init__(self, keys, values, dictionary):\\n        self.enc = {k: v for k,v in zip(keys, values)}\\n        self.decrypt = collections.Counter(self.encrypt(w) for w in dictionary).__getitem__\\n\\n    def encrypt(self, word1):\\n        return \\'\\'.join(self.enc.get(c, \\'#\\') for c in word1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908722,
                "title": "easy-understanding-c-code-with-comments-without-tries",
                "content": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string> m;\\n    unordered_map<string,int> dict;\\n    // vector k is keys, vector v is values and vector d is dictionary\\n    Encrypter(vector<char>& k, vector<string>& v, vector<string>& d) {\\n        int n = k.size();\\n        // we store the key value pairs in an unordered_map m, so that encryption of a char takes O(1).\\n        for(int i=0;i<n;i++){\\n            m[k[i]] = v[i];\\n        }\\n        \\n        // we encrypt the strings in the vector d and store it\\'s count in an unordered_map dict.\\n        // so that we can directly say the count of decryptions for a string in O(1).\\n        n = d.size();\\n        for(int i=0;i<n;i++){\\n            dict[encrypt(d[i])]++;\\n        }\\n    }\\n    \\n    string encrypt(string s) {\\n        // encrypt the string using key value pairs in unordered_map m\\n        int n = s.length();\\n        string ans = \"\";\\n        for(int i=0;i<n;i++){\\n            if(m.find(s[i])==m.end()) return \"\";\\n            ans += m[s[i]];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string s) {\\n        if(dict.find(s)==dict.end()) return 0; // if not present in dict, return 0\\n        return dict[s]; // else return count.\\n    }\\n};\\n```\\n**Upvote if it helps!\\uD83D\\uDE4C**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string> m;\\n    unordered_map<string,int> dict;\\n    // vector k is keys, vector v is values and vector d is dictionary\\n    Encrypter(vector<char>& k, vector<string>& v, vector<string>& d) {\\n        int n = k.size();\\n        // we store the key value pairs in an unordered_map m, so that encryption of a char takes O(1).\\n        for(int i=0;i<n;i++){\\n            m[k[i]] = v[i];\\n        }\\n        \\n        // we encrypt the strings in the vector d and store it\\'s count in an unordered_map dict.\\n        // so that we can directly say the count of decryptions for a string in O(1).\\n        n = d.size();\\n        for(int i=0;i<n;i++){\\n            dict[encrypt(d[i])]++;\\n        }\\n    }\\n    \\n    string encrypt(string s) {\\n        // encrypt the string using key value pairs in unordered_map m\\n        int n = s.length();\\n        string ans = \"\";\\n        for(int i=0;i<n;i++){\\n            if(m.find(s[i])==m.end()) return \"\";\\n            ans += m[s[i]];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string s) {\\n        if(dict.find(s)==dict.end()) return 0; // if not present in dict, return 0\\n        return dict[s]; // else return count.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908714,
                "title": "c-simple-solution-w-explanation-hashmap-trie-dfs-hashmap-preprocess",
                "content": "\\n\\u2714\\uFE0F ***Solution - I  (Hashmap + Trie)***\\n\\nWe are given an array of characters `K`, an array of strings `V` and another array of strings `D`.\\nA string `W` is encrypted by replacing each character `c`, found at `K[i]` with `V[i]` (only single possible index `i`).\\nA string `W` is decrypted by replacing every 2-character substring `s`, found at `V[i]` with `K[i]` for all possible `i`. This decrypted value must be present in `D`.\\n\\n**Encryption:**\\n* The encryption process is straight-forward wherein for every character `c` in given word `W`, we need to find  `c`\\'s index `i` in `K` & replace it with corresponding string in `V`, i.e `V[i]`. \\n* For this, we can use a hashmap `K_V` to keep mapping between each key and value.\\n\\n**Decryption:**\\n* For decryption, there can be multiple choices for replacement of a substring of length 2 and we need to consider each of them to find count of possible decryptions. \\n* But for efficient decryption process, we need to eliminate a choice as soon as we know that it wont be found in `D`. \\n* For this, we can maintain Trie consisting of all strings from `D` & we stop further exploration as soon as we find that current choice wont lead to a string present in the trie.\\n* We also keep a hashmap `V_Ks` to map a value in `V` to all possible keys in `K`.\\n\\n**C++**\\n```cpp\\nclass Trie {\\npublic:    \\n    Trie* chars[26]{};\\n    bool endsHere = false;\\n    void insert(string& s) {\\n        auto cur = this;\\n        for(auto c : s) \\n            cur = cur -> chars[c-\\'a\\'] ? cur -> chars[c-\\'a\\'] : cur -> chars[c-\\'a\\'] = new Trie();\\n        cur -> endsHere = true;\\n    }\\n};\\n\\nclass Encrypter {\\n    Trie* t = new Trie();                      // Trie of dictionary strings\\n    unordered_map<char, string> K_V;           // key : value\\n    unordered_map<string, vector<char>> V_Ks;  // value : [key]\\npublic:\\n    Encrypter(vector<char>& K, vector<string>& V, vector<string>& D) {\\n        for(int i = 0; i < size(K); i++) \\n            K_V[K[i]] = V[i], \\n            V_Ks[V[i]].push_back(K[i]);\\n        for(auto& d : D) t -> insert(d);\\n    }\\n    \\n    string encrypt(string W) {\\n        string ans = \"\";\\n        for(auto c : W) ans += K_V[c];\\n        return ans;\\n    }\\n    \\n    int decrypt(string W) {\\n        return dfs(W, t);\\n    }\\n    int dfs(string& W, Trie* T, int i = 0) {\\n        if(i == size(W)) return T -> endsHere;\\n        int ans = 0;\\n        for(string s = W.substr(i, 2); auto c : V_Ks[s]) \\n            if(T -> chars[c-\\'a\\']) \\n                ans += dfs(W, T -> chars[c-\\'a\\'], i+2);\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n\\n\\u2714\\uFE0F ***Solution - II  (Hashmap + Pre-process)***\\n\\nWe can also preprocess and keep all possible encrypted strings that can be obtained by encrypting strings in `D`. Then we can directly return the count of strings which could lead to a given encrypted string `W`.\\n\\n**C++**\\n```cpp\\nclass Encrypter {\\n    unordered_map<char, string> K_V;           // key : value\\n    unordered_map<string, int> mp;             // encrypted string : count\\npublic:\\n    Encrypter(vector<char>& K, vector<string>& V, vector<string>& D) {\\n        for(int i = 0; i < size(K); i++) K_V[K[i]] = V[i];\\n        for(auto& d : D) mp[encrypt(d)]++;\\n    }\\n    \\n    string encrypt(string W) {\\n        string ans = \"\";\\n        for(auto c : W) ans += K_V[c];\\n        return ans;\\n    }\\n    \\n    int decrypt(string W) {\\n        return mp[W];\\n    }\\n};\\n```\\n\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Trie {\\npublic:    \\n    Trie* chars[26]{};\\n    bool endsHere = false;\\n    void insert(string& s) {\\n        auto cur = this;\\n        for(auto c : s) \\n            cur = cur -> chars[c-\\'a\\'] ? cur -> chars[c-\\'a\\'] : cur -> chars[c-\\'a\\'] = new Trie();\\n        cur -> endsHere = true;\\n    }\\n};\\n\\nclass Encrypter {\\n    Trie* t = new Trie();                      // Trie of dictionary strings\\n    unordered_map<char, string> K_V;           // key : value\\n    unordered_map<string, vector<char>> V_Ks;  // value : [key]\\npublic:\\n    Encrypter(vector<char>& K, vector<string>& V, vector<string>& D) {\\n        for(int i = 0; i < size(K); i++) \\n            K_V[K[i]] = V[i], \\n            V_Ks[V[i]].push_back(K[i]);\\n        for(auto& d : D) t -> insert(d);\\n    }\\n    \\n    string encrypt(string W) {\\n        string ans = \"\";\\n        for(auto c : W) ans += K_V[c];\\n        return ans;\\n    }\\n    \\n    int decrypt(string W) {\\n        return dfs(W, t);\\n    }\\n    int dfs(string& W, Trie* T, int i = 0) {\\n        if(i == size(W)) return T -> endsHere;\\n        int ans = 0;\\n        for(string s = W.substr(i, 2); auto c : V_Ks[s]) \\n            if(T -> chars[c-\\'a\\']) \\n                ans += dfs(W, T -> chars[c-\\'a\\'], i+2);\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Encrypter {\\n    unordered_map<char, string> K_V;           // key : value\\n    unordered_map<string, int> mp;             // encrypted string : count\\npublic:\\n    Encrypter(vector<char>& K, vector<string>& V, vector<string>& D) {\\n        for(int i = 0; i < size(K); i++) K_V[K[i]] = V[i];\\n        for(auto& d : D) mp[encrypt(d)]++;\\n    }\\n    \\n    string encrypt(string W) {\\n        string ans = \"\";\\n        for(auto c : W) ans += K_V[c];\\n        return ans;\\n    }\\n    \\n    int decrypt(string W) {\\n        return mp[W];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908702,
                "title": "encrypted-dictionary-vs-trie",
                "content": "#### Approach 1: Encrypted Dictionary\\nI did not see this, but it makes sense. If we encrypt all words in the dictionary, some of those words may have the same encrypted representation.\\n\\nWe could store the number of dictionary words for each encrypted representation in hash map `m`, and return this count in the `decrypt` function.\\n\\n**C++**\\n```cpp\\nclass Encrypter {\\n    unordered_map<char, string> ch2s;    \\n    unordered_map<string, int> m;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i)\\n            ch2s[keys[i]] = values[i];\\n        for (auto &s : dictionary)\\n            ++m[encrypt(s)];\\n    }\\n    string encrypt(string word1) {\\n        string res;\\n        for (char ch : word1)\\n            res += ch2s[ch];\\n        return res;\\n    }\\n    int decrypt(string word2) { return m[word2]; }\\n};\\n```\\n\\n#### Approach 2: Trie\\nWe need to pay attention to the `decrypt` function. If we check for a valid word in the end, we will get TLE.\\n    \\nTherefore, we need to use Trie so we can prune invalid words as we go.\\n    \\n**C++**\\n```cpp\\nint val2int(char a, char b) { return (a - \\'a\\') * 26 + b - \\'a\\'; }\\nstruct trie {\\n    trie* ch[26] = {};\\n    bool end = false;\\n    void insert(string &w, int i = 0) {\\n        if (i == w.size())\\n            end = true;\\n        else {\\n            auto *p = ch[w[i] - \\'a\\'];\\n            if (p == nullptr)\\n                p = ch[w[i] - \\'a\\'] = new trie();\\n            p->insert(w, i + 1);\\n        }\\n    }\\n    int count(string &w, unordered_map<int, vector<char>> &s2ch, int i = 0) {\\n        if (i == w.size())\\n            return end;\\n        int res = 0, v = val2int(w[i], w[i + 1]);\\n        for (auto k : s2ch[v])\\n            if (ch[k - \\'a\\'] != nullptr)\\n                res += ch[k - \\'a\\']->count(w, s2ch, i + 2);\\n        return res;\\n    }\\n};\\nclass Encrypter {\\n    unordered_map<int, vector<char>> s2ch;\\n    unordered_map<char, string> ch2s;    \\n    trie root;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i) {\\n            s2ch[val2int(values[i][0], values[i][1])].push_back(keys[i]);\\n            ch2s[keys[i]] = values[i];\\n        }\\n        for (auto &s : dictionary)\\n            root.insert(s);\\n    }\\n    string encrypt(string word1) {\\n        string res;\\n        for (char ch : word1)\\n            res += ch2s[ch];\\n        return res;\\n    }\\n    int decrypt(string word2) { return root.count(word2, s2ch); }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Encrypter {\\n    unordered_map<char, string> ch2s;    \\n    unordered_map<string, int> m;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i)\\n            ch2s[keys[i]] = values[i];\\n        for (auto &s : dictionary)\\n            ++m[encrypt(s)];\\n    }\\n    string encrypt(string word1) {\\n        string res;\\n        for (char ch : word1)\\n            res += ch2s[ch];\\n        return res;\\n    }\\n    int decrypt(string word2) { return m[word2]; }\\n};\\n```\n```cpp\\nint val2int(char a, char b) { return (a - \\'a\\') * 26 + b - \\'a\\'; }\\nstruct trie {\\n    trie* ch[26] = {};\\n    bool end = false;\\n    void insert(string &w, int i = 0) {\\n        if (i == w.size())\\n            end = true;\\n        else {\\n            auto *p = ch[w[i] - \\'a\\'];\\n            if (p == nullptr)\\n                p = ch[w[i] - \\'a\\'] = new trie();\\n            p->insert(w, i + 1);\\n        }\\n    }\\n    int count(string &w, unordered_map<int, vector<char>> &s2ch, int i = 0) {\\n        if (i == w.size())\\n            return end;\\n        int res = 0, v = val2int(w[i], w[i + 1]);\\n        for (auto k : s2ch[v])\\n            if (ch[k - \\'a\\'] != nullptr)\\n                res += ch[k - \\'a\\']->count(w, s2ch, i + 2);\\n        return res;\\n    }\\n};\\nclass Encrypter {\\n    unordered_map<int, vector<char>> s2ch;\\n    unordered_map<char, string> ch2s;    \\n    trie root;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i) {\\n            s2ch[val2int(values[i][0], values[i][1])].push_back(keys[i]);\\n            ch2s[keys[i]] = values[i];\\n        }\\n        for (auto &s : dictionary)\\n            root.insert(s);\\n    }\\n    string encrypt(string word1) {\\n        string res;\\n        for (char ch : word1)\\n            res += ch2s[ch];\\n        return res;\\n    }\\n    int decrypt(string word2) { return root.count(word2, s2ch); }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908833,
                "title": "python-hashmap-counter-solution-with-detailed-explanations-very-clean-concise",
                "content": "This is the first time I get AK over the past few months. I would like to share my solution with the LC community.\\n\\n**Intuition**\\nThe given constraints are not large, we can pre-compute all necessary quantities only once.\\n\\n\\n**Explanation**\\nWe can pre-compute two hashmaps as follows:\\n\\n(1) The first hashmap `self.hashmap` is a encryption map - we map each key with their encrypted values, which is straightforward.\\n(2) The second hashmap `self.dictmap` is a `Counter` - we encrypt each word in the given `dictionary` and use the encrypted string as the key and increase the counter by 1. As such, we have solved the duplication problem of the `decrypt()` method.\\n\\n**Complexity**\\nTime in `__init__()`: `O(sum(dictionary[i].length))`, which gets amortized over later function calls\\nSpace in `__init__()`: `O(dictionary.length)`\\nTime in `encrypt()`: `O(word1.length)`\\nSpace in `encrypt()`: `O(1)` (if not counting the `output` string)\\nTime in `decrypt()`: `O(1)`\\nSpace in `decrypt()`: `O(1)`\\n\\n\\nBelow is my in-contest solution. Please upvote if you find this solution helpful. Thanks!\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.hashmap = dict()\\n        for i in range(len(keys)):\\n            self.hashmap[keys[i]] = values[i]\\n        self.dictmap = defaultdict(int)\\n        for word in dictionary:\\n            self.dictmap[self.encrypt(word)] += 1\\n\\n    def encrypt(self, word1: str) -> str:\\n        output = \\'\\'\\n        for char in word1:\\n            output += self.hashmap[char]\\n        return output\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.dictmap[word2]\\n```\\n\\n**Follow up** (for self-learning purpose): The `encrypt()` method can be written as follows to handle more general test cases (given in the Comments section).\\n```\\ndef encrypt(self, word1: str) -> str:\\n    output = \\'\\'\\n    for char in word1:\\n        if char in self.hashmap:\\n            output += self.hashmap[char]\\n        else:\\n            return \\'\\'\\n    return output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.hashmap = dict()\\n        for i in range(len(keys)):\\n            self.hashmap[keys[i]] = values[i]\\n        self.dictmap = defaultdict(int)\\n        for word in dictionary:\\n            self.dictmap[self.encrypt(word)] += 1\\n\\n    def encrypt(self, word1: str) -> str:\\n        output = \\'\\'\\n        for char in word1:\\n            output += self.hashmap[char]\\n        return output\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.dictmap[word2]\\n```\n```\\ndef encrypt(self, word1: str) -> str:\\n    output = \\'\\'\\n    for char in word1:\\n        if char in self.hashmap:\\n            output += self.hashmap[char]\\n        else:\\n            return \\'\\'\\n    return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908706,
                "title": "c-maps-fastest",
                "content": "```\\nclass Encrypter {\\n    map<char,string> kmap;\\n    map<string,int> rmap;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dic) {\\n        int n = keys.size();\\n        for(int i  = 0 ; i < n ; i++){\\n            kmap[keys[i]] = values[i];\\n        }\\n        for(auto x : dic){\\n            rmap[encrypt(x)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto x : word1){\\n            ans += kmap[x];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string word2) {\\n        return rmap[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\n    map<char,string> kmap;\\n    map<string,int> rmap;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dic) {\\n        int n = keys.size();\\n        for(int i  = 0 ; i < n ; i++){\\n            kmap[keys[i]] = values[i];\\n        }\\n        for(auto x : dic){\\n            rmap[encrypt(x)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto x : word1){\\n            ans += kmap[x];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string word2) {\\n        return rmap[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908902,
                "title": "python-very-simple-code",
                "content": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.enc = dict()\\n        self.n = len(keys)        \\n        \\n        for i in range(self.n):\\n            self.enc[keys[i]] = values[i]\\n        \\n        self.dict = dictionary\\n            \\n    def encrypt(self, word1: str) -> str:\\n        es = \\'\\'\\n        for w in word1:\\n            es += self.enc[w]\\n        return es\\n\\n    def decrypt(self, word2: str) -> int:\\n        ans = 0 \\n        for w in self.dict:\\n            if self.encrypt(w) == word2:\\n                ans += 1\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.enc = dict()\\n        self.n = len(keys)        \\n        \\n        for i in range(self.n):\\n            self.enc[keys[i]] = values[i]\\n        \\n        self.dict = dictionary\\n            \\n    def encrypt(self, word1: str) -> str:\\n        es = \\'\\'\\n        for w in word1:\\n            es += self.enc[w]\\n        return es\\n\\n    def decrypt(self, word2: str) -> int:\\n        ans = 0 \\n        for w in self.dict:\\n            if self.encrypt(w) == word2:\\n                ans += 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908891,
                "title": "java-solution-with-description-pre-process-dictionary-o-1-decrypt",
                "content": "**Approach**: \\nWhenever decrypt(word) is called decrypt the word. However `values` contains duplicates and it will match to different keys and our descrypt can have many answers. \\nSo, total number of combinations you can achieve is really high and checking every value to dictionary is not a feasible solution.\\n\\nTo overcome that instead of processing word in decrypt(word), pre-process all values in dictionary before. As given there are at most 100 words in dictionary so, encrypt that. As any encryption can lead to same string, store the count of each encryption. This way whenever decrypt is called, just seach that string in our Map and return the count.\\n\\n**Time complexity**:\\n\\nEncrypt: O(n), n: length of word\\nDecrypt: O(1)\\nClass define Encrypter : O(n*m), where n: length of longest word in dictionary, m = dictionary.length\\n\\n**Upvote if it helps. Thanks :)**\\n\\n```\\nclass Encrypter {\\n    \\n    Map<String, Integer> encryptedDictCount;\\n    int[] keys;\\n    Set<String> dictionary;\\n    String[] val;\\n    \\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.keys = new int[26];\\n        encryptedDictCount = new HashMap<>();\\n        this.val = values.clone();\\n        this.dictionary = new HashSet<>(Arrays.asList(dictionary));\\n        \\n        for(int i=0; i<keys.length; i++) {\\n            this.keys[keys[i] - \\'a\\'] = i;\\n        }\\n        \\n        for(String dict : dictionary) {\\n            String encrpted = encrypt(dict);\\n            encryptedDictCount.put(encrpted, encryptedDictCount.getOrDefault(encrpted, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i =0; i < word1.length(); i++) {\\n            int c = word1.charAt(i) - \\'a\\';\\n            sb.append(val[keys[c]]);\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return encryptedDictCount.getOrDefault(word2, 0);\\n    }\\n}\\n\\n ```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n    \\n    Map<String, Integer> encryptedDictCount;\\n    int[] keys;\\n    Set<String> dictionary;\\n    String[] val;\\n    \\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.keys = new int[26];\\n        encryptedDictCount = new HashMap<>();\\n        this.val = values.clone();\\n        this.dictionary = new HashSet<>(Arrays.asList(dictionary));\\n        \\n        for(int i=0; i<keys.length; i++) {\\n            this.keys[keys[i] - \\'a\\'] = i;\\n        }\\n        \\n        for(String dict : dictionary) {\\n            String encrpted = encrypt(dict);\\n            encryptedDictCount.put(encrpted, encryptedDictCount.getOrDefault(encrpted, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i =0; i < word1.length(); i++) {\\n            int c = word1.charAt(i) - \\'a\\';\\n            sb.append(val[keys[c]]);\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return encryptedDictCount.getOrDefault(word2, 0);\\n    }\\n}\\n\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2778107,
                "title": "java-solutions",
                "content": "```\\nclass Encrypter {\\n    class TrieNode{\\n        int count;\\n        TrieNode[] letter;\\n        public TrieNode(){\\n            letter=new TrieNode[26];\\n            count=0;\\n        }\\n        \\n        public void add(String s){\\n            TrieNode p=this;\\n            for(int i=0;i<s.length();i++){\\n                char ch=s.charAt(i);\\n                if(p.letter[ch-97]==null){\\n                    p.letter[ch-97]=new TrieNode();\\n                }\\n                p=p.letter[ch-97];\\n            }\\n            p.count++;\\n        }\\n        \\n    }\\n    Map<Character,String> charMap;\\n    Map<String,Set<Character>> valueMap;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        charMap=new HashMap<>();\\n        valueMap=new HashMap<>();\\n        root=new TrieNode();\\n        for(int i=0;i<keys.length;i++){\\n            charMap.put(keys[i],values[i]);\\n            valueMap.computeIfAbsent(values[i],key->new HashSet<>()).add(keys[i]);\\n        }\\n        for(String word:dictionary){\\n            String encrypted=encrypt(word);\\n            if(null!=encrypted)\\n                root.add(encrypted);\\n        }\\n    }\\n    public String encrypt(String word1) {\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<word1.length();i++){\\n            if(charMap.get(word1.charAt(i))==null)\\n                return null;\\n            sb.append(charMap.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    public int decrypt(String word2) {\\n        TrieNode p=root;\\n        for(int i=0;i<word2.length();i++){\\n            p=p.letter[word2.charAt(i)-97];\\n            if(p==null)\\n                return 0;\\n        }\\n        return p.count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Encrypter {\\n    class TrieNode{\\n        int count;\\n        TrieNode[] letter;\\n        public TrieNode(){\\n            letter=new TrieNode[26];\\n            count=0;\\n        }\\n        \\n        public void add(String s){\\n            TrieNode p=this;\\n            for(int i=0;i<s.length();i++){\\n                char ch=s.charAt(i);\\n                if(p.letter[ch-97]==null){\\n                    p.letter[ch-97]=new TrieNode();\\n                }\\n                p=p.letter[ch-97];\\n            }\\n            p.count++;\\n        }\\n        \\n    }\\n    Map<Character,String> charMap;\\n    Map<String,Set<Character>> valueMap;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        charMap=new HashMap<>();\\n        valueMap=new HashMap<>();\\n        root=new TrieNode();\\n        for(int i=0;i<keys.length;i++){\\n            charMap.put(keys[i],values[i]);\\n            valueMap.computeIfAbsent(values[i],key->new HashSet<>()).add(keys[i]);\\n        }\\n        for(String word:dictionary){\\n            String encrypted=encrypt(word);\\n            if(null!=encrypted)\\n                root.add(encrypted);\\n        }\\n    }\\n    public String encrypt(String word1) {\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<word1.length();i++){\\n            if(charMap.get(word1.charAt(i))==null)\\n                return null;\\n            sb.append(charMap.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    public int decrypt(String word2) {\\n        TrieNode p=root;\\n        for(int i=0;i<word2.length();i++){\\n            p=p.letter[word2.charAt(i)-97];\\n            if(p==null)\\n                return 0;\\n        }\\n        return p.count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908980,
                "title": "java-trie-map-with-trie-node-class-implementation",
                "content": "The approach is to first encrypt the words of the dictionary and store them in a trie with a count of each words.\\nNext, what\\'s left is just traversing over the trie with decrypted word to get the count.\\n**Please upvote if you got the solution.**\\n```\\nclass Encrypter {\\n    class TrieNode{\\n        int count;\\n        TrieNode[] letter;\\n        public TrieNode(){\\n            letter=new TrieNode[26];\\n            count=0;\\n        }\\n        \\n        public void add(String s){\\n            TrieNode p=this;\\n            for(int i=0;i<s.length();i++){\\n                char ch=s.charAt(i);\\n                if(p.letter[ch-97]==null){\\n                    p.letter[ch-97]=new TrieNode();\\n                }\\n                p=p.letter[ch-97];\\n            }\\n            p.count++;\\n        }\\n        \\n    }\\n    Map<Character,String> charMap;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        charMap=new HashMap<>();\\n        root=new TrieNode();\\n        for(int i=0;i<keys.length;i++){\\n            charMap.put(keys[i],values[i]);\\n        }\\n        for(String word:dictionary){\\n            String encrypted=encrypt(word);\\n            if(null!=encrypted)\\n                root.add(encrypted);\\n        }\\n    }\\n    public String encrypt(String word1) {\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<word1.length();i++){\\n            if(charMap.get(word1.charAt(i))==null)\\n                return null;\\n            sb.append(charMap.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    public int decrypt(String word2) {\\n        TrieNode p=root;\\n        for(int i=0;i<word2.length();i++){\\n            p=p.letter[word2.charAt(i)-97];\\n            if(p==null)\\n                return 0;\\n        }\\n        return p.count;\\n    }\\n}\\n```\\nQueries and discussions regarding the implementation are most welcome.",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Trie"
                ],
                "code": "```\\nclass Encrypter {\\n    class TrieNode{\\n        int count;\\n        TrieNode[] letter;\\n        public TrieNode(){\\n            letter=new TrieNode[26];\\n            count=0;\\n        }\\n        \\n        public void add(String s){\\n            TrieNode p=this;\\n            for(int i=0;i<s.length();i++){\\n                char ch=s.charAt(i);\\n                if(p.letter[ch-97]==null){\\n                    p.letter[ch-97]=new TrieNode();\\n                }\\n                p=p.letter[ch-97];\\n            }\\n            p.count++;\\n        }\\n        \\n    }\\n    Map<Character,String> charMap;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        charMap=new HashMap<>();\\n        root=new TrieNode();\\n        for(int i=0;i<keys.length;i++){\\n            charMap.put(keys[i],values[i]);\\n        }\\n        for(String word:dictionary){\\n            String encrypted=encrypt(word);\\n            if(null!=encrypted)\\n                root.add(encrypted);\\n        }\\n    }\\n    public String encrypt(String word1) {\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<word1.length();i++){\\n            if(charMap.get(word1.charAt(i))==null)\\n                return null;\\n            sb.append(charMap.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    public int decrypt(String word2) {\\n        TrieNode p=root;\\n        for(int i=0;i<word2.length();i++){\\n            p=p.letter[word2.charAt(i)-97];\\n            if(p==null)\\n                return 0;\\n        }\\n        return p.count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908851,
                "title": "c-short-hash-map",
                "content": "\\n\\nSee my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n\\n## Solution 1. Hash Map\\n\\n`encrypt` is straightforward. For `decrypt`, we can precompute ans store the frequencies of encrypted permitted value strings in a map `freq`, and return `freq[word]` in `decrypt`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/encrypt-and-decrypt-strings/\\n// Author: github.com/lzl124631x\\n// Time:\\n//      Encrypter: O(K + V + D) where `K` is the length of `keys`, `V` and `D` are the sizes of all the contents in `values` and `dict`, respectively.\\n//      encrypt: O(W) where `W` is the length of the input word\\n//      decrypt: O(W)\\n// Space: O(K + V + D)\\nclass Encrypter {\\n    unordered_map<char, string> m; // mapping from character keys to corresponding value strings\\n    unordered_map<string, int> freq; // frequency map of encrypted permitted original strings\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i) {\\n            m[keys[i]] = values[i];\\n        }\\n        for (auto &s : dictionary) {\\n            auto e = encrypt(s);\\n            if (e.size()) freq[e]++;\\n        }\\n    }\\n    string encrypt(string s) {\\n        string ans;\\n        for (char c : s) {\\n            if (m.count(c) == 0) return \"\"; // invalid key character met, return empty string.\\n            ans += m[c];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string s) {\\n        return freq.count(s) ? freq[s] : 0;\\n    }\\n};\\n```\\n\\nThe problem didn\\'t say clearly whether a permitted original string might include unsupported keys. If it might include, then we need to consider the following testcase:\\n\\n```\\n[\"Encrypter\",\"decrypt\"]\\n[[[\"a\"],[\"pq\"],[\"a\",\"ax\"]],[\"pq\"]]\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/encrypt-and-decrypt-strings/\\n// Author: github.com/lzl124631x\\n// Time:\\n//      Encrypter: O(K + V + D) where `K` is the length of `keys`, `V` and `D` are the sizes of all the contents in `values` and `dict`, respectively.\\n//      encrypt: O(W) where `W` is the length of the input word\\n//      decrypt: O(W)\\n// Space: O(K + V + D)\\nclass Encrypter {\\n    unordered_map<char, string> m; // mapping from character keys to corresponding value strings\\n    unordered_map<string, int> freq; // frequency map of encrypted permitted original strings\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i) {\\n            m[keys[i]] = values[i];\\n        }\\n        for (auto &s : dictionary) {\\n            auto e = encrypt(s);\\n            if (e.size()) freq[e]++;\\n        }\\n    }\\n    string encrypt(string s) {\\n        string ans;\\n        for (char c : s) {\\n            if (m.count(c) == 0) return \"\"; // invalid key character met, return empty string.\\n            ans += m[c];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string s) {\\n        return freq.count(s) ? freq[s] : 0;\\n    }\\n};\\n```\n```\\n[\"Encrypter\",\"decrypt\"]\\n[[[\"a\"],[\"pq\"],[\"a\",\"ax\"]],[\"pq\"]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979556,
                "title": "java-c-python-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***C++***\\n```class Encrypter {\\npublic:\\n    unordered_map<char,string> m;\\n    unordered_map<string,int> dict;\\n    // vector k is keys, vector v is values and vector d is dictionary\\n    Encrypter(vector<char>& k, vector<string>& v, vector<string>& d) {\\n        int n = k.size();\\n        // we store the key value pairs in an unordered_map m, so that encryption of a char takes O(1).\\n        for(int i=0;i<n;i++){\\n            m[k[i]] = v[i];\\n        }\\n        \\n        // we encrypt the strings in the vector d and store it\\'s count in an unordered_map dict.\\n        // so that we can directly say the count of decryptions for a string in O(1).\\n        n = d.size();\\n        for(int i=0;i<n;i++){\\n            string p = encrypt(d[i]);\\n            dict[p]++;\\n        }\\n    }\\n    \\n    string encrypt(string s) {\\n        // encrypt the string using key value pairs in unordered_map m\\n        int n = s.length();\\n        string p = \"\";\\n        for(int i=0;i<n;i++){\\n            if(m.find(s[i])==m.end()){\\n                return \"\";\\n            }\\n            p += m[s[i]];\\n        }\\n        return p;\\n    }\\n    \\n    int decrypt(string s) {\\n        if(dict.find(s)==dict.end()) return 0; // if not present in dict, return 0\\n        return dict[s]; // else return count.\\n    }\\n};\\n```\\n\\n***Java***\\n```\\nclass Encrypter {\\n    class TrieNode{\\n        int count;\\n        TrieNode[] letter;\\n        public TrieNode(){\\n            letter=new TrieNode[26];\\n            count=0;\\n        }\\n        \\n        public void add(String s){\\n            TrieNode p=this;\\n            for(int i=0;i<s.length();i++){\\n                char ch=s.charAt(i);\\n                if(p.letter[ch-97]==null){\\n                    p.letter[ch-97]=new TrieNode();\\n                }\\n                p=p.letter[ch-97];\\n            }\\n            p.count++;\\n        }\\n        \\n    }\\n    Map<Character,String> charMap;\\n    Map<String,Set<Character>> valueMap;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        charMap=new HashMap<>();\\n        valueMap=new HashMap<>();\\n        root=new TrieNode();\\n        for(int i=0;i<keys.length;i++){\\n            charMap.put(keys[i],values[i]);\\n            valueMap.computeIfAbsent(values[i],key->new HashSet<>()).add(keys[i]);\\n        }\\n        for(String word:dictionary){\\n            String encrypted=encrypt(word);\\n            if(null!=encrypted)\\n                root.add(encrypted);\\n        }\\n    }\\n    public String encrypt(String word1) {\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<word1.length();i++){\\n            if(charMap.get(word1.charAt(i))==null)\\n                return null;\\n            sb.append(charMap.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    public int decrypt(String word2) {\\n        TrieNode p=root;\\n        for(int i=0;i<word2.length();i++){\\n            p=p.letter[word2.charAt(i)-97];\\n            if(p==null)\\n                return 0;\\n        }\\n        return p.count;\\n    }\\n}\\n```\\n\\n***Python***\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.hashmap = dict()\\n        for i in range(len(keys)):\\n            self.hashmap[keys[i]] = values[i]\\n        self.dictmap = defaultdict(int)\\n        for word in dictionary:\\n            self.dictmap[self.encrypt(word)] += 1\\n\\n    def encrypt(self, word1: str) -> str:\\n        output = \\'\\'\\n        for char in word1:\\n            output += self.hashmap[char]\\n        return output\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.dictmap[word2]\\n```\\n\\n***Consider upvote if useful!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```class Encrypter {\\npublic:\\n    unordered_map<char,string> m;\\n    unordered_map<string,int> dict;\\n    // vector k is keys, vector v is values and vector d is dictionary\\n    Encrypter(vector<char>& k, vector<string>& v, vector<string>& d) {\\n        int n = k.size();\\n        // we store the key value pairs in an unordered_map m, so that encryption of a char takes O(1).\\n        for(int i=0;i<n;i++){\\n            m[k[i]] = v[i];\\n        }\\n        \\n        // we encrypt the strings in the vector d and store it\\'s count in an unordered_map dict.\\n        // so that we can directly say the count of decryptions for a string in O(1).\\n        n = d.size();\\n        for(int i=0;i<n;i++){\\n            string p = encrypt(d[i]);\\n            dict[p]++;\\n        }\\n    }\\n    \\n    string encrypt(string s) {\\n        // encrypt the string using key value pairs in unordered_map m\\n        int n = s.length();\\n        string p = \"\";\\n        for(int i=0;i<n;i++){\\n            if(m.find(s[i])==m.end()){\\n                return \"\";\\n            }\\n            p += m[s[i]];\\n        }\\n        return p;\\n    }\\n    \\n    int decrypt(string s) {\\n        if(dict.find(s)==dict.end()) return 0; // if not present in dict, return 0\\n        return dict[s]; // else return count.\\n    }\\n};\\n```\n```\\nclass Encrypter {\\n    class TrieNode{\\n        int count;\\n        TrieNode[] letter;\\n        public TrieNode(){\\n            letter=new TrieNode[26];\\n            count=0;\\n        }\\n        \\n        public void add(String s){\\n            TrieNode p=this;\\n            for(int i=0;i<s.length();i++){\\n                char ch=s.charAt(i);\\n                if(p.letter[ch-97]==null){\\n                    p.letter[ch-97]=new TrieNode();\\n                }\\n                p=p.letter[ch-97];\\n            }\\n            p.count++;\\n        }\\n        \\n    }\\n    Map<Character,String> charMap;\\n    Map<String,Set<Character>> valueMap;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        charMap=new HashMap<>();\\n        valueMap=new HashMap<>();\\n        root=new TrieNode();\\n        for(int i=0;i<keys.length;i++){\\n            charMap.put(keys[i],values[i]);\\n            valueMap.computeIfAbsent(values[i],key->new HashSet<>()).add(keys[i]);\\n        }\\n        for(String word:dictionary){\\n            String encrypted=encrypt(word);\\n            if(null!=encrypted)\\n                root.add(encrypted);\\n        }\\n    }\\n    public String encrypt(String word1) {\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<word1.length();i++){\\n            if(charMap.get(word1.charAt(i))==null)\\n                return null;\\n            sb.append(charMap.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    public int decrypt(String word2) {\\n        TrieNode p=root;\\n        for(int i=0;i<word2.length();i++){\\n            p=p.letter[word2.charAt(i)-97];\\n            if(p==null)\\n                return 0;\\n        }\\n        return p.count;\\n    }\\n}\\n```\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.hashmap = dict()\\n        for i in range(len(keys)):\\n            self.hashmap[keys[i]] = values[i]\\n        self.dictmap = defaultdict(int)\\n        for word in dictionary:\\n            self.dictmap[self.encrypt(word)] += 1\\n\\n    def encrypt(self, word1: str) -> str:\\n        output = \\'\\'\\n        for char in word1:\\n            output += self.hashmap[char]\\n        return output\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.dictmap[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961804,
                "title": "python3-hash-table-freq-table",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/f2b4a5c0268eb27201b136764bb0b6ad3880c6f6) for solutions of weekly 287.\\n\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.mp = dict(zip(keys, values))\\n        self.freq = Counter(map(self.encrypt, dictionary))\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join(self.mp.get(ch, \"##\") for ch in word1)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.freq[word2]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.mp = dict(zip(keys, values))\\n        self.freq = Counter(map(self.encrypt, dictionary))\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join(self.mp.get(ch, \"##\") for ch in word1)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.freq[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909284,
                "title": "c-hashmap-based-solution-why-is-this-problem-marked-as-hard",
                "content": "```\\nclass Encrypter {\\npublic:\\n    map<string, int> cnt;\\n    map<char, string> kv;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dict) {\\n        \\n        for(int i=0; i<keys.size(); i++)\\n            kv[keys[i]]=values[i];\\n        \\n        for(auto d : dict)\\n            cnt[encrypt(d)]++;\\n    }\\n    \\n    string encrypt(string word1) {\\n        string encp;\\n        for(auto c : word1)\\n            encp+=kv[c];\\n        return encp;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return cnt[word2];\\n    }\\n};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    map<string, int> cnt;\\n    map<char, string> kv;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dict) {\\n        \\n        for(int i=0; i<keys.size(); i++)\\n            kv[keys[i]]=values[i];\\n        \\n        for(auto d : dict)\\n            cnt[encrypt(d)]++;\\n    }\\n    \\n    string encrypt(string word1) {\\n        string encp;\\n        for(auto c : word1)\\n            encp+=kv[c];\\n        return encp;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return cnt[word2];\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 1909054,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Encrypter {\\npublic:\\n    unordered_set<string> dict;\\n    unordered_map<char,string> en;\\n    unordered_map<string,vector<char>> dy;\\n   \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(auto& t:dictionary)\\n         {   dict.insert(t);}\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            char c=keys[i];\\n            string s=values[i];\\n            en[c]=s;\\n            dy[s].push_back(c);\\n        }\\n        \\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans=\"\";\\n        for(char c:word1)\\n        {\\n            ans+=en[c];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int cnt=0;\\n        for(auto t:dict)\\n        {\\n            string ans=\"\";\\n            for(int i=0;i<t.size();i++)\\n            {\\n                ans+=en[t[i]];\\n            }\\n            if(ans==word2)\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n \\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_set<string> dict;\\n    unordered_map<char,string> en;\\n    unordered_map<string,vector<char>> dy;\\n   \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(auto& t:dictionary)\\n         {   dict.insert(t);}\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            char c=keys[i];\\n            string s=values[i];\\n            en[c]=s;\\n            dy[s].push_back(c);\\n        }\\n        \\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans=\"\";\\n        for(char c:word1)\\n        {\\n            ans+=en[c];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int cnt=0;\\n        for(auto t:dict)\\n        {\\n            string ans=\"\";\\n            for(int i=0;i<t.size();i++)\\n            {\\n                ans+=en[t[i]];\\n            }\\n            if(ans==word2)\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908746,
                "title": "java-solution-using-hashmaps",
                "content": "```\\nclass Encrypter {\\n    Map<Character, String> map;\\n    Map<String, Integer> counts;\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        map = new HashMap<>();\\n        counts = new HashMap<>();\\n        \\n        for (int i = 0; i < keys.length; i++) {\\n            map.put(keys[i], values[i]);\\n        }\\n        \\n        for (int i = 0; i < dictionary.length; i++) {\\n            String dictionaryResult = encrypt(dictionary[i]);\\n            counts.put(dictionaryResult, counts.getOrDefault(dictionaryResult, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String result = \"\";\\n        \\n        for (int i = 0; i < word1.length(); i++) {\\n            char c = word1.charAt(i);\\n            result = result + map.get(c);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return counts.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Simulation"
                ],
                "code": "```\\nclass Encrypter {\\n    Map<Character, String> map;\\n    Map<String, Integer> counts;\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        map = new HashMap<>();\\n        counts = new HashMap<>();\\n        \\n        for (int i = 0; i < keys.length; i++) {\\n            map.put(keys[i], values[i]);\\n        }\\n        \\n        for (int i = 0; i < dictionary.length; i++) {\\n            String dictionaryResult = encrypt(dictionary[i]);\\n            counts.put(dictionaryResult, counts.getOrDefault(dictionaryResult, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String result = \"\";\\n        \\n        for (int i = 0; i < word1.length(); i++) {\\n            char c = word1.charAt(i);\\n            result = result + map.get(c);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return counts.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908740,
                "title": "python-trie-solution-and-explanation",
                "content": "**\\uD83D\\uDC46Please UPVOTE it if you find my soulutions are useful \\uD83D\\uDC46 Feel free to ask any question**\\n# [Python] \\uD83C\\uDF1F Trie Solution and Explanation \\uD83D\\uDC95\\n## 1\\uFE0F\\u20E3 Main Idea:\\n* key2Value:  It is a **one to one map** from key to value, so we could just creat a key2Value hashMap easily\\n* value2Key: It is a **one to many map** from value back to keys, so we use defaultdict(list) to store all keys\\n* trieDict: We build our dictionary in a trie, beacuse when we decrypt from value2Key. There are too many possible that could generate Memory Limit Exceed\\n\\tSo we could use a trie, once we found currChar is not in our currNode. We don\\'t have to traverse all remaining possible.\\n\\t\\n* **func buildTrie** : Init a trie = {}, iterate through all words in dictionary. And iterate through char in word to build a trie\\n* **encrypt**: Iterate through word1 to map all char to its value. And append it in res. Finnally stringfy res and return.\\n* **decrypt** : This is the hard part in this question\\n1. Find all posiible from value2Key: For example ```\"ei\" can map to \\'a\\' or \\'c\\', \"zf\" maps to \\'b\\', and \"am\" maps to \\'d\\'.``` ```So possible = [[a,c] , [b], [a,c], [d]]```\\n2. findInTrie: Given possibles, DFS search from possible in our self.trieDict. If current word is valid res += 1.\\n\\n## Code\\n\\n**Python**\\n```python\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        \\n        self.key2Value = {}\\n        for key, value in zip(keys, values):\\n            self.key2Value[key] = value\\n            \\n        self.value2Key = defaultdict(list)\\n        for key, value in zip(keys, values):\\n            self.value2Key[value].append(key)\\n            \\n        self.trieDict = self.buildTrie(dictionary)\\n        \\n    def buildTrie(self, dictionary):\\n        trie = {}\\n        for word in dictionary:\\n            currNode = trie\\n            for s in word:\\n                if s not in currNode:\\n                    currNode[s] = {}\\n                currNode = currNode[s]\\n            currNode[\"*\"] = word\\n        return trie\\n    \\n    def encrypt(self, word1: str) -> str:\\n        res = []\\n        for char in word1:\\n            res.append(self.key2Value[char])\\n        return \"\".join(res)\\n\\n    def decrypt(self, word2: str) -> int:\\n        # 1. Find all posiible from value2Key \\n        idx = 0\\n        possible = []\\n        while idx < len(word2):\\n            value = word2[idx:idx+2]\\n            possible.append(self.value2Key[value])\\n            idx += 2\\n        # 2. Given possible, see if a possilbe is valid in trie\\n        return self.findInTrie(possible, 0, self.trieDict)\\n        \\n        \\n    def findInTrie(self, possible, idx, currNode):\\n        res = 0\\n        if idx == len(possible):\\n            if \"*\" in currNode:\\n                return 1\\n            return 0\\n        for char in possible[idx]:\\n            if char in currNode:\\n                res += self.findInTrie(possible, idx + 1, currNode[char])\\n        return res\\n```\\n\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)",
                "solutionTags": [],
                "code": "```\"ei\" can map to \\'a\\' or \\'c\\', \"zf\" maps to \\'b\\', and \"am\" maps to \\'d\\'.```\n```So possible = [[a,c] , [b], [a,c], [d]]```\n```python\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        \\n        self.key2Value = {}\\n        for key, value in zip(keys, values):\\n            self.key2Value[key] = value\\n            \\n        self.value2Key = defaultdict(list)\\n        for key, value in zip(keys, values):\\n            self.value2Key[value].append(key)\\n            \\n        self.trieDict = self.buildTrie(dictionary)\\n        \\n    def buildTrie(self, dictionary):\\n        trie = {}\\n        for word in dictionary:\\n            currNode = trie\\n            for s in word:\\n                if s not in currNode:\\n                    currNode[s] = {}\\n                currNode = currNode[s]\\n            currNode[\"*\"] = word\\n        return trie\\n    \\n    def encrypt(self, word1: str) -> str:\\n        res = []\\n        for char in word1:\\n            res.append(self.key2Value[char])\\n        return \"\".join(res)\\n\\n    def decrypt(self, word2: str) -> int:\\n        # 1. Find all posiible from value2Key \\n        idx = 0\\n        possible = []\\n        while idx < len(word2):\\n            value = word2[idx:idx+2]\\n            possible.append(self.value2Key[value])\\n            idx += 2\\n        # 2. Given possible, see if a possilbe is valid in trie\\n        return self.findInTrie(possible, 0, self.trieDict)\\n        \\n        \\n    def findInTrie(self, possible, idx, currNode):\\n        res = 0\\n        if idx == len(possible):\\n            if \"*\" in currNode:\\n                return 1\\n            return 0\\n        for char in possible[idx]:\\n            if char in currNode:\\n                res += self.findInTrie(possible, idx + 1, currNode[char])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775969,
                "title": "c-easy-faster",
                "content": "\\n\\n# Code\\n```\\nclass Encrypter {\\npublic:\\n   unordered_map<char, string> enc;\\n    unordered_map<string, int> count;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i)\\n            enc[keys[i]] = values[i];\\n        for (string& w: dictionary)\\n            count[encrypt(w)]++;\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res = \"\";\\n        for (char c: word1) {\\n        \\tif (!enc.count(c)) return \"\";\\n            res += enc[c];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return count[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n   unordered_map<char, string> enc;\\n    unordered_map<string, int> count;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i)\\n            enc[keys[i]] = values[i];\\n        for (string& w: dictionary)\\n            count[encrypt(w)]++;\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res = \"\";\\n        for (char c: word1) {\\n        \\tif (!enc.count(c)) return \"\";\\n            res += enc[c];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return count[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909590,
                "title": "easiest-hard-probelm-logic-complexity-analysis-c",
                "content": "## **Solution**\\n\\n\\n#### **LOGIC**\\n* Map vector ```keys``` to ```values``` so that we do not need to loop through ```keys``` to find correct value.\\n* ```dictionary``` is having all decrypted string, so we will encrypt them and see if the result match to the ```word2``` if so, then increase ```sol``` by 1.\\n* If you crete all decrypted string from ```word2``` and then try to look ```dictionary``` for that valuse. then it will make it very complex in term of code and time.\\n\\n\\n#### **Code**  \\n```cpp\\nclass Encrypter {\\npublic:\\n    unordered_map<char, string> mp1;\\n    vector<string> dictionary;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        this->dictionary = dictionary;\\n        for (int i = 0; i < keys.size(); i++) {\\n            mp1[keys[i]] =  values[i];\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string sol = \"\";\\n        for (auto x : word1) {\\n            sol += mp1[x];\\n        }\\n        return sol;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int sol = 0;\\n        \\n        for (auto x : this->dictionary) {\\n            if (encrypt(x) == word2) {\\n                sol++;\\n            }\\n        }\\n        \\n        return sol;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```\\n\\n## **Complexity**\\n\\n##### __Apporach : 1__  \\n##### Time Complexity:  \\n* __Encrypter__:  __O(size_of_keys)__\\n* __encrypt__:  __O(size_of_word1)__\\n* __decrypt__:  __O(size_of_dictionary)__\\n\\n##### Space Complexity:\\n* __O(size_of_dictionary)__\\n\\n\\n<br>\\n\\n __Check out all [my](https://leetcode.com/siddp6/) recent solutions [here](https://github.com/sidd6p/LeetCode)__\\n\\n \\n __Feel Free to Ask Doubts\\nAnd Please Share Some Suggestions\\nHAPPY CODING :)__\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```keys```\n```values```\n```keys```\n```dictionary```\n```word2```\n```sol```\n```word2```\n```dictionary```\n```cpp\\nclass Encrypter {\\npublic:\\n    unordered_map<char, string> mp1;\\n    vector<string> dictionary;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        this->dictionary = dictionary;\\n        for (int i = 0; i < keys.size(); i++) {\\n            mp1[keys[i]] =  values[i];\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string sol = \"\";\\n        for (auto x : word1) {\\n            sol += mp1[x];\\n        }\\n        return sol;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int sol = 0;\\n        \\n        for (auto x : this->dictionary) {\\n            if (encrypt(x) == word2) {\\n                sol++;\\n            }\\n        }\\n        \\n        return sol;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909251,
                "title": "elegant-pythonic-solution",
                "content": "The `encrypt` is the easiest part of the problem. Create a mapping and you are done.  The `decrypt` and `dictionary` values is a little tricky to figure out and we have basically have to create an inverse frequency map for this.\\n\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.encrypt_map = {k: v for k, v in zip(keys, values)}\\n        self.decrypt_map = Counter()\\n        \\n        for word in dictionary:\\n            res = self.encrypt(word)\\n            self.decrypt_map[res] += 1\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join([self.encrypt_map[letter] for letter in word1])\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.decrypt_map[word2]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.encrypt_map = {k: v for k, v in zip(keys, values)}\\n        self.decrypt_map = Counter()\\n        \\n        for word in dictionary:\\n            res = self.encrypt(word)\\n            self.decrypt_map[res] += 1\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join([self.encrypt_map[letter] for letter in word1])\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.decrypt_map[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909075,
                "title": "python-easy-understanding-python-solution",
                "content": "After 1 hour struggled with dp and trie. The question tend to be solved as simple as this \\nLOL\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.keydic = {e:i for i,e in enumerate(keys)}\\n        self.values = values\\n        self.dictionary = set(dictionary)\\n\\n    def encrypt(self, word1: str) -> str:\\n        res = \\'\\'\\n        for c in word1:\\n            res += self.values[self.keydic[c]]\\n        return res\\n        \\n\\n    def decrypt(self, word2: str) -> int:\\n        res = 0\\n        \\n        for item in self.dictionary:\\n            if self.encrypt(item) == word2:\\n                res += 1\\n        return res\\n```\\n\\nHere I also  post my Trie + Dp solution, but it is exceed the time limit. I would appricate if anyone could helpe me optimize the solution.\\n\\n```\\nclass Trie:\\n    def __init__(self):\\n        self.child = {}\\n    \\n    def add(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.child:\\n                cur.child[c] = Trie()\\n            cur = cur.child[c]\\n        \\n        if \\'#\\' not in cur.child:\\n            cur.child[\\'#\\'] = \\'#\\'\\n    \\n    def find(self, word):\\n        cur = self \\n        \\n        for c in word:\\n            if c not in cur.child:\\n                return False\\n            cur = cur.child[c]\\n        \\n        return True \\n    \\n    def findExact(self, word):\\n        cur = self \\n        \\n        for c in word:\\n            if c not in cur.child:\\n                return False\\n            cur = cur.child[c]\\n        return \\'#\\' in cur.child \\n\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.keydic = {e:i for i,e in enumerate(keys)}\\n        self.values = values\\n        self.trie = Trie()\\n        \\n        for word in dictionary:\\n            self.trie.add(word)\\n            \\n        self.map = defaultdict(list)\\n        \\n        for key, enco in zip(keys, values): # build the map from the eco to the initial word\\n            self.map[enco].append(key)\\n        \\n\\n    def encrypt(self, word1: str) -> str:\\n        res = \\'\\'\\n        for c in word1:\\n            res += self.values[self.keydic[c]]\\n        return res\\n        \\n\\n    def decrypt(self, word2: str) -> int:\\n        chunks, chunk_size = len(word2), 2\\n        word = [ word2[i:i+chunk_size] for i in range(0, chunks, chunk_size)]\\n        size = len(word)\\n        dp = [[] for _ in range(size)]\\n        \\n        res  = 0\\n        for i in range(size):\\n            enco = word[i]\\n            if i == 0:\\n                for item in self.map[enco]:\\n                    if self.trie.find(item):\\n                        if i == size -1:\\n                            if \\'#\\' in self.trie.child[item].child:\\n                                res += 1\\n                        else:       \\n                            dp[i].append((item,self.trie.child[item]))\\n            else :\\n                for prev,pointer in dp[i-1]:\\n                    for curc in self.map[enco]:\\n                        if pointer.find(curc):\\n                            if i == size -1:\\n                                if \\'#\\' in pointer.child[curc].child:\\n                                    res += 1\\n                            else:\\n                                dp[i].append((prev + curc,pointer.child[curc]))\\n        return res     \\n\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.keydic = {e:i for i,e in enumerate(keys)}\\n        self.values = values\\n        self.dictionary = set(dictionary)\\n\\n    def encrypt(self, word1: str) -> str:\\n        res = \\'\\'\\n        for c in word1:\\n            res += self.values[self.keydic[c]]\\n        return res\\n        \\n\\n    def decrypt(self, word2: str) -> int:\\n        res = 0\\n        \\n        for item in self.dictionary:\\n            if self.encrypt(item) == word2:\\n                res += 1\\n        return res\\n```\n```\\nclass Trie:\\n    def __init__(self):\\n        self.child = {}\\n    \\n    def add(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.child:\\n                cur.child[c] = Trie()\\n            cur = cur.child[c]\\n        \\n        if \\'#\\' not in cur.child:\\n            cur.child[\\'#\\'] = \\'#\\'\\n    \\n    def find(self, word):\\n        cur = self \\n        \\n        for c in word:\\n            if c not in cur.child:\\n                return False\\n            cur = cur.child[c]\\n        \\n        return True \\n    \\n    def findExact(self, word):\\n        cur = self \\n        \\n        for c in word:\\n            if c not in cur.child:\\n                return False\\n            cur = cur.child[c]\\n        return \\'#\\' in cur.child \\n\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.keydic = {e:i for i,e in enumerate(keys)}\\n        self.values = values\\n        self.trie = Trie()\\n        \\n        for word in dictionary:\\n            self.trie.add(word)\\n            \\n        self.map = defaultdict(list)\\n        \\n        for key, enco in zip(keys, values): # build the map from the eco to the initial word\\n            self.map[enco].append(key)\\n        \\n\\n    def encrypt(self, word1: str) -> str:\\n        res = \\'\\'\\n        for c in word1:\\n            res += self.values[self.keydic[c]]\\n        return res\\n        \\n\\n    def decrypt(self, word2: str) -> int:\\n        chunks, chunk_size = len(word2), 2\\n        word = [ word2[i:i+chunk_size] for i in range(0, chunks, chunk_size)]\\n        size = len(word)\\n        dp = [[] for _ in range(size)]\\n        \\n        res  = 0\\n        for i in range(size):\\n            enco = word[i]\\n            if i == 0:\\n                for item in self.map[enco]:\\n                    if self.trie.find(item):\\n                        if i == size -1:\\n                            if \\'#\\' in self.trie.child[item].child:\\n                                res += 1\\n                        else:       \\n                            dp[i].append((item,self.trie.child[item]))\\n            else :\\n                for prev,pointer in dp[i-1]:\\n                    for curc in self.map[enco]:\\n                        if pointer.find(curc):\\n                            if i == size -1:\\n                                if \\'#\\' in pointer.child[curc].child:\\n                                    res += 1\\n                            else:\\n                                dp[i].append((prev + curc,pointer.child[curc]))\\n        return res     \\n\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908808,
                "title": "c-hashmap-trie-dp-dfs",
                "content": "```C++\\nstruct Trie {\\n    Trie* next[26];\\n    bool eof = false;\\n    Trie() {memset(next,0,sizeof(next));}\\n    void insert(string& s, int p) {\\n        if(p == s.length()) eof = true;\\n        else {\\n            if(!next[s[p]-\\'a\\']) next[s[p]-\\'a\\'] = new Trie();\\n            next[s[p]-\\'a\\']->insert(s, p + 1);\\n        }\\n    }\\n};\\nclass Encrypter {\\n    unordered_map<char, int> k;\\n    vector<string> v;\\n    unordered_map<string, unordered_set<char>> mpv;\\n    Trie* t, *rt;\\n\\n    vector<pair<bool, vector<Trie*>>> DP;\\n    vector<bool> vis;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        t = new Trie();\\n        rt = new Trie();\\n        v = values;\\n\\n        for(int i = 0; i < keys.size(); i++)\\n            k[keys[i]] = i;\\n        for(int i = 0; i < values.size(); i++)\\n            mpv[values[i]].insert(keys[i]);\\n        for(auto& v : values)\\n            t->insert(v, 0);\\n        for(auto& d : dictionary) {\\n            auto rd = d;\\n            reverse(rd.begin(), rd.end());\\n            rt->insert(rd, 0);\\n        }\\n    }\\n\\n    string encrypt(string word1) {\\n        stringstream ss;\\n        for(auto& w : word1) {\\n            ss<<v[k[w]];\\n        }\\n        return ss.str();\\n    }\\n\\n    int decrypt(string word2) {\\n        int n = word2.length();\\n        DP = vector<pair<bool, vector<Trie*>>>(n + 1, {false, {}});\\n        DP.back() = {true, {rt}};\\n\\n        vis = vector<bool>(n + 1, false);\\n        vis.back() = true;\\n\\n        auto [_, s] = helper(word2, 0);\\n        int res = 0;\\n        for(auto& rtrie : s) {\\n            res += rtrie->eof;\\n        }\\n\\n        return res;\\n    }\\n\\n    pair<bool,vector<Trie*>> helper(string& w, int p) {\\n        if(vis[p]) return DP[p];\\n        vis[p] = true;\\n        string ss;\\n        vector<Trie*> res;\\n        Trie* trie = t;\\n        bool PO = false;\\n        for(int i = p; i < w.length(); i++) {\\n            if(!trie->next[w[i]-\\'a\\']) break;\\n\\n            trie = trie->next[w[i]-\\'a\\'];\\n            ss += w[i];\\n            if(!trie->eof) continue;\\n            auto [po, comb] = helper(w, i + 1);\\n            if(!po) continue;\\n\\n            for(auto& rtrie : comb) {\\n                for(auto ch : mpv[ss]) {\\n                    if(!rtrie->next[ch-\\'a\\']) continue;\\n                    PO = true;\\n                    Trie* nrt = rtrie->next[ch-\\'a\\'];\\n                    res.push_back(nrt);\\n                }\\n            }\\n        }\\n        return DP[p] = {PO, res};\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n\\n```",
                "solutionTags": [],
                "code": "```C++\\nstruct Trie {\\n    Trie* next[26];\\n    bool eof = false;\\n    Trie() {memset(next,0,sizeof(next));}\\n    void insert(string& s, int p) {\\n        if(p == s.length()) eof = true;\\n        else {\\n            if(!next[s[p]-\\'a\\']) next[s[p]-\\'a\\'] = new Trie();\\n            next[s[p]-\\'a\\']->insert(s, p + 1);\\n        }\\n    }\\n};\\nclass Encrypter {\\n    unordered_map<char, int> k;\\n    vector<string> v;\\n    unordered_map<string, unordered_set<char>> mpv;\\n    Trie* t, *rt;\\n\\n    vector<pair<bool, vector<Trie*>>> DP;\\n    vector<bool> vis;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        t = new Trie();\\n        rt = new Trie();\\n        v = values;\\n\\n        for(int i = 0; i < keys.size(); i++)\\n            k[keys[i]] = i;\\n        for(int i = 0; i < values.size(); i++)\\n            mpv[values[i]].insert(keys[i]);\\n        for(auto& v : values)\\n            t->insert(v, 0);\\n        for(auto& d : dictionary) {\\n            auto rd = d;\\n            reverse(rd.begin(), rd.end());\\n            rt->insert(rd, 0);\\n        }\\n    }\\n\\n    string encrypt(string word1) {\\n        stringstream ss;\\n        for(auto& w : word1) {\\n            ss<<v[k[w]];\\n        }\\n        return ss.str();\\n    }\\n\\n    int decrypt(string word2) {\\n        int n = word2.length();\\n        DP = vector<pair<bool, vector<Trie*>>>(n + 1, {false, {}});\\n        DP.back() = {true, {rt}};\\n\\n        vis = vector<bool>(n + 1, false);\\n        vis.back() = true;\\n\\n        auto [_, s] = helper(word2, 0);\\n        int res = 0;\\n        for(auto& rtrie : s) {\\n            res += rtrie->eof;\\n        }\\n\\n        return res;\\n    }\\n\\n    pair<bool,vector<Trie*>> helper(string& w, int p) {\\n        if(vis[p]) return DP[p];\\n        vis[p] = true;\\n        string ss;\\n        vector<Trie*> res;\\n        Trie* trie = t;\\n        bool PO = false;\\n        for(int i = p; i < w.length(); i++) {\\n            if(!trie->next[w[i]-\\'a\\']) break;\\n\\n            trie = trie->next[w[i]-\\'a\\'];\\n            ss += w[i];\\n            if(!trie->eof) continue;\\n            auto [po, comb] = helper(w, i + 1);\\n            if(!po) continue;\\n\\n            for(auto& rtrie : comb) {\\n                for(auto ch : mpv[ss]) {\\n                    if(!rtrie->next[ch-\\'a\\']) continue;\\n                    PO = true;\\n                    Trie* nrt = rtrie->next[ch-\\'a\\'];\\n                    res.push_back(nrt);\\n                }\\n            }\\n        }\\n        return DP[p] = {PO, res};\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908758,
                "title": "c-hashmap-set",
                "content": "Decryption: The dictionary of strings size is atmax 100. it\\'s better to encrypt each string in the dictionary and check whether it matches with the given string.\\n```\\nclass Encrypter {\\npublic:\\n    set<string> isInDictionary;\\n    vector<string> value;\\n    vector<int> keyIndex;\\n    unordered_map<char,string> keyToValueMap;\\n    \\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        \\n        //allocate space to store indices of each character in keys.\\n        keyIndex.resize(26,INT_MAX);\\n        \\n        int n=keys.size();\\n        for(int i=0;i<n;i++)\\n            keyIndex[keys[i]-\\'a\\']=i;\\n        \\n        //assign value to values vector.\\n        value=values;\\n        \\n        \\n        // store the corresponding value string of each character in keys.\\n        for(int i=0;i<n;i++)\\n            keyToValueMap[keys[i]]=values[i];\\n        \\n        //save the strings in dictionary in a map.\\n        for(auto str:dictionary)\\n            isInDictionary.insert(str);\\n    }\\n    \\n    string encrypt(string word1) {\\n        string encryptedStr;\\n        // retrieve each charater value string using the keyIndex of that character.\\n        for(auto ch:word1)\\n            encryptedStr+=value[keyIndex[ch-\\'a\\']];\\n        return encryptedStr;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int sz=word2.length();\\n        int count=0;\\n        // dictionary contains the decrypted strings since the dictionary size is 100.\\n        // traverse the dictionary and construct the corresponding encrypted string.\\n        for(string dictStr:isInDictionary){\\n            string enctryptedStr;\\n            //construct the encrypted string.\\n            for(auto ch:dictStr){\\n                //if there is no mapping for the character\\n                if(keyToValueMap.find(ch)==keyToValueMap.end())\\n                    return 0;\\n                enctryptedStr+=keyToValueMap[ch];\\n            }\\n\\t\\t\\t//increase the count if the encrypted string matches with word2.\\n            if(enctryptedStr==word2)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "Decryption: The dictionary of strings size is atmax 100. it\\'s better to encrypt each string in the dictionary and check whether it matches with the given string.\\n```\\nclass Encrypter {\\npublic:\\n    set<string> isInDictionary;\\n    vector<string> value;\\n    vector<int> keyIndex;\\n    unordered_map<char,string> keyToValueMap;\\n    \\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        \\n        //allocate space to store indices of each character in keys.\\n        keyIndex.resize(26,INT_MAX);\\n        \\n        int n=keys.size();\\n        for(int i=0;i<n;i++)\\n            keyIndex[keys[i]-\\'a\\']=i;\\n        \\n        //assign value to values vector.\\n        value=values;\\n        \\n        \\n        // store the corresponding value string of each character in keys.\\n        for(int i=0;i<n;i++)\\n            keyToValueMap[keys[i]]=values[i];\\n        \\n        //save the strings in dictionary in a map.\\n        for(auto str:dictionary)\\n            isInDictionary.insert(str);\\n    }\\n    \\n    string encrypt(string word1) {\\n        string encryptedStr;\\n        // retrieve each charater value string using the keyIndex of that character.\\n        for(auto ch:word1)\\n            encryptedStr+=value[keyIndex[ch-\\'a\\']];\\n        return encryptedStr;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int sz=word2.length();\\n        int count=0;\\n        // dictionary contains the decrypted strings since the dictionary size is 100.\\n        // traverse the dictionary and construct the corresponding encrypted string.\\n        for(string dictStr:isInDictionary){\\n            string enctryptedStr;\\n            //construct the encrypted string.\\n            for(auto ch:dictStr){\\n                //if there is no mapping for the character\\n                if(keyToValueMap.find(ch)==keyToValueMap.end())\\n                    return 0;\\n                enctryptedStr+=keyToValueMap[ch];\\n            }\\n\\t\\t\\t//increase the count if the encrypted string matches with word2.\\n            if(enctryptedStr==word2)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 4080996,
                "title": "very-simple-solution-try-catch-without-trie",
                "content": "# Code\\n```\\nclass Encrypter {\\n    String key_value[]=new String[26];\\n    HashMap<String, Integer> encrypted_dictionary=new HashMap<>();\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        int i=0;\\n        for(char key: keys) key_value[key-\\'a\\']=values[i++];\\n        \\n        for(String word: dictionary) {\\n            String encr=encrypt(word);\\n            if(encr==null) continue;\\n            encrypted_dictionary.put(encr, encrypted_dictionary.getOrDefault(encr, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        char[] res=new char[word1.length()*2];\\n        for(int i=0;i<word1.length();i++) {\\n            try{\\n                res[i*2]=key_value[word1.charAt(i)-\\'a\\'].charAt(0);\\n                res[i*2+1]=key_value[word1.charAt(i)-\\'a\\'].charAt(1);\\n            }catch(Exception e){\\n                return null;\\n            }\\n        }\\n        return new String(res);\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return encrypted_dictionary.getOrDefault(word2, 0);\\n    }\\n}\\n```\\n\\nThe Try catch block... its because I didnt want to mannually check for the error. Anyways, if a word causes problem, it wont be there in encrypted dictionary anyways... \\uD83D\\uDC4D\\uFE0F\\uD83D\\uDC4D\\uFE0F",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Encrypter {\\n    String key_value[]=new String[26];\\n    HashMap<String, Integer> encrypted_dictionary=new HashMap<>();\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        int i=0;\\n        for(char key: keys) key_value[key-\\'a\\']=values[i++];\\n        \\n        for(String word: dictionary) {\\n            String encr=encrypt(word);\\n            if(encr==null) continue;\\n            encrypted_dictionary.put(encr, encrypted_dictionary.getOrDefault(encr, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        char[] res=new char[word1.length()*2];\\n        for(int i=0;i<word1.length();i++) {\\n            try{\\n                res[i*2]=key_value[word1.charAt(i)-\\'a\\'].charAt(0);\\n                res[i*2+1]=key_value[word1.charAt(i)-\\'a\\'].charAt(1);\\n            }catch(Exception e){\\n                return null;\\n            }\\n        }\\n        return new String(res);\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return encrypted_dictionary.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544782,
                "title": "two-maps-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Encrypter {\\npublic:\\n    map<char,string> mp;\\n    map<string,int> decrypted;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i = 0; i < keys.size(); i++){\\n            mp[keys[i]] = values[i];\\n        }\\n        for(int i = 0; i < dictionary.size(); i++){\\n            decrypted[encrypt(dictionary[i])]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(int i = 0; i < word1.size(); i++){\\n            if(mp.find(word1[i]) == mp.end()){\\n                return \"\";\\n            }\\n            ans += mp[word1[i]];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n       if(decrypted.find(word2) == decrypted.end()){\\n           return 0;\\n       }\\n       return decrypted[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    map<char,string> mp;\\n    map<string,int> decrypted;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i = 0; i < keys.size(); i++){\\n            mp[keys[i]] = values[i];\\n        }\\n        for(int i = 0; i < dictionary.size(); i++){\\n            decrypted[encrypt(dictionary[i])]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(int i = 0; i < word1.size(); i++){\\n            if(mp.find(word1[i]) == mp.end()){\\n                return \"\";\\n            }\\n            ans += mp[word1[i]];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n       if(decrypted.find(word2) == decrypted.end()){\\n           return 0;\\n       }\\n       return decrypted[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2475098,
                "title": "java-trie-hashmap",
                "content": "```\\nclass Encrypter {\\n    class Node {\\n        Node[] child = new Node[26];\\n        boolean isEnd = false;\\n        String word;\\n        Node () {\\n            //  Default\\n        }\\n    }\\n    //  this map is requied for encrypting the string\\n    HashMap<Integer, List<String>> charMap = new HashMap<>();\\n    //  this map is required for decrypting the string (to get the next valid or possible \\n    //  characters of a string in dictionary)\\n    HashMap<String, List<Integer>> revMap = new HashMap<>();\\n    //  stores all string in dictionary\\n    HashSet<String> dict = new HashSet<>();\\n    //  root of the Trie\\n    Node root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for (String s : dictionary) {\\n            dict.add(s);\\n        }\\n        constructTrie(dictionary);\\n        for (int i = 0; i < keys.length; i++) {\\n            //  charMap\\n            if (!charMap.containsKey(keys[i] - \\'a\\')) {\\n                charMap.put(keys[i] - \\'a\\', new ArrayList<>());\\n            }\\n            charMap.get(keys[i] - \\'a\\').add(values[i]);\\n            //  revMap\\n            if (!revMap.containsKey(values[i])) {\\n                revMap.put(values[i], new ArrayList<>());\\n            }\\n            revMap.get(values[i]).add(keys[i] - \\'a\\');\\n        }\\n    }\\n    \\n    //  Trie for pruning (adding words on trie)\\n    private void constructTrie(String[] words) {\\n        root = new Node();\\n        for (String w : words) {\\n            Node curr = root;\\n            for (char c : w.toCharArray()) {\\n                if (curr.child[c - \\'a\\'] == null) {\\n                    curr.child[c - \\'a\\'] = new Node();\\n                }\\n                curr = curr.child[c - \\'a\\'];\\n            }\\n            curr.isEnd = true;\\n            curr.word = w;\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder answer = new StringBuilder(\"\");\\n        for (char c : word1.toCharArray()) {\\n            if (!charMap.containsKey(c - \\'a\\')) return \"\";\\n            answer.append(charMap.get(c - \\'a\\').get(0));\\n        }\\n        return answer.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        Node curr = root;\\n        return helper(word2, curr, 0);\\n    }\\n    \\n    private int helper(String s, Node curr, int currIdx) {\\n        if (currIdx == s.length()) {\\n            //  at the end of the string and checking if this is present in the dict\\n            return dict.contains(curr.word) ? 1 : 0;\\n        }\\n        String key = s.substring(currIdx, currIdx + 2);\\n        List<Integer> next = revMap.getOrDefault(key, new ArrayList<>());\\n        int count = 0;\\n        for (int c : next) {\\n            if (curr.child[c] != null) {\\n                count += helper(s, curr.child[c], currIdx + 2);\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\n    class Node {\\n        Node[] child = new Node[26];\\n        boolean isEnd = false;\\n        String word;\\n        Node () {\\n            //  Default\\n        }\\n    }\\n    //  this map is requied for encrypting the string\\n    HashMap<Integer, List<String>> charMap = new HashMap<>();\\n    //  this map is required for decrypting the string (to get the next valid or possible \\n    //  characters of a string in dictionary)\\n    HashMap<String, List<Integer>> revMap = new HashMap<>();\\n    //  stores all string in dictionary\\n    HashSet<String> dict = new HashSet<>();\\n    //  root of the Trie\\n    Node root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for (String s : dictionary) {\\n            dict.add(s);\\n        }\\n        constructTrie(dictionary);\\n        for (int i = 0; i < keys.length; i++) {\\n            //  charMap\\n            if (!charMap.containsKey(keys[i] - \\'a\\')) {\\n                charMap.put(keys[i] - \\'a\\', new ArrayList<>());\\n            }\\n            charMap.get(keys[i] - \\'a\\').add(values[i]);\\n            //  revMap\\n            if (!revMap.containsKey(values[i])) {\\n                revMap.put(values[i], new ArrayList<>());\\n            }\\n            revMap.get(values[i]).add(keys[i] - \\'a\\');\\n        }\\n    }\\n    \\n    //  Trie for pruning (adding words on trie)\\n    private void constructTrie(String[] words) {\\n        root = new Node();\\n        for (String w : words) {\\n            Node curr = root;\\n            for (char c : w.toCharArray()) {\\n                if (curr.child[c - \\'a\\'] == null) {\\n                    curr.child[c - \\'a\\'] = new Node();\\n                }\\n                curr = curr.child[c - \\'a\\'];\\n            }\\n            curr.isEnd = true;\\n            curr.word = w;\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder answer = new StringBuilder(\"\");\\n        for (char c : word1.toCharArray()) {\\n            if (!charMap.containsKey(c - \\'a\\')) return \"\";\\n            answer.append(charMap.get(c - \\'a\\').get(0));\\n        }\\n        return answer.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        Node curr = root;\\n        return helper(word2, curr, 0);\\n    }\\n    \\n    private int helper(String s, Node curr, int currIdx) {\\n        if (currIdx == s.length()) {\\n            //  at the end of the string and checking if this is present in the dict\\n            return dict.contains(curr.word) ? 1 : 0;\\n        }\\n        String key = s.substring(currIdx, currIdx + 2);\\n        List<Integer> next = revMap.getOrDefault(key, new ArrayList<>());\\n        int count = 0;\\n        for (int c : next) {\\n            if (curr.child[c] != null) {\\n                count += helper(s, curr.child[c], currIdx + 2);\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1956564,
                "title": "python-trie-and-hashmap",
                "content": "`@cache` helps a lot with same queries in test cases.\\n\\n# Trie\\n```python\\nclass TrieNode:\\n    def __init__(self, words: List[str] = None):\\n        self.children = {}\\n        self.a_word = False\\n        if words:\\n            for word in words:\\n                self.add(word)\\n\\n    def add(self, word: str):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n        cur.a_word = True\\n\\n\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.keylookup = {key: val for key, val in zip(keys, values)}\\n        self.vallookup = defaultdict(list)\\n        for i, val in enumerate(values):\\n            self.vallookup[val].append(keys[i])\\n        self.trie = TrieNode(dictionary)\\n\\n    @cache\\n    def encrypt(self, word1: str) -> str:\\n        ret = []\\n        for c in word1:\\n            if c not in self.keylookup:\\n                return \"\"\\n            ret.append(self.keylookup[c])\\n        return \"\".join(ret)\\n\\n    @cache\\n    def decrypt(self, word2: str) -> int:\\n        chunks = (word2[i : i + 2] for i in range(0, len(word2), 2))\\n        candidates = list(self.vallookup[s] for s in chunks)\\n        N = len(candidates)\\n\\n        def dfs(root: TrieNode, i):\\n            if i == N:\\n                return int(root.a_word)\\n\\n            count = 0\\n            for key in candidates[i]:\\n                if key in root.children:\\n                    count += dfs(root.children[key], i + 1)\\n\\n            return count\\n\\n        return dfs(self.trie, 0)\\n```\\n\\n# hashmap\\n```python\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.klookup = {key: val for key, val in zip(keys, values)}\\n        self.dlookup = Counter(self.encrypt(w) for w in dictionary)\\n\\n    @cache\\n    def encrypt(self, word1: str) -> str:\\n        ret = []\\n        for c in word1:\\n            if c not in self.klookup:\\n                return \"\"\\n            ret.append(self.klookup[c])\\n        return \"\".join(ret)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.dlookup[word2]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass TrieNode:\\n    def __init__(self, words: List[str] = None):\\n        self.children = {}\\n        self.a_word = False\\n        if words:\\n            for word in words:\\n                self.add(word)\\n\\n    def add(self, word: str):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n        cur.a_word = True\\n\\n\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.keylookup = {key: val for key, val in zip(keys, values)}\\n        self.vallookup = defaultdict(list)\\n        for i, val in enumerate(values):\\n            self.vallookup[val].append(keys[i])\\n        self.trie = TrieNode(dictionary)\\n\\n    @cache\\n    def encrypt(self, word1: str) -> str:\\n        ret = []\\n        for c in word1:\\n            if c not in self.keylookup:\\n                return \"\"\\n            ret.append(self.keylookup[c])\\n        return \"\".join(ret)\\n\\n    @cache\\n    def decrypt(self, word2: str) -> int:\\n        chunks = (word2[i : i + 2] for i in range(0, len(word2), 2))\\n        candidates = list(self.vallookup[s] for s in chunks)\\n        N = len(candidates)\\n\\n        def dfs(root: TrieNode, i):\\n            if i == N:\\n                return int(root.a_word)\\n\\n            count = 0\\n            for key in candidates[i]:\\n                if key in root.children:\\n                    count += dfs(root.children[key], i + 1)\\n\\n            return count\\n\\n        return dfs(self.trie, 0)\\n```\n```python\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.klookup = {key: val for key, val in zip(keys, values)}\\n        self.dlookup = Counter(self.encrypt(w) for w in dictionary)\\n\\n    @cache\\n    def encrypt(self, word1: str) -> str:\\n        ret = []\\n        for c in word1:\\n            if c not in self.klookup:\\n                return \"\"\\n            ret.append(self.klookup[c])\\n        return \"\".join(ret)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.dlookup[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942851,
                "title": "java-solution-faster-than-25-81-less-than-81-35",
                "content": "```\\n\\tMap<Character, String> kvMap = new HashMap<>();\\n    Map<String, List<Character>> vkMap = new HashMap<>();\\n    TrieNode root = new TrieNode();\\n    Map<String, Integer> cache = new HashMap<>();\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for (int i = 0, len = keys.length; i < len; ++i) {\\n            char key = keys[i];\\n            String value = values[i];\\n            kvMap.put(key, value);\\n            List<Character> characters = vkMap.getOrDefault(value, new ArrayList<>());\\n            characters.add(key);\\n            vkMap.put(value, characters);\\n        }\\n        for (String dic : dictionary) {\\n            build(root, dic);\\n        }\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : word1.toCharArray()) {\\n            String s = kvMap.get(c);\\n            if (s == null) {\\n                return \"\";\\n            }\\n            sb.append(s);\\n        }\\n        return sb.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        Integer integer = cache.get(word2);\\n        if (integer == null) {\\n            int dfs = dfs(word2, 0, new StringBuilder());\\n            cache.put(word2, dfs);\\n            return dfs;\\n        }\\n        return integer;\\n    }\\n\\n        private int dfs(String word2, int index, StringBuilder sb) {\\n        if (index == word2.length()) {\\n            return search(root, sb.toString(), 0) ? 1 : 0;\\n        }\\n        if (index > 0 && !searchPrefix(root, sb.toString(), 0)) {\\n             return 0;\\n        }\\n        int count = 0;\\n        String substr = word2.substring(index, index + 2);\\n        List<Character> characters = vkMap.get(substr);\\n        if (characters == null) {\\n            return 0;\\n        }\\n        for (Character c : characters) {\\n            sb.append(c);\\n            count += dfs(word2, index + 2, sb);\\n            sb.deleteCharAt(sb.length() - 1);\\n        }\\n        return count;\\n    }\\n\\n    private void build(TrieNode root, String word) {\\n        TrieNode curr = root;\\n        for (char c : word.toCharArray()) {\\n            Map<Character, TrieNode> children = curr.getChildren();\\n            TrieNode node = children.get(c);\\n            if (node == null) {\\n                node = new TrieNode();\\n                children.put(c, node);\\n            }\\n            curr = node;\\n        }\\n        curr.setWord(true);\\n    }\\n\\n    private boolean search(TrieNode root, String word, int index) {\\n        if (index == word.length()) {\\n            return false;\\n        }\\n        char c = word.charAt(index);\\n        TrieNode node = root.getChildren().get(c);\\n        if (node == null) {\\n            return false;\\n        }\\n        if (index == word.length() - 1 && node.isWord) {\\n            return true;\\n        }\\n        return search(node, word, index + 1);\\n    }\\n\\n    private boolean searchPrefix(TrieNode root, String word, int index) {\\n        if (index == word.length()) {\\n            return true;\\n        }\\n        char c = word.charAt(index);\\n        TrieNode node = root.getChildren().get(c);\\n        if (node == null) {\\n            return false;\\n        }\\n        return searchPrefix(node, word, index + 1);\\n    }\\n\\n    private static class TrieNode {\\n\\n        Map<Character, TrieNode> children = new HashMap<>();\\n        boolean isWord;\\n\\n        public Map<Character, TrieNode> getChildren() {\\n            return children;\\n        }\\n\\n        public void setChildren(Map<Character, TrieNode> children) {\\n            this.children = children;\\n        }\\n\\n        public boolean isWord() {\\n            return isWord;\\n        }\\n\\n        public void setWord(boolean word) {\\n            isWord = word;\\n        }\\n\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\n\\tMap<Character, String> kvMap = new HashMap<>();\\n    Map<String, List<Character>> vkMap = new HashMap<>();\\n    TrieNode root = new TrieNode();\\n    Map<String, Integer> cache = new HashMap<>();\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for (int i = 0, len = keys.length; i < len; ++i) {\\n            char key = keys[i];\\n            String value = values[i];\\n            kvMap.put(key, value);\\n            List<Character> characters = vkMap.getOrDefault(value, new ArrayList<>());\\n            characters.add(key);\\n            vkMap.put(value, characters);\\n        }\\n        for (String dic : dictionary) {\\n            build(root, dic);\\n        }\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : word1.toCharArray()) {\\n            String s = kvMap.get(c);\\n            if (s == null) {\\n                return \"\";\\n            }\\n            sb.append(s);\\n        }\\n        return sb.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        Integer integer = cache.get(word2);\\n        if (integer == null) {\\n            int dfs = dfs(word2, 0, new StringBuilder());\\n            cache.put(word2, dfs);\\n            return dfs;\\n        }\\n        return integer;\\n    }\\n\\n        private int dfs(String word2, int index, StringBuilder sb) {\\n        if (index == word2.length()) {\\n            return search(root, sb.toString(), 0) ? 1 : 0;\\n        }\\n        if (index > 0 && !searchPrefix(root, sb.toString(), 0)) {\\n             return 0;\\n        }\\n        int count = 0;\\n        String substr = word2.substring(index, index + 2);\\n        List<Character> characters = vkMap.get(substr);\\n        if (characters == null) {\\n            return 0;\\n        }\\n        for (Character c : characters) {\\n            sb.append(c);\\n            count += dfs(word2, index + 2, sb);\\n            sb.deleteCharAt(sb.length() - 1);\\n        }\\n        return count;\\n    }\\n\\n    private void build(TrieNode root, String word) {\\n        TrieNode curr = root;\\n        for (char c : word.toCharArray()) {\\n            Map<Character, TrieNode> children = curr.getChildren();\\n            TrieNode node = children.get(c);\\n            if (node == null) {\\n                node = new TrieNode();\\n                children.put(c, node);\\n            }\\n            curr = node;\\n        }\\n        curr.setWord(true);\\n    }\\n\\n    private boolean search(TrieNode root, String word, int index) {\\n        if (index == word.length()) {\\n            return false;\\n        }\\n        char c = word.charAt(index);\\n        TrieNode node = root.getChildren().get(c);\\n        if (node == null) {\\n            return false;\\n        }\\n        if (index == word.length() - 1 && node.isWord) {\\n            return true;\\n        }\\n        return search(node, word, index + 1);\\n    }\\n\\n    private boolean searchPrefix(TrieNode root, String word, int index) {\\n        if (index == word.length()) {\\n            return true;\\n        }\\n        char c = word.charAt(index);\\n        TrieNode node = root.getChildren().get(c);\\n        if (node == null) {\\n            return false;\\n        }\\n        return searchPrefix(node, word, index + 1);\\n    }\\n\\n    private static class TrieNode {\\n\\n        Map<Character, TrieNode> children = new HashMap<>();\\n        boolean isWord;\\n\\n        public Map<Character, TrieNode> getChildren() {\\n            return children;\\n        }\\n\\n        public void setChildren(Map<Character, TrieNode> children) {\\n            this.children = children;\\n        }\\n\\n        public boolean isWord() {\\n            return isWord;\\n        }\\n\\n        public void setWord(boolean word) {\\n            isWord = word;\\n        }\\n\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1930455,
                "title": "this-very-simple-solution-beats-80-while-trie-gets-tle",
                "content": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.kv = {k:v for k,v in zip(keys, values)}\\n        self.d = collections.Counter([self.encrypt(d) for d in dictionary])\\n        \\n    def encrypt(self, word1: str) -> str:\\n        res = \\'\\'\\n        for c in word1:\\n            if c not in self.kv: return \\'\\'\\n            res += self.kv[c]\\n        return res\\n\\n        \\n    def decrypt(self, word2: str) -> int:\\n        return self.d[word2]\\n            \\n        \\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.kv = {k:v for k,v in zip(keys, values)}\\n        self.d = collections.Counter([self.encrypt(d) for d in dictionary])\\n        \\n    def encrypt(self, word1: str) -> str:\\n        res = \\'\\'\\n        for c in word1:\\n            if c not in self.kv: return \\'\\'\\n            res += self.kv[c]\\n        return res\\n\\n        \\n    def decrypt(self, word2: str) -> int:\\n        return self.d[word2]\\n            \\n        \\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926788,
                "title": "simple-java-solution-with-2-maps",
                "content": "```\\nclass Encrypter {\\n    private Map<Character, String> enc = new HashMap<>();\\n    private Map<String, Integer> countMap = new HashMap<>();\\n    private static final String DEFAULT_ENCODE_STRING = \"#\";\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int idx = 0; idx < keys.length; idx++) {\\n            enc.put(keys[idx], values[idx]);\\n        }\\n        for (String word : dictionary) {\\n            String encryptString = encrypt(word);\\n            countMap.put(encryptString, countMap.getOrDefault(encryptString, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder result = new StringBuilder();\\n        for (int idx = 0; idx < word1.length(); idx++) {\\n            result.append(enc.getOrDefault(word1.charAt(idx), DEFAULT_ENCODE_STRING));\\n        }\\n        return result.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return countMap.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\n    private Map<Character, String> enc = new HashMap<>();\\n    private Map<String, Integer> countMap = new HashMap<>();\\n    private static final String DEFAULT_ENCODE_STRING = \"#\";\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int idx = 0; idx < keys.length; idx++) {\\n            enc.put(keys[idx], values[idx]);\\n        }\\n        for (String word : dictionary) {\\n            String encryptString = encrypt(word);\\n            countMap.put(encryptString, countMap.getOrDefault(encryptString, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder result = new StringBuilder();\\n        for (int idx = 0; idx < word1.length(); idx++) {\\n            result.append(enc.getOrDefault(word1.charAt(idx), DEFAULT_ENCODE_STRING));\\n        }\\n        return result.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return countMap.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920897,
                "title": "c-easy-to-understand-simple-solution-using-hashmap",
                "content": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string> mp1;\\n    vector<string> dic;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        int n=keys.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp1[keys[i]]=values[i];\\n        }\\n        dic=dictionary;\\n    }\\n    string encrypt(string word1) {\\n     string ans=\"\";\\n        for(char ch:word1)\\n        {\\n            if(mp1.find(ch)==mp1.end())\\n            return \"\";\\n            ans+=mp1[ch];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string word2) {\\n        int ans=0;\\n        for(auto str:dic)\\n        {\\n          if(encrypt(str)==word2)\\n          ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string> mp1;\\n    vector<string> dic;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        int n=keys.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp1[keys[i]]=values[i];\\n        }\\n        dic=dictionary;\\n    }\\n    string encrypt(string word1) {\\n     string ans=\"\";\\n        for(char ch:word1)\\n        {\\n            if(mp1.find(ch)==mp1.end())\\n            return \"\";\\n            ans+=mp1[ch];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string word2) {\\n        int ans=0;\\n        for(auto str:dic)\\n        {\\n          if(encrypt(str)==word2)\\n          ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920780,
                "title": "a-few-solutions",
                "content": "Encrypt each string `s` of the input array `A` as `t` and track the count `cnt` of each successfully encrypted `t`.  We use a map `m` to associate each `i`<sup>th</sup> input character of `C` with the corresponding `i`<sup>th</sup> input string of `S` for encryption.\\n\\nNote: we know the encryption successfully transforms input string `s` into output string `t` when the cardinality of `s` is equal to the cardinality of `t` divided evenly by `2` since each single character is encoded as two characters.\\n* `2 * |s| == |t|`\\n\\n---\\n\\n*Kotlin*\\n```\\ntypealias CA = CharArray\\ntypealias AS = Array<String>\\nclass Encrypter(C: CA, S: AS, A: AS) {\\n    private var m = mutableMapOf<Char, String>()\\n    private var cnt = mutableMapOf<String, Int>()\\n    var encrypt = { s: String -> s.toCharArray().map{ m[it] ?: \"\" }.joinToString(\"\") }\\n    var decrypt = { s: String -> cnt[s] ?: 0 }\\n    init {\\n        m = (C zip S).toMap().toMutableMap()\\n        for (s in A) {\\n            var t = encrypt(s)\\n            if (2 * s.length == t.length)\\n                cnt[t] = 1 + (cnt[t] ?: 0)\\n        }\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nclass Encrypter {\\n    constructor(C, S, A) {\\n        this.m = new Map(_.zip(C, S));\\n        this.cnt = new Map();\\n        for (let s of A) {\\n            let t = this.encrypt(s);\\n            if (2 * s.length == t.length)\\n                this.cnt.set(t, 1 + (this.cnt.get(t) || 0));\\n        }\\n    }\\n    encrypt = s => s.split(\\'\\').map(c => this.m.get(c) || \\'\\').join(\\'\\');\\n    decrypt = s => this.cnt.get(s) || 0;\\n}\\n```\\n\\n*Python3*\\n```\\nclass Encrypter:\\n    def __init__(self, C, S, A):\\n        self.m = { c: s for c, s in zip(C, S) }\\n        self.cnt = defaultdict(int)\\n        for s in A:\\n            t = self.encrypt(s)\\n            if 2 * len(s) == len(t):\\n                self.cnt[t] += 1\\n    encrypt = lambda self, s: \\'\\'.join(self.m[c] for c in list(s) if c in self.m)\\n    decrypt = lambda self, s: self.cnt[s]\\n```\\n\\n*Rust*\\n```\\nuse std::collections::HashMap;\\nstruct Encrypter {\\n    m: HashMap<char, String>,\\n    cnt: HashMap<String, i32>\\n}\\ntype VC = Vec<char>;\\ntype VS = Vec<String>;\\nimpl Encrypter {\\n    fn new(C: VC, S: VS, A: VS) -> Self {\\n        let mut m = HashMap::new();\\n        let mut cnt = HashMap::new();\\n        for (c, s) in C.iter().zip(S.iter()) {\\n            m.insert(*c, s.clone());\\n        }\\n        let mut me = Encrypter{ m, cnt };\\n        for s in A {\\n            let t = Self::encrypt(&mut me, s.clone());\\n            if 2 * s.len() == t.len() {\\n                *me.cnt.entry(t).or_insert(0) += 1;\\n            }\\n        }\\n        me\\n    }\\n    fn encrypt(&mut self, s: String) -> String {\\n        let mut t = String::new();\\n        for c in s.chars() {\\n            if let Some(x) = self.m.get(&c) {\\n                t.push_str(x.as_str());\\n            }\\n        }\\n        t\\n    }\\n    fn decrypt(&mut self, s: String) -> i32 {\\n        *self.cnt.entry(s).or_insert(0)\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Encrypter {\\npublic:\\n    using VC = vector<char>;\\n    using VS = vector<string>;\\n    using Map = unordered_map<char, string>;\\n    using Counter = unordered_map<string, int>;\\n    Map m;\\n    Counter cnt;\\n    Encrypter(VC& C, VS& S, VS& A) {\\n        for (auto i{ 0 }; i < C.size(); ++i)\\n            m[C[i]] = S[i];\\n        for (auto& s: A) {\\n            auto t = encrypt(s);\\n            if (2 * s.size() == t.size())\\n                ++cnt[t];\\n        }\\n    }\\n    string encrypt(string s) {\\n        ostringstream os;\\n        transform(s.begin(), s.end(), ostream_iterator<string>(os, \"\"), [&](auto c) { return m[c]; });\\n        return os.str();\\n    }\\n    int decrypt(string s) {\\n        return cnt[s];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypealias CA = CharArray\\ntypealias AS = Array<String>\\nclass Encrypter(C: CA, S: AS, A: AS) {\\n    private var m = mutableMapOf<Char, String>()\\n    private var cnt = mutableMapOf<String, Int>()\\n    var encrypt = { s: String -> s.toCharArray().map{ m[it] ?: \"\" }.joinToString(\"\") }\\n    var decrypt = { s: String -> cnt[s] ?: 0 }\\n    init {\\n        m = (C zip S).toMap().toMutableMap()\\n        for (s in A) {\\n            var t = encrypt(s)\\n            if (2 * s.length == t.length)\\n                cnt[t] = 1 + (cnt[t] ?: 0)\\n        }\\n    }\\n}\\n```\n```\\nclass Encrypter {\\n    constructor(C, S, A) {\\n        this.m = new Map(_.zip(C, S));\\n        this.cnt = new Map();\\n        for (let s of A) {\\n            let t = this.encrypt(s);\\n            if (2 * s.length == t.length)\\n                this.cnt.set(t, 1 + (this.cnt.get(t) || 0));\\n        }\\n    }\\n    encrypt = s => s.split(\\'\\').map(c => this.m.get(c) || \\'\\').join(\\'\\');\\n    decrypt = s => this.cnt.get(s) || 0;\\n}\\n```\n```\\nclass Encrypter:\\n    def __init__(self, C, S, A):\\n        self.m = { c: s for c, s in zip(C, S) }\\n        self.cnt = defaultdict(int)\\n        for s in A:\\n            t = self.encrypt(s)\\n            if 2 * len(s) == len(t):\\n                self.cnt[t] += 1\\n    encrypt = lambda self, s: \\'\\'.join(self.m[c] for c in list(s) if c in self.m)\\n    decrypt = lambda self, s: self.cnt[s]\\n```\n```\\nuse std::collections::HashMap;\\nstruct Encrypter {\\n    m: HashMap<char, String>,\\n    cnt: HashMap<String, i32>\\n}\\ntype VC = Vec<char>;\\ntype VS = Vec<String>;\\nimpl Encrypter {\\n    fn new(C: VC, S: VS, A: VS) -> Self {\\n        let mut m = HashMap::new();\\n        let mut cnt = HashMap::new();\\n        for (c, s) in C.iter().zip(S.iter()) {\\n            m.insert(*c, s.clone());\\n        }\\n        let mut me = Encrypter{ m, cnt };\\n        for s in A {\\n            let t = Self::encrypt(&mut me, s.clone());\\n            if 2 * s.len() == t.len() {\\n                *me.cnt.entry(t).or_insert(0) += 1;\\n            }\\n        }\\n        me\\n    }\\n    fn encrypt(&mut self, s: String) -> String {\\n        let mut t = String::new();\\n        for c in s.chars() {\\n            if let Some(x) = self.m.get(&c) {\\n                t.push_str(x.as_str());\\n            }\\n        }\\n        t\\n    }\\n    fn decrypt(&mut self, s: String) -> i32 {\\n        *self.cnt.entry(s).or_insert(0)\\n    }\\n}\\n```\n```\\nclass Encrypter {\\npublic:\\n    using VC = vector<char>;\\n    using VS = vector<string>;\\n    using Map = unordered_map<char, string>;\\n    using Counter = unordered_map<string, int>;\\n    Map m;\\n    Counter cnt;\\n    Encrypter(VC& C, VS& S, VS& A) {\\n        for (auto i{ 0 }; i < C.size(); ++i)\\n            m[C[i]] = S[i];\\n        for (auto& s: A) {\\n            auto t = encrypt(s);\\n            if (2 * s.size() == t.size())\\n                ++cnt[t];\\n        }\\n    }\\n    string encrypt(string s) {\\n        ostringstream os;\\n        transform(s.begin(), s.end(), ostream_iterator<string>(os, \"\"), [&](auto c) { return m[c]; });\\n        return os.str();\\n    }\\n    int decrypt(string s) {\\n        return cnt[s];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915722,
                "title": "c-using-two-hashmaps-easy-understanding-fastest",
                "content": "Here\\'s the trick:\\nDo not generate all the possible strings after decryption and then count the occurrences in dictionary, TAKE THE REVERSE WAY, encrypt the dictionary and store it in a map, now just return the number of occurrences in that map of the desired string to be decrypted.\\n\\nWe can create 2 hashmaps, \\n- one to map the keys to value, so that we can instantly get the corresponding encryption of a character in O(1) for the encryption method.\\n- other for decryption method, to encrypt all the strings in the dictionary and count the occurences. Now whenever we get a call to decrypt a string, we can direct look it up in the hashmap, and return the count instead of actually decrypting it and checking if it exists in the dictionary.\\n\\nThe Code below would make it much clearer. \\n\\n```\\nclass Encrypter {\\npublic:\\n  unordered_map<char, string> encDict;\\n  unordered_map<string, int> decDict;\\n  \\n  Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n    for(int i=0; i<keys.size(); i++) {\\n      encDict[keys[i]] = values[i];\\n    }\\n    for(auto i:dictionary) {\\n      string tmp = encrypt(i);\\n      if(tmp.size())\\n        decDict[tmp]++;\\n    }\\n  }\\n\\n  string encrypt(string word1) {\\n    string encrypted = \"\";\\n    for(auto i:word1) {\\n      if(encDict[i]==\"\") return \"\";\\n      encrypted += encDict[i];\\n    }\\n    return encrypted;\\n  }\\n\\n  int decrypt(string word2) {    \\n    return decDict[word2];\\n  }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n  unordered_map<char, string> encDict;\\n  unordered_map<string, int> decDict;\\n  \\n  Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n    for(int i=0; i<keys.size(); i++) {\\n      encDict[keys[i]] = values[i];\\n    }\\n    for(auto i:dictionary) {\\n      string tmp = encrypt(i);\\n      if(tmp.size())\\n        decDict[tmp]++;\\n    }\\n  }\\n\\n  string encrypt(string word1) {\\n    string encrypted = \"\";\\n    for(auto i:word1) {\\n      if(encDict[i]==\"\") return \"\";\\n      encrypted += encDict[i];\\n    }\\n    return encrypted;\\n  }\\n\\n  int decrypt(string word2) {    \\n    return decDict[word2];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915491,
                "title": "test-cases-can-be-passed-using-a-simple-cache",
                "content": "The Time Limit Exceeded  cases (e.g case 201) rely on sending the same input over and over. If one adds a simple cache those cases get passed and the solution gets Accepted, despite it not being the intention.\\n\\nThere needs to be cases that lead to TLE using different inputs for each one to avoid this issue.",
                "solutionTags": [],
                "code": "The Time Limit Exceeded  cases (e.g case 201) rely on sending the same input over and over. If one adds a simple cache those cases get passed and the solution gets Accepted, despite it not being the intention.\\n\\nThere needs to be cases that lead to TLE using different inputs for each one to avoid this issue.",
                "codeTag": "Unknown"
            },
            {
                "id": 1915086,
                "title": "javascript-two-hashmaps",
                "content": "```\\nclass Encrypter {\\n  constructor(keys, values, dictionary) {\\n    this.mapKeyToValue = {};\\n    this.mapCount = {};\\n    const n = keys.length;\\n\\n    for (let i = 0; i < n; i++) {\\n      const key = keys[i];\\n      const value = values[i];\\n      this.mapKeyToValue[key] = value;\\n    }\\n\\n    for (const dict of dictionary) {\\n      const encrypted = this.encrypt(dict);\\n      this.mapCount[encrypted] = (this.mapCount[encrypted] || 0) + 1;\\n    }\\n  }\\n\\n  encrypt(word1) {\\n    let res = \\'\\';\\n    for (const char of word1) {\\n      res += this.mapKeyToValue[char];\\n    }\\n    return res;\\n  }\\n\\n  decrypt(word2) {\\n    return this.mapCount[word2] || 0;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\n  constructor(keys, values, dictionary) {\\n    this.mapKeyToValue = {};\\n    this.mapCount = {};\\n    const n = keys.length;\\n\\n    for (let i = 0; i < n; i++) {\\n      const key = keys[i];\\n      const value = values[i];\\n      this.mapKeyToValue[key] = value;\\n    }\\n\\n    for (const dict of dictionary) {\\n      const encrypted = this.encrypt(dict);\\n      this.mapCount[encrypted] = (this.mapCount[encrypted] || 0) + 1;\\n    }\\n  }\\n\\n  encrypt(word1) {\\n    let res = \\'\\';\\n    for (const char of word1) {\\n      res += this.mapKeyToValue[char];\\n    }\\n    return res;\\n  }\\n\\n  decrypt(word2) {\\n    return this.mapCount[word2] || 0;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911392,
                "title": "easy-to-understand-cpp",
                "content": "```\\nclass Encrypter {\\n    map<char,int> k;\\n    map<int,string> v;\\n    map<string,int> cnt;\\n    set<string> dic;\\n    map<string,int> freq;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0;i<keys.size();i++)k[keys[i]]=i;\\n        for(int i=0;i<values.size();i++)v[i]=values[i];\\n        \\n        for(auto &x:values)cnt[x]++;\\n        \\n        for(auto &x:dictionary){\\n            string enc=encrypt(x);\\n            freq[enc]++;\\n        }\\n        // dic.insert(x);        \\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans=\"\";\\n        for(auto &x:word1){\\n            int tem=k[x];\\n            string s=v[tem];\\n            ans+=s;\\n        }\\n        return ans;        \\n    }\\n    \\n    int decrypt(string word2) {\\n        // if(dic.find(word2)==dic.end())return 0;\\n        int ans=1;\\n        \\n        \\n        return freq[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Encrypter {\\n    map<char,int> k;\\n    map<int,string> v;\\n    map<string,int> cnt;\\n    set<string> dic;\\n    map<string,int> freq;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0;i<keys.size();i++)k[keys[i]]=i;\\n        for(int i=0;i<values.size();i++)v[i]=values[i];\\n        \\n        for(auto &x:values)cnt[x]++;\\n        \\n        for(auto &x:dictionary){\\n            string enc=encrypt(x);\\n            freq[enc]++;\\n        }\\n        // dic.insert(x);        \\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans=\"\";\\n        for(auto &x:word1){\\n            int tem=k[x];\\n            string s=v[tem];\\n            ans+=s;\\n        }\\n        return ans;        \\n    }\\n    \\n    int decrypt(string word2) {\\n        // if(dic.find(word2)==dic.end())return 0;\\n        int ans=1;\\n        \\n        \\n        return freq[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1911274,
                "title": "python-trie",
                "content": "Build the trie with encrypted strings in the dictionary. Use c[\\'#\\'] to store the number of occurence. \\n\\n```\\nclass Trie:\\n    def __init__(self):\\n        self.trie = {}\\n    \\n    def add(self,s):\\n        cur = self.trie\\n        ns = len(s)\\n        for i in range(0,ns,2):\\n            c = s[i:i+2]\\n            if c not in cur:\\n                cur[c]={}\\n            cur = cur[c]\\n        if \\'#\\' not in cur:\\n            cur[\\'#\\'] = 1\\n        else:\\n            cur[\\'#\\'] += 1\\n    \\n    def get(self,s):\\n        cur = self.trie\\n        ns = len(s)\\n        for i in range(0,ns,2):\\n            c = s[i:i+2]\\n            if c not in cur:\\n                return 0\\n            cur = cur[c]\\n        if \\'#\\' in cur:\\n            return cur[\\'#\\']\\n        else:\\n            return 0\\n\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        n = len(keys)\\n        self.dic = defaultdict(str)\\n        for i in range(n):\\n            self.dic[keys[i]] = values[i]\\n        \\n        self.T = Trie()\\n        for di in dictionary:\\n            ndi = [self.dic[c] for c in di]\\n            self.T.add(\\'\\'.join(ndi))\\n\\n    def encrypt(self, word1: str) -> str:\\n        ns = [self.dic[c] for c in word1]\\n        return \\'\\'.join(ns)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.T.get(word2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Trie:\\n    def __init__(self):\\n        self.trie = {}\\n    \\n    def add(self,s):\\n        cur = self.trie\\n        ns = len(s)\\n        for i in range(0,ns,2):\\n            c = s[i:i+2]\\n            if c not in cur:\\n                cur[c]={}\\n            cur = cur[c]\\n        if \\'#\\' not in cur:\\n            cur[\\'#\\'] = 1\\n        else:\\n            cur[\\'#\\'] += 1\\n    \\n    def get(self,s):\\n        cur = self.trie\\n        ns = len(s)\\n        for i in range(0,ns,2):\\n            c = s[i:i+2]\\n            if c not in cur:\\n                return 0\\n            cur = cur[c]\\n        if \\'#\\' in cur:\\n            return cur[\\'#\\']\\n        else:\\n            return 0\\n\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        n = len(keys)\\n        self.dic = defaultdict(str)\\n        for i in range(n):\\n            self.dic[keys[i]] = values[i]\\n        \\n        self.T = Trie()\\n        for di in dictionary:\\n            ndi = [self.dic[c] for c in di]\\n            self.T.add(\\'\\'.join(ndi))\\n\\n    def encrypt(self, word1: str) -> str:\\n        ns = [self.dic[c] for c in word1]\\n        return \\'\\'.join(ns)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.T.get(word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909405,
                "title": "javascript-brain-teaser-390ms",
                "content": "for decrypt() first thinking is do backtracking, and check if match to any of them in dictionary, this way I tried get TLE with 201/203 passed (don\\'t know how to improve)\\n\\nThen I figure out what we need to do is just encrypt each string in dictionary, and see if it match to decrypt (^_^)\\n```\\n// template: {value: array indices increasing order}\\nconst counter_value_in_indexA_in = (a_or_s) => { let m = new Map(); let n = a_or_s.length; for (let i = 0; i < n; i++) { if (!m.has(a_or_s[i])) m.set(a_or_s[i], []); m.get(a_or_s[i]).push(i); } return m; };\\n\\nfunction Encrypter(k, v, dict) {\\n    dict = new Set(dict);\\n    let mk = counter_value_in_indexA_in(k), mv = counter_value_in_indexA_in(v), memo = new Map();\\n    return { encrypt, decrypt }\\n    function encrypt(s) {\\n        let res = \\'\\';\\n        for (const c of s) {\\n            let i = mk.get(c)[0];\\n            res += v[i];\\n        }\\n        return res;\\n    }\\n    function decrypt(s) { // reverse thinking\\n        if (memo.has(s)) return memo.get(s);\\n        let res = 0;\\n        for (const dic of dict) {\\n            if (encrypt(dic) == s) res++;\\n        }\\n        memo.set(s, res);\\n        return res;\\n    }\\n}\\n```\\nbacktracking tried version, not working TLE 201/203 passed\\n```\\nconst counter_value_in_indexA_in = (a_or_s) => { let m = new Map(); let n = a_or_s.length; for (let i = 0; i < n; i++) { if (!m.has(a_or_s[i])) m.set(a_or_s[i], []); m.get(a_or_s[i]).push(i); } return m; };\\n\\nfunction Encrypter(k, v, dict) {\\n    dict = new Set(dict);\\n    let mk = counter_value_in_indexA_in(k), mv = counter_value_in_indexA_in(v);\\n    return { encrypt, decrypt }\\n    function encrypt(s) {\\n        let res = \\'\\';\\n        for (const c of s) {\\n            let i = mk.get(c)[0];\\n            res += v[i];\\n        }\\n        return res;\\n    }\\n    function decrypt(s) {\\n        let n = s.length, res = 0;\\n        function dfs(pos, cur) {\\n            if (pos == n) {\\n                let t = cur.join(\"\");\\n                if (dict.has(t)) res++;\\n                return;\\n            }\\n            for (let i = pos; i < n; i++) {\\n                let next = s.slice(pos, i + 1); // find next substring/array\\n                if (!mv.has(next)) continue;\\n                let ia = mv.get(next) || [];\\n                for (const idx of ia) {\\n                    cur.push(k[idx]);\\n                    dfs(i + 1, cur);\\n                    cur.pop();\\n                }\\n            }\\n        }\\n        dfs(0, []);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n// template: {value: array indices increasing order}\\nconst counter_value_in_indexA_in = (a_or_s) => { let m = new Map(); let n = a_or_s.length; for (let i = 0; i < n; i++) { if (!m.has(a_or_s[i])) m.set(a_or_s[i], []); m.get(a_or_s[i]).push(i); } return m; };\\n\\nfunction Encrypter(k, v, dict) {\\n    dict = new Set(dict);\\n    let mk = counter_value_in_indexA_in(k), mv = counter_value_in_indexA_in(v), memo = new Map();\\n    return { encrypt, decrypt }\\n    function encrypt(s) {\\n        let res = \\'\\';\\n        for (const c of s) {\\n            let i = mk.get(c)[0];\\n            res += v[i];\\n        }\\n        return res;\\n    }\\n    function decrypt(s) { // reverse thinking\\n        if (memo.has(s)) return memo.get(s);\\n        let res = 0;\\n        for (const dic of dict) {\\n            if (encrypt(dic) == s) res++;\\n        }\\n        memo.set(s, res);\\n        return res;\\n    }\\n}\\n```\n```\\nconst counter_value_in_indexA_in = (a_or_s) => { let m = new Map(); let n = a_or_s.length; for (let i = 0; i < n; i++) { if (!m.has(a_or_s[i])) m.set(a_or_s[i], []); m.get(a_or_s[i]).push(i); } return m; };\\n\\nfunction Encrypter(k, v, dict) {\\n    dict = new Set(dict);\\n    let mk = counter_value_in_indexA_in(k), mv = counter_value_in_indexA_in(v);\\n    return { encrypt, decrypt }\\n    function encrypt(s) {\\n        let res = \\'\\';\\n        for (const c of s) {\\n            let i = mk.get(c)[0];\\n            res += v[i];\\n        }\\n        return res;\\n    }\\n    function decrypt(s) {\\n        let n = s.length, res = 0;\\n        function dfs(pos, cur) {\\n            if (pos == n) {\\n                let t = cur.join(\"\");\\n                if (dict.has(t)) res++;\\n                return;\\n            }\\n            for (let i = pos; i < n; i++) {\\n                let next = s.slice(pos, i + 1); // find next substring/array\\n                if (!mv.has(next)) continue;\\n                let ia = mv.get(next) || [];\\n                for (const idx of ia) {\\n                    cur.push(k[idx]);\\n                    dfs(i + 1, cur);\\n                    cur.pop();\\n                }\\n            }\\n        }\\n        dfs(0, []);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909305,
                "title": "python-simple-short-and-easy-to-understand",
                "content": "```\\nfrom collections import defaultdict\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        \\n        self.keys = { key:val for key, val in zip(keys, values)}\\n        self.decryptCount = defaultdict(lambda:0)\\n        \\n        for word in dictionary:\\n            self.decryptCount[\"\".join([self.keys[ch] for ch in word])]+=1\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \"\".join([self.keys[ch] for ch in word1])\\n        \\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.decryptCount[word2]\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        \\n        self.keys = { key:val for key, val in zip(keys, values)}\\n        self.decryptCount = defaultdict(lambda:0)\\n        \\n        for word in dictionary:\\n            self.decryptCount[\"\".join([self.keys[ch] for ch in word])]+=1\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \"\".join([self.keys[ch] for ch in word1])\\n        \\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.decryptCount[word2]\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909172,
                "title": "c-using-hashmap-preprocessing",
                "content": "Simply, encrypt all the strings of *dictionary* in the constructor only and then store the frequency of the encoded string in the *dict* map. Then, return the frequency of the encoded string from the *dict* map int the **decrpyt** method.\\n\\n```\\nclass Encrypter\\n{\\npublic:\\n    unordered_map<char, string> kv;\\n    unordered_map<string,int> dict;\\n    Encrypter(vector<char> &keys, vector<string> &values, vector<string> &dictionary) {\\n        for (int i = 0; i < size(keys); i++)\\n            kv[keys[i]] = values[i];\\n        for(auto str: dictionary)\\n            dict[encrypt(str)]++;\\n    }\\n    \\n    string encrypt(string w) {\\n        string s = \"\";\\n        for (int i = 0; i < size(w); i++)\\n            s += kv[w[i]];\\n        return s;\\n    }\\n    \\n    int decrypt(string w) {\\n        return dict[w];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter\\n{\\npublic:\\n    unordered_map<char, string> kv;\\n    unordered_map<string,int> dict;\\n    Encrypter(vector<char> &keys, vector<string> &values, vector<string> &dictionary) {\\n        for (int i = 0; i < size(keys); i++)\\n            kv[keys[i]] = values[i];\\n        for(auto str: dictionary)\\n            dict[encrypt(str)]++;\\n    }\\n    \\n    string encrypt(string w) {\\n        string s = \"\";\\n        for (int i = 0; i < size(w); i++)\\n            s += kv[w[i]];\\n        return s;\\n    }\\n    \\n    int decrypt(string w) {\\n        return dict[w];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909139,
                "title": "easy-map-solution-in-c-with-comments-without-trie",
                "content": "```\\nclass Encrypter {\\npublic:\\n    map<char,string> m1;\\n    map<string,vector<char>> m2;\\n    map<string,int> m3;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dic) {\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            m1[keys[i]]=values[i];  //store value of key\\n            m2[values[i]].push_back(keys[i]); //store key of value\\n        }\\n        for(int i=0;i<dic.size();i++)\\n        {\\n\\t\\t\\t//count the frequency of given text in encrypted form\\n            string sa=encrypt(dic[i]); \\n            m3[sa]++;\\n        }\\n    }\\n    string encrypt(string word1) {\\n        string s1;\\n        for(int i=0;i<word1.size();i++)\\n        {\\n            s1+=m1[word1[i]];\\n        }\\n        return s1;\\n    }\\n    int decrypt(string word2) {\\n        return m3[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    map<char,string> m1;\\n    map<string,vector<char>> m2;\\n    map<string,int> m3;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dic) {\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            m1[keys[i]]=values[i];  //store value of key\\n            m2[values[i]].push_back(keys[i]); //store key of value\\n        }\\n        for(int i=0;i<dic.size();i++)\\n        {\\n\\t\\t\\t//count the frequency of given text in encrypted form\\n            string sa=encrypt(dic[i]); \\n            m3[sa]++;\\n        }\\n    }\\n    string encrypt(string word1) {\\n        string s1;\\n        for(int i=0;i<word1.size();i++)\\n        {\\n            s1+=m1[word1[i]];\\n        }\\n        return s1;\\n    }\\n    int decrypt(string word2) {\\n        return m3[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1909130,
                "title": "by-using-three-maps",
                "content": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string>m1;\\n    unordered_map<string,vector<char>>m2;\\n    unordered_map<string,int>m3;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0;i<keys.size();i++){\\n            m1[keys[i]]=values[i];\\n            m2[values[i]].push_back(keys[i]);\\n        }\\n        for(int i=0;i<dictionary.size();i++) {\\n            string ss=encrypt(dictionary[i]);\\n            m3[ss]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ss;\\n        for(int i=0;i<word1.size();i++){\\n            ss+=m1[word1[i]];\\n        }\\n        return ss;\\n    }\\n    int decrypt(string word2) {\\n        return m3[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string>m1;\\n    unordered_map<string,vector<char>>m2;\\n    unordered_map<string,int>m3;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0;i<keys.size();i++){\\n            m1[keys[i]]=values[i];\\n            m2[values[i]].push_back(keys[i]);\\n        }\\n        for(int i=0;i<dictionary.size();i++) {\\n            string ss=encrypt(dictionary[i]);\\n            m3[ss]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ss;\\n        for(int i=0;i<word1.size();i++){\\n            ss+=m1[word1[i]];\\n        }\\n        return ss;\\n    }\\n    int decrypt(string word2) {\\n        return m3[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909101,
                "title": "java-trie",
                "content": "\\tclass TrieNode{\\n        TrieNode[] children;\\n        boolean isWord;\\n        \\n        public TrieNode(){\\n            children = new TrieNode[26];\\n            isWord = false;\\n        }\\n    }\\n    \\n    Map<Character, String> key2value;\\n    Map<String, Set<Character>> value2key;\\n    TrieNode root;\\n    \\n    private void insert(String word, TrieNode root){\\n        TrieNode cur = root;\\n        for(int i = 0; i < word.length(); i++){\\n            char c = word.charAt(i);\\n            if(cur.children[c - \\'a\\'] == null)\\n                cur.children[c - \\'a\\'] = new TrieNode();\\n            cur = cur.children[c - \\'a\\'];\\n            if(i == word.length() - 1){\\n                cur.isWord = true;\\n            }\\n        }\\n    }\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        key2value = new HashMap<>();\\n        value2key = new HashMap<>();\\n        root = new TrieNode();\\n        for(int i = 0; i < keys.length; i++){\\n            char key = keys[i];\\n            String value = values[i];\\n            key2value.put(key, value);\\n            value2key.putIfAbsent(value, new HashSet<Character>());\\n            value2key.get(value).add(key);\\n        }\\n        for(String s: dictionary){\\n            insert(s, root);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < word1.length(); i++){\\n            sb.append(key2value.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        int[] res = new int[1];\\n        dfs(word2, 0, res, this.root);\\n        return res[0];\\n    }\\n    \\n    private void dfs(String s, int idx, int[] res, TrieNode root){\\n        if(idx == s.length() && root.isWord){\\n            res[0]++;\\n            return;\\n        }\\n        if(idx >= s.length()){\\n            return;\\n        }\\n        String str = s.substring(idx, idx + 2);\\n        if(!value2key.containsKey(str)){\\n            return;\\n        }\\n        for(char cha: value2key.get(str)){\\n            if(root.children[cha - \\'a\\'] != null){\\n                dfs(s, idx + 2, res, root.children[cha - \\'a\\']);\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "\\tclass TrieNode{\\n        TrieNode[] children;\\n        boolean isWord;\\n        \\n        public TrieNode(){\\n            children = new TrieNode[26];\\n            isWord = false;\\n        }\\n    }\\n    \\n    Map<Character, String> key2value;\\n    Map<String, Set<Character>> value2key;\\n    TrieNode root;\\n    \\n    private void insert(String word, TrieNode root){\\n        TrieNode cur = root;\\n        for(int i = 0; i < word.length(); i++){\\n            char c = word.charAt(i);\\n            if(cur.children[c - \\'a\\'] == null)\\n                cur.children[c - \\'a\\'] = new TrieNode();\\n            cur = cur.children[c - \\'a\\'];\\n            if(i == word.length() - 1){\\n                cur.isWord = true;\\n            }\\n        }\\n    }\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        key2value = new HashMap<>();\\n        value2key = new HashMap<>();\\n        root = new TrieNode();\\n        for(int i = 0; i < keys.length; i++){\\n            char key = keys[i];\\n            String value = values[i];\\n            key2value.put(key, value);\\n            value2key.putIfAbsent(value, new HashSet<Character>());\\n            value2key.get(value).add(key);\\n        }\\n        for(String s: dictionary){\\n            insert(s, root);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < word1.length(); i++){\\n            sb.append(key2value.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        int[] res = new int[1];\\n        dfs(word2, 0, res, this.root);\\n        return res[0];\\n    }\\n    \\n    private void dfs(String s, int idx, int[] res, TrieNode root){\\n        if(idx == s.length() && root.isWord){\\n            res[0]++;\\n            return;\\n        }\\n        if(idx >= s.length()){\\n            return;\\n        }\\n        String str = s.substring(idx, idx + 2);\\n        if(!value2key.containsKey(str)){\\n            return;\\n        }\\n        for(char cha: value2key.get(str)){\\n            if(root.children[cha - \\'a\\'] != null){\\n                dfs(s, idx + 2, res, root.children[cha - \\'a\\']);\\n            }\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1909063,
                "title": "cheated-solution-make-this-a-easy-problem",
                "content": "Instead of really solving this problem, as the dictionary is super short, we can just do a encryption of all of them when initialize, and store the encrpted->count map.\\n\\n\\n```cpp\\nclass Encrypter {\\npublic:\\n    unordered_map<char, string> m;\\n    unordered_map<string, int> count;\\n    \\n    Encrypter(vector<char>& K, vector<string>& V, vector<string>& D) {\\n        for (int i = 0; i < K.size(); ++i) \\n            m[K[i]] = V[i];\\n        \\n        for (string& s : D) {\\n            string en_s = encrypt(s);\\n            count[en_s]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ret = \"\";\\n        for (char& c : word1) ret += m[c];\\n        return ret;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return count[word2];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Encrypter {\\npublic:\\n    unordered_map<char, string> m;\\n    unordered_map<string, int> count;\\n    \\n    Encrypter(vector<char>& K, vector<string>& V, vector<string>& D) {\\n        for (int i = 0; i < K.size(); ++i) \\n            m[K[i]] = V[i];\\n        \\n        for (string& s : D) {\\n            string en_s = encrypt(s);\\n            count[en_s]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ret = \"\";\\n        for (char& c : word1) ret += m[c];\\n        return ret;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return count[word2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909016,
                "title": "hash-map-bruteforce",
                "content": "\\n```\\nclass Encrypter {\\npublic:\\n    map<char,string> m;\\n    map<string,int> com;\\n    Encrypter(vector<char>& k, vector<string>& v, vector<string>& d) {\\n        for(int i=0; i<k.size(); ++i)\\n        {\\n            m[k[i]] = v[i];\\n            // mm[v[i]].push_back(k[i]);\\n        }\\n        \\n        for(int i=0; i<d.size(); ++i)\\n        {\\n            string ans = \"\";\\n            for(int j=0; j<d[i].size(); ++j)\\n            {\\n                ans+=m[d[i][j]];\\n            }\\n            com[ans]++;\\n        }\\n    }\\n    \\n    string encrypt(string s) {\\n        \\n        string ans = \"\";\\n        \\n        for(int i=0; i<s.size(); ++i)\\n        {\\n            ans+=m[s[i]];\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int decrypt(string s) {\\n        \\n        if(com.count(s))\\n            return com[s];\\n        \\n        return 0;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    map<char,string> m;\\n    map<string,int> com;\\n    Encrypter(vector<char>& k, vector<string>& v, vector<string>& d) {\\n        for(int i=0; i<k.size(); ++i)\\n        {\\n            m[k[i]] = v[i];\\n            // mm[v[i]].push_back(k[i]);\\n        }\\n        \\n        for(int i=0; i<d.size(); ++i)\\n        {\\n            string ans = \"\";\\n            for(int j=0; j<d[i].size(); ++j)\\n            {\\n                ans+=m[d[i][j]];\\n            }\\n            com[ans]++;\\n        }\\n    }\\n    \\n    string encrypt(string s) {\\n        \\n        string ans = \"\";\\n        \\n        for(int i=0; i<s.size(); ++i)\\n        {\\n            ans+=m[s[i]];\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int decrypt(string s) {\\n        \\n        if(com.count(s))\\n            return com[s];\\n        \\n        return 0;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908959,
                "title": "easy-trie-bfs-python-optimized-code",
                "content": "**Solution 1: Trie**\\n\\n1. Use a trie to store the target words of dict\\n2. Find all combinations using a lookup dict.\\n```\\nclass Trie:\\n    def __init__(self):\\n        self.child = defaultdict()\\n        self.present = False\\n        \\nclass Encrypter:\\n\\n    def insert(self,s):\\n        p = self.t\\n        for ch in s:\\n            if ch not in p.child:\\n                p.child[ch] = Trie()\\n            p = p.child[ch]\\n        p.present = True\\n    \\n    def __init__(self, k: List[str], v: List[str], target_dict: List[str]):\\n        self.d = {k[i]:v[i] for i in range(len(k))}\\n        self.t = Trie()\\n        self.max_d_word_len = 0\\n        for s in target_dict:\\n            flag = True\\n            for ch in s:\\n                if ch not in self.d:\\n                    flag = False\\n                    break\\n            if flag:\\n                self.max_d_word_len = max(self.max_d_word_len, len(s))\\n                self.insert(s)\\n        \\n        self.rev = defaultdict(list)\\n        for i in range(len(k)):\\n            self.rev[v[i]].append(k[i])\\n            \\n    def encrypt(self, s: str) -> str:\\n        res = \"\"\\n        for ch in s:\\n            res += self.d[ch]\\n        return res\\n\\n    def decrypt(self, s: str) -> int:\\n      \\n        if len(s)//2 > self.max_d_word_len:\\n            return 0\\n        \\n        p = self.t        \\n        q = deque()\\n        q.append([0,p]) # index in s, ptr to trie\\n        cnt = 0\\n\\n        while q:\\n            i, p = q.popleft()\\n            \\n            if i == len(s):\\n                if p.present:\\n                    cnt += 1\\n                continue\\n            \\n            for k in self.rev[s[i:i+2]]:\\n                if k not in p.child:\\n                    continue\\n                t = p.child[k]\\n                q.append([i+2,t])\\n            \\n        return cnt\\n```\\n\\n**Solution 2:**\\n\\nInstead of decrypting result for each decrypt() call and then matching it with target list.\\nEncrypt the words in target list and count them. \\nSo each decrypt call can look it up in dict.\\n```\\nclass Encrypter:\\n    \\n    def __init__(self, k: List[str], v: List[str], target: List[str]):\\n        self.d = {k[i]:v[i] for i in range(len(k))}\\n        self.encrypt_target = defaultdict(int)\\n        for val in target:\\n            self.encrypt_target[self.encrypt(val)] += 1\\n            \\n    def encrypt(self, s: str) -> str:\\n        res = \"\"\\n        for ch in s:\\n            res += self.d[ch]\\n        return res\\n\\n    def decrypt(self, s: str) -> int:\\n        return self.encrypt_target[s]\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Trie:\\n    def __init__(self):\\n        self.child = defaultdict()\\n        self.present = False\\n        \\nclass Encrypter:\\n\\n    def insert(self,s):\\n        p = self.t\\n        for ch in s:\\n            if ch not in p.child:\\n                p.child[ch] = Trie()\\n            p = p.child[ch]\\n        p.present = True\\n    \\n    def __init__(self, k: List[str], v: List[str], target_dict: List[str]):\\n        self.d = {k[i]:v[i] for i in range(len(k))}\\n        self.t = Trie()\\n        self.max_d_word_len = 0\\n        for s in target_dict:\\n            flag = True\\n            for ch in s:\\n                if ch not in self.d:\\n                    flag = False\\n                    break\\n            if flag:\\n                self.max_d_word_len = max(self.max_d_word_len, len(s))\\n                self.insert(s)\\n        \\n        self.rev = defaultdict(list)\\n        for i in range(len(k)):\\n            self.rev[v[i]].append(k[i])\\n            \\n    def encrypt(self, s: str) -> str:\\n        res = \"\"\\n        for ch in s:\\n            res += self.d[ch]\\n        return res\\n\\n    def decrypt(self, s: str) -> int:\\n      \\n        if len(s)//2 > self.max_d_word_len:\\n            return 0\\n        \\n        p = self.t        \\n        q = deque()\\n        q.append([0,p]) # index in s, ptr to trie\\n        cnt = 0\\n\\n        while q:\\n            i, p = q.popleft()\\n            \\n            if i == len(s):\\n                if p.present:\\n                    cnt += 1\\n                continue\\n            \\n            for k in self.rev[s[i:i+2]]:\\n                if k not in p.child:\\n                    continue\\n                t = p.child[k]\\n                q.append([i+2,t])\\n            \\n        return cnt\\n```\n```\\nclass Encrypter:\\n    \\n    def __init__(self, k: List[str], v: List[str], target: List[str]):\\n        self.d = {k[i]:v[i] for i in range(len(k))}\\n        self.encrypt_target = defaultdict(int)\\n        for val in target:\\n            self.encrypt_target[self.encrypt(val)] += 1\\n            \\n    def encrypt(self, s: str) -> str:\\n        res = \"\"\\n        for ch in s:\\n            res += self.d[ch]\\n        return res\\n\\n    def decrypt(self, s: str) -> int:\\n        return self.encrypt_target[s]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908949,
                "title": "python-10-liner-o-1-for-decrypt",
                "content": "```\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.key_to_value = {k: v for k, v in zip(keys, values)}\\n        self.counter = Counter([self.encrypt(word) for word in dictionary])\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join([self.key_to_value[char] for char in word1])\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.counter[word2]\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "```\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.key_to_value = {k: v for k, v in zip(keys, values)}\\n        self.counter = Counter([self.encrypt(word) for word in dictionary])\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join([self.key_to_value[char] for char in word1])\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.counter[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908938,
                "title": "simple-java-solution-precompute-o-1-decrypt",
                "content": "Idea is pre-encryting the word in dictionary and store the count in a map. When doing decryption, simply check the map and return the count.\\n```\\nclass Encrypter {\\n    Map<Character, Integer> keyIndexMap = new HashMap<>();\\n    Map<String, Integer> dictCountMap = new HashMap<>();\\n    String[] values;\\n    String[] dictionary;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int i = 0; i < keys.length; i++) {\\n            this.keyIndexMap.put(keys[i], i);\\n        }\\n        this.values = values;\\n\\t\\t// precompute the encrypted value of all words in dict\\n        for(int i = 0; i < dictionary.length; i++) {\\n            dictionary[i] = encrypt(dictionary[i]);\\n            dictCountMap.put(dictionary[i], dictCountMap.getOrDefault(dictionary[i], 0) + 1);\\n        }\\n        this.dictionary = dictionary;\\n    }\\n    \\n    public String encrypt(String word1) {\\n        char[] charArray = word1.toCharArray();\\n        StringBuilder builder = new StringBuilder();\\n        for(char c: charArray) {\\n            int index = keyIndexMap.get(c);\\n            builder.append(values[index]);\\n        }\\n        return builder.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return dictCountMap.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\n    Map<Character, Integer> keyIndexMap = new HashMap<>();\\n    Map<String, Integer> dictCountMap = new HashMap<>();\\n    String[] values;\\n    String[] dictionary;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int i = 0; i < keys.length; i++) {\\n            this.keyIndexMap.put(keys[i], i);\\n        }\\n        this.values = values;\\n\\t\\t// precompute the encrypted value of all words in dict\\n        for(int i = 0; i < dictionary.length; i++) {\\n            dictionary[i] = encrypt(dictionary[i]);\\n            dictCountMap.put(dictionary[i], dictCountMap.getOrDefault(dictionary[i], 0) + 1);\\n        }\\n        this.dictionary = dictionary;\\n    }\\n    \\n    public String encrypt(String word1) {\\n        char[] charArray = word1.toCharArray();\\n        StringBuilder builder = new StringBuilder();\\n        for(char c: charArray) {\\n            int index = keyIndexMap.get(c);\\n            builder.append(values[index]);\\n        }\\n        return builder.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return dictCountMap.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908927,
                "title": "python-not-trie-just-search-on-the-dictionary",
                "content": "Instead of trie, try to search for each word in the dictionary (because the dictionary size is only 100 and each word in the dictionary is also 100):\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.kv = {}\\n        self.vk = {}\\n        for i in range(len(keys)):\\n            k, v = keys[i], values[i]\\n            self.kv[k] = values[i]\\n            \\n            if v not in self.vk:\\n                self.vk[v] = set()\\n                \\n            self.vk[v].add(k)\\n            \\n        self.dick = dictionary\\n\\n        \\n    def encrypt(self, w: str) -> str:\\n        res = \"\"\\n        for c in w:\\n            res += self.kv[c]\\n        return res\\n    \\n\\n    def decrypt(self, w: str) -> int:\\n        adj = []\\n        for i in range(2, len(w)+1, 2):\\n            cur = w[i-2:i]\\n            if cur not in self.vk:\\n                return 0\\n            adj.append(self.vk[cur])\\n                \\n        res = 0\\n        for d in self.dick:\\n            if len(d) != len(adj):\\n                continue\\n                \\n            ok = True\\n            for i in range(len(d)):\\n                if d[i] not in adj[i]:\\n                    ok = False\\n                    break\\n            if ok:\\n                res += 1\\n        \\n        return res\\n        \\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.kv = {}\\n        self.vk = {}\\n        for i in range(len(keys)):\\n            k, v = keys[i], values[i]\\n            self.kv[k] = values[i]\\n            \\n            if v not in self.vk:\\n                self.vk[v] = set()\\n                \\n            self.vk[v].add(k)\\n            \\n        self.dick = dictionary\\n\\n        \\n    def encrypt(self, w: str) -> str:\\n        res = \"\"\\n        for c in w:\\n            res += self.kv[c]\\n        return res\\n    \\n\\n    def decrypt(self, w: str) -> int:\\n        adj = []\\n        for i in range(2, len(w)+1, 2):\\n            cur = w[i-2:i]\\n            if cur not in self.vk:\\n                return 0\\n            adj.append(self.vk[cur])\\n                \\n        res = 0\\n        for d in self.dick:\\n            if len(d) != len(adj):\\n                continue\\n                \\n            ok = True\\n            for i in range(len(d)):\\n                if d[i] not in adj[i]:\\n                    ok = False\\n                    break\\n            if ok:\\n                res += 1\\n        \\n        return res\\n        \\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908901,
                "title": "java-dfs-trie",
                "content": "This is the first time I completed all four problems~~~!!!\\n```\\nclass Encrypter {\\n    Map<Character,String> enMap;\\n    Map<String, List<Character>> deMap;\\n    Set<String> dict;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.enMap = new HashMap<>();\\n        this.deMap = new HashMap<>();\\n        this.dict = new HashSet<>();\\n        \\n        for(int i = 0; i < keys.length; i++) {\\n            enMap.put(keys[i], values[i]);\\n            if(!deMap.containsKey(values[i])) {\\n                deMap.put(values[i], new ArrayList<>());\\n            }\\n            deMap.get(values[i]).add(keys[i]);\\n        }   \\n        \\n        for(String str : dictionary) {\\n            dict.add(str);\\n        }  \\n        \\n        this.root = new TrieNode();\\n        for(String str : dictionary){\\n            root.insert(root, str);\\n        }\\n        \\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sol = new StringBuilder();\\n        for(char ch : word1.toCharArray()) {\\n            sol.append(enMap.get(ch));\\n        }\\n        return sol.toString();\\n    } \\n    \\n    public int decrypt(String word2) {\\n        int[] res = {0};\\n        StringBuilder sol = new StringBuilder();\\n        TrieNode curRoot = root;\\n        \\n        dfs(word2, curRoot, 0, sol, deMap, dict, res);\\n        return res[0];\\n    }\\n    \\n    private void dfs(String word, TrieNode curRoot, int index, StringBuilder sol, Map<String, List<Character>> deMap, Set<String> dict, int[] res) {\\n        \\n        if(index >= word.length() - 1) {\\n            String temp = sol.toString();\\n            if(dict.contains(temp)) {\\n                res[0]++;\\n            }\\n            return;\\n        }\\n        \\n        String cur = word.substring(index, index + 2);\\n        \\n        List<Character> list = deMap.get(cur);\\n        int len = sol.length();\\n        if(list == null) {\\n            sol.append(cur);\\n            dfs(word, curRoot, index + 2, sol, deMap, dict, res);\\n            sol.setLength(len);\\n        } else {\\n            for(char c : list) {\\n                if(curRoot.children[c - \\'a\\'] == null) {\\n                    continue;\\n                }\\n                sol.append(c);\\n                dfs(word, curRoot.children[c -\\'a\\'], index + 2, sol, deMap, dict, res);\\n                sol.setLength(len);\\n            }\\n        }    \\n    }\\n    \\n    class TrieNode {\\n        boolean isWord;\\n        TrieNode[] children;\\n        public TrieNode() {\\n            this.isWord = false;\\n            this.children = new TrieNode[26];\\n        }\\n        \\n        public TrieNode insert(TrieNode root, String word) {\\n            TrieNode cur = root;\\n            \\n            for(int i = 0; i < word.length(); i++) {\\n                if(cur.children[word.charAt(i) - \\'a\\'] == null) {\\n                    cur.children[word.charAt(i) - \\'a\\'] = new TrieNode();\\n                }\\n                cur = cur.children[word.charAt(i) - \\'a\\'];\\n            }\\n            cur.isWord = true;\\n            return root;\\n        }\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Encrypter {\\n    Map<Character,String> enMap;\\n    Map<String, List<Character>> deMap;\\n    Set<String> dict;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.enMap = new HashMap<>();\\n        this.deMap = new HashMap<>();\\n        this.dict = new HashSet<>();\\n        \\n        for(int i = 0; i < keys.length; i++) {\\n            enMap.put(keys[i], values[i]);\\n            if(!deMap.containsKey(values[i])) {\\n                deMap.put(values[i], new ArrayList<>());\\n            }\\n            deMap.get(values[i]).add(keys[i]);\\n        }   \\n        \\n        for(String str : dictionary) {\\n            dict.add(str);\\n        }  \\n        \\n        this.root = new TrieNode();\\n        for(String str : dictionary){\\n            root.insert(root, str);\\n        }\\n        \\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sol = new StringBuilder();\\n        for(char ch : word1.toCharArray()) {\\n            sol.append(enMap.get(ch));\\n        }\\n        return sol.toString();\\n    } \\n    \\n    public int decrypt(String word2) {\\n        int[] res = {0};\\n        StringBuilder sol = new StringBuilder();\\n        TrieNode curRoot = root;\\n        \\n        dfs(word2, curRoot, 0, sol, deMap, dict, res);\\n        return res[0];\\n    }\\n    \\n    private void dfs(String word, TrieNode curRoot, int index, StringBuilder sol, Map<String, List<Character>> deMap, Set<String> dict, int[] res) {\\n        \\n        if(index >= word.length() - 1) {\\n            String temp = sol.toString();\\n            if(dict.contains(temp)) {\\n                res[0]++;\\n            }\\n            return;\\n        }\\n        \\n        String cur = word.substring(index, index + 2);\\n        \\n        List<Character> list = deMap.get(cur);\\n        int len = sol.length();\\n        if(list == null) {\\n            sol.append(cur);\\n            dfs(word, curRoot, index + 2, sol, deMap, dict, res);\\n            sol.setLength(len);\\n        } else {\\n            for(char c : list) {\\n                if(curRoot.children[c - \\'a\\'] == null) {\\n                    continue;\\n                }\\n                sol.append(c);\\n                dfs(word, curRoot.children[c -\\'a\\'], index + 2, sol, deMap, dict, res);\\n                sol.setLength(len);\\n            }\\n        }    \\n    }\\n    \\n    class TrieNode {\\n        boolean isWord;\\n        TrieNode[] children;\\n        public TrieNode() {\\n            this.isWord = false;\\n            this.children = new TrieNode[26];\\n        }\\n        \\n        public TrieNode insert(TrieNode root, String word) {\\n            TrieNode cur = root;\\n            \\n            for(int i = 0; i < word.length(); i++) {\\n                if(cur.children[word.charAt(i) - \\'a\\'] == null) {\\n                    cur.children[word.charAt(i) - \\'a\\'] = new TrieNode();\\n                }\\n                cur = cur.children[word.charAt(i) - \\'a\\'];\\n            }\\n            cur.isWord = true;\\n            return root;\\n        }\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908887,
                "title": "c-rainbow-table-solution-and-trie-solution",
                "content": "#### rainbow table \\nA [rainbow table](https://en.wikipedia.org/wiki/Rainbow_table) is a precomputed table for caching the output of cryptographic hash functions, usually for cracking password hashes. \\n```\\nclass Encrypter {\\npublic:\\n    vector<string> k2v;\\n    unordered_map<string,vector<int>> v2k; \\n    unordered_map<string,int> m; \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) : k2v(26,\"\"){\\n        for(int i = 0;i<keys.size();i++) {\\n            k2v[keys[i] - \\'a\\'] = values[i];\\n            v2k[values[i]].push_back(keys[i] - \\'a\\');\\n        }\\n        for(auto& s : dictionary) {\\n            m[encrypt(s)]++; \\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ret;\\n        for(char ch : word1) {\\n            ret += k2v[ch-\\'a\\'];\\n        }\\n        return ret; \\n    }\\n    \\n    \\n    int decrypt(string word2) {\\n        return m[word2];\\n    }\\n};\\n\\n```\\n#### Trie solution \\n```\\nclass Encrypter {\\npublic:\\n    vector<string> k2v;\\n    unordered_map<string,vector<int>> v2k; \\n    class Node {\\n    public:\\n        bool leaf = false; \\n        vector<Node*> children;\\n        Node() : leaf{false}, children(26,nullptr) {}\\n    };\\n    class Trie {\\n    public:\\n        Node* root = new Node(); \\n        void insert(const string& str) {\\n            auto t = root; \\n            for(char ch : str) {\\n                if(t->children[ch - \\'a\\'] == nullptr) {\\n                    t->children[ch-\\'a\\'] = new Node(); \\n                }\\n                t = t->children[ch-\\'a\\'];\\n            }\\n            t->leaf = true; \\n        }\\n    };\\n    Trie trie; \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) : k2v(26,\"\"){\\n        for(int i = 0;i<keys.size();i++) {\\n            k2v[keys[i] - \\'a\\'] = values[i];\\n            v2k[values[i]].push_back(keys[i] - \\'a\\');\\n        }\\n        for(auto& str : dictionary) {\\n            trie.insert(str);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ret;\\n        for(char ch : word1) {\\n            ret += k2v[ch-\\'a\\'];\\n        }\\n        return ret; \\n    }\\n    \\n    int f(Node* node, const string& word2, int i) {\\n        if(node == nullptr) {\\n            return 0; \\n        }\\n        if(i == word2.size()) {\\n            if(node->leaf) {\\n                return 1;\\n            }\\n            return 0; \\n        }\\n        auto v = word2.substr(i,2);\\n        int ret = 0; \\n        for(int k : v2k[v]) {\\n            ret += f(node->children[k],word2,i+2);\\n        }\\n        return ret; \\n    }\\n    int decrypt(string word2) {\\n        return f(trie.root,word2,0); \\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    vector<string> k2v;\\n    unordered_map<string,vector<int>> v2k; \\n    unordered_map<string,int> m; \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) : k2v(26,\"\"){\\n        for(int i = 0;i<keys.size();i++) {\\n            k2v[keys[i] - \\'a\\'] = values[i];\\n            v2k[values[i]].push_back(keys[i] - \\'a\\');\\n        }\\n        for(auto& s : dictionary) {\\n            m[encrypt(s)]++; \\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ret;\\n        for(char ch : word1) {\\n            ret += k2v[ch-\\'a\\'];\\n        }\\n        return ret; \\n    }\\n    \\n    \\n    int decrypt(string word2) {\\n        return m[word2];\\n    }\\n};\\n\\n```\n```\\nclass Encrypter {\\npublic:\\n    vector<string> k2v;\\n    unordered_map<string,vector<int>> v2k; \\n    class Node {\\n    public:\\n        bool leaf = false; \\n        vector<Node*> children;\\n        Node() : leaf{false}, children(26,nullptr) {}\\n    };\\n    class Trie {\\n    public:\\n        Node* root = new Node(); \\n        void insert(const string& str) {\\n            auto t = root; \\n            for(char ch : str) {\\n                if(t->children[ch - \\'a\\'] == nullptr) {\\n                    t->children[ch-\\'a\\'] = new Node(); \\n                }\\n                t = t->children[ch-\\'a\\'];\\n            }\\n            t->leaf = true; \\n        }\\n    };\\n    Trie trie; \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) : k2v(26,\"\"){\\n        for(int i = 0;i<keys.size();i++) {\\n            k2v[keys[i] - \\'a\\'] = values[i];\\n            v2k[values[i]].push_back(keys[i] - \\'a\\');\\n        }\\n        for(auto& str : dictionary) {\\n            trie.insert(str);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ret;\\n        for(char ch : word1) {\\n            ret += k2v[ch-\\'a\\'];\\n        }\\n        return ret; \\n    }\\n    \\n    int f(Node* node, const string& word2, int i) {\\n        if(node == nullptr) {\\n            return 0; \\n        }\\n        if(i == word2.size()) {\\n            if(node->leaf) {\\n                return 1;\\n            }\\n            return 0; \\n        }\\n        auto v = word2.substr(i,2);\\n        int ret = 0; \\n        for(int k : v2k[v]) {\\n            ret += f(node->children[k],word2,i+2);\\n        }\\n        return ret; \\n    }\\n    int decrypt(string word2) {\\n        return f(trie.root,word2,0); \\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1908884,
                "title": "c-trie",
                "content": "```\\nclass TrieNode {\\npublic: \\n    TrieNode* next[26];\\n    bool is_word;\\n    TrieNode() {memset(next, 0, sizeof(next)); is_word = false;}\\n};\\n\\nclass Trie {\\npublic: \\n    Trie() {\\n        root = new TrieNode();\\n    }\\n    \\n    TrieNode* getRoot()\\n    {\\n        return root;\\n    }\\n    \\n    void insert(string word) {\\n        TrieNode* cur = root;\\n        for (auto c : word)\\n        {\\n            if (!cur->next[c - \\'a\\'])\\n                cur->next[c - \\'a\\'] = new TrieNode();\\n            cur = cur->next[c - \\'a\\'];\\n        }\\n        cur->is_word = true;\\n    }\\n    \\n    TrieNode* find(char c, TrieNode* node)\\n    {\\n        if (node->next[c - \\'a\\'])\\n            return node->next[c - \\'a\\'];\\n        else \\n            return nullptr;\\n    }\\n    \\nprivate: \\n    TrieNode* root;\\n};\\n\\nclass Encrypter {\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        int n = keys.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            k2v[keys[i]] = values[i];\\n            v2k[values[i]].push_back(keys[i]);\\n        }\\n        trie = new Trie();\\n        for (auto& s : dictionary)\\n            trie->insert(s);\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for (auto& c : word1)\\n            ans += k2v[c];\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int n = word2.length(), m = n / 2;\\n        vector<vector<char>> k(m);\\n        for (int i = 0, j = 0; i < n; i += 2, j++)\\n        {\\n            k[j] = v2k[word2.substr(i, 2)];\\n            if (k[j].size() == 0)\\n                return 0;\\n        }\\n        int ans = 0;\\n        dfs(k, 0, m, trie->getRoot(), ans);\\n        return ans;\\n    }\\n    \\nprivate: \\n    unordered_map<char, string> k2v;\\n    unordered_map<string, vector<char>> v2k;\\n    Trie* trie;\\n    \\n    void dfs(vector<vector<char>>& k, int r, int& m, TrieNode* cur, int& ans)\\n    {\\n        if (r == m)\\n        {\\n            if (cur->is_word)\\n                ans++;\\n            return;\\n        }\\n        for (auto& c : k[r])\\n        {\\n            TrieNode* nxt = trie->find(c, cur);\\n            if (nxt)\\n                dfs(k, r + 1, m, nxt, ans);\\n        }\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode {\\npublic: \\n    TrieNode* next[26];\\n    bool is_word;\\n    TrieNode() {memset(next, 0, sizeof(next)); is_word = false;}\\n};\\n\\nclass Trie {\\npublic: \\n    Trie() {\\n        root = new TrieNode();\\n    }\\n    \\n    TrieNode* getRoot()\\n    {\\n        return root;\\n    }\\n    \\n    void insert(string word) {\\n        TrieNode* cur = root;\\n        for (auto c : word)\\n        {\\n            if (!cur->next[c - \\'a\\'])\\n                cur->next[c - \\'a\\'] = new TrieNode();\\n            cur = cur->next[c - \\'a\\'];\\n        }\\n        cur->is_word = true;\\n    }\\n    \\n    TrieNode* find(char c, TrieNode* node)\\n    {\\n        if (node->next[c - \\'a\\'])\\n            return node->next[c - \\'a\\'];\\n        else \\n            return nullptr;\\n    }\\n    \\nprivate: \\n    TrieNode* root;\\n};\\n\\nclass Encrypter {\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        int n = keys.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            k2v[keys[i]] = values[i];\\n            v2k[values[i]].push_back(keys[i]);\\n        }\\n        trie = new Trie();\\n        for (auto& s : dictionary)\\n            trie->insert(s);\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for (auto& c : word1)\\n            ans += k2v[c];\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int n = word2.length(), m = n / 2;\\n        vector<vector<char>> k(m);\\n        for (int i = 0, j = 0; i < n; i += 2, j++)\\n        {\\n            k[j] = v2k[word2.substr(i, 2)];\\n            if (k[j].size() == 0)\\n                return 0;\\n        }\\n        int ans = 0;\\n        dfs(k, 0, m, trie->getRoot(), ans);\\n        return ans;\\n    }\\n    \\nprivate: \\n    unordered_map<char, string> k2v;\\n    unordered_map<string, vector<char>> v2k;\\n    Trie* trie;\\n    \\n    void dfs(vector<vector<char>>& k, int r, int& m, TrieNode* cur, int& ans)\\n    {\\n        if (r == m)\\n        {\\n            if (cur->is_word)\\n                ans++;\\n            return;\\n        }\\n        for (auto& c : k[r])\\n        {\\n            TrieNode* nxt = trie->find(c, cur);\\n            if (nxt)\\n                dfs(k, r + 1, m, nxt, ans);\\n        }\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908873,
                "title": "c-clean-commented-code",
                "content": "```\\nclass Encrypter {\\npublic:\\n    unordered_map <char, string> mp; // Will be used while encrypting. \\n    unordered_map <string, unordered_set<char>> allTwotoOne; // stores for each string of len 2, possible characteres it can map to\\n    unordered_set <string> dict; // our dictionary which includes valid words after decrypting.\\n\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i) {\\n            mp[keys[i]] = values[i]; // will be used in encryption.\\n        }\\n        for (int i = 0; i < values.size(); ++i) {\\n            allTwotoOne[values[i]].insert(keys[i]); // all possible chars which this encrypted 2 len string can decrpt to.\\n        }\\n        for (auto x : dictionary) {\\n            dict.insert(x);   // just making it global.\\n        }\\n    }   \\n    \\n    /*\\n        We can use mp to just replace each character with susbtrs of len 2.\\n    */\\n\\n    string encrypt(string word1) {\\n        string res = \"\";\\n        for (auto x : word1) {\\n            res += mp[x];\\n        }\\n        return res;\\n    }\\n    /*\\n        Returns the number of possible strings word2 could decrypt to that also appear in dictionary.\\n    */\\n    int decrypt(string word2) {\\n        int ways = 0;\\n        int enc_len = word2.size() / 2;\\n        // check for each word in dictionary, can it be formed while decyrpting string in given manner.\\n        for (auto x : dict) { \\n            if (x.size() != enc_len) continue; // prune as fast as possible.\\n            int i = 0;\\n            int can = 1;\\n            for (auto ch : x) {\\n                if (!allTwotoOne[word2.substr(i, 2)].count(ch)) { // if this 2 len substr cant decrypt to the current char of current string in dict, then break(prune)\\n                    can = 0;\\n                    break;\\n                } else { // go to next 2 len substr.\\n                    i += 2;\\n                }\\n            }\\n            ways += can;\\n        }\\n        return ways;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```\\n\\nUPvote if you liked my solution.\\nThanks.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map <char, string> mp; // Will be used while encrypting. \\n    unordered_map <string, unordered_set<char>> allTwotoOne; // stores for each string of len 2, possible characteres it can map to\\n    unordered_set <string> dict; // our dictionary which includes valid words after decrypting.\\n\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i) {\\n            mp[keys[i]] = values[i]; // will be used in encryption.\\n        }\\n        for (int i = 0; i < values.size(); ++i) {\\n            allTwotoOne[values[i]].insert(keys[i]); // all possible chars which this encrypted 2 len string can decrpt to.\\n        }\\n        for (auto x : dictionary) {\\n            dict.insert(x);   // just making it global.\\n        }\\n    }   \\n    \\n    /*\\n        We can use mp to just replace each character with susbtrs of len 2.\\n    */\\n\\n    string encrypt(string word1) {\\n        string res = \"\";\\n        for (auto x : word1) {\\n            res += mp[x];\\n        }\\n        return res;\\n    }\\n    /*\\n        Returns the number of possible strings word2 could decrypt to that also appear in dictionary.\\n    */\\n    int decrypt(string word2) {\\n        int ways = 0;\\n        int enc_len = word2.size() / 2;\\n        // check for each word in dictionary, can it be formed while decyrpting string in given manner.\\n        for (auto x : dict) { \\n            if (x.size() != enc_len) continue; // prune as fast as possible.\\n            int i = 0;\\n            int can = 1;\\n            for (auto ch : x) {\\n                if (!allTwotoOne[word2.substr(i, 2)].count(ch)) { // if this 2 len substr cant decrypt to the current char of current string in dict, then break(prune)\\n                    can = 0;\\n                    break;\\n                } else { // go to next 2 len substr.\\n                    i += 2;\\n                }\\n            }\\n            ways += can;\\n        }\\n        return ways;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908865,
                "title": "java-hashing-easy-to-understand-smart-approach",
                "content": "**Here I am discussing my approach to this problem**\\n**Approach:**\\n1. Create an `enc` map which **stores the key value pair** of what each character will **encrypt** to.\\n2. Create a `dictionary` map which will **store the count of each encrypted word** from the `dictionary` string.\\n3. In `encrypt` function, we just take each character from `word1`, and use `enc` map to **encrypt** it.\\n4. In `decrypt` function, we just return the **count of each** `word2` from `dictionary` map.\\n\\n**Source Code:**\\n```\\nclass Encrypter {\\n    Map<Character, String> enc;\\n    Map<String, Integer> dictionary;\\n    \\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.enc = new HashMap<>();\\n        this.dictionary = new HashMap<>();\\n        \\n        for(int i = 0; i < keys.length; ++i)\\n            enc.put(keys[i], values[i]);\\n        \\n        for(String v : dictionary) {\\n            StringBuilder sb = new StringBuilder();\\n            \\n            for(char ch : v.toCharArray())\\n                sb.append(enc.get(ch));\\n            \\n            this.dictionary.put(sb.toString(), this.dictionary.getOrDefault(sb.toString(), 0) + 1);\\n        }\\n        \\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(char ch : word1.toCharArray())\\n            sb.append(enc.get(ch));\\n        \\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return dictionary.getOrDefault(word2, 0);\\n    }\\n}\\n```\\n\\n**Complexity Analysis:**\\n```\\nTime Complexity: O(c * n) // c = number of calls, n = word.length\\nSpace Complexity : O(m) // m = number of dictionary words\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Encrypter {\\n    Map<Character, String> enc;\\n    Map<String, Integer> dictionary;\\n    \\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.enc = new HashMap<>();\\n        this.dictionary = new HashMap<>();\\n        \\n        for(int i = 0; i < keys.length; ++i)\\n            enc.put(keys[i], values[i]);\\n        \\n        for(String v : dictionary) {\\n            StringBuilder sb = new StringBuilder();\\n            \\n            for(char ch : v.toCharArray())\\n                sb.append(enc.get(ch));\\n            \\n            this.dictionary.put(sb.toString(), this.dictionary.getOrDefault(sb.toString(), 0) + 1);\\n        }\\n        \\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(char ch : word1.toCharArray())\\n            sb.append(enc.get(ch));\\n        \\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return dictionary.getOrDefault(word2, 0);\\n    }\\n}\\n```\n```\\nTime Complexity: O(c * n) // c = number of calls, n = word.length\\nSpace Complexity : O(m) // m = number of dictionary words\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908853,
                "title": "hashmap-solution-o-n-encrypt-o-1-decrypt",
                "content": "pre-built dictionary to encrypt string\\n\\n```\\nclass Encrypter {\\n\\n    Map<Character, String> keyValueMap = new HashMap<>();\\n    Map<String, Integer> encryptCntMap = new HashMap<>();\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for (int i = 0; i < keys.length; i++) {\\n            keyValueMap.put(keys[i], values[i]);\\n        }\\n\\n        for (String s : dictionary) {\\n            String enc = this.encrypt(s);\\n            encryptCntMap.put(enc, encryptCntMap.getOrDefault(enc, 0) + 1);\\n        }\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < word1.length(); i++) {\\n            sb.append(keyValueMap.get(word1.charAt(i)));\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        return encryptCntMap.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n\\n    Map<Character, String> keyValueMap = new HashMap<>();\\n    Map<String, Integer> encryptCntMap = new HashMap<>();\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for (int i = 0; i < keys.length; i++) {\\n            keyValueMap.put(keys[i], values[i]);\\n        }\\n\\n        for (String s : dictionary) {\\n            String enc = this.encrypt(s);\\n            encryptCntMap.put(enc, encryptCntMap.getOrDefault(enc, 0) + 1);\\n        }\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < word1.length(); i++) {\\n            sb.append(keyValueMap.get(word1.charAt(i)));\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        return encryptCntMap.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908836,
                "title": "easy-understand-code-no-dfs-no-trie-simple-logic",
                "content": "public class Encrypter {\\n\\n    HashSet<string> pString;\\n    // dictionary used for encryption\\n    Dictionary<string, HashSet<char>> rDict = new Dictionary<string, HashSet<char>>();\\n    // dictionary used for decryption\\n    Dictionary<char, string> fDict = new Dictionary<char, string>();\\n        \\n    public Encrypter(char[] keys, string[] values, string[] dictionary) {\\n        pString = new HashSet<string>(dictionary);\\n        for (int i = 0; i < keys.Length; i++){\\n            fDict.Add(keys[i], values[i]);\\n            if (!rDict.ContainsKey(values[i]))\\n                rDict.Add(values[i], new HashSet<char>());\\n            rDict[values[i]].Add(keys[i]);\\n        }\\n    }\\n    \\n    public string Encrypt(string word1) {\\n        string output = \"\";\\n        foreach (char c in word1){\\n            output += fDict[c];\\n        }\\n        return output;\\n    }\\n    \\n    // Because the dictionary is smaller than 100, we basically just loop the dictionary for each number, worst time is just 100 * 100\\n    public int Decrypt(string word2) {\\n        List<string> hs = new List<string>(pString);\\n        int len = word2.Length / 2;\\n        for (int i = 0; i < len; i++){\\n            string str = word2.Substring(i*2, 2);\\n            if (!rDict.ContainsKey(str))\\n                return 0;\\n            HashSet<char> ch = rDict[str];\\n            List<string> temp = new List<string>();\\n            foreach (string h in hs){\\n                if (h.Length > i && ch.Contains(h[i]))\\n                    temp.Add(h);\\n            }\\n            if (temp.Count == 0)\\n                return 0;\\n            hs = temp;\\n        }\\n        List<string> output = new List<string>();\\n        foreach (string k in hs){\\n            if (k.Length == len)\\n                output.Add(k);\\n        }\\n\\n        return output.Count;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj.Encrypt(word1);\\n * int param_2 = obj.Decrypt(word2);\\n */",
                "solutionTags": [],
                "code": "public class Encrypter {\\n\\n    HashSet<string> pString;\\n    // dictionary used for encryption\\n    Dictionary<string, HashSet<char>> rDict = new Dictionary<string, HashSet<char>>();\\n    // dictionary used for decryption\\n    Dictionary<char, string> fDict = new Dictionary<char, string>();\\n        \\n    public Encrypter(char[] keys, string[] values, string[] dictionary) {\\n        pString = new HashSet<string>(dictionary);\\n        for (int i = 0; i < keys.Length; i++){\\n            fDict.Add(keys[i], values[i]);\\n            if (!rDict.ContainsKey(values[i]))\\n                rDict.Add(values[i], new HashSet<char>());\\n            rDict[values[i]].Add(keys[i]);\\n        }\\n    }\\n    \\n    public string Encrypt(string word1) {\\n        string output = \"\";\\n        foreach (char c in word1){\\n            output += fDict[c];\\n        }\\n        return output;\\n    }\\n    \\n    // Because the dictionary is smaller than 100, we basically just loop the dictionary for each number, worst time is just 100 * 100\\n    public int Decrypt(string word2) {\\n        List<string> hs = new List<string>(pString);\\n        int len = word2.Length / 2;\\n        for (int i = 0; i < len; i++){\\n            string str = word2.Substring(i*2, 2);\\n            if (!rDict.ContainsKey(str))\\n                return 0;\\n            HashSet<char> ch = rDict[str];\\n            List<string> temp = new List<string>();\\n            foreach (string h in hs){\\n                if (h.Length > i && ch.Contains(h[i]))\\n                    temp.Add(h);\\n            }\\n            if (temp.Count == 0)\\n                return 0;\\n            hs = temp;\\n        }\\n        List<string> output = new List<string>();\\n        foreach (string k in hs){\\n            if (k.Length == len)\\n                output.Add(k);\\n        }\\n\\n        return output.Count;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj.Encrypt(word1);\\n * int param_2 = obj.Decrypt(word2);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1908770,
                "title": "python-not-hard-but-confusing",
                "content": "That is, the way this question is worded. We are supposed to use the encryption function we have written to descript efficiently. That\\'s sort of the hint (otherwise it\\'s trivial to code the encryption).\\n\\n```python\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.h = collections.defaultdict(str)\\n        for k, v in zip(keys, values):\\n            self.h[k] = v\\n        self.dictionary = set(dictionary)\\n        \\n\\n    def encrypt(self, word1):\\n        ans = \\'\\'\\n        for x in word1:\\n            if not self.h[x]:\\n                ans += x\\n            else:\\n                ans += self.h[x]\\n        return ans\\n\\n    \\n    def decrypt(self, word2):\\n        ans = 0\\n        for word in self.dictionary:\\n            if self.encrypt(word) == word2:\\n                ans += 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.h = collections.defaultdict(str)\\n        for k, v in zip(keys, values):\\n            self.h[k] = v\\n        self.dictionary = set(dictionary)\\n        \\n\\n    def encrypt(self, word1):\\n        ans = \\'\\'\\n        for x in word1:\\n            if not self.h[x]:\\n                ans += x\\n            else:\\n                ans += self.h[x]\\n        return ans\\n\\n    \\n    def decrypt(self, word2):\\n        ans = 0\\n        for word in self.dictionary:\\n            if self.encrypt(word) == word2:\\n                ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908735,
                "title": "easy-to-understand-solution-c-unordered-maps",
                "content": "Firstly, we will store all the information present with us in a hashmap so that we can retrieve them faster. The two arrays Keys[] and Values[] can be stored in a single hashmap\\n\\nThe encrypt function is easy to implement. Just traverse through the string \\u2018word1\\u2019 and replace each character with its corresponding value string.\\n\\nThe decrypt function needs only one trick to implement. One may think we can recursively form all the possible strings by taking characters in pairs and encrypt these pairs but this will have a polynomial time complexity since a given pair may have one or more encryption characters.\\n\\n**But we can be a little smart in doing this. Instead of finding all the decryption strings of the given string and check how many of those are present in the dictionary array, we can encrypt all the strings present in the dictionary array, maintain their count using a frequency hashmap and finally check how any time the string \\u2018word2\\u2019 exist in this frequency map. **\\n\\n\\n```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string> m1;\\n    unordered_map<string,int> m2;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        \\n        // storing all the characters along with their encryption keys\\n\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            m1[keys[i]]=values[i];\\n        }\\n        \\n        // iterating through the string in the dictionary, encrypting them and maintaining a frequency hashmap m2\\n        \\n        for(auto i:dictionary)\\n        {\\n            string ans=\"\";\\n            \\n            string word1=i;\\n        \\n            for(int i=0;i<word1.size();i++)\\n            {\\n                ans+=m1[word1[i]];\\n            }\\n\\n            if(m2.find(ans)==m2.end())\\n            {\\n                m2[ans]=1;\\n            }\\n            else{\\n                m2[ans]++;\\n            }\\n        }\\n        \\n    }\\n    \\n    string encrypt(string word1) {\\n        \\n        // simple encryption\\n        \\n        string ans=\"\";\\n        \\n        for(int i=0;i<word1.size();i++)\\n        {\\n            ans+=m1[word1[i]];\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int decrypt(string word2) {\\n        \\n        // return the frequency of the word2 in the hashmap m2\\n        \\n        if(m2.find(word2)==m2.end())\\n        {\\n            return 0;\\n        }\\n        return m2[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n\\n```\\n",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string> m1;\\n    unordered_map<string,int> m2;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        \\n        // storing all the characters along with their encryption keys\\n\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            m1[keys[i]]=values[i];\\n        }\\n        \\n        // iterating through the string in the dictionary, encrypting them and maintaining a frequency hashmap m2\\n        \\n        for(auto i:dictionary)\\n        {\\n            string ans=\"\";\\n            \\n            string word1=i;\\n        \\n            for(int i=0;i<word1.size();i++)\\n            {\\n                ans+=m1[word1[i]];\\n            }\\n\\n            if(m2.find(ans)==m2.end())\\n            {\\n                m2[ans]=1;\\n            }\\n            else{\\n                m2[ans]++;\\n            }\\n        }\\n        \\n    }\\n    \\n    string encrypt(string word1) {\\n        \\n        // simple encryption\\n        \\n        string ans=\"\";\\n        \\n        for(int i=0;i<word1.size();i++)\\n        {\\n            ans+=m1[word1[i]];\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int decrypt(string word2) {\\n        \\n        // return the frequency of the word2 in the hashmap m2\\n        \\n        if(m2.find(word2)==m2.end())\\n        {\\n            return 0;\\n        }\\n        return m2[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908733,
                "title": "cpp-straight-forward-solution",
                "content": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char, string> lookup;\\n    vector<string> dict;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        dict = dictionary;\\n        for(int i = 0; i < keys.size(); i++) {\\n            lookup[keys[i]] = values[i];\\n        }\\n        \\n    }\\n    string encrypt(string word1) {\\n        string res = \"\";\\n        for(auto key : word1) res += lookup[key];\\n        return res;\\n    }\\n    \\n    //generate all decrypted words from words in dictonary\\n    int decrypt(string word2) {\\n        int cnt = 0;\\n        for(auto word : dict) {\\n            string s = \"\";\\n            for(auto key : word) {\\n                s += lookup[key];\\n            }\\n            \\n            if(s == word2) cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char, string> lookup;\\n    vector<string> dict;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        dict = dictionary;\\n        for(int i = 0; i < keys.size(); i++) {\\n            lookup[keys[i]] = values[i];\\n        }\\n        \\n    }\\n    string encrypt(string word1) {\\n        string res = \"\";\\n        for(auto key : word1) res += lookup[key];\\n        return res;\\n    }\\n    \\n    //generate all decrypted words from words in dictonary\\n    int decrypt(string word2) {\\n        int cnt = 0;\\n        for(auto word : dict) {\\n            string s = \"\";\\n            for(auto key : word) {\\n                s += lookup[key];\\n            }\\n            \\n            if(s == word2) cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018573,
                "title": "rust-solution",
                "content": "# Code\\n```\\nuse std::collections::HashMap;\\n\\nstruct Encrypter {\\n    map: HashMap<char, String>,\\n    dictionary: HashMap<String, i32>,\\n}\\n\\nimpl Encrypter {\\n    fn new(keys: Vec<char>, values: Vec<String>, dictionary: Vec<String>) -> Self {\\n        let map: HashMap<char, String> = keys.into_iter().zip(values.into_iter()).collect();\\n        let mut ret = Self { map, dictionary: HashMap::new() };\\n\\n        ret.dictionary = dictionary.into_iter().fold(HashMap::new(), |mut dict, word| {\\n            let word = ret.encrypt(word);\\n            if !word.is_empty() {\\n                dict.entry(word).and_modify(|e| *e += 1).or_insert(1);\\n            }\\n            dict\\n        });\\n        ret\\n    }\\n\\n    fn encrypt(&self, word1: String) -> String {\\n        let mut ret = String::new();\\n        for c in word1.chars() {\\n            if let Some(s) = self.map.get(&c) {\\n                ret.push_str(s.as_str());\\n            } else {\\n                return String::new();\\n            }\\n        }\\n        ret\\n    }\\n\\n    fn decrypt(&self, word2: String) -> i32 { self.dictionary.get(&word2).cloned().unwrap_or(0) }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nstruct Encrypter {\\n    map: HashMap<char, String>,\\n    dictionary: HashMap<String, i32>,\\n}\\n\\nimpl Encrypter {\\n    fn new(keys: Vec<char>, values: Vec<String>, dictionary: Vec<String>) -> Self {\\n        let map: HashMap<char, String> = keys.into_iter().zip(values.into_iter()).collect();\\n        let mut ret = Self { map, dictionary: HashMap::new() };\\n\\n        ret.dictionary = dictionary.into_iter().fold(HashMap::new(), |mut dict, word| {\\n            let word = ret.encrypt(word);\\n            if !word.is_empty() {\\n                dict.entry(word).and_modify(|e| *e += 1).or_insert(1);\\n            }\\n            dict\\n        });\\n        ret\\n    }\\n\\n    fn encrypt(&self, word1: String) -> String {\\n        let mut ret = String::new();\\n        for c in word1.chars() {\\n            if let Some(s) = self.map.get(&c) {\\n                ret.push_str(s.as_str());\\n            } else {\\n                return String::new();\\n            }\\n        }\\n        ret\\n    }\\n\\n    fn decrypt(&self, word2: String) -> i32 { self.dictionary.get(&word2).cloned().unwrap_or(0) }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3996812,
                "title": "2-typescript-javascript-solutions-reverse-lookup-and-trie",
                "content": "# Code\\n\\n## Using Reverse Lookup (~200ms)\\n(Encrypt all dictionary words and lookup count during decryption.)\\n```\\nclass Encrypter {\\n  private keysToValues: { [key: string]: string } = {};\\n  private encryptionCount: { [word: string]: number } = {};\\n  \\n  constructor(keys: string[], values: string[], dictionary: string[]) {\\n    for (let i = 0; i < keys.length; i++) {\\n      this.keysToValues[keys[i]] = values[i];\\n    }\\n    for (const word of dictionary) {\\n      const encrypted = this.encrypt(word);\\n      this.encryptionCount[encrypted] ??= 0;\\n      this.encryptionCount[encrypted]++;\\n    }\\n  }\\n\\n  encrypt(word1: string): string {\\n    let encrypted = \"\";\\n    for (const char of word1) {\\n      if (!this.keysToValues[char]) return \"\";\\n      encrypted += this.keysToValues[char];\\n    }\\n    return encrypted;\\n  }\\n\\n  decrypt(word2: string): number {\\n    return this.encryptionCount[word2] ?? 0;\\n  }\\n}\\n```\\n\\n## Using Trie (~1500ms)\\n(Probably the intended solution.)\\n```\\nclass Encrypter {\\n  private trie: TrieNode;\\n  private keysToValues: { [key: string]: string } = {};\\n  private valuesToKeys: { [value: string]: string[] } = {};\\n\\n  constructor(keys: string[], values: string[], dictionary: string[]) {\\n    this.trie = buildTrie(dictionary);\\n    for (let i = 0; i < keys.length; i++) {\\n      const key = keys[i];\\n      const value = values[i];\\n      this.keysToValues[key] = value;\\n      const arr = this.valuesToKeys[value] ?? [];\\n      arr.push(key);\\n      this.valuesToKeys[value] = arr;\\n    }\\n  }\\n\\n  encrypt(word1: string): string {\\n    let encrypted = \"\";\\n    for (const char of word1) {\\n      if (!this.keysToValues[char]) return \"\";\\n      encrypted += this.keysToValues[char];\\n    }\\n    return encrypted;\\n  }\\n\\n  decrypt(word2: string): number {\\n    const possible = [this.trie];\\n    for (let i = 0; i <= word2.length - 2; i += 2) {\\n      for (const trieNode of possible.splice(0, possible.length)) {\\n        for (const key of this.valuesToKeys[word2.slice(i, i + 2)] ?? []) {\\n          const nextNode = trieNode.children[key];\\n          if (nextNode) possible.push(nextNode);\\n        }\\n      }\\n      if (possible.length === 0) break;\\n    }\\n    return possible.filter(({ leaf }) => leaf).length;\\n  }\\n}\\n\\ninterface TrieNode {\\n  char: string;\\n  leaf: boolean;\\n  children: { [char: string]: TrieNode };\\n}\\n\\nconst buildTrie = (\\n  words: string[],\\n  parent: TrieNode = { char: \"\", leaf: false, children: {} }\\n) => {\\n  const wordMap: { [char: string]: string[] } = {};\\n  for (const word of words) {\\n    if (word === \"\") {\\n      parent.leaf = true;\\n      continue;\\n    }\\n    const char = word[0];\\n    const arr = wordMap[char] ?? [];\\n    arr.push(word.slice(1));\\n    wordMap[char] = arr;\\n  }\\n  for (const [char, words] of Object.entries(wordMap)) {\\n    const trieNode = {\\n      char,\\n      leaf: false,\\n      children: {},\\n    };\\n    buildTrie(words, trieNode);\\n    parent.children[char] = trieNode;\\n  }\\n  return parent;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Trie"
                ],
                "code": "```\\nclass Encrypter {\\n  private keysToValues: { [key: string]: string } = {};\\n  private encryptionCount: { [word: string]: number } = {};\\n  \\n  constructor(keys: string[], values: string[], dictionary: string[]) {\\n    for (let i = 0; i < keys.length; i++) {\\n      this.keysToValues[keys[i]] = values[i];\\n    }\\n    for (const word of dictionary) {\\n      const encrypted = this.encrypt(word);\\n      this.encryptionCount[encrypted] ??= 0;\\n      this.encryptionCount[encrypted]++;\\n    }\\n  }\\n\\n  encrypt(word1: string): string {\\n    let encrypted = \"\";\\n    for (const char of word1) {\\n      if (!this.keysToValues[char]) return \"\";\\n      encrypted += this.keysToValues[char];\\n    }\\n    return encrypted;\\n  }\\n\\n  decrypt(word2: string): number {\\n    return this.encryptionCount[word2] ?? 0;\\n  }\\n}\\n```\n```\\nclass Encrypter {\\n  private trie: TrieNode;\\n  private keysToValues: { [key: string]: string } = {};\\n  private valuesToKeys: { [value: string]: string[] } = {};\\n\\n  constructor(keys: string[], values: string[], dictionary: string[]) {\\n    this.trie = buildTrie(dictionary);\\n    for (let i = 0; i < keys.length; i++) {\\n      const key = keys[i];\\n      const value = values[i];\\n      this.keysToValues[key] = value;\\n      const arr = this.valuesToKeys[value] ?? [];\\n      arr.push(key);\\n      this.valuesToKeys[value] = arr;\\n    }\\n  }\\n\\n  encrypt(word1: string): string {\\n    let encrypted = \"\";\\n    for (const char of word1) {\\n      if (!this.keysToValues[char]) return \"\";\\n      encrypted += this.keysToValues[char];\\n    }\\n    return encrypted;\\n  }\\n\\n  decrypt(word2: string): number {\\n    const possible = [this.trie];\\n    for (let i = 0; i <= word2.length - 2; i += 2) {\\n      for (const trieNode of possible.splice(0, possible.length)) {\\n        for (const key of this.valuesToKeys[word2.slice(i, i + 2)] ?? []) {\\n          const nextNode = trieNode.children[key];\\n          if (nextNode) possible.push(nextNode);\\n        }\\n      }\\n      if (possible.length === 0) break;\\n    }\\n    return possible.filter(({ leaf }) => leaf).length;\\n  }\\n}\\n\\ninterface TrieNode {\\n  char: string;\\n  leaf: boolean;\\n  children: { [char: string]: TrieNode };\\n}\\n\\nconst buildTrie = (\\n  words: string[],\\n  parent: TrieNode = { char: \"\", leaf: false, children: {} }\\n) => {\\n  const wordMap: { [char: string]: string[] } = {};\\n  for (const word of words) {\\n    if (word === \"\") {\\n      parent.leaf = true;\\n      continue;\\n    }\\n    const char = word[0];\\n    const arr = wordMap[char] ?? [];\\n    arr.push(word.slice(1));\\n    wordMap[char] = arr;\\n  }\\n  for (const [char, words] of Object.entries(wordMap)) {\\n    const trieNode = {\\n      char,\\n      leaf: false,\\n      children: {},\\n    };\\n    buildTrie(words, trieNode);\\n    parent.children[char] = trieNode;\\n  }\\n  return parent;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958315,
                "title": "encrypt-decrypt-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Time:  ctor:    O(m + d), m is len(keys), d is sum(len(x) for x in dictionary)\\n//        encrypt: O(n)\\n//        decrypt: O(n)\\n// Space: O(m + d)\\n\\n// freq table\\nclass Encrypter {\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < size(keys); ++i) {\\n            lookup_[keys[i]] = values[i];\\n        }\\n        for (const auto& x : dictionary) {\\n            ++cnt_[encrypt(x)];\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string result;\\n        for (const auto& c : word1) {\\n            if (!lookup_.count(c)) {\\n                return \"\";\\n            }\\n            result += lookup_[c];\\n        }\\n        return result;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return cnt_[word2];\\n    }\\n\\nprivate:\\n    unordered_map<char, string> lookup_;\\n    unordered_map<string, int> cnt_;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String",
                    "Design",
                    "Trie"
                ],
                "code": "```\\n// Time:  ctor:    O(m + d), m is len(keys), d is sum(len(x) for x in dictionary)\\n//        encrypt: O(n)\\n//        decrypt: O(n)\\n// Space: O(m + d)\\n\\n// freq table\\nclass Encrypter {\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < size(keys); ++i) {\\n            lookup_[keys[i]] = values[i];\\n        }\\n        for (const auto& x : dictionary) {\\n            ++cnt_[encrypt(x)];\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string result;\\n        for (const auto& c : word1) {\\n            if (!lookup_.count(c)) {\\n                return \"\";\\n            }\\n            result += lookup_[c];\\n        }\\n        return result;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return cnt_[word2];\\n    }\\n\\nprivate:\\n    unordered_map<char, string> lookup_;\\n    unordered_map<string, int> cnt_;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899951,
                "title": "typescript-hash-table-time-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Encrypter {\\n    private _keyMap: Map<string, string>;\\n    private _decryptedWordMap: Map<string, number>;\\n\\n    constructor(keys: string[], values: string[], dictionary: string[]) {\\n        this._keyMap = new Map();\\n        this._decryptedWordMap = new Map();\\n\\n        keys.forEach((key, i) => {\\n            this._keyMap.set(key, values[i]);\\n        });\\n\\n        dictionary.forEach((word) => {\\n            const decryptedWord = this.encrypt(word);\\n            const decryptedWordNum = this._decryptedWordMap.get(decryptedWord);\\n\\n            if (decryptedWordNum !== undefined)\\n                this._decryptedWordMap.set(decryptedWord, decryptedWordNum + 1);\\n            else\\n                this._decryptedWordMap.set(decryptedWord, 1);\\n        });\\n    }\\n\\n    encrypt(word1: string): string {\\n        let decryptedWord1 = \"\";\\n\\n        word1.split(\"\").forEach((char) => {\\n            decryptedWord1 += this._keyMap.get(char);\\n        });\\n\\n        return decryptedWord1;\\n    }\\n\\n    decrypt(word2: string): number {\\n        const decryptedWordNum = this._decryptedWordMap.get(word2);\\n\\n        if (decryptedWordNum)\\n            return decryptedWordNum\\n        else\\n            return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Hash Table"
                ],
                "code": "```\\nclass Encrypter {\\n    private _keyMap: Map<string, string>;\\n    private _decryptedWordMap: Map<string, number>;\\n\\n    constructor(keys: string[], values: string[], dictionary: string[]) {\\n        this._keyMap = new Map();\\n        this._decryptedWordMap = new Map();\\n\\n        keys.forEach((key, i) => {\\n            this._keyMap.set(key, values[i]);\\n        });\\n\\n        dictionary.forEach((word) => {\\n            const decryptedWord = this.encrypt(word);\\n            const decryptedWordNum = this._decryptedWordMap.get(decryptedWord);\\n\\n            if (decryptedWordNum !== undefined)\\n                this._decryptedWordMap.set(decryptedWord, decryptedWordNum + 1);\\n            else\\n                this._decryptedWordMap.set(decryptedWord, 1);\\n        });\\n    }\\n\\n    encrypt(word1: string): string {\\n        let decryptedWord1 = \"\";\\n\\n        word1.split(\"\").forEach((char) => {\\n            decryptedWord1 += this._keyMap.get(char);\\n        });\\n\\n        return decryptedWord1;\\n    }\\n\\n    decrypt(word2: string): number {\\n        const decryptedWordNum = this._decryptedWordMap.get(word2);\\n\\n        if (decryptedWordNum)\\n            return decryptedWordNum\\n        else\\n            return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874459,
                "title": "python-simple-solution-beats-96-92",
                "content": "# Code\\n```\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.key2value={}\\n        for k,v in zip(keys,values):\\n            self.key2value[k]=v\\n        self.dictionary=Counter()\\n        for d in dictionary:\\n            self.dictionary[self.encrypt(d)]+=1\\n\\n    def encrypt(self, word1: str) -> str:\\n        res=[]\\n        for c in word1:\\n            if c in self.key2value:\\n                res.append(self.key2value[c])\\n            else:\\n                return \"\"\\n        return \"\".join(res)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return  self.dictionary[word2]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.key2value={}\\n        for k,v in zip(keys,values):\\n            self.key2value[k]=v\\n        self.dictionary=Counter()\\n        for d in dictionary:\\n            self.dictionary[self.encrypt(d)]+=1\\n\\n    def encrypt(self, word1: str) -> str:\\n        res=[]\\n        for c in word1:\\n            if c in self.key2value:\\n                res.append(self.key2value[c])\\n            else:\\n                return \"\"\\n        return \"\".join(res)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return  self.dictionary[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750883,
                "title": "c-solution-without-trie-hashing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Encrypter {\\n    public:\\n    unordered_map<char,string>mp;\\n    unordered_map<string,unordered_map<char,int>>revMp;\\n    unordered_map<int,vector<string>>dict;\\n\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            mp[keys[i]] = values[i];\\n            revMp[values[i]][keys[i]]++;\\n        }\\n        for(auto &i:dictionary)\\n        {\\n            dict[i.length()].push_back(i);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto& i:word1)\\n        {\\n            if(mp.find(i) == mp.end())\\n            return \"\";\\n            ans+=mp[i];\\n        }\\n    return ans;\\n    }\\n    \\n    int decrypt(string word2){\\n        if(word2.length() % 2 )\\n        return 0;\\n        vector<string>&v = dict[word2.length()/2];\\n        int res=0;\\n        for(auto &i : v)\\n        {\\n            bool ok = true;\\n            int x = 0;\\n            for(int j=0;j<i.length();j++)\\n            {\\n                if(revMp[word2.substr(x,2)][i[j]] == 0)\\n                {\\n                    ok=false;\\n                    break;\\n                }\\n                x+=2;\\n            }\\n\\n            if(ok)\\n            res++;\\n        }\\n    return res;\\n    }\\n};\\n\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Encrypter {\\n    public:\\n    unordered_map<char,string>mp;\\n    unordered_map<string,unordered_map<char,int>>revMp;\\n    unordered_map<int,vector<string>>dict;\\n\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            mp[keys[i]] = values[i];\\n            revMp[values[i]][keys[i]]++;\\n        }\\n        for(auto &i:dictionary)\\n        {\\n            dict[i.length()].push_back(i);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto& i:word1)\\n        {\\n            if(mp.find(i) == mp.end())\\n            return \"\";\\n            ans+=mp[i];\\n        }\\n    return ans;\\n    }\\n    \\n    int decrypt(string word2){\\n        if(word2.length() % 2 )\\n        return 0;\\n        vector<string>&v = dict[word2.length()/2];\\n        int res=0;\\n        for(auto &i : v)\\n        {\\n            bool ok = true;\\n            int x = 0;\\n            for(int j=0;j<i.length();j++)\\n            {\\n                if(revMp[word2.substr(x,2)][i[j]] == 0)\\n                {\\n                    ok=false;\\n                    break;\\n                }\\n                x+=2;\\n            }\\n\\n            if(ok)\\n            res++;\\n        }\\n    return res;\\n    }\\n};\\n\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676976,
                "title": "python3-hashmap-solution",
                "content": "\\n# Code\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.mapping = {}\\n        self.countDict = defaultdict(int)\\n        for i in range(len(keys)):\\n            self.mapping[keys[i]]=values[i]\\n        for key in dictionary:\\n            self.countDict[self.encrypt(key,0)] += 1\\n    def encrypt(self, word1: str,init = 1) -> str:\\n        ans = \"\"\\n        for ch in word1:\\n            if ch in self.mapping:\\n                ans+=self.mapping[ch]\\n            else:\\n                if init==0: return \"\"\\n                ans+=ch\\n        return ans\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.countDict[word2]\\n\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.mapping = {}\\n        self.countDict = defaultdict(int)\\n        for i in range(len(keys)):\\n            self.mapping[keys[i]]=values[i]\\n        for key in dictionary:\\n            self.countDict[self.encrypt(key,0)] += 1\\n    def encrypt(self, word1: str,init = 1) -> str:\\n        ans = \"\"\\n        for ch in word1:\\n            if ch in self.mapping:\\n                ans+=self.mapping[ch]\\n            else:\\n                if init==0: return \"\"\\n                ans+=ch\\n        return ans\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.countDict[word2]\\n\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661824,
                "title": "c-python-trie-hash-map-solution-with-explanation",
                "content": "use a hash map to record mapping of letter to values.\\nuse Trie to store word of dictionary after encrypting, if the word  after encrypting is empty string, pass it.\\n\\ntc: \\n__init__ O(len(keys) + O(len(dictionary)))\\nencrypt O(n)\\ndecrypt O(n)\\n\\nsc is O(len(dictionary) * 100)\\n\\n### c++\\n```cpp\\nclass Trie {\\npublic:\\n    int cnt;\\n    Trie* child[26];\\n    Trie(): cnt(0), child{} {};\\n};\\n\\nclass Encrypter {\\npublic:\\n    string* map[26];\\n    Trie* root;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary): map{nullptr}, root{nullptr} {\\n        for (int i = 0, size = keys.size(); i < size; i+=1) map[keys[i]-\\'a\\'] = &values[i];\\n        this -> root = new Trie();\\n        auto insert = [&] (const string& word) -> void {\\n            if (word.empty()) return;\\n            Trie* cur = this -> root;\\n            for (auto& ch: word) {\\n                if (cur -> child[ch-\\'a\\'] == nullptr) cur -> child[ch-\\'a\\'] = new Trie();\\n                cur = cur -> child[ch-\\'a\\'];\\n            }\\n            cur -> cnt += 1;\\n        };\\n        for (auto& word: dictionary) insert(this -> encrypt(word));\\n    }\\n    \\n    string encrypt(string word1) {\\n        string s;\\n        for (auto& ch: word1) {\\n            if (!this -> map[ch - \\'a\\']) return \"\";\\n            s += *(this -> map[ch - \\'a\\']);\\n        }\\n        return s;\\n    }\\n    \\n    int decrypt(string word2) {\\n        Trie* cur = this -> root;\\n        for (auto& ch: word2) {\\n            if (! cur -> child[ch -\\'a\\']) return 0;\\n            cur = cur -> child[ch -\\'a\\'];\\n        }\\n        return cur -> cnt;\\n    }\\n};\\n```\\n### python\\n```python\\nclass Trie:\\n    def __init__(self):\\n        self.childs = {}\\n        self.cnt = 0\\n\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.map = {k:v for k, v in zip(keys, values)}\\n        self.root = Trie()\\n        def insert(word):\\n            if not word: return\\n            cur = self.root\\n            for ch in word:\\n                if ch not in cur.childs: cur.childs[ch] = Trie()\\n                cur = cur.childs[ch]\\n            cur.cnt += 1\\n\\n        for word in dictionary:\\n            insert(self.encrypt(word))\\n\\n    def encrypt(self, word1: str) -> str:\\n        string = []\\n        for ch in word1:\\n            if ch not in self.map: return \\'\\'\\n            string.append(self.map[ch])\\n        return \\'\\'.join(string)\\n        \\n    def decrypt(self, word2: str) -> int:\\n        cur = self.root\\n        for idx, ch in enumerate(word2):\\n            if ch not in cur.childs: return 0\\n            cur = cur.childs[ch]\\n        return cur.cnt\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Hash Table",
                    "Trie"
                ],
                "code": "```cpp\\nclass Trie {\\npublic:\\n    int cnt;\\n    Trie* child[26];\\n    Trie(): cnt(0), child{} {};\\n};\\n\\nclass Encrypter {\\npublic:\\n    string* map[26];\\n    Trie* root;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary): map{nullptr}, root{nullptr} {\\n        for (int i = 0, size = keys.size(); i < size; i+=1) map[keys[i]-\\'a\\'] = &values[i];\\n        this -> root = new Trie();\\n        auto insert = [&] (const string& word) -> void {\\n            if (word.empty()) return;\\n            Trie* cur = this -> root;\\n            for (auto& ch: word) {\\n                if (cur -> child[ch-\\'a\\'] == nullptr) cur -> child[ch-\\'a\\'] = new Trie();\\n                cur = cur -> child[ch-\\'a\\'];\\n            }\\n            cur -> cnt += 1;\\n        };\\n        for (auto& word: dictionary) insert(this -> encrypt(word));\\n    }\\n    \\n    string encrypt(string word1) {\\n        string s;\\n        for (auto& ch: word1) {\\n            if (!this -> map[ch - \\'a\\']) return \"\";\\n            s += *(this -> map[ch - \\'a\\']);\\n        }\\n        return s;\\n    }\\n    \\n    int decrypt(string word2) {\\n        Trie* cur = this -> root;\\n        for (auto& ch: word2) {\\n            if (! cur -> child[ch -\\'a\\']) return 0;\\n            cur = cur -> child[ch -\\'a\\'];\\n        }\\n        return cur -> cnt;\\n    }\\n};\\n```\n```python\\nclass Trie:\\n    def __init__(self):\\n        self.childs = {}\\n        self.cnt = 0\\n\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.map = {k:v for k, v in zip(keys, values)}\\n        self.root = Trie()\\n        def insert(word):\\n            if not word: return\\n            cur = self.root\\n            for ch in word:\\n                if ch not in cur.childs: cur.childs[ch] = Trie()\\n                cur = cur.childs[ch]\\n            cur.cnt += 1\\n\\n        for word in dictionary:\\n            insert(self.encrypt(word))\\n\\n    def encrypt(self, word1: str) -> str:\\n        string = []\\n        for ch in word1:\\n            if ch not in self.map: return \\'\\'\\n            string.append(self.map[ch])\\n        return \\'\\'.join(string)\\n        \\n    def decrypt(self, word2: str) -> int:\\n        cur = self.root\\n        for idx, ch in enumerate(word2):\\n            if ch not in cur.childs: return 0\\n            cur = cur.childs[ch]\\n        return cur.cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613010,
                "title": "straight-forward-solution-187ms-runtime-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor encryption - since for every character in string \\'c\\' present in key[i] we need to fetch values[i], we\\'ll build a dictionary mapping each key[i] to valeus[i] so we can get value associated with each key-character in O(1).\\n\\nFor decryption - since we need to find possible strings in valid \\'dictionary\\' array that we can encrypt to get this string that we are currently trying to decrypt, we can simply encrypt all the possible/valid string provided already in \\'dictionary\\' array, and see how many of those strings can map to same encrypted result (that we are currently tryint to decrypt)\\n\\nFor both of these steps since we need to build dictionaries, we perform the pre-computation steps needed in constructor.\\n\\n![Screenshot 2023-06-08 145030.png](https://assets.leetcode.com/users/images/b0531d62-cd4f-4283-8292-6e2d8fc57fd4_1686216056.4274116.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**Constructor / Pre-processing** - O(D*N) -> D is number of words in dictionary and N is the max number of characters in a word (as we are calling Encrypt for each word)\\n**Encrypt** - O(N) -> N is the number of characters in the word to encrypt\\n**Decrypt** - O(1)\\n\\nOverall - O(D*N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**Constructor / Pre-processing** - O(D) -> D is number of words in dictionary that we are storing in Dictionary\\n**Encrypt** - O(N) -> as we are using a StringBuilder\\n**Decrypt** - O(1)\\n\\nOverall - O(D)\\n\\n## Please upvote if you like the approach\\n\\n# Code\\n```\\npublic class Encrypter {\\n    char[] keys;\\n    string[] values;\\n    string[] dictionary;\\n\\n    //for encrypt\\n    Dictionary<char, string> keyMap;\\n\\n    //for decrypt\\n    Dictionary<string, int> valueMap;\\n\\n    public Encrypter(char[] keys, string[] values, string[] dictionary) {\\n        this.keys = keys;\\n        this.values = values;\\n        this.dictionary = dictionary;\\n\\n        keyMap = new Dictionary<char, string>();\\n        for (int i = 0; i < keys.Length; i++)\\n            keyMap[keys[i]] = values[i];\\n\\n        valueMap = new Dictionary<string, int>();\\n        for (int i = 0; i < dictionary.Length; i++)\\n        {\\n            string str = Encrypt(dictionary[i]);\\n            if (!valueMap.ContainsKey(str))\\n            {\\n                valueMap.Add(str, 1);\\n            }\\n            else\\n            {\\n                valueMap[str]++;\\n            }\\n        }\\n    }\\n    \\n    public string Encrypt(string word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < word1.Length; i++)\\n        {\\n            if (keyMap.TryGetValue(word1[i], out string str))\\n            {\\n                sb.Append(str);\\n            }\\n            else\\n            {\\n                return \"\";\\n            }\\n        }\\n\\n        return sb.ToString();\\n    }\\n    \\n    public int Decrypt(string word2) {\\n        if(valueMap.TryGetValue(word2, out int result))\\n            return result;\\n        else\\n            return 0;\\n    }\\n}\\n```\\n\\n## Please upvote if you like the approach",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Hash Table",
                    "String",
                    "Design"
                ],
                "code": "```\\npublic class Encrypter {\\n    char[] keys;\\n    string[] values;\\n    string[] dictionary;\\n\\n    //for encrypt\\n    Dictionary<char, string> keyMap;\\n\\n    //for decrypt\\n    Dictionary<string, int> valueMap;\\n\\n    public Encrypter(char[] keys, string[] values, string[] dictionary) {\\n        this.keys = keys;\\n        this.values = values;\\n        this.dictionary = dictionary;\\n\\n        keyMap = new Dictionary<char, string>();\\n        for (int i = 0; i < keys.Length; i++)\\n            keyMap[keys[i]] = values[i];\\n\\n        valueMap = new Dictionary<string, int>();\\n        for (int i = 0; i < dictionary.Length; i++)\\n        {\\n            string str = Encrypt(dictionary[i]);\\n            if (!valueMap.ContainsKey(str))\\n            {\\n                valueMap.Add(str, 1);\\n            }\\n            else\\n            {\\n                valueMap[str]++;\\n            }\\n        }\\n    }\\n    \\n    public string Encrypt(string word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < word1.Length; i++)\\n        {\\n            if (keyMap.TryGetValue(word1[i], out string str))\\n            {\\n                sb.Append(str);\\n            }\\n            else\\n            {\\n                return \"\";\\n            }\\n        }\\n\\n        return sb.ToString();\\n    }\\n    \\n    public int Decrypt(string word2) {\\n        if(valueMap.TryGetValue(word2, out int result))\\n            return result;\\n        else\\n            return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594273,
                "title": "python-simple-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Encrypter:\\n    def __init__(self, keys, values, dictionary):\\n        self.dict1 = {i:j for i,j in zip(keys,values)}\\n        self.dict2 = defaultdict(list)\\n        self.dictionary = dictionary\\n\\n        for i,j in zip(values,keys):\\n            self.dict2[i].append(j)\\n\\n    def encrypt(self, word1):\\n        str1 = \"\"\\n\\n        for i in word1:\\n            if i not in self.dict1:\\n                return \"\"\\n            else:\\n                str1 += self.dict1[i]\\n\\n        return str1\\n\\n    def decrypt(self, word2):\\n        total = 0\\n\\n        for i in self.dictionary:\\n            if self.encrypt(i) == word2:\\n                total += 1\\n\\n        return total\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Encrypter:\\n    def __init__(self, keys, values, dictionary):\\n        self.dict1 = {i:j for i,j in zip(keys,values)}\\n        self.dict2 = defaultdict(list)\\n        self.dictionary = dictionary\\n\\n        for i,j in zip(values,keys):\\n            self.dict2[i].append(j)\\n\\n    def encrypt(self, word1):\\n        str1 = \"\"\\n\\n        for i in word1:\\n            if i not in self.dict1:\\n                return \"\"\\n            else:\\n                str1 += self.dict1[i]\\n\\n        return str1\\n\\n    def decrypt(self, word2):\\n        total = 0\\n\\n        for i in self.dictionary:\\n            if self.encrypt(i) == word2:\\n                total += 1\\n\\n        return total\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590876,
                "title": "c-simple-solution-using-two-dictionaries",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe want a keys[i] -> values[i] dictionary to easily encrypt a character in O(1) and a word in O(n) where n is the length of the word.\\n\\nSimilarly, for an O(1) decryption we want to pre-process all of the strings in the given dictionary upon Encrypter construction.\\n\\nThe Encrytper would run in O(n) where n is the number of strings in the dictionary. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a dicitonary mapping chars to strings (keys to values).\\nUse a dicitonary mapping words to count the number of possible strings word2 could decrypt to that also appear in dictionary.\\nProcess the above in Encrypter.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nEncrypter O(n)\\nEncrypt O(n)\\nDecrypt O(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nEncrypter O(n)\\nEncrypt O(1)\\nDecrypt O(1)\\n\\n# Code\\n```\\npublic class Encrypter {\\n\\n    Dictionary<char, string> keyToValue = new Dictionary<char,string>();\\n    Dictionary<string,int> fullDict = new Dictionary<string,int>();\\n\\n    public Encrypter(char[] keys, string[] values, string[] dictionary) {\\n        for(int i = 0; i < keys.Length; i++) {\\n            keyToValue[keys[i]] = values[i];\\n        }\\n        \\n        for (int j = 0; j < dictionary.Length; j++) {\\n            var word = dictionary[j];\\n            var encrypted = Encrypt(word);\\n            var present = fullDict.TryGetValue(encrypted, out var val);\\n            if (!present) {\\n                fullDict.Add(encrypted, 1);\\n            }\\n            else {\\n                val++;\\n                fullDict[encrypted] = val;\\n            }\\n        }\\n    }\\n    \\n    public string Encrypt(string word1) {\\n        var encStr = string.Empty;\\n        for (int i = 0; i < word1.Length; i++) {\\n            var present = keyToValue.TryGetValue(word1[i] , out var val);\\n            if(!present) {\\n                encStr += \"#\";\\n                // gotta add a random value so that strings with no mapping don\\'t increase count in fullDict by mistake\\n                // testcase for this is \\n                //[[[\"b\"],[\"ca\"],[\"aaa\",\"cacbc\",\"bbaba\",\"bb\"]],[\"bbb\"],[\"cacaca\"]]\\n            }\\n            else{\\n                encStr += val; \\n            }          \\n        }\\n        return encStr;\\n    }\\n    \\n    public int Decrypt(string word2) {\\n        var present = fullDict.TryGetValue(word2, out var count);\\n        return present ? count : 0;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj.Encrypt(word1);\\n * int param_2 = obj.Decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Encrypter {\\n\\n    Dictionary<char, string> keyToValue = new Dictionary<char,string>();\\n    Dictionary<string,int> fullDict = new Dictionary<string,int>();\\n\\n    public Encrypter(char[] keys, string[] values, string[] dictionary) {\\n        for(int i = 0; i < keys.Length; i++) {\\n            keyToValue[keys[i]] = values[i];\\n        }\\n        \\n        for (int j = 0; j < dictionary.Length; j++) {\\n            var word = dictionary[j];\\n            var encrypted = Encrypt(word);\\n            var present = fullDict.TryGetValue(encrypted, out var val);\\n            if (!present) {\\n                fullDict.Add(encrypted, 1);\\n            }\\n            else {\\n                val++;\\n                fullDict[encrypted] = val;\\n            }\\n        }\\n    }\\n    \\n    public string Encrypt(string word1) {\\n        var encStr = string.Empty;\\n        for (int i = 0; i < word1.Length; i++) {\\n            var present = keyToValue.TryGetValue(word1[i] , out var val);\\n            if(!present) {\\n                encStr += \"#\";\\n                // gotta add a random value so that strings with no mapping don\\'t increase count in fullDict by mistake\\n                // testcase for this is \\n                //[[[\"b\"],[\"ca\"],[\"aaa\",\"cacbc\",\"bbaba\",\"bb\"]],[\"bbb\"],[\"cacaca\"]]\\n            }\\n            else{\\n                encStr += val; \\n            }          \\n        }\\n        return encStr;\\n    }\\n    \\n    public int Decrypt(string word2) {\\n        var present = fullDict.TryGetValue(word2, out var count);\\n        return present ? count : 0;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj.Encrypt(word1);\\n * int param_2 = obj.Decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405875,
                "title": "simple-java-solution",
                "content": "```\\nclass Encrypter {\\n    HashMap<Character,String> h=new HashMap<Character,String>();\\n    HashMap<String,Integer> map=new HashMap<String,Integer>();\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int i=0;i<keys.length;i++)\\n        {\\n            h.put(keys[i],values[i]);\\n        }\\n        for(int i=0;i<dictionary.length;i++)\\n        {\\n            String str=\"\";\\n            int flag=0;\\n            for(int j=0;j<dictionary[i].length();j++)\\n            {\\n                if(!h.containsKey(dictionary[i].charAt(j)))\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n               str+=h.get(dictionary[i].charAt(j));\\n            }\\n            if(flag==0)\\n            {\\n                if(!map.containsKey(str))\\n                {\\n                    map.put(str,1);\\n                }\\n                else\\n                {\\n                    map.put(str,map.get(str)+1);\\n                }\\n            }\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String str=\"\";\\n        for(int i=0;i<word1.length();i++)\\n        {\\n            str+=h.get(word1.charAt(i));\\n        }\\n\\n        return str;\\n        \\n    }\\n    \\n    public int decrypt(String word2) {\\n        if(map.containsKey(word2))\\n        {\\n            return map.get(word2);\\n        }\\n\\n        return 0;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n    HashMap<Character,String> h=new HashMap<Character,String>();\\n    HashMap<String,Integer> map=new HashMap<String,Integer>();\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int i=0;i<keys.length;i++)\\n        {\\n            h.put(keys[i],values[i]);\\n        }\\n        for(int i=0;i<dictionary.length;i++)\\n        {\\n            String str=\"\";\\n            int flag=0;\\n            for(int j=0;j<dictionary[i].length();j++)\\n            {\\n                if(!h.containsKey(dictionary[i].charAt(j)))\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n               str+=h.get(dictionary[i].charAt(j));\\n            }\\n            if(flag==0)\\n            {\\n                if(!map.containsKey(str))\\n                {\\n                    map.put(str,1);\\n                }\\n                else\\n                {\\n                    map.put(str,map.get(str)+1);\\n                }\\n            }\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String str=\"\";\\n        for(int i=0;i<word1.length();i++)\\n        {\\n            str+=h.get(word1.charAt(i));\\n        }\\n\\n        return str;\\n        \\n    }\\n    \\n    public int decrypt(String word2) {\\n        if(map.containsKey(word2))\\n        {\\n            return map.get(word2);\\n        }\\n\\n        return 0;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352515,
                "title": "c-golang-2-maps",
                "content": "# Code\\n```\\n//--------------------------------------\\n// C++\\n//--------------------------------------\\nclass Encrypter {\\n    unordered_map<char, string> EMap;\\n    unordered_map<string, int> DMap;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i = 0; i < keys.size(); i++) {\\n            EMap[keys[i]] = values[i];\\n        }\\n        for(string word: dictionary) {\\n            string val = \"\";\\n            bool flag = true;\\n            for(char ch: word) {\\n                if(EMap.find(ch) != EMap.end())\\n                    val += EMap[ch];\\n                else {\\n                    flag = false;\\n                    break;\\n                }\\n            } \\n            if(flag)\\n            DMap[val]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(char ch: word1) {\\n            ans += EMap[ch];\\n        } \\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return DMap[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n\\n\\n//--------------------------------------\\n// Golang\\n//--------------------------------------\\ntype Encrypter struct {\\n    EMap map[byte]string\\n    DMap map[string]int\\n}\\n\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n    EMap := make(map[byte]string)\\n    DMap := make(map[string]int)\\n    for i := 0; i < len(keys); i++ {\\n        EMap[keys[i]] = values[i]\\n    }\\n    for _, word := range dictionary {\\n        val := \"\"\\n        flag := true\\n        for _, ch := range word {\\n            if _, ok := EMap[byte(ch)]; ok {\\n                val += EMap[byte(ch)]\\n            } else {\\n                flag = false\\n                break\\n            }\\n        } \\n        if flag {DMap[val]++} \\n    }\\n    return Encrypter {\\n        EMap: EMap,\\n        DMap: DMap,\\n    }\\n}\\n\\n\\nfunc (this *Encrypter) Encrypt(word1 string) string {\\n    ans := \"\"\\n    for _, ch := range word1 {\\n        ans += this.EMap[byte(ch)]\\n    } \\n    return ans\\n}\\n\\n\\nfunc (this *Encrypter) Decrypt(word2 string) int {\\n    return this.DMap[word2]\\n}\\n\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * obj := Constructor(keys, values, dictionary);\\n * param_1 := obj.Encrypt(word1);\\n * param_2 := obj.Decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Hash Table",
                    "String",
                    "Design"
                ],
                "code": "```\\n//--------------------------------------\\n// C++\\n//--------------------------------------\\nclass Encrypter {\\n    unordered_map<char, string> EMap;\\n    unordered_map<string, int> DMap;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i = 0; i < keys.size(); i++) {\\n            EMap[keys[i]] = values[i];\\n        }\\n        for(string word: dictionary) {\\n            string val = \"\";\\n            bool flag = true;\\n            for(char ch: word) {\\n                if(EMap.find(ch) != EMap.end())\\n                    val += EMap[ch];\\n                else {\\n                    flag = false;\\n                    break;\\n                }\\n            } \\n            if(flag)\\n            DMap[val]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(char ch: word1) {\\n            ans += EMap[ch];\\n        } \\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return DMap[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n\\n\\n//--------------------------------------\\n// Golang\\n//--------------------------------------\\ntype Encrypter struct {\\n    EMap map[byte]string\\n    DMap map[string]int\\n}\\n\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n    EMap := make(map[byte]string)\\n    DMap := make(map[string]int)\\n    for i := 0; i < len(keys); i++ {\\n        EMap[keys[i]] = values[i]\\n    }\\n    for _, word := range dictionary {\\n        val := \"\"\\n        flag := true\\n        for _, ch := range word {\\n            if _, ok := EMap[byte(ch)]; ok {\\n                val += EMap[byte(ch)]\\n            } else {\\n                flag = false\\n                break\\n            }\\n        } \\n        if flag {DMap[val]++} \\n    }\\n    return Encrypter {\\n        EMap: EMap,\\n        DMap: DMap,\\n    }\\n}\\n\\n\\nfunc (this *Encrypter) Encrypt(word1 string) string {\\n    ans := \"\"\\n    for _, ch := range word1 {\\n        ans += this.EMap[byte(ch)]\\n    } \\n    return ans\\n}\\n\\n\\nfunc (this *Encrypter) Decrypt(word2 string) int {\\n    return this.DMap[word2]\\n}\\n\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * obj := Constructor(keys, values, dictionary);\\n * param_1 := obj.Encrypt(word1);\\n * param_2 := obj.Decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284893,
                "title": "c-trie-dfs",
                "content": "```\\nclass Encrypter {\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(auto& s:dictionary) add(s);\\n        vals.resize(128);\\n        for(int i=0;i<keys.size();i++){\\n            vals[keys[i]] = values[i];\\n            decodeMap[values[i]].push_back(keys[i]-\\'a\\');\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res;\\n        for(auto c:word1){\\n            if(vals[c].empty()) return {};\\n            res += vals[c];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int res = 0;\\n        decrypt(word2, 0, root, res);\\n        return res;\\n    }\\n\\nprivate:\\n    struct Node{\\n        bool isWord = false;\\n        Node* child[26] = {nullptr};\\n    };\\n\\n    void add(const string& s){\\n        auto p = root;\\n        for(auto c:s){\\n            if(!p->child[c-\\'a\\']) p->child[c-\\'a\\'] = new Node();\\n            p = p->child[c-\\'a\\'];\\n        }\\n        p->isWord = true;\\n    }\\n\\n    void decrypt(const string& s, int i, Node* p, int& res){\\n        if(!p) return;\\n        if(i == s.size()){\\n            if(p->isWord) res++;\\n            return;\\n        }\\n        auto& v = decodeMap[s.substr(i, 2)];\\n        for(auto c:v){\\n            decrypt(s, i+2, p->child[c], res);\\n        }\\n    }\\n    \\n    Node* root = new Node();\\n    vector<string> vals;\\n    unordered_map<string, vector<int>> decodeMap;\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(auto& s:dictionary) add(s);\\n        vals.resize(128);\\n        for(int i=0;i<keys.size();i++){\\n            vals[keys[i]] = values[i];\\n            decodeMap[values[i]].push_back(keys[i]-\\'a\\');\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res;\\n        for(auto c:word1){\\n            if(vals[c].empty()) return {};\\n            res += vals[c];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int res = 0;\\n        decrypt(word2, 0, root, res);\\n        return res;\\n    }\\n\\nprivate:\\n    struct Node{\\n        bool isWord = false;\\n        Node* child[26] = {nullptr};\\n    };\\n\\n    void add(const string& s){\\n        auto p = root;\\n        for(auto c:s){\\n            if(!p->child[c-\\'a\\']) p->child[c-\\'a\\'] = new Node();\\n            p = p->child[c-\\'a\\'];\\n        }\\n        p->isWord = true;\\n    }\\n\\n    void decrypt(const string& s, int i, Node* p, int& res){\\n        if(!p) return;\\n        if(i == s.size()){\\n            if(p->isWord) res++;\\n            return;\\n        }\\n        auto& v = decodeMap[s.substr(i, 2)];\\n        for(auto c:v){\\n            decrypt(s, i+2, p->child[c], res);\\n        }\\n    }\\n    \\n    Node* root = new Node();\\n    vector<string> vals;\\n    unordered_map<string, vector<int>> decodeMap;\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283180,
                "title": "c-solution-with-comments",
                "content": "unordered_map<char, string>m;\\n    unordered_map<string, int>dict;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n   //key--->value ki mapping kro\\n     int n = keys.size();   \\n     for(int i=0; i<n; i++){\\n         m[keys[i]] = values[i];\\n     }   \\n     //dictionary ke words  ko encrypt krkr unn encrypted words ki frequency store kro..   \\n     n = dictionary.size();  \\n     for(int i=0; i<n; i++){\\n        dict[encrypt(dictionary[i])]++; \\n     }   \\n    }\\n    \\n    string encrypt(string word1) {\\n    //map ki help de word1 ko encrypt kro\\n    int n = word1.size();  \\n      string ans = \"\";  \\n        for(int i=0; i<n; i++){\\n            if(m.find(word1[i]) == m.end())return \"\";\\n            else{\\n                ans += m[word1[i]];\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n   //map ke through word ko decrypt kro\\n        if(dict.find(word2) == dict.end())return 0;``\\n        return dict[word2];\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "unordered_map<char, string>m;\\n    unordered_map<string, int>dict;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n   //key--->value ki mapping kro\\n     int n = keys.size();   \\n     for(int i=0; i<n; i++){\\n         m[keys[i]] = values[i];\\n     }   \\n     //dictionary ke words  ko encrypt krkr unn encrypted words ki frequency store kro..   \\n     n = dictionary.size();  \\n     for(int i=0; i<n; i++){\\n        dict[encrypt(dictionary[i])]++; \\n     }   \\n    }\\n    \\n    string encrypt(string word1) {\\n    //map ki help de word1 ko encrypt kro\\n    int n = word1.size();  \\n      string ans = \"\";  \\n        for(int i=0; i<n; i++){\\n            if(m.find(word1[i]) == m.end())return \"\";\\n            else{\\n                ans += m[word1[i]];\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n   //map ke through word ko decrypt kro\\n        if(dict.find(word2) == dict.end())return 0;``\\n        return dict[word2];\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3254331,
                "title": "using-hashmap",
                "content": "\\n# Code\\n```\\nclass Encrypter {\\n    Map<Character,String> encryptionMap;\\n    Map<String,Integer> wayToDecrypt;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        encryptionMap=new HashMap<>();\\n        for(int i=0;i<keys.length;i++){\\n            encryptionMap.put(keys[i],values[i]);\\n        }\\n        wayToDecrypt=new HashMap<>();\\n        for(String w:dictionary){\\n            String encryptedStr=encrypt(w);\\n            wayToDecrypt.put(encryptedStr,wayToDecrypt.getOrDefault(encryptedStr,0)+1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder encryptedStr=new StringBuilder();\\n        for(int i=0;i<word1.length();i++)\\n            encryptedStr.append(encryptionMap.getOrDefault(word1.charAt(i),\"#\"));\\n        return encryptedStr.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return wayToDecrypt.getOrDefault(word2,0);\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n    Map<Character,String> encryptionMap;\\n    Map<String,Integer> wayToDecrypt;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        encryptionMap=new HashMap<>();\\n        for(int i=0;i<keys.length;i++){\\n            encryptionMap.put(keys[i],values[i]);\\n        }\\n        wayToDecrypt=new HashMap<>();\\n        for(String w:dictionary){\\n            String encryptedStr=encrypt(w);\\n            wayToDecrypt.put(encryptedStr,wayToDecrypt.getOrDefault(encryptedStr,0)+1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder encryptedStr=new StringBuilder();\\n        for(int i=0;i<word1.length();i++)\\n            encryptedStr.append(encryptionMap.getOrDefault(word1.charAt(i),\"#\"));\\n        return encryptedStr.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return wayToDecrypt.getOrDefault(word2,0);\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243268,
                "title": "java-simple-solution-using-hashmap-and-its-methods",
                "content": "\\n\\n# Code\\n```\\nclass Encrypter {\\n    Map<Character,String> encryptionMap;\\n    Map<String,Integer> wayToDecrypt;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        encryptionMap=new HashMap<>();\\n        for(int i=0;i<keys.length;i++){\\n            encryptionMap.put(keys[i],values[i]);\\n        }\\n        wayToDecrypt=new HashMap<>();\\n        for(String w:dictionary){\\n            String encryptedStr=encrypt(w);\\n            wayToDecrypt.put(encryptedStr,wayToDecrypt.getOrDefault(encryptedStr,0)+1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder encryptedStr=new StringBuilder();\\n        for(int i=0;i<word1.length();i++)\\n            encryptedStr.append(encryptionMap.getOrDefault(word1.charAt(i),\"#\"));\\n        return encryptedStr.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return wayToDecrypt.getOrDefault(word2,0);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Encrypter {\\n    Map<Character,String> encryptionMap;\\n    Map<String,Integer> wayToDecrypt;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        encryptionMap=new HashMap<>();\\n        for(int i=0;i<keys.length;i++){\\n            encryptionMap.put(keys[i],values[i]);\\n        }\\n        wayToDecrypt=new HashMap<>();\\n        for(String w:dictionary){\\n            String encryptedStr=encrypt(w);\\n            wayToDecrypt.put(encryptedStr,wayToDecrypt.getOrDefault(encryptedStr,0)+1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder encryptedStr=new StringBuilder();\\n        for(int i=0;i<word1.length();i++)\\n            encryptedStr.append(encryptionMap.getOrDefault(word1.charAt(i),\"#\"));\\n        return encryptedStr.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return wayToDecrypt.getOrDefault(word2,0);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105951,
                "title": "simple-solution-100-faster-using-hashtable-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we will save values for encryption and as we have to decrypt word2 and see how many words can be made that lie in dict , so we will make encryption for words in dict and count in how many ways that encryption can be decrypted , so we can simply return in decrypt call .\\n![image.png](https://assets.leetcode.com/users/images/b48e583f-c741-4e4f-b8d9-9b7d0c74e89e_1674834382.4091935.png)\\n\\n# Complexity\\n- Time complexity: O(dict[i]*dict.length + word1.length**calls to encrypt)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Encrypter {\\npublic:\\n    vector<string> val;\\n    unordered_map<string,int> m;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dict) {\\n        val.resize(26,\"\");\\n        for(int i=0;i<keys.size();i++){\\n            val[keys[i]-\\'a\\'] = values[i];\\n        }\\n        // we will simply store encrypt string\\n        for(auto s: dict){\\n            string tem = \"\";\\n            for(auto c: s){\\n                if(val[c-\\'a\\'] == \"\"){ tem =\"\"; break;}\\n                tem += val[c-\\'a\\'];\\n            }\\n            m[tem]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto c: word1){\\n            if(val[c-\\'a\\'] == \"\") return \"\";\\n            ans += val[c-\\'a\\'];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        if(m.find(word2) != m.end()) return m[word2];\\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    vector<string> val;\\n    unordered_map<string,int> m;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dict) {\\n        val.resize(26,\"\");\\n        for(int i=0;i<keys.size();i++){\\n            val[keys[i]-\\'a\\'] = values[i];\\n        }\\n        // we will simply store encrypt string\\n        for(auto s: dict){\\n            string tem = \"\";\\n            for(auto c: s){\\n                if(val[c-\\'a\\'] == \"\"){ tem =\"\"; break;}\\n                tem += val[c-\\'a\\'];\\n            }\\n            m[tem]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto c: word1){\\n            if(val[c-\\'a\\'] == \"\") return \"\";\\n            ans += val[c-\\'a\\'];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        if(m.find(word2) != m.end()) return m[word2];\\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899070,
                "title": "golang-hash-map-and-trie",
                "content": "```go\\ntype TrieNode struct {\\n  Children [26]*TrieNode\\n  Word bool\\n}\\n\\ntype Encrypter struct {\\n  encryptsTo map[byte]string\\n  decryptsTo map[string][]byte\\n  dict *TrieNode\\n}\\n\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n  encryptsTo := make(map[byte]string)\\n  decryptsTo := make(map[string][]byte)\\n  for i := 0; i < len(keys); i++ {\\n    encryptsTo[keys[i]] = values[i]\\n    decryptsTo[values[i]] = append(decryptsTo[values[i]], keys[i])\\n  }\\n  root := &TrieNode{}\\n  for _, word := range dictionary {\\n    insert(root, word)\\n  }\\n  return Encrypter{encryptsTo, decryptsTo, root}\\n}\\n\\nfunc insert(root *TrieNode, word string) {\\n  curr := root\\n  for i := 0; i < len(word); i++ {\\n    child := curr.Children[word[i]-\\'a\\']\\n    if child == nil {\\n      child = &TrieNode{}\\n      curr.Children[word[i]-\\'a\\'] = child\\n    }\\n    curr = child\\n  }\\n  curr.Word = true\\n}\\n\\n\\nfunc (this *Encrypter) Encrypt(word1 string) string {\\n  var res strings.Builder\\n  for i := 0; i < len(word1); i++ {\\n    if ct, ok := this.encryptsTo[word1[i]]; ok {\\n      res.WriteString(ct)\\n    } else {\\n      return \"\"\\n    }\\n  }\\n  return res.String()\\n}\\n\\n\\nfunc (this *Encrypter) Decrypt(word2 string) int {\\n  return this.countDecryptions(this.dict, word2, 0)  \\n}\\n\\nfunc (this *Encrypter) countDecryptions(node *TrieNode, word string, pos int) int {\\n  if pos == len(word) {\\n    if node.Word {\\n      return 1\\n    }\\n    return 0\\n  }\\n  var res int\\n  ct := word[pos:pos+2]\\n  for _, key := range this.decryptsTo[ct] {\\n    child := node.Children[key-\\'a\\']\\n    if child != nil {\\n      res += this.countDecryptions(child, word, pos+2)\\n    }\\n  }\\n  return res\\n}\\n\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * obj := Constructor(keys, values, dictionary);\\n * param_1 := obj.Encrypt(word1);\\n * param_2 := obj.Decrypt(word2);\\n */\\n ```",
                "solutionTags": [
                    "Go",
                    "Trie"
                ],
                "code": "```go\\ntype TrieNode struct {\\n  Children [26]*TrieNode\\n  Word bool\\n}\\n\\ntype Encrypter struct {\\n  encryptsTo map[byte]string\\n  decryptsTo map[string][]byte\\n  dict *TrieNode\\n}\\n\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n  encryptsTo := make(map[byte]string)\\n  decryptsTo := make(map[string][]byte)\\n  for i := 0; i < len(keys); i++ {\\n    encryptsTo[keys[i]] = values[i]\\n    decryptsTo[values[i]] = append(decryptsTo[values[i]], keys[i])\\n  }\\n  root := &TrieNode{}\\n  for _, word := range dictionary {\\n    insert(root, word)\\n  }\\n  return Encrypter{encryptsTo, decryptsTo, root}\\n}\\n\\nfunc insert(root *TrieNode, word string) {\\n  curr := root\\n  for i := 0; i < len(word); i++ {\\n    child := curr.Children[word[i]-\\'a\\']\\n    if child == nil {\\n      child = &TrieNode{}\\n      curr.Children[word[i]-\\'a\\'] = child\\n    }\\n    curr = child\\n  }\\n  curr.Word = true\\n}\\n\\n\\nfunc (this *Encrypter) Encrypt(word1 string) string {\\n  var res strings.Builder\\n  for i := 0; i < len(word1); i++ {\\n    if ct, ok := this.encryptsTo[word1[i]]; ok {\\n      res.WriteString(ct)\\n    } else {\\n      return \"\"\\n    }\\n  }\\n  return res.String()\\n}\\n\\n\\nfunc (this *Encrypter) Decrypt(word2 string) int {\\n  return this.countDecryptions(this.dict, word2, 0)  \\n}\\n\\nfunc (this *Encrypter) countDecryptions(node *TrieNode, word string, pos int) int {\\n  if pos == len(word) {\\n    if node.Word {\\n      return 1\\n    }\\n    return 0\\n  }\\n  var res int\\n  ct := word[pos:pos+2]\\n  for _, key := range this.decryptsTo[ct] {\\n    child := node.Children[key-\\'a\\']\\n    if child != nil {\\n      res += this.countDecryptions(child, word, pos+2)\\n    }\\n  }\\n  return res\\n}\\n\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * obj := Constructor(keys, values, dictionary);\\n * param_1 := obj.Encrypt(word1);\\n * param_2 := obj.Decrypt(word2);\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 2826497,
                "title": "c-solution-using-little-string-trick",
                "content": "Well, unexpected problem : having problems in adding strings together (-_-) during encryption = time limit exceeded.\\n\\nSolution : Well, just realized that one can just set the resultant string into final size and assign characters to it = what do you know, 100 times faster than adding substrings (which will extend the string but I\\'ve never expected to have such a difference in runtime (-_-)) \\n\\nHa ha (-_-)\\n\\n```cpp\\nstruct n {\\n    char flag;\\n    n* chi[26];\\n    n() {\\n        for (int i = 0; i < 26; i++) {\\n            chi[i] = nullptr;\\n        }\\n    }\\n};\\nclass Encrypter {\\npublic:\\n    n* D;\\n    std::map<string, vector<char>> V;\\n    string M[26];\\n    int cnt, w2len;\\n    \\n    void insertT(n* T, string& str, char f) {\\n        for (char c : str) {\\n            if (T->chi[(c - \\'a\\')] == nullptr) {\\n                T->chi[(c - \\'a\\')] = new n();\\n            }\\n            T = T->chi[(c - \\'a\\')];\\n        }\\n        T->flag = f;\\n    }\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        D = new n();\\n        V = {};\\n        for (int i = 0; i < 26; i++) {\\n            M[i] = \"\";\\n        }\\n        for (int i = 0; i < values.size(); i++) {\\n            if (V.find(values[i]) == V.end()) {\\n                V[values[i]] = { keys[i] };\\n            }\\n            else {\\n                V[values[i]].push_back(keys[i]);\\n            }\\n            M[(keys[i] - \\'a\\')] = values[i];\\n        }    \\n        for (int i = 0; i < dictionary.size(); i++) {\\n            insertT(D, dictionary[i], \\'$\\');\\n        }\\n    }\\n    \\n    void opt(string& w2, int idx, n* cd) {\\n        string k = w2.substr(idx, 2);\\n        if (V.find(k) == V.end())\\n            return;\\n        else {\\n            for (char des : V[k]) {\\n                if (cd->chi[(des - \\'a\\')] != nullptr) {\\n                    if (idx + 2 == w2len && cd->chi[(des - \\'a\\')]->flag == \\'$\\') {\\n                        cnt++;\\n                    }\\n                    else {\\n                        opt(w2, idx + 2, cd->chi[(des - \\'a\\')]);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res = word1;\\n        res = res + word1;\\n        for (int i = 0; i < word1.length(); i++) {\\n            if (M[(word1[i] - \\'a\\')].length() == 0) {\\n                return \"\";\\n            }\\n            res[i * 2] = M[(word1[i] - \\'a\\')][0];\\n            res[i * 2 + 1] = M[(word1[i] - \\'a\\')][1];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        cnt = 0;\\n        w2len = word2.length();\\n        opt(word2, 0, D);\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [],
                "code": "```cpp\\nstruct n {\\n    char flag;\\n    n* chi[26];\\n    n() {\\n        for (int i = 0; i < 26; i++) {\\n            chi[i] = nullptr;\\n        }\\n    }\\n};\\nclass Encrypter {\\npublic:\\n    n* D;\\n    std::map<string, vector<char>> V;\\n    string M[26];\\n    int cnt, w2len;\\n    \\n    void insertT(n* T, string& str, char f) {\\n        for (char c : str) {\\n            if (T->chi[(c - \\'a\\')] == nullptr) {\\n                T->chi[(c - \\'a\\')] = new n();\\n            }\\n            T = T->chi[(c - \\'a\\')];\\n        }\\n        T->flag = f;\\n    }\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        D = new n();\\n        V = {};\\n        for (int i = 0; i < 26; i++) {\\n            M[i] = \"\";\\n        }\\n        for (int i = 0; i < values.size(); i++) {\\n            if (V.find(values[i]) == V.end()) {\\n                V[values[i]] = { keys[i] };\\n            }\\n            else {\\n                V[values[i]].push_back(keys[i]);\\n            }\\n            M[(keys[i] - \\'a\\')] = values[i];\\n        }    \\n        for (int i = 0; i < dictionary.size(); i++) {\\n            insertT(D, dictionary[i], \\'$\\');\\n        }\\n    }\\n    \\n    void opt(string& w2, int idx, n* cd) {\\n        string k = w2.substr(idx, 2);\\n        if (V.find(k) == V.end())\\n            return;\\n        else {\\n            for (char des : V[k]) {\\n                if (cd->chi[(des - \\'a\\')] != nullptr) {\\n                    if (idx + 2 == w2len && cd->chi[(des - \\'a\\')]->flag == \\'$\\') {\\n                        cnt++;\\n                    }\\n                    else {\\n                        opt(w2, idx + 2, cd->chi[(des - \\'a\\')]);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res = word1;\\n        res = res + word1;\\n        for (int i = 0; i < word1.length(); i++) {\\n            if (M[(word1[i] - \\'a\\')].length() == 0) {\\n                return \"\";\\n            }\\n            res[i * 2] = M[(word1[i] - \\'a\\')][0];\\n            res[i * 2 + 1] = M[(word1[i] - \\'a\\')][1];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        cnt = 0;\\n        w2len = word2.length();\\n        opt(word2, 0, D);\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813645,
                "title": "go-solution-with-trie",
                "content": "```\\n// 2227. Encrypt and Decrypt Strings\\n// 2227. \\u52A0\\u5BC6\\u89E3\\u5BC6\\u5B57\\u7B26\\u4E32\\n// \\u601D\\u8DEF\\uFF1A\\u9006\\u5411\\u601D\\u7EF4\\ntype Encrypter struct {\\n\\tchildren [26]*Encrypter\\n\\tisEnd    bool\\n\\tcount    int             // counting the number of dictionary\\'s word same encrypt code\\n\\tm        map[byte]string // keys[i]:values[i]\\n}\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n\\te := Encrypter{}\\n\\t// keys[i]:values[i]\\n\\te.m = make(map[byte]string, len(keys))\\n\\tfor i := 0; i < len(keys); i++ {\\n\\t\\te.m[keys[i]] = values[i]\\n\\t}\\n\\t// encrypt the words of the dictionary\\n\\t// and store them in a trie\\n\\t// with a count of each words.\\n\\tfor _, word := range dictionary {\\n\\t\\tw := e.Encrypt(word)\\n\\t\\tif len(w) == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\te.insert(w)\\n\\t}\\n\\treturn e\\n}\\n\\nfunc (e *Encrypter) insert(w string) {\\n\\tcur := e\\n\\tfor _, ch := range w {\\n\\t\\tif cur.children[ch-\\'a\\'] == nil {\\n\\t\\t\\tcur.children[ch-\\'a\\'] = &Encrypter{}\\n\\t\\t}\\n\\t\\tcur = cur.children[ch-\\'a\\']\\n\\t}\\n\\tcur.isEnd = true\\n\\tcur.count++\\n}\\n\\nfunc (e *Encrypter) search(w string) bool {\\n\\tcur := e\\n\\tfor _, ch := range w {\\n\\t\\tif cur.children[ch-\\'a\\'] == nil {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t\\tcur = cur.children[ch-\\'a\\']\\n\\t}\\n\\treturn cur.isEnd\\n}\\n\\n// time O(n) space O(n)\\nfunc (e *Encrypter) Encrypt(w string) string {\\n\\tans := strings.Builder{}\\n\\tfor _, ch := range w {\\n\\t\\tval, ok := e.m[byte(ch)]\\n\\t\\tif !ok {\\n\\t\\t\\t// in case a character of the string is not present in keys,\\n\\t\\t\\t// the encryption process cannot be carried out,\\n\\t\\t\\t// and an empty string \"\" is returned.\\n\\t\\t\\treturn \"\"\\n\\t\\t}\\n\\t\\tans.WriteString(val)\\n\\t}\\n\\treturn ans.String()\\n}\\n\\n// time O(n) space O(n)\\nfunc (e *Encrypter) Decrypt(w string) int {\\n\\t// traversing over the trie\\n\\t// with decrypted word to get the count.\\n\\tcur := e\\n\\tfor _, ch := range w {\\n\\t\\tif cur.children[ch-\\'a\\'] == nil {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\tcur = cur.children[ch-\\'a\\']\\n\\t}\\n\\treturn cur.count\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * obj := Constructor(keys, values, dictionary);\\n * param_1 := obj.Encrypt(word1);\\n * param_2 := obj.Decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "Go",
                    "Trie"
                ],
                "code": "```\\n// 2227. Encrypt and Decrypt Strings\\n// 2227. \\u52A0\\u5BC6\\u89E3\\u5BC6\\u5B57\\u7B26\\u4E32\\n// \\u601D\\u8DEF\\uFF1A\\u9006\\u5411\\u601D\\u7EF4\\ntype Encrypter struct {\\n\\tchildren [26]*Encrypter\\n\\tisEnd    bool\\n\\tcount    int             // counting the number of dictionary\\'s word same encrypt code\\n\\tm        map[byte]string // keys[i]:values[i]\\n}\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n\\te := Encrypter{}\\n\\t// keys[i]:values[i]\\n\\te.m = make(map[byte]string, len(keys))\\n\\tfor i := 0; i < len(keys); i++ {\\n\\t\\te.m[keys[i]] = values[i]\\n\\t}\\n\\t// encrypt the words of the dictionary\\n\\t// and store them in a trie\\n\\t// with a count of each words.\\n\\tfor _, word := range dictionary {\\n\\t\\tw := e.Encrypt(word)\\n\\t\\tif len(w) == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\te.insert(w)\\n\\t}\\n\\treturn e\\n}\\n\\nfunc (e *Encrypter) insert(w string) {\\n\\tcur := e\\n\\tfor _, ch := range w {\\n\\t\\tif cur.children[ch-\\'a\\'] == nil {\\n\\t\\t\\tcur.children[ch-\\'a\\'] = &Encrypter{}\\n\\t\\t}\\n\\t\\tcur = cur.children[ch-\\'a\\']\\n\\t}\\n\\tcur.isEnd = true\\n\\tcur.count++\\n}\\n\\nfunc (e *Encrypter) search(w string) bool {\\n\\tcur := e\\n\\tfor _, ch := range w {\\n\\t\\tif cur.children[ch-\\'a\\'] == nil {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t\\tcur = cur.children[ch-\\'a\\']\\n\\t}\\n\\treturn cur.isEnd\\n}\\n\\n// time O(n) space O(n)\\nfunc (e *Encrypter) Encrypt(w string) string {\\n\\tans := strings.Builder{}\\n\\tfor _, ch := range w {\\n\\t\\tval, ok := e.m[byte(ch)]\\n\\t\\tif !ok {\\n\\t\\t\\t// in case a character of the string is not present in keys,\\n\\t\\t\\t// the encryption process cannot be carried out,\\n\\t\\t\\t// and an empty string \"\" is returned.\\n\\t\\t\\treturn \"\"\\n\\t\\t}\\n\\t\\tans.WriteString(val)\\n\\t}\\n\\treturn ans.String()\\n}\\n\\n// time O(n) space O(n)\\nfunc (e *Encrypter) Decrypt(w string) int {\\n\\t// traversing over the trie\\n\\t// with decrypted word to get the count.\\n\\tcur := e\\n\\tfor _, ch := range w {\\n\\t\\tif cur.children[ch-\\'a\\'] == nil {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\tcur = cur.children[ch-\\'a\\']\\n\\t}\\n\\treturn cur.count\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * obj := Constructor(keys, values, dictionary);\\n * param_1 := obj.Encrypt(word1);\\n * param_2 := obj.Decrypt(word2);\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2806049,
                "title": "2-solutions-using-trie-and-2-maps-easy-to-understand-c",
                "content": "```\\n\\nvector<int> keyMap;\\n    unordered_map<string,int> decryptMap;\\n    vector<string> valueArr;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        valueArr = values;\\n        keyMap = vector<int>(26,-1);\\n        // keep key to index mapping\\n        for(int i = 0; i < keys.size(); i++) {\\n            keyMap[keys[i]-\\'a\\'] = i;\\n        }\\n        \\n        // Create Trie for all dictionary words to search\\n        for (auto &w : dictionary) {\\n            decryptMap[encrypt(w)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        int len = word1.length();\\n        string result(2*len,\\'a\\');\\n        for (int i = 0; i < len; i++) {\\n            int idx = keyMap[word1[i]-\\'a\\'];\\n            if (idx == -1)\\n                return \"\";\\n            result[2*i]   = valueArr[idx][0];\\n            result[2*i+1] = valueArr[idx][1];\\n        }\\n        return result;\\n    }\\n    \\n    \\n    int decrypt(string word2) {\\n       auto it = decryptMap.find(word2);\\n       if (it == decryptMap.end())\\n           return 0;\\n       return it->second;\\n    }\\n\\t\\nclass Encrypter {\\npublic:\\n    \\n    // Construct the trie of the given word\\n    struct TrieNode {\\n        bool isLeaf;\\n       TrieNode* child[26];\\n    };\\n    \\n    TrieNode* root = NULL;\\n    TrieNode* makeTrieNode() {\\n        TrieNode* node = new TrieNode();\\n        node->isLeaf = false;\\n        for (int i = 0; i <  26; i++) {\\n            node->child[i] = NULL;\\n        }\\n        return node;\\n    }\\n    \\n    void addToTrie(string word) {\\n        if (!root) {\\n            root = makeTrieNode();\\n        }\\n        TrieNode* node = root;\\n        for (int i = 0; i < word.length(); i++){\\n            int idx = word[i] - \\'a\\';\\n            if (!node->child[idx]) {\\n                node->child[idx] = makeTrieNode();\\n            }\\n            node = node->child[idx];\\n        }\\n        node->isLeaf = true;\\n    }\\n    \\n    \\n    \\n    int n = 26;\\n    \\n    vector<string> dict;\\n    vector<char> keyData;\\n    vector<int> keyMap;\\n    unordered_map<string,vector<int>> strKeyMap;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        keyData = keys;\\n        dict = values;\\n        \\n        keyMap = vector<int>(26,-1);\\n        // keep key to index mapping\\n        for(int i = 0; i < keys.size(); i++) {\\n            keyMap[keys[i]-\\'a\\'] = i;\\n        }\\n        // keep value to index mapping\\n        for (int i = 0; i < values.size(); i++) {\\n            strKeyMap[values[i]].push_back(i);\\n        }\\n        \\n        // Create Trie for all dictionary words to search\\n        for (auto &w : dictionary) {\\n            addToTrie(w);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string result;\\n        for (auto &c : word1) {\\n            int idx = keyMap[c-\\'a\\'];\\n            if (idx == -1)\\n                return \"\";\\n            result += dict[idx];\\n        }\\n        return result;\\n    }\\n    \\n    int helper(int idx, string &word, TrieNode* node) {\\n        // if no trie node return\\n        if (!node) {\\n            return 0;\\n        }\\n        \\n        // if reached end of the word, check if we are trieNode leaf\\n        if (idx == word.size()) {\\n            if (node->isLeaf) {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        // check if current value has a key mapping\\n        string str = word.substr(idx,2);\\n        auto it = strKeyMap.find(str);\\n        if (it == strKeyMap.end())\\n            return 0;\\n        \\n        int ret = 0;\\n        // Iterate on list of possible keys\\n        for (auto &i : it->second) {\\n            int id = keyData[i] - \\'a\\';\\n            ret += helper(idx+2,word,node->child[id]);\\n        }\\n        return ret;\\n    }\\n    \\n    int decrypt(string word2) {\\n       string dWord;\\n       return helper(0,word2,root);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nvector<int> keyMap;\\n    unordered_map<string,int> decryptMap;\\n    vector<string> valueArr;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        valueArr = values;\\n        keyMap = vector<int>(26,-1);\\n        // keep key to index mapping\\n        for(int i = 0; i < keys.size(); i++) {\\n            keyMap[keys[i]-\\'a\\'] = i;\\n        }\\n        \\n        // Create Trie for all dictionary words to search\\n        for (auto &w : dictionary) {\\n            decryptMap[encrypt(w)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        int len = word1.length();\\n        string result(2*len,\\'a\\');\\n        for (int i = 0; i < len; i++) {\\n            int idx = keyMap[word1[i]-\\'a\\'];\\n            if (idx == -1)\\n                return \"\";\\n            result[2*i]   = valueArr[idx][0];\\n            result[2*i+1] = valueArr[idx][1];\\n        }\\n        return result;\\n    }\\n    \\n    \\n    int decrypt(string word2) {\\n       auto it = decryptMap.find(word2);\\n       if (it == decryptMap.end())\\n           return 0;\\n       return it->second;\\n    }\\n\\t\\nclass Encrypter {\\npublic:\\n    \\n    // Construct the trie of the given word\\n    struct TrieNode {\\n        bool isLeaf;\\n       TrieNode* child[26];\\n    };\\n    \\n    TrieNode* root = NULL;\\n    TrieNode* makeTrieNode() {\\n        TrieNode* node = new TrieNode();\\n        node->isLeaf = false;\\n        for (int i = 0; i <  26; i++) {\\n            node->child[i] = NULL;\\n        }\\n        return node;\\n    }\\n    \\n    void addToTrie(string word) {\\n        if (!root) {\\n            root = makeTrieNode();\\n        }\\n        TrieNode* node = root;\\n        for (int i = 0; i < word.length(); i++){\\n            int idx = word[i] - \\'a\\';\\n            if (!node->child[idx]) {\\n                node->child[idx] = makeTrieNode();\\n            }\\n            node = node->child[idx];\\n        }\\n        node->isLeaf = true;\\n    }\\n    \\n    \\n    \\n    int n = 26;\\n    \\n    vector<string> dict;\\n    vector<char> keyData;\\n    vector<int> keyMap;\\n    unordered_map<string,vector<int>> strKeyMap;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        keyData = keys;\\n        dict = values;\\n        \\n        keyMap = vector<int>(26,-1);\\n        // keep key to index mapping\\n        for(int i = 0; i < keys.size(); i++) {\\n            keyMap[keys[i]-\\'a\\'] = i;\\n        }\\n        // keep value to index mapping\\n        for (int i = 0; i < values.size(); i++) {\\n            strKeyMap[values[i]].push_back(i);\\n        }\\n        \\n        // Create Trie for all dictionary words to search\\n        for (auto &w : dictionary) {\\n            addToTrie(w);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string result;\\n        for (auto &c : word1) {\\n            int idx = keyMap[c-\\'a\\'];\\n            if (idx == -1)\\n                return \"\";\\n            result += dict[idx];\\n        }\\n        return result;\\n    }\\n    \\n    int helper(int idx, string &word, TrieNode* node) {\\n        // if no trie node return\\n        if (!node) {\\n            return 0;\\n        }\\n        \\n        // if reached end of the word, check if we are trieNode leaf\\n        if (idx == word.size()) {\\n            if (node->isLeaf) {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        // check if current value has a key mapping\\n        string str = word.substr(idx,2);\\n        auto it = strKeyMap.find(str);\\n        if (it == strKeyMap.end())\\n            return 0;\\n        \\n        int ret = 0;\\n        // Iterate on list of possible keys\\n        for (auto &i : it->second) {\\n            int id = keyData[i] - \\'a\\';\\n            ret += helper(idx+2,word,node->child[id]);\\n        }\\n        return ret;\\n    }\\n    \\n    int decrypt(string word2) {\\n       string dWord;\\n       return helper(0,word2,root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780295,
                "title": "python-solution-using-trie-and-hash-table-o-len-word1-encrypt-and-o-len-word2-decrypt",
                "content": "\\n\\n# Code\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.d1=[None for _ in range(26)]\\n        self.d2={}\\n        for i,item in enumerate(keys):\\n            self.d1[ord(item)-97]=values[i]\\n        self.dict=Trie()\\n        for item in dictionary:\\n            val=self.encrypt(item)\\n            self.dict.insert(val)\\n    def encrypt(self, word1: str) -> str:\\n        ans=[]\\n        for item in word1:\\n            item=ord(item)-97\\n            if(not self.d1[item]):\\n                return \"\"\\n            else:\\n                ans.append(self.d1[item])\\n        return \"\".join(ans)\\n    def decrypt(self, word2: str) -> int:\\n        return self.dict.search(word2)\\n\\nclass Trie:\\n    def __init__(self):\\n        self.child=[None for _ in range(26)]\\n        self.count=0\\n    def insert(self,word):\\n        for item in word:\\n            j=ord(item)-97\\n            if(not self.child[j]):\\n                self.child[j]=Trie()\\n            self=self.child[j]\\n        self.count+=1\\n    def search(self,word):\\n        for item in word:\\n            j=ord(item)-97\\n            if(not self.child[j]):\\n                return 0\\n            self=self.child[j]\\n        return self.count\\n\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Trie"
                ],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.d1=[None for _ in range(26)]\\n        self.d2={}\\n        for i,item in enumerate(keys):\\n            self.d1[ord(item)-97]=values[i]\\n        self.dict=Trie()\\n        for item in dictionary:\\n            val=self.encrypt(item)\\n            self.dict.insert(val)\\n    def encrypt(self, word1: str) -> str:\\n        ans=[]\\n        for item in word1:\\n            item=ord(item)-97\\n            if(not self.d1[item]):\\n                return \"\"\\n            else:\\n                ans.append(self.d1[item])\\n        return \"\".join(ans)\\n    def decrypt(self, word2: str) -> int:\\n        return self.dict.search(word2)\\n\\nclass Trie:\\n    def __init__(self):\\n        self.child=[None for _ in range(26)]\\n        self.count=0\\n    def insert(self,word):\\n        for item in word:\\n            j=ord(item)-97\\n            if(not self.child[j]):\\n                self.child[j]=Trie()\\n            self=self.child[j]\\n        self.count+=1\\n    def search(self,word):\\n        for item in word:\\n            j=ord(item)-97\\n            if(not self.child[j]):\\n                return 0\\n            self=self.child[j]\\n        return self.count\\n\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779845,
                "title": "rust-solution-with-hashmap-28-ms-6-3-mb",
                "content": "\\nKey Idea :  encrypt and decrypt will be called around 200 times for one new call, so, even if new is slow, if encrypt and decrypt are relatively fast, the whole process would be fast. \\n\\nEncrypt will have to remain O(N) because, we don\\'t know which all words can be encrypted so we can not cache them prior to it\\'s call.\\n\\nDecrypt on the other hand returns how many Strings upon encryption in Dictionary will return that string. Since the dictionary is only initialized once, and has finite number of words with finite length, we can cache it\\'s results in a hashmap. So, if we have the encrypted string as key, we can use that to get the count or return 0.\\n\\nWith some other minor optimizations, we can get the final Space and Time Complexities of the functions like so\\n\\nnew() -> TC : O(N<sup>2</sup>), SC : O(N)\\nEncrypt -> TC : O(N), SC : O(N)\\nDecrypt -> TC : O*(1), SC : O(1)\\n\\n**Note that since we are using a HashMap, the time complexity can get to O(N), however, here since the number of words in dictionary isn\\'t that much, it\\'s O(1).**\\n\\n```\\nuse std::collections::HashMap;\\n\\nstruct Encrypter {\\n    value_map : [String; 26],\\n    dict_map : HashMap<String, i32>\\n}\\n\\n\\nimpl Encrypter {\\n    fn new(keys: Vec<char>, values: Vec<String>, dictionary: Vec<String>) -> Self {\\n        let mut value_map : [String; 26] = Default::default();\\n        \\n        keys\\n\\t\\t.into_iter()\\n\\t\\t.zip(values.into_iter())\\n\\t\\t.for_each(\\n\\t\\t\\t#[inline]\\n\\t\\t\\t|(key, value)| \\n\\t\\t\\tvalue_map[(key as u8 - b\\'a\\') as usize] = value\\n\\t\\t);\\n        \\n        let mut res = Self{\\n            value_map,\\n            dict_map : HashMap::with_capacity(5)\\n        };\\n        \\n        for word in dictionary {\\n            let key = res.encrypt(word);\\n            *res.dict_map.entry(key).or_insert(0) += 1;\\n        }\\n        \\n        res\\n    }\\n    \\n    fn encrypt(&self, word1: String) -> String {\\n        let mut res : String = String::with_capacity(word1.len() * 2);\\n        \\n        for b in word1.into_bytes() {\\n            if !self.value_map[(b - b\\'a\\') as usize].is_empty(){\\n                res.push_str(&self.value_map[(b - b\\'a\\') as usize]);\\n            } else {\\n                return String::new()\\n            }\\n        }\\n        \\n        res\\n    }\\n    \\n    fn decrypt(&self, word2: String) -> i32 {\\n        *self.dict_map.get(&word2).unwrap_or(&0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nstruct Encrypter {\\n    value_map : [String; 26],\\n    dict_map : HashMap<String, i32>\\n}\\n\\n\\nimpl Encrypter {\\n    fn new(keys: Vec<char>, values: Vec<String>, dictionary: Vec<String>) -> Self {\\n        let mut value_map : [String; 26] = Default::default();\\n        \\n        keys\\n\\t\\t.into_iter()\\n\\t\\t.zip(values.into_iter())\\n\\t\\t.for_each(\\n\\t\\t\\t#[inline]\\n\\t\\t\\t|(key, value)| \\n\\t\\t\\tvalue_map[(key as u8 - b\\'a\\') as usize] = value\\n\\t\\t);\\n        \\n        let mut res = Self{\\n            value_map,\\n            dict_map : HashMap::with_capacity(5)\\n        };\\n        \\n        for word in dictionary {\\n            let key = res.encrypt(word);\\n            *res.dict_map.entry(key).or_insert(0) += 1;\\n        }\\n        \\n        res\\n    }\\n    \\n    fn encrypt(&self, word1: String) -> String {\\n        let mut res : String = String::with_capacity(word1.len() * 2);\\n        \\n        for b in word1.into_bytes() {\\n            if !self.value_map[(b - b\\'a\\') as usize].is_empty(){\\n                res.push_str(&self.value_map[(b - b\\'a\\') as usize]);\\n            } else {\\n                return String::new()\\n            }\\n        }\\n        \\n        res\\n    }\\n    \\n    fn decrypt(&self, word2: String) -> i32 {\\n        *self.dict_map.get(&word2).unwrap_or(&0)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2779656,
                "title": "javascript-the-hard-way",
                "content": "```\\nvar Encrypter = function(keys, values, dictionary) {\\n    var i;\\n    \\n    this.ks = {};\\n    this.sk = {};\\n    \\n    let paintTrie = function(word, key) {\\n        var i;\\n        let sk = this.sk;\\n        \\n        for( i=0; i<word.length; i++ ) {\\n            if( !(word[i] in sk) ) sk[word[i]] = {};\\n            sk = sk[word[i]];\\n        }\\n        if( !(\\'key\\' in sk) ) sk.key = new Set();\\n        sk.key.add(key);\\n    }\\n    var sk;\\n    for( i=0; i<keys.length; i++ ) {\\n        this.ks[keys[i]] = values[i];\\n        \\n        paintTrie.bind(this)(values[i], keys[i]);\\n    }\\n    this.dict = new Set(dictionary);\\n    this.dictrie = {};\\n    var dt, word;\\n    for( word of this.dict ) {\\n        dt = this.dictrie;\\n        for( i=0; i<word.length; i++ ) {\\n            if( !(word[i] in dt) ) dt[word[i]] = {};\\n            dt = dt[word[i]];\\n        }\\n        dt.valid = true;\\n    }\\n};\\n\\nEncrypter.prototype.encrypt = function(word1) {\\n    var i, result=\"\";\\n    for( i=0; i<word1.length; i++ ) {\\n        result += this.ks[word1[i]];\\n    }\\n    return result;\\n};\\n\\nEncrypter.prototype.decrypt = function(word2) {\\n    let ways = function(i=0, ansTrees=null) {\\n        var j, k, y, z;\\n        var sk = this.sk;\\n        var ans = 0;\\n        var res, subtrees, subkeys;\\n        \\n\\n        if( ansTrees === null ) ansTrees = [this.dictrie];\\n        if( i >= word2.length ) {\\n            let count=0;\\n            for( j=0; j<ansTrees.length; j++ ) {\\n                if( ansTrees[j].valid === true )\\n                    count++;\\n            }\\n            return count;\\n        }\\n        \\n        for( j=i; j<word2.length; j++ ) {\\n            if( !(word2[j] in sk) )\\n                break;\\n            sk = sk[word2[j]];\\n            \\n            if( \\'key\\' in sk ) {\\n                subkeys = [];\\n                subtrees = [];\\n                for( res of sk.key ) {\\n                    for( y=0; y<ansTrees.length; y++ ) {\\n                        dt = ansTrees[y];\\n                        for( k=0; k<res.length; k++ ) {\\n                            if( !(res[k] in dt) ) break;\\n                            dt = dt[res[k]];\\n                        }\\n                        if( k<res.length ) continue;\\n                        subkeys.push(res);\\n                        subtrees.push(dt);\\n                    }\\n                }\\n                if( subkeys.length == 0 ) continue;\\n                \\n                let sub = ways.bind(this)( j+1, subtrees );\\n                ans += sub;\\n            }\\n        }\\n        \\n        return ans;\\n    };\\n    \\n    return ways.bind(this)();\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar Encrypter = function(keys, values, dictionary) {\\n    var i;\\n    \\n    this.ks = {};\\n    this.sk = {};\\n    \\n    let paintTrie = function(word, key) {\\n        var i;\\n        let sk = this.sk;\\n        \\n        for( i=0; i<word.length; i++ ) {\\n            if( !(word[i] in sk) ) sk[word[i]] = {};\\n            sk = sk[word[i]];\\n        }\\n        if( !(\\'key\\' in sk) ) sk.key = new Set();\\n        sk.key.add(key);\\n    }\\n    var sk;\\n    for( i=0; i<keys.length; i++ ) {\\n        this.ks[keys[i]] = values[i];\\n        \\n        paintTrie.bind(this)(values[i], keys[i]);\\n    }\\n    this.dict = new Set(dictionary);\\n    this.dictrie = {};\\n    var dt, word;\\n    for( word of this.dict ) {\\n        dt = this.dictrie;\\n        for( i=0; i<word.length; i++ ) {\\n            if( !(word[i] in dt) ) dt[word[i]] = {};\\n            dt = dt[word[i]];\\n        }\\n        dt.valid = true;\\n    }\\n};\\n\\nEncrypter.prototype.encrypt = function(word1) {\\n    var i, result=\"\";\\n    for( i=0; i<word1.length; i++ ) {\\n        result += this.ks[word1[i]];\\n    }\\n    return result;\\n};\\n\\nEncrypter.prototype.decrypt = function(word2) {\\n    let ways = function(i=0, ansTrees=null) {\\n        var j, k, y, z;\\n        var sk = this.sk;\\n        var ans = 0;\\n        var res, subtrees, subkeys;\\n        \\n\\n        if( ansTrees === null ) ansTrees = [this.dictrie];\\n        if( i >= word2.length ) {\\n            let count=0;\\n            for( j=0; j<ansTrees.length; j++ ) {\\n                if( ansTrees[j].valid === true )\\n                    count++;\\n            }\\n            return count;\\n        }\\n        \\n        for( j=i; j<word2.length; j++ ) {\\n            if( !(word2[j] in sk) )\\n                break;\\n            sk = sk[word2[j]];\\n            \\n            if( \\'key\\' in sk ) {\\n                subkeys = [];\\n                subtrees = [];\\n                for( res of sk.key ) {\\n                    for( y=0; y<ansTrees.length; y++ ) {\\n                        dt = ansTrees[y];\\n                        for( k=0; k<res.length; k++ ) {\\n                            if( !(res[k] in dt) ) break;\\n                            dt = dt[res[k]];\\n                        }\\n                        if( k<res.length ) continue;\\n                        subkeys.push(res);\\n                        subtrees.push(dt);\\n                    }\\n                }\\n                if( subkeys.length == 0 ) continue;\\n                \\n                let sub = ways.bind(this)( j+1, subtrees );\\n                ans += sub;\\n            }\\n        }\\n        \\n        return ans;\\n    };\\n    \\n    return ways.bind(this)();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2703218,
                "title": "easy-understanding-map",
                "content": "```\\nclass Encrypter {\\n    map<char,string> kmap;\\n    map<string,int> rmap;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dic) {\\n        int n = keys.size();\\n        for(int i  = 0 ; i < n ; i++){\\n            kmap[keys[i]] = values[i];\\n        }\\n        for(auto x : dic){\\n            // cout<<encrypt(x)<<\" \";\\n            rmap[encrypt(x)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto x : word1){\\n            if(kmap.find(x) == kmap.end()) return \"\";\\n            ans += kmap[x];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string word2) {\\n        return rmap[word2];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\n    map<char,string> kmap;\\n    map<string,int> rmap;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dic) {\\n        int n = keys.size();\\n        for(int i  = 0 ; i < n ; i++){\\n            kmap[keys[i]] = values[i];\\n        }\\n        for(auto x : dic){\\n            // cout<<encrypt(x)<<\" \";\\n            rmap[encrypt(x)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto x : word1){\\n            if(kmap.find(x) == kmap.end()) return \"\";\\n            ans += kmap[x];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string word2) {\\n        return rmap[word2];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2665637,
                "title": "one-hashmap-use",
                "content": "class Encrypter {\\n\\n    String[] key = new String[26];\\n    String[] dictionary;\\n    HashMap<String,Integer> H;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        H = new HashMap<>();\\n        simplyKeys(keys,values);\\n        this.dictionary=dictionary;\\n        addHashMap();\\n    }\\n    \\n    public void simplyKeys(char[] keys,String[] values){\\n        for(int i=0;i<keys.length;i++){\\n            key[keys[i]-\\'a\\']=values[i];\\n        }\\n    }\\n    \\n    public void addHashMap(){\\n        for(String dict : dictionary){\\n            H.put(encrypt(dict),H.getOrDefault(encrypt(dict),0)+1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String res = \"\";\\n        for(char ch : word1.toCharArray()){\\n            if(key[ch-\\'a\\']==null ||key[ch-\\'a\\']==\"\") return \"\";\\n            else res+=key[ch-\\'a\\'];\\n        }\\n        return res;\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return H.containsKey(word2) ? H.get(word2) : 0;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Encrypter {\\n\\n    String[] key = new String[26];\\n    String[] dictionary;\\n    HashMap<String,Integer> H;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        H = new HashMap<>();\\n        simplyKeys(keys,values);\\n        this.dictionary=dictionary;\\n        addHashMap();\\n    }\\n    \\n    public void simplyKeys(char[] keys,String[] values){\\n        for(int i=0;i<keys.length;i++){\\n            key[keys[i]-\\'a\\']=values[i];\\n        }\\n    }\\n    \\n    public void addHashMap(){\\n        for(String dict : dictionary){\\n            H.put(encrypt(dict),H.getOrDefault(encrypt(dict),0)+1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String res = \"\";\\n        for(char ch : word1.toCharArray()){\\n            if(key[ch-\\'a\\']==null ||key[ch-\\'a\\']==\"\") return \"\";\\n            else res+=key[ch-\\'a\\'];\\n        }\\n        return res;\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return H.containsKey(word2) ? H.get(word2) : 0;\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 2599073,
                "title": "kotlin-100-time-and-space-saving-dictionary-in-trie-checking-recursively",
                "content": "```\\nclass Encrypter(keys: CharArray, values: Array<String>, dictionary: Array<String>) {\\n\\n    class TrieNode(val next: Array<TrieNode?> = Array(26) { null }, var isEnd: Boolean = false)\\n\\n    val forward = mutableMapOf<Char, String>().also {\\n        keys.forEachIndexed { index, c ->\\n            it[c] = values[index]\\n        }\\n    }\\n    val backward = mutableMapOf<String, MutableList<Char>>().also {\\n        values.forEachIndexed { index, str ->\\n            it[str] = (it[str] ?: mutableListOf()).also {\\n                it.add(keys[index])\\n            }\\n        }\\n    }\\n\\n    // for dictionary [a, aba, acba, abaff] trie will be\\n\\t//\\n    //                        *root*\\n    //                      a (end=true)\\n    //                b            c\\n    //        a (end = true)     b\\n    //          f               a (end = true)\\n    //            f (end = true)\\n    //\\n    val root = TrieNode().also { root ->\\n        dictionary.forEach {dicStr ->\\n            var nowItem = root\\n            dicStr.forEachIndexed { index, ch ->\\n                if (nowItem.next[ch - \\'a\\'] == null) {\\n                    TrieNode(isEnd = (index == dicStr.length-1)).also {\\n                        nowItem.next[ch - \\'a\\'] = it\\n                        nowItem = it\\n                    }\\n                } else {\\n\\n                    nowItem = nowItem.next[ch - \\'a\\']!!.also {\\n                        it.isEnd = it.isEnd || (index == dicStr.length-1)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    fun encrypt(word1: String): String {\\n        return word1.asSequence().map { forward[it] }.joinToString(\"\")\\n    }\\n\\n    fun decrypt(word2: String): Int {\\n        var cantBeAny = false\\n        val possChars = word2.chunked(2).asSequence().map {\\n            backward[it] ?: mutableListOf<Char>().also {\\n                cantBeAny = true\\n            }\\n        }.toList().toTypedArray()\\n\\n        // odd length or any of pair is not present in \\'values\\' array\\n        if (cantBeAny) return 0\\n\\n        var count = 0\\n\\n        fun tryAdd(nowNode: TrieNode, index: Int) {\\n            if (index == possChars.size - 1) { // last char checking\\n                possChars[index].forEach {\\n                    nowNode.next[it - \\'a\\']?.let { nextNode ->\\n                        if(nextNode.isEnd) {\\n                            count++\\n                        }\\n                    }\\n                }\\n            } else {\\n                possChars[index].forEach {\\n                    nowNode.next[it - \\'a\\']?.let { nextNode ->\\n                        tryAdd(nextNode, index + 1)\\n                    }\\n                }\\n            }\\n        }\\n\\n        tryAdd(root, 0)\\n        return count\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Encrypter(keys: CharArray, values: Array<String>, dictionary: Array<String>) {\\n\\n    class TrieNode(val next: Array<TrieNode?> = Array(26) { null }, var isEnd: Boolean = false)\\n\\n    val forward = mutableMapOf<Char, String>().also {\\n        keys.forEachIndexed { index, c ->\\n            it[c] = values[index]\\n        }\\n    }\\n    val backward = mutableMapOf<String, MutableList<Char>>().also {\\n        values.forEachIndexed { index, str ->\\n            it[str] = (it[str] ?: mutableListOf()).also {\\n                it.add(keys[index])\\n            }\\n        }\\n    }\\n\\n    // for dictionary [a, aba, acba, abaff] trie will be\\n\\t//\\n    //                        *root*\\n    //                      a (end=true)\\n    //                b            c\\n    //        a (end = true)     b\\n    //          f               a (end = true)\\n    //            f (end = true)\\n    //\\n    val root = TrieNode().also { root ->\\n        dictionary.forEach {dicStr ->\\n            var nowItem = root\\n            dicStr.forEachIndexed { index, ch ->\\n                if (nowItem.next[ch - \\'a\\'] == null) {\\n                    TrieNode(isEnd = (index == dicStr.length-1)).also {\\n                        nowItem.next[ch - \\'a\\'] = it\\n                        nowItem = it\\n                    }\\n                } else {\\n\\n                    nowItem = nowItem.next[ch - \\'a\\']!!.also {\\n                        it.isEnd = it.isEnd || (index == dicStr.length-1)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    fun encrypt(word1: String): String {\\n        return word1.asSequence().map { forward[it] }.joinToString(\"\")\\n    }\\n\\n    fun decrypt(word2: String): Int {\\n        var cantBeAny = false\\n        val possChars = word2.chunked(2).asSequence().map {\\n            backward[it] ?: mutableListOf<Char>().also {\\n                cantBeAny = true\\n            }\\n        }.toList().toTypedArray()\\n\\n        // odd length or any of pair is not present in \\'values\\' array\\n        if (cantBeAny) return 0\\n\\n        var count = 0\\n\\n        fun tryAdd(nowNode: TrieNode, index: Int) {\\n            if (index == possChars.size - 1) { // last char checking\\n                possChars[index].forEach {\\n                    nowNode.next[it - \\'a\\']?.let { nextNode ->\\n                        if(nextNode.isEnd) {\\n                            count++\\n                        }\\n                    }\\n                }\\n            } else {\\n                possChars[index].forEach {\\n                    nowNode.next[it - \\'a\\']?.let { nextNode ->\\n                        tryAdd(nextNode, index + 1)\\n                    }\\n                }\\n            }\\n        }\\n\\n        tryAdd(root, 0)\\n        return count\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2521009,
                "title": "c",
                "content": "```\\npublic class Encrypter {\\n    Trie t;\\n    Dictionary<char,string> d;\\n\\n    public Encrypter(char[] keys, string[] values, string[] dictionary) {\\n        d = new Dictionary<char,string>();\\n        t = new Trie();\\n        for(int i = 0; i < keys.Length; i++){\\n            d[keys[i]] = values[i];\\n        }\\n        foreach(var i in dictionary){\\n            string check = Encrypt(i);\\n            if(!string.IsNullOrEmpty(check))\\n              t.Insert(check);\\n        }\\n    }\\n    \\n    public string Encrypt(string word1) {\\n        string res = \"\";\\n        foreach(var i in word1){\\n            if(d.ContainsKey(i))\\n                res+= d[i];\\n            else return string.Empty;\\n        }\\n        return res;\\n    }\\n    \\n    public int Decrypt(string word2) {\\n        return t.Search(word2);\\n    }\\n}\\n\\npublic class Trie{\\n    public TrieNode root = new TrieNode();\\n    \\n    public void Insert(string word){\\n        var temp = root;\\n        foreach(var i in word){\\n            if(!temp.ch.ContainsKey(i)){\\n                temp.ch.Add(i,new TrieNode());\\n            }\\n            temp = temp.ch[i];\\n        }\\n        temp.end += 1;\\n    }\\n    public int Search(string word){\\n        var temp = root;\\n        foreach(var i in word){\\n            if(!temp.ch.ContainsKey(i)) return 0;\\n            temp = temp.ch[i];\\n        }\\n        return temp.end;\\n    }\\n}\\npublic class TrieNode{\\n    public char val;\\n    public Dictionary<char,TrieNode> ch = new ();\\n    public int end;\\n    \\n    public TrieNode(){}\\n    \\n    public TrieNode(char val){\\n        this.val = val;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj.Encrypt(word1);\\n * int param_2 = obj.Decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\npublic class Encrypter {\\n    Trie t;\\n    Dictionary<char,string> d;\\n\\n    public Encrypter(char[] keys, string[] values, string[] dictionary) {\\n        d = new Dictionary<char,string>();\\n        t = new Trie();\\n        for(int i = 0; i < keys.Length; i++){\\n            d[keys[i]] = values[i];\\n        }\\n        foreach(var i in dictionary){\\n            string check = Encrypt(i);\\n            if(!string.IsNullOrEmpty(check))\\n              t.Insert(check);\\n        }\\n    }\\n    \\n    public string Encrypt(string word1) {\\n        string res = \"\";\\n        foreach(var i in word1){\\n            if(d.ContainsKey(i))\\n                res+= d[i];\\n            else return string.Empty;\\n        }\\n        return res;\\n    }\\n    \\n    public int Decrypt(string word2) {\\n        return t.Search(word2);\\n    }\\n}\\n\\npublic class Trie{\\n    public TrieNode root = new TrieNode();\\n    \\n    public void Insert(string word){\\n        var temp = root;\\n        foreach(var i in word){\\n            if(!temp.ch.ContainsKey(i)){\\n                temp.ch.Add(i,new TrieNode());\\n            }\\n            temp = temp.ch[i];\\n        }\\n        temp.end += 1;\\n    }\\n    public int Search(string word){\\n        var temp = root;\\n        foreach(var i in word){\\n            if(!temp.ch.ContainsKey(i)) return 0;\\n            temp = temp.ch[i];\\n        }\\n        return temp.end;\\n    }\\n}\\npublic class TrieNode{\\n    public char val;\\n    public Dictionary<char,TrieNode> ch = new ();\\n    public int end;\\n    \\n    public TrieNode(){}\\n    \\n    public TrieNode(char val){\\n        this.val = val;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj.Encrypt(word1);\\n * int param_2 = obj.Decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2514185,
                "title": "c-hashmap",
                "content": "```\\nclass Encrypter {\\npublic:\\n    vector<int>hash;\\n    vector<char>keys;\\n    vector<string>dict,values;\\n    unordered_map<string,int>mpEncrpyted;\\n    Encrypter(vector<char>& key, vector<string>& value, vector<string>& dictionary) {\\n        hash=vector<int>(26,-1);\\n        for(int i=0;i<key.size();i++)\\n        {\\n            hash[key[i]-\\'a\\']=i;\\n        }\\n        \\n        keys=key;\\n        values=value;\\n        dict=dictionary;\\n        for(string s:dict)\\n        {\\n            mpEncrpyted[encrypt(s)]++;\\n        }\\n        \\n    }\\n    \\n    string encrypt(string word1) {\\n        int n=word1.length();\\n        string ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(hash[word1[i]-\\'a\\']==-1)return \"\";\\n            ans+=values[hash[word1[i]-\\'a\\']];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return mpEncrpyted[word2];\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    vector<int>hash;\\n    vector<char>keys;\\n    vector<string>dict,values;\\n    unordered_map<string,int>mpEncrpyted;\\n    Encrypter(vector<char>& key, vector<string>& value, vector<string>& dictionary) {\\n        hash=vector<int>(26,-1);\\n        for(int i=0;i<key.size();i++)\\n        {\\n            hash[key[i]-\\'a\\']=i;\\n        }\\n        \\n        keys=key;\\n        values=value;\\n        dict=dictionary;\\n        for(string s:dict)\\n        {\\n            mpEncrpyted[encrypt(s)]++;\\n        }\\n        \\n    }\\n    \\n    string encrypt(string word1) {\\n        int n=word1.length();\\n        string ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(hash[word1[i]-\\'a\\']==-1)return \"\";\\n            ans+=values[hash[word1[i]-\\'a\\']];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return mpEncrpyted[word2];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2496934,
                "title": "python-dictionary-solution",
                "content": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], d: List[str]):\\n        self.look = dict(zip(keys, values))\\n        self.d = Counter(self.encrypt(c) for c in d)\\n        \\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join(self.look.get(c, \\'#\\') for c in word1)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.d[word2]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], d: List[str]):\\n        self.look = dict(zip(keys, values))\\n        self.d = Counter(self.encrypt(c) for c in d)\\n        \\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join(self.look.get(c, \\'#\\') for c in word1)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.d[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488939,
                "title": "encrypt",
                "content": "class Encrypter {\\npublic:\\n    map<char,string>mp1;\\n    map<string,set<char>>mp2;\\n     vector<string>d;\\n    Encrypter(vector<char>& key, vector<string>& values, vector<string>& dict) {\\n        for(int i=0;i<key.size();i++){\\n            mp1[key[i]]=values[i];\\n            mp2[values[i]].insert(key[i]);\\n        }\\n        d=dict;\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res=\"\";\\n        for(auto x:word1){\\n            if(mp1.find(x)==mp1.end()) return \"\";\\n            res+=mp1[x];\\n        }\\n        return res;\\n    }\\n    int decrypt(string w) {\\n        int n=w.size();\\n        if(n%2) return 0;\\n        int ans=0;\\n        for(auto s:d){\\n            if(w==encrypt(s)){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Encrypter {\\npublic:\\n    map<char,string>mp1;\\n    map<string,set<char>>mp2;\\n     vector<string>d;\\n    Encrypter(vector<char>& key, vector<string>& values, vector<string>& dict) {\\n        for(int i=0;i<key.size();i++){\\n            mp1[key[i]]=values[i];\\n            mp2[values[i]].insert(key[i]);\\n        }\\n        d=dict;\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res=\"\";\\n        for(auto x:word1){\\n            if(mp1.find(x)==mp1.end()) return \"\";\\n            res+=mp1[x];\\n        }\\n        return res;\\n    }\\n    int decrypt(string w) {\\n        int n=w.size();\\n        if(n%2) return 0;\\n        int ans=0;\\n        for(auto s:d){\\n            if(w==encrypt(s)){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2488362,
                "title": "python-trie",
                "content": "```\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.h=defaultdict(lambda:\\'*\\')\\n        for key,value in zip(keys,values):\\n            self.h[key]=value\\n        self.trie=Trie()\\n        for word in dictionary:\\n            self.trie.add(\\'\\'.join(self.h[x] for x in word))\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join(self.h[x] for x in word1 if self.h[x]!=\\'*\\')\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.trie.get(word2)\\n    \\nclass Trie:\\n    def __init__(self):\\n        self.root={}\\n    def add(self,word):\\n        node=self.root\\n        for i in range(0,len(word),2):\\n            cur=word[i:i+2]\\n            if cur not in node:\\n                node[cur]={}\\n            node=node[cur]\\n        if \\'#\\' not in node:\\n            node[\\'#\\']=1\\n        else:\\n            node[\\'#\\']+=1\\n    def get(self,word):\\n        node=self.root\\n        for i in range(0,len(word),2):\\n            cur=word[i:i+2]\\n            if cur not in node:\\n                return 0\\n            else:\\n                node=node[cur]\\n        if \\'#\\' in node:\\n            return node[\\'#\\']\\n        else:\\n            return 0\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.h=defaultdict(lambda:\\'*\\')\\n        for key,value in zip(keys,values):\\n            self.h[key]=value\\n        self.trie=Trie()\\n        for word in dictionary:\\n            self.trie.add(\\'\\'.join(self.h[x] for x in word))\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join(self.h[x] for x in word1 if self.h[x]!=\\'*\\')\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.trie.get(word2)\\n    \\nclass Trie:\\n    def __init__(self):\\n        self.root={}\\n    def add(self,word):\\n        node=self.root\\n        for i in range(0,len(word),2):\\n            cur=word[i:i+2]\\n            if cur not in node:\\n                node[cur]={}\\n            node=node[cur]\\n        if \\'#\\' not in node:\\n            node[\\'#\\']=1\\n        else:\\n            node[\\'#\\']+=1\\n    def get(self,word):\\n        node=self.root\\n        for i in range(0,len(word),2):\\n            cur=word[i:i+2]\\n            if cur not in node:\\n                return 0\\n            else:\\n                node=node[cur]\\n        if \\'#\\' in node:\\n            return node[\\'#\\']\\n        else:\\n            return 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2483394,
                "title": "just-use-encrypt-for-decrypt-simple-python-solution",
                "content": "```\\ndef __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        \\n        self.keys = {c : i for i, c in enumerate(keys)}\\n        self.val_list = values\\n        self.dict = set(dictionary)\\n       \\n    def encrypt(self, word1: str) -> str:    \\n        ans = \\'\\'\\n        for c in word1:\\n            if c not in self.keys:\\n                return \\'\\'\\n            ans += self.val_list[self.keys[c]]\\n        return ans \\n\\n\\n    def decrypt(self, word2: str) -> int:\\n        \\n        cnt = 0\\n        for c in self.dict:\\n            ans = self.encrypt(c)\\n            if ans == word2:\\n                cnt += 1\\n        \\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\ndef __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        \\n        self.keys = {c : i for i, c in enumerate(keys)}\\n        self.val_list = values\\n        self.dict = set(dictionary)\\n       \\n    def encrypt(self, word1: str) -> str:    \\n        ans = \\'\\'\\n        for c in word1:\\n            if c not in self.keys:\\n                return \\'\\'\\n            ans += self.val_list[self.keys[c]]\\n        return ans \\n\\n\\n    def decrypt(self, word2: str) -> int:\\n        \\n        cnt = 0\\n        for c in self.dict:\\n            ans = self.encrypt(c)\\n            if ans == word2:\\n                cnt += 1\\n        \\n        return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2471560,
                "title": "python",
                "content": "```\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.dic = {x : i for i, x in enumerate(keys)}\\n        self.values = values\\n        self.dictionary = dictionary\\n\\n    def encrypt(self, word1: str) -> str:\\n        res = \\'\\'\\n        for i in word1:\\n            if i not in self.dic:\\n                return \\'\\'\\n            res += self.values[self.dic[i]]\\n        return res\\n\\n    def decrypt(self, word2: str) -> int:\\n        cnt = 0\\n        for i in self.dictionary:\\n            s = self.encrypt(i)\\n            if s == word2:\\n                cnt += 1\\n        return cnt\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.dic = {x : i for i, x in enumerate(keys)}\\n        self.values = values\\n        self.dictionary = dictionary\\n\\n    def encrypt(self, word1: str) -> str:\\n        res = \\'\\'\\n        for i in word1:\\n            if i not in self.dic:\\n                return \\'\\'\\n            res += self.values[self.dic[i]]\\n        return res\\n\\n    def decrypt(self, word2: str) -> int:\\n        cnt = 0\\n        for i in self.dictionary:\\n            s = self.encrypt(i)\\n            if s == word2:\\n                cnt += 1\\n        return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2402687,
                "title": "java-hashmap-84",
                "content": "```\\nclass Encrypter {\\n    Map<Character,String> encTable;\\n    Map<String,Integer> dictionaryMap;\\n    int decRes;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        encTable = new HashMap<>();\\n        dictionaryMap = new HashMap<>();\\n        for(int i = 0; i < keys.length; i++){\\n            encTable.put(keys[i], values[i]);            \\n        }\\n        \\n        for(String s : dictionary){\\n            char[] cArr = s.toCharArray();\\n            StringBuilder sb = new StringBuilder();\\n            boolean appendYn = true;\\n            for(char c : cArr){\\n                if(!encTable.containsKey(c)){\\n                    appendYn = false;\\n                    break;                    \\n                }\\n                sb.append(encTable.get(c));\\n            }            \\n            \\n            if(!appendYn){\\n                continue;\\n            }\\n            \\n            String d = sb.toString();\\n            if(d.length() > 0){\\n                dictionaryMap.put(d,dictionaryMap.getOrDefault(d,0)+1);\\n            }\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] cArr = word1.toCharArray();\\n        for(char c : cArr){\\n            sb.append(encTable.get(c));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {        \\n        return dictionaryMap.getOrDefault(word2,0);\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n    Map<Character,String> encTable;\\n    Map<String,Integer> dictionaryMap;\\n    int decRes;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        encTable = new HashMap<>();\\n        dictionaryMap = new HashMap<>();\\n        for(int i = 0; i < keys.length; i++){\\n            encTable.put(keys[i], values[i]);            \\n        }\\n        \\n        for(String s : dictionary){\\n            char[] cArr = s.toCharArray();\\n            StringBuilder sb = new StringBuilder();\\n            boolean appendYn = true;\\n            for(char c : cArr){\\n                if(!encTable.containsKey(c)){\\n                    appendYn = false;\\n                    break;                    \\n                }\\n                sb.append(encTable.get(c));\\n            }            \\n            \\n            if(!appendYn){\\n                continue;\\n            }\\n            \\n            String d = sb.toString();\\n            if(d.length() > 0){\\n                dictionaryMap.put(d,dictionaryMap.getOrDefault(d,0)+1);\\n            }\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] cArr = word1.toCharArray();\\n        for(char c : cArr){\\n            sb.append(encTable.get(c));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {        \\n        return dictionaryMap.getOrDefault(word2,0);\\n    }\\n    \\n}",
                "codeTag": "Java"
            },
            {
                "id": 2309711,
                "title": "javascript-easy-to-undertand-beats-67",
                "content": "```\\nclass Encrypter {\\n    constructor (keys, values, dictionary) {\\n        this.encryptMap = keys.reduce((map, key, i) => (map[key] = values[i], map), {});\\n        this.encryptedVals = [...new Set(dictionary)].map((w) => this.encrypt(w));\\n    }\\n    \\n    encrypt (word) {\\n        return word.split(``).reduce((s, c) => s + this.encryptMap[c], ``);\\n    }\\n    \\n    decrypt (word) {\\n        return this.encryptedVals.filter((x) => x === word).length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Encrypter {\\n    constructor (keys, values, dictionary) {\\n        this.encryptMap = keys.reduce((map, key, i) => (map[key] = values[i], map), {});\\n        this.encryptedVals = [...new Set(dictionary)].map((w) => this.encrypt(w));\\n    }\\n    \\n    encrypt (word) {\\n        return word.split(``).reduce((s, c) => s + this.encryptMap[c], ``);\\n    }\\n    \\n    decrypt (word) {\\n        return this.encryptedVals.filter((x) => x === word).length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2286710,
                "title": "javascript-with-pre-encryption",
                "content": "```\\nvar Encrypter = function(keys, values, dictionary) {\\n    this.encryptMap = new Map();\\n    for (let i = 0; i < keys.length; i++) {\\n        this.encryptMap.set(keys[i], values[i]);\\n    }\\n    this.dict = new Set(dictionary);\\n    // Encypt the values in dict for easy comparison later\\n    this.encryptedVals = [];\\n    for (let word of this.dict) {\\n        this.encryptedVals.push(this.encrypt(word));\\n    }\\n};\\nEncrypter.prototype.encrypt = function(word1) {\\n    let encrypted = \\'\\';\\n    for (let char of word1) {\\n        encrypted += this.encryptMap.get(char);\\n    }\\n    return encrypted;\\n};\\nEncrypter.prototype.decrypt = function(word2) {\\n    return this.encryptedVals.filter(x => x === word2).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar Encrypter = function(keys, values, dictionary) {\\n    this.encryptMap = new Map();\\n    for (let i = 0; i < keys.length; i++) {\\n        this.encryptMap.set(keys[i], values[i]);\\n    }\\n    this.dict = new Set(dictionary);\\n    // Encypt the values in dict for easy comparison later\\n    this.encryptedVals = [];\\n    for (let word of this.dict) {\\n        this.encryptedVals.push(this.encrypt(word));\\n    }\\n};\\nEncrypter.prototype.encrypt = function(word1) {\\n    let encrypted = \\'\\';\\n    for (let char of word1) {\\n        encrypted += this.encryptMap.get(char);\\n    }\\n    return encrypted;\\n};\\nEncrypter.prototype.decrypt = function(word2) {\\n    return this.encryptedVals.filter(x => x === word2).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2126251,
                "title": "java-easy-solution-without-using-trie",
                "content": "\\n\\n\\n```\\nMap<Character, String> eMap;\\n    Map<String, Integer> dMap;\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        eMap = new HashMap<>();\\n        dMap = new HashMap<>();\\n        for (int i = 0; i < keys.length; i++) \\n            eMap.put(keys[i], values[i]);\\n\\n        for (int i = 0; i < dictionary.length; i++) {\\n            String str = encrypt(dictionary[i]);\\n\\t\\t\\t/*\\n\\t\\t\\tInput: [\"Encrypter\",\"decrypt\"]  [[[\"a\"],[\"pq\"],[\"aa\",\"x\"]],[\"null\"]]\\n            Output: [null,1]   <------ wrong o/p\\n           Expected: [null,0]\\n\\t\\t\\tto avoid wrong ans,\\n\\t\\t\\twe need to put \"if condition\" after that we need to add in dMap to update the current value\\n\\t\\t\\t*/\\n            if (!str.equals(\"\") && !str.equals(\"null\"))\\n                dMap.put(str, dMap.getOrDefault(str, 0) + 1);\\n        }\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : word1.toCharArray()) {\\n            sb.append(eMap.get(c));\\n        }\\n        return sb.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        return dMap.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nMap<Character, String> eMap;\\n    Map<String, Integer> dMap;\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        eMap = new HashMap<>();\\n        dMap = new HashMap<>();\\n        for (int i = 0; i < keys.length; i++) \\n            eMap.put(keys[i], values[i]);\\n\\n        for (int i = 0; i < dictionary.length; i++) {\\n            String str = encrypt(dictionary[i]);\\n\\t\\t\\t/*\\n\\t\\t\\tInput: [\"Encrypter\",\"decrypt\"]  [[[\"a\"],[\"pq\"],[\"aa\",\"x\"]],[\"null\"]]\\n            Output: [null,1]   <------ wrong o/p\\n           Expected: [null,0]\\n\\t\\t\\tto avoid wrong ans,\\n\\t\\t\\twe need to put \"if condition\" after that we need to add in dMap to update the current value\\n\\t\\t\\t*/\\n            if (!str.equals(\"\") && !str.equals(\"null\"))\\n                dMap.put(str, dMap.getOrDefault(str, 0) + 1);\\n        }\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : word1.toCharArray()) {\\n            sb.append(eMap.get(c));\\n        }\\n        return sb.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        return dMap.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2101700,
                "title": "kotlin-simple-ds-to-reverse-check-the-elements-without-a-trie",
                "content": "```\\nclass MultiString(val size: Int) {\\n    private val indexList: Array<MutableSet<Char>> = Array(size) {it -> mutableSetOf<Char>()}\\n    \\n    fun addPossibleCharsAtIndex(chars: Collection<Char>, index: Int) {\\n        indexList[index].addAll(chars)\\n    }\\n    \\n    override fun toString(): String {\\n        return indexList.joinToString(\",\")\\n    }\\n    fun match(other: String): Boolean {\\n        if(other.length != size) {\\n            return false\\n        }\\n        for(i in 0 until other.length) {\\n            if(!indexList[i].contains(other[i])) {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n\\nclass Encrypter(keys: CharArray, values: Array<String>, dictionary: Array<String>) {\\n    \\n    private val keyMap = mutableMapOf<Char, String>()\\n    private val reverseMap = mutableMapOf<String, MutableSet<Char>>()\\n    private val dictSet = mutableListOf<String>()\\n    \\n    init {\\n        for(i in 0 until keys.size) {\\n            keyMap[keys[i]] = values[i]\\n            val reverseSet = reverseMap[values[i]] ?: mutableSetOf<Char>()\\n            reverseSet.add(keys[i])\\n            reverseMap[values[i]] = reverseSet\\n        }\\n        dictSet.addAll(dictionary)\\n    }\\n\\n    fun encrypt(word1: String): String {\\n        val result = StringBuilder()\\n        var ok = true\\n        for(c in word1) {\\n            val value = keyMap[c] ?: run {\\n                ok = false\\n            }\\n            if(!ok) {\\n                break\\n            }\\n            result.append(value)\\n        }\\n        if(!ok) {\\n            return \"\"\\n        }\\n        return result.toString()\\n    }\\n\\n    fun decrypt(word2: String): Int {\\n        var count = 0\\n        val word2MultiString = MultiString(word2.length/2)\\n        for(i in 0 until word2.length step 2) {\\n            val currentString = \"\" + word2[i] + word2[i+1]\\n            val chars = reverseMap[currentString] ?: return 0\\n            word2MultiString.addPossibleCharsAtIndex(chars, i/2)\\n        }\\n        //println(word2MultiString)\\n        \\n        for(dict in dictSet) {\\n            if(word2MultiString.match(dict)) {\\n                //println(\"$dict is a match\")\\n                count++\\n            }\\n        }\\n        return count\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MultiString(val size: Int) {\\n    private val indexList: Array<MutableSet<Char>> = Array(size) {it -> mutableSetOf<Char>()}\\n    \\n    fun addPossibleCharsAtIndex(chars: Collection<Char>, index: Int) {\\n        indexList[index].addAll(chars)\\n    }\\n    \\n    override fun toString(): String {\\n        return indexList.joinToString(\",\")\\n    }\\n    fun match(other: String): Boolean {\\n        if(other.length != size) {\\n            return false\\n        }\\n        for(i in 0 until other.length) {\\n            if(!indexList[i].contains(other[i])) {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n\\nclass Encrypter(keys: CharArray, values: Array<String>, dictionary: Array<String>) {\\n    \\n    private val keyMap = mutableMapOf<Char, String>()\\n    private val reverseMap = mutableMapOf<String, MutableSet<Char>>()\\n    private val dictSet = mutableListOf<String>()\\n    \\n    init {\\n        for(i in 0 until keys.size) {\\n            keyMap[keys[i]] = values[i]\\n            val reverseSet = reverseMap[values[i]] ?: mutableSetOf<Char>()\\n            reverseSet.add(keys[i])\\n            reverseMap[values[i]] = reverseSet\\n        }\\n        dictSet.addAll(dictionary)\\n    }\\n\\n    fun encrypt(word1: String): String {\\n        val result = StringBuilder()\\n        var ok = true\\n        for(c in word1) {\\n            val value = keyMap[c] ?: run {\\n                ok = false\\n            }\\n            if(!ok) {\\n                break\\n            }\\n            result.append(value)\\n        }\\n        if(!ok) {\\n            return \"\"\\n        }\\n        return result.toString()\\n    }\\n\\n    fun decrypt(word2: String): Int {\\n        var count = 0\\n        val word2MultiString = MultiString(word2.length/2)\\n        for(i in 0 until word2.length step 2) {\\n            val currentString = \"\" + word2[i] + word2[i+1]\\n            val chars = reverseMap[currentString] ?: return 0\\n            word2MultiString.addPossibleCharsAtIndex(chars, i/2)\\n        }\\n        //println(word2MultiString)\\n        \\n        for(dict in dictSet) {\\n            if(word2MultiString.match(dict)) {\\n                //println(\"$dict is a match\")\\n                count++\\n            }\\n        }\\n        return count\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054508,
                "title": "java-trie",
                "content": "```\\nclass Encrypter {\\n    \\n    Map<Character,Integer> map = new HashMap<>();\\n    Map<String,List<Integer>> valueMap = new HashMap<>();\\n    char [] keys;\\n\\tTrie trie = new Trie();\\n    String[] values;\\n    \\n    class Trie{\\n        Map<Character,Trie> children = new HashMap<>();\\n        boolean leaf = false;\\n        \\n        void insert(String str,int idx){\\n            if(idx>=str.length()){\\n                this.leaf = true;\\n                return;\\n            }\\n            Trie child = children.get(str.charAt(idx));\\n            if(child==null){\\n                children.put(str.charAt(idx),new Trie());\\n            }\\n            children.get(str.charAt(idx)).insert(str,idx+1);\\n        }\\n        \\n        int search(String str, int idx){\\n            if(str.length()%2!=0){\\n                return 0;\\n            }\\n            if(idx>=str.length()){\\n                return this.leaf?1:0;\\n            }\\n            int count = 0;\\n            String next = str.substring(idx,idx+2);\\n            List<Integer> nextIndicies = valueMap.getOrDefault(next,new ArrayList<>());\\n            for(Integer nextIndex:nextIndicies){\\n                if(children.containsKey(keys[nextIndex])){\\n                    count += children.get(keys[nextIndex]).search(str, idx + 2);\\n                }\\n            }\\n            return count;\\n        }\\n    }\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.keys = keys;\\n        this.values = values;\\n        for(int i= 0;i<keys.length;i++){\\n            map.put(keys[i],i);\\n        }\\n        for(int i= 0;i<values.length;i++){\\n            List<Integer> list = valueMap.getOrDefault(values[i],new ArrayList<>());\\n            list.add(i);\\n            valueMap.put(values[i],list);\\n        }\\n        \\n        for(String str : dictionary){\\n            trie.insert(str,0);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuffer b = new StringBuffer();\\n        for(char ch : word1.toCharArray()){\\n            if(map.containsKey(ch)){\\n                b.append(values[map.get(ch)]);\\n            }else{\\n                return \"\";\\n            }\\n        }\\n        return b.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return trie.search(word2,0);\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\n    \\n    Map<Character,Integer> map = new HashMap<>();\\n    Map<String,List<Integer>> valueMap = new HashMap<>();\\n    char [] keys;\\n\\tTrie trie = new Trie();\\n    String[] values;\\n    \\n    class Trie{\\n        Map<Character,Trie> children = new HashMap<>();\\n        boolean leaf = false;\\n        \\n        void insert(String str,int idx){\\n            if(idx>=str.length()){\\n                this.leaf = true;\\n                return;\\n            }\\n            Trie child = children.get(str.charAt(idx));\\n            if(child==null){\\n                children.put(str.charAt(idx),new Trie());\\n            }\\n            children.get(str.charAt(idx)).insert(str,idx+1);\\n        }\\n        \\n        int search(String str, int idx){\\n            if(str.length()%2!=0){\\n                return 0;\\n            }\\n            if(idx>=str.length()){\\n                return this.leaf?1:0;\\n            }\\n            int count = 0;\\n            String next = str.substring(idx,idx+2);\\n            List<Integer> nextIndicies = valueMap.getOrDefault(next,new ArrayList<>());\\n            for(Integer nextIndex:nextIndicies){\\n                if(children.containsKey(keys[nextIndex])){\\n                    count += children.get(keys[nextIndex]).search(str, idx + 2);\\n                }\\n            }\\n            return count;\\n        }\\n    }\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.keys = keys;\\n        this.values = values;\\n        for(int i= 0;i<keys.length;i++){\\n            map.put(keys[i],i);\\n        }\\n        for(int i= 0;i<values.length;i++){\\n            List<Integer> list = valueMap.getOrDefault(values[i],new ArrayList<>());\\n            list.add(i);\\n            valueMap.put(values[i],list);\\n        }\\n        \\n        for(String str : dictionary){\\n            trie.insert(str,0);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuffer b = new StringBuffer();\\n        for(char ch : word1.toCharArray()){\\n            if(map.containsKey(ch)){\\n                b.append(values[map.get(ch)]);\\n            }else{\\n                return \"\";\\n            }\\n        }\\n        return b.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return trie.search(word2,0);\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2023323,
                "title": "c-without-trie",
                "content": "```\\n#define forup(i,i0,n) for(int i=i0; i<=(int)n; i++)\\n#define fordown(i,n,i0) for(int i=n; i>=(int)i0; i--)\\n\\nclass Encrypter {\\n    map <char, string> keyToVal; \\n    map <string, set <char> > valToKey; \\n    vector <string> d; \\npublic:\\n    Encrypter(vector<char> keys, vector<string> values, vector<string> dict) {\\n        forup(i,0,keys.size()-1) {\\n            keyToVal[keys[i]] = values[i];\\n            valToKey[values[i]].insert(keys[i]);\\n        }\\n        d = dict;\\n    }\\n    \\n    string encrypt(string w) {\\n        string res=\"\";\\n        forup(i,0,w.size()-1) {\\n            if (keyToVal.find(w[i]) == keyToVal.end()) return \"\"; \\n            res += keyToVal[w[i]]; \\n        }\\n        return res; \\n    }\\n    \\n    int decrypt(string w) {\\n        int n = w.size();\\n        if (n%2 == 1) return 0; \\n        int ans = 0;\\n        for(string cand : d) {\\n            if (cand.size() == n/2) {\\n                bool ok = true; \\n                for(int i = 0; i < n; i+=2) {\\n                    string val = \"\"; val+=w[i]; val+=w[i+1]; \\n                    if (valToKey.find(val) != valToKey.end()) {\\n                        if (valToKey[val].find(cand[i/2]) == valToKey[val].end()) ok = false; \\n                    }\\n                    else ok = false; \\n                }\\n                if (ok) ans++;\\n            }\\n        }\\n        return ans;          \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define forup(i,i0,n) for(int i=i0; i<=(int)n; i++)\\n#define fordown(i,n,i0) for(int i=n; i>=(int)i0; i--)\\n\\nclass Encrypter {\\n    map <char, string> keyToVal; \\n    map <string, set <char> > valToKey; \\n    vector <string> d; \\npublic:\\n    Encrypter(vector<char> keys, vector<string> values, vector<string> dict) {\\n        forup(i,0,keys.size()-1) {\\n            keyToVal[keys[i]] = values[i];\\n            valToKey[values[i]].insert(keys[i]);\\n        }\\n        d = dict;\\n    }\\n    \\n    string encrypt(string w) {\\n        string res=\"\";\\n        forup(i,0,w.size()-1) {\\n            if (keyToVal.find(w[i]) == keyToVal.end()) return \"\"; \\n            res += keyToVal[w[i]]; \\n        }\\n        return res; \\n    }\\n    \\n    int decrypt(string w) {\\n        int n = w.size();\\n        if (n%2 == 1) return 0; \\n        int ans = 0;\\n        for(string cand : d) {\\n            if (cand.size() == n/2) {\\n                bool ok = true; \\n                for(int i = 0; i < n; i+=2) {\\n                    string val = \"\"; val+=w[i]; val+=w[i+1]; \\n                    if (valToKey.find(val) != valToKey.end()) {\\n                        if (valToKey[val].find(cand[i/2]) == valToKey[val].end()) ok = false; \\n                    }\\n                    else ok = false; \\n                }\\n                if (ok) ans++;\\n            }\\n        }\\n        return ans;          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1973915,
                "title": "c-trie-based-solution",
                "content": "```\\nclass Encrypter {\\n    unordered_map<char, string> map;\\n    unordered_map<string, vector<char>> reverse_map;\\n    class trie {\\n      vector<trie*> next;\\n      bool end;\\n    public:\\n      trie() {\\n        next.resize(26, nullptr);\\n        end = false;\\n      }\\n      ~trie() {\\n        for (trie *t : next) delete t;\\n        next.clear();\\n      }\\n      void add(const std::string &s) {\\n        trie *t = this;\\n        for (int i = 0; i < s.length(); i++) {\\n          if (t->next[s[i]-\\'a\\'] == nullptr) {\\n            t->next[s[i]-\\'a\\'] = new trie;\\n          }\\n          t = t->next[s[i]-\\'a\\'];\\n        }\\n        t->end = true;\\n      }\\n      trie* nextNode(char ch) {\\n        return next[ch-\\'a\\'];\\n      }\\n      bool isValid() { return end; }        \\n    };\\n    trie t;    \\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (string &s: dictionary)\\n          t.add(s);\\n        for (int i = 0; i < keys.size(); i++) { \\n            map[keys[i]] = values[i];\\n            reverse_map[values[i]].push_back(keys[i]);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        stringstream ss;\\n        for (char ch: word1) {\\n            auto it = map.find(ch);\\n            if (it != map.end())\\n                ss << it->second;\\n            else ss << ch;\\n        }\\n        return ss.str();\\n    }\\n\\n    void helper(std::string &s, int &cnt, int index, trie* node) {\\n      if (index >= s.length()) {\\n        if (node && node->isValid())\\n            cnt++;\\n        return;\\n      }\\n      string t = s.substr(index, 2);\\n      for (char ch: reverse_map[t]) {\\n        trie *t_node = node->nextNode(ch);\\n        if (t_node != nullptr) {\\n          helper(s, cnt, index+2, t_node);\\n        }\\n      }\\n    }    \\n    int decrypt(string word2) {\\n        int cnt = 0;\\n        helper(word2, cnt, 0, &t);\\n        return cnt;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\n    unordered_map<char, string> map;\\n    unordered_map<string, vector<char>> reverse_map;\\n    class trie {\\n      vector<trie*> next;\\n      bool end;\\n    public:\\n      trie() {\\n        next.resize(26, nullptr);\\n        end = false;\\n      }\\n      ~trie() {\\n        for (trie *t : next) delete t;\\n        next.clear();\\n      }\\n      void add(const std::string &s) {\\n        trie *t = this;\\n        for (int i = 0; i < s.length(); i++) {\\n          if (t->next[s[i]-\\'a\\'] == nullptr) {\\n            t->next[s[i]-\\'a\\'] = new trie;\\n          }\\n          t = t->next[s[i]-\\'a\\'];\\n        }\\n        t->end = true;\\n      }\\n      trie* nextNode(char ch) {\\n        return next[ch-\\'a\\'];\\n      }\\n      bool isValid() { return end; }        \\n    };\\n    trie t;    \\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (string &s: dictionary)\\n          t.add(s);\\n        for (int i = 0; i < keys.size(); i++) { \\n            map[keys[i]] = values[i];\\n            reverse_map[values[i]].push_back(keys[i]);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        stringstream ss;\\n        for (char ch: word1) {\\n            auto it = map.find(ch);\\n            if (it != map.end())\\n                ss << it->second;\\n            else ss << ch;\\n        }\\n        return ss.str();\\n    }\\n\\n    void helper(std::string &s, int &cnt, int index, trie* node) {\\n      if (index >= s.length()) {\\n        if (node && node->isValid())\\n            cnt++;\\n        return;\\n      }\\n      string t = s.substr(index, 2);\\n      for (char ch: reverse_map[t]) {\\n        trie *t_node = node->nextNode(ch);\\n        if (t_node != nullptr) {\\n          helper(s, cnt, index+2, t_node);\\n        }\\n      }\\n    }    \\n    int decrypt(string word2) {\\n        int cnt = 0;\\n        helper(word2, cnt, 0, &t);\\n        return cnt;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1969128,
                "title": "java-trie-based-faster-than-95-mem-less-than-87",
                "content": "```\\nclass Encrypter {\\n    Map<Character, Integer> keysMap;\\n    Map<String, Set<Integer>> valuesMap;\\n    char[] keys;\\n    String[] values;\\n    Trie trie;\\n    Map<String, Integer> decMem;\\n    Map<String, String> encMem;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.keys = keys;\\n        this.values = values;\\n        this.keysMap = new HashMap<>();\\n        this.valuesMap = new HashMap<>();\\n        this.trie = new Trie();\\n        decMem = new HashMap<>();\\n        encMem = new HashMap<>();\\n        for(int i=0; i<keys.length; i++){\\n            keysMap.put(keys[i], i);\\n        }\\n        for(int i=0; i< this.values.length; i++){\\n            Set<Integer> st = valuesMap.getOrDefault(values[i], new HashSet<>());\\n            st.add(i);\\n            valuesMap.put(values[i], st);\\n        }\\n        for(String s: dictionary){\\n            trie.add(s);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        if(encMem.containsKey(word1)) return encMem.get(word1);\\n        StringBuilder res = new StringBuilder();\\n        for(int i=0; i<word1.length(); i++){\\n            if(!keysMap.containsKey(word1.charAt(i))) return \"\";\\n            String repl = this.values[keysMap.get(word1.charAt(i))];\\n            res.append(repl);\\n        }\\n        String ans = res.toString();\\n        encMem.put(word1, ans);\\n        return ans;\\n    } \\n     public int decrypt(String word2) {\\n         if(decMem.containsKey(word2)) return decMem.get(word2);\\n         int ans = decryptRec(word2, 0, new StringBuilder(), this.trie);\\n         decMem.put(word2, ans);\\n         return ans;\\n     }\\n    public int decryptRec(String word2, int start, StringBuilder prefix, Trie t) {\\n        //handle base case\\n        if(start>=word2.length()) {\\n            if(this.trie.wordExists(prefix)) return 1;\\n            return 0;\\n        }\\n        String hashed = word2.substring(start, start+2);\\n        Set<Integer> indcs = valuesMap.getOrDefault(hashed, new HashSet<>());\\n        int ans = 0;\\n        for(Integer i: indcs){\\n            char repl = keys[i];\\n            prefix.append(repl);\\n            if(t.links.containsKey(repl)) ans = ans + decryptRec(word2, start+2, prefix, t.links.get(repl));\\n            prefix.deleteCharAt(prefix.length()-1);\\n        }\\n        return ans;\\n    }\\n}\\nclass Trie{\\n    Map<Character, Trie> links = new HashMap<>();\\n    boolean isTerminal = false;\\n    String word = null;\\n    public void add(String s){\\n        Trie cur = this;\\n        for(int i=0; i<s.length(); i++){\\n            Trie next = cur.links.getOrDefault(s.charAt(i), new Trie());\\n            cur.links.put(s.charAt(i), next);\\n            if(i==s.length()-1){\\n                next.isTerminal = true;\\n                next.word = s;\\n            }\\n            cur = next;\\n        }\\n    }\\n    public boolean prefixExists(StringBuilder p){\\n        Trie t = this;\\n        for(int i=0; i<p.length(); i++){\\n            if(!t.links.containsKey(p.charAt(i))) return false;\\n            t = t.links.get(p.charAt(i));\\n        }\\n        return true;\\n    }\\n    public boolean wordExists(StringBuilder p){\\n        Trie t = this;\\n        for(int i=0; i<p.length(); i++){\\n            if(!t.links.containsKey(p.charAt(i))) return false;\\n            if(i==p.length()-1 && t.links.get(p.charAt(i)).isTerminal) return true;\\n            t = t.links.get(p.charAt(i));\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\n    Map<Character, Integer> keysMap;\\n    Map<String, Set<Integer>> valuesMap;\\n    char[] keys;\\n    String[] values;\\n    Trie trie;\\n    Map<String, Integer> decMem;\\n    Map<String, String> encMem;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.keys = keys;\\n        this.values = values;\\n        this.keysMap = new HashMap<>();\\n        this.valuesMap = new HashMap<>();\\n        this.trie = new Trie();\\n        decMem = new HashMap<>();\\n        encMem = new HashMap<>();\\n        for(int i=0; i<keys.length; i++){\\n            keysMap.put(keys[i], i);\\n        }\\n        for(int i=0; i< this.values.length; i++){\\n            Set<Integer> st = valuesMap.getOrDefault(values[i], new HashSet<>());\\n            st.add(i);\\n            valuesMap.put(values[i], st);\\n        }\\n        for(String s: dictionary){\\n            trie.add(s);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        if(encMem.containsKey(word1)) return encMem.get(word1);\\n        StringBuilder res = new StringBuilder();\\n        for(int i=0; i<word1.length(); i++){\\n            if(!keysMap.containsKey(word1.charAt(i))) return \"\";\\n            String repl = this.values[keysMap.get(word1.charAt(i))];\\n            res.append(repl);\\n        }\\n        String ans = res.toString();\\n        encMem.put(word1, ans);\\n        return ans;\\n    } \\n     public int decrypt(String word2) {\\n         if(decMem.containsKey(word2)) return decMem.get(word2);\\n         int ans = decryptRec(word2, 0, new StringBuilder(), this.trie);\\n         decMem.put(word2, ans);\\n         return ans;\\n     }\\n    public int decryptRec(String word2, int start, StringBuilder prefix, Trie t) {\\n        //handle base case\\n        if(start>=word2.length()) {\\n            if(this.trie.wordExists(prefix)) return 1;\\n            return 0;\\n        }\\n        String hashed = word2.substring(start, start+2);\\n        Set<Integer> indcs = valuesMap.getOrDefault(hashed, new HashSet<>());\\n        int ans = 0;\\n        for(Integer i: indcs){\\n            char repl = keys[i];\\n            prefix.append(repl);\\n            if(t.links.containsKey(repl)) ans = ans + decryptRec(word2, start+2, prefix, t.links.get(repl));\\n            prefix.deleteCharAt(prefix.length()-1);\\n        }\\n        return ans;\\n    }\\n}\\nclass Trie{\\n    Map<Character, Trie> links = new HashMap<>();\\n    boolean isTerminal = false;\\n    String word = null;\\n    public void add(String s){\\n        Trie cur = this;\\n        for(int i=0; i<s.length(); i++){\\n            Trie next = cur.links.getOrDefault(s.charAt(i), new Trie());\\n            cur.links.put(s.charAt(i), next);\\n            if(i==s.length()-1){\\n                next.isTerminal = true;\\n                next.word = s;\\n            }\\n            cur = next;\\n        }\\n    }\\n    public boolean prefixExists(StringBuilder p){\\n        Trie t = this;\\n        for(int i=0; i<p.length(); i++){\\n            if(!t.links.containsKey(p.charAt(i))) return false;\\n            t = t.links.get(p.charAt(i));\\n        }\\n        return true;\\n    }\\n    public boolean wordExists(StringBuilder p){\\n        Trie t = this;\\n        for(int i=0; i<p.length(); i++){\\n            if(!t.links.containsKey(p.charAt(i))) return false;\\n            if(i==p.length()-1 && t.links.get(p.charAt(i)).isTerminal) return true;\\n            t = t.links.get(p.charAt(i));\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962125,
                "title": "c-2227-encrypt-and-decrypt-strings",
                "content": "\\n```\\nclass Encrypter {\\n    unordered_map<char, string> mp; \\n    unordered_map<string, int> freq; \\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i) mp[keys[i]] = values[i]; \\n        for (auto& word : dictionary) {\\n            string key; \\n            for (auto& ch : word) \\n                if (!mp.count(ch)) key += \"##\"; \\n                else key += mp[ch]; \\n            ++freq[key]; \\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans; \\n        for (auto& ch : word1) ans += mp[ch]; \\n        return ans; \\n    }\\n    \\n    int decrypt(string word2) {\\n        return freq[word2]; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\n    unordered_map<char, string> mp; \\n    unordered_map<string, int> freq; \\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i) mp[keys[i]] = values[i]; \\n        for (auto& word : dictionary) {\\n            string key; \\n            for (auto& ch : word) \\n                if (!mp.count(ch)) key += \"##\"; \\n                else key += mp[ch]; \\n            ++freq[key]; \\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans; \\n        for (auto& ch : word1) ans += mp[ch]; \\n        return ans; \\n    }\\n    \\n    int decrypt(string word2) {\\n        return freq[word2]; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1947464,
                "title": "simple-python-solution",
                "content": "class Encrypter(object):\\n\\n    def __init__(self, keys, values, dictionary):\\n\\n        self.values=values\\n        self.keys=keys\\n        self.dic=defaultdict(int)\\n        for i in dictionary:\\n            self.dic[self.encrypt(i)]+=1\\n        \\n        \"\"\"\\n        :type keys: List[str]\\n        :type values: List[str]\\n        :type dictionary: List[str]\\n        \"\"\"\\n        \\n\\n    def encrypt(self, word1):\\n        ans=\"\"\\n        for i in word1:\\n            if i not in self.keys:\\n                return 0\\n            ans+=self.values[(self.keys.index(i))]\\n        return ans\\n        \"\"\"\\n        :type word1: str\\n        :rtype: str\\n        \"\"\"\\n        \\n\\n    def decrypt(self, word2):\\n        return self.dic[word2]\\n        \"\"\"\\n        :type word2: str\\n        :rtype: int\\n        \"\"\"\\n        \\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Encrypter(object):\\n\\n    def __init__(self, keys, values, dictionary):\\n\\n        self.values=values\\n        self.keys=keys\\n        self.dic=defaultdict(int)\\n        for i in dictionary:\\n            self.dic[self.encrypt(i)]+=1\\n        \\n        \"\"\"\\n        :type keys: List[str]\\n        :type values: List[str]\\n        :type dictionary: List[str]\\n        \"\"\"\\n        \\n\\n    def encrypt(self, word1):\\n        ans=\"\"\\n        for i in word1:\\n            if i not in self.keys:\\n                return 0\\n            ans+=self.values[(self.keys.index(i))]\\n        return ans\\n        \"\"\"\\n        :type word1: str\\n        :rtype: str\\n        \"\"\"\\n        \\n\\n    def decrypt(self, word2):\\n        return self.dic[word2]\\n        \"\"\"\\n        :type word2: str\\n        :rtype: int\\n        \"\"\"\\n        \\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1942236,
                "title": "trie-bfs",
                "content": "```\\nclass Encrypter \\n{\\nprivate:\\n    unordered_map<char,string> m;\\n    unordered_map<string,vector<char>> ump;\\n    struct Node\\n    {\\n        Node* links[26];\\n        bool flag=false;\\n        \\n        bool containsKey(char ch)\\n        {\\n            return links[ch-\\'a\\']!=nullptr;\\n        }\\n\\n        void put(char ch,Node* node)\\n        {\\n            links[ch-\\'a\\']=node;\\n        }\\n        \\n        Node* get(char ch)\\n        {\\n            return links[ch-\\'a\\'];\\n        }\\n        \\n        void setEnd()\\n        {\\n            flag = true;\\n        }\\n    };\\n    \\n    void insert(Node* node,string word)\\n    {\\n        for(int i=0;i<word.length();i++)\\n        {\\n            if(!node->containsKey(word[i]))\\n            {\\n                node->put(word[i],new Node());\\n            }\\n            node = node->get(word[i]);\\n        }\\n        node->setEnd();\\n    }\\n    \\n    bool search(Node* node,string word)\\n    {\\n        for(int i=0;i<word.length();i++)\\n        {\\n            if(node->containsKey(word[i]))\\n                node=node->get(word[i]);\\n            else\\n                return false;\\n        }\\n        return node->flag;\\n    }\\n    Node* root;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) \\n    {\\n        root=new Node();\\n        for(string s:dictionary)\\n            insert(root,s);\\n        ump.clear();\\n        m.clear();\\n        for(int i=0;i<keys.size();i++){\\n            m[keys[i]]=values[i];\\n            ump[values[i]].push_back(keys[i]);\\n        }\\n    }\\n    \\n    string encrypt(string word1) \\n    {\\n        string ans=\"\";\\n        for(char c : word1)\\n        {\\n            ans+=m[c];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) \\n    {\\n        int ans=0;\\n        vector<vector<char>> v;        \\n        for(int i=0;i<word2.length();i+=2)\\n        {\\n            string str = word2.substr(i,2);\\n            vector<char> temp;\\n            for(char c : ump[str])\\n            {\\n                temp.push_back(c);\\n            }    \\n            v.push_back(temp);\\n        }\\n        int j=0;\\n        queue<Node*> q;\\n        q.push(root);\\n        q.push(nullptr);\\n        int f = v.size()-1;\\n        \\n        while(j<v.size() && !q.empty())\\n        {\\n            Node* temp = q.front();\\n            if(temp == nullptr)\\n            {\\n                j++;\\n                q.pop();\\n                if(j!=v.size())\\n                    q.push(nullptr);\\n                continue;\\n            }\\n            if(j != f)\\n            {                \\n                for(char ch : v[j])\\n                {\\n                    if(temp->containsKey(ch))\\n                    {\\n                        q.push(temp->get(ch));\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                for(char ch : v[j])\\n                {\\n                    if(temp->containsKey(ch))\\n                    {\\n                        Node* t = temp->get(ch);\\n                        if(t->flag)\\n                            ans++;                        \\n                    }\\n                }\\n            }  \\n            q.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "Trie",
                    "Queue"
                ],
                "code": "```\\nclass Encrypter \\n{\\nprivate:\\n    unordered_map<char,string> m;\\n    unordered_map<string,vector<char>> ump;\\n    struct Node\\n    {\\n        Node* links[26];\\n        bool flag=false;\\n        \\n        bool containsKey(char ch)\\n        {\\n            return links[ch-\\'a\\']!=nullptr;\\n        }\\n\\n        void put(char ch,Node* node)\\n        {\\n            links[ch-\\'a\\']=node;\\n        }\\n        \\n        Node* get(char ch)\\n        {\\n            return links[ch-\\'a\\'];\\n        }\\n        \\n        void setEnd()\\n        {\\n            flag = true;\\n        }\\n    };\\n    \\n    void insert(Node* node,string word)\\n    {\\n        for(int i=0;i<word.length();i++)\\n        {\\n            if(!node->containsKey(word[i]))\\n            {\\n                node->put(word[i],new Node());\\n            }\\n            node = node->get(word[i]);\\n        }\\n        node->setEnd();\\n    }\\n    \\n    bool search(Node* node,string word)\\n    {\\n        for(int i=0;i<word.length();i++)\\n        {\\n            if(node->containsKey(word[i]))\\n                node=node->get(word[i]);\\n            else\\n                return false;\\n        }\\n        return node->flag;\\n    }\\n    Node* root;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) \\n    {\\n        root=new Node();\\n        for(string s:dictionary)\\n            insert(root,s);\\n        ump.clear();\\n        m.clear();\\n        for(int i=0;i<keys.size();i++){\\n            m[keys[i]]=values[i];\\n            ump[values[i]].push_back(keys[i]);\\n        }\\n    }\\n    \\n    string encrypt(string word1) \\n    {\\n        string ans=\"\";\\n        for(char c : word1)\\n        {\\n            ans+=m[c];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) \\n    {\\n        int ans=0;\\n        vector<vector<char>> v;        \\n        for(int i=0;i<word2.length();i+=2)\\n        {\\n            string str = word2.substr(i,2);\\n            vector<char> temp;\\n            for(char c : ump[str])\\n            {\\n                temp.push_back(c);\\n            }    \\n            v.push_back(temp);\\n        }\\n        int j=0;\\n        queue<Node*> q;\\n        q.push(root);\\n        q.push(nullptr);\\n        int f = v.size()-1;\\n        \\n        while(j<v.size() && !q.empty())\\n        {\\n            Node* temp = q.front();\\n            if(temp == nullptr)\\n            {\\n                j++;\\n                q.pop();\\n                if(j!=v.size())\\n                    q.push(nullptr);\\n                continue;\\n            }\\n            if(j != f)\\n            {                \\n                for(char ch : v[j])\\n                {\\n                    if(temp->containsKey(ch))\\n                    {\\n                        q.push(temp->get(ch));\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                for(char ch : v[j])\\n                {\\n                    if(temp->containsKey(ch))\\n                    {\\n                        Node* t = temp->get(ch);\\n                        if(t->flag)\\n                            ans++;                        \\n                    }\\n                }\\n            }  \\n            q.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936856,
                "title": "c-simple-solution",
                "content": "*The solution is very intuitive.*\\n**1**. **Encrypt**:\\n\\tFor encryption, we need to replace every char of `word1` by its corresponding value. It is best to use a hashmap to store key, value pairs. So, while encrypting, replace every character by its corresponding value stored in the map `k2v`.\\n\\n**2**. **Decrypt**:\\n\\tSince we need to match every possible decryption with the given dictionary to see how many matches are there, it is better to reverse this approach. So, for every word in the dictionary, calculate the encrypted version and store the count of it in another hashmap `dict` . So, when decrypt function is called, we can just return the count of `dict[word2]`. Thing to note is, while calculating encryptions of words in a dictionary, not every char of a word will be in `k2v keys`. So, for those strings, no encryption is possible and hence we do need to store them (as they will never be able form a word with a possible decryption).\\n\\n```\\nclass Encrypter {\\nprivate:\\n    unordered_map<char, string> k2v;\\n    unordered_map<string, int> dict;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0; i<keys.size(); i++){\\n            k2v[keys[i]] = values[i];\\n        }\\n        for(string d: dictionary){\\n            string enc = \"\";\\n            int flag = 0;\\n            for(char c: d){\\n                if(k2v.find(c) == k2v.end()){\\n                    flag = 1;\\n                    break;\\n                }\\n                enc += k2v[c];\\n            }\\n            if(!flag) dict[enc]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string enc = \"\";\\n        for(char c: word1){\\n            enc += k2v[c];\\n        }\\n        return enc;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return dict[word2];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Encrypter {\\nprivate:\\n    unordered_map<char, string> k2v;\\n    unordered_map<string, int> dict;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0; i<keys.size(); i++){\\n            k2v[keys[i]] = values[i];\\n        }\\n        for(string d: dictionary){\\n            string enc = \"\";\\n            int flag = 0;\\n            for(char c: d){\\n                if(k2v.find(c) == k2v.end()){\\n                    flag = 1;\\n                    break;\\n                }\\n                enc += k2v[c];\\n            }\\n            if(!flag) dict[enc]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string enc = \"\";\\n        for(char c: word1){\\n            enc += k2v[c];\\n        }\\n        return enc;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return dict[word2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1930872,
                "title": "scala-trie-with-dfs",
                "content": "```scala\\n\\nclass Encrypter(_keys: Array[Char], _values: Array[String], _dictionary: Array[String]) {\\n\\n  type int = Int\\n  import scala.collection.mutable.{HashMap, ArrayBuffer}\\n  val keys = new HashMap[Char, Int]\\n  _keys.zipWithIndex.foreach { case (v, i) =>\\n    keys += (v -> i)\\n  }\\n  type ab = ArrayBuffer[int]\\n  val values = new HashMap[String, ab]\\n  _values.zipWithIndex.foreach {\\n    case (x, i) => {\\n      if (!values.contains(x)) values += (x -> new ab)\\n      values(x) += i\\n    }\\n  }\\n\\n  case class Node(\\n      val c: Char,\\n      val chs: HashMap[Char, Node] = new HashMap[Char, Node],\\n      var isEnd: Boolean = false\\n  )\\n\\n  def f(_node: Node, str: String): Unit = {\\n    var node = _node\\n    str.toCharArray\\n      .foreach(c => {\\n        if (!node.chs.contains(c)) node.chs += (c -> (new Node(c)))\\n        node = node.chs(c)\\n      })\\n    node.isEnd = true\\n  }\\n\\n  val root = new Node(\\' \\')\\n  _dictionary.foreach(str => f(root, str))\\n\\n  // println(values )\\n  def encrypt(word1: String): String =\\n    word1.toCharArray\\n      .map(c => _values(keys(c)))\\n      .mkString\\n\\n  def decrypt(word2: String): Int = {\\n\\n    var count    = 0\\n    var continue = true\\n    def f(idx: int, node: Node): Unit = {\\n      if (!continue) return\\n      if (idx == word2.length()) {\\n        if (node.isEnd)\\n          count += 1\\n        return\\n      }\\n      val s = word2.charAt(idx) + \"\" + word2.charAt(idx + 1)\\n      if (!values.contains(s)) {\\n        continue = false\\n        return\\n      }\\n      values(s).foreach(id => if (node.chs.contains(_keys(id))) f(idx + 2, node.chs(_keys(id))))\\n\\n    }\\n\\n    f(0, root)\\n    count\\n\\n  }\\n\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```scala\\n\\nclass Encrypter(_keys: Array[Char], _values: Array[String], _dictionary: Array[String]) {\\n\\n  type int = Int\\n  import scala.collection.mutable.{HashMap, ArrayBuffer}\\n  val keys = new HashMap[Char, Int]\\n  _keys.zipWithIndex.foreach { case (v, i) =>\\n    keys += (v -> i)\\n  }\\n  type ab = ArrayBuffer[int]\\n  val values = new HashMap[String, ab]\\n  _values.zipWithIndex.foreach {\\n    case (x, i) => {\\n      if (!values.contains(x)) values += (x -> new ab)\\n      values(x) += i\\n    }\\n  }\\n\\n  case class Node(\\n      val c: Char,\\n      val chs: HashMap[Char, Node] = new HashMap[Char, Node],\\n      var isEnd: Boolean = false\\n  )\\n\\n  def f(_node: Node, str: String): Unit = {\\n    var node = _node\\n    str.toCharArray\\n      .foreach(c => {\\n        if (!node.chs.contains(c)) node.chs += (c -> (new Node(c)))\\n        node = node.chs(c)\\n      })\\n    node.isEnd = true\\n  }\\n\\n  val root = new Node(\\' \\')\\n  _dictionary.foreach(str => f(root, str))\\n\\n  // println(values )\\n  def encrypt(word1: String): String =\\n    word1.toCharArray\\n      .map(c => _values(keys(c)))\\n      .mkString\\n\\n  def decrypt(word2: String): Int = {\\n\\n    var count    = 0\\n    var continue = true\\n    def f(idx: int, node: Node): Unit = {\\n      if (!continue) return\\n      if (idx == word2.length()) {\\n        if (node.isEnd)\\n          count += 1\\n        return\\n      }\\n      val s = word2.charAt(idx) + \"\" + word2.charAt(idx + 1)\\n      if (!values.contains(s)) {\\n        continue = false\\n        return\\n      }\\n      values(s).foreach(id => if (node.chs.contains(_keys(id))) f(idx + 2, node.chs(_keys(id))))\\n\\n    }\\n\\n    f(0, root)\\n    count\\n\\n  }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929920,
                "title": "java-trie-in-40-lines",
                "content": "```\\nprivate static class Node {\\n\\tprivate final String encryptedChar;\\n\\tprivate final Map<String, Node> nexts = new HashMap<>();\\n\\tprivate int wordCount = 0;\\n\\tprivate Node(String encryptedChar) {\\n\\t\\tthis.encryptedChar = encryptedChar;\\n\\t}\\n}\\nprivate final Map<Character, String> forwardMap = new HashMap<>();\\nprivate final Node start = new Node(null);\\npublic Encrypter(char[] keys, String[] values, String[] dictionary) {\\n\\tfor(int i = 0; i < keys.length; i++) {\\n\\t\\tforwardMap.put(keys[i], values[i]);\\n\\t}\\n\\tfor(String word : dictionary) {\\n\\t\\tNode node = start;\\n\\t\\tfor(int i = 0; i<word.length(); i++) {\\n\\t\\t\\tString encryptedChar = forwardMap.get(word.charAt(i));\\n\\t\\t\\tNode nextNode = node.nexts.computeIfAbsent(encryptedChar, key -> new Node(encryptedChar));\\n\\t\\t\\tif(i == word.length() - 1) nextNode.wordCount++;\\n\\t\\t\\tnode = nextNode;\\n\\t\\t}\\n\\t}\\n}\\npublic String encrypt(String word1) {\\n\\tStringBuffer result = new StringBuffer();\\n\\tfor(char c : word1.toCharArray()) result.append(forwardMap.get(c));\\n\\treturn result.toString();\\n}\\npublic int decrypt(String word2) {\\n\\tNode node = start;\\n\\tfor(int i = 0; i<word2.length() / 2; i++) {\\n\\t\\tString encryptedChar = word2.substring(i * 2, i * 2 + 2);\\n\\t\\tnode = node.nexts.get(encryptedChar);\\n\\t\\tif(node == null) return 0;\\n\\t}\\n\\treturn node.wordCount;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nprivate static class Node {\\n\\tprivate final String encryptedChar;\\n\\tprivate final Map<String, Node> nexts = new HashMap<>();\\n\\tprivate int wordCount = 0;\\n\\tprivate Node(String encryptedChar) {\\n\\t\\tthis.encryptedChar = encryptedChar;\\n\\t}\\n}\\nprivate final Map<Character, String> forwardMap = new HashMap<>();\\nprivate final Node start = new Node(null);\\npublic Encrypter(char[] keys, String[] values, String[] dictionary) {\\n\\tfor(int i = 0; i < keys.length; i++) {\\n\\t\\tforwardMap.put(keys[i], values[i]);\\n\\t}\\n\\tfor(String word : dictionary) {\\n\\t\\tNode node = start;\\n\\t\\tfor(int i = 0; i<word.length(); i++) {\\n\\t\\t\\tString encryptedChar = forwardMap.get(word.charAt(i));\\n\\t\\t\\tNode nextNode = node.nexts.computeIfAbsent(encryptedChar, key -> new Node(encryptedChar));\\n\\t\\t\\tif(i == word.length() - 1) nextNode.wordCount++;\\n\\t\\t\\tnode = nextNode;\\n\\t\\t}\\n\\t}\\n}\\npublic String encrypt(String word1) {\\n\\tStringBuffer result = new StringBuffer();\\n\\tfor(char c : word1.toCharArray()) result.append(forwardMap.get(c));\\n\\treturn result.toString();\\n}\\npublic int decrypt(String word2) {\\n\\tNode node = start;\\n\\tfor(int i = 0; i<word2.length() / 2; i++) {\\n\\t\\tString encryptedChar = word2.substring(i * 2, i * 2 + 2);\\n\\t\\tnode = node.nexts.get(encryptedChar);\\n\\t\\tif(node == null) return 0;\\n\\t}\\n\\treturn node.wordCount;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929334,
                "title": "java-sol-2-maps-and-precompute",
                "content": "Approach,\\n1. Make 2 maps\\n2. One for storing <keys[i],values[i]> pairs.\\n3. Second for storing decrypted string frequencies from dictionary array\\n4. While precomputing dictionary array, make sure not to store invalid decrypted strings\\n5. Below is the implementation for the same.\\n```\\nclass Encrypter {\\n    Map<Character,String> en;\\n    Map<String,Integer> deq;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        en = new HashMap<>();\\n        deq = new HashMap<>();\\n        int n = keys.length;\\n        //Encrypt Map\\n        for (int i = 0; i < n; i++) {\\n            en.put(keys[i],values[i]);\\n        }\\n        \\n        // Decrypted Strings from dictionary array\\n        for (String s : dictionary) {\\n            StringBuilder ans = new StringBuilder();\\n            boolean flag = true;\\n            for (char ch : s.toCharArray()) {\\n                if (en.get(ch) == null) {\\n                    flag = false;\\n                    break;\\n                }\\n                ans.append(en.get(ch));\\n            }\\n            String key = ans.toString();\\n            if (key.equals(\"\") || !flag) continue;\\n            deq.put(key,deq.getOrDefault(key,0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder ans = new StringBuilder();\\n        for (char ch : word1.toCharArray()) {\\n            ans.append(en.getOrDefault(ch,\"\"));\\n        }\\n        return ans.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return deq.getOrDefault(word2,0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n    Map<Character,String> en;\\n    Map<String,Integer> deq;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        en = new HashMap<>();\\n        deq = new HashMap<>();\\n        int n = keys.length;\\n        //Encrypt Map\\n        for (int i = 0; i < n; i++) {\\n            en.put(keys[i],values[i]);\\n        }\\n        \\n        // Decrypted Strings from dictionary array\\n        for (String s : dictionary) {\\n            StringBuilder ans = new StringBuilder();\\n            boolean flag = true;\\n            for (char ch : s.toCharArray()) {\\n                if (en.get(ch) == null) {\\n                    flag = false;\\n                    break;\\n                }\\n                ans.append(en.get(ch));\\n            }\\n            String key = ans.toString();\\n            if (key.equals(\"\") || !flag) continue;\\n            deq.put(key,deq.getOrDefault(key,0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder ans = new StringBuilder();\\n        for (char ch : word1.toCharArray()) {\\n            ans.append(en.getOrDefault(ch,\"\"));\\n        }\\n        return ans.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return deq.getOrDefault(word2,0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1928783,
                "title": "c-code-two-hashmap-s-only",
                "content": "```\\nclass Encrypter {\\npublic:\\n    \\n    unordered_map<char,string> m1;\\n    unordered_map<string,int> m2;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& d) {\\n        m1.clear();\\n        m2.clear();\\n        \\n        for(int i=0;i<keys.size();i++){\\n            m1[keys[i]] = values[i];\\n        }\\n        \\n        for(int i=0;i<d.size();i++){\\n            string str = encrypt(d[i]);\\n            \\n            if(str != \"\"){\\n                 m2[str]++;\\n            }\\n           \\n            \\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string str = \"\";\\n        \\n        for(int i=0;i<word1.size();i++){\\n            if(m1.find(word1[i])==m1.end()) return \"\";\\n            str += m1[word1[i]];\\n        }\\n       \\n        return str;\\n        \\n    }\\n    \\n    int decrypt(string word2) {\\n        return m2[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    \\n    unordered_map<char,string> m1;\\n    unordered_map<string,int> m2;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& d) {\\n        m1.clear();\\n        m2.clear();\\n        \\n        for(int i=0;i<keys.size();i++){\\n            m1[keys[i]] = values[i];\\n        }\\n        \\n        for(int i=0;i<d.size();i++){\\n            string str = encrypt(d[i]);\\n            \\n            if(str != \"\"){\\n                 m2[str]++;\\n            }\\n           \\n            \\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string str = \"\";\\n        \\n        for(int i=0;i<word1.size();i++){\\n            if(m1.find(word1[i])==m1.end()) return \"\";\\n            str += m1[word1[i]];\\n        }\\n       \\n        return str;\\n        \\n    }\\n    \\n    int decrypt(string word2) {\\n        return m2[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926771,
                "title": "java-hashmap",
                "content": "```\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\nclass Encrypter {\\n\\n    private String[] dictionary;\\n    private Map<Character, String> charVsStringMap = new HashMap<>();\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.dictionary = dictionary;\\n        for (int i = 0; i < keys.length; i++) {\\n            charVsStringMap.putIfAbsent(keys[i], values[i]);\\n        }\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder stringBuilder = new StringBuilder();\\n        for (char c : word1.toCharArray()) {\\n            stringBuilder.append(charVsStringMap.get(c));\\n        }\\n        return stringBuilder.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        int ans = 0;\\n        for (String str : dictionary) {\\n            String newStr = \"\";\\n\\n            for (char ch : str.toCharArray()) {\\n\\n                if (charVsStringMap.containsKey(ch)) {\\n                    newStr += charVsStringMap.get(ch);\\n\\n                } else {\\n                    newStr = \"\";\\n                    break;\\n                }\\n            }\\n            if (newStr.equals(word2)) {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\nclass Encrypter {\\n\\n    private String[] dictionary;\\n    private Map<Character, String> charVsStringMap = new HashMap<>();\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.dictionary = dictionary;\\n        for (int i = 0; i < keys.length; i++) {\\n            charVsStringMap.putIfAbsent(keys[i], values[i]);\\n        }\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder stringBuilder = new StringBuilder();\\n        for (char c : word1.toCharArray()) {\\n            stringBuilder.append(charVsStringMap.get(c));\\n        }\\n        return stringBuilder.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        int ans = 0;\\n        for (String str : dictionary) {\\n            String newStr = \"\";\\n\\n            for (char ch : str.toCharArray()) {\\n\\n                if (charVsStringMap.containsKey(ch)) {\\n                    newStr += charVsStringMap.get(ch);\\n\\n                } else {\\n                    newStr = \"\";\\n                    break;\\n                }\\n            }\\n            if (newStr.equals(word2)) {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926295,
                "title": "golang-trie",
                "content": "```\\ntype Encrypter struct {\\n    k2v map[byte]string\\n    v2k map[string][]byte\\n    trie *node\\n}\\n\\ntype node struct {\\n    next []*node\\n    end bool\\n}\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n    k2v := make(map[byte]string)\\n    v2k := make(map[string][]byte)\\n    \\n    for i, k := range keys {\\n        k2v[k] = values[i]\\n    }\\n    \\n    for i, v := range values {\\n        v2k[v] = append(v2k[v], keys[i])\\n    }\\n    \\n    trie := &node{\\n        next: make([]*node, 26),\\n        end: false,\\n    }\\n    \\n    for _, w := range dictionary {\\n        cur := trie\\n        for _, r := range w {\\n            if cur.next[r - \\'a\\'] == nil {\\n                cur.next[r - \\'a\\'] = &node{\\n                    next: make([]*node, 26),\\n                    end: false,\\n                }\\n            }\\n            cur = cur.next[r - \\'a\\']\\n        }\\n        cur.end = true\\n    }\\n    \\n    return Encrypter{\\n        k2v: k2v,\\n        v2k: v2k,\\n        trie: trie,\\n    }    \\n}\\n\\n\\nfunc (this *Encrypter) Encrypt(word1 string) string {\\n    var res bytes.Buffer\\n    for i := 0; i < len(word1); i++ {\\n        res.WriteString(this.k2v[word1[i]])\\n    }\\n    return res.String()\\n}\\n\\n\\nfunc (this *Encrypter) Decrypt(word2 string) int {\\n    return this.dfs(word2)\\n}\\n\\nfunc (this *Encrypter) dfs(word2 string) int {\\n    if len(word2) == 0 {\\n        if this.trie.end {\\n            return 1\\n        } else {\\n            return 0\\n        }\\n    }\\n    \\n    res := 0\\n    for _, b := range this.v2k[word2[:2]] {\\n        if this.trie.next[b - \\'a\\'] != nil {\\n            tmp := this.trie\\n            this.trie = this.trie.next[b - \\'a\\']\\n            res += this.dfs(word2[2:])\\n            this.trie = tmp\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype Encrypter struct {\\n    k2v map[byte]string\\n    v2k map[string][]byte\\n    trie *node\\n}\\n\\ntype node struct {\\n    next []*node\\n    end bool\\n}\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n    k2v := make(map[byte]string)\\n    v2k := make(map[string][]byte)\\n    \\n    for i, k := range keys {\\n        k2v[k] = values[i]\\n    }\\n    \\n    for i, v := range values {\\n        v2k[v] = append(v2k[v], keys[i])\\n    }\\n    \\n    trie := &node{\\n        next: make([]*node, 26),\\n        end: false,\\n    }\\n    \\n    for _, w := range dictionary {\\n        cur := trie\\n        for _, r := range w {\\n            if cur.next[r - \\'a\\'] == nil {\\n                cur.next[r - \\'a\\'] = &node{\\n                    next: make([]*node, 26),\\n                    end: false,\\n                }\\n            }\\n            cur = cur.next[r - \\'a\\']\\n        }\\n        cur.end = true\\n    }\\n    \\n    return Encrypter{\\n        k2v: k2v,\\n        v2k: v2k,\\n        trie: trie,\\n    }    \\n}\\n\\n\\nfunc (this *Encrypter) Encrypt(word1 string) string {\\n    var res bytes.Buffer\\n    for i := 0; i < len(word1); i++ {\\n        res.WriteString(this.k2v[word1[i]])\\n    }\\n    return res.String()\\n}\\n\\n\\nfunc (this *Encrypter) Decrypt(word2 string) int {\\n    return this.dfs(word2)\\n}\\n\\nfunc (this *Encrypter) dfs(word2 string) int {\\n    if len(word2) == 0 {\\n        if this.trie.end {\\n            return 1\\n        } else {\\n            return 0\\n        }\\n    }\\n    \\n    res := 0\\n    for _, b := range this.v2k[word2[:2]] {\\n        if this.trie.next[b - \\'a\\'] != nil {\\n            tmp := this.trie\\n            this.trie = this.trie.next[b - \\'a\\']\\n            res += this.dfs(word2[2:])\\n            this.trie = tmp\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1925491,
                "title": "java-trie-dfs-hashmaps",
                "content": "Runtime: 970 ms, faster than 27.23% of Java online submissions for Encrypt and Decrypt Strings.\\nMemory Usage: 509.4 MB, less than 5.06% of Java online submissions for Encrypt and Decrypt Strings.\\n```\\nclass Encrypter {\\n  class Node{                                            //class for each node in Trie\\n    public Node[] p;                                     //array all neigbours    \\n    public boolean eow;                                  //mark for end of word\\n    \\n    Node (){\\n      p = new Node[26];                                  //whan we construct node\\n      for(int i = 0; i != 26; i++) p[i] = null;          //we inicialize all neigbours as \"null\"  \\n      eow = false;                                       //and check our mark for end of word as false\\n    }\\n  }\\n  public Node root;                                      //root of Trie\\n    \\n  public void insert(String w) { \\n    Node n = root;                                       //node for traversal through Trie\\n    for(int i = 0; i < w.length(); i++){                 \\n      int id = (int)(w.charAt(i) - \\'a\\');                 //fetch current letter from word and calculate index for it\\n      \\n      if(n.p[id] != null) n = n.p[id];                   //if this letter is presented in table move to next\\n      else                                               //if not \\n        for(; i != w.length(); i++){                     //create new nodes\\n          id = (int)(w.charAt(i) - \\'a\\');\\n          n.p[id] = new Node();\\n          n = n.p[id];\\n        }\\n    }\\n    n.eow = true;                                        //check last node as end of word\\n  }\\n      \\n  Map<Character, String> en;                             //for encoding strings\\n  Map<String, List<Integer>> de;                         //{string, list of indexes of letters with this string} \\n  Map<String, Integer> answeres;                         //for coinciding enquiries\\n  int ans;                                               //for counting all possibilities for each enquiry \\n  \\n  public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n    en = new HashMap<>();\\n    de = new HashMap<>();\\n    answeres = new HashMap<>();\\n    root = new Node();                                   //construct new Trie\\n    root.eow = true;                                     //and put string \"\"\\n  \\n    \\n    for(int i = 0; i != keys.length; i++){               //fill our hashmaps\\n      en.put(keys[i], values[i]);\\n      if(!de.containsKey(values[i])){\\n        List<Integer> list = new ArrayList<>();\\n        de.put(values[i], list);\\n      }\\n      de.get(values[i]).add(keys[i] - \\'a\\');\\n    }\\n    \\n    for(int i = 0; i != dictionary.length; i++)          //and construct Trie\\n      insert(dictionary[i]);\\n  }\\n    \\n  public String encrypt(String word1) {                  //construct answer\\n    String ans = \"\";\\n    for(int i = 0; i != word1.length(); i++)\\n      ans += en.get(word1.charAt(i));\\n    \\n    return ans;\\n  }\\n    \\n  public int decrypt(String word2) {\\n    if(answeres.containsKey(word2)) return answeres.get(word2);   //if we already have this inquiry\\n    \\n    ans = 0;                                                      //refrash counter of all possibilities\\n    dfs(0, root, word2);                                          //dfs\\n    answeres.put(word2, ans);                                     //put this answer for next inquiries\\n    \\n    return ans;   \\n  }\\n  \\n  public void dfs(int i, Node node, String w){                    //dfs\\n    String key = w.substring(i, i + 2);                           //fetch current substring\\n    if(de.containsKey(key))                                       //if we have keys for this substring\\n      for(int j = 0; j != de.get(key).size(); j++)                //try to move through Trie\\n        if( node.p[de.get(key).get(j)] != null) {                 //if we dont have node in Trie\\n          if(i + 2 == w.length()){                             //if we reach end of current word\\n            if(node.p[de.get(key).get(j)].eow == true) ans++;     //check : have we this word in Trie?\\n          }\\n          else dfs(i+2, node.p[de.get(key).get(j)], w);        //if we dont reach\\n    }\\n  }\\n  \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n  class Node{                                            //class for each node in Trie\\n    public Node[] p;                                     //array all neigbours    \\n    public boolean eow;                                  //mark for end of word\\n    \\n    Node (){\\n      p = new Node[26];                                  //whan we construct node\\n      for(int i = 0; i != 26; i++) p[i] = null;          //we inicialize all neigbours as \"null\"  \\n      eow = false;                                       //and check our mark for end of word as false\\n    }\\n  }\\n  public Node root;                                      //root of Trie\\n    \\n  public void insert(String w) { \\n    Node n = root;                                       //node for traversal through Trie\\n    for(int i = 0; i < w.length(); i++){                 \\n      int id = (int)(w.charAt(i) - \\'a\\');                 //fetch current letter from word and calculate index for it\\n      \\n      if(n.p[id] != null) n = n.p[id];                   //if this letter is presented in table move to next\\n      else                                               //if not \\n        for(; i != w.length(); i++){                     //create new nodes\\n          id = (int)(w.charAt(i) - \\'a\\');\\n          n.p[id] = new Node();\\n          n = n.p[id];\\n        }\\n    }\\n    n.eow = true;                                        //check last node as end of word\\n  }\\n      \\n  Map<Character, String> en;                             //for encoding strings\\n  Map<String, List<Integer>> de;                         //{string, list of indexes of letters with this string} \\n  Map<String, Integer> answeres;                         //for coinciding enquiries\\n  int ans;                                               //for counting all possibilities for each enquiry \\n  \\n  public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n    en = new HashMap<>();\\n    de = new HashMap<>();\\n    answeres = new HashMap<>();\\n    root = new Node();                                   //construct new Trie\\n    root.eow = true;                                     //and put string \"\"\\n  \\n    \\n    for(int i = 0; i != keys.length; i++){               //fill our hashmaps\\n      en.put(keys[i], values[i]);\\n      if(!de.containsKey(values[i])){\\n        List<Integer> list = new ArrayList<>();\\n        de.put(values[i], list);\\n      }\\n      de.get(values[i]).add(keys[i] - \\'a\\');\\n    }\\n    \\n    for(int i = 0; i != dictionary.length; i++)          //and construct Trie\\n      insert(dictionary[i]);\\n  }\\n    \\n  public String encrypt(String word1) {                  //construct answer\\n    String ans = \"\";\\n    for(int i = 0; i != word1.length(); i++)\\n      ans += en.get(word1.charAt(i));\\n    \\n    return ans;\\n  }\\n    \\n  public int decrypt(String word2) {\\n    if(answeres.containsKey(word2)) return answeres.get(word2);   //if we already have this inquiry\\n    \\n    ans = 0;                                                      //refrash counter of all possibilities\\n    dfs(0, root, word2);                                          //dfs\\n    answeres.put(word2, ans);                                     //put this answer for next inquiries\\n    \\n    return ans;   \\n  }\\n  \\n  public void dfs(int i, Node node, String w){                    //dfs\\n    String key = w.substring(i, i + 2);                           //fetch current substring\\n    if(de.containsKey(key))                                       //if we have keys for this substring\\n      for(int j = 0; j != de.get(key).size(); j++)                //try to move through Trie\\n        if( node.p[de.get(key).get(j)] != null) {                 //if we dont have node in Trie\\n          if(i + 2 == w.length()){                             //if we reach end of current word\\n            if(node.p[de.get(key).get(j)].eow == true) ans++;     //check : have we this word in Trie?\\n          }\\n          else dfs(i+2, node.p[de.get(key).get(j)], w);        //if we dont reach\\n    }\\n  }\\n  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1924906,
                "title": "python-solution-with-explanation",
                "content": "I refrain from using \"+\" operator to concatenate strings in the encrypt method because that would give us the O(word1)**2 squared complexity since strings are immutable and we are basically copying everything to a new string every time. So it would be more efficient and apt to use \"join\" statement as it would cost us just O(word1) time.\\n\\nPlease let me know in the comments if something is not clear.\\n\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        \\n        self.mapping = defaultdict(str)\\n        \\n\\t\\t#mapping each key to its respective value\\n        for x, y in zip(keys, values): \\n            self.mapping[x] = y            \\n            \\n        self.frequency = defaultdict(int)\\n        \\n\\t\\t#encrpting every worder by function calling and updating \\n\\t\\t#how many times the encrypted sequene occurs\\n        for word in dictionary:\\n            self.frequency[self.encrypt(word)] += 1  \\n        \\n  \\n    def encrypt(self, word1: str) -> str:\\n\\t    #Using list. So that it would be efficient to concatenate it at the end using join.\\n        res = [] \\n        \\n        for c in word1:\\n            if c in self.mapping:\\n                res.append(self.mapping[c])\\n            else:\\n                return \\'\\' \\n\\t\\t\\t\\t# #it\\'s important that even if one charecter is missing, we should\\n\\t\\t\\t\\t#return an empty string or else it would give wrong output\\n\\t\\t\\t\\t\\n        return \"\".join(res)  \\n        \\n\\t\\t\\n    def decrypt(self, word2: str) -> int:\\n\\t\\n\\t    #return the frequency of the encrypted sequence\\n        return self.frequency[word2]\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "I refrain from using \"+\" operator to concatenate strings in the encrypt method because that would give us the O(word1)**2 squared complexity since strings are immutable and we are basically copying everything to a new string every time. So it would be more efficient and apt to use \"join\" statement as it would cost us just O(word1) time.\\n\\nPlease let me know in the comments if something is not clear.\\n\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        \\n        self.mapping = defaultdict(str)\\n        \\n\\t\\t#mapping each key to its respective value\\n        for x, y in zip(keys, values): \\n            self.mapping[x] = y            \\n            \\n        self.frequency = defaultdict(int)\\n        \\n\\t\\t#encrpting every worder by function calling and updating \\n\\t\\t#how many times the encrypted sequene occurs\\n        for word in dictionary:\\n            self.frequency[self.encrypt(word)] += 1  \\n        \\n  \\n    def encrypt(self, word1: str) -> str:\\n\\t    #Using list. So that it would be efficient to concatenate it at the end using join.\\n        res = [] \\n        \\n        for c in word1:\\n            if c in self.mapping:\\n                res.append(self.mapping[c])\\n            else:\\n                return \\'\\' \\n\\t\\t\\t\\t# #it\\'s important that even if one charecter is missing, we should\\n\\t\\t\\t\\t#return an empty string or else it would give wrong output\\n\\t\\t\\t\\t\\n        return \"\".join(res)  \\n        \\n\\t\\t\\n    def decrypt(self, word2: str) -> int:\\n\\t\\n\\t    #return the frequency of the encrypted sequence\\n        return self.frequency[word2]\\n",
                "codeTag": "Java"
            },
            {
                "id": 1920939,
                "title": "swift-hash-map-solution",
                "content": "```\\n\\nclass Encrypter {\\n\\n    var dict = [Character: String]()\\n    var map = [String: [String]]()\\n\\n    init(_ keys: [Character], _ values: [String], _ dictionary: [String]) {\\n        let count = keys.count\\n\\n        for i in 0..<count {\\n            dict[keys[i]] = values[i]\\n        }\\n        \\n        for i in dictionary {\\n          map[encrypt(i), default: []].append(i)   \\n        }\\n    }\\n    \\n    func encrypt(_ word1: String) -> String {\\n        var res = \"\"\\n    \\n        for i in word1 {\\n            if let val = dict[i] {\\n                res += val\\n            } else { return \"\" }\\n        }\\n        \\n        return res\\n    }\\n    \\n    func decrypt(_ word2: String) -> Int {\\n        return map[word2, default: []].count     \\n    }\\n}",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\n\\nclass Encrypter {\\n\\n    var dict = [Character: String]()\\n    var map = [String: [String]]()\\n\\n    init(_ keys: [Character], _ values: [String], _ dictionary: [String]) {\\n        let count = keys.count\\n\\n        for i in 0..<count {\\n            dict[keys[i]] = values[i]\\n        }\\n        \\n        for i in dictionary {\\n          map[encrypt(i), default: []].append(i)   \\n        }\\n    }\\n    \\n    func encrypt(_ word1: String) -> String {\\n        var res = \"\"\\n    \\n        for i in word1 {\\n            if let val = dict[i] {\\n                res += val\\n            } else { return \"\" }\\n        }\\n        \\n        return res\\n    }\\n    \\n    func decrypt(_ word2: String) -> Int {\\n        return map[word2, default: []].count     \\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1920424,
                "title": "cpp-simple-and-clean-code",
                "content": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char, string> hsh;\\n    unordered_map<string, int> box;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0;i<keys.size();i++){\\n            hsh[keys[i]] = values[i];\\n        }\\n        for(string&s: dictionary){\\n            box[encrypt(s)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(char c: word1){\\n            if(hsh.find(c) != hsh.end()) ans += hsh[c];\\n            else ans.push_back(\\'.\\');\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    int decrypt(string word2) {\\n        return box[word2];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char, string> hsh;\\n    unordered_map<string, int> box;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0;i<keys.size();i++){\\n            hsh[keys[i]] = values[i];\\n        }\\n        for(string&s: dictionary){\\n            box[encrypt(s)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(char c: word1){\\n            if(hsh.find(c) != hsh.end()) ans += hsh[c];\\n            else ans.push_back(\\'.\\');\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    int decrypt(string word2) {\\n        return box[word2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920343,
                "title": "golang-hash-solution",
                "content": "```go\\n// AC\\nimport \"strings\"\\n\\ntype Encrypter struct {\\n\\tencryptMap    map[string]string\\n\\tresultCounter map[string]int\\n}\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n\\tencryptMap := make(map[string]string)\\n\\tfor i, v := range keys {\\n\\t\\tencryptMap[string(v)] = values[i]\\n\\t}\\n\\tresultCounter := make(map[string]int)\\n\\tfor _, v := range dictionary {\\n\\t\\tencrypted := encryptHelper(v, encryptMap)\\n\\t\\tif len(encrypted) == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tresultCounter[encrypted]++\\n\\t}\\n\\treturn Encrypter{\\n\\t\\tencryptMap:    encryptMap,\\n\\t\\tresultCounter: resultCounter,\\n\\t}\\n}\\n\\nfunc (e *Encrypter) Encrypt(word1 string) string {\\n\\treturn encryptHelper(word1, e.encryptMap)\\n}\\n\\nfunc encryptHelper(word string, encryptMap map[string]string) string {\\n\\tsb := strings.Builder{}\\n\\tfor _, v := range word {\\n\\t\\tif len(encryptMap[string(v)]) == 0 {\\n\\t\\t\\treturn \"\"\\n\\t\\t}\\n\\t\\tsb.WriteString(encryptMap[string(v)])\\n\\t}\\n\\treturn sb.String()\\n}\\n\\nfunc (e *Encrypter) Decrypt(word2 string) int {\\n\\treturn e.resultCounter[word2]\\n}\\n```\\n\\n```go\\n// TLE :(\\nimport \"strings\"\\n\\ntype Encrypter struct {\\n\\tdictionary map[int]map[string]bool\\n\\tencryptMap map[string]string\\n\\tdecryptMap map[string][]string\\n}\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n\\tdictionaryHelper := make(map[int]map[string]bool)\\n\\tfor _, v := range dictionary {\\n\\t\\tif dictionaryHelper[len(v)] == nil {\\n\\t\\t\\tdictionaryHelper[len(v)] = make(map[string]bool)\\n\\t\\t}\\n\\t\\tfor i := 1; i <= len(v); i++ {\\n\\t\\t\\tdictionaryHelper[len(v)][v[:i]] = true\\n\\t\\t}\\n\\t}\\n\\tencryptMap := make(map[string]string)\\n\\tdecryptMap := make(map[string][]string)\\n\\tfor i, v := range keys {\\n\\t\\tencryptMap[string(v)] = values[i]\\n\\t\\tdecryptMap[values[i]] = append(decryptMap[values[i]], string(v))\\n\\t}\\n\\treturn Encrypter{\\n\\t\\tdictionary: dictionaryHelper,\\n\\t\\tencryptMap: encryptMap,\\n\\t\\tdecryptMap: decryptMap,\\n\\t}\\n}\\n\\nfunc (e *Encrypter) Encrypt(word1 string) string {\\n\\tsb := strings.Builder{}\\n\\tfor _, v := range word1 {\\n\\t\\tsb.WriteString(e.encryptMap[string(v)])\\n\\t}\\n\\treturn sb.String()\\n}\\n\\nfunc (e *Encrypter) Decrypt(word2 string) int {\\n\\tdictionary := e.dictionary[len(word2)/2]\\n\\tcurrent := make([]string, 0, len(e.decryptMap[word2[:2]]))\\n\\tfor _, v := range e.decryptMap[word2[:2]] {\\n\\t\\tif dictionary[v] == true {\\n\\t\\t\\tcurrent = append(current, v)\\n\\t\\t}\\n\\t}\\n\\tfor i := 2; i < len(word2) && len(current) > 0; i += 2 {\\n\\t\\talphas := e.decryptMap[word2[i:i+2]]\\n\\t\\tnext := make([]string, 0, len(current))\\n\\t\\tfor _, alpha := range alphas {\\n\\t\\t\\tfor _, pre := range current {\\n\\t\\t\\t\\tnewWord := pre + alpha\\n\\t\\t\\t\\tif dictionary[newWord] == true {\\n\\t\\t\\t\\t\\tnext = append(next, newWord)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcurrent = next\\n\\t}\\n\\treturn len(current)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\n// AC\\nimport \"strings\"\\n\\ntype Encrypter struct {\\n\\tencryptMap    map[string]string\\n\\tresultCounter map[string]int\\n}\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n\\tencryptMap := make(map[string]string)\\n\\tfor i, v := range keys {\\n\\t\\tencryptMap[string(v)] = values[i]\\n\\t}\\n\\tresultCounter := make(map[string]int)\\n\\tfor _, v := range dictionary {\\n\\t\\tencrypted := encryptHelper(v, encryptMap)\\n\\t\\tif len(encrypted) == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tresultCounter[encrypted]++\\n\\t}\\n\\treturn Encrypter{\\n\\t\\tencryptMap:    encryptMap,\\n\\t\\tresultCounter: resultCounter,\\n\\t}\\n}\\n\\nfunc (e *Encrypter) Encrypt(word1 string) string {\\n\\treturn encryptHelper(word1, e.encryptMap)\\n}\\n\\nfunc encryptHelper(word string, encryptMap map[string]string) string {\\n\\tsb := strings.Builder{}\\n\\tfor _, v := range word {\\n\\t\\tif len(encryptMap[string(v)]) == 0 {\\n\\t\\t\\treturn \"\"\\n\\t\\t}\\n\\t\\tsb.WriteString(encryptMap[string(v)])\\n\\t}\\n\\treturn sb.String()\\n}\\n\\nfunc (e *Encrypter) Decrypt(word2 string) int {\\n\\treturn e.resultCounter[word2]\\n}\\n```\n```go\\n// TLE :(\\nimport \"strings\"\\n\\ntype Encrypter struct {\\n\\tdictionary map[int]map[string]bool\\n\\tencryptMap map[string]string\\n\\tdecryptMap map[string][]string\\n}\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n\\tdictionaryHelper := make(map[int]map[string]bool)\\n\\tfor _, v := range dictionary {\\n\\t\\tif dictionaryHelper[len(v)] == nil {\\n\\t\\t\\tdictionaryHelper[len(v)] = make(map[string]bool)\\n\\t\\t}\\n\\t\\tfor i := 1; i <= len(v); i++ {\\n\\t\\t\\tdictionaryHelper[len(v)][v[:i]] = true\\n\\t\\t}\\n\\t}\\n\\tencryptMap := make(map[string]string)\\n\\tdecryptMap := make(map[string][]string)\\n\\tfor i, v := range keys {\\n\\t\\tencryptMap[string(v)] = values[i]\\n\\t\\tdecryptMap[values[i]] = append(decryptMap[values[i]], string(v))\\n\\t}\\n\\treturn Encrypter{\\n\\t\\tdictionary: dictionaryHelper,\\n\\t\\tencryptMap: encryptMap,\\n\\t\\tdecryptMap: decryptMap,\\n\\t}\\n}\\n\\nfunc (e *Encrypter) Encrypt(word1 string) string {\\n\\tsb := strings.Builder{}\\n\\tfor _, v := range word1 {\\n\\t\\tsb.WriteString(e.encryptMap[string(v)])\\n\\t}\\n\\treturn sb.String()\\n}\\n\\nfunc (e *Encrypter) Decrypt(word2 string) int {\\n\\tdictionary := e.dictionary[len(word2)/2]\\n\\tcurrent := make([]string, 0, len(e.decryptMap[word2[:2]]))\\n\\tfor _, v := range e.decryptMap[word2[:2]] {\\n\\t\\tif dictionary[v] == true {\\n\\t\\t\\tcurrent = append(current, v)\\n\\t\\t}\\n\\t}\\n\\tfor i := 2; i < len(word2) && len(current) > 0; i += 2 {\\n\\t\\talphas := e.decryptMap[word2[i:i+2]]\\n\\t\\tnext := make([]string, 0, len(current))\\n\\t\\tfor _, alpha := range alphas {\\n\\t\\t\\tfor _, pre := range current {\\n\\t\\t\\t\\tnewWord := pre + alpha\\n\\t\\t\\t\\tif dictionary[newWord] == true {\\n\\t\\t\\t\\t\\tnext = append(next, newWord)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcurrent = next\\n\\t}\\n\\treturn len(current)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1915872,
                "title": "using-zip-and-dict-in-python",
                "content": "class Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.d = defaultdict(int)\\n        self.m = {}\\n        for i, j in zip(keys, values):\\n            self.m[i] = j\\n        print(self.m)\\n        for i in dictionary:\\n            l = []\\n            for x in i:\\n                l.append(self.m[x])\\n            print(l)\\n            self.d[\\'\\'.join(l)] += 1\\n        print(self.d)\\n\\n    def encrypt(self, word1: str) -> str:\\n        l = []\\n        for x in word1:\\n            l.append(self.m[x])\\n        return \\'\\'.join(l)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.d[word2]",
                "solutionTags": [],
                "code": "class Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.d = defaultdict(int)\\n        self.m = {}\\n        for i, j in zip(keys, values):\\n            self.m[i] = j\\n        print(self.m)\\n        for i in dictionary:\\n            l = []\\n            for x in i:\\n                l.append(self.m[x])\\n            print(l)\\n            self.d[\\'\\'.join(l)] += 1\\n        print(self.d)\\n\\n    def encrypt(self, word1: str) -> str:\\n        l = []\\n        for x in word1:\\n            l.append(self.m[x])\\n        return \\'\\'.join(l)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.d[word2]",
                "codeTag": "Java"
            },
            {
                "id": 1915670,
                "title": "rust-hashmap-hashset-search-from-dic-word-o-n",
                "content": "```\\nuse std::collections::{HashMap, HashSet};\\nstruct Encrypter {\\n    ci: HashMap<char, usize>,\\n    vi: HashMap<String, HashSet<usize>>,\\n    values: Vec<String>,\\n    dic: Vec<String>,\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl Encrypter {\\n\\n    fn new(keys: Vec<char>, values: Vec<String>, dictionary: Vec<String>) -> Self {\\n        let mut ci = HashMap::new();\\n        let mut vi = HashMap::new();\\n        for (i, &c) in keys.iter().enumerate() {\\n            ci.insert(c, i);\\n        }\\n        for (i, v) in values.iter().enumerate() {\\n            let list = vi.entry(v.to_string()).or_insert(HashSet::new());\\n            list.insert(i);\\n        }\\n        \\n        // println!(\"ci {:?}\\\\n vi {:#?}\\\\n\", ci, vi);\\n        \\n        Encrypter {\\n            ci,\\n            vi,\\n            values,\\n            dic: dictionary,\\n        }\\n        \\n    }\\n    \\n    fn encrypt(&self, word1: String) -> String {\\n        let mut ans = \"\".to_owned();\\n        for c in word1.chars() {\\n            let i = self.ci[&c];\\n            let v = &self.values[i][..];\\n            ans.push_str(v);\\n        }\\n        ans\\n    }\\n    \\n    fn decrypt(&self, word2: String) -> i32 {\\n        let mut cnt = 0;\\n        let mut conn:Vec<&HashSet<usize>> = vec![];\\n        let n = word2.len()/2;\\n        for i in 0..n {\\n            let sub = &word2[i*2..i*2+2];\\n            // println!(\"sub {}\", sub);\\n            if !self.vi.contains_key(sub) {\\n                return 0;\\n            }\\n            let ids = &self.vi[sub];\\n            conn.push(ids);\\n        }\\n        // println!(\"conn {:?}\", conn);\\n        \\'dic_loop: for word in self.dic.iter() {\\n            if word.len() != n {\\n                continue\\n            }\\n            for (i, c) in word.chars().enumerate() {\\n                if !self.ci.contains_key(&c) {\\n                    continue \\'dic_loop;\\n                }\\n                let ids = &conn[i];\\n                let id = self.ci[&c];\\n                if !ids.contains(&id) {\\n                    continue \\'dic_loop;\\n                }\\n            }\\n            cnt += 1;\\n        }\\n        \\n        cnt\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::{HashMap, HashSet};\\nstruct Encrypter {\\n    ci: HashMap<char, usize>,\\n    vi: HashMap<String, HashSet<usize>>,\\n    values: Vec<String>,\\n    dic: Vec<String>,\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl Encrypter {\\n\\n    fn new(keys: Vec<char>, values: Vec<String>, dictionary: Vec<String>) -> Self {\\n        let mut ci = HashMap::new();\\n        let mut vi = HashMap::new();\\n        for (i, &c) in keys.iter().enumerate() {\\n            ci.insert(c, i);\\n        }\\n        for (i, v) in values.iter().enumerate() {\\n            let list = vi.entry(v.to_string()).or_insert(HashSet::new());\\n            list.insert(i);\\n        }\\n        \\n        // println!(\"ci {:?}\\\\n vi {:#?}\\\\n\", ci, vi);\\n        \\n        Encrypter {\\n            ci,\\n            vi,\\n            values,\\n            dic: dictionary,\\n        }\\n        \\n    }\\n    \\n    fn encrypt(&self, word1: String) -> String {\\n        let mut ans = \"\".to_owned();\\n        for c in word1.chars() {\\n            let i = self.ci[&c];\\n            let v = &self.values[i][..];\\n            ans.push_str(v);\\n        }\\n        ans\\n    }\\n    \\n    fn decrypt(&self, word2: String) -> i32 {\\n        let mut cnt = 0;\\n        let mut conn:Vec<&HashSet<usize>> = vec![];\\n        let n = word2.len()/2;\\n        for i in 0..n {\\n            let sub = &word2[i*2..i*2+2];\\n            // println!(\"sub {}\", sub);\\n            if !self.vi.contains_key(sub) {\\n                return 0;\\n            }\\n            let ids = &self.vi[sub];\\n            conn.push(ids);\\n        }\\n        // println!(\"conn {:?}\", conn);\\n        \\'dic_loop: for word in self.dic.iter() {\\n            if word.len() != n {\\n                continue\\n            }\\n            for (i, c) in word.chars().enumerate() {\\n                if !self.ci.contains_key(&c) {\\n                    continue \\'dic_loop;\\n                }\\n                let ids = &conn[i];\\n                let id = self.ci[&c];\\n                if !ids.contains(&id) {\\n                    continue \\'dic_loop;\\n                }\\n            }\\n            cnt += 1;\\n        }\\n        \\n        cnt\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1914609,
                "title": "c-solution",
                "content": "```\\nclass Encrypter {\\npublic:\\n    map<char,string>em;\\n    map<string,set<char>>dm;\\n    set<string>words;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dic)     {\\n       for(int i=0;i<keys.size();i++)\\n       {\\n           em[keys[i]]=values[i];\\n           dm[values[i]].insert(keys[i]);\\n       }\\n        for(auto it:dic) words.insert(it);\\n    }\\n    \\n    string encrypt(string w1) {\\n       string s;\\n        for(auto it:w1) s+=em[it];\\n        return s;\\n    }\\n    \\n    int decrypt(string w2) {\\n        int tc=0;\\n        for(auto it:words)\\n        {\\n            if(encrypt(it)==w2) tc++;\\n        }\\n        return tc;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    map<char,string>em;\\n    map<string,set<char>>dm;\\n    set<string>words;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dic)     {\\n       for(int i=0;i<keys.size();i++)\\n       {\\n           em[keys[i]]=values[i];\\n           dm[values[i]].insert(keys[i]);\\n       }\\n        for(auto it:dic) words.insert(it);\\n    }\\n    \\n    string encrypt(string w1) {\\n       string s;\\n        for(auto it:w1) s+=em[it];\\n        return s;\\n    }\\n    \\n    int decrypt(string w2) {\\n        int tc=0;\\n        for(auto it:words)\\n        {\\n            if(encrypt(it)==w2) tc++;\\n        }\\n        return tc;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1913855,
                "title": "using-hashmap-java",
                "content": "\\n     class Encrypter {\\n        Map<Character,String> m=new HashMap<>();\\n    String dictionary1[];\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int i=0;i<keys.length;i++){\\n            m.put(keys[i],values[i]);\\n        }\\n        dictionary1=new String[dictionary.length];\\n        int i=0;\\n        for(String x:dictionary){\\n            dictionary1[i++]=x;\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String x=\"\";\\n        for(char c:word1.toCharArray()){\\n            if(m.containsKey(c)){\\n                x+=m.get(c);\\n            }\\n        }\\n        return x;\\n    }\\n    \\n    public int decrypt(String word2) {\\n        int c1=0;\\n        for(String x:dictionary1){\\n           String x1=\"\";\\n            for(char c:x.toCharArray()){\\n                if(m.containsKey(c)){\\n                    x1+=m.get(c);\\n                }\\n            }\\n            if(word2.equals(x1))c1++;\\n        }\\n        return c1;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "\\n     class Encrypter {\\n        Map<Character,String> m=new HashMap<>();\\n    String dictionary1[];\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int i=0;i<keys.length;i++){\\n            m.put(keys[i],values[i]);\\n        }\\n        dictionary1=new String[dictionary.length];\\n        int i=0;\\n        for(String x:dictionary){\\n            dictionary1[i++]=x;\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String x=\"\";\\n        for(char c:word1.toCharArray()){\\n            if(m.containsKey(c)){\\n                x+=m.get(c);\\n            }\\n        }\\n        return x;\\n    }\\n    \\n    public int decrypt(String word2) {\\n        int c1=0;\\n        for(String x:dictionary1){\\n           String x1=\"\";\\n            for(char c:x.toCharArray()){\\n                if(m.containsKey(c)){\\n                    x1+=m.get(c);\\n                }\\n            }\\n            if(word2.equals(x1))c1++;\\n        }\\n        return c1;\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 1913315,
                "title": "c-solution-using-trie",
                "content": "\\tclass Encrypter {\\n\\tpublic:\\n\\t\\tclass node{\\n\\t\\t\\tpublic:\\n\\t\\t\\tnode* next[26];\\n\\t\\t\\tbool isend;\\n\\t\\t\\tnode(){\\n\\t\\t\\t\\tfor(int i=0; i<26; i++){\\n\\t\\t\\t\\t\\tnext[i] = nullptr;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tisend = false;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tclass Trie {\\n\\t\\tpublic:\\n\\n\\t\\t\\tnode* root = new node;\\n\\t\\t\\tvoid insert(string word) {\\n\\t\\t\\t\\tnode* temp = root;\\n\\t\\t\\t\\tfor(int i=0; i<word.size(); i++){\\n\\t\\t\\t\\t\\tchar c = word[i];\\n\\t\\t\\t\\t\\tif(temp->next[c - \\'a\\'] == nullptr) temp->next[c-\\'a\\'] = new node;\\n\\t\\t\\t\\t\\ttemp = temp->next[c-\\'a\\'];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttemp->isend = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tbool search(string word) {\\n\\t\\t\\t\\tnode* temp = root;\\n\\t\\t\\t\\tfor(int i=0; i<word.size(); i++){\\n\\t\\t\\t\\t\\tchar c = word[i];\\n\\t\\t\\t\\t\\tif(temp->next[c - \\'a\\'] == nullptr) return false;;\\n\\t\\t\\t\\t\\ttemp = temp->next[c-\\'a\\'];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn temp->isend;\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\t\\tTrie t;\\n\\t\\tunordered_map<char,string> mp;\\n\\t\\tunordered_map<string, vector<char>> rmp;\\n\\t\\tunordered_map<string , bool> vis;\\n\\t\\tEncrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n\\t\\t\\tfor(int i=0; i<keys.size(); i++){\\n\\t\\t\\t\\tmp[keys[i]] = values[i];\\n\\t\\t\\t\\trmp[values[i]].push_back(keys[i]);\\n\\t\\t\\t}\\n\\t\\t\\tfor(auto &w : dictionary){\\n\\t\\t\\t\\tvis[w] = true;\\n\\t\\t\\t\\tt.insert(w);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tstring encrypt(string word1) {\\n\\t\\t\\tstring str = \"\";\\n\\t\\t\\tfor(auto &c : word1){\\n\\t\\t\\t\\tstr += mp[c];\\n\\t\\t\\t}\\n\\t\\t\\treturn str;\\n\\t\\t}\\n\\t\\tint solve(int i, vector<vector<char>> &vt, node* temp){\\n\\t\\t\\tif(i == vt.size()){\\n\\t\\t\\t\\tif(temp->isend) return 1;\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tfor(int j=0; j<vt[i].size(); j++){\\n\\t\\t\\t\\tif(temp->next[vt[i][j] - \\'a\\'] != NULL){\\n\\t\\t\\t\\t\\tans += solve(i+1, vt, temp->next[vt[i][j] - \\'a\\']);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\n\\t\\t}\\n\\t\\tint decrypt(string word2) {\\n\\t\\t\\tint n = word2.size();\\n\\t\\t\\tvector<vector<char>> vt;\\n\\t\\t\\tvector<char> prev;\\n\\t\\t\\tif(n &1) return 0;\\n\\t\\t\\tfor(int i=0; i<n; i+=2){\\n\\t\\t\\t\\tstring str = \"\";\\n\\t\\t\\t\\tstr += word2[i];\\n\\t\\t\\t\\tstr += word2[i+1];\\n\\t\\t\\t\\tif(rmp.count(str) == 0) return 0;\\n\\t\\t\\t\\tvt.push_back(rmp[str]);\\n\\t\\t\\t}\\n\\t\\t\\tnode* temp = t.root;\\n\\t\\t\\tint ans = solve(0, vt, temp);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Your Encrypter object will be instantiated and called as such:\\n\\t * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n\\t * string param_1 = obj->encrypt(word1);\\n\\t * int param_2 = obj->decrypt(word2);\\n\\t */",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "\\tclass Encrypter {\\n\\tpublic:\\n\\t\\tclass node{\\n\\t\\t\\tpublic:\\n\\t\\t\\tnode* next[26];\\n\\t\\t\\tbool isend;\\n\\t\\t\\tnode(){\\n\\t\\t\\t\\tfor(int i=0; i<26; i++){\\n\\t\\t\\t\\t\\tnext[i] = nullptr;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tisend = false;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tclass Trie {\\n\\t\\tpublic:\\n\\n\\t\\t\\tnode* root = new node;\\n\\t\\t\\tvoid insert(string word) {\\n\\t\\t\\t\\tnode* temp = root;\\n\\t\\t\\t\\tfor(int i=0; i<word.size(); i++){\\n\\t\\t\\t\\t\\tchar c = word[i];\\n\\t\\t\\t\\t\\tif(temp->next[c - \\'a\\'] == nullptr) temp->next[c-\\'a\\'] = new node;\\n\\t\\t\\t\\t\\ttemp = temp->next[c-\\'a\\'];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttemp->isend = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tbool search(string word) {\\n\\t\\t\\t\\tnode* temp = root;\\n\\t\\t\\t\\tfor(int i=0; i<word.size(); i++){\\n\\t\\t\\t\\t\\tchar c = word[i];\\n\\t\\t\\t\\t\\tif(temp->next[c - \\'a\\'] == nullptr) return false;;\\n\\t\\t\\t\\t\\ttemp = temp->next[c-\\'a\\'];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn temp->isend;\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\t\\tTrie t;\\n\\t\\tunordered_map<char,string> mp;\\n\\t\\tunordered_map<string, vector<char>> rmp;\\n\\t\\tunordered_map<string , bool> vis;\\n\\t\\tEncrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n\\t\\t\\tfor(int i=0; i<keys.size(); i++){\\n\\t\\t\\t\\tmp[keys[i]] = values[i];\\n\\t\\t\\t\\trmp[values[i]].push_back(keys[i]);\\n\\t\\t\\t}\\n\\t\\t\\tfor(auto &w : dictionary){\\n\\t\\t\\t\\tvis[w] = true;\\n\\t\\t\\t\\tt.insert(w);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tstring encrypt(string word1) {\\n\\t\\t\\tstring str = \"\";\\n\\t\\t\\tfor(auto &c : word1){\\n\\t\\t\\t\\tstr += mp[c];\\n\\t\\t\\t}\\n\\t\\t\\treturn str;\\n\\t\\t}\\n\\t\\tint solve(int i, vector<vector<char>> &vt, node* temp){\\n\\t\\t\\tif(i == vt.size()){\\n\\t\\t\\t\\tif(temp->isend) return 1;\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tfor(int j=0; j<vt[i].size(); j++){\\n\\t\\t\\t\\tif(temp->next[vt[i][j] - \\'a\\'] != NULL){\\n\\t\\t\\t\\t\\tans += solve(i+1, vt, temp->next[vt[i][j] - \\'a\\']);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\n\\t\\t}\\n\\t\\tint decrypt(string word2) {\\n\\t\\t\\tint n = word2.size();\\n\\t\\t\\tvector<vector<char>> vt;\\n\\t\\t\\tvector<char> prev;\\n\\t\\t\\tif(n &1) return 0;\\n\\t\\t\\tfor(int i=0; i<n; i+=2){\\n\\t\\t\\t\\tstring str = \"\";\\n\\t\\t\\t\\tstr += word2[i];\\n\\t\\t\\t\\tstr += word2[i+1];\\n\\t\\t\\t\\tif(rmp.count(str) == 0) return 0;\\n\\t\\t\\t\\tvt.push_back(rmp[str]);\\n\\t\\t\\t}\\n\\t\\t\\tnode* temp = t.root;\\n\\t\\t\\tint ans = solve(0, vt, temp);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Your Encrypter object will be instantiated and called as such:\\n\\t * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n\\t * string param_1 = obj->encrypt(word1);\\n\\t * int param_2 = obj->decrypt(word2);\\n\\t */",
                "codeTag": "Java"
            },
            {
                "id": 1913137,
                "title": "c-hashset-and-trie",
                "content": "Basic ideas:\\n1.TLE issue: using dict1 as cache of Encrypt to avoid TLE.\\n2.Build a trie tree by all valid strings from dictionary. Using valid to mark an acceptable decrypt string.\\n\\n```\\n    public class Encrypter\\n    {\\n        private readonly Dictionary<char, string> encryptDict;\\n        private readonly Dictionary<string, List<char>> decryptDict;\\n        private readonly HashSet<string> set;\\n        private readonly Dictionary<string, string> dict1;\\n        private readonly TrieOfEncrypt root;\\n        public Encrypter(char[] keys, string[] values, string[] dictionary)\\n        {\\n            encryptDict=new Dictionary<char, string>();\\n            decryptDict=new Dictionary<string, List<char>>();\\n            for(int i=0; i<keys.Length; i++)\\n            {\\n                encryptDict.Add(keys[i], values[i]);\\n                if(!decryptDict.ContainsKey(values[i])) decryptDict.Add(values[i],new List<char>());\\n                decryptDict[values[i]].Add(keys[i]);\\n            }\\n            set = new HashSet<string>(dictionary);\\n            dict1 = new Dictionary<string, string>();\\n            root = new TrieOfEncrypt();\\n            BuildTrieTree();\\n        }\\n\\n        private void BuildTrieTree()\\n        {\\n            foreach(var key in set)\\n            {\\n                var curr = root;\\n                foreach(var c in key)\\n                {\\n                    if (!curr.childs.ContainsKey(c)) curr.childs.Add(c, new TrieOfEncrypt());\\n                    curr = curr.childs[c];\\n                }\\n                //only trie node with valid == true count 1 in Decrypt()\\n                curr.valid = true;\\n            }\\n        }\\n\\n        public string Encrypt(string word1)\\n        {\\n            //cache encrypt keys to avoid TLE\\n            if(dict1.ContainsKey(word1))return dict1[word1];\\n            StringBuilder sb= new StringBuilder();\\n            //string res = string.Empty;\\n            foreach (var c in word1)\\n                sb.Append(encryptDict[c]);\\n            var res = sb.ToString();\\n            dict1.Add(word1, res);\\n            return res;\\n        }\\n\\t\\t\\n        public int Decrypt(string word2)\\n        {\\n            var list = new List<TrieOfEncrypt>() { root };\\n            for(int i = 0; i < word2.Length; i += 2)\\n            {\\n                var str=word2.Substring(i, 2);\\n                if (!decryptDict.ContainsKey(str)) return 0;//cannot decrypted\\n                var next = new List<TrieOfEncrypt>();\\n                foreach (var curr in list)\\n                {\\n                    foreach (var c in decryptDict[str])\\n                    {\\n                        if (curr.childs.ContainsKey(c))\\n                            next.Add(curr.childs[c]);//only add available nodes to next loop\\n                    }\\n                }\\n                list = next;\\n                if (list.Count == 0) return 0;//can not decrypted\\n            }\\n            return list.Where(x=>x.valid).Count();\\n        }\\n    }\\n\\n    public class TrieOfEncrypt\\n    {\\n        //indicate if current trie node is valid\\n        public bool valid = false;\\n        public readonly Dictionary<char, TrieOfEncrypt> childs;\\n        public TrieOfEncrypt()\\n        {\\n            childs = new Dictionary<char, TrieOfEncrypt>();\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Encrypter\\n    {\\n        private readonly Dictionary<char, string> encryptDict;\\n        private readonly Dictionary<string, List<char>> decryptDict;\\n        private readonly HashSet<string> set;\\n        private readonly Dictionary<string, string> dict1;\\n        private readonly TrieOfEncrypt root;\\n        public Encrypter(char[] keys, string[] values, string[] dictionary)\\n        {\\n            encryptDict=new Dictionary<char, string>();\\n            decryptDict=new Dictionary<string, List<char>>();\\n            for(int i=0; i<keys.Length; i++)\\n            {\\n                encryptDict.Add(keys[i], values[i]);\\n                if(!decryptDict.ContainsKey(values[i])) decryptDict.Add(values[i],new List<char>());\\n                decryptDict[values[i]].Add(keys[i]);\\n            }\\n            set = new HashSet<string>(dictionary);\\n            dict1 = new Dictionary<string, string>();\\n            root = new TrieOfEncrypt();\\n            BuildTrieTree();\\n        }\\n\\n        private void BuildTrieTree()\\n        {\\n            foreach(var key in set)\\n            {\\n                var curr = root;\\n                foreach(var c in key)\\n                {\\n                    if (!curr.childs.ContainsKey(c)) curr.childs.Add(c, new TrieOfEncrypt());\\n                    curr = curr.childs[c];\\n                }\\n                //only trie node with valid == true count 1 in Decrypt()\\n                curr.valid = true;\\n            }\\n        }\\n\\n        public string Encrypt(string word1)\\n        {\\n            //cache encrypt keys to avoid TLE\\n            if(dict1.ContainsKey(word1))return dict1[word1];\\n            StringBuilder sb= new StringBuilder();\\n            //string res = string.Empty;\\n            foreach (var c in word1)\\n                sb.Append(encryptDict[c]);\\n            var res = sb.ToString();\\n            dict1.Add(word1, res);\\n            return res;\\n        }\\n\\t\\t\\n        public int Decrypt(string word2)\\n        {\\n            var list = new List<TrieOfEncrypt>() { root };\\n            for(int i = 0; i < word2.Length; i += 2)\\n            {\\n                var str=word2.Substring(i, 2);\\n                if (!decryptDict.ContainsKey(str)) return 0;//cannot decrypted\\n                var next = new List<TrieOfEncrypt>();\\n                foreach (var curr in list)\\n                {\\n                    foreach (var c in decryptDict[str])\\n                    {\\n                        if (curr.childs.ContainsKey(c))\\n                            next.Add(curr.childs[c]);//only add available nodes to next loop\\n                    }\\n                }\\n                list = next;\\n                if (list.Count == 0) return 0;//can not decrypted\\n            }\\n            return list.Where(x=>x.valid).Count();\\n        }\\n    }\\n\\n    public class TrieOfEncrypt\\n    {\\n        //indicate if current trie node is valid\\n        public bool valid = false;\\n        public readonly Dictionary<char, TrieOfEncrypt> childs;\\n        public TrieOfEncrypt()\\n        {\\n            childs = new Dictionary<char, TrieOfEncrypt>();\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1913134,
                "title": "pre-count-dictionary-solution",
                "content": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.m={}\\n        for i in range(len(keys)):\\n            self.m[keys[i]]=values[i]\\n        self.count={}\\n        for word in dictionary:\\n            l=[]\\n            for c in word:\\n                l.append(self.m[c])\\n            possible_string=\"\".join(l)\\n            self.count[possible_string]=self.count.get(possible_string,0)+1\\n\\n                \\n    def encrypt(self, word1: str) -> str:\\n        l=[]\\n        for c in word1:\\n            l.append(self.m[c])\\n        possible_string=\"\".join(l)\\n        return possible_string\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.count.get(word2,0)\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.m={}\\n        for i in range(len(keys)):\\n            self.m[keys[i]]=values[i]\\n        self.count={}\\n        for word in dictionary:\\n            l=[]\\n            for c in word:\\n                l.append(self.m[c])\\n            possible_string=\"\".join(l)\\n            self.count[possible_string]=self.count.get(possible_string,0)+1\\n\\n                \\n    def encrypt(self, word1: str) -> str:\\n        l=[]\\n        for c in word1:\\n            l.append(self.m[c])\\n        possible_string=\"\".join(l)\\n        return possible_string\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.count.get(word2,0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912932,
                "title": "scala-simple-problem-so-0-need-for-more-than-5-lines-including-all",
                "content": "`encrypt` is easy. Now you might want to use complex algorithm for `decrypt`, but it turns out *(gotcha)*, the dictionary input is always quite small.\\nSo you could pre-encrypt them and make the histogram of encrypted values. When you hit `decrypt`, you simply return the pre-computed counts.\\n\\n```scala\\nclass Encrypter (_keys: Array[Char], _values: Array[String], _dictionary: Array[String]) {\\n  val ktov = (_keys.iterator zip _values.iterator).toMap\\n  val encCounts = _dictionary.groupMapReduce (encrypt (_)) (_ => 1) (_ + _)\\n  def encrypt (word1: String): String = word1.flatMap (ktov (_)).mkString\\n  def decrypt (word2: String): Int = encCounts.getOrElse (word2, 0) }\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```scala\\nclass Encrypter (_keys: Array[Char], _values: Array[String], _dictionary: Array[String]) {\\n  val ktov = (_keys.iterator zip _values.iterator).toMap\\n  val encCounts = _dictionary.groupMapReduce (encrypt (_)) (_ => 1) (_ + _)\\n  def encrypt (word1: String): String = word1.flatMap (ktov (_)).mkString\\n  def decrypt (word2: String): Int = encCounts.getOrElse (word2, 0) }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912816,
                "title": "easy-understanding-c-code-trie",
                "content": "https://github.com/kumarmanish03/DSA-Solved-Questions/blob/main/Tree/Encrypt%20and%20Decrypt%20Strings.cpp\\n\\n```\\n// Manish Kumar, IIIT Allahabad\\n// Trie\\n\\nhttps://leetcode.com/problems/encrypt-and-decrypt-strings/\\n\\nclass Encrypter {\\npublic:\\n    struct Trie{\\n        Trie *child[26];\\n        Trie(){\\n            for(int i = 0; i < 26; i++)\\n                child[i] = NULL;\\n        }\\n    };\\n    \\n    Trie* d;\\n    \\n    unordered_map<string, vector<char>> v;\\n    unordered_map<string, int> dict;\\n    vector<string> data;\\n    unordered_map<string, int> decrypted;\\n    \\n    int cnt;\\n    \\n    void insert(string s, Trie* head){\\n        Trie* curr = head;\\n        for(char c:s){\\n            if(!curr->child[c-\\'a\\'])\\n                curr->child[c-\\'a\\'] = new Trie();\\n            curr = curr->child[c-\\'a\\'];\\n        }\\n    }\\n    \\n    bool search(string s, Trie* head){\\n        Trie* curr = head;\\n        for(char c:s){\\n            if(!curr->child[c-\\'a\\'])\\n                return false;\\n            curr = curr->child[c-\\'a\\'];\\n        }\\n        return true;\\n    }\\n    \\n    Encrypter(vector<char>& key, vector<string>& val, vector<string>& dictionary) {\\n        d = new Trie();\\n        v.clear();\\n        cnt = 0;\\n        dict.clear();\\n        data.resize(26, \"\");\\n        decrypted.clear();\\n        \\n        for(string s:dictionary){\\n            insert(s, d);\\n            dict[s]++;\\n        }\\n        \\n        for(int i = 0; i < key.size();i++){\\n            data[key[i]-\\'a\\'] = val[i];\\n                // cout<<val[24];\\n        } \\n        \\n        for(int i = 0; i < val.size(); i++){\\n            v[val[i]].push_back(key[i]);\\n        }\\n        \\n               \\n        \\n    }\\n    \\n    void recur(string s, string t, int i){\\n        if(i >= s.size()){\\n            if(dict[t])\\n                cnt++;\\n            return;\\n        }\\n        \\n        if(search(t, d) == false)\\n            return;\\n        \\n        string q = s.substr(i, 2);\\n        for(char x:v[q])\\n            recur(s, t+x, i+2);\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res=\"\";\\n        for(int i = 0; i < word1.size(); i++){\\n            res += data[word1[i]-\\'a\\'];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        if(decrypted.find(word2) != decrypted.end())\\n            return decrypted[word2];\\n        cnt = 0;\\n        string t = \"\";\\n        int i = 0;\\n        recur(word2, t, i);\\n        return decrypted[word2] = cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\n// Manish Kumar, IIIT Allahabad\\n// Trie\\n\\nhttps://leetcode.com/problems/encrypt-and-decrypt-strings/\\n\\nclass Encrypter {\\npublic:\\n    struct Trie{\\n        Trie *child[26];\\n        Trie(){\\n            for(int i = 0; i < 26; i++)\\n                child[i] = NULL;\\n        }\\n    };\\n    \\n    Trie* d;\\n    \\n    unordered_map<string, vector<char>> v;\\n    unordered_map<string, int> dict;\\n    vector<string> data;\\n    unordered_map<string, int> decrypted;\\n    \\n    int cnt;\\n    \\n    void insert(string s, Trie* head){\\n        Trie* curr = head;\\n        for(char c:s){\\n            if(!curr->child[c-\\'a\\'])\\n                curr->child[c-\\'a\\'] = new Trie();\\n            curr = curr->child[c-\\'a\\'];\\n        }\\n    }\\n    \\n    bool search(string s, Trie* head){\\n        Trie* curr = head;\\n        for(char c:s){\\n            if(!curr->child[c-\\'a\\'])\\n                return false;\\n            curr = curr->child[c-\\'a\\'];\\n        }\\n        return true;\\n    }\\n    \\n    Encrypter(vector<char>& key, vector<string>& val, vector<string>& dictionary) {\\n        d = new Trie();\\n        v.clear();\\n        cnt = 0;\\n        dict.clear();\\n        data.resize(26, \"\");\\n        decrypted.clear();\\n        \\n        for(string s:dictionary){\\n            insert(s, d);\\n            dict[s]++;\\n        }\\n        \\n        for(int i = 0; i < key.size();i++){\\n            data[key[i]-\\'a\\'] = val[i];\\n                // cout<<val[24];\\n        } \\n        \\n        for(int i = 0; i < val.size(); i++){\\n            v[val[i]].push_back(key[i]);\\n        }\\n        \\n               \\n        \\n    }\\n    \\n    void recur(string s, string t, int i){\\n        if(i >= s.size()){\\n            if(dict[t])\\n                cnt++;\\n            return;\\n        }\\n        \\n        if(search(t, d) == false)\\n            return;\\n        \\n        string q = s.substr(i, 2);\\n        for(char x:v[q])\\n            recur(s, t+x, i+2);\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res=\"\";\\n        for(int i = 0; i < word1.size(); i++){\\n            res += data[word1[i]-\\'a\\'];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        if(decrypted.find(word2) != decrypted.end())\\n            return decrypted[word2];\\n        cnt = 0;\\n        string t = \"\";\\n        int i = 0;\\n        recur(word2, t, i);\\n        return decrypted[word2] = cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1912408,
                "title": "rust-translated-from-lee215-s-solution",
                "content": "```rust\\n\\nuse std::{\\n    cmp::{Ordering, Reverse},\\n    collections::{BinaryHeap, HashMap, HashSet},\\n    fmt::Binary,\\n    hash::Hash,\\n};\\n\\nstruct Encrypter {\\n    encode: HashMap<char, String>,\\n    count: HashMap<String, i32>,\\n}\\n\\nimpl Encrypter {\\n    fn new(keys: Vec<char>, values: Vec<String>, dictionary: Vec<String>) -> Self {\\n        let mut encode = HashMap::new();\\n        for i in 0..keys.len() {\\n            encode.insert(keys[i], values[i].clone());\\n        }\\n\\n        let mut count = HashMap::new();\\n        let mut encrypter = Encrypter { encode, count };\\n\\n        for w in dictionary {\\n            let encoded = Self::encrypt(&encrypter, w);\\n            *encrypter.count.entry(encoded).or_insert(0) += 1;\\n        }\\n\\n        encryptera\\n    }\\n\\n    fn encrypt(&self, word1: String) -> String {\\n        let mut res = String::new();\\n        for c in word1.chars() {\\n            let value = self.encode.get(&c).unwrap();\\n            res.push_str(value.as_str())\\n        }\\n        res\\n    }\\n\\n    fn decrypt(&self, word2: String) -> i32 {\\n        match self.count.get(&word2) {\\n            Some(res) => *res,\\n            None => 0,\\n        }\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```rust\\n\\nuse std::{\\n    cmp::{Ordering, Reverse},\\n    collections::{BinaryHeap, HashMap, HashSet},\\n    fmt::Binary,\\n    hash::Hash,\\n};\\n\\nstruct Encrypter {\\n    encode: HashMap<char, String>,\\n    count: HashMap<String, i32>,\\n}\\n\\nimpl Encrypter {\\n    fn new(keys: Vec<char>, values: Vec<String>, dictionary: Vec<String>) -> Self {\\n        let mut encode = HashMap::new();\\n        for i in 0..keys.len() {\\n            encode.insert(keys[i], values[i].clone());\\n        }\\n\\n        let mut count = HashMap::new();\\n        let mut encrypter = Encrypter { encode, count };\\n\\n        for w in dictionary {\\n            let encoded = Self::encrypt(&encrypter, w);\\n            *encrypter.count.entry(encoded).or_insert(0) += 1;\\n        }\\n\\n        encryptera\\n    }\\n\\n    fn encrypt(&self, word1: String) -> String {\\n        let mut res = String::new();\\n        for c in word1.chars() {\\n            let value = self.encode.get(&c).unwrap();\\n            res.push_str(value.as_str())\\n        }\\n        res\\n    }\\n\\n    fn decrypt(&self, word2: String) -> i32 {\\n        match self.count.get(&word2) {\\n            Some(res) => *res,\\n            None => 0,\\n        }\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1912223,
                "title": "3-min-hindi-video-simple-hash-solution",
                "content": "3 min Hindi Video | Simple hash Solution \\nyoutube .com/watch?v=3Ev4oM6p-s4\\n\\nPLEASE PLEASE upvote it if you like it. Jaroor upvote karna.",
                "solutionTags": [],
                "code": "3 min Hindi Video | Simple hash Solution \\nyoutube .com/watch?v=3Ev4oM6p-s4\\n\\nPLEASE PLEASE upvote it if you like it. Jaroor upvote karna.",
                "codeTag": "Unknown"
            },
            {
                "id": 1911731,
                "title": "python-simple-use-two-dicts",
                "content": "We just need to use 2 dicts:\\n**dict1**: to map character from *key* to its value in *values* (which will be used in *encrypt*)\\n**dict2**: to map each word in dictionary to its encrypted word using **dict1** and store its count of occurances (which will be used in *decrypt*)\\n\\n\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.pair,self.de = defaultdict(str),defaultdict(int)\\n        for i,j in enumerate(keys):\\n            self.pair[j]=values[i]\\n        for i in dictionary:\\n            key = \"\".join(self.pair[j] for j in i)\\n            self.de[key]+=1\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \"\".join(self.pair[i] for i in word1)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.de[word2]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.pair,self.de = defaultdict(str),defaultdict(int)\\n        for i,j in enumerate(keys):\\n            self.pair[j]=values[i]\\n        for i in dictionary:\\n            key = \"\".join(self.pair[j] for j in i)\\n            self.de[key]+=1\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \"\".join(self.pair[i] for i in word1)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.de[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911486,
                "title": "c-easy-solution",
                "content": "```\\nclass Encrypter {\\npublic:\\n    //data members\\n    vector<char> keys;\\n    vector<string> values;\\n    vector<string> dictionary;\\n    unordered_map<char, int> keyIndex;\\n    unordered_map<string, vector<int>> valuesIndex;\\n    unordered_map<string, int> freq;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        this->keys = keys;\\n        this->values = values;\\n        this->dictionary = dictionary;\\n        for(int i = 0; i < keys.size(); i++){\\n            keyIndex[keys[i]] = i;\\n        }\\n        for(int i = 0; i < values.size(); i++){\\n            valuesIndex[values[i]].push_back(i);\\n        }\\n        \\n        for(auto i: dictionary){\\n            string ans = encrypt(i);\\n            freq[ans] += 1;\\n        }\\n    }\\n   \\n\\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto i: word1){\\n            int index = keyIndex[i];\\n            string temp = values[index];\\n            ans += temp;\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n       return freq[word2];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    //data members\\n    vector<char> keys;\\n    vector<string> values;\\n    vector<string> dictionary;\\n    unordered_map<char, int> keyIndex;\\n    unordered_map<string, vector<int>> valuesIndex;\\n    unordered_map<string, int> freq;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        this->keys = keys;\\n        this->values = values;\\n        this->dictionary = dictionary;\\n        for(int i = 0; i < keys.size(); i++){\\n            keyIndex[keys[i]] = i;\\n        }\\n        for(int i = 0; i < values.size(); i++){\\n            valuesIndex[values[i]].push_back(i);\\n        }\\n        \\n        for(auto i: dictionary){\\n            string ans = encrypt(i);\\n            freq[ans] += 1;\\n        }\\n    }\\n   \\n\\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto i: word1){\\n            int index = keyIndex[i];\\n            string temp = values[index];\\n            ans += temp;\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n       return freq[word2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911396,
                "title": "python-very-simple-solution",
                "content": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.key_val_map=dict()\\n        for i in range(len(keys)):\\n            self.key_val_map[keys[i]]=values[i]\\n        \\n        self.dictionary_freq=defaultdict(int)\\n        for i in dictionary:\\n            ans=\"\"\\n            for char in i:\\n                ans+=self.key_val_map[char]\\n            self.dictionary_freq[ans]+=1\\n                \\n        \\n\\n    def encrypt(self, word1: str) -> str:\\n        ans=\"\"\\n        for char in word1:\\n            ans+=self.key_val_map[char]\\n        return ans\\n        \\n\\n    def decrypt(self, word2: str) -> int:\\n        \\n        return self.dictionary_freq[word2]\\n        \\n\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.key_val_map=dict()\\n        for i in range(len(keys)):\\n            self.key_val_map[keys[i]]=values[i]\\n        \\n        self.dictionary_freq=defaultdict(int)\\n        for i in dictionary:\\n            ans=\"\"\\n            for char in i:\\n                ans+=self.key_val_map[char]\\n            self.dictionary_freq[ans]+=1\\n                \\n        \\n\\n    def encrypt(self, word1: str) -> str:\\n        ans=\"\"\\n        for char in word1:\\n            ans+=self.key_val_map[char]\\n        return ans\\n        \\n\\n    def decrypt(self, word2: str) -> int:\\n        \\n        return self.dictionary_freq[word2]\\n        \\n\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911391,
                "title": "python-three-lines-of-code",
                "content": "This is the easiest hard problem ever. It\\'s just three lines of python code with one line in each class method.\\n\\n```\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.k2v, self.dict = dict(zip(keys, values)), dictionary\\n        \\n    def encrypt(self, word1: str) -> str:\\n        return \"\".join(self.k2v[c] for c in word1)\\n        \\n    def decrypt(self, word2: str) -> int:\\n        return sum(1 for word in self.dict if self.encrypt(word) == word2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.k2v, self.dict = dict(zip(keys, values)), dictionary\\n        \\n    def encrypt(self, word1: str) -> str:\\n        return \"\".join(self.k2v[c] for c in word1)\\n        \\n    def decrypt(self, word2: str) -> int:\\n        return sum(1 for word in self.dict if self.encrypt(word) == word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911346,
                "title": "java-solution-using-trie",
                "content": "```\\nclass TrieNode{\\n    public Map<Character, TrieNode> children = new HashMap();\\n    public boolean isWord;\\n}\\n\\nclass Encrypter {\\n    Map<Character, String> keysToValues  = new HashMap();\\n    Map<String, List<Character>> valuesToKeys = new HashMap();\\n    TrieNode root = new TrieNode();\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        int i  = 0;\\n        for(char key : keys){\\n            keysToValues.put(key, values[i++]);\\n        }\\n        for(i = 0; i < values.length; i++){\\n            valuesToKeys.putIfAbsent(values[i], new ArrayList());\\n            valuesToKeys.get(values[i]).add(keys[i]);\\n        }\\n        \\n        for(String word : dictionary){\\n            construct(root, word);\\n        }\\n    }\\n    \\n    private void construct(TrieNode root, String word){\\n        for(int i = 0; i< word.length(); i++){\\n            char c = word.charAt(i);\\n            if(root.children.containsKey(c)){\\n                root = root.children.get(c);\\n            }else{\\n                TrieNode node = new TrieNode();\\n                root.children.put(c, node);\\n                root = node;\\n            }\\n        }\\n        \\n        root.isWord = true;\\n    }\\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i = 0; i< word1.length(); i++){\\n            char c = word1.charAt(i);\\n            if(keysToValues.get(c) != null){\\n                sb.append(keysToValues.get(c));\\n            }else{\\n                sb.append(c);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n       return count(root, word2, 0);\\n    }\\n    \\n    private int count(TrieNode root, String word2, int index){\\n        if(index == word2.length() && root.isWord) return 1;\\n        if(index == word2.length()) return 0;\\n        String str = word2.substring(index, index+2);\\n        int res = 0;\\n        if( valuesToKeys.get(str) != null){\\n            for(Character c  : valuesToKeys.get(str)){\\n                if(root.children.get(c) != null){\\n                    res += count(root.children.get(c), word2, index+2);\\n                } \\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode{\\n    public Map<Character, TrieNode> children = new HashMap();\\n    public boolean isWord;\\n}\\n\\nclass Encrypter {\\n    Map<Character, String> keysToValues  = new HashMap();\\n    Map<String, List<Character>> valuesToKeys = new HashMap();\\n    TrieNode root = new TrieNode();\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        int i  = 0;\\n        for(char key : keys){\\n            keysToValues.put(key, values[i++]);\\n        }\\n        for(i = 0; i < values.length; i++){\\n            valuesToKeys.putIfAbsent(values[i], new ArrayList());\\n            valuesToKeys.get(values[i]).add(keys[i]);\\n        }\\n        \\n        for(String word : dictionary){\\n            construct(root, word);\\n        }\\n    }\\n    \\n    private void construct(TrieNode root, String word){\\n        for(int i = 0; i< word.length(); i++){\\n            char c = word.charAt(i);\\n            if(root.children.containsKey(c)){\\n                root = root.children.get(c);\\n            }else{\\n                TrieNode node = new TrieNode();\\n                root.children.put(c, node);\\n                root = node;\\n            }\\n        }\\n        \\n        root.isWord = true;\\n    }\\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i = 0; i< word1.length(); i++){\\n            char c = word1.charAt(i);\\n            if(keysToValues.get(c) != null){\\n                sb.append(keysToValues.get(c));\\n            }else{\\n                sb.append(c);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n       return count(root, word2, 0);\\n    }\\n    \\n    private int count(TrieNode root, String word2, int index){\\n        if(index == word2.length() && root.isWord) return 1;\\n        if(index == word2.length()) return 0;\\n        String str = word2.substring(index, index+2);\\n        int res = 0;\\n        if( valuesToKeys.get(str) != null){\\n            for(Character c  : valuesToKeys.get(str)){\\n                if(root.children.get(c) != null){\\n                    res += count(root.children.get(c), word2, index+2);\\n                } \\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1911321,
                "title": "most-optimized-code-using-dict",
                "content": "\\ndef __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n\\t\\tself.d = defaultdict(int)\\n        self.m = {}\\n        for i, j in zip(keys, values):\\n            self.m[i] = j\\n        print(self.m)\\n        for i in dictionary:\\n            l = []\\n            for x in i:\\n                l.append(self.m[x])\\n            self.d[\\'\\'.join(l)] += 1\\n        print(self.d)\\n    def encrypt(self, word1: str) -> str:\\n        l = []\\n        for x in word1:\\n            l.append(self.m[x])\\n        return \\'\\'.join(l)\\n\\tdef decrypt(self, word2: str) -> int:\\n        return self.d[word2]",
                "solutionTags": [],
                "code": "\\ndef __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n\\t\\tself.d = defaultdict(int)\\n        self.m = {}\\n        for i, j in zip(keys, values):\\n            self.m[i] = j\\n        print(self.m)\\n        for i in dictionary:\\n            l = []\\n            for x in i:\\n                l.append(self.m[x])\\n            self.d[\\'\\'.join(l)] += 1\\n        print(self.d)\\n    def encrypt(self, word1: str) -> str:\\n        l = []\\n        for x in word1:\\n            l.append(self.m[x])\\n        return \\'\\'.join(l)\\n\\tdef decrypt(self, word2: str) -> int:\\n        return self.d[word2]",
                "codeTag": "Python3"
            },
            {
                "id": 1911295,
                "title": "easy-c-solution-hashmap-tries",
                "content": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string> encryptMap;\\n    map<string,vector<char>> decryptMap;\\n    struct Trie{\\n        Trie* characters[26];\\n        bool isEnd = false;\\n    }*trie = new Trie();\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int index = 0 ; index < keys.size() ; ++index){\\n            encryptMap[keys[index]] = values[index];\\n        }\\n        for(int index = 0 ; index < values.size() ; ++index){\\n            decryptMap[values[index]].push_back(keys[index]);\\n        }\\n        for(auto word : dictionary){\\n            struct Trie* temp = trie;\\n            for(auto ch : word){\\n                if(!temp->characters[ch - \\'a\\']){\\n                    temp->characters[ch - \\'a\\'] = new Trie();\\n                }\\n                temp = temp->characters[ch - \\'a\\'];\\n            }\\n            temp->isEnd = true;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans;\\n        for(auto ch : word1){\\n            ans.append(encryptMap[ch]);\\n        }\\n        return ans;\\n    }\\n    int decryptCount(string &word2 , int index , struct Trie* trie){\\n        if(index == word2.length()){\\n            if(trie->isEnd){\\n                return 1;\\n            }\\n            else{\\n                return 0;\\n            }\\n        }\\n        int count = 0;\\n        for(auto ch : decryptMap[word2.substr(index , 2)]){\\n            if(trie->characters[ch - \\'a\\']){\\n                count += decryptCount(word2 , index + 2 , trie->characters[ch - \\'a\\']);\\n            }\\n        }\\n        return count;\\n    }\\n    int decrypt(string word2) {\\n        return decryptCount(word2 , 0 , trie);\\n    \\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string> encryptMap;\\n    map<string,vector<char>> decryptMap;\\n    struct Trie{\\n        Trie* characters[26];\\n        bool isEnd = false;\\n    }*trie = new Trie();\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int index = 0 ; index < keys.size() ; ++index){\\n            encryptMap[keys[index]] = values[index];\\n        }\\n        for(int index = 0 ; index < values.size() ; ++index){\\n            decryptMap[values[index]].push_back(keys[index]);\\n        }\\n        for(auto word : dictionary){\\n            struct Trie* temp = trie;\\n            for(auto ch : word){\\n                if(!temp->characters[ch - \\'a\\']){\\n                    temp->characters[ch - \\'a\\'] = new Trie();\\n                }\\n                temp = temp->characters[ch - \\'a\\'];\\n            }\\n            temp->isEnd = true;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans;\\n        for(auto ch : word1){\\n            ans.append(encryptMap[ch]);\\n        }\\n        return ans;\\n    }\\n    int decryptCount(string &word2 , int index , struct Trie* trie){\\n        if(index == word2.length()){\\n            if(trie->isEnd){\\n                return 1;\\n            }\\n            else{\\n                return 0;\\n            }\\n        }\\n        int count = 0;\\n        for(auto ch : decryptMap[word2.substr(index , 2)]){\\n            if(trie->characters[ch - \\'a\\']){\\n                count += decryptCount(word2 , index + 2 , trie->characters[ch - \\'a\\']);\\n            }\\n        }\\n        return count;\\n    }\\n    int decrypt(string word2) {\\n        return decryptCount(word2 , 0 , trie);\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911250,
                "title": "python3-stupid-easy-solution-with-counter",
                "content": "```python\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.kv = dict(zip(keys, values))\\n        self.ctr = Counter(self.encrypt(w) for w in dictionary)\\n        \\n    def encrypt(self, word1: str) -> str:\\n        s = list(word1)\\n        for i, c in enumerate(word1):\\n            s[i] = self.kv[c]\\n        return \\'\\'.join(s)\\n            \\n    def decrypt(self, word2: str) -> int:\\n        return self.ctr[word2]\\n ```",
                "solutionTags": [],
                "code": "```python\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.kv = dict(zip(keys, values))\\n        self.ctr = Counter(self.encrypt(w) for w in dictionary)\\n        \\n    def encrypt(self, word1: str) -> str:\\n        s = list(word1)\\n        for i, c in enumerate(word1):\\n            s[i] = self.kv[c]\\n        return \\'\\'.join(s)\\n            \\n    def decrypt(self, word2: str) -> int:\\n        return self.ctr[word2]\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1911205,
                "title": "java-hashmaps-with-trick",
                "content": "The way the problem is defined - is probably just Medium:\\n* Encryption - just follow the mapping rules.\\n* Decryption - there\\'s only a finite number of decryption results - encrypt them all in preprocessing and then just lookup input to decrypt.\\n```\\nclass Encrypter {\\n    Map<Character,String> enc;\\n    Map<String,Integer> encDict;\\n    \\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        int n= keys.length;\\n        this.enc= new HashMap<>();\\n        for(int i=0; i<n; i++) enc.put(keys[i], values[i]);\\n\\n        this.encDict= new HashMap<>();\\n        for(String word:dictionary){\\n            String encWord= encrypt(word);\\n            encDict.put(encWord, 1+encDict.getOrDefault(encWord, 0));\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        char[] ca= word1.toCharArray();\\n        StringBuilder sb= new StringBuilder();\\n        for(char c:ca) sb.append(enc.get(c));\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return encDict.getOrDefault(word2, 0);\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "The way the problem is defined - is probably just Medium:\\n* Encryption - just follow the mapping rules.\\n* Decryption - there\\'s only a finite number of decryption results - encrypt them all in preprocessing and then just lookup input to decrypt.\\n```\\nclass Encrypter {\\n    Map<Character,String> enc;\\n    Map<String,Integer> encDict;\\n    \\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        int n= keys.length;\\n        this.enc= new HashMap<>();\\n        for(int i=0; i<n; i++) enc.put(keys[i], values[i]);\\n\\n        this.encDict= new HashMap<>();\\n        for(String word:dictionary){\\n            String encWord= encrypt(word);\\n            encDict.put(encWord, 1+encDict.getOrDefault(encWord, 0));\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        char[] ca= word1.toCharArray();\\n        StringBuilder sb= new StringBuilder();\\n        for(char c:ca) sb.append(enc.get(c));\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return encDict.getOrDefault(word2, 0);\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 1910749,
                "title": "python-3-hashmap-and-counter",
                "content": "Maintain a hashmap and a counter. Hashmap `c2v` converts keys to values, and garanteed by the question all letters in word1 appear in keys. Counter `en_ct` keeps count of encrypted from all words in the dictionary, if word2 is in `en_ct`, return its count, otherwise 0 - word2 not in the dictionary.\\n\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.en_ct = Counter()\\n        self.c2v = {keys[i]: values[i] for i in range(len(keys))}\\n        for word in dictionary:\\n            s = \\'\\'\\n            for c in word:\\n                s += self.c2v[c]\\n            self.en_ct[s] += 1\\n\\n    def encrypt(self, word1: str) -> str:\\n        s = \\'\\'\\n        for c in word1:\\n            s += self.c2v[c]\\n        return s\\n\\n    def decrypt(self, word2: str) -> int:\\n        if word2 not in self.en_ct:\\n            return 0\\n        return self.en_ct[word2]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.en_ct = Counter()\\n        self.c2v = {keys[i]: values[i] for i in range(len(keys))}\\n        for word in dictionary:\\n            s = \\'\\'\\n            for c in word:\\n                s += self.c2v[c]\\n            self.en_ct[s] += 1\\n\\n    def encrypt(self, word1: str) -> str:\\n        s = \\'\\'\\n        for c in word1:\\n            s += self.c2v[c]\\n        return s\\n\\n    def decrypt(self, word2: str) -> int:\\n        if word2 not in self.en_ct:\\n            return 0\\n        return self.en_ct[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910648,
                "title": "java-trie-hashmap-o-n",
                "content": "The idea is to encrypt all dictionary words and create a trie tree of all of them.\\nRoot nodes of the trie tree should hold the dictionary frequency of each encrypted word \\n\\n```\\nclass Encrypter {\\n\\n    class TrieNode {\\n        public int count;\\n        public TrieNode[] next;\\n\\n        public TrieNode() {\\n            count = 0;\\n            next = new TrieNode[26];\\n        }\\n        public void add(String str) {\\n            TrieNode node = this;\\n            for (int i = 0; i < str.length(); i++) {\\n                int index = str.charAt(i) - \\'a\\';\\n                if (node.next[index] == null) {\\n                    node.next[index] = new TrieNode();\\n                }\\n                node = node.next[index];\\n            }\\n            node.count++;\\n        }\\n    }\\n\\n\\n    HashMap < Character, Integer > keysMap;\\n    String[] values;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        keysMap = new HashMap();\\n        for (int i = 0; i < keys.length; i++) {\\n            keysMap.put(keys[i], i);\\n        }\\n        this.values = values;\\n        root = new TrieNode();\\n        for (String s: dictionary) {\\n            root.add(encrypt(s));\\n        }\\n\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder str = new StringBuilder();\\n        for (int i = 0; i < word1.length(); i++) {\\n            str.append(values[keysMap.get(word1.charAt(i))]);\\n        }\\n\\n        return str.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        TrieNode node = root;\\n        for (int i = 0; i < word2.length(); i++) {\\n            int index = word2.charAt(i) - \\'a\\';\\n            if (node.next[index] == null) return 0;\\n            else node = node.next[index];\\n        }\\n        return node.count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Encrypter {\\n\\n    class TrieNode {\\n        public int count;\\n        public TrieNode[] next;\\n\\n        public TrieNode() {\\n            count = 0;\\n            next = new TrieNode[26];\\n        }\\n        public void add(String str) {\\n            TrieNode node = this;\\n            for (int i = 0; i < str.length(); i++) {\\n                int index = str.charAt(i) - \\'a\\';\\n                if (node.next[index] == null) {\\n                    node.next[index] = new TrieNode();\\n                }\\n                node = node.next[index];\\n            }\\n            node.count++;\\n        }\\n    }\\n\\n\\n    HashMap < Character, Integer > keysMap;\\n    String[] values;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        keysMap = new HashMap();\\n        for (int i = 0; i < keys.length; i++) {\\n            keysMap.put(keys[i], i);\\n        }\\n        this.values = values;\\n        root = new TrieNode();\\n        for (String s: dictionary) {\\n            root.add(encrypt(s));\\n        }\\n\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder str = new StringBuilder();\\n        for (int i = 0; i < word1.length(); i++) {\\n            str.append(values[keysMap.get(word1.charAt(i))]);\\n        }\\n\\n        return str.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        TrieNode node = root;\\n        for (int i = 0; i < word2.length(); i++) {\\n            int index = word2.charAt(i) - \\'a\\';\\n            if (node.next[index] == null) return 0;\\n            else node = node.next[index];\\n        }\\n        return node.count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910582,
                "title": "java-hashmap-only-easy-understanding",
                "content": "```\\nclass Encrypter {\\n    HashMap<Character, String> map = new HashMap<>(); // key to value\\n    HashMap<String, Integer> map2 = new HashMap<>(); // encrypt every word in dictionary, map it to number of times its found in dictionary\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int i = 0;i < keys.length; i++){\\n            map.put(keys[i], values[i]);\\n        }\\n        for(int i = 0;i < dictionary.length; i++){\\n            map2.put(encrypt(dictionary[i]), map2.getOrDefault(encrypt(dictionary[i]), 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String encrypted = \"\";\\n        for(int i = 0;i < word1.length(); i++){\\n            char curr = word1.charAt(i);\\n            encrypted += map.get(curr);\\n        }\\n        return encrypted;\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return map2.getOrDefault(word2, 0);\\n    }\\n    \\n    \\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n    HashMap<Character, String> map = new HashMap<>(); // key to value\\n    HashMap<String, Integer> map2 = new HashMap<>(); // encrypt every word in dictionary, map it to number of times its found in dictionary\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int i = 0;i < keys.length; i++){\\n            map.put(keys[i], values[i]);\\n        }\\n        for(int i = 0;i < dictionary.length; i++){\\n            map2.put(encrypt(dictionary[i]), map2.getOrDefault(encrypt(dictionary[i]), 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String encrypted = \"\";\\n        for(int i = 0;i < word1.length(); i++){\\n            char curr = word1.charAt(i);\\n            encrypted += map.get(curr);\\n        }\\n        return encrypted;\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return map2.getOrDefault(word2, 0);\\n    }\\n    \\n    \\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910551,
                "title": "c-hashmap-trie",
                "content": "```\\nclass Trie{\\nprivate:\\n    unordered_map<string, Trie*> next; \\n    bool isWord = false;\\n    int match = 0;\\npublic:\\n    Trie(){}\\n    void insert(string word,vector<string>& ktov)\\n    {\\n        Trie* node = this;\\n        for(char& c:word)\\n        {\\n            if(node->next[ktov[c-\\'a\\']]==nullptr)\\n                node->next[ktov[c-\\'a\\']] = new Trie();\\n            node = node->next[ktov[c-\\'a\\']];\\n        }\\n        node->isWord = true;\\n        node->match++;\\n    }\\n    int search(string word)\\n    {\\n        Trie* node = this;\\n        for(int i=0;i<word.size();i+=2)\\n        {\\n            string now = word.substr(i,2);\\n            if(node->next[now]==nullptr)\\n                return 0;\\n            node = node->next[now];\\n        }\\n        return node->match;\\n    }\\n};\\nclass Encrypter {\\nprivate:\\n    unordered_set<string> dict;\\n    vector<string> ktov;\\n    unordered_map<string,vector<char>> vtok;\\n    Trie* d;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        ktov.assign(26,\"\");\\n        d = new Trie();\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            ktov[keys[i]-\\'a\\'] = values[i];\\n            vtok[values[i]].push_back(keys[i]);\\n        }\\n        for(auto& t:dictionary)\\n        {\\n            d->insert(t,ktov);\\n        }\\n            \\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto& w:word1)\\n        {\\n            ans += ktov[w-\\'a\\'];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return d->search(word2);\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass Trie{\\nprivate:\\n    unordered_map<string, Trie*> next; \\n    bool isWord = false;\\n    int match = 0;\\npublic:\\n    Trie(){}\\n    void insert(string word,vector<string>& ktov)\\n    {\\n        Trie* node = this;\\n        for(char& c:word)\\n        {\\n            if(node->next[ktov[c-\\'a\\']]==nullptr)\\n                node->next[ktov[c-\\'a\\']] = new Trie();\\n            node = node->next[ktov[c-\\'a\\']];\\n        }\\n        node->isWord = true;\\n        node->match++;\\n    }\\n    int search(string word)\\n    {\\n        Trie* node = this;\\n        for(int i=0;i<word.size();i+=2)\\n        {\\n            string now = word.substr(i,2);\\n            if(node->next[now]==nullptr)\\n                return 0;\\n            node = node->next[now];\\n        }\\n        return node->match;\\n    }\\n};\\nclass Encrypter {\\nprivate:\\n    unordered_set<string> dict;\\n    vector<string> ktov;\\n    unordered_map<string,vector<char>> vtok;\\n    Trie* d;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        ktov.assign(26,\"\");\\n        d = new Trie();\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            ktov[keys[i]-\\'a\\'] = values[i];\\n            vtok[values[i]].push_back(keys[i]);\\n        }\\n        for(auto& t:dictionary)\\n        {\\n            d->insert(t,ktov);\\n        }\\n            \\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto& w:word1)\\n        {\\n            ans += ktov[w-\\'a\\'];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return d->search(word2);\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910411,
                "title": "trie-but-failed-very-hard-time-limit",
                "content": "\\tclass Node{\\n\\tpublic:\\n\\t\\tbool isEnd;\\n\\t\\tNode* arr[26];\\n\\n\\t\\tNode(){\\n\\t\\t\\tisEnd = false;\\n\\t\\t\\tfor(int i=0;i<26;i++) {\\n\\t\\t\\t\\tarr[i] = NULL;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\tclass Encrypter {\\n\\t\\tNode* root;\\n\\t\\tunordered_map<char,string> keys;\\n\\t\\tunordered_map<string,vector<char> > values;\\n\\n\\t\\tvoid insert(string& s){\\n\\t\\t\\tNode* t = root;\\n\\t\\t\\tfor(int i=0;i<s.size();i++) {\\n\\t\\t\\t\\tif(t->arr[s[i] - \\'a\\'] == NULL) {\\n\\t\\t\\t\\t\\tt->arr[s[i] - \\'a\\'] = new Node();\\n\\t\\t\\t\\t}            \\n\\t\\t\\t\\tt = t->arr[s[i]-\\'a\\'];\\n\\t\\t\\t}\\n\\t\\t\\tt->isEnd = true;\\n\\t\\t}\\n\\n\\t\\tint decrypt(string& word,int i,Node* t){\\n\\t\\t\\tif(i >= word.size()) {\\n\\t\\t\\t\\treturn t->isEnd;\\n\\t\\t\\t}\\n\\t\\t\\tstring s = word.substr(i,2);\\n\\t\\t\\tint ans = 0;        \\n\\t\\t\\tfor(char& ch:values[s]) {\\n\\t\\t\\t\\tif(t->arr[ch - \\'a\\'] == NULL) continue;\\n\\t\\t\\t\\tans += decrypt(word, i+2, t->arr[ch - \\'a\\']);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\tpublic:\\n\\t\\tEncrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n\\t\\t\\t// Encrypter\\n\\t\\t\\tfor(int i=0;i<keys.size();i++) {\\n\\t\\t\\t\\tthis->keys[keys[i]] = values[i];\\n\\t\\t\\t\\tthis->values[values[i]].push_back(keys[i]);\\n\\t\\t\\t}\\n\\n\\t\\t\\troot = new Node();\\n\\t\\t\\tfor(string& it:dictionary){\\n\\t\\t\\t\\tinsert(it);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tstring encrypt(string word1) {\\n\\t\\t\\t// encrypt\\n\\t\\t\\tstring word = \"\";\\n\\t\\t\\tfor(char& c:word1){\\n\\t\\t\\t\\tword = word + keys[c]; \\n\\t\\t\\t}\\n\\t\\t\\treturn word;\\n\\t\\t}\\n\\n\\t\\tint decrypt(string word2) {\\n\\t\\t\\t// decrypt\\n\\t\\t\\treturn decrypt(word2, 0, root);\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Your Encrypter object will be instantiated and called as such:\\n\\t * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n\\t * string param_1 = obj->encrypt(word1);\\n\\t * int param_2 = obj->decrypt(word2);\\n\\t */",
                "solutionTags": [
                    "Trie"
                ],
                "code": "\\tclass Node{\\n\\tpublic:\\n\\t\\tbool isEnd;\\n\\t\\tNode* arr[26];\\n\\n\\t\\tNode(){\\n\\t\\t\\tisEnd = false;\\n\\t\\t\\tfor(int i=0;i<26;i++) {\\n\\t\\t\\t\\tarr[i] = NULL;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\tclass Encrypter {\\n\\t\\tNode* root;\\n\\t\\tunordered_map<char,string> keys;\\n\\t\\tunordered_map<string,vector<char> > values;\\n\\n\\t\\tvoid insert(string& s){\\n\\t\\t\\tNode* t = root;\\n\\t\\t\\tfor(int i=0;i<s.size();i++) {\\n\\t\\t\\t\\tif(t->arr[s[i] - \\'a\\'] == NULL) {\\n\\t\\t\\t\\t\\tt->arr[s[i] - \\'a\\'] = new Node();\\n\\t\\t\\t\\t}            \\n\\t\\t\\t\\tt = t->arr[s[i]-\\'a\\'];\\n\\t\\t\\t}\\n\\t\\t\\tt->isEnd = true;\\n\\t\\t}\\n\\n\\t\\tint decrypt(string& word,int i,Node* t){\\n\\t\\t\\tif(i >= word.size()) {\\n\\t\\t\\t\\treturn t->isEnd;\\n\\t\\t\\t}\\n\\t\\t\\tstring s = word.substr(i,2);\\n\\t\\t\\tint ans = 0;        \\n\\t\\t\\tfor(char& ch:values[s]) {\\n\\t\\t\\t\\tif(t->arr[ch - \\'a\\'] == NULL) continue;\\n\\t\\t\\t\\tans += decrypt(word, i+2, t->arr[ch - \\'a\\']);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\tpublic:\\n\\t\\tEncrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n\\t\\t\\t// Encrypter\\n\\t\\t\\tfor(int i=0;i<keys.size();i++) {\\n\\t\\t\\t\\tthis->keys[keys[i]] = values[i];\\n\\t\\t\\t\\tthis->values[values[i]].push_back(keys[i]);\\n\\t\\t\\t}\\n\\n\\t\\t\\troot = new Node();\\n\\t\\t\\tfor(string& it:dictionary){\\n\\t\\t\\t\\tinsert(it);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tstring encrypt(string word1) {\\n\\t\\t\\t// encrypt\\n\\t\\t\\tstring word = \"\";\\n\\t\\t\\tfor(char& c:word1){\\n\\t\\t\\t\\tword = word + keys[c]; \\n\\t\\t\\t}\\n\\t\\t\\treturn word;\\n\\t\\t}\\n\\n\\t\\tint decrypt(string word2) {\\n\\t\\t\\t// decrypt\\n\\t\\t\\treturn decrypt(word2, 0, root);\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Your Encrypter object will be instantiated and called as such:\\n\\t * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n\\t * string param_1 = obj->encrypt(word1);\\n\\t * int param_2 = obj->decrypt(word2);\\n\\t */",
                "codeTag": "Java"
            },
            {
                "id": 1910319,
                "title": "c-solution-with-trick-making-it-easiest-hard-problem",
                "content": "\\n\\n```\\n class Encrypter {\\npublic:\\n    //For mappint character with its index\\n    map<char,int> keys_mp;\\n    \\n    //For storing values array\\n    vector<string> val;\\n    //Dictionary map to store reverse mapping of dictonary words and its encryption count.\\n    map<string, int> dict_mp;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0; i<keys.size(); i++) keys_mp[keys[i]] = i;\\n        val = values;\\n        //Preparing map for encrypted dictionary word and its count\\n        for(string str: dictionary){\\n            dict_mp[encrypt(str)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(char ch: word1){\\n            ans += val[keys_mp[ch]];    \\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        if (dict_mp.find(word2) == dict_mp.end()) return 0;\\n        return dict_mp[word2];\\n    }\\n};\\n   \\n```",
                "solutionTags": [],
                "code": "```\\n class Encrypter {\\npublic:\\n    //For mappint character with its index\\n    map<char,int> keys_mp;\\n    \\n    //For storing values array\\n    vector<string> val;\\n    //Dictionary map to store reverse mapping of dictonary words and its encryption count.\\n    map<string, int> dict_mp;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0; i<keys.size(); i++) keys_mp[keys[i]] = i;\\n        val = values;\\n        //Preparing map for encrypted dictionary word and its count\\n        for(string str: dictionary){\\n            dict_mp[encrypt(str)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(char ch: word1){\\n            ans += val[keys_mp[ch]];    \\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        if (dict_mp.find(word2) == dict_mp.end()) return 0;\\n        return dict_mp[word2];\\n    }\\n};\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910089,
                "title": "map-c",
                "content": "```class Encrypter {\\npublic:\\n    map<string,int>dict;\\n    map<char,string>key;\\n    map<string,vector<char>>value;\\n    map<string,int>mp;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        dict.clear();\\n        key.clear();\\n        value.clear();\\n        for(auto &a:dictionary) dict[a]++;\\n        for(int i=0;i<keys.size();i++){\\n            key[keys[i]]=values[i];\\n            value[values[i]].push_back(keys[i]);\\n        }\\n        for(auto &a:dictionary){\\n            string ans=\"\";\\n            bool h=false;\\n            for(int i=0;i<a.size();i++){\\n                if(key.count(a[i])) ans+=key[a[i]];\\n                else h=true;\\n            }\\n            if(h) continue;\\n            mp[ans]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans=\"\";\\n        for(int i=0;i<word1.size();i++){\\n            if(key.count(word1[i])) ans+=key[word1[i]];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string word2) {\\n        if(!mp.count(word2)) return 0;\\n        return mp[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n ```",
                "solutionTags": [],
                "code": "```class Encrypter {\\npublic:\\n    map<string,int>dict;\\n    map<char,string>key;\\n    map<string,vector<char>>value;\\n    map<string,int>mp;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        dict.clear();\\n        key.clear();\\n        value.clear();\\n        for(auto &a:dictionary) dict[a]++;\\n        for(int i=0;i<keys.size();i++){\\n            key[keys[i]]=values[i];\\n            value[values[i]].push_back(keys[i]);\\n        }\\n        for(auto &a:dictionary){\\n            string ans=\"\";\\n            bool h=false;\\n            for(int i=0;i<a.size();i++){\\n                if(key.count(a[i])) ans+=key[a[i]];\\n                else h=true;\\n            }\\n            if(h) continue;\\n            mp[ans]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans=\"\";\\n        for(int i=0;i<word1.size();i++){\\n            if(key.count(word1[i])) ans+=key[word1[i]];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string word2) {\\n        if(!mp.count(word2)) return 0;\\n        return mp[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1910027,
                "title": "c-solution",
                "content": "\\tclass Encrypter {\\n    unordered_map<char, string> en;\\n    unordered_map<string, int> de;\\n\\n\\tpublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i = 0; i < keys.size(); i++)\\n            en[keys[i]] = values[i];\\n\\n        for(string s: dictionary)\\n            de[encrypt(s)]++;\\n    }\\n    \\n    string encrypt(string s) {\\n        string ans = \"\";\\n        \\n        for(char c: s)\\n            ans += en[c];\\n        \\n        return ans;\\n    }\\n    \\n    int decrypt(string s) {\\n        return de[s];\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "\\tclass Encrypter {\\n    unordered_map<char, string> en;\\n    unordered_map<string, int> de;\\n\\n\\tpublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i = 0; i < keys.size(); i++)\\n            en[keys[i]] = values[i];\\n\\n        for(string s: dictionary)\\n            de[encrypt(s)]++;\\n    }\\n    \\n    string encrypt(string s) {\\n        string ans = \"\";\\n        \\n        for(char c: s)\\n            ans += en[c];\\n        \\n        return ans;\\n    }\\n    \\n    int decrypt(string s) {\\n        return de[s];\\n    }\\n\\t};",
                "codeTag": "Java"
            },
            {
                "id": 1909945,
                "title": "c-encryption-hashmap-decryption-dfs-trie",
                "content": "**Prerequisite: TRIE**\\nEncrypting the string is straight forward, just store the string for each character in map and You are good to go. Also decryption of string is easy, the only difficult part is verifying the final string from the dictionary. \\n##### TLE for Set: \\nIf we use **set** to store and verify from dictionary, no doubt it will give the correct ans but using so will also increase our runtime. Because, before verifying we will 1st decrypt the whole string and after that we will verify from **Set**. By doing so we are doing redundent searches because its possible that the string doesn\\'t even exists in **set**. \\nSo, we need to find a way to decrypt the string word by word along with verification. Solution to this is Trie, as trie stores the string word by word and level by level.\\n#### Trie Solution:\\n1. Store each word of `dictionary` in trie\\n1. For decryption, use Trie along with DFS. \\n1. Take two character(given) at a time, find it\\'s decryption match from hashmap. Verify the if this character in the word exits in trie or not.\\n*  **Example**: We have a word in Trie, `word` = **\"abbccc\"**,(stored in trie like a->b->b->c->c->c) and we have formed the decrypted string till 3rd character like,`re` = **\"abb\"**. \\n*  Now suppose our next character after decryption is **\\'f\\'**, but **\\'f\\'** does exits in next sequence of characters in **trie**. So, we will stop our search here and **return** **0**. But if it matches, we will continue our search untill there are no more chararcter to decrypt. If we reach at the end of the string, check if the word exits, if it do, **return 1**.\\n\\nBelow is the Implementation.\\n```\\nclass trie {\\npublic:\\n    char c;\\n    int word; trie* arr[26];\\n    trie(char ch) {\\n        c= ch;\\n        word = 0;\\n        for(int i = 0; i<26;++i){\\n            arr[i]=NULL;\\n        }\\n    }\\n    \\n    void addWord(string s) {\\n        trie* temp = this;\\n        for(int i = 0; i<s.size();++i){\\n            if(temp->arr[s[i]-\\'a\\']!=NULL) temp = temp->arr[s[i]-\\'a\\'];\\n            else{\\n                trie* p = new trie(s[i]);\\n                temp->arr[s[i]-\\'a\\'] = p;\\n                temp=p;\\n            }\\n        }\\n        temp->word=1;\\n    }\\n};\\nclass Encrypter {\\n    map<char,string> mp;\\n    map<string,vector<char>> mp1;\\n    trie* root = NULL;\\n    \\n    int dfs(string &s,int in,trie* root){\\n        if(in>=s.size()) return root->word;\\n        string t = string(1,s[in])+string(1,s[in+1]);\\n        int ans = 0;\\n        vector<char>& temp = mp1[t];\\n        for(int i = 0; i<temp.size();++i){\\n            if(root->arr[temp[i]-\\'a\\']!=NULL){\\n                ans+= dfs(s,in+2,root->arr[temp[i]-\\'a\\']);\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        root = new trie(\\'*\\');\\n        for(int i = 0; i<dictionary.size();++i) root->addWord(dictionary[i]);\\n        for(int i = 0; i<keys.size();++i) mp[keys[i]] = values[i];\\n        for(int i = 0; i<values.size();++i) mp1[values[i]].push_back(keys[i]);\\n    }\\n    \\n    string encrypt(string s) {\\n        string re;\\n        for(int i = 0; i<s.size();++i) re+=mp[s[i]];\\n        return re;\\n    }\\n    \\n    int decrypt(string s) {\\n       return dfs(s,0,root);\\n    }\\n};\\n```\\n**Upvote if it Helps**",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass trie {\\npublic:\\n    char c;\\n    int word; trie* arr[26];\\n    trie(char ch) {\\n        c= ch;\\n        word = 0;\\n        for(int i = 0; i<26;++i){\\n            arr[i]=NULL;\\n        }\\n    }\\n    \\n    void addWord(string s) {\\n        trie* temp = this;\\n        for(int i = 0; i<s.size();++i){\\n            if(temp->arr[s[i]-\\'a\\']!=NULL) temp = temp->arr[s[i]-\\'a\\'];\\n            else{\\n                trie* p = new trie(s[i]);\\n                temp->arr[s[i]-\\'a\\'] = p;\\n                temp=p;\\n            }\\n        }\\n        temp->word=1;\\n    }\\n};\\nclass Encrypter {\\n    map<char,string> mp;\\n    map<string,vector<char>> mp1;\\n    trie* root = NULL;\\n    \\n    int dfs(string &s,int in,trie* root){\\n        if(in>=s.size()) return root->word;\\n        string t = string(1,s[in])+string(1,s[in+1]);\\n        int ans = 0;\\n        vector<char>& temp = mp1[t];\\n        for(int i = 0; i<temp.size();++i){\\n            if(root->arr[temp[i]-\\'a\\']!=NULL){\\n                ans+= dfs(s,in+2,root->arr[temp[i]-\\'a\\']);\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        root = new trie(\\'*\\');\\n        for(int i = 0; i<dictionary.size();++i) root->addWord(dictionary[i]);\\n        for(int i = 0; i<keys.size();++i) mp[keys[i]] = values[i];\\n        for(int i = 0; i<values.size();++i) mp1[values[i]].push_back(keys[i]);\\n    }\\n    \\n    string encrypt(string s) {\\n        string re;\\n        for(int i = 0; i<s.size();++i) re+=mp[s[i]];\\n        return re;\\n    }\\n    \\n    int decrypt(string s) {\\n       return dfs(s,0,root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909917,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(N * N), for decryption and O(N) for encryption***\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Encrypter {\\npublic:\\n    unordered_map<char, int> key;\\n    \\n    vector<string> value;\\n    \\n    vector<string> dictionary;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionarys) {\\n        \\n        for(int i = 0; i < keys.size(); i++)\\n        {\\n            key[keys[i]] = i;\\n        }\\n        \\n        value = values;\\n        \\n        dictionary = dictionarys;\\n    }\\n    \\n    string encrypt(string word1) {\\n        \\n        int n = word1.size();\\n        \\n        string res = \"\";\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            char c = word1[i];\\n            \\n            int idx = key[c];\\n            \\n            string str = value[idx];\\n            \\n            res += str;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        \\n        int res = 0;\\n        \\n        for(auto x : dictionary)\\n        {\\n            if(encrypt(x) == word2)\\n            {\\n                res++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char, int> key;\\n    \\n    vector<string> value;\\n    \\n    vector<string> dictionary;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionarys) {\\n        \\n        for(int i = 0; i < keys.size(); i++)\\n        {\\n            key[keys[i]] = i;\\n        }\\n        \\n        value = values;\\n        \\n        dictionary = dictionarys;\\n    }\\n    \\n    string encrypt(string word1) {\\n        \\n        int n = word1.size();\\n        \\n        string res = \"\";\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            char c = word1[i];\\n            \\n            int idx = key[c];\\n            \\n            string str = value[idx];\\n            \\n            res += str;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        \\n        int res = 0;\\n        \\n        for(auto x : dictionary)\\n        {\\n            if(encrypt(x) == word2)\\n            {\\n                res++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909883,
                "title": "java-simple-code-using-hashmap-100-faster-with-explaination",
                "content": "**Time Complexity :-\\nEncrypter:- O(nlog(n))\\nencrypt:- O(mlog(n)) ; m-> length of provided String\\ndecrypt:- O(mlog(n))\\n\\n**\\n\\n**Explanation :-**\\nComming Soon\\n\\n**JAVA Code :-**\\n```\\nclass Encrypter {\\n    HashMap<Character,String> map1;\\n    HashMap<String,ArrayList<Character>> map2;\\n    HashMap<String,Integer> map3;\\n    public Encrypter(char[] keys, String[] values, String[] dict) {\\n        map1 = new HashMap<>();\\n        map2 = new HashMap<>();\\n        map3 = new HashMap<>();\\n        for(int i=0;i<keys.length;i++) {\\n            map1.put(keys[i],values[i]);\\n            if(map2.containsKey(values[i])) {\\n                ArrayList<Character> list = map2.get(values[i]);\\n                list.add(keys[i]);\\n                map2.put(values[i],list);\\n            } else {\\n                ArrayList<Character> list = new ArrayList<>();\\n                list.add(keys[i]);\\n                map2.put(values[i],list);\\n            }\\n        }\\n        for(String s : dict) {\\n            String cd = encrypt(s);\\n            if(map3.containsKey(cd)) {\\n                map3.put(cd,map3.get(cd)+1);\\n            } else {\\n                map3.put(cd,1);\\n            }\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<word1.length();i++) {\\n            sb.append(map1.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        int ct=0;\\n        for(String k : map3.keySet()) {\\n            if(k.compareTo(word2)==0) {\\n                ct+=map3.get(k);\\n            }\\n        }\\n        return ct;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n ```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n    HashMap<Character,String> map1;\\n    HashMap<String,ArrayList<Character>> map2;\\n    HashMap<String,Integer> map3;\\n    public Encrypter(char[] keys, String[] values, String[] dict) {\\n        map1 = new HashMap<>();\\n        map2 = new HashMap<>();\\n        map3 = new HashMap<>();\\n        for(int i=0;i<keys.length;i++) {\\n            map1.put(keys[i],values[i]);\\n            if(map2.containsKey(values[i])) {\\n                ArrayList<Character> list = map2.get(values[i]);\\n                list.add(keys[i]);\\n                map2.put(values[i],list);\\n            } else {\\n                ArrayList<Character> list = new ArrayList<>();\\n                list.add(keys[i]);\\n                map2.put(values[i],list);\\n            }\\n        }\\n        for(String s : dict) {\\n            String cd = encrypt(s);\\n            if(map3.containsKey(cd)) {\\n                map3.put(cd,map3.get(cd)+1);\\n            } else {\\n                map3.put(cd,1);\\n            }\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<word1.length();i++) {\\n            sb.append(map1.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        int ct=0;\\n        for(String k : map3.keySet()) {\\n            if(k.compareTo(word2)==0) {\\n                ct+=map3.get(k);\\n            }\\n        }\\n        return ct;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1909756,
                "title": "c-trie",
                "content": "```\\nclass Encrypter {\\npublic:\\n    string charmap[26];\\n    vector<char> rmap[26][26];\\n    \\n    struct trienode{\\n        char c;\\n        trienode* child[26];\\n        bool isend;\\n        \\n        trienode(char cc){\\n            c = cc;\\n            for(int i=0;i<26;i++){\\n                child[i] =nullptr;\\n            }\\n            isend =false;\\n        }\\n        \\n        \\n        trienode(){\\n            c = \\'#\\';\\n            for(int i=0;i<26;i++){\\n                child[i] =nullptr;\\n            }\\n            isend =false;\\n        }\\n    }*root;\\n    \\n    void insert(trienode* root,string word){\\n        trienode* travel = root;\\n        \\n        for(int i=0;i<word.size();i++){\\n            int c = word[i]-\\'a\\';\\n            if(!travel->child[c]){\\n                travel->child[c] = new trienode(word[i]);\\n            }\\n            travel = travel->child[c];\\n        }\\n        travel->isend = true;\\n    }\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& words) {\\n        \\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                rmap[i][j].clear();\\n            }\\n        }\\n        for(int i=0;i<26;i++){\\n            charmap[i] = \"\";\\n        }\\n        \\n        for(int i=0;i<keys.size();i++){\\n            charmap[keys[i]-\\'a\\'] = values[i];\\n            rmap[values[i][0]-\\'a\\'][values[i][1]-\\'a\\'].push_back(keys[i]);\\n        }\\n        \\n        root = new trienode(\\'$\\');\\n        for(auto word : words){\\n            insert(root,word);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto c : word1){\\n            ans+=charmap[c-\\'a\\'];\\n        }\\n        return ans;\\n    }\\n    \\n    int dfs(string &word,int idx,trienode* travel){\\n        int n = word.size();\\n        \\n        if(!travel)return 0;\\n        \\n        if(idx==n){\\n            return travel->isend;\\n        }\\n        \\n        if(rmap[word[idx]-\\'a\\'][word[idx+1]-\\'a\\'].size()==0)return 0;\\n        \\n        int ans = 0;\\n        for(char c : rmap[word[idx]-\\'a\\'][word[idx+1]-\\'a\\']){\\n            ans+=dfs(word,idx+2,travel->child[c-\\'a\\']);  \\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return dfs(word2,0,root);\\n    }\\n};\\n\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */``\\n```\\n\\n**TIme Complexity of Encrypt : o(no of chars in given word)\\nTime Complexity of Decrypt : O((no_of chars in given word/2) * size_of_dictionary)**\\n\\nSince we are using Trie, there lies atmost size of dictionary paths at the end of last recursion call and other would have been pruned.\\n\\nThe max depth of recursion tree is no_of_chars/2 and max paths is size_of_dictionary.\\nHence Complexity is O((no_of chars in given word/2) * size_of_dictionary).\\n\\n**Note: If you dont pass word by reference in Decrypt dfs function call you would get TLE**",
                "solutionTags": [
                    "Depth-First Search",
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    string charmap[26];\\n    vector<char> rmap[26][26];\\n    \\n    struct trienode{\\n        char c;\\n        trienode* child[26];\\n        bool isend;\\n        \\n        trienode(char cc){\\n            c = cc;\\n            for(int i=0;i<26;i++){\\n                child[i] =nullptr;\\n            }\\n            isend =false;\\n        }\\n        \\n        \\n        trienode(){\\n            c = \\'#\\';\\n            for(int i=0;i<26;i++){\\n                child[i] =nullptr;\\n            }\\n            isend =false;\\n        }\\n    }*root;\\n    \\n    void insert(trienode* root,string word){\\n        trienode* travel = root;\\n        \\n        for(int i=0;i<word.size();i++){\\n            int c = word[i]-\\'a\\';\\n            if(!travel->child[c]){\\n                travel->child[c] = new trienode(word[i]);\\n            }\\n            travel = travel->child[c];\\n        }\\n        travel->isend = true;\\n    }\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& words) {\\n        \\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                rmap[i][j].clear();\\n            }\\n        }\\n        for(int i=0;i<26;i++){\\n            charmap[i] = \"\";\\n        }\\n        \\n        for(int i=0;i<keys.size();i++){\\n            charmap[keys[i]-\\'a\\'] = values[i];\\n            rmap[values[i][0]-\\'a\\'][values[i][1]-\\'a\\'].push_back(keys[i]);\\n        }\\n        \\n        root = new trienode(\\'$\\');\\n        for(auto word : words){\\n            insert(root,word);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto c : word1){\\n            ans+=charmap[c-\\'a\\'];\\n        }\\n        return ans;\\n    }\\n    \\n    int dfs(string &word,int idx,trienode* travel){\\n        int n = word.size();\\n        \\n        if(!travel)return 0;\\n        \\n        if(idx==n){\\n            return travel->isend;\\n        }\\n        \\n        if(rmap[word[idx]-\\'a\\'][word[idx+1]-\\'a\\'].size()==0)return 0;\\n        \\n        int ans = 0;\\n        for(char c : rmap[word[idx]-\\'a\\'][word[idx+1]-\\'a\\']){\\n            ans+=dfs(word,idx+2,travel->child[c-\\'a\\']);  \\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return dfs(word2,0,root);\\n    }\\n};\\n\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */``\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1834851,
                "content": [
                    {
                        "username": "matthewwdaly",
                        "content": "Testcases do not allow encrypting a word containing a letter not in the keys, even though we are specifically told to handle that edge case."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Think about storing dictionary in encrypted form."
                    }
                ]
            },
            {
                "id": 2043619,
                "content": [
                    {
                        "username": "matthewwdaly",
                        "content": "Testcases do not allow encrypting a word containing a letter not in the keys, even though we are specifically told to handle that edge case."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Think about storing dictionary in encrypted form."
                    }
                ]
            }
        ]
    },
    {
        "title": " Check if There Is a Valid Parentheses String Path",
        "question_content": "<p>A parentheses string is a <strong>non-empty</strong> string consisting only of <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>. It is <strong>valid</strong> if <strong>any</strong> of the following conditions is <strong>true</strong>:</p>\n\n<ul>\n\t<li>It is <code>()</code>.</li>\n\t<li>It can be written as <code>AB</code> (<code>A</code> concatenated with <code>B</code>), where <code>A</code> and <code>B</code> are valid parentheses strings.</li>\n\t<li>It can be written as <code>(A)</code>, where <code>A</code> is a valid parentheses string.</li>\n</ul>\n\n<p>You are given an <code>m x n</code> matrix of parentheses <code>grid</code>. A <strong>valid parentheses string path</strong> in the grid is a path satisfying <strong>all</strong> of the following conditions:</p>\n\n<ul>\n\t<li>The path starts from the upper left cell <code>(0, 0)</code>.</li>\n\t<li>The path ends at the bottom-right cell <code>(m - 1, n - 1)</code>.</li>\n\t<li>The path only ever moves <strong>down</strong> or <strong>right</strong>.</li>\n\t<li>The resulting parentheses string formed by the path is <strong>valid</strong>.</li>\n</ul>\n\n<p>Return <code>true</code> <em>if there exists a <strong>valid parentheses string path</strong> in the grid.</em> Otherwise, return <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/15/example1drawio.png\" style=\"width: 521px; height: 300px;\" />\n<pre>\n<strong>Input:</strong> grid = [[&quot;(&quot;,&quot;(&quot;,&quot;(&quot;],[&quot;)&quot;,&quot;(&quot;,&quot;)&quot;],[&quot;(&quot;,&quot;(&quot;,&quot;)&quot;],[&quot;(&quot;,&quot;(&quot;,&quot;)&quot;]]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The above diagram shows two possible paths that form valid parentheses strings.\nThe first path shown results in the valid parentheses string &quot;()(())&quot;.\nThe second path shown results in the valid parentheses string &quot;((()))&quot;.\nNote that there may be other valid parentheses string paths.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/15/example2drawio.png\" style=\"width: 165px; height: 165px;\" />\n<pre>\n<strong>Input:</strong> grid = [[&quot;)&quot;,&quot;)&quot;],[&quot;(&quot;,&quot;(&quot;]]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The two possible paths form the parentheses strings &quot;))(&quot; and &quot;)((&quot;. Since neither of them are valid parentheses strings, we return false.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>grid[i][j]</code> is either <code>&#39;(&#39;</code> or <code>&#39;)&#39;</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2017937,
                "title": "simple-dfs-dp",
                "content": "This problem can be solved by simply applying a DFS from top of the grid to bottom and keeping a count of \\'(\\' and \\')\\' as k.\\n\\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    int dp[100][100][205];\\n    bool solve(vector<vector<char>>& grid, int i, int j, int k)\\n    {\\n        if(i>=n || j>=m)\\n            return 0;\\n        \\n        if(grid[i][j]==\\'(\\')\\n            k++;\\n        else\\n            k--;\\n        \\n        if(k<0)\\n            return 0;\\n        \\n        if(i==n-1 && j==m-1)\\n            return (k==0);\\n        \\n        if(dp[i][j][k]!=-1)\\n            return dp[i][j][k];\\n        \\n        return dp[i][j][k]=(solve(grid, i+1, j, k) | solve(grid, i, j+1, k));\\n    }\\n    \\n    bool hasValidPath(vector<vector<char>>& grid)\\n    {\\n        n=grid.size();\\n        m=grid[0].size();\\n        memset(dp, -1, sizeof(dp));\\n        return solve(grid, 0, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n, m;\\n    int dp[100][100][205];\\n    bool solve(vector<vector<char>>& grid, int i, int j, int k)\\n    {\\n        if(i>=n || j>=m)\\n            return 0;\\n        \\n        if(grid[i][j]==\\'(\\')\\n            k++;\\n        else\\n            k--;\\n        \\n        if(k<0)\\n            return 0;\\n        \\n        if(i==n-1 && j==m-1)\\n            return (k==0);\\n        \\n        if(dp[i][j][k]!=-1)\\n            return dp[i][j][k];\\n        \\n        return dp[i][j][k]=(solve(grid, i+1, j, k) | solve(grid, i, j+1, k));\\n    }\\n    \\n    bool hasValidPath(vector<vector<char>>& grid)\\n    {\\n        n=grid.size();\\n        m=grid[0].size();\\n        memset(dp, -1, sizeof(dp));\\n        return solve(grid, 0, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017740,
                "title": "dfs",
                "content": "We run normal DFS, going left and right.\\n- We track the balance `bal` to check if the path is valid.\\n- If `bal` goes negative - we prune: orphan \\')\\'.\\n- if `bal` exceeds `(m + n) / 2` - we prune: too many \\'(\\' to close.\\n- If we reach the bottom-right corner, and `bal` is zero - we found a valid path.\\n\\nWe need to use memoisation (`visited`) so we do not explore the same cell with the same balance - otherwise we\\'ll get TLE.\\n\\n**C++**\\n```cpp\\nint visited[100][100][101] = {};\\nbool hasValidPath(vector<vector<char>>& grid, int i = 0, int j = 0, int bal = 0) {\\n    int m = grid.size(), n = grid[0].size();\\n    bal += grid[i][j] == \\'(\\' ? 1 : -1;\\n    if (bal < 0 || bal > (m + n) / 2 || visited[i][j][bal])\\n        return false;\\n    visited[i][j][bal] = true;\\n    if (i == m - 1 && j == n - 1 && bal == 0)\\n        return true;\\n    if (i < m - 1 && hasValidPath(grid, i + 1, j, bal))\\n        return true;\\n    if (j < n - 1 && hasValidPath(grid, i, j + 1, bal))\\n        return true;\\n    return false;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint visited[100][100][101] = {};\\nbool hasValidPath(vector<vector<char>>& grid, int i = 0, int j = 0, int bal = 0) {\\n    int m = grid.size(), n = grid[0].size();\\n    bal += grid[i][j] == \\'(\\' ? 1 : -1;\\n    if (bal < 0 || bal > (m + n) / 2 || visited[i][j][bal])\\n        return false;\\n    visited[i][j][bal] = true;\\n    if (i == m - 1 && j == n - 1 && bal == 0)\\n        return true;\\n    if (i < m - 1 && hasValidPath(grid, i + 1, j, bal))\\n        return true;\\n    if (j < n - 1 && hasValidPath(grid, i, j + 1, bal))\\n        return true;\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2017872,
                "title": "java-c-python-dp-solution",
                "content": "# **Explanation**\\nFor each ceel `A[i][j]`\\nwe count the number of open parenthese for the path reaching `A[i][j]`.\\nIf it\\'s negative, it\\'s not valid already.\\nFinally we check if there is a path to `A[m-1][n-1]` that has no open parenthese,\\nthat means a valid parentheses string path reaching `A[m-1][n-1]`.\\n<br>\\n\\n# **Optimisation**\\nI usually don\\'t handle edge cases specially,\\nsince they can be correctly handled by itself.\\nAnd usually the short cut only improve edge case, not general case,\\n\\nHere are 3 quick fail case:\\nIf `(n + m) % 2 == 0`, the length of path to `A[m-1][n-1]` is odd, can return false.\\nIf `A[-1][-1] == \\'(\\'`, no valid start can return false.\\nIf `A[0][0] == \\')\\'`, no valid end, can return false.\\n<br>\\n\\n# **Complexity**\\nTime `O(mn(m+n))`\\nSpace `O(mn(m+n))`\\n<br>\\n\\n**Java**\\nEdited from @arignote solution.\\n\\nTrick 1: \\nA[i][j][0] for the path count -1,\\nA[i][j][1] for the path count 0, etc.\\nNo need to handle negative specially.\\n\\nTrick 2: \\nUse something like `A[i+1] += A[i]` instead of `A[i] = A[i-1]`\\nNo need to handle `i == 0` and `j == 0` specially.\\n\\nTrick 3: \\n`dp[m][n - 1]` and `dp[m - 1][n]` are from `dp[m - 1][n - 1]`,\\nreturn `dp[m][n - 1][1]` for the result.\\n\\n```java\\n    public boolean hasValidPath(char[][] A) {\\n        int m = A.length, n = A[0].length;\\n        boolean[][][] dp = new boolean[m + 1][n + 1][103];\\n        dp[0][0][1] = true;\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                for (int k = 1; k <= 101; ++k) {\\n                    dp[i][j + 1][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                    dp[i + 1][j][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                }\\n        return dp[m][n - 1][1];\\n    }\\n```\\n**C++**\\nEdited from @agrinote, explained above.\\n```cpp\\n    bool hasValidPath(vector<vector<char>>& A) {\\n        int m = A.size(), n = A[0].size(), maxk = (m + n + 1) / 2;\\n        vector<vector<vector<int>>> dp(m + 1, vector<vector<int>>(n + 1, vector<int>(maxk + 10)));\\n        dp[0][0][1] = 1;\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                for (int k = 1; k <= maxk; ++k) {\\n                    dp[i][j + 1][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                    dp[i + 1][j][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                }\\n        return dp[m][n - 1][1];        \\n    }\\n```\\n\\n**Python**\\nUsing `set` are faster, since most path are not valid.\\n```py\\n    def hasValidPath(self, A):\\n        m, n = len(A), len(A[0])\\n        dp = defaultdict(set)\\n        dp[0, -1] = dp[-1, 0] = {0}\\n        for i in range(m):\\n            for j in range(n):\\n                d = 1 if A[i][j] == \\'(\\' else -1\\n                dp[i,j] |= {a + d for a in dp[i-1,j] | dp[i,j-1] if a + d >= 0}\\n        return 0 in dp[m - 1, n - 1]\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public boolean hasValidPath(char[][] A) {\\n        int m = A.length, n = A[0].length;\\n        boolean[][][] dp = new boolean[m + 1][n + 1][103];\\n        dp[0][0][1] = true;\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                for (int k = 1; k <= 101; ++k) {\\n                    dp[i][j + 1][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                    dp[i + 1][j][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                }\\n        return dp[m][n - 1][1];\\n    }\\n```\n```cpp\\n    bool hasValidPath(vector<vector<char>>& A) {\\n        int m = A.size(), n = A[0].size(), maxk = (m + n + 1) / 2;\\n        vector<vector<vector<int>>> dp(m + 1, vector<vector<int>>(n + 1, vector<int>(maxk + 10)));\\n        dp[0][0][1] = 1;\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                for (int k = 1; k <= maxk; ++k) {\\n                    dp[i][j + 1][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                    dp[i + 1][j][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                }\\n        return dp[m][n - 1][1];        \\n    }\\n```\n```py\\n    def hasValidPath(self, A):\\n        m, n = len(A), len(A[0])\\n        dp = defaultdict(set)\\n        dp[0, -1] = dp[-1, 0] = {0}\\n        for i in range(m):\\n            for j in range(n):\\n                d = 1 if A[i][j] == \\'(\\' else -1\\n                dp[i,j] |= {a + d for a in dp[i-1,j] | dp[i,j-1] if a + d >= 0}\\n        return 0 in dp[m - 1, n - 1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2018503,
                "title": "c-extremely-fast-short-2-loops-dp",
                "content": "You can refer to other posts for basic 3D DP solution. Here I optimize the 3D DP with two tricks:\\n\\n* Early return if the length of path is odd\\n* Use `bitset` with each bit representing a possible number of open parenthesis. When we meet a new opening `\\'(\\'`, we should add one more open parenthesis to all previous memorized result. With `bitset` we simply left shift. Similarly, For `\\')\\'` we right shift.\\n\\n```\\nbool hasValidPath(vector<vector<char>>& grid) {\\n    int m = grid.size(), n = grid[0].size();\\n    if ((m + n - 1) % 2) // early return for odd length path\\n        return false;\\n    vector<bitset<100>> dp(n + 1);\\n    for (int i = 0; i < m; i++) {\\n        dp[0][0] = !i;\\n        for (int j = 0; j < n; j++)\\n            dp[j + 1] = grid[i][j] == \\'(\\' ? (dp[j] | dp[j + 1]) << 1: (dp[j] | dp[j + 1]) >> 1;\\n    }\\n    return dp[n][0];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool hasValidPath(vector<vector<char>>& grid) {\\n    int m = grid.size(), n = grid[0].size();\\n    if ((m + n - 1) % 2) // early return for odd length path\\n        return false;\\n    vector<bitset<100>> dp(n + 1);\\n    for (int i = 0; i < m; i++) {\\n        dp[0][0] = !i;\\n        for (int j = 0; j < n; j++)\\n            dp[j + 1] = grid[i][j] == \\'(\\' ? (dp[j] | dp[j + 1]) << 1: (dp[j] | dp[j + 1]) >> 1;\\n    }\\n    return dp[n][0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018005,
                "title": "python-simple-memoisation-caching",
                "content": "There are two main parts of the solution:\\n1. Logic to determine whether a sequence is [Balanced Paranteses](https://leetcode.com/problems/valid-parentheses/). This can be achieved using `Stack`(`O(N) space`) or using a `counter` variable(`O(1) space`). I will be using the latter.\\n2. A recursive function to check the existence of a valid parantheses sequence in the input `grid`.\\n\\n\\n\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:  \\n        m = len(grid)\\n        n = len(grid[0])\\n        @lru_cache(maxsize=None)\\n        def hasValidPathInner(x, y, cnt):\\n            # cnt variable would act as a counter to track \\n            # the balance of parantheses sequence\\n            if x == m or y == n or cnt < 0:\\n                return False\\n            \\n            # logic to check the balance of sequence\\n            cnt += 1 if grid[x][y] == \\'(\\' else -1\\n            \\n            # if balanced and end of grid, return True\\n            if x == m - 1 and y == n - 1 and not cnt:\\n                return True\\n            \\n            return hasValidPathInner(x + 1, y, cnt) or hasValidPathInner(x, y + 1, cnt)\\n\\n        return hasValidPathInner(0, 0, 0)\\n```\\n\\n**Time = O(mn(m+n))** - Due to memoization, the same path won\\'t be visited twice. `M + N` is the max length of a sequence or max depth of recursive stack from `0,0` to `m-1,n-1` in the `grid` \\n**Space = O(mn(m+n))**\\n\\n\\n----\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:  \\n        m = len(grid)\\n        n = len(grid[0])\\n        @lru_cache(maxsize=None)\\n        def hasValidPathInner(x, y, cnt):\\n            # cnt variable would act as a counter to track \\n            # the balance of parantheses sequence\\n            if x == m or y == n or cnt < 0:\\n                return False\\n            \\n            # logic to check the balance of sequence\\n            cnt += 1 if grid[x][y] == \\'(\\' else -1\\n            \\n            # if balanced and end of grid, return True\\n            if x == m - 1 and y == n - 1 and not cnt:\\n                return True\\n            \\n            return hasValidPathInner(x + 1, y, cnt) or hasValidPathInner(x, y + 1, cnt)\\n\\n        return hasValidPathInner(0, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018115,
                "title": "memoization",
                "content": "**if at any point open < 0 then the path is not balanced.**\\n\\n```\\nclass Solution {\\n    int m, n;\\n    int memo[101][101][201];\\npublic:\\n    bool doit(vector<vector<char>>& grid, int i, int j, int open) {\\n        \\n        open += grid[i][j] == \\'(\\' ? 1 : -1;\\n        if (open < 0)   return false;\\n        if (memo[i][j][open] != -1) return memo[i][j][open];\\n        if (i == m-1 and j == n-1 and open == 0)    return true;\\n        if (i < m-1 and doit(grid, i+1, j, open))   return memo[i][j][open] = true;\\n        if (j < n-1 and doit(grid, i, j+1, open))   return memo[i][j][open] = true;\\n        return memo[i][j][open] = false;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        \\n        memset(memo, -1, sizeof memo);\\n        m = size(grid), n = size(grid[0]);\\n        if((m+n-1)&1) return false;\\n        return doit(grid, 0, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int m, n;\\n    int memo[101][101][201];\\npublic:\\n    bool doit(vector<vector<char>>& grid, int i, int j, int open) {\\n        \\n        open += grid[i][j] == \\'(\\' ? 1 : -1;\\n        if (open < 0)   return false;\\n        if (memo[i][j][open] != -1) return memo[i][j][open];\\n        if (i == m-1 and j == n-1 and open == 0)    return true;\\n        if (i < m-1 and doit(grid, i+1, j, open))   return memo[i][j][open] = true;\\n        if (j < n-1 and doit(grid, i, j+1, open))   return memo[i][j][open] = true;\\n        return memo[i][j][open] = false;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        \\n        memset(memo, -1, sizeof memo);\\n        m = size(grid), n = size(grid[0]);\\n        if((m+n-1)&1) return false;\\n        return doit(grid, 0, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017812,
                "title": "same-as-valid-parenthesis-string-but-with-memo-o-mn-m-n",
                "content": "**Intuition:** Same as checking valid parenthesis in a string. Need to maintain a counter \"open\" to mark the number of opening/closing braces encountered. If \\'(\\' is encountered incr. open by 1, else decrement open by 1. Now as there can be several paths possible from each cell in a grid, so there can be multiple repeated calculations done from each cell. To avoid that use DP/Memoisation.\\nDP array has 3 states: row, col, open count. Since open count can be maximum of 199(complete first row + complete last column), so taking 201.\\n\\n```\\nCode: \\nclass Solution {\\npublic:\\n    int dp[101][101][201];\\t\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        memset(dp, -1, sizeof(dp));\\n        return isPossible(grid, 0, 0, 0);\\n    }\\n    \\n    bool isPossible(vector<vector<char>>& grid, int i, int j, int open) {\\n        if(i == grid.size() || j == grid[0].size())\\n            return false;\\n        if(grid[i][j] == \\')\\' && open == 0)\\n            return false;\\n        if(i == grid.size()-1 && j == grid[0].size()-1) \\n            return open+(grid[i][j] == \\'(\\' ? 1 : -1) == 0;\\n        if(dp[i][j][open] != -1)\\n            return dp[i][j][open];\\n        return dp[i][j][open] = isPossible(grid, i+1, j, open+(grid[i][j] == \\'(\\' ? 1 : -1)) ||  // down\\n                                isPossible(grid, i, j+1, open+(grid[i][j] == \\'(\\' ? 1 : -1));\\t// right\\n    }\\n};\\n```\\n\\nKindly upvote if helpful to keep me motivated ^-^. Also comment down for any doubts.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nCode: \\nclass Solution {\\npublic:\\n    int dp[101][101][201];\\t\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        memset(dp, -1, sizeof(dp));\\n        return isPossible(grid, 0, 0, 0);\\n    }\\n    \\n    bool isPossible(vector<vector<char>>& grid, int i, int j, int open) {\\n        if(i == grid.size() || j == grid[0].size())\\n            return false;\\n        if(grid[i][j] == \\')\\' && open == 0)\\n            return false;\\n        if(i == grid.size()-1 && j == grid[0].size()-1) \\n            return open+(grid[i][j] == \\'(\\' ? 1 : -1) == 0;\\n        if(dp[i][j][open] != -1)\\n            return dp[i][j][open];\\n        return dp[i][j][open] = isPossible(grid, i+1, j, open+(grid[i][j] == \\'(\\' ? 1 : -1)) ||  // down\\n                                isPossible(grid, i, j+1, open+(grid[i][j] == \\'(\\' ? 1 : -1));\\t// right\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017824,
                "title": "java-solution-using-dp",
                "content": "```\\nclass Solution {\\n    static Boolean[][][] dp;\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        dp = new Boolean[101][101][201];  // [row][col][open-close]\\n        if(grid[0][0] == \\')\\'){   // cannot start with \\')\\'\\n            return false;\\n        }\\n        if(grid[m-1][n-1] == \\'(\\'){  // cannot end with \\'(\\' \\n            return false;\\n        }\\n        return solve(grid,0,0,m,n,0,0);\\n    }\\n    public static boolean solve(char[][] grid,int i,int j,int m,int n,int open,int close){\\n        if(grid[i][j] == \\'(\\'){\\n            open++;\\n        }\\n        else{\\n            close++;\\n        }\\n        if(close > open){  // at any point if closeBracket count exceeds openBracket count then return false since this path can never lead to valid paranthesis string\\n            return false;\\n        }\\n        if(i == m-1 && j == n-1){  // on reaching bottom right cell if openCount == closeCount return true else return false\\n            return open == close;\\n        }\\n        if(dp[i][j][open-close] != null){  // check for precomputed overlapping subproblem\\n            return dp[i][j][open-close];\\n        }\\n        if(i == m-1){   // make sure to not go out of the grid in last row\\n            return dp[i][j][open-close] = solve(grid,i,j+1,m,n,open,close);\\n        }\\n        if(j == n-1){  // make sure to not go out of the grid in last col\\n            return dp[i][j][open-close] = solve(grid,i+1,j,m,n,open,close);\\n        }\\n        boolean op = solve(grid,i+1,j,m,n,open,close) || solve(grid,i,j+1,m,n,open,close); // we have two choices to move forward, [i+1][j] or [i][j+1]\\n        return dp[i][j][open-close] = op;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    static Boolean[][][] dp;\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        dp = new Boolean[101][101][201];  // [row][col][open-close]\\n        if(grid[0][0] == \\')\\'){   // cannot start with \\')\\'\\n            return false;\\n        }\\n        if(grid[m-1][n-1] == \\'(\\'){  // cannot end with \\'(\\' \\n            return false;\\n        }\\n        return solve(grid,0,0,m,n,0,0);\\n    }\\n    public static boolean solve(char[][] grid,int i,int j,int m,int n,int open,int close){\\n        if(grid[i][j] == \\'(\\'){\\n            open++;\\n        }\\n        else{\\n            close++;\\n        }\\n        if(close > open){  // at any point if closeBracket count exceeds openBracket count then return false since this path can never lead to valid paranthesis string\\n            return false;\\n        }\\n        if(i == m-1 && j == n-1){  // on reaching bottom right cell if openCount == closeCount return true else return false\\n            return open == close;\\n        }\\n        if(dp[i][j][open-close] != null){  // check for precomputed overlapping subproblem\\n            return dp[i][j][open-close];\\n        }\\n        if(i == m-1){   // make sure to not go out of the grid in last row\\n            return dp[i][j][open-close] = solve(grid,i,j+1,m,n,open,close);\\n        }\\n        if(j == n-1){  // make sure to not go out of the grid in last col\\n            return dp[i][j][open-close] = solve(grid,i+1,j,m,n,open,close);\\n        }\\n        boolean op = solve(grid,i+1,j,m,n,open,close) || solve(grid,i,j+1,m,n,open,close); // we have two choices to move forward, [i+1][j] or [i][j+1]\\n        return dp[i][j][open-close] = op;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017743,
                "title": "c-two-solution-bfs-and-dp-dp-and-memoization",
                "content": "**first bfs solution**\\n```\\nclass Solution {\\npublic:\\n    int n,m;\\n    bool hasValidPath(vector<vector<char>>& mat) \\n    {\\n        vector<pair<int,int>>d={{0,1},{1,0}};\\n        n=mat.size();\\n        m=mat[0].size();\\n        queue<tuple<int,int,int>>q;\\n        if(mat[0][0]==\\'(\\')\\n        {\\n        q.push({0,0,1});\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n        int dp[111][111][311];\\n        memset(dp,-1,sizeof(dp));\\n        dp[0][0][1]=1;\\n        while(q.size())\\n        {\\n            auto [x,y,b]=q.front();\\n            q.pop();\\n            if(b<0)\\n            {\\n                continue;\\n            }\\n            if(x==n-1&&y==m-1)\\n            {\\n                if(b==0)\\n                {\\n                    return true;\\n                }\\n            }\\n            for(auto it:d)\\n            {\\n                int nx=x+it.first;\\n                int ny=y+it.second;\\n                if(b<0)\\n                {\\n                    continue;\\n                }\\n                if(nx>=0&&ny>=0&&nx<n&&ny<m&&dp[nx][ny][b]==-1)\\n                {\\n                    if(b>=0&&b<=n*m)\\n                    dp[nx][ny][b]=1;\\n                    if(mat[nx][ny]==\\'(\\')\\n                    {\\n                        q.push({nx,ny,b+1});\\n                    }\\n                    else\\n                    {\\n                        q.push({nx,ny,b-1});\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n**second dp solution using memoization**\\n```\\nclass Solution {\\npublic:\\n    int n,m;\\n    int dp[101][101][200];\\n    bool find(vector<vector<char>>& mat,int row,int col,int open)\\n    {\\n        if(row<0||col<0||row>=n||col>=m||open<0)\\n        {\\n            return false;\\n        }\\n        if(dp[row][col][open]!=-1)\\n        {\\n            return dp[row][col][open];\\n        }\\n        if(row==n-1&&col==m-1)\\n        {\\n            if(mat[row][col]==\\'(\\')\\n            {\\n                open++;\\n            }\\n            else \\n            {\\n                open--;\\n            }\\n            return open==0;\\n        }\\n        if(mat[row][col]==\\'(\\')\\n        {\\n            if(find(mat,row+1,col,open+1)||find(mat,row,col+1,open+1))\\n            {\\n                return true;\\n            }\\n        }\\n        else\\n        {\\n            if(find(mat,row+1,col,open-1)||find(mat,row,col+1,open-1))\\n            {\\n                return true;\\n            }\\n        }\\n        return dp[row][col][open]=false;\\n    }\\n    bool hasValidPath(vector<vector<char>>& mat) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        n=mat.size();\\n        m=mat[0].size();\\n        return find(mat,0,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    bool hasValidPath(vector<vector<char>>& mat) \\n    {\\n        vector<pair<int,int>>d={{0,1},{1,0}};\\n        n=mat.size();\\n        m=mat[0].size();\\n        queue<tuple<int,int,int>>q;\\n        if(mat[0][0]==\\'(\\')\\n        {\\n        q.push({0,0,1});\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n        int dp[111][111][311];\\n        memset(dp,-1,sizeof(dp));\\n        dp[0][0][1]=1;\\n        while(q.size())\\n        {\\n            auto [x,y,b]=q.front();\\n            q.pop();\\n            if(b<0)\\n            {\\n                continue;\\n            }\\n            if(x==n-1&&y==m-1)\\n            {\\n                if(b==0)\\n                {\\n                    return true;\\n                }\\n            }\\n            for(auto it:d)\\n            {\\n                int nx=x+it.first;\\n                int ny=y+it.second;\\n                if(b<0)\\n                {\\n                    continue;\\n                }\\n                if(nx>=0&&ny>=0&&nx<n&&ny<m&&dp[nx][ny][b]==-1)\\n                {\\n                    if(b>=0&&b<=n*m)\\n                    dp[nx][ny][b]=1;\\n                    if(mat[nx][ny]==\\'(\\')\\n                    {\\n                        q.push({nx,ny,b+1});\\n                    }\\n                    else\\n                    {\\n                        q.push({nx,ny,b-1});\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int n,m;\\n    int dp[101][101][200];\\n    bool find(vector<vector<char>>& mat,int row,int col,int open)\\n    {\\n        if(row<0||col<0||row>=n||col>=m||open<0)\\n        {\\n            return false;\\n        }\\n        if(dp[row][col][open]!=-1)\\n        {\\n            return dp[row][col][open];\\n        }\\n        if(row==n-1&&col==m-1)\\n        {\\n            if(mat[row][col]==\\'(\\')\\n            {\\n                open++;\\n            }\\n            else \\n            {\\n                open--;\\n            }\\n            return open==0;\\n        }\\n        if(mat[row][col]==\\'(\\')\\n        {\\n            if(find(mat,row+1,col,open+1)||find(mat,row,col+1,open+1))\\n            {\\n                return true;\\n            }\\n        }\\n        else\\n        {\\n            if(find(mat,row+1,col,open-1)||find(mat,row,col+1,open-1))\\n            {\\n                return true;\\n            }\\n        }\\n        return dp[row][col][open]=false;\\n    }\\n    bool hasValidPath(vector<vector<char>>& mat) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        n=mat.size();\\n        m=mat[0].size();\\n        return find(mat,0,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018172,
                "title": "dfs-memo",
                "content": "* If `g[i][j] == \\'(\\'` then o++ (increment openings)\\nelse o-- (decrement openings) \\n* At max brackets will be manhattan distance from last cell to 0th cell\\n\\t i.e., `r-1 + c-1 => r+c-2`\\n* Prune when `o>max or o<0`\\n```\\nclass Solution {\\n\\n    public boolean hasValidPath(char[][] grid) {\\n        int r = grid.length;\\n        int c = grid[0].length;\\n        max = (r + c) - 2;\\n        dp = new Boolean[r + 1][c + 1][max + 1];\\n        return solve(0, 0, grid, 0);\\n    }\\n\\n    int max = 0;\\n    Boolean dp[][][];\\n\\n    private boolean solve(int i, int j, char g[][], int open) {\\n        if (i < 0 || j < 0 || i >= g.length || j >= g[0].length) return false;\\n        if (open < 0 || open > max) return false;\\n        if (dp[i][j][open] != null) return dp[i][j][open];\\n        if (i == g.length - 1 && j == g[0].length - 1) {\\n            if (g[i][j] == \\'(\\') open++; else open--;\\n            return open == 0;\\n        }\\n        if (g[i][j] == \\'(\\') return dp[i][j][open] = solve(i + 1, j, g, open + 1) || solve(i, j + 1, g, open + 1);\\n        return dp[i][j][open] = solve(i + 1, j, g, open - 1) || solve(i, j + 1, g, open - 1);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\n    public boolean hasValidPath(char[][] grid) {\\n        int r = grid.length;\\n        int c = grid[0].length;\\n        max = (r + c) - 2;\\n        dp = new Boolean[r + 1][c + 1][max + 1];\\n        return solve(0, 0, grid, 0);\\n    }\\n\\n    int max = 0;\\n    Boolean dp[][][];\\n\\n    private boolean solve(int i, int j, char g[][], int open) {\\n        if (i < 0 || j < 0 || i >= g.length || j >= g[0].length) return false;\\n        if (open < 0 || open > max) return false;\\n        if (dp[i][j][open] != null) return dp[i][j][open];\\n        if (i == g.length - 1 && j == g[0].length - 1) {\\n            if (g[i][j] == \\'(\\') open++; else open--;\\n            return open == 0;\\n        }\\n        if (g[i][j] == \\'(\\') return dp[i][j][open] = solve(i + 1, j, g, open + 1) || solve(i, j + 1, g, open + 1);\\n        return dp[i][j][open] = solve(i + 1, j, g, open - 1) || solve(i, j + 1, g, open - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021277,
                "title": "6-short-lines-python-bitsets",
                "content": "Using ints as bitsets, where bit `i` being 1 means that we can reach the grid cell with `i` parentheses opened. Always take the union of the left cell\\'s and upper cell\\'s bitset, and shift it left or right depending on the cell\\'s parenthesis.\\n\\n**Solution 1, bottom-up DP**\\n\\nInstead of a 2D dp array, I just keep its latest row. \\n\\n    def hasValidPath(_, A):\\n        dp = [1] + [0] * 99\\n        for row in A:\\n            L = 0\\n            dp = [L := (lshift, rshift)[a == \\')\\'](L | U, 1)\\n                  for a, U in zip(row, dp)]\\n        return dp[-1] & 1\\n\\n**Solution 2, top-down with memoization**\\n\\n    def hasValidPath(_, A):\\n        @cache\\n        def dp(i, j):\\n            if i < 0 or j < 0:\\n                return i == 0\\n            return (lshift, rshift)[A[i][j] == \\')\\'](dp(i-1, j) | dp(i, j-1), 1)\\n        return dp(len(A)-1, len(A[0])-1) & 1",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "Using ints as bitsets, where bit `i` being 1 means that we can reach the grid cell with `i` parentheses opened. Always take the union of the left cell\\'s and upper cell\\'s bitset, and shift it left or right depending on the cell\\'s parenthesis.\\n\\n**Solution 1, bottom-up DP**\\n\\nInstead of a 2D dp array, I just keep its latest row. \\n\\n    def hasValidPath(_, A):\\n        dp = [1] + [0] * 99\\n        for row in A:\\n            L = 0\\n            dp = [L := (lshift, rshift)[a == \\')\\'](L | U, 1)\\n                  for a, U in zip(row, dp)]\\n        return dp[-1] & 1\\n\\n**Solution 2, top-down with memoization**\\n\\n    def hasValidPath(_, A):\\n        @cache\\n        def dp(i, j):\\n            if i < 0 or j < 0:\\n                return i == 0\\n            return (lshift, rshift)[A[i][j] == \\')\\'](dp(i-1, j) | dp(i, j-1), 1)\\n        return dp(len(A)-1, len(A[0])-1) & 1",
                "codeTag": "Python3"
            },
            {
                "id": 2018906,
                "title": "c-simple-bfs-dp-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        \\n        queue<tuple<int,int,int>> q;\\n        int visited[100][100][101] = {};\\n        \\n        int row=grid.size();\\n        int col=grid[0].size();\\n        \\n        if(grid[0][0]==\\'(\\') q.push({0,0,1});\\n        else return false;\\n        \\n        while(!q.empty()){\\n            \\n            auto [Nx,Ny,b]=q.front();\\n            q.pop();\\n            \\n            if(b<0 or b>(row+col)/2 or visited[Nx][Ny][b]) continue;\\n            visited[Nx][Ny][b] = true;\\n\\n            if(Nx==row-1 and Ny==col-1 and b==0) return true;\\n            \\n            if(Nx+1<row){\\n                if(grid[Nx+1][Ny]==\\'(\\') q.push({Nx+1,Ny,b+1});\\n                else q.push({Nx+1,Ny,b-1});\\n            }\\n            if(Ny+1<col){\\n                if(grid[Nx][Ny+1]==\\'(\\') q.push({Nx,Ny+1,b+1});\\n                else q.push({Nx,Ny+1,b-1});\\n            }\\n            \\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        \\n        queue<tuple<int,int,int>> q;\\n        int visited[100][100][101] = {};\\n        \\n        int row=grid.size();\\n        int col=grid[0].size();\\n        \\n        if(grid[0][0]==\\'(\\') q.push({0,0,1});\\n        else return false;\\n        \\n        while(!q.empty()){\\n            \\n            auto [Nx,Ny,b]=q.front();\\n            q.pop();\\n            \\n            if(b<0 or b>(row+col)/2 or visited[Nx][Ny][b]) continue;\\n            visited[Nx][Ny][b] = true;\\n\\n            if(Nx==row-1 and Ny==col-1 and b==0) return true;\\n            \\n            if(Nx+1<row){\\n                if(grid[Nx+1][Ny]==\\'(\\') q.push({Nx+1,Ny,b+1});\\n                else q.push({Nx+1,Ny,b-1});\\n            }\\n            if(Ny+1<col){\\n                if(grid[Nx][Ny+1]==\\'(\\') q.push({Nx,Ny+1,b+1});\\n                else q.push({Nx,Ny+1,b-1});\\n            }\\n            \\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018305,
                "title": "java-dfs-memoization-easy-to-understand",
                "content": "```\\nclass Solution {\\n    boolean[][][] vis = new boolean[100][100][101];\\n    boolean isValid(char[][] grid, int i, int j, int count){\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        count += grid[i][j]==\\'(\\' ? 1 : -1;\\n        if(count < 0 || count > (n+m)/2 || vis[i][j][count]) return false;\\n        vis[i][j][count] = true;\\n\\t\\t\\n        if(count==0 && i==n-1 &&  j==m-1) return true;\\n        if(i < n-1 && isValid(grid,i+1,j,count)) return true;\\n        if(j < m-1 && isValid(grid,i,j+1,count)) return true;\\n        return false;\\n    }\\n    public boolean hasValidPath(char[][] grid) {\\n        return isValid(grid, 0, 0, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    boolean[][][] vis = new boolean[100][100][101];\\n    boolean isValid(char[][] grid, int i, int j, int count){\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        count += grid[i][j]==\\'(\\' ? 1 : -1;\\n        if(count < 0 || count > (n+m)/2 || vis[i][j][count]) return false;\\n        vis[i][j][count] = true;\\n\\t\\t\\n        if(count==0 && i==n-1 &&  j==m-1) return true;\\n        if(i < n-1 && isValid(grid,i+1,j,count)) return true;\\n        if(j < m-1 && isValid(grid,i,j+1,count)) return true;\\n        return false;\\n    }\\n    public boolean hasValidPath(char[][] grid) {\\n        return isValid(grid, 0, 0, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018132,
                "title": "python3-short-dp-6-lines-explained",
                "content": "### Explanation:\\n* `k` denotes the running sum of the parentheses. For each `(`, add +1 for each `)` add -1\\n* At any point `k` should not be less than 0 else valid parentheses beyond that point is not possible\\n*  If `(A[i][j] == \\')\\' and k < 1)` k will become < 0 when we perform k - 1, so we return `False`\\n*  `if i == m - 1 and j == n - 1: return A[i][j] == \\')\\' and k == 1` If we are on the last cell return `True` if last cell contains `)` and `k == 1`. `k - 1` will be `= 0` which will mean parentheses are balanced. For every other case on last cell, we return `False` \\n*  The `any()` function returns True if any item in an iterable are true, otherwise it returns False.\\n\\n```\\ndef hasValidPath(self, A: List[List[str]]) -> bool:\\n\\t@cache\\n\\tdef dfs(i, j, k):\\n\\t\\tif i >= len(A) or j >= len(A[0]) or (A[i][j] == \\')\\' and k < 1): return False\\n\\t\\tif i == len(A) - 1 and j == len(A[0]) - 1: return A[i][j] == \\')\\' and k == 1\\n\\t\\treturn any(dfs(i + x, j + y, k + (1 if A[i][j] == \\'(\\' else -1)) for x, y in [[0, 1], [1, 0]])\\n\\treturn dfs(0, 0, 0)\\n```\\nTime complexity: O(mn(m+n))",
                "solutionTags": [],
                "code": "```\\ndef hasValidPath(self, A: List[List[str]]) -> bool:\\n\\t@cache\\n\\tdef dfs(i, j, k):\\n\\t\\tif i >= len(A) or j >= len(A[0]) or (A[i][j] == \\')\\' and k < 1): return False\\n\\t\\tif i == len(A) - 1 and j == len(A[0]) - 1: return A[i][j] == \\')\\' and k == 1\\n\\t\\treturn any(dfs(i + x, j + y, k + (1 if A[i][j] == \\'(\\' else -1)) for x, y in [[0, 1], [1, 0]])\\n\\treturn dfs(0, 0, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2017796,
                "title": "simple-top-down-code",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        if(grid[0][0]==\")\"):return False\\n        @lru_cache(None)\\n        def fun(s,i,j):\\n            if(s<0):return False\\n            if(i==(len(grid)-1) and j==(len(grid[0])-1)):return s==0\\n            if(i+1<len(grid)):\\n                if(grid[i+1][j]==\")\"):\\n                    if(fun(s-1,i+1,j)):return True\\n                if(grid[i+1][j]==\"(\"):\\n                    if(fun(s+1,i+1,j)):return True\\n            if(j+1<len(grid[0])):\\n                if(grid[i][j+1]==\")\"):\\n                    if(fun(s-1,i,j+1)):return True\\n                if(grid[i][j+1]==\"(\"):\\n                    if(fun(s+1,i,j+1)):return True\\n            return False\\n        return fun(1,0,0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        if(grid[0][0]==\")\"):return False\\n        @lru_cache(None)\\n        def fun(s,i,j):\\n            if(s<0):return False\\n            if(i==(len(grid)-1) and j==(len(grid[0])-1)):return s==0\\n            if(i+1<len(grid)):\\n                if(grid[i+1][j]==\")\"):\\n                    if(fun(s-1,i+1,j)):return True\\n                if(grid[i+1][j]==\"(\"):\\n                    if(fun(s+1,i+1,j)):return True\\n            if(j+1<len(grid[0])):\\n                if(grid[i][j+1]==\")\"):\\n                    if(fun(s-1,i,j+1)):return True\\n                if(grid[i][j+1]==\"(\"):\\n                    if(fun(s+1,i,j+1)):return True\\n            return False\\n        return fun(1,0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020278,
                "title": "c-bottom-up-dp-solution-faster-than-100-o-mn-m-n-64",
                "content": "The solution uses a similar idea to all the other current solutions. Since int_128 seems to be unavailable, we can simply use a bitset to achieve O(mn(m+n) / 64) time complexity.\\n\\nIdea:\\nWe know from valid parantheses question all we need to do is maintain the number of left brackets. Here, `dp[i][j][k]` represents whether there is a valid way of reaching i, j with k left brackets remaining. The bit operations here just help speedup the solution but the logic is similar to all other DP solutions.\\n\\n```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        vector<vector<bitset<101>>> dp;\\n        int r = grid.size(), c = grid[0].size();\\n        dp.assign(r, vector<bitset<101>>(c, bitset<101>()));\\n        \\n        if (grid[0][0] == \\'(\\') dp[0][0][1] = 1;\\n        else return false;\\n        \\n        for (int i = 1; i < r; i++) {\\n            if (grid[i][0] == \\'(\\') dp[i][0] = (dp[i-1][0] << 1);\\n            else dp[i][0] = (dp[i-1][0] >> 1);\\n        }\\n        \\n        for (int j = 1; j < c; j++) {\\n            if (grid[0][j] == \\'(\\') dp[0][j] = (dp[0][j-1] << 1);\\n            else dp[0][j] = (dp[0][j-1] >> 1);\\n        }\\n        \\n        for (int i = 1; i < r; i++) {\\n            for (int j = 1; j < c; j++) {\\n                dp[i][j] = dp[i-1][j] | dp[i][j-1];\\n                if (grid[i][j] == \\'(\\') dp[i][j] <<= 1;\\n                else dp[i][j] >>= 1;\\n            }\\n        }\\n        \\n        return dp[r-1][c-1][0];\\n    }\\n};\\n```\\n\\nFurther optimization: we can simply compress it to a vector of bitsets instead :)\\n```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        vector<bitset<101>> dp;\\n        int r = grid.size(), c = grid[0].size();\\n        if (grid[0][0] != \\'(\\') return false;\\n        dp.assign(c, bitset<101>()); dp[0][0] = 1;\\n        \\n        for (int i = 0; i < r; i++) {\\n            if (grid[i][0] == \\'(\\') dp[0] <<= 1;\\n            else dp[0] >>= 1;\\n            for (int j = 1; j < c; j++) {\\n                dp[j] |= dp[j-1];\\n                if (grid[i][j] == \\'(\\') dp[j] <<= 1;\\n                else dp[j] >>= 1;\\n            }\\n        }\\n        \\n        return dp[c-1][0];\\n    }\\n};\\n```\\n\\nDo upvote if you think the solution helped you! And do leave any questions below :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        vector<vector<bitset<101>>> dp;\\n        int r = grid.size(), c = grid[0].size();\\n        dp.assign(r, vector<bitset<101>>(c, bitset<101>()));\\n        \\n        if (grid[0][0] == \\'(\\') dp[0][0][1] = 1;\\n        else return false;\\n        \\n        for (int i = 1; i < r; i++) {\\n            if (grid[i][0] == \\'(\\') dp[i][0] = (dp[i-1][0] << 1);\\n            else dp[i][0] = (dp[i-1][0] >> 1);\\n        }\\n        \\n        for (int j = 1; j < c; j++) {\\n            if (grid[0][j] == \\'(\\') dp[0][j] = (dp[0][j-1] << 1);\\n            else dp[0][j] = (dp[0][j-1] >> 1);\\n        }\\n        \\n        for (int i = 1; i < r; i++) {\\n            for (int j = 1; j < c; j++) {\\n                dp[i][j] = dp[i-1][j] | dp[i][j-1];\\n                if (grid[i][j] == \\'(\\') dp[i][j] <<= 1;\\n                else dp[i][j] >>= 1;\\n            }\\n        }\\n        \\n        return dp[r-1][c-1][0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        vector<bitset<101>> dp;\\n        int r = grid.size(), c = grid[0].size();\\n        if (grid[0][0] != \\'(\\') return false;\\n        dp.assign(c, bitset<101>()); dp[0][0] = 1;\\n        \\n        for (int i = 0; i < r; i++) {\\n            if (grid[i][0] == \\'(\\') dp[0] <<= 1;\\n            else dp[0] >>= 1;\\n            for (int j = 1; j < c; j++) {\\n                dp[j] |= dp[j-1];\\n                if (grid[i][j] == \\'(\\') dp[j] <<= 1;\\n                else dp[j] >>= 1;\\n            }\\n        }\\n        \\n        return dp[c-1][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017789,
                "title": "python3-dfs-iterative",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        if grid[0][0] == \\')\\':\\n            return False\\n        \\n        m, n = len(grid), len(grid[0])\\n        DIRS = [[0,1],[1,0]]\\n        \\n        stack = []\\n        \\n        # bal for tracking parenthesis balance\\n        bal = 1\\n        stack.append([0, 0, bal])\\n        seen = set()\\n        seen.add((0, 0, bal))\\n        while stack:\\n            x, y, curr_bal = stack.pop()\\n            if x == m - 1 and y == n - 1 and curr_bal == 0:\\n                return True\\n            curr = grid[x][y]\\n            for d in DIRS:\\n                r = x + d[0]\\n                c = y + d[1]\\n                if 0<=r<m and 0<=c<n:\\n                    if (r,c,curr_bal) not in seen:\\n                        seen.add((r,c,curr_bal))\\n                        next_p = grid[r][c]\\n                        if next_p == \"(\":\\n                            curr_bal += 1\\n                            stack.append([r, c, curr_bal])\\n                            curr_bal -= 1\\n                        else:\\n                            if curr_bal > 0:\\n                                curr_bal -= 1\\n                                stack.append([r, c, curr_bal])\\n                                curr_bal += 1\\n        return False\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        if grid[0][0] == \\')\\':\\n            return False\\n        \\n        m, n = len(grid), len(grid[0])\\n        DIRS = [[0,1],[1,0]]\\n        \\n        stack = []\\n        \\n        # bal for tracking parenthesis balance\\n        bal = 1\\n        stack.append([0, 0, bal])\\n        seen = set()\\n        seen.add((0, 0, bal))\\n        while stack:\\n            x, y, curr_bal = stack.pop()\\n            if x == m - 1 and y == n - 1 and curr_bal == 0:\\n                return True\\n            curr = grid[x][y]\\n            for d in DIRS:\\n                r = x + d[0]\\n                c = y + d[1]\\n                if 0<=r<m and 0<=c<n:\\n                    if (r,c,curr_bal) not in seen:\\n                        seen.add((r,c,curr_bal))\\n                        next_p = grid[r][c]\\n                        if next_p == \"(\":\\n                            curr_bal += 1\\n                            stack.append([r, c, curr_bal])\\n                            curr_bal -= 1\\n                        else:\\n                            if curr_bal > 0:\\n                                curr_bal -= 1\\n                                stack.append([r, c, curr_bal])\\n                                curr_bal += 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017723,
                "title": "3d-dp-simple-intuition",
                "content": "**Approach :-**\\n\\nWe try to find a path such that there will be always opening bracket >= closing bracket and finally at the end opening bracket == closing bracket. We use third changing variable as the opening bracket + closing bracket and hence we can solve this using 3D DP.\\n\\n```\\nCode:\\n\\nclass Solution {\\npublic:\\n    bool isSafe(int i,int j,int m,int n){\\n        return i >= 0 and i < m and j >= 0 and j < n;\\n    }\\n    bool solve(vector<vector<char>>& grid,int i,int j,int curr,vector<vector<vector<int>>>&dp){\\n        if(curr < 0) return false;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if(i == m-1 and j == n-1){\\n            if(grid[i][j] == \\'(\\'){\\n                curr += 1;\\n            }else{\\n                curr -= 1;\\n            }\\n            if(curr == 0) return true;\\n            return false;\\n        }\\n        if(dp[i][j][curr] != -1) return dp[i][j][curr];\\n        int temp;\\n        bool ans = false;\\n        if(grid[i][j] == \\'(\\'){\\n            temp = 1;\\n        }else{\\n            temp = -1;\\n        }\\n        \\n        if(isSafe(i+1,j,m,n)){\\n            ans |= solve(grid,i+1,j,curr+temp,dp);\\n        }\\n        if(isSafe(i,j+1,m,n)){\\n            ans |= solve(grid,i,j+1,curr+temp,dp);\\n        }\\n        return dp[i][j][curr] = ans;\\n        \\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<vector<int>>>dp(m,vector<vector<int>>(n,vector<int>(201,-1)));\\n        return solve(grid,0,0,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nCode:\\n\\nclass Solution {\\npublic:\\n    bool isSafe(int i,int j,int m,int n){\\n        return i >= 0 and i < m and j >= 0 and j < n;\\n    }\\n    bool solve(vector<vector<char>>& grid,int i,int j,int curr,vector<vector<vector<int>>>&dp){\\n        if(curr < 0) return false;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if(i == m-1 and j == n-1){\\n            if(grid[i][j] == \\'(\\'){\\n                curr += 1;\\n            }else{\\n                curr -= 1;\\n            }\\n            if(curr == 0) return true;\\n            return false;\\n        }\\n        if(dp[i][j][curr] != -1) return dp[i][j][curr];\\n        int temp;\\n        bool ans = false;\\n        if(grid[i][j] == \\'(\\'){\\n            temp = 1;\\n        }else{\\n            temp = -1;\\n        }\\n        \\n        if(isSafe(i+1,j,m,n)){\\n            ans |= solve(grid,i+1,j,curr+temp,dp);\\n        }\\n        if(isSafe(i,j+1,m,n)){\\n            ans |= solve(grid,i,j+1,curr+temp,dp);\\n        }\\n        return dp[i][j][curr] = ans;\\n        \\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<vector<int>>>dp(m,vector<vector<int>>(n,vector<int>(201,-1)));\\n        return solve(grid,0,0,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2389353,
                "title": "c-simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    int n, m;\\n    bool dfs(int x, int y, int open, vector<vector<char>>& grid, vector<vector<vector<int>>> &dp)\\n    {\\n        if(x >= n || y >= m) return false;\\n        if(grid[x][y] == \\'(\\')\\n            open++;\\n        else\\n            open--;\\n        if(open < 0)\\n            return false;\\n        if(dp[x][y][open] != -1)\\n            return dp[x][y][open];\\n        if(x == n-1 && y == m-1)\\n        {\\n            if(open == 0)\\n                return true;\\n            return false;\\n        }\\n        bool val = dfs(x+1, y, open, grid, dp) || dfs(x, y+1, open, grid, dp);\\n        return dp[x][y][open] = val;\\n    }\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        vector<vector<vector<int>>> dp(n+1, vector<vector<int>> (m+1, vector<int> (201, -1)));\\n        return dfs(0,0,0,grid,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int n, m;\\n    bool dfs(int x, int y, int open, vector<vector<char>>& grid, vector<vector<vector<int>>> &dp)\\n    {\\n        if(x >= n || y >= m) return false;\\n        if(grid[x][y] == \\'(\\')\\n            open++;\\n        else\\n            open--;\\n        if(open < 0)\\n            return false;\\n        if(dp[x][y][open] != -1)\\n            return dp[x][y][open];\\n        if(x == n-1 && y == m-1)\\n        {\\n            if(open == 0)\\n                return true;\\n            return false;\\n        }\\n        bool val = dfs(x+1, y, open, grid, dp) || dfs(x, y+1, open, grid, dp);\\n        return dp[x][y][open] = val;\\n    }\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        vector<vector<vector<int>>> dp(n+1, vector<vector<int>> (m+1, vector<int> (201, -1)));\\n        return dfs(0,0,0,grid,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2034492,
                "title": "3d-dp-intuitive-easy-to-understand",
                "content": "**Key Points** - We have to take care of the open parenthesis we are left with till now in our path.\\nSo, for any given indeces i and j we can have atmost n+m open braces i.e, the sum of the matrix dimensions. Whenever we calculate our answer for a given combination of \\'i\\' , \\'j\\' and \\'open\\' (open stands for unclosed brackets we have till now), we store that answer in the dp array.\\n\\nNote :- pls refer the code for more clarity\\n\\n\\n```class Solution {\\npublic:\\n    int t[101][101][201];                              //Dp array \\n    bool helper(vector<vector<char>>& grid,int open,int i,int j)\\n    {\\n        if(i>=grid.size() || j>=grid[0].size())   //Base Case  - out of bound\\n            return false;\\n        \\n        \\n        if(i==grid.size()-1 && j==grid[0].size()-1) // reached the n-1,m-1 cell\\n            {\\n                if(open==1 && grid[i][j]==\\')\\')   // true only if last element is \\'{\\' and number of open brackets left if 1 \\n                    return t[i][j][open]=true;  \\n                else\\n                    return t[i][j][open]=false;      // false otherwise\\n            }\\n        \\n        if(t[i][j][open]!=-1)   // if calculated previously \\n            return t[i][j][open];\\n        \\n        if(grid[i][j]==\\'(\\')  // if we encounter an open bracket\\n        {\\n            return  t[i][j][open]=helper(grid,open+1,i+1,j) || helper(grid,open+1,i,j+1);  // moving down and right\\n        }\\n        else     // if we encounter an open bracket\\n        {\\n            if(open<=0)                          //when closing bracket is encountered without any previous open bracket\\n                return t[i][j][open]=false;\\n                                                                                   // open count will decrease when closed bracket is encountered\\n                return t[i][j][open]=helper(grid,open-1,i+1,j) || helper(grid,open-1,i,j+1);   // moving down and right\\n        }\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        memset(t,-1,sizeof(t));               // intializing the dp array\\n        return helper(grid,0,0,0);           // initially  i=0 , j=0 i.e; starting point and open is also 0\\n    }\\n};```\\n\\nDo upvote if you found this to be helpful \\uD83D\\uDE0A\\uD83D\\uDE0A.",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```class Solution {\\npublic:\\n    int t[101][101][201];                              //Dp array \\n    bool helper(vector<vector<char>>& grid,int open,int i,int j)\\n    {\\n        if(i>=grid.size() || j>=grid[0].size())   //Base Case  - out of bound\\n            return false;\\n        \\n        \\n        if(i==grid.size()-1 && j==grid[0].size()-1) // reached the n-1,m-1 cell\\n            {\\n                if(open==1 && grid[i][j]==\\')\\')   // true only if last element is \\'{\\' and number of open brackets left if 1 \\n                    return t[i][j][open]=true;  \\n                else\\n                    return t[i][j][open]=false;      // false otherwise\\n            }\\n        \\n        if(t[i][j][open]!=-1)   // if calculated previously \\n            return t[i][j][open];\\n        \\n        if(grid[i][j]==\\'(\\')  // if we encounter an open bracket\\n        {\\n            return  t[i][j][open]=helper(grid,open+1,i+1,j) || helper(grid,open+1,i,j+1);  // moving down and right\\n        }\\n        else     // if we encounter an open bracket\\n        {\\n            if(open<=0)                          //when closing bracket is encountered without any previous open bracket\\n                return t[i][j][open]=false;\\n                                                                                   // open count will decrease when closed bracket is encountered\\n                return t[i][j][open]=helper(grid,open-1,i+1,j) || helper(grid,open-1,i,j+1);   // moving down and right\\n        }\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        memset(t,-1,sizeof(t));               // intializing the dp array\\n        return helper(grid,0,0,0);           // initially  i=0 , j=0 i.e; starting point and open is also 0\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2020540,
                "title": "simple-dp-solution-with-c-bitset",
                "content": "At dp[i][j] we count how many excess open parenthesis we have till ```i,j``` (>= 0, negative means that particular path can be ignored from now on).  Now, at ```i,j``` if it\\'s open, we increase all counts by 1 (i.e left-shift) otherwise decrease all counts by 1.  \\nC++ bitset<201> can simulate this directly. increase can be left-shift etc.\\n```\\ntypedef bitset<201> sp;\\ntypedef vector<sp> vsp;\\ntypedef vector<vsp> vvsp;\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vvsp dp = vvsp(m, vsp(n, sp()));\\n        dp[0][0] = grid[0][0] == \\'(\\';\\n        for (int i=0;i<m;++i) for (int j=0;j<n;++j) {\\n            dp[i][j] = dp[i][j] | (j ? dp[i][j-1] : 0) | (i ? dp[i-1][j] : 0 );\\n            if (grid[i][j] == \\'(\\') dp[i][j] <<= 1;\\n            else dp[i][j] >>= 1;\\n        }\\n        return dp.back().back().test(0) > 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```i,j```\n```i,j```\n```\\ntypedef bitset<201> sp;\\ntypedef vector<sp> vsp;\\ntypedef vector<vsp> vvsp;\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vvsp dp = vvsp(m, vsp(n, sp()));\\n        dp[0][0] = grid[0][0] == \\'(\\';\\n        for (int i=0;i<m;++i) for (int j=0;j<n;++j) {\\n            dp[i][j] = dp[i][j] | (j ? dp[i][j-1] : 0) | (i ? dp[i-1][j] : 0 );\\n            if (grid[i][j] == \\'(\\') dp[i][j] <<= 1;\\n            else dp[i][j] >>= 1;\\n        }\\n        return dp.back().back().test(0) > 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019994,
                "title": "fully-explained-recursion-memoization-cpp",
                "content": "we can solve this question easily by taking \\'(\\' as +1 and \\')\\' as -1.Now start adding the cell values in right or down direction and if sum is negative that means it cant be a valid path as it can not be balanced at any condition.\\nNow do a recursion and check if we have already visited this node with th current sum, if yes then return the memoized value otherwise go to the right and down and return OR of both paths.\\nBase condition: if we will reach at the bottom right cell then sum should be 0 for a correct path otherwise the paranthesis must be unbalanced.\\n\\nPFB my code for your reference:)\\n\\n```\\nclass Solution {\\npublic:\\n    bool dfs(int i,int j,int n,int m,int score,vector<vector<int>>& g,vector<vector<vector<int>>>& dp){\\n        if(i>=n || j>=m) return false;\\n        score+=g[i][j];\\n        if(i==n-1 && j==m-1) return score==0;\\n        if(score<0) return false;\\n        if(dp[i][j][score] != -1) return dp[i][j][score];\\n        return dp[i][j][score]=dfs(i+1,j,n,m,score,g,dp) || dfs(i,j+1,n,m,score,g,dp);\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        if((n+m-1)&1) return false;\\n        vector<vector<int>> g(n,vector<int>(m,-1));\\n        vector<vector<vector<int>>> dp(n,vector<vector<int>>(m,vector<int>(n+m+5,-1)));\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(grid[i][j]==\\'(\\') g[i][j]=1;\\n        return dfs(0,0,n,m,0,g,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(int i,int j,int n,int m,int score,vector<vector<int>>& g,vector<vector<vector<int>>>& dp){\\n        if(i>=n || j>=m) return false;\\n        score+=g[i][j];\\n        if(i==n-1 && j==m-1) return score==0;\\n        if(score<0) return false;\\n        if(dp[i][j][score] != -1) return dp[i][j][score];\\n        return dp[i][j][score]=dfs(i+1,j,n,m,score,g,dp) || dfs(i,j+1,n,m,score,g,dp);\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        if((n+m-1)&1) return false;\\n        vector<vector<int>> g(n,vector<int>(m,-1));\\n        vector<vector<vector<int>>> dp(n,vector<vector<int>>(m,vector<int>(n+m+5,-1)));\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(grid[i][j]==\\'(\\') g[i][j]=1;\\n        return dfs(0,0,n,m,0,g,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019857,
                "title": "c-solution-with-visitedflag-array",
                "content": "\\tpublic class Solution {\\n\\n\\t\\tprivate bool[,,] _visited;\\n\\t\\tprivate int _rowLength;\\n\\t\\tprivate int _colLength;\\n\\t\\tprivate int _midLength;\\n\\t\\tprivate char[][] _grid;\\n\\n\\t\\tpublic bool ValidPath(int row, int col,int bal){\\n\\t\\t\\tbal += _grid[row][col]==\\'(\\'?1:-1;\\n\\t\\t\\tif(bal < 0 || bal > _midLength || _visited[row,col,bal])\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t_visited[row,col,bal]=true;\\n\\t\\t\\tif(row == _rowLength-1 && col == _colLength-1){\\n\\t\\t\\t\\tif(bal == 0)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(row<_rowLength-1 && ValidPath(row+1,col,bal))\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\tif(col<_colLength-1 && ValidPath(row,col+1,bal))\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tpublic bool HasValidPath(char[][] grid) {\\n\\t\\t\\t_rowLength = grid.Length;\\n\\t\\t\\t_colLength = grid[0].Length;\\n\\t\\t\\t_midLength = (_rowLength+_colLength)/2;\\n\\t\\t\\t_visited = new bool[_rowLength,_colLength,_midLength+1];\\n\\t\\t\\t_grid = grid;\\n\\n\\t\\t\\treturn ValidPath(0,0,0);\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n\\t\\tprivate bool[,,] _visited;\\n\\t\\tprivate int _rowLength;\\n\\t\\tprivate int _colLength;\\n\\t\\tprivate int _midLength;\\n\\t\\tprivate char[][] _grid;\\n\\n\\t\\tpublic bool ValidPath(int row, int col,int bal){\\n\\t\\t\\tbal += _grid[row][col]==\\'(\\'?1:-1;\\n\\t\\t\\tif(bal < 0 || bal > _midLength || _visited[row,col,bal])\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t_visited[row,col,bal]=true;\\n\\t\\t\\tif(row == _rowLength-1 && col == _colLength-1){\\n\\t\\t\\t\\tif(bal == 0)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2019037,
                "title": "c-solution-dfs-3d-dp-memoization",
                "content": "The approach is based on simple dfs on the given matrix. We start from the very first cell `matrix[0][0]` and consider both the two choices to go right or down from the current cell. On the fly we track the balancing of the parenthesis by taking a variable (Here `s`) and adding one to it if we encounter an opening `\\'(\\'` parentheses and subtracting one from it if we encounter a closing parenthesis `\\')\\'`. \\n\\nOn reaching the last cell i.e., `matrix[n - 1][m - 1]` we check if `s` becomes equal to zero, we found a valid parenthesis string path.\\n\\n```\\nclass Solution {\\npublic:\\n    bool ff(vector<vector<vector<int>>> &dp, int i, int j, int n, int m, int s, vector<vector<char>> &a)\\n    {\\n        if(i == n || j == m || s < 0) return false;\\n        if(i == n - 1 && j == m - 1) \\n        {\\n            int sum = (a[i][j] == \\'(\\' ? s + 1 : s - 1);\\n            return (sum == 0);\\n        }\\n        if(dp[i][j][s] != -1) return dp[i][j][s];\\n        // Go Down\\n        if(ff(dp, i + 1, j, n, m, ((a[i][j] == \\'(\\') ? s + 1 : s - 1), a)) return dp[i][j][s] = true;\\n        // Go Right\\n        if(ff(dp, i, j + 1, n, m, ((a[i][j] == \\'(\\') ? s + 1 : s - 1), a)) return dp[i][j][s] = true;\\n        return dp[i][j][s] = false;\\n    }\\n    bool hasValidPath(vector<vector<char>>& a) \\n    {\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>> (m, vector<int> (n + m + 2, -1)));\\n        return ff(dp, 0, 0, n, m, 0, a);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool ff(vector<vector<vector<int>>> &dp, int i, int j, int n, int m, int s, vector<vector<char>> &a)\\n    {\\n        if(i == n || j == m || s < 0) return false;\\n        if(i == n - 1 && j == m - 1) \\n        {\\n            int sum = (a[i][j] == \\'(\\' ? s + 1 : s - 1);\\n            return (sum == 0);\\n        }\\n        if(dp[i][j][s] != -1) return dp[i][j][s];\\n        // Go Down\\n        if(ff(dp, i + 1, j, n, m, ((a[i][j] == \\'(\\') ? s + 1 : s - 1), a)) return dp[i][j][s] = true;\\n        // Go Right\\n        if(ff(dp, i, j + 1, n, m, ((a[i][j] == \\'(\\') ? s + 1 : s - 1), a)) return dp[i][j][s] = true;\\n        return dp[i][j][s] = false;\\n    }\\n    bool hasValidPath(vector<vector<char>>& a) \\n    {\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>> (m, vector<int> (n + m + 2, -1)));\\n        return ff(dp, 0, 0, n, m, 0, a);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018216,
                "title": "python-3-pruned-bfs-with-memo-counting-brackets",
                "content": "**BFS solution with count open bracket and closing bracket**\\n\\nFalse case + pruning case to skip the addition to the queue\\n- if starting with close bracket -> False\\n- if ending with open bracket -> False\\n- if memo at the current position has less number of open bracket, no need to check as both path will end up same result -> skip\\n- if current number of unmatched open bracket has more then the steps left to the target -> this path is invalid -> skip\\n- We can\\'t have closing bracket when current path has no open bracket left to be matched -> skip\\n- if we didn\\'t find the answer until try all the path -> False\\n\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        rLen, cLen = len(grid), len(grid[0])\\n        direc = [(1, 0), (0, 1)]\\n        q = deque()\\n        maxStep = rLen + cLen - 2\\n        visited = {}\\n        \\n        # starting with closing bracket = invalid parentheses return False\\n        if grid[0][0] == \\')\\':\\n            return False\\n        # can\\'t end with closing bracket\\n        elif grid[rLen - 1][cLen - 1] == \\'(\\':\\n            return False\\n        elif grid[0][0] == \\'(\\':\\n            q.append((0, 0, 1))\\n        \\n        while q:\\n            currR, currC, currCount = q.popleft()\\n            # memo skip if currCount > then previous as we will find answer anyways\\n            if (currR, currC) in visited:\\n                if visited[(currR, currC)] <= currCount:\\n                    continue\\n            visited[(currR, currC)] = currCount\\n            # if curr number of open count has more than possible steps left to target then skip\\n            if (maxStep - currR + currC) < currCount:\\n                continue\\n            # reach to target? -> make sure our count == 0 and return True\\n            if currR == rLen - 1 and currC == cLen - 1:\\n                if currCount == 0:\\n                    return True\\n            for dr, dc in direc:\\n                newR, newC = currR + dr, currC + dc\\n                if newR < rLen and newC < cLen:\\n                    if grid[newR][newC] == \\'(\\':\\n                        q.append((newR, newC, currCount + 1))\\n                    elif grid[newR][newC] == \\')\\':\\n                        # if currCount is 0 then we can\\'t take path with closing bracket\\n                        if currCount > 0:\\n                            q.append((newR, newC, currCount - 1))\\n        # we didnt find solution for all possible path return False\\n        return False\\n```\\n\\n**Please UPVOTE if you find this solution helpful !\\nHappy algo!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        rLen, cLen = len(grid), len(grid[0])\\n        direc = [(1, 0), (0, 1)]\\n        q = deque()\\n        maxStep = rLen + cLen - 2\\n        visited = {}\\n        \\n        # starting with closing bracket = invalid parentheses return False\\n        if grid[0][0] == \\')\\':\\n            return False\\n        # can\\'t end with closing bracket\\n        elif grid[rLen - 1][cLen - 1] == \\'(\\':\\n            return False\\n        elif grid[0][0] == \\'(\\':\\n            q.append((0, 0, 1))\\n        \\n        while q:\\n            currR, currC, currCount = q.popleft()\\n            # memo skip if currCount > then previous as we will find answer anyways\\n            if (currR, currC) in visited:\\n                if visited[(currR, currC)] <= currCount:\\n                    continue\\n            visited[(currR, currC)] = currCount\\n            # if curr number of open count has more than possible steps left to target then skip\\n            if (maxStep - currR + currC) < currCount:\\n                continue\\n            # reach to target? -> make sure our count == 0 and return True\\n            if currR == rLen - 1 and currC == cLen - 1:\\n                if currCount == 0:\\n                    return True\\n            for dr, dc in direc:\\n                newR, newC = currR + dr, currC + dc\\n                if newR < rLen and newC < cLen:\\n                    if grid[newR][newC] == \\'(\\':\\n                        q.append((newR, newC, currCount + 1))\\n                    elif grid[newR][newC] == \\')\\':\\n                        # if currCount is 0 then we can\\'t take path with closing bracket\\n                        if currCount > 0:\\n                            q.append((newR, newC, currCount - 1))\\n        # we didnt find solution for all possible path return False\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018050,
                "title": "dfs-3-d-dp-memoization",
                "content": "**PLEASE UPVOTE IF U FIND MY SOLUTION HELPFUL**\\n\\n```\\nclass Solution {\\n    bool f=0;\\n    int c=0;\\n    //int dp[101][101][201];\\n    bool dfs(vector<vector<char>>& grid,int i,int j,int &n,int &m, vector<vector<vector<int>>>& dp)\\n    {\\n        if(f)return 1;\\n        if(i>=n||j>=m)return 0;\\n        \\n        if(i==n-1&&j==m-1)\\n        {\\n            if(c==1){f=1;return 1;}\\n            return 0;\\n        }\\n        \\n        if(dp[i][j][c]!=-1)\\n            return dp[i][j][c];\\n        \\n        if(grid[i][j]==\\'(\\')\\n            c++;\\n        else\\n        {\\n            if(c)c--;\\n            else\\n                return 0;\\n        }\\n        \\n        bool flag=0;\\n        flag|=dfs(grid,i+1,j,n,m,dp);\\n        flag|=dfs(grid,i,j+1,n,m,dp);\\n        \\n        c=grid[i][j]==\\'(\\'?c-1:c+1;\\n        return dp[i][j][c]=flag?1:0;\\n    }\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) \\n    {\\n        int n=grid.size(),m=grid[0].size();\\n        if(grid[0][0]==\\')\\'||grid[n-1][m-1]==\\'(\\')return 0;\\n        vector<vector<vector<int>>>dp(n,vector<vector<int>>(m,vector<int>(m+n-1,-1)));\\n        return dfs(grid,0,0,n,m,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    bool f=0;\\n    int c=0;\\n    //int dp[101][101][201];\\n    bool dfs(vector<vector<char>>& grid,int i,int j,int &n,int &m, vector<vector<vector<int>>>& dp)\\n    {\\n        if(f)return 1;\\n        if(i>=n||j>=m)return 0;\\n        \\n        if(i==n-1&&j==m-1)\\n        {\\n            if(c==1){f=1;return 1;}\\n            return 0;\\n        }\\n        \\n        if(dp[i][j][c]!=-1)\\n            return dp[i][j][c];\\n        \\n        if(grid[i][j]==\\'(\\')\\n            c++;\\n        else\\n        {\\n            if(c)c--;\\n            else\\n                return 0;\\n        }\\n        \\n        bool flag=0;\\n        flag|=dfs(grid,i+1,j,n,m,dp);\\n        flag|=dfs(grid,i,j+1,n,m,dp);\\n        \\n        c=grid[i][j]==\\'(\\'?c-1:c+1;\\n        return dp[i][j][c]=flag?1:0;\\n    }\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) \\n    {\\n        int n=grid.size(),m=grid[0].size();\\n        if(grid[0][0]==\\')\\'||grid[n-1][m-1]==\\'(\\')return 0;\\n        vector<vector<vector<int>>>dp(n,vector<vector<int>>(m,vector<int>(m+n-1,-1)));\\n        return dfs(grid,0,0,n,m,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017898,
                "title": "c-hashset-dp-w-crappy-image-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/c8a67b6a-e11b-420d-94e2-eef687da5e05_1651983094.751082.png)\\n\\n```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if (grid[m-1][n-1] == \\'(\\' || (m+n)%2 == 0)\\n            return false;\\n        vector<vector<unordered_set<int>>> dp(m+1, vector<unordered_set<int>>(n+1));\\n        dp[m][n-1].insert(0);\\n        dp[m-1][n].insert(0);\\n        for (int i = m-1; i >= 0; --i) {\\n            for (int j = n-1; j >= 0; --j) {\\n                int p = (grid[i][j] == \\')\\') ? 1 : -1;\\n                for (int v: dp[i+1][j]) {\\n                    v += p;\\n                    if (v >= 0)\\n                        dp[i][j].insert(v);\\n                }\\n                for (int v: dp[i][j+1]) {\\n                    v += p;\\n                    if (v >= 0)\\n                        dp[i][j].insert(v);\\n                }\\n            }\\n        }\\n        return dp[0][0].find(0) != dp[0][0].end();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if (grid[m-1][n-1] == \\'(\\' || (m+n)%2 == 0)\\n            return false;\\n        vector<vector<unordered_set<int>>> dp(m+1, vector<unordered_set<int>>(n+1));\\n        dp[m][n-1].insert(0);\\n        dp[m-1][n].insert(0);\\n        for (int i = m-1; i >= 0; --i) {\\n            for (int j = n-1; j >= 0; --j) {\\n                int p = (grid[i][j] == \\')\\') ? 1 : -1;\\n                for (int v: dp[i+1][j]) {\\n                    v += p;\\n                    if (v >= 0)\\n                        dp[i][j].insert(v);\\n                }\\n                for (int v: dp[i][j+1]) {\\n                    v += p;\\n                    if (v >= 0)\\n                        dp[i][j].insert(v);\\n                }\\n            }\\n        }\\n        return dp[0][0].find(0) != dp[0][0].end();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017736,
                "title": "cpp-dfs-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<vector<vector<int>>> dp;\\n    bool dfs(int i,int j,vector<vector<char>>& g,int cnt){     // cnt = number of opening brackets remaining\\n        if(i<0 || j<0 || i>=n || j>=m) return 0;\\n        \\n        if(dp[i][j][cnt]!=-1) return dp[i][j][cnt];\\n        \\n        if(i==n-1 && j==m-1){\\n            if(g[i][j]==\\'(\\') cnt++;\\n            else cnt--;\\n            \\n            if(cnt<0) return 0;\\n            if(cnt==0) return 1;\\n            \\n            return dp[i][j][cnt] = 0;\\n        }\\n        \\n        if(g[i][j] == \\'(\\'){\\n            if(dfs(i+1,j,g,cnt+1)) return 1;\\n            if(dfs(i,j+1,g,cnt+1)) return 1;\\n        }\\n        else{\\n            if(cnt == 0) return dp[i][j][cnt] = 0;\\n            if(dfs(i+1,j,g,cnt-1)) return 1;\\n            if(dfs(i,j+1,g,cnt-1)) return 1;\\n        }\\n        \\n        return dp[i][j][cnt]=0;\\n    }\\n\\t\\n    bool hasValidPath(vector<vector<char>>& g) {\\n        n = g.size(), m = g[0].size();\\n        dp = vector<vector<vector<int>>>(n,vector<vector<int>>(m,vector<int>(m+n+1,-1)));\\n        return dfs(0,0,g,0);\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int n,m;\\n    vector<vector<vector<int>>> dp;\\n    bool dfs(int i,int j,vector<vector<char>>& g,int cnt){     // cnt = number of opening brackets remaining\\n        if(i<0 || j<0 || i>=n || j>=m) return 0;\\n        \\n        if(dp[i][j][cnt]!=-1) return dp[i][j][cnt];\\n        \\n        if(i==n-1 && j==m-1){\\n            if(g[i][j]==\\'(\\') cnt++;\\n            else cnt--;\\n            \\n            if(cnt<0) return 0;\\n            if(cnt==0) return 1;\\n            \\n            return dp[i][j][cnt] = 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3724881,
                "title": "3-d-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(int r, int c, int count, vector<vector<char>> &grid, vector<vector<vector<int>>> &dp)\\n{\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    if (r == n - 1 and c == m - 1)\\n    {\\n        return count == 1;\\n    }\\n\\n    if (r < 0 or r >= n or c < 0 or c >= m or count < 0 or count > ((m + n) / 2))\\n    {\\n        return false;\\n    }\\n\\n    if (dp[r][c][count] != -1)\\n    {\\n        return dp[r][c][count];\\n    }\\n\\n    int tot = count;\\n    if (grid[r][c] == \\'(\\')\\n    {\\n        tot++;\\n    }\\n    else\\n    {\\n        tot--;\\n    }\\n\\n    bool right = solve(r, c + 1, tot, grid, dp);\\n    bool down = solve(r + 1, c, tot, grid, dp);\\n\\n    return dp[r][c][count] = right or down;\\n}\\n\\nbool hasValidPath(vector<vector<char>> &grid)\\n{\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    if (n % 2 == m % 2)\\n    {\\n        return false;\\n    }\\n    if (grid[0][0] == \\')\\' or grid[n - 1][m - 1] == \\'(\\')\\n    {\\n        return false;\\n    }\\n    vector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int>(((m + n) / 2) + 1, -1)));\\n\\n    return solve(0, 0, 0, grid, dp);\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(int r, int c, int count, vector<vector<char>> &grid, vector<vector<vector<int>>> &dp)\\n{\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    if (r == n - 1 and c == m - 1)\\n    {\\n        return count == 1;\\n    }\\n\\n    if (r < 0 or r >= n or c < 0 or c >= m or count < 0 or count > ((m + n) / 2))\\n    {\\n        return false;\\n    }\\n\\n    if (dp[r][c][count] != -1)\\n    {\\n        return dp[r][c][count];\\n    }\\n\\n    int tot = count;\\n    if (grid[r][c] == \\'(\\')\\n    {\\n        tot++;\\n    }\\n    else\\n    {\\n        tot--;\\n    }\\n\\n    bool right = solve(r, c + 1, tot, grid, dp);\\n    bool down = solve(r + 1, c, tot, grid, dp);\\n\\n    return dp[r][c][count] = right or down;\\n}\\n\\nbool hasValidPath(vector<vector<char>> &grid)\\n{\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    if (n % 2 == m % 2)\\n    {\\n        return false;\\n    }\\n    if (grid[0][0] == \\')\\' or grid[n - 1][m - 1] == \\'(\\')\\n    {\\n        return false;\\n    }\\n    vector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int>(((m + n) / 2) + 1, -1)));\\n\\n    return solve(0, 0, 0, grid, dp);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434922,
                "title": "100-faster-using-recursion-3d-dp-dp-row-column-count-of",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool helper(int i, int j, int count, vector<vector<char>>& grid,  vector< vector< vector<int> > > &dp) {\\n        if(i == grid.size() || j == grid[0].size()) return false;\\n        if(i == grid.size() -1 && j == grid[0].size() - 1) {\\n            if(grid[i][j] == \\'(\\') return false;\\n            return count - 1 == 0;\\n        }\\n        if(dp[i][j][count] != -1) return dp[i][j][count];\\n\\n        if(grid[i][j] == \\'(\\') {\\n            return dp[i][j][count] = helper(i+1, j, count+1, grid, dp) || helper(i, j+1, count+1, grid, dp);\\n        }\\n        if(count > 0) return dp[i][j][count] = helper(i+1, j, count-1, grid, dp) || helper(i, j+1, count-1, grid, dp);\\n\\n        return dp[i][j][count] =false;\\n        \\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        vector< vector< vector<int> > > dp(grid.size(), vector< vector< int > > (grid[0].size(), vector< int > (grid.size()+grid[0].size(), -1)));\\n        return helper(0, 0, 0, grid, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(int i, int j, int count, vector<vector<char>>& grid,  vector< vector< vector<int> > > &dp) {\\n        if(i == grid.size() || j == grid[0].size()) return false;\\n        if(i == grid.size() -1 && j == grid[0].size() - 1) {\\n            if(grid[i][j] == \\'(\\') return false;\\n            return count - 1 == 0;\\n        }\\n        if(dp[i][j][count] != -1) return dp[i][j][count];\\n\\n        if(grid[i][j] == \\'(\\') {\\n            return dp[i][j][count] = helper(i+1, j, count+1, grid, dp) || helper(i, j+1, count+1, grid, dp);\\n        }\\n        if(count > 0) return dp[i][j][count] = helper(i+1, j, count-1, grid, dp) || helper(i, j+1, count-1, grid, dp);\\n\\n        return dp[i][j][count] =false;\\n        \\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        vector< vector< vector<int> > > dp(grid.size(), vector< vector< int > > (grid[0].size(), vector< int > (grid.size()+grid[0].size(), -1)));\\n        return helper(0, 0, 0, grid, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353083,
                "title": "2d-dp-solution-in-java",
                "content": "### Approach\\nThe approach used in the given code is to solve the problem using dynamic programming. The idea is to create a 2D array called dp, where each cell stores the set of possible balance values at that position. We start by initializing the set at the top-left cell with the value 1 if the path starts with a \\'(\\' character.\\n\\nThen, we iterate over each cell of the dp array and update the set of balances at each cell based on the direction of the paths. For each neighboring cell, we check the set of possible balances at that cell and add or subtract 1 to get the new balance value. We then add the new balance value to the set of balances at the current cell if it is non-negative.\\n\\nFinally, we check if the set of balances at the bottom-right cell of the dp array contains 0, which means that there exists a path from the top-left cell to the bottom-right cell with a balanced set of parentheses. If the set contains 0, we return `true`. Otherwise, we return `false`.\\n\\n# Complexity\\n- Time complexity: $$O(mn(m+n))$$\\n- Space complexity: $$O(mn)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] path = new int[][]{{-1, 0}, {0, -1}};\\n\\n        Set<Integer>[][] dp = new HashSet[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j] = new HashSet<>();\\n            }\\n        }\\n\\n        if (grid[0][0] == \\'(\\') dp[0][0].add(1);\\n\\n        /*This is the main logic of the program. \\n        \\n        We iterate over each cell of the dp array and calculate the balance of \\n        the parentheses at that cell.The variable cur is set to 1 if the current cell\\n        contains an open parenthesis, and -1 otherwise.*/\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int cur = grid[i][j] == \\'(\\' ? 1 : -1;\\n                for (int[] d : path) {\\n                    int x = i + d[0], y = j + d[1];\\n                    if (x < 0 || y < 0) continue;\\n\\n                    for (int bal : dp[x][y]) {\\n                        bal += cur;\\n                        if (bal < 0) continue;\\n                        dp[i][j].add(bal);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1].contains(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] path = new int[][]{{-1, 0}, {0, -1}};\\n\\n        Set<Integer>[][] dp = new HashSet[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j] = new HashSet<>();\\n            }\\n        }\\n\\n        if (grid[0][0] == \\'(\\') dp[0][0].add(1);\\n\\n        /*This is the main logic of the program. \\n        \\n        We iterate over each cell of the dp array and calculate the balance of \\n        the parentheses at that cell.The variable cur is set to 1 if the current cell\\n        contains an open parenthesis, and -1 otherwise.*/\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int cur = grid[i][j] == \\'(\\' ? 1 : -1;\\n                for (int[] d : path) {\\n                    int x = i + d[0], y = j + d[1];\\n                    if (x < 0 || y < 0) continue;\\n\\n                    for (int bal : dp[x][y]) {\\n                        bal += cur;\\n                        if (bal < 0) continue;\\n                        dp[i][j].add(bal);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1].contains(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731709,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   bool hasValidPath(vector<vector<char>>& A) {\\n        int m = A.size(), n = A[0].size(), maxk = (m + n + 1) / 2;\\n        vector<vector<vector<int>>> dp(m + 1, vector<vector<int>>(n + 1, vector<int>(maxk + 10)));\\n        dp[0][0][1] = 1;\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                for (int k = 1; k <= maxk; ++k) {\\n                    dp[i][j + 1][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                    dp[i + 1][j][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                }\\n        return dp[m][n - 1][1];        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool hasValidPath(vector<vector<char>>& A) {\\n        int m = A.size(), n = A[0].size(), maxk = (m + n + 1) / 2;\\n        vector<vector<vector<int>>> dp(m + 1, vector<vector<int>>(n + 1, vector<int>(maxk + 10)));\\n        dp[0][0][1] = 1;\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                for (int k = 1; k <= maxk; ++k) {\\n                    dp[i][j + 1][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                    dp[i + 1][j][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                }\\n        return dp[m][n - 1][1];        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263853,
                "title": "c-memomization-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool f(vector<vector<char>>&g,int i,int j,int st,vector<vector<vector<int>>>&dp)\\n    { \\n        if(i==0&&j==0)\\n        {\\n            if(st==1)\\n            {\\n                if(g[i][j]==\\'(\\')\\n                    return true;\\n                else\\n                    return false;\\n            }\\n            else\\n                return false;\\n        }\\n        if(i<0||j<0)\\n        {\\n          return false;\\n        }   \\n        if(g[i][j]==\\')\\')\\n            st+=1;\\n        else\\n        {\\n           if(st==0)\\n               return dp[i][j][st]=false;\\n           else\\n               st--;\\n        }\\n        if(dp[i][j][st]!=-1)\\n            return dp[i][j][st];\\n        return dp[i][j][st]=f(g,i-1,j,st,dp)||f(g,i,j-1,st,dp);\\n    }\\n    bool hasValidPath(vector<vector<char>>&g) {\\n        int st=0;\\n        vector<vector<vector<int>>>dp(g.size()+1,vector<vector<int>>(g[0].size()+1,vector<int>(g.size()+g[0].size()+2,-1)));\\n        return f(g,g.size()-1,g[0].size()-1,st,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(vector<vector<char>>&g,int i,int j,int st,vector<vector<vector<int>>>&dp)\\n    { \\n        if(i==0&&j==0)\\n        {\\n            if(st==1)\\n            {\\n                if(g[i][j]==\\'(\\')\\n                    return true;\\n                else\\n                    return false;\\n            }\\n            else\\n                return false;\\n        }\\n        if(i<0||j<0)\\n        {\\n          return false;\\n        }   \\n        if(g[i][j]==\\')\\')\\n            st+=1;\\n        else\\n        {\\n           if(st==0)\\n               return dp[i][j][st]=false;\\n           else\\n               st--;\\n        }\\n        if(dp[i][j][st]!=-1)\\n            return dp[i][j][st];\\n        return dp[i][j][st]=f(g,i-1,j,st,dp)||f(g,i,j-1,st,dp);\\n    }\\n    bool hasValidPath(vector<vector<char>>&g) {\\n        int st=0;\\n        vector<vector<vector<int>>>dp(g.size()+1,vector<vector<int>>(g[0].size()+1,vector<int>(g.size()+g[0].size()+2,-1)));\\n        return f(g,g.size()-1,g[0].size()-1,st,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2162698,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8  The ART of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\nLet `k` be the amount of open parenthesis `\\'(\\'` *not* paired with a close parenthesis `\\')\\'` on the path from the top-left cell `0`,`0` ending at cell `i`,`j`.  Note: `k` must *not* be negative at any point in the path (otherwise there\\'s too many close parenthesis `\\')\\'` for a valid path)\\n\\n**Top-Down:** let `D` and `R` denote adjacent cells \"down\" and \"right\" correspondingly.\\n\\n**Bottom-Up:** let `U` and `L` denote adjacent cells \"up\" and \"left\" correspondingly, let `dp[i][j]` denote the set of all `k` possibilities of open parenthesis `\\'(\\'` for paths ending at cell `i`,`j`.  And we formulate the future from the past by considering all `k` candidates `cands`. \\n\\n---\\n\\n**Kotlin Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun hasValidPath(A: Array<CharArray>): Boolean {\\n        var M = A.size\\n        var N = A[0].size\\n        fun go(i: Int = 0, j: Int = 0, k_: Int = 0): Boolean {\\n            if (i == M || j == N)\\n                return false\\n            var k = k_ + if (A[i][j] == \\'(\\') 1 else -1\\n            if (k < 0)\\n                return false\\n            if (i == M - 1 && j == N - 1)\\n                return k == 0\\n            var D = go(i + 1, j, k)\\n            var R = go(i, j + 1, k)\\n            return D || R\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun hasValidPath(A: Array<CharArray>): Boolean {\\n        var M = A.size\\n        var N = A[0].size\\n        var m = mutableMapOf<String, Boolean>()\\n        fun go(i: Int = 0, j: Int = 0, k_: Int = 0): Boolean {\\n            if (i == M || j == N)\\n                return false\\n            var k = k_ + if (A[i][j] == \\'(\\') 1 else -1\\n            if (k < 0)\\n                return false\\n            if (i == M - 1 && j == N - 1)\\n                return k == 0\\n            var key = \"$i,$j,$k\"\\n            if (!m.contains(key)) {\\n                var D = go(i + 1, j, k)\\n                var R = go(i, j + 1, k)\\n                m[key] = D || R\\n            }\\n            return m[key]!!\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun hasValidPath(A: Array<CharArray>): Boolean {\\n        var M = A.size\\n        var N = A[0].size\\n        var dp = Array(M) { Array(N) { mutableSetOf<Int>() } }\\n        if (A[0][0] == \\'(\\')\\n            dp[0][0].add(1)\\n        for (i in 0 until M) {\\n            for (j in 0 until N) {\\n                var U = if (0 <= i - 1) dp[i - 1][j] else mutableSetOf<Int>()\\n                var L = if (0 <= j - 1) dp[i][j - 1] else mutableSetOf<Int>()\\n                var cands = U union L\\n                for (k_ in cands) {\\n                    var k = k_ + if (A[i][j] == \\'(\\') 1 else -1\\n                    if (0 <= k)\\n                        dp[i][j].add(k)\\n                }\\n            }\\n        }\\n        return dp[M - 1][N - 1].contains(0)\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet hasValidPath = A => {\\n    let M = A.length,\\n        N = A[0].length;\\n    let go = (i = 0, j = 0, k = 0) => {\\n        if (i == M || j == N)\\n            return false;\\n        k += A[i][j] == \\'(\\' ? 1 : -1;\\n        if (k < 0)\\n            return false;\\n        if (i == M - 1 && j == N - 1)\\n            return !k;\\n        let D = go(i + 1, j, k),\\n            R = go(i, j + 1, k);\\n        return D || R;\\n    };\\n    return go();\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet hasValidPath = (A, m = new Map()) => {\\n    let M = A.length,\\n        N = A[0].length;\\n    let go = (i = 0, j = 0, k = 0) => {\\n        if (i == M || j == N)\\n            return false;\\n        k += A[i][j] == \\'(\\' ? 1 : -1;\\n        if (k < 0)\\n            return false;\\n        if (i == M - 1 && j == N - 1)\\n            return !k;\\n        let key = `${i},${j},${k}`;\\n        if (!m.has(key)) {\\n            let D = go(i + 1, j, k),\\n                R = go(i, j + 1, k);\\n            m.set(key, D || R);\\n        }\\n        return m.get(key);\\n    };\\n    return go();\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet hasValidPath = A => {\\n    let M = A.length,\\n        N = A[0].length;\\n    let dp = [...Array(M)].map(_ => [...Array(N)].map(_ => new Set()));\\n    if (A[0][0] == \\'(\\')\\n        dp[0][0].add(1);\\n    for (let i = 0; i < M; ++i) {\\n        for (let j = 0; j < N; ++j) {\\n            let U = 0 <= i - 1 ? dp[i - 1][j] : new Set(),\\n                L = 0 <= j - 1 ? dp[i][j - 1] : new Set();\\n            let cands = new Set([...U, ...L]);\\n            for (let k of cands) {\\n                k += A[i][j] == \\'(\\' ? 1 : -1;\\n                if (0 <= k)\\n                    dp[i][j].add(k);\\n            }\\n        }\\n    }\\n    return dp[M - 1][N - 1].has(0);\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def hasValidPath(self, A: List[List[str]]) -> bool:\\n        M = len(A)\\n        N = len(A[0])\\n        def go(i = 0, j = 0, k = 0):\\n            if i == M or j == N:\\n                return False\\n            k += 1 if A[i][j] == \\'(\\' else -1\\n            if k < 0:\\n                return False\\n            if i == M - 1 and j == N - 1:\\n                return not k\\n            D = go(i + 1, j, k)\\n            R = go(i, j + 1, k)\\n            return D or R\\n        return go()\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution:\\n    def hasValidPath(self, A: List[List[str]]) -> bool:\\n        M = len(A)\\n        N = len(A[0])\\n        @cache\\n        def go(i = 0, j = 0, k = 0):\\n            if i == M or j == N:\\n                return False\\n            k += 1 if A[i][j] == \\'(\\' else -1\\n            if k < 0:\\n                return False\\n            if i == M - 1 and j == N - 1:\\n                return not k\\n            D = go(i + 1, j, k)\\n            R = go(i, j + 1, k)\\n            return D or R\\n        return go()\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def hasValidPath(self, A: List[List[str]]) -> bool:\\n        M = len(A)\\n        N = len(A[0])\\n        dp = [[set() for _ in range(N)] for _ in range(M)]\\n        if A[0][0] == \\'(\\':\\n            dp[0][0].add(1)\\n        for i in range(M):\\n            for j in range(N):\\n                U = dp[i - 1][j] if 0 <= i - 1 else set()\\n                L = dp[i][j - 1] if 0 <= j - 1 else set()\\n                for k in U.union(L):\\n                    k += 1 if A[i][j] == \\'(\\' else -1\\n                    if 0 <= k:\\n                        dp[i][j].add(k)\\n        return 0 in dp[M - 1][N - 1]\\n```\\n\\n---\\n\\n**Rust Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\ntype VC = Vec<char>;\\ntype VVC = Vec<VC>;\\nimpl Solution {\\n    pub fn has_valid_path(A: VVC) -> bool {\\n        fn go(A: &VVC, i: usize, j: usize, mut k: i32) -> bool {\\n            if i == A.len() || j == A[0].len() {\\n                return false;\\n            }\\n            k += if A[i][j] == \\'(\\' { 1 } else { -1 };\\n            if k < 0 {\\n                return false;\\n            }\\n            if i == A.len() - 1 && j == A[0].len() - 1 {\\n                return k == 0;\\n            }\\n            let D = go(A, i + 1, j, k);\\n            let R = go(A, i, j + 1, k);\\n            return D || R;\\n        }\\n        go(&A, 0, 0, 0)\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\ntype VC = Vec<char>;\\ntype VVC = Vec<VC>;\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn has_valid_path(A: VVC) -> bool {\\n        fn go(A: &VVC, i: usize, j: usize, mut k: i32, m: &mut HashMap::<String, bool>) -> bool {\\n            if i == A.len() || j == A[0].len() {\\n                return false;\\n            }\\n            k += if A[i][j] == \\'(\\' { 1 } else { -1 };\\n            if k < 0 {\\n                return false;\\n            }\\n            if i == A.len() - 1 && j == A[0].len() - 1 {\\n                return k == 0;\\n            }\\n            let key = format!(\"{},{},{}\", i, j, k);\\n            if !m.contains_key(&key) {\\n                let D = go(A, i + 1, j, k, m);\\n                let R = go(A, i, j + 1, k, m);\\n                m.insert(key.clone(), D || R);\\n            }\\n            *m.get(&key).unwrap()\\n        }\\n        let mut m = HashMap::new();\\n        go(&A, 0, 0, 0, &mut m)\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\ntype VC = Vec<char>;\\ntype VVC = Vec<VC>;\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn has_valid_path(A: VVC) -> bool {\\n        let M = A.len();\\n        let N = A[0].len();\\n        let mut dp = vec![vec![HashSet::new(); N]; M];\\n        if A[0][0] == \\'(\\' {\\n            dp[0][0].insert(1);\\n        }\\n        for i in 0..M {\\n            for j in 0..N {\\n                let U = if 0 <= i as i32 - 1 { dp[i - 1][j].clone() } else { HashSet::new() };\\n                let L = if 0 <= j as i32 - 1 { dp[i][j - 1].clone() } else { HashSet::new() };\\n                let cands = U.union(&L);\\n                for k_ in cands {\\n                    let k = k_ + if A[i][j] == \\'(\\' { 1 } else { -1 };\\n                    if 0 <= k {\\n                        dp[i][j].insert(k);\\n                    }\\n                }\\n            }\\n        }\\n        dp[M - 1][N - 1].contains(&0)\\n    }\\n}\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using VC = vector<char>;\\n    using VVC = vector<VC>;\\n    using fun = function<bool(int, int, int)>;\\n    bool hasValidPath(VVC& A) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        fun go = [&](auto i, auto j, auto k) {\\n            if (i == M || j == N)\\n                return false;\\n            k += A[i][j] == \\'(\\' ? 1 : -1;\\n            if (k < 0)\\n                return false;\\n            if (i == M - 1 && j == N - 1)\\n                return !k;\\n            auto D = go(i + 1, j, k),\\n                 R = go(i, j + 1, k);\\n            return D || R;\\n        };\\n        return go(0, 0, 0);\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using VC = vector<char>;\\n    using VVC = vector<VC>;\\n    using fun = function<bool(int, int, int)>;\\n    using Map = unordered_map<string, bool>;\\n    bool hasValidPath(VVC& A, Map m = {}) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        auto hash = [](auto i, auto j, auto k) {\\n            stringstream ss; ss << i << \",\" << j << \",\" << k;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto j, auto k) {\\n            if (i == M || j == N)\\n                return false;\\n            k += A[i][j] == \\'(\\' ? 1 : -1;\\n            if (k < 0)\\n                return false;\\n            if (i == M - 1 && j == N - 1)\\n                return !k;\\n            auto key = hash(i, j, k);\\n            if (m.find(key) == m.end()) {\\n                auto D = go(i + 1, j, k),\\n                     R = go(i, j + 1, k);\\n                m[key] = D || R;\\n            }\\n            return m[key];\\n        };\\n        return go(0, 0, 0);\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VC = vector<char>;\\n    using VVC = vector<VC>;\\n    using Set = unordered_set<int>;\\n    using VS = vector<Set>;\\n    using VVS = vector<VS>;\\n    bool hasValidPath(VVC& A) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        VVS dp(M, VS(N));\\n        if (A[0][0] == \\'(\\')\\n            dp[0][0].insert(1);\\n        for (auto i{ 0 }; i < M; ++i) {\\n            for (auto j{ 0 }; j < N; ++j) {\\n                auto U = 0 <= i - 1 ? dp[i - 1][j] : Set{},\\n                     L = 0 <= j - 1 ? dp[i][j - 1] : Set{};\\n                Set cands;\\n                set_union(U.begin(), U.end(),\\n                          L.begin(), L.end(), inserter(cands, cands.end()));\\n                for (auto k: cands) {\\n                    k += A[i][j] == \\'(\\' ? 1 : -1;\\n                    if (0 <= k)\\n                        dp[i][j].insert(k);\\n                }\\n            }\\n        }\\n        return dp[M - 1][N - 1].find(0) != dp[M - 1][N - 1].end();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun hasValidPath(A: Array<CharArray>): Boolean {\\n        var M = A.size\\n        var N = A[0].size\\n        fun go(i: Int = 0, j: Int = 0, k_: Int = 0): Boolean {\\n            if (i == M || j == N)\\n                return false\\n            var k = k_ + if (A[i][j] == \\'(\\') 1 else -1\\n            if (k < 0)\\n                return false\\n            if (i == M - 1 && j == N - 1)\\n                return k == 0\\n            var D = go(i + 1, j, k)\\n            var R = go(i, j + 1, k)\\n            return D || R\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun hasValidPath(A: Array<CharArray>): Boolean {\\n        var M = A.size\\n        var N = A[0].size\\n        var m = mutableMapOf<String, Boolean>()\\n        fun go(i: Int = 0, j: Int = 0, k_: Int = 0): Boolean {\\n            if (i == M || j == N)\\n                return false\\n            var k = k_ + if (A[i][j] == \\'(\\') 1 else -1\\n            if (k < 0)\\n                return false\\n            if (i == M - 1 && j == N - 1)\\n                return k == 0\\n            var key = \"$i,$j,$k\"\\n            if (!m.contains(key)) {\\n                var D = go(i + 1, j, k)\\n                var R = go(i, j + 1, k)\\n                m[key] = D || R\\n            }\\n            return m[key]!!\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun hasValidPath(A: Array<CharArray>): Boolean {\\n        var M = A.size\\n        var N = A[0].size\\n        var dp = Array(M) { Array(N) { mutableSetOf<Int>() } }\\n        if (A[0][0] == \\'(\\')\\n            dp[0][0].add(1)\\n        for (i in 0 until M) {\\n            for (j in 0 until N) {\\n                var U = if (0 <= i - 1) dp[i - 1][j] else mutableSetOf<Int>()\\n                var L = if (0 <= j - 1) dp[i][j - 1] else mutableSetOf<Int>()\\n                var cands = U union L\\n                for (k_ in cands) {\\n                    var k = k_ + if (A[i][j] == \\'(\\') 1 else -1\\n                    if (0 <= k)\\n                        dp[i][j].add(k)\\n                }\\n            }\\n        }\\n        return dp[M - 1][N - 1].contains(0)\\n    }\\n}\\n```\n```\\nlet hasValidPath = A => {\\n    let M = A.length,\\n        N = A[0].length;\\n    let go = (i = 0, j = 0, k = 0) => {\\n        if (i == M || j == N)\\n            return false;\\n        k += A[i][j] == \\'(\\' ? 1 : -1;\\n        if (k < 0)\\n            return false;\\n        if (i == M - 1 && j == N - 1)\\n            return !k;\\n        let D = go(i + 1, j, k),\\n            R = go(i, j + 1, k);\\n        return D || R;\\n    };\\n    return go();\\n};\\n```\n```\\nlet hasValidPath = (A, m = new Map()) => {\\n    let M = A.length,\\n        N = A[0].length;\\n    let go = (i = 0, j = 0, k = 0) => {\\n        if (i == M || j == N)\\n            return false;\\n        k += A[i][j] == \\'(\\' ? 1 : -1;\\n        if (k < 0)\\n            return false;\\n        if (i == M - 1 && j == N - 1)\\n            return !k;\\n        let key = `${i},${j},${k}`;\\n        if (!m.has(key)) {\\n            let D = go(i + 1, j, k),\\n                R = go(i, j + 1, k);\\n            m.set(key, D || R);\\n        }\\n        return m.get(key);\\n    };\\n    return go();\\n};\\n```\n```\\nlet hasValidPath = A => {\\n    let M = A.length,\\n        N = A[0].length;\\n    let dp = [...Array(M)].map(_ => [...Array(N)].map(_ => new Set()));\\n    if (A[0][0] == \\'(\\')\\n        dp[0][0].add(1);\\n    for (let i = 0; i < M; ++i) {\\n        for (let j = 0; j < N; ++j) {\\n            let U = 0 <= i - 1 ? dp[i - 1][j] : new Set(),\\n                L = 0 <= j - 1 ? dp[i][j - 1] : new Set();\\n            let cands = new Set([...U, ...L]);\\n            for (let k of cands) {\\n                k += A[i][j] == \\'(\\' ? 1 : -1;\\n                if (0 <= k)\\n                    dp[i][j].add(k);\\n            }\\n        }\\n    }\\n    return dp[M - 1][N - 1].has(0);\\n};\\n```\n```\\nclass Solution:\\n    def hasValidPath(self, A: List[List[str]]) -> bool:\\n        M = len(A)\\n        N = len(A[0])\\n        def go(i = 0, j = 0, k = 0):\\n            if i == M or j == N:\\n                return False\\n            k += 1 if A[i][j] == \\'(\\' else -1\\n            if k < 0:\\n                return False\\n            if i == M - 1 and j == N - 1:\\n                return not k\\n            D = go(i + 1, j, k)\\n            R = go(i, j + 1, k)\\n            return D or R\\n        return go()\\n```\n```\\nclass Solution:\\n    def hasValidPath(self, A: List[List[str]]) -> bool:\\n        M = len(A)\\n        N = len(A[0])\\n        @cache\\n        def go(i = 0, j = 0, k = 0):\\n            if i == M or j == N:\\n                return False\\n            k += 1 if A[i][j] == \\'(\\' else -1\\n            if k < 0:\\n                return False\\n            if i == M - 1 and j == N - 1:\\n                return not k\\n            D = go(i + 1, j, k)\\n            R = go(i, j + 1, k)\\n            return D or R\\n        return go()\\n```\n```\\nclass Solution:\\n    def hasValidPath(self, A: List[List[str]]) -> bool:\\n        M = len(A)\\n        N = len(A[0])\\n        dp = [[set() for _ in range(N)] for _ in range(M)]\\n        if A[0][0] == \\'(\\':\\n            dp[0][0].add(1)\\n        for i in range(M):\\n            for j in range(N):\\n                U = dp[i - 1][j] if 0 <= i - 1 else set()\\n                L = dp[i][j - 1] if 0 <= j - 1 else set()\\n                for k in U.union(L):\\n                    k += 1 if A[i][j] == \\'(\\' else -1\\n                    if 0 <= k:\\n                        dp[i][j].add(k)\\n        return 0 in dp[M - 1][N - 1]\\n```\n```\\ntype VC = Vec<char>;\\ntype VVC = Vec<VC>;\\nimpl Solution {\\n    pub fn has_valid_path(A: VVC) -> bool {\\n        fn go(A: &VVC, i: usize, j: usize, mut k: i32) -> bool {\\n            if i == A.len() || j == A[0].len() {\\n                return false;\\n            }\\n            k += if A[i][j] == \\'(\\' { 1 } else { -1 };\\n            if k < 0 {\\n                return false;\\n            }\\n            if i == A.len() - 1 && j == A[0].len() - 1 {\\n                return k == 0;\\n            }\\n            let D = go(A, i + 1, j, k);\\n            let R = go(A, i, j + 1, k);\\n            return D || R;\\n        }\\n        go(&A, 0, 0, 0)\\n    }\\n}\\n```\n```\\ntype VC = Vec<char>;\\ntype VVC = Vec<VC>;\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn has_valid_path(A: VVC) -> bool {\\n        fn go(A: &VVC, i: usize, j: usize, mut k: i32, m: &mut HashMap::<String, bool>) -> bool {\\n            if i == A.len() || j == A[0].len() {\\n                return false;\\n            }\\n            k += if A[i][j] == \\'(\\' { 1 } else { -1 };\\n            if k < 0 {\\n                return false;\\n            }\\n            if i == A.len() - 1 && j == A[0].len() - 1 {\\n                return k == 0;\\n            }\\n            let key = format!(\"{},{},{}\", i, j, k);\\n            if !m.contains_key(&key) {\\n                let D = go(A, i + 1, j, k, m);\\n                let R = go(A, i, j + 1, k, m);\\n                m.insert(key.clone(), D || R);\\n            }\\n            *m.get(&key).unwrap()\\n        }\\n        let mut m = HashMap::new();\\n        go(&A, 0, 0, 0, &mut m)\\n    }\\n}\\n```\n```\\ntype VC = Vec<char>;\\ntype VVC = Vec<VC>;\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn has_valid_path(A: VVC) -> bool {\\n        let M = A.len();\\n        let N = A[0].len();\\n        let mut dp = vec![vec![HashSet::new(); N]; M];\\n        if A[0][0] == \\'(\\' {\\n            dp[0][0].insert(1);\\n        }\\n        for i in 0..M {\\n            for j in 0..N {\\n                let U = if 0 <= i as i32 - 1 { dp[i - 1][j].clone() } else { HashSet::new() };\\n                let L = if 0 <= j as i32 - 1 { dp[i][j - 1].clone() } else { HashSet::new() };\\n                let cands = U.union(&L);\\n                for k_ in cands {\\n                    let k = k_ + if A[i][j] == \\'(\\' { 1 } else { -1 };\\n                    if 0 <= k {\\n                        dp[i][j].insert(k);\\n                    }\\n                }\\n            }\\n        }\\n        dp[M - 1][N - 1].contains(&0)\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VC = vector<char>;\\n    using VVC = vector<VC>;\\n    using fun = function<bool(int, int, int)>;\\n    bool hasValidPath(VVC& A) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        fun go = [&](auto i, auto j, auto k) {\\n            if (i == M || j == N)\\n                return false;\\n            k += A[i][j] == \\'(\\' ? 1 : -1;\\n            if (k < 0)\\n                return false;\\n            if (i == M - 1 && j == N - 1)\\n                return !k;\\n            auto D = go(i + 1, j, k),\\n                 R = go(i, j + 1, k);\\n            return D || R;\\n        };\\n        return go(0, 0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VC = vector<char>;\\n    using VVC = vector<VC>;\\n    using fun = function<bool(int, int, int)>;\\n    using Map = unordered_map<string, bool>;\\n    bool hasValidPath(VVC& A, Map m = {}) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        auto hash = [](auto i, auto j, auto k) {\\n            stringstream ss; ss << i << \",\" << j << \",\" << k;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto j, auto k) {\\n            if (i == M || j == N)\\n                return false;\\n            k += A[i][j] == \\'(\\' ? 1 : -1;\\n            if (k < 0)\\n                return false;\\n            if (i == M - 1 && j == N - 1)\\n                return !k;\\n            auto key = hash(i, j, k);\\n            if (m.find(key) == m.end()) {\\n                auto D = go(i + 1, j, k),\\n                     R = go(i, j + 1, k);\\n                m[key] = D || R;\\n            }\\n            return m[key];\\n        };\\n        return go(0, 0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VC = vector<char>;\\n    using VVC = vector<VC>;\\n    using Set = unordered_set<int>;\\n    using VS = vector<Set>;\\n    using VVS = vector<VS>;\\n    bool hasValidPath(VVC& A) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        VVS dp(M, VS(N));\\n        if (A[0][0] == \\'(\\')\\n            dp[0][0].insert(1);\\n        for (auto i{ 0 }; i < M; ++i) {\\n            for (auto j{ 0 }; j < N; ++j) {\\n                auto U = 0 <= i - 1 ? dp[i - 1][j] : Set{},\\n                     L = 0 <= j - 1 ? dp[i][j - 1] : Set{};\\n                Set cands;\\n                set_union(U.begin(), U.end(),\\n                          L.begin(), L.end(), inserter(cands, cands.end()));\\n                for (auto k: cands) {\\n                    k += A[i][j] == \\'(\\' ? 1 : -1;\\n                    if (0 <= k)\\n                        dp[i][j].insert(k);\\n                }\\n            }\\n        }\\n        return dp[M - 1][N - 1].find(0) != dp[M - 1][N - 1].end();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136427,
                "title": "c-easy-to-understand-dp-code-3d-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<vector<char>> &grid,int i,int j,int n,int m,vector<vector<vector<int>>> &dp,int count)\\n    {\\n        if(i>=n||j>=m)\\n        {\\n            return false;\\n        }\\n        if(count>(n+m)/2)\\n        {\\n            return dp[i][j][count]=false;\\n        }\\n        if(grid[i][j]==\\'(\\')\\n        {\\n            count++;\\n        }\\n        else\\n        {\\n            count--;\\n        }\\n        if(count<0)\\n        {\\n            return false;\\n        }\\n        if(dp[i][j][count]!=-1)\\n        {\\n            return dp[i][j][count];\\n        }\\n        if(i==n-1&&j==m-1&&count==0)\\n        {\\n            return dp[i][j][count]=true;\\n        }\\n        bool ans=false;\\n        if(solve(grid,i+1,j,n,m,dp,count)||solve(grid,i,j+1,n,m,dp,count))\\n        {\\n            ans=true;\\n        }\\n        return dp[i][j][count]=ans;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(m+1,vector<int>(202,-1)));\\n        return solve(grid,0,0,n,m,dp,0);\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<vector<char>> &grid,int i,int j,int n,int m,vector<vector<vector<int>>> &dp,int count)\\n    {\\n        if(i>=n||j>=m)\\n        {\\n            return false;\\n        }\\n        if(count>(n+m)/2)\\n        {\\n            return dp[i][j][count]=false;\\n        }\\n        if(grid[i][j]==\\'(\\')\\n        {\\n            count++;\\n        }\\n        else\\n        {\\n            count--;\\n        }\\n        if(count<0)\\n        {\\n            return false;\\n        }\\n        if(dp[i][j][count]!=-1)\\n        {\\n            return dp[i][j][count];\\n        }\\n        if(i==n-1&&j==m-1&&count==0)\\n        {\\n            return dp[i][j][count]=true;\\n        }\\n        bool ans=false;\\n        if(solve(grid,i+1,j,n,m,dp,count)||solve(grid,i,j+1,n,m,dp,count))\\n        {\\n            ans=true;\\n        }\\n        return dp[i][j][count]=ans;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(m+1,vector<int>(202,-1)));\\n        return solve(grid,0,0,n,m,dp,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128202,
                "title": "c-simple-and-correct-solution-dp",
                "content": "**r :- rows, c :- columns, o :- number of opening brackets**\\nwhen we reach at the last index i.e (grid[m-1][n-1]) ,after following the path we check that \\n1- there should be closed bracket in cell [m-1][n-1].\\n2 - after reaching the last cell there should only be 1 opening bracket left that will be balanced by the closed bracket in the last cell.\\nif this 2 condition are true the we store true.\\n\\nFor optimization we use memoization to store the state of the recursion.\\n\\n**If you liked the solution . please upvote!!!** \\uD83D\\uDE0E\\n\\n\\tclass Solution {\\n\\tpublic:\\n    bool ans= false;\\n    int t[101][101][1001];\\n    void solve(vector<vector<char>>& g,int r,int c,int o)\\n    {\\n        if(t[r][c][o]!=0)\\n            return;\\n        if(r>g.size()-1||c>g[0].size()-1)\\n            return;\\n        if(r==g.size()-1&&c==g[0].size()-1)\\n        {\\n            if(g[r][c]==\\')\\'&& o==1)\\n                ans=true;\\n            return;\\n        }\\n            if(g[r][c]==\\'(\\')\\n            {\\n                int t = o+1;\\n                solve(g,r,c+1,t);\\n                solve(g,r+1,c,t);\\n            }\\n            else if(o>0 && g[r][c]==\\')\\')\\n            {\\n                int t = o-1;\\n                solve(g,r,c+1,t);\\n                solve(g,r+1,c,t);\\n            }\\n        t[r][c][o] = 1;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        memset(t,0,sizeof(t));\\n        solve(grid,0,0,0);\\n        return ans;\\n    }\\n\\t};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    bool ans= false;\\n    int t[101][101][1001];\\n    void solve(vector<vector<char>>& g,int r,int c,int o)\\n    {\\n        if(t[r][c][o]!=0)\\n            return;\\n        if(r>g.size()-1||c>g[0].size()-1)\\n            return;\\n        if(r==g.size()-1&&c==g[0].size()-1)\\n        {\\n            if(g[r][c]==\\')\\'&& o==1)\\n                ans=true;\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2067060,
                "title": "memoization-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<char>>& grid,int count,int n,int m,int i,int j,vector<vector<vector<int>>>&dp){\\n        if(i<0 || i>=n || j<0 || j>=m)return false;\\n       // cout<<grid[i][j]<<count<<\" \";\\n        if(grid[i][j]==\\')\\'){\\n            if(count<=0)return 0;\\n            else count--;\\n        }\\n        \\n        \\n        if(grid[i][j]==\\'(\\')count++;\\n         \\n        \\n        if(i==n-1 && j==m-1){\\n            if(count==0){\\n                return 1;\\n            }\\n        }\\n        if(dp[i][j][count]!=-1)return dp[i][j][count];\\n        \\n        //down \\n        if(solve(grid,count,n,m,i+1,j,dp)==1)return dp[i][j][count] = 1;\\n        if(solve(grid,count,n,m,i,j+1,dp)==1)return dp[i][j][count]=1; //left\\n        \\n        \\n        \\n        \\n       \\n        return dp[i][j][count]=0;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n       vector<vector<vector<int>>>dp(n,vector<vector<int>>(m,vector<int>(m+n,-1)));\\n        int count=0;\\n       \\n        int sol = solve(grid,count,n,m,0,0,dp);\\n       \\n        \\n        if(sol==1)return true;\\n    \\n        return false;\\n    }\\n};\\n```\\nI\\'m so proud of me for solving this. Literally lost a night\\'s sleep over this one",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<char>>& grid,int count,int n,int m,int i,int j,vector<vector<vector<int>>>&dp){\\n        if(i<0 || i>=n || j<0 || j>=m)return false;\\n       // cout<<grid[i][j]<<count<<\" \";\\n        if(grid[i][j]==\\')\\'){\\n            if(count<=0)return 0;\\n            else count--;\\n        }\\n        \\n        \\n        if(grid[i][j]==\\'(\\')count++;\\n         \\n        \\n        if(i==n-1 && j==m-1){\\n            if(count==0){\\n                return 1;\\n            }\\n        }\\n        if(dp[i][j][count]!=-1)return dp[i][j][count];\\n        \\n        //down \\n        if(solve(grid,count,n,m,i+1,j,dp)==1)return dp[i][j][count] = 1;\\n        if(solve(grid,count,n,m,i,j+1,dp)==1)return dp[i][j][count]=1; //left\\n        \\n        \\n        \\n        \\n       \\n        return dp[i][j][count]=0;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n       vector<vector<vector<int>>>dp(n,vector<vector<int>>(m,vector<int>(m+n,-1)));\\n        int count=0;\\n       \\n        int sol = solve(grid,count,n,m,0,0,dp);\\n       \\n        \\n        if(sol==1)return true;\\n    \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2060185,
                "title": "the-one-optimization-to-speed-up-your-memoization",
                "content": "Intuition behind optimizing memoization-\\nThe path length in any scenario irrespective of the path we take would always be equal to n+m-1 since we can only move right or downwards and we\\'ll have to cover n depth and m width.\\nSince we know that the number of open and closed brackets would be same in the end we can conclude that at any moment, the open brackets would be less than or equal to (n+m-1)/2.\\nAs most of the solutions are using the no. of open brackets for memoization we can reduce the size of our vector signifcantly by making the max no. of open brackets as (n+m-1)/2 instead of n * m.\\n\\n``\\nclass Solution {\\npublic:\\nbool helper(int i,int j,int o,vector<vector<char>>&grid,vector<vector<vector<int>>>&memo){  \\n    int n=grid.size();\\n    int m=grid[0].size();\\n    if(o>(n+m)/2)  return false; \\n    if(i>=n or i<0 or j>=m or j<0)return false;\\n                                                                                                     if(i==n-1 and j==m-1){\\n        if(o==1)return true;\\n        return false;\\n    }         \\n    if(memo[i][j][o]!=-1)return memo[i][j][o];\\n    char curr=grid[i][j];\\n    \\n    if(curr==\\')\\'){\\n        if(o>=1)\\n             return memo[i][j][o]=helper(i+1,j,o-1,grid,memo) or helper(i,j+1,o-1,grid,memo);\\n        else return memo[i][j][o]=false;\\n    }\\n      else  return memo[i][j][o]=helper(i+1,j,o+1,grid,memo) or helper(i,j+1,o+1,grid,memo);\\n      \\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<vector<int>>>memo(n,vector<vector<int>>(m,vector<int>((n+m)/2+1,-1)));\\n        if(grid[n-1][m-1]==\\'(\\')return false;\\n        \\n        return helper(0,0,0,grid,memo);\\n        \\n    }\\n};\\n``",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\nbool helper(int i,int j,int o,vector<vector<char>>&grid,vector<vector<vector<int>>>&memo){  \\n    int n=grid.size();\\n    int m=grid[0].size();\\n    if(o>(n+m)/2)  return false; \\n    if(i>=n or i<0 or j>=m or j<0)return false;\\n                                                                                                     if(i==n-1 and j==m-1){\\n        if(o==1)return true;\\n        return false;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2050921,
                "title": "c-classic-dfs-dp",
                "content": "* **If at any point in our traversal we find that open has become negative then return false as there is no way to balance a `)` bracket if it arrives before `(`.** \\n \\n```\\nclass Solution {\\npublic:\\n    int r ,c ;\\n    int dp[101][101][1001] ;\\n    bool solve(int x , int y , vector<vector<char>>&grid , int open ){\\n        if(x >= r || y >= c) return false ;\\n        open += grid[x][y] == \\'(\\' ? 1 : -1 ;\\n        if(open < 0) return false ;\\n        if(x == r - 1 and y == c - 1 ) return (open == 0) ;\\n        \\n        if(dp[x][y][open] != -1) return dp[x][y][open] ;\\n        \\n        bool path1 = solve(x,y+1,grid,open) ;\\n        bool path2 = solve(x+1,y,grid,open) ;\\n        return dp[x][y][open] = (path1 or path2) ;\\n        \\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        r = grid.size() ;\\n        c = grid[0].size() ;\\n        memset(dp,-1,sizeof(dp)) ;\\n        return solve(0,0,grid,0) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int r ,c ;\\n    int dp[101][101][1001] ;\\n    bool solve(int x , int y , vector<vector<char>>&grid , int open ){\\n        if(x >= r || y >= c) return false ;\\n        open += grid[x][y] == \\'(\\' ? 1 : -1 ;\\n        if(open < 0) return false ;\\n        if(x == r - 1 and y == c - 1 ) return (open == 0) ;\\n        \\n        if(dp[x][y][open] != -1) return dp[x][y][open] ;\\n        \\n        bool path1 = solve(x,y+1,grid,open) ;\\n        bool path2 = solve(x+1,y,grid,open) ;\\n        return dp[x][y][open] = (path1 or path2) ;\\n        \\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        r = grid.size() ;\\n        c = grid[0].size() ;\\n        memset(dp,-1,sizeof(dp)) ;\\n        return solve(0,0,grid,0) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031616,
                "title": "simple-dp-memomization-faster-and-easy-to-understand",
                "content": "Simple Intution ,It is same as to find the Path from top left corner to right down corner but here the catch is to find the valid path which should statisfy the given conditions like **()** (parentheses)\\n\\nAnd there is a condition we should take care \\n1. The Path should not start with **)**. \\n2. The path should not end with **(**.\\n\\n**DP Approach**\\n* First take a variable lets say **start**  which will count the parentheses i.e if \"**(**\" then start++  if \"**)**\" start--.\\n* Traverse the all possible paths with right and down.\\n* Until it statisfy the condition i.e (n-1,m-1 and start=0)\\n* if the start is 0 at the end that means we got a path with equal no of parentheses.\\n* To Optimize the code Use Memomization.\\n\\n```\\nclass Solution {\\n    Boolean dp[][][];\\n    public boolean hasValidPath(char[][] grid) \\n    {\\n        dp=new Boolean[grid.length][grid[0].length][grid.length+grid[0].length];\\n        return helper(grid,0,0,0);\\n    }\\n    public boolean helper(char[][] grid,int i,int j,int start)\\n    {\\n        if(i>=grid.length || j>=grid[0].length) return false;\\n        if(grid[i][j]==\\'(\\')\\n            start++;\\n        else\\n            start--;\\n        if(start<0) return false;\\n        if(i==grid.length-1 && j==grid[0].length-1) return start==0;\\n        if(dp[i][j][start]!=null) return dp[i][j][start];\\n        dp[i][j][start]=(helper(grid,i+1,j,start) || helper(grid,i,j+1,start));\\n        return dp[i][j][start];\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Boolean dp[][][];\\n    public boolean hasValidPath(char[][] grid) \\n    {\\n        dp=new Boolean[grid.length][grid[0].length][grid.length+grid[0].length];\\n        return helper(grid,0,0,0);\\n    }\\n    public boolean helper(char[][] grid,int i,int j,int start)\\n    {\\n        if(i>=grid.length || j>=grid[0].length) return false;\\n        if(grid[i][j]==\\'(\\')\\n            start++;\\n        else\\n            start--;\\n        if(start<0) return false;\\n        if(i==grid.length-1 && j==grid[0].length-1) return start==0;\\n        if(dp[i][j][start]!=null) return dp[i][j][start];\\n        dp[i][j][start]=(helper(grid,i+1,j,start) || helper(grid,i,j+1,start));\\n        return dp[i][j][start];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2028833,
                "title": "python-simple-dp-solution-top-down",
                "content": "Here is a simple solution\\n\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m,n=len(grid), len(grid[0])\\n        \\n        # first value in the grid should be \\'(\\' and last value be \\')\\'\\n        if grid[0][0]!=\\'(\\' or grid[-1][-1]!=\\')\\':\\n            return False\\n\\n        @lru_cache(None)\\n        def dp(i,j,c):\\n            # When we reach the last cell, the number of open brackets should be 1.\\n            # \\')\\' from last cell balances it\\n            if i==m-1 and j==n-1:\\n                if c==1:\\n                    return True\\n                else:\\n                    return False\\n            # i,j should be within the range of m,n\\n            if i>=m or j>=n:\\n                return False\\n            \\n            res=False\\n            # From every cell, we can move right(j+1) or down(i+1)\\n            if grid[i][j]==\\'(\\':\\n                # When we encounter \\'(\\' we increment count by 1\\n                res=res or dp(i+1, j, c+1) or dp(i, j+1, c+1)\\n            else:\\n                # When we encounter \\')\\' number of of open brackets must be greater than 0\\n                if c>0:\\n                    # Decrement the count by 1\\n                    res=res or dp(i+1, j, c-1) or dp(i, j+1, c-1)\\n            return res\\n        return dp(0,0,0)\\n        \\n\\t",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "Here is a simple solution\\n\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m,n=len(grid), len(grid[0])\\n        \\n        # first value in the grid should be \\'(\\' and last value be \\')\\'\\n        if grid[0][0]!=\\'(\\' or grid[-1][-1]!=\\')\\':\\n            return False\\n\\n        @lru_cache(None)\\n        def dp(i,j,c):\\n            # When we reach the last cell, the number of open brackets should be 1.\\n            # \\')\\' from last cell balances it\\n            if i==m-1 and j==n-1:\\n                if c==1:\\n                    return True\\n                else:\\n                    return False\\n            # i,j should be within the range of m,n\\n            if i>=m or j>=n:\\n                return False\\n            \\n            res=False\\n            # From every cell, we can move right(j+1) or down(i+1)\\n            if grid[i][j]==\\'(\\':\\n                # When we encounter \\'(\\' we increment count by 1\\n                res=res or dp(i+1, j, c+1) or dp(i, j+1, c+1)\\n            else:\\n                # When we encounter \\')\\' number of of open brackets must be greater than 0\\n                if c>0:\\n                    # Decrement the count by 1\\n                    res=res or dp(i+1, j, c-1) or dp(i, j+1, c-1)\\n            return res\\n        return dp(0,0,0)\\n        \\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 2026194,
                "title": "python-and-memorize",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        \\n        m, n = len(grid), len(grid[0])\\n        if grid[0][0] == \\')\\':\\n            return False\\n        if grid[-1][-1] == \\'(\\':\\n            return False\\n        if (m + n) % 2 == 0:\\n            return False\\n        \\n        halfLen = (m + n) // 2\\n        \\n        helper = [[set([]) for _ in range(n)] for _ in range(m)]\\n        helper[0][0].add(1)\\n        \\n        for c in range(1, n):\\n            for e in helper[0][c-1]:\\n                if halfLen >= e + (1 if grid[0][c] == \\'(\\' else -1) >= 0:\\n                    helper[0][c].add(  e + (1 if grid[0][c] == \\'(\\' else -1) )\\n            \\n        for r in range(1, m):\\n            lst = [e + ( 1 if grid[r][0] == \\'(\\' else -1 ) for e in helper[r-1][0] if halfLen >= e + (1 if grid[r][0] == \\'(\\' else -1) >= 0]\\n            for e in lst:\\n                helper[r][0].add(e)\\n            \\n            for c in range(1, n):\\n                lst = [e + ( 1 if grid[r][c] == \\'(\\' else -1 ) for e in helper[r-1][c].union(helper[r][c-1]) if halfLen >= e + (1 if grid[r][c] == \\'(\\' else -1) >= 0]\\n                \\n                for e in lst:\\n                    helper[r][c].add(e)\\n                    \\n        \\n        return 0 in helper[-1][-1]\\n                \\n        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        \\n        m, n = len(grid), len(grid[0])\\n        if grid[0][0] == \\')\\':\\n            return False\\n        if grid[-1][-1] == \\'(\\':\\n            return False\\n        if (m + n) % 2 == 0:\\n            return False\\n        \\n        halfLen = (m + n) // 2\\n        \\n        helper = [[set([]) for _ in range(n)] for _ in range(m)]\\n        helper[0][0].add(1)\\n        \\n        for c in range(1, n):\\n            for e in helper[0][c-1]:\\n                if halfLen >= e + (1 if grid[0][c] == \\'(\\' else -1) >= 0:\\n                    helper[0][c].add(  e + (1 if grid[0][c] == \\'(\\' else -1) )\\n            \\n        for r in range(1, m):\\n            lst = [e + ( 1 if grid[r][0] == \\'(\\' else -1 ) for e in helper[r-1][0] if halfLen >= e + (1 if grid[r][0] == \\'(\\' else -1) >= 0]\\n            for e in lst:\\n                helper[r][0].add(e)\\n            \\n            for c in range(1, n):\\n                lst = [e + ( 1 if grid[r][c] == \\'(\\' else -1 ) for e in helper[r-1][c].union(helper[r][c-1]) if halfLen >= e + (1 if grid[r][c] == \\'(\\' else -1) >= 0]\\n                \\n                for e in lst:\\n                    helper[r][c].add(e)\\n                    \\n        \\n        return 0 in helper[-1][-1]\\n                \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024969,
                "title": "cpp-explanation-99-faster-using-0-1-knapsack-and-dp-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dp[101][101][101]; \\n    // dp[i][j][k] stores the ans at position i,j where the difference between the number of left and the right brackets is k\\n    int vis[101][101][101];\\n    // vis[i][j][k] stores of we ever visit the position i, j where the difference between the number of left and the right brackets is k\\n    int n, m;\\n    bool find(int x, int y, vector<vector<char>>&grid, int l, int r){\\n        if(r > l) return false; // for optimizatin if right brackets if > left bracketthen obviously we can\\'t reach to an ans eg:- ()) \\n        if(l > (n+m-1)/2) return false; // in our final ans l will be equals to (n+m-1)/2 in case it is more than our required value we are on the wrong path\\n        if(vis[x][y][l-r] != -1) return dp[x][y][l-r];  // using memorization\\n        vis[x][y][l-r] = 1; // mark this position as visited\\n        if(x == n-1 && y == m-1){   // if we reach at bottom right\\n            return dp[x][y][l-r] = (l == r);    // return if l==r or not\\n        }\\n        bool ans = false; \\n        if(x != n-1){ // if we can go down then try going down\\n            ans |= find(x+1, y, grid, l + (grid[x+1][y] == \\'(\\'), r + (grid[x+1][y] == \\')\\'));\\n        }\\n        if(ans) return dp[x][y][l-r] = ans; // if we find the ans return true no need to go to the right side now\\n        if(y != m-1){\\n            // in case we do not find the ans go right\\n            ans |= find(x, y+1, grid, l + (grid[x][y+1] == \\'(\\'), r + (grid[x][y+1] == \\')\\'));\\n        }\\n        return dp[x][y][l-r] = ans; //return the ans\\n        \\n    }\\n    \\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        if(grid[0][0] == \\')\\') return false; // if 1st grid is right bracket then return false;\\n        n = grid.size();\\n        m = grid[0].size();\\n        if((n + m - 1)&1) return false; // if the path contains odd number of grid return false\\n        memset(dp, false, sizeof(dp));\\n        memset(vis, -1, sizeof(vis));\\n        return find(0, 0, grid, 1, 0);  // return the ans\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dp[101][101][101]; \\n    // dp[i][j][k] stores the ans at position i,j where the difference between the number of left and the right brackets is k\\n    int vis[101][101][101];\\n    // vis[i][j][k] stores of we ever visit the position i, j where the difference between the number of left and the right brackets is k\\n    int n, m;\\n    bool find(int x, int y, vector<vector<char>>&grid, int l, int r){\\n        if(r > l) return false; // for optimizatin if right brackets if > left bracketthen obviously we can\\'t reach to an ans eg:- ()) \\n        if(l > (n+m-1)/2) return false; // in our final ans l will be equals to (n+m-1)/2 in case it is more than our required value we are on the wrong path\\n        if(vis[x][y][l-r] != -1) return dp[x][y][l-r];  // using memorization\\n        vis[x][y][l-r] = 1; // mark this position as visited\\n        if(x == n-1 && y == m-1){   // if we reach at bottom right\\n            return dp[x][y][l-r] = (l == r);    // return if l==r or not\\n        }\\n        bool ans = false; \\n        if(x != n-1){ // if we can go down then try going down\\n            ans |= find(x+1, y, grid, l + (grid[x+1][y] == \\'(\\'), r + (grid[x+1][y] == \\')\\'));\\n        }\\n        if(ans) return dp[x][y][l-r] = ans; // if we find the ans return true no need to go to the right side now\\n        if(y != m-1){\\n            // in case we do not find the ans go right\\n            ans |= find(x, y+1, grid, l + (grid[x][y+1] == \\'(\\'), r + (grid[x][y+1] == \\')\\'));\\n        }\\n        return dp[x][y][l-r] = ans; //return the ans\\n        \\n    }\\n    \\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        if(grid[0][0] == \\')\\') return false; // if 1st grid is right bracket then return false;\\n        n = grid.size();\\n        m = grid[0].size();\\n        if((n + m - 1)&1) return false; // if the path contains odd number of grid return false\\n        memset(dp, false, sizeof(dp));\\n        memset(vis, -1, sizeof(vis));\\n        return find(0, 0, grid, 1, 0);  // return the ans\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024123,
                "title": "java-dp-solution-with-explanation",
                "content": "\\n**Explanation**\\nFor each ceel A[i][j]\\nwe count the number of open parenthese for the path reaching A[i][j].\\nIf it\\'s negative, it\\'s not valid already.\\nFinally we check if there is a path to A[m-1][n-1] that has no open parenthese,\\nthat means a valid parentheses string path reaching A[m-1][n-1].\\n\\n\\n**Optimisation**\\nI usually don\\'t handle edge cases specially,\\nsince they can be correctly handled by itself.\\nAnd usually the short cut only improve edge case, not general case,\\n\\nHere are 3 quick fail case:\\nIf (n + m) % 2 == 0, the length of path to A[m-1][n-1] is odd, can return false.\\nIf A[-1][-1] == \\'(\\', no valid start can return false.\\nIf A[0][0] == \\')\\', no valid end, can return false.\\n\\n```\\n    public boolean hasValidPath(char[][] A) {\\n        int m = A.length, n = A[0].length;\\n        boolean[][][] dp = new boolean[m + 1][n + 1][103];\\n        dp[0][0][1] = true;\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                for (int k = 1; k <= 101; ++k) {\\n                    dp[i][j + 1][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                    dp[i + 1][j][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                }\\n        return dp[m][n - 1][1];\\n    }\\n```\\n\\nTrick 1:\\nA[i][j][0] for the path count -1,\\nA[i][j][1] for the path count 0, etc.\\nNo need to handle negative specially.\\n\\nTrick 2:\\nUse something like A[i+1] += A[i] instead of A[i] = A[i-1]\\nNo need to handle i == 0 and j == 0 specially.\\n\\nTrick 3:\\ndp[m][n - 1] and dp[m - 1][n] are from dp[m - 1][n - 1],\\nreturn dp[m][n - 1][1] for the result.\\n\\nBy help of @lee215",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n    public boolean hasValidPath(char[][] A) {\\n        int m = A.length, n = A[0].length;\\n        boolean[][][] dp = new boolean[m + 1][n + 1][103];\\n        dp[0][0][1] = true;\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                for (int k = 1; k <= 101; ++k) {\\n                    dp[i][j + 1][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                    dp[i + 1][j][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                }\\n        return dp[m][n - 1][1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2022808,
                "title": "easy-dfs-java-soln",
                "content": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        return helper(grid, 0, 0, 0, new Boolean[m][n][m + n]);\\n    }\\n    \\n    private boolean helper(char[][] grid, int i, int j, int bal, Boolean [][][] visit){\\n        if(i >= grid.length || j >= grid[0].length || bal < 0){\\n            return false;\\n        }\\n        \\n        if(visit[i][j][bal] != null){\\n            return visit[i][j][bal];\\n        }\\n        \\n        int updateBal = bal + (grid[i][j] == \\'(\\' ? 1 : -1);\\n        \\n        if(i == grid.length - 1 && j == grid[0].length - 1 && updateBal == 0){\\n            return true;\\n        }\\n        \\n        boolean d = helper(grid, i + 1, j, updateBal, visit);\\n        boolean r = helper(grid, i, j + 1, updateBal, visit);\\n        visit[i][j][bal] = d || r;\\n        return d || r;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        return helper(grid, 0, 0, 0, new Boolean[m][n][m + n]);\\n    }\\n    \\n    private boolean helper(char[][] grid, int i, int j, int bal, Boolean [][][] visit){\\n        if(i >= grid.length || j >= grid[0].length || bal < 0){\\n            return false;\\n        }\\n        \\n        if(visit[i][j][bal] != null){\\n            return visit[i][j][bal];\\n        }\\n        \\n        int updateBal = bal + (grid[i][j] == \\'(\\' ? 1 : -1);\\n        \\n        if(i == grid.length - 1 && j == grid[0].length - 1 && updateBal == 0){\\n            return true;\\n        }\\n        \\n        boolean d = helper(grid, i + 1, j, updateBal, visit);\\n        boolean r = helper(grid, i, j + 1, updateBal, visit);\\n        visit[i][j][bal] = d || r;\\n        return d || r;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2022762,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    HashMap<String, Boolean> mem = new HashMap();\\n    public boolean hasValidPath(char[][] grid) {\\n        return dfs(grid, 0, 0, 0);\\n    }\\n    \\n    \\n    boolean dfs(char[][] g, int r, int c, int v) {\\n        if (r == g.length-1 && c == g[0].length-1) {\\n            if (g[r][c] == \\'(\\') v++;\\n            else v--;\\n            if (v == 0) return true;\\n            else return false;\\n        } \\n        if (r < 0 || c < 0 || r>g.length-1 || c > g[0].length-1) return false;\\n        \\n        String key = (r * g.length + c) + \"_\" + v;\\n        if (mem.containsKey(key)) return mem.get(key);\\n        boolean ans = false;\\n        if (g[r][c] == \\'(\\') v++;\\n        else {\\n            v--;\\n            if (v < 0) {\\n                mem.put(key, false);\\n                return false;\\n            }\\n        }\\n        ans = ans || dfs(g, r+1,c,v);\\n        ans = ans || dfs(g, r, c+1, v);\\n\\n        mem.put(key, ans);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<String, Boolean> mem = new HashMap();\\n    public boolean hasValidPath(char[][] grid) {\\n        return dfs(grid, 0, 0, 0);\\n    }\\n    \\n    \\n    boolean dfs(char[][] g, int r, int c, int v) {\\n        if (r == g.length-1 && c == g[0].length-1) {\\n            if (g[r][c] == \\'(\\') v++;\\n            else v--;\\n            if (v == 0) return true;\\n            else return false;\\n        } \\n        if (r < 0 || c < 0 || r>g.length-1 || c > g[0].length-1) return false;\\n        \\n        String key = (r * g.length + c) + \"_\" + v;\\n        if (mem.containsKey(key)) return mem.get(key);\\n        boolean ans = false;\\n        if (g[r][c] == \\'(\\') v++;\\n        else {\\n            v--;\\n            if (v < 0) {\\n                mem.put(key, false);\\n                return false;\\n            }\\n        }\\n        ans = ans || dfs(g, r+1,c,v);\\n        ans = ans || dfs(g, r, c+1, v);\\n\\n        mem.put(key, ans);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2022322,
                "title": "c-recursion-memoization-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int row, col;\\n    int dp[101][101][202];\\n    \\n    bool solve(vector<vector<char>>& grid, int i, int j, int score){\\n        // if out of grid, return false\\n         if(i >= row || j >= col) return false ;\\n        \\n        // calculate score\\n         if(grid[i][j] == \\'(\\') score++;\\n         else score--;\\n         \\n        // if score is negative than it means that this parentheses is not valid, return false\\n         if(score < 0) return false;\\n        \\n        // if we reach to the destination with score = 0, it is a valid path, return true;\\n         if(i == grid.size() - 1 && j == grid[0].size() - 1 && score == 0){\\n              return true;\\n         }\\n         \\n         // if we already know the answer, return that\\n         if(dp[i][j][score] != -1) return dp[i][j][score];\\n        \\n         // else calulate the answer in moving down, right, and calculate the answer and return\\n         return dp[i][j][score] = solve(grid, i + 1, j , score) || solve(grid, i , j + 1, score);\\n    }\\n    \\n    \\n    bool hasValidPath(vector<vector<char>>& grid) {\\n         row = grid.size(), col = grid[0].size();\\n         memset(dp,-1, sizeof(dp));\\n         return  solve(grid, 0,0, 0);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int row, col;\\n    int dp[101][101][202];\\n    \\n    bool solve(vector<vector<char>>& grid, int i, int j, int score){\\n        // if out of grid, return false\\n         if(i >= row || j >= col) return false ;\\n        \\n        // calculate score\\n         if(grid[i][j] == \\'(\\') score++;\\n         else score--;\\n         \\n        // if score is negative than it means that this parentheses is not valid, return false\\n         if(score < 0) return false;\\n        \\n        // if we reach to the destination with score = 0, it is a valid path, return true;\\n         if(i == grid.size() - 1 && j == grid[0].size() - 1 && score == 0){\\n              return true;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 2021722,
                "title": "java-maintain-the-number-of-opening-and-closing-the-brackets-and-memoize-it",
                "content": "```\\nclass Solution {\\n    private int R;\\n    private int C;\\n    private int[][][] dp;\\n    \\n    public boolean hasValidPath(char[][] grid) {\\n        \\n        this.R = grid.length;\\n        this.C = grid[0].length;\\n        this.dp = new int[R+1][C+1][201];\\n        \\n        for(int[][] i : dp){\\n            for(int[] j : i){\\n                Arrays.fill(j, -1);\\n            }\\n        }\\n        \\n        if(find(0, 0, 0, 0, grid)) return true;\\n        \\n        return false;\\n    }\\n    \\n    private boolean find(int r, int c, int left, int right, char[][] grid){\\n        if(r < 0 || r >= R ||c < 0 || c >= C){\\n            return false;\\n        }\\n        \\n        if(grid[r][c] == \\'(\\'){\\n            left++;\\n        }else right++;\\n        \\n        if(left == right && r == R-1 && c == C-1){\\n            return true;\\n        }\\n        \\n        // System.out.println(r + \" \" + c + \" \" + left + \" \" + right + \" \");\\n        if(left >= right){\\n            if(dp[r][c][left-right] != -1){\\n                return dp[r][c][left-right] == 1 ? true : false;\\n            }\\n        }else return false;\\n        \\n        \\n        boolean isPossible = false;\\n        isPossible = find(r, c+1, left, right, grid) || find(r+1, c, left, right, grid);\\n        dp[r][c][left-right] = isPossible ==  true ? 1 : 0;\\n        \\n        return isPossible;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int R;\\n    private int C;\\n    private int[][][] dp;\\n    \\n    public boolean hasValidPath(char[][] grid) {\\n        \\n        this.R = grid.length;\\n        this.C = grid[0].length;\\n        this.dp = new int[R+1][C+1][201];\\n        \\n        for(int[][] i : dp){\\n            for(int[] j : i){\\n                Arrays.fill(j, -1);\\n            }\\n        }\\n        \\n        if(find(0, 0, 0, 0, grid)) return true;\\n        \\n        return false;\\n    }\\n    \\n    private boolean find(int r, int c, int left, int right, char[][] grid){\\n        if(r < 0 || r >= R ||c < 0 || c >= C){\\n            return false;\\n        }\\n        \\n        if(grid[r][c] == \\'(\\'){\\n            left++;\\n        }else right++;\\n        \\n        if(left == right && r == R-1 && c == C-1){\\n            return true;\\n        }\\n        \\n        // System.out.println(r + \" \" + c + \" \" + left + \" \" + right + \" \");\\n        if(left >= right){\\n            if(dp[r][c][left-right] != -1){\\n                return dp[r][c][left-right] == 1 ? true : false;\\n            }\\n        }else return false;\\n        \\n        \\n        boolean isPossible = false;\\n        isPossible = find(r, c+1, left, right, grid) || find(r+1, c, left, right, grid);\\n        dp[r][c][left-right] = isPossible ==  true ? 1 : 0;\\n        \\n        return isPossible;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020033,
                "title": "go-dp",
                "content": "```\\nvar dp[101][101][110]bool\\n\\nfunc hasValidPath(a [][]byte) bool {\\n    if a[0][0] == \\')\\' {\\n        return false\\n    }\\n    \\n    var n, m int = len(a), len(a[0])\\n    for i := 0; i < n; i++ {\\n        for j := 0; j < m; j++ {\\n            for k := 0; k < 101; k++ {\\n                dp[i][j][k] = false\\n            }\\n        }\\n    }\\n    \\n    dp[0][0][1] = true\\n    for i := 0; i < n; i++ {\\n        for j := 0; j < m; j++ {\\n            if i - 1 >= 0 {\\n                if a[i][j] == \\'(\\' {\\n                    for open := 1; open < 105; open ++ {\\n                        dp[i][j][open] = dp[i][j][open] || dp[i - 1][j][open - 1]\\n                    }\\n                } else {\\n                    for open := 0; open < 105; open ++ {\\n                        dp[i][j][open] = dp[i][j][open] || dp[i - 1][j][open + 1]\\n                    }\\n                }\\n            }\\n            if j - 1 >= 0 {\\n                if a[i][j] == \\'(\\' {\\n                    for open := 1; open < 105; open ++ {\\n                        dp[i][j][open] = dp[i][j][open] || dp[i][j - 1][open - 1]\\n                    }\\n                } else {\\n                    for open := 0; open < 105; open ++ {\\n                        dp[i][j][open] = dp[i][j][open] || dp[i][j - 1][open + 1]\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return dp[n - 1][m - 1][0]\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar dp[101][101][110]bool\\n\\nfunc hasValidPath(a [][]byte) bool {\\n    if a[0][0] == \\')\\' {\\n        return false\\n    }\\n    \\n    var n, m int = len(a), len(a[0])\\n    for i := 0; i < n; i++ {\\n        for j := 0; j < m; j++ {\\n            for k := 0; k < 101; k++ {\\n                dp[i][j][k] = false\\n            }\\n        }\\n    }\\n    \\n    dp[0][0][1] = true\\n    for i := 0; i < n; i++ {\\n        for j := 0; j < m; j++ {\\n            if i - 1 >= 0 {\\n                if a[i][j] == \\'(\\' {\\n                    for open := 1; open < 105; open ++ {\\n                        dp[i][j][open] = dp[i][j][open] || dp[i - 1][j][open - 1]\\n                    }\\n                } else {\\n                    for open := 0; open < 105; open ++ {\\n                        dp[i][j][open] = dp[i][j][open] || dp[i - 1][j][open + 1]\\n                    }\\n                }\\n            }\\n            if j - 1 >= 0 {\\n                if a[i][j] == \\'(\\' {\\n                    for open := 1; open < 105; open ++ {\\n                        dp[i][j][open] = dp[i][j][open] || dp[i][j - 1][open - 1]\\n                    }\\n                } else {\\n                    for open := 0; open < 105; open ++ {\\n                        dp[i][j][open] = dp[i][j][open] || dp[i][j - 1][open + 1]\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return dp[n - 1][m - 1][0]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2019810,
                "title": "python3-dfs-solution",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        if grid[0][0] == \\')\\': return False\\n        \\n        RC = [len(grid), len(grid[0])]\\n        seen = set()\\n        result = [False]\\n        \\n        def dfs(x, y, balance, seen):\\n            if result[0] == True: return\\n            R, C = RC[0], RC[1]\\n            \\n            if x == R - 1 and y == C - 1 and balance == 0:\\n                result[0] = True\\n                return\\n            \\n            for d in [[0,1], [1,0]]:\\n                new_x, new_y = x + d[0], y + d[1]\\n                \\n                if 0<=new_x<R and 0<=new_y<C:\\n                    \\n                    if grid[new_x][new_y] != \\'#\\':\\n                        prev_balance = balance\\n                        balance += 1 if grid[new_x][new_y] == \\'(\\' else -1\\n                        \\n                        if balance > -1 and balance < (R + C) // 2 + 1:\\n\\n                            if (new_x, new_y, balance) not in seen:\\n                                seen.add((new_x, new_y, balance))\\n                                \\n                                temp = grid[new_x][new_y]\\n                                grid[new_x][new_y] = \\'#\\'\\n                                dfs(new_x, new_y, balance, seen)\\n                                grid[new_x][new_y] = temp\\n                        \\n                        balance = prev_balance\\n        \\n        grid[0][0] = \\'#\\'\\n        seen.add((0,0,1))\\n        dfs(0, 0, 1, seen)\\n        \\n        return result[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        if grid[0][0] == \\')\\': return False\\n        \\n        RC = [len(grid), len(grid[0])]\\n        seen = set()\\n        result = [False]\\n        \\n        def dfs(x, y, balance, seen):\\n            if result[0] == True: return\\n            R, C = RC[0], RC[1]\\n            \\n            if x == R - 1 and y == C - 1 and balance == 0:\\n                result[0] = True\\n                return\\n            \\n            for d in [[0,1], [1,0]]:\\n                new_x, new_y = x + d[0], y + d[1]\\n                \\n                if 0<=new_x<R and 0<=new_y<C:\\n                    \\n                    if grid[new_x][new_y] != \\'#\\':\\n                        prev_balance = balance\\n                        balance += 1 if grid[new_x][new_y] == \\'(\\' else -1\\n                        \\n                        if balance > -1 and balance < (R + C) // 2 + 1:\\n\\n                            if (new_x, new_y, balance) not in seen:\\n                                seen.add((new_x, new_y, balance))\\n                                \\n                                temp = grid[new_x][new_y]\\n                                grid[new_x][new_y] = \\'#\\'\\n                                dfs(new_x, new_y, balance, seen)\\n                                grid[new_x][new_y] = temp\\n                        \\n                        balance = prev_balance\\n        \\n        grid[0][0] = \\'#\\'\\n        seen.add((0,0,1))\\n        dfs(0, 0, 1, seen)\\n        \\n        return result[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019487,
                "title": "simple-dfs-memo",
                "content": "We will create a valid variable to see if the current path is valid or not .\\nIf valid variable is positive it means we have more open bracket and hence we can close it but if it becomes negative at any point means close bracket are more and hence path is invalid.\\n\\nWe have a 3d dp of 3 variables row column and valid.\\n\\n```\\nint n,m;\\n    int dp[102][102][201];\\n    bool f(vector<vector<char>>&grid,int i,int j,int valid)\\n    {\\n        if(i<0 or i>=n or j<0 or j>=m)return false;\\n        if(grid[i][j]==\\'(\\')valid++;\\n        else valid--;\\n        if(valid<0)return false;\\n        if(i==n-1 and j==m-1)return valid==0;//we have reached the end see if valid= =0 means open==close bracket\\n        if(dp[i][j][valid]!=-1)\\n        {\\n            return dp[i][j][valid]==1;\\n        }\\n        return dp[i][j][valid]=f(grid,i+1,j,valid) or f(grid,i,j+1,valid);\\n        \\n    }\\n    \\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        memset(dp,-1,sizeof(dp));\\n        n=grid.size();\\n        m=grid[0].size();\\n        return f(grid,0,0,0);   \\n    }\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint n,m;\\n    int dp[102][102][201];\\n    bool f(vector<vector<char>>&grid,int i,int j,int valid)\\n    {\\n        if(i<0 or i>=n or j<0 or j>=m)return false;\\n        if(grid[i][j]==\\'(\\')valid++;\\n        else valid--;\\n        if(valid<0)return false;\\n        if(i==n-1 and j==m-1)return valid==0;//we have reached the end see if valid= =0 means open==close bracket\\n        if(dp[i][j][valid]!=-1)\\n        {\\n            return dp[i][j][valid]==1;\\n        }\\n        return dp[i][j][valid]=f(grid,i+1,j,valid) or f(grid,i,j+1,valid);\\n        \\n    }\\n    \\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        memset(dp,-1,sizeof(dp));\\n        n=grid.size();\\n        m=grid[0].size();\\n        return f(grid,0,0,0);   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018832,
                "title": "clean-python-solution",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        \\n        @cache\\n        \\n        def helper(i,j,cnt):\\n            if i<0 or j<0:\\n                return False\\n            \\n            if i==0 and j==0:\\n                if grid[i][j]==\"(\":\\n                    cnt-=1\\n                else:\\n                    cnt+=1\\n                return cnt==0\\n                \\n            \\n            if grid[i][j]==\")\":\\n                cnt+=1\\n            else:\\n                cnt-=1\\n                if cnt<0:\\n                    return False\\n                    \\n            \\n            return helper(i-1,j,cnt) or helper(i,j-1,cnt)\\n        \\n        \\n        m=len(grid)\\n        n=len(grid[0])\\n        return helper(m-1,n-1,0)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        \\n        @cache\\n        \\n        def helper(i,j,cnt):\\n            if i<0 or j<0:\\n                return False\\n            \\n            if i==0 and j==0:\\n                if grid[i][j]==\"(\":\\n                    cnt-=1\\n                else:\\n                    cnt+=1\\n                return cnt==0\\n                \\n            \\n            if grid[i][j]==\")\":\\n                cnt+=1\\n            else:\\n                cnt-=1\\n                if cnt<0:\\n                    return False\\n                    \\n            \\n            return helper(i-1,j,cnt) or helper(i,j-1,cnt)\\n        \\n        \\n        m=len(grid)\\n        n=len(grid[0])\\n        return helper(m-1,n-1,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018364,
                "title": "java-dfs-memo-vs-dp-with-explanation",
                "content": "Share two approaches:\\n- DFS + memo (top-down)\\n- DP (bottom-up)\\n\\n#### DFS + memo\\n##### Steps\\n1. Track the `bal` to check if the path is valid\\n2. When `bal < 0`, prune it\\n3. If the `bal == 0` in the bottom-right corner, we find the valid path\\n\\nuse `memo` to enhance the performance.\\n\\n##### Solution\\n- time complexity: `O(mn(m+n))`\\n- space complexity: `O(mn(m+n))`\\n```java\\npublic boolean hasValidPath(char[][] grid) {\\n    int m = grid.length, n = grid[0].length;\\n    Boolean[][][] memo = new Boolean[m][n][m + n];\\n    return dfs(grid, 0, 0, 0, memo);\\n}\\n\\nboolean dfs(char[][] grid, int i, int j, int bal, Boolean[][][] memo) {\\n    int m = grid.length, n = grid[0].length;\\n    if (i < 0 || i >= m || j < 0 || j >= n || bal < 0) return false;\\n    int cur = grid[i][j] == \\'(\\' ? 1 : -1;\\n    if (i == m - 1 && j == n - 1 && bal + cur == 0) return true;\\n\\n    if (memo[i][j][bal] != null) return memo[i][j][bal];\\n    boolean valid = dfs(grid, i + 1, j, bal + cur, memo) || dfs(grid, i, j + 1, bal + cur, memo);\\n\\n    if (valid) memo[i][j][bal] = true;\\n    else memo[i][j][bal] = false;\\n    return valid;\\n}\\n```\\n------\\n#### DP\\n##### Steps\\n1. For every `grid[i][j]`, we track all possible `bal` \\n2. If the left or top of current grid has balance `bal`, then the current grid can have `bal +- 1` depends on the current grid is `(` or `)`\\n  Fomular is: \\n  ```\\n  grid[i][j][bal] = grid[i-1][j][bal-cur] || grid[i][j-1][bal-cur] where cur = grid[i][j] == 1 ? 1 : 0\\n  ```\\n3. If the `bal < 0`, prune it\\n4. If the `bal == 0` in the bottom-right corner, we find the valid path\\n\\nNote:\\nWe can implement it use 2D set or 3D array to track the balance\\n\\n##### Solution (2D Set)\\n- time complexity: `O(mn(m+n))`\\n- space complexity: `O(mn(m+n))`\\n```java\\npublic boolean hasValidPath(char[][] grid) {\\n    int m = grid.length, n = grid[0].length;\\n    int[][] directions = new int[][]{{-1, 0}, {0, -1}};\\n\\n    Set<Integer>[][] dp = new HashSet[m][n];\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            dp[i][j] = new HashSet<>();\\n        }\\n    }\\n\\n    if (grid[0][0] == \\'(\\') dp[0][0].add(1);\\n\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            int cur = grid[i][j] == \\'(\\' ? 1 : -1;\\n            for (int[] d : directions) {\\n                int x = i + d[0], y = j + d[1];\\n                if (x < 0 || y < 0) continue;\\n\\n                for (int bal : dp[x][y]) {\\n                    bal += cur;\\n                    if (bal < 0) continue;\\n                    dp[i][j].add(bal);\\n                }\\n            }\\n        }\\n    }\\n    return dp[m-1][n-1].contains(0);\\n}\\n```\\n\\n##### Solution (3D Array)\\n```java\\npublic boolean hasValidPath(char[][] grid) {\\n    int m = grid.length, n = grid[0].length;\\n    int[][] dirs = new int[][]{{-1, 0}, {0, -1}};\\n    boolean[][][] dp = new boolean[m][n][m + n + 1];\\n\\n\\n    if (grid[0][0] == \\'(\\') dp[0][0][1] = true;\\n\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            int cur = grid[i][j] == \\'(\\' ? 1 : -1;\\n            for (int bal = 0; bal < m + n; bal++) {\\n                if (i > 0 && bal - cur >= 0) {\\n                    dp[i][j][bal] |= dp[i - 1][j][bal - cur];\\n                }\\n                if (j > 0 && bal - cur >= 0) {\\n                    dp[i][j][bal] |= dp[i][j - 1][bal - cur];\\n                }\\n            }\\n        }\\n    }\\n    return dp[m-1][n-1][0];\\n}\\n```\\n\\nPleaes let me know if this explanation is helpful for you, thanks!",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```java\\npublic boolean hasValidPath(char[][] grid) {\\n    int m = grid.length, n = grid[0].length;\\n    Boolean[][][] memo = new Boolean[m][n][m + n];\\n    return dfs(grid, 0, 0, 0, memo);\\n}\\n\\nboolean dfs(char[][] grid, int i, int j, int bal, Boolean[][][] memo) {\\n    int m = grid.length, n = grid[0].length;\\n    if (i < 0 || i >= m || j < 0 || j >= n || bal < 0) return false;\\n    int cur = grid[i][j] == \\'(\\' ? 1 : -1;\\n    if (i == m - 1 && j == n - 1 && bal + cur == 0) return true;\\n\\n    if (memo[i][j][bal] != null) return memo[i][j][bal];\\n    boolean valid = dfs(grid, i + 1, j, bal + cur, memo) || dfs(grid, i, j + 1, bal + cur, memo);\\n\\n    if (valid) memo[i][j][bal] = true;\\n    else memo[i][j][bal] = false;\\n    return valid;\\n}\\n```\n```\\n  grid[i][j][bal] = grid[i-1][j][bal-cur] || grid[i][j-1][bal-cur] where cur = grid[i][j] == 1 ? 1 : 0\\n  ```\n```java\\npublic boolean hasValidPath(char[][] grid) {\\n    int m = grid.length, n = grid[0].length;\\n    int[][] directions = new int[][]{{-1, 0}, {0, -1}};\\n\\n    Set<Integer>[][] dp = new HashSet[m][n];\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            dp[i][j] = new HashSet<>();\\n        }\\n    }\\n\\n    if (grid[0][0] == \\'(\\') dp[0][0].add(1);\\n\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            int cur = grid[i][j] == \\'(\\' ? 1 : -1;\\n            for (int[] d : directions) {\\n                int x = i + d[0], y = j + d[1];\\n                if (x < 0 || y < 0) continue;\\n\\n                for (int bal : dp[x][y]) {\\n                    bal += cur;\\n                    if (bal < 0) continue;\\n                    dp[i][j].add(bal);\\n                }\\n            }\\n        }\\n    }\\n    return dp[m-1][n-1].contains(0);\\n}\\n```\n```java\\npublic boolean hasValidPath(char[][] grid) {\\n    int m = grid.length, n = grid[0].length;\\n    int[][] dirs = new int[][]{{-1, 0}, {0, -1}};\\n    boolean[][][] dp = new boolean[m][n][m + n + 1];\\n\\n\\n    if (grid[0][0] == \\'(\\') dp[0][0][1] = true;\\n\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            int cur = grid[i][j] == \\'(\\' ? 1 : -1;\\n            for (int bal = 0; bal < m + n; bal++) {\\n                if (i > 0 && bal - cur >= 0) {\\n                    dp[i][j][bal] |= dp[i - 1][j][bal - cur];\\n                }\\n                if (j > 0 && bal - cur >= 0) {\\n                    dp[i][j][bal] |= dp[i][j - 1][bal - cur];\\n                }\\n            }\\n        }\\n    }\\n    return dp[m-1][n-1][0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018333,
                "title": "too-tight-bounds-tle-for-same-complexity-solutions",
                "content": "```\\nclass Solution {\\nprivate: \\n    unordered_map<int, unordered_map<int, unordered_map<int, int>>> dp;\\n    int r, c;\\n    bool valid(int x, int y, int dif, vector<vector<char>> &grid) {\\n        if (x < 0 || y < 0 || x >= r || y >= c) return false;\\n        if (grid[x][y] == \\'(\\') dif++;\\n        else dif--;\\n        if (dif < 0 || dif > (r + c) / 2)    return false;\\n        if (x == r - 1 && y == c - 1 && !dif)   return true;\\n        if (dp[x][y].find(dif) != dp[x][y].end())    return dp[x][y][dif];\\n        return dp[x][y][dif] = valid(x, y + 1, dif, grid) || valid(x + 1, y, dif, grid);\\n        \\n    }\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        r = grid.size(), c = grid[0].size();\\n        return valid(0, 0, 0, grid);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate: \\n    unordered_map<int, unordered_map<int, unordered_map<int, int>>> dp;\\n    int r, c;\\n    bool valid(int x, int y, int dif, vector<vector<char>> &grid) {\\n        if (x < 0 || y < 0 || x >= r || y >= c) return false;\\n        if (grid[x][y] == \\'(\\') dif++;\\n        else dif--;\\n        if (dif < 0 || dif > (r + c) / 2)    return false;\\n        if (x == r - 1 && y == c - 1 && !dif)   return true;\\n        if (dp[x][y].find(dif) != dp[x][y].end())    return dp[x][y][dif];\\n        return dp[x][y][dif] = valid(x, y + 1, dif, grid) || valid(x + 1, y, dif, grid);\\n        \\n    }\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        r = grid.size(), c = grid[0].size();\\n        return valid(0, 0, 0, grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018259,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[102][102][204];\\n    int f(int r, int c, int o1, int o2, int n, int m, vector<vector<char>>& g){\\n        if(o1<o2){\\n         return 0;\\n        }\\n        if(dp[r][c][o1-o2]!=-1)return dp[r][c][o1-o2];\\n        int val = 0;\\n        if(r<n-1){\\n            val = val || f(r+1, c, o1 + (g[r][c] == \\'(\\'), o2 + (g[r][c] == \\')\\'), n, m, g);\\n        }\\n        if(c<m-1){\\n            val = val || f(r, c+1, o1 + (g[r][c] == \\'(\\'), o2 + (g[r][c] == \\')\\'), n, m, g);\\n        }\\n        if(r==n-1 && c == m-1){\\n            return o1 + (g[r][c] == \\'(\\') == o2 +( g[r][c] == \\')\\');\\n        }\\n        return dp[r][c][o1-o2] = val;     \\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        return f(0,0,0,0,n,m, grid);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[102][102][204];\\n    int f(int r, int c, int o1, int o2, int n, int m, vector<vector<char>>& g){\\n        if(o1<o2){\\n         return 0;\\n        }\\n        if(dp[r][c][o1-o2]!=-1)return dp[r][c][o1-o2];\\n        int val = 0;\\n        if(r<n-1){\\n            val = val || f(r+1, c, o1 + (g[r][c] == \\'(\\'), o2 + (g[r][c] == \\')\\'), n, m, g);\\n        }\\n        if(c<m-1){\\n            val = val || f(r, c+1, o1 + (g[r][c] == \\'(\\'), o2 + (g[r][c] == \\')\\'), n, m, g);\\n        }\\n        if(r==n-1 && c == m-1){\\n            return o1 + (g[r][c] == \\'(\\') == o2 +( g[r][c] == \\')\\');\\n        }\\n        return dp[r][c][o1-o2] = val;     \\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        return f(0,0,0,0,n,m, grid);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018247,
                "title": "python-simple-but-slow-using-bfs",
                "content": "```python\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        # Three quick failure cases\\n        if grid[0][0]==\")\": return False\\n        if grid[-1][-1]==\"(\": return False\\n        if (m+n)%2==0: return False\\n        \\n        # Let\\'s start!\\n        queue=[(0,0,1)] # row, col, acc.sum (must be 0 at the destination); assuming that \"(\"=1 and \")\"=-1\\n        visited=set()\\n        visited.add((0,0,1))\\n        while(queue):\\n            row, col, acc_sum = queue.pop(0)\\n            if row==m-1 and col==n-1 and acc_sum==0:\\n                return True\\n            \\n            # move down\\n            if row < m-1:\\n                next_item=1 if grid[row+1][col]==\"(\" else -1\\n                next_sum = acc_sum+next_item\\n                if next_sum>=0 and (row+1, col, next_sum) not in visited:\\n                    queue.append((row+1, col, next_sum))\\n                    visited.add((row+1, col, next_sum))\\n            \\n            # move right\\n            if col < n-1:\\n                next_item=1 if grid[row][col+1]==\"(\" else -1\\n                next_sum = acc_sum+next_item\\n                if next_sum>=0 and (row, col+1, next_sum) not in visited:\\n                    queue.append((row, col+1, next_sum))\\n                    visited.add((row, col+1, next_sum))\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        # Three quick failure cases\\n        if grid[0][0]==\")\": return False\\n        if grid[-1][-1]==\"(\": return False\\n        if (m+n)%2==0: return False\\n        \\n        # Let\\'s start!\\n        queue=[(0,0,1)] # row, col, acc.sum (must be 0 at the destination); assuming that \"(\"=1 and \")\"=-1\\n        visited=set()\\n        visited.add((0,0,1))\\n        while(queue):\\n            row, col, acc_sum = queue.pop(0)\\n            if row==m-1 and col==n-1 and acc_sum==0:\\n                return True\\n            \\n            # move down\\n            if row < m-1:\\n                next_item=1 if grid[row+1][col]==\"(\" else -1\\n                next_sum = acc_sum+next_item\\n                if next_sum>=0 and (row+1, col, next_sum) not in visited:\\n                    queue.append((row+1, col, next_sum))\\n                    visited.add((row+1, col, next_sum))\\n            \\n            # move right\\n            if col < n-1:\\n                next_item=1 if grid[row][col+1]==\"(\" else -1\\n                next_sum = acc_sum+next_item\\n                if next_sum>=0 and (row, col+1, next_sum) not in visited:\\n                    queue.append((row, col+1, next_sum))\\n                    visited.add((row, col+1, next_sum))\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018234,
                "title": "c-dp-recursive-memoization-full-explanation-o-nm-n-m",
                "content": "Before to explain my solution, let\\'s solve a simpler problem.\\n\\nHow to check if a parenthesis string is balanced, well this is a classic problem that can be solved using a stack but let\\'s try another approach.\\n\\nWe are going to maintain a int variable initialize with zero and traverse the string from left to right and for each character:\\n\\n* if the current char is \\'(\\' we add +1\\n* if the current char is \\')\\' we add -1\\n\\nIf at some point the sum becomes negative then the string is not balanced, also at the end the total sum needs to be zero (try different examples to convince you that is true).\\n\\nNow using this knowledge how can solve the problem?\\n\\nWe can use a dp approach similar to other grid problems for example [62. Unique Paths](https://leetcode.com/problems/unique-paths/)\\n\\ndp(i, j, s) = the path that finish at position (i, j) with sum s\\n\\nAs i stated before if the sum is negative we can return false, the other states are\\n\\n    dp(n - 1, m - 1, s) = if s == 0 return true otherwise false // Base case\\n    dp(i, j, s) = dp(i + 1, j, s + value of char in new position) or dp(i, j + 1, s + s + value of char in new position) // general case\\n\\nFinally, how many different states exist? i goes from [0, n) and j goes from [0, m) but the case of s is tricky, if you notice because only are allowed to move down or right the size of any path is n + m, this is more clear in the following example:\\n\\n![image](https://assets.leetcode.com/users/images/f84d5c25-68ae-4cc3-9b27-54e5db39556e_1651986492.763448.png)\\n\\nThen our final complexity is O(nm(n + m)).\\n\\nHere is my code:\\n```cpp\\nclass Solution {\\n    \\n    int n, m, memo[102][102][205];\\n\\n    int dp(vector<vector<char>>& grid, int i, int j, int sum) {\\n        if (i == n - 1 and j == m - 1) // Reach the final position\\n\\t\\t\\treturn (sum == 0); \\n        if (sum < 0) return false;\\n        if (memo[i][j][sum] != -1) return memo[i][j][sum];\\n\\t\\t\\n        if (i == n - 1 and j != m - 1) // Last row\\n            return memo[i][j][sum] = dp(grid, i, j + 1, sum + (grid[i][j + 1] == \\'(\\'? 1 : -1));\\n        if (i != n - 1 and j == m - 1) // Lats column\\n            return memo[i][j][sum] = dp(grid, i + 1, j, sum + (grid[i + 1][j] == \\'(\\' ? 1 : -1));\\n\\t\\t\\t\\n        return memo[i][j][sum] = dp(grid, i, j + 1, sum + (grid[i][j + 1] == \\'(\\'? 1 : -1)) or dp(grid, i + 1, j, sum + (grid[i + 1][j] == \\'(\\' ? 1 : -1));\\n    }\\n    \\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {        \\n        n = grid.size();\\n        m = grid[0].size();\\n        memset(memo, -1, sizeof(memo));\\n        return dp(grid, 0, 0, grid[0][0] == \\'(\\' ? 1 : -1);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n    \\n    int n, m, memo[102][102][205];\\n\\n    int dp(vector<vector<char>>& grid, int i, int j, int sum) {\\n        if (i == n - 1 and j == m - 1) // Reach the final position\\n\\t\\t\\treturn (sum == 0); \\n        if (sum < 0) return false;\\n        if (memo[i][j][sum] != -1) return memo[i][j][sum];\\n\\t\\t\\n        if (i == n - 1 and j != m - 1) // Last row\\n            return memo[i][j][sum] = dp(grid, i, j + 1, sum + (grid[i][j + 1] == \\'(\\'? 1 : -1));\\n        if (i != n - 1 and j == m - 1) // Lats column\\n            return memo[i][j][sum] = dp(grid, i + 1, j, sum + (grid[i + 1][j] == \\'(\\' ? 1 : -1));\\n\\t\\t\\t\\n        return memo[i][j][sum] = dp(grid, i, j + 1, sum + (grid[i][j + 1] == \\'(\\'? 1 : -1)) or dp(grid, i + 1, j, sum + (grid[i + 1][j] == \\'(\\' ? 1 : -1));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2018101,
                "title": "javascript-dfs",
                "content": "```js\\n\\n\\n/**\\n * @param {character[][]} grid\\n * @return {boolean}\\n */\\nconst hasValidPath = function (grid) {\\n  const memo = {}\\n  const dfs = (row, col, diff) => {\\n    const key = `${row}-${col}-${diff}`\\n    if (memo[key] !== undefined) {\\n      return memo[key]\\n    }\\n    if (row < 0 || row >= grid.length || col < 0 || col >= grid[row].length) {\\n      return false\\n    }\\n    if (grid[row][col] === \\'(\\') {\\n      diff += 1\\n    } else {\\n      diff -= 1\\n    }\\n    if (diff < 0) {\\n      return false\\n    }\\n    if (row === grid.length - 1 && col === grid[row].length - 1 && diff === 0) {\\n      return true\\n    }\\n    let result = false\\n\\n    result = result || dfs(row + 1, col, diff)\\n    result = result || dfs(row, col + 1, diff)\\n    memo[key] = result\\n    return result\\n  }\\n  return dfs(0, 0, 0, 0)\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```js\\n\\n\\n/**\\n * @param {character[][]} grid\\n * @return {boolean}\\n */\\nconst hasValidPath = function (grid) {\\n  const memo = {}\\n  const dfs = (row, col, diff) => {\\n    const key = `${row}-${col}-${diff}`\\n    if (memo[key] !== undefined) {\\n      return memo[key]\\n    }\\n    if (row < 0 || row >= grid.length || col < 0 || col >= grid[row].length) {\\n      return false\\n    }\\n    if (grid[row][col] === \\'(\\') {\\n      diff += 1\\n    } else {\\n      diff -= 1\\n    }\\n    if (diff < 0) {\\n      return false\\n    }\\n    if (row === grid.length - 1 && col === grid[row].length - 1 && diff === 0) {\\n      return true\\n    }\\n    let result = false\\n\\n    result = result || dfs(row + 1, col, diff)\\n    result = result || dfs(row, col + 1, diff)\\n    memo[key] = result\\n    return result\\n  }\\n  return dfs(0, 0, 0, 0)\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018011,
                "title": "java-3d-dp",
                "content": "```\\nclass Solution {\\n    int counter = 0;\\n    Boolean[][][] dp = new Boolean[101][101][201];\\n    public boolean hasValidPath(char[][] grid) {\\n        int row = grid.length-1;\\n        int col = grid[0].length-1;\\n        if(grid[0][0] !=\\'(\\' || grid[row][col] != \\')\\'){\\n            return false;\\n        }\\n        boolean res =  helper(grid, 0, 0, 0, 0, row, col);\\n        return res;\\n    }\\n    \\n    public boolean helper(char[][] grid, int i, int j, int open, int close, int row, int col){\\n        if(i<0 || j < 0 || i>row || j > col){\\n            \\n            return false;\\n        }\\n        else if((i==row) && (j==col) && (open==close+1)){\\n            dp[i][j][open - close] = true;\\n            return true;\\n        }\\n        else if(dp[i][j][open - close] != null){\\n            return dp[i][j][open - close];\\n        }\\n        else if(grid[i][j] == \\'(\\'){\\n            boolean res =  helper(grid, i+1, j, open+1, close, row, col) || helper(grid, i, j+1, open+1, close, row, col);\\n            dp[i][j][open - close] = res;\\n            return res;\\n        }\\n        else if( (open > close) && (grid[i][j] == \\')\\')){\\n            boolean res = helper(grid, i+1, j, open, close+1, row, col) || helper(grid, i, j+1, open, close+1, row, col);\\n            dp[i][j][open - close] = res;\\n            return res;\\n        }\\n        else{\\n            dp[i][j][open-close] = false;\\n            return false;\\n        }\\n\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int counter = 0;\\n    Boolean[][][] dp = new Boolean[101][101][201];\\n    public boolean hasValidPath(char[][] grid) {\\n        int row = grid.length-1;\\n        int col = grid[0].length-1;\\n        if(grid[0][0] !=\\'(\\' || grid[row][col] != \\')\\'){\\n            return false;\\n        }\\n        boolean res =  helper(grid, 0, 0, 0, 0, row, col);\\n        return res;\\n    }\\n    \\n    public boolean helper(char[][] grid, int i, int j, int open, int close, int row, int col){\\n        if(i<0 || j < 0 || i>row || j > col){\\n            \\n            return false;\\n        }\\n        else if((i==row) && (j==col) && (open==close+1)){\\n            dp[i][j][open - close] = true;\\n            return true;\\n        }\\n        else if(dp[i][j][open - close] != null){\\n            return dp[i][j][open - close];\\n        }\\n        else if(grid[i][j] == \\'(\\'){\\n            boolean res =  helper(grid, i+1, j, open+1, close, row, col) || helper(grid, i, j+1, open+1, close, row, col);\\n            dp[i][j][open - close] = res;\\n            return res;\\n        }\\n        else if( (open > close) && (grid[i][j] == \\')\\')){\\n            boolean res = helper(grid, i+1, j, open, close+1, row, col) || helper(grid, i, j+1, open, close+1, row, col);\\n            dp[i][j][open - close] = res;\\n            return res;\\n        }\\n        else{\\n            dp[i][j][open-close] = false;\\n            return false;\\n        }\\n\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018007,
                "title": "dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int vis[101][101][200], n, m;\\n    bool possible = 0;\\n    int fx[2] = {+1, +0};\\n    int fy[2] = {+0, +1};\\n    \\n    void dfs(int x, int y, int cum, vector<vector<char>>& grid) {  \\n        if (possible) return;\\n        vis[x][y][cum] = true;\\n        int sum = cum + (grid[x][y] == \\'(\\' ? 1 : -1);\\n        \\n        if (sum < 0) return ;\\n        \\n        if (x == n - 1 && y == m - 1) {\\n            possible |= (sum == 0);\\n            return ;\\n        }\\n                      \\n        for (int i = 0; i < 2; i++) {\\n            int nx = x + fx[i];\\n            int ny = y + fy[i];\\n            if (nx < 0 || ny < 0 || nx >= n || ny >= m) continue;\\n            if (!vis[nx][ny][sum]) {\\n                dfs(nx, ny, sum, grid);\\n            }\\n        }\\n        \\n    }\\n    \\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        dfs(0, 0, 0, grid);\\n        return possible;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int vis[101][101][200], n, m;\\n    bool possible = 0;\\n    int fx[2] = {+1, +0};\\n    int fy[2] = {+0, +1};\\n    \\n    void dfs(int x, int y, int cum, vector<vector<char>>& grid) {  \\n        if (possible) return;\\n        vis[x][y][cum] = true;\\n        int sum = cum + (grid[x][y] == \\'(\\' ? 1 : -1);\\n        \\n        if (sum < 0) return ;\\n        \\n        if (x == n - 1 && y == m - 1) {\\n            possible |= (sum == 0);\\n            return ;\\n        }\\n                      \\n        for (int i = 0; i < 2; i++) {\\n            int nx = x + fx[i];\\n            int ny = y + fy[i];\\n            if (nx < 0 || ny < 0 || nx >= n || ny >= m) continue;\\n            if (!vis[nx][ny][sum]) {\\n                dfs(nx, ny, sum, grid);\\n            }\\n        }\\n        \\n    }\\n    \\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        dfs(0, 0, 0, grid);\\n        return possible;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017880,
                "title": "c-dp-solution-easy-to-understand",
                "content": "```\\nint dp[100][100][101];\\n    bool findans(int x,int y,vector<vector<char> >&grid,int all){\\n        if(x==grid.size()-1&&y==grid[0].size()-1){\\n            if(all==-1){\\n                return false;\\n            }\\n            int add=(grid[x][y]==\\'(\\'?1:-1);\\n            if(all+add==0){\\n                return true;\\n            }\\n            return false;\\n        }\\n        if(all<0){\\n            return false;\\n        }\\n        if(all>100){\\n            return false;\\n        }\\n        if(dp[x][y][all]!=-1){\\n            return dp[x][y][all];\\n        }\\n        // cout<<all<<\" \"<<x<<\" \"<<y<<endl;\\n        bool ans=false,ans2=false;\\n        if(x+1<grid.size()){\\n            int add=(grid[x][y]==\\'(\\'?1:-1);\\n           ans=findans(x+1,y,grid,all+add); \\n        }\\n        if(ans)return dp[x][y][all]= true;\\n        if(y+1<grid[0].size()){\\n            int add=(grid[x][y]==\\'(\\'?1:-1);\\n            ans=findans(x,y+1,grid,all+add); \\n        }\\n        return dp[x][y][all]=ans;\\n    }\\n    \\n    \\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        memset(dp,-1,sizeof(dp));\\n        return findans(0,0,grid,0);\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nint dp[100][100][101];\\n    bool findans(int x,int y,vector<vector<char> >&grid,int all){\\n        if(x==grid.size()-1&&y==grid[0].size()-1){\\n            if(all==-1){\\n                return false;\\n            }\\n            int add=(grid[x][y]==\\'(\\'?1:-1);\\n            if(all+add==0){\\n                return true;\\n            }\\n            return false;\\n        }\\n        if(all<0){\\n            return false;\\n        }\\n        if(all>100){\\n            return false;\\n        }\\n        if(dp[x][y][all]!=-1){\\n            return dp[x][y][all];\\n        }\\n        // cout<<all<<\" \"<<x<<\" \"<<y<<endl;\\n        bool ans=false,ans2=false;\\n        if(x+1<grid.size()){\\n            int add=(grid[x][y]==\\'(\\'?1:-1);\\n           ans=findans(x+1,y,grid,all+add); \\n        }\\n        if(ans)return dp[x][y][all]= true;\\n        if(y+1<grid[0].size()){\\n            int add=(grid[x][y]==\\'(\\'?1:-1);\\n            ans=findans(x,y+1,grid,all+add); \\n        }\\n        return dp[x][y][all]=ans;\\n    }\\n    \\n    \\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        memset(dp,-1,sizeof(dp));\\n        return findans(0,0,grid,0);\\n    }\\n\\t```",
                "codeTag": "C++"
            },
            {
                "id": 2017845,
                "title": "python3-dp",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/9aa0edb0815f3e0a75a47808e1690ca424f169e5) for solutions of weekly 292. \\n\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        @cache\\n        def fn(i, j, v): \\n            \"\"\"Return True if value of v at (i, j) is possible.\"\"\"\\n            if i == m-1 and j == n-1: return v == 0 \\n            for ii, jj in (i+1, j), (i, j+1): \\n                if 0 <= ii < m and 0 <= jj < n: \\n                    if grid[ii][jj] == \\'(\\': vv = v+1\\n                    else: vv = v-1\\n                    if 0 <= vv <= min(ii+jj+1, m+n-ii-jj) and fn(ii, jj, vv): return True \\n            return False \\n        \\n        return fn(0, 0, 1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        @cache\\n        def fn(i, j, v): \\n            \"\"\"Return True if value of v at (i, j) is possible.\"\"\"\\n            if i == m-1 and j == n-1: return v == 0 \\n            for ii, jj in (i+1, j), (i, j+1): \\n                if 0 <= ii < m and 0 <= jj < n: \\n                    if grid[ii][jj] == \\'(\\': vv = v+1\\n                    else: vv = v-1\\n                    if 0 <= vv <= min(ii+jj+1, m+n-ii-jj) and fn(ii, jj, vv): return True \\n            return False \\n        \\n        return fn(0, 0, 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017770,
                "title": "recursion-memorization-c",
                "content": "```\\nclass Solution {\\nprivate:\\n    int dp[101][101][502];\\npublic:\\n    bool solve(int i,int j,vector<vector<char>> &grid,int close){\\n        if(i < 0 or j < 0 or i >= grid.size() or j >= grid[0].size()) return false;\\n        if(close < 0) return false;\\n        if(i == grid.size()-1 and j == grid[0].size()-1){\\n            close += grid[i][j] == \\')\\' ? -1 : 1;\\n            return close == 0;\\n        }\\n        \\n        if(dp[i][j][close] != -1) return dp[i][j][close];\\n        \\n        int new_close = grid[i][j] == \\')\\' ? close - 1 : close + 1;\\n        \\n        bool op1 = solve(i+1,j,grid,new_close);\\n        bool op2 = solve(i,j+1,grid,new_close);\\n        \\n        return dp[i][j][close] = (op1 or op2);\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        if(grid[0][0] == \\')\\') return false;\\n        memset(dp,-1,sizeof dp);\\n        return solve(0,0,grid,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dp[101][101][502];\\npublic:\\n    bool solve(int i,int j,vector<vector<char>> &grid,int close){\\n        if(i < 0 or j < 0 or i >= grid.size() or j >= grid[0].size()) return false;\\n        if(close < 0) return false;\\n        if(i == grid.size()-1 and j == grid[0].size()-1){\\n            close += grid[i][j] == \\')\\' ? -1 : 1;\\n            return close == 0;\\n        }\\n        \\n        if(dp[i][j][close] != -1) return dp[i][j][close];\\n        \\n        int new_close = grid[i][j] == \\')\\' ? close - 1 : close + 1;\\n        \\n        bool op1 = solve(i+1,j,grid,new_close);\\n        bool op2 = solve(i,j+1,grid,new_close);\\n        \\n        return dp[i][j][close] = (op1 or op2);\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        if(grid[0][0] == \\')\\') return false;\\n        memset(dp,-1,sizeof dp);\\n        return solve(0,0,grid,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017763,
                "title": "why-recursion-is-not-working",
                "content": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        if(grid[0][0]==\\')\\') return false;\\n        return path(grid,0,1,1)||path(grid,1,0,1);\\n    }\\n    public boolean path(char[][] grid,int i,int j,int cnt)\\n    {\\n        if(i>=grid.length || j>=grid[0].length) return false;\\n        if(grid[i][j]==\\')\\') cnt--;\\n        else cnt++;\\n        if(cnt<0) return false;\\n        if(i==grid.length-1 && j==grid[0].length-1)\\n        {\\n            if(cnt!=0)return false;\\n            return true;\\n        }\\n        return path(grid,i+1,j,cnt)||path(grid,i,j+1,cnt);\\n    }\\n}",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        if(grid[0][0]==\\')\\') return false;\\n        return path(grid,0,1,1)||path(grid,1,0,1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2017724,
                "title": "python-clean-top-down-dp-with-explanation-t-o-mn-m-n",
                "content": "A pretty straightforward while naive solution for this kind of problem would be traversing and backtracking. But since `1 <= m, n <= 100`, the naive solution has `T = O(comb(m + n - 2, m - 1))` worst-case time complexity, which is `comb(198, 99) > 2^193` in the case. That is certainly unbearable.\\n\\nWe can improve it hugely by using Dynamic Programming techniques.\\n\\nThe `DP(x, y, open_left_parentheses)` implies whether there is a valid Parentheses String Path starting from the pos `(x, y)` with some `open_left_parentheses`. \\n\\nAt every DP step, we examine the character at `grid[x][y]`:\\n\\n- If the current parenthesis is left `(`, we just increment the `open_left_parentheses` count by 1.\\n- If the current parenthesis is left `)`, we check if there are already some open left parentheses on the path so far.\\n  - If there is open `(`, we decrement the `open_left_parentheses` count by 1 to indicate the match of a pair of parentheses.\\n  - Otherwise, the current path is determined to be invalid (e.g. `)`, `()())`).\\n\\nThen we try moving downwards or rightwards if the next step is in still within borders. The DP function returns true if and only if **either** of the two direction could lead to a valid path.\\n\\n**Code:**\\n\\n```\\nfrom functools import cache\\n\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m = len(grid)\\n        n = len(grid[0])\\n        if grid[m-1][n-1] == \"(\":\\n            return False\\n        \\n        @cache\\n        def dp(x, y, o):\\n            if x == m - 1 and y == n - 1:\\n                return o == 1 # assert grid[m-1][n-1] == \")\"\\n            if grid[x][y] == \"(\":\\n                o += 1\\n            else: # \")\"\\n                if o == 0:\\n                    return False\\n                o -= 1\\n            if x + 1 < m and dp(x + 1, y, o):\\n                return True\\n            if y + 1 < n and dp(x, y + 1, o):\\n                return True\\n            # unreachable branch\\n                \\n        return dp(0, 0, 0)\\n```\\n\\n**Time complexity:**\\n\\n`T = O(m * n * (m + n))`\\n\\n(`o` in the `DP(x, y, o)` is at most `m + n`)",
                "solutionTags": [],
                "code": "```\\nfrom functools import cache\\n\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m = len(grid)\\n        n = len(grid[0])\\n        if grid[m-1][n-1] == \"(\":\\n            return False\\n        \\n        @cache\\n        def dp(x, y, o):\\n            if x == m - 1 and y == n - 1:\\n                return o == 1 # assert grid[m-1][n-1] == \")\"\\n            if grid[x][y] == \"(\":\\n                o += 1\\n            else: # \")\"\\n                if o == 0:\\n                    return False\\n                o -= 1\\n            if x + 1 < m and dp(x + 1, y, o):\\n                return True\\n            if y + 1 < n and dp(x, y + 1, o):\\n                return True\\n            # unreachable branch\\n                \\n        return dp(0, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074317,
                "title": "bitmask-bottom-up-c-bitset-and-optional",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        typedef std::bitset<100> v1_t;\\n        typedef std::optional<v1_t> v_t;\\n        int m=grid.size(),n=grid[0].size();\\n        std::vector<std::vector<v_t>> dp(m,std::vector<v_t>(n));\\n        for(auto i=0;i<m;++i)for(auto j=0;j<n;++j)\\n        {\\n            v_t v1=std::nullopt,v2=std::nullopt;\\n            auto& u=dp[i][j];\\n            if(i==0&&j==0)\\n            {\\n                if(grid[i][j]==\\'(\\')\\n                    u=1<<1;\\n                else\\n                    return false;\\n                continue;\\n            }\\n            if(i>0)\\n                v2=dp[i-1][j];\\n            if(j>0)\\n                v1=dp[i][j-1];\\n                \\n            if(grid[i][j]==\\')\\')\\n            {\\n                if(v1&&v1->none())\\n                    v1=std::nullopt;\\n                if(v2&&v2->none())\\n                    v2=std::nullopt;\\n            }\\n            \\n            if(v1&&v2)\\n            {\\n                if(grid[i][j]==\\'(\\')\\n                    u=*v1<<1|*v2<<1;\\n                else\\n                    u=*v1>>1|*v2>>1;\\n            }\\n            else if(v1)\\n            {\\n                if(grid[i][j]==\\'(\\')\\n                    u=*v1<<1;\\n                else\\n                    u=*v1>>1;\\n            }\\n            else if(v2)\\n            {\\n                if(grid[i][j]==\\'(\\')\\n                    u=*v2<<1;\\n                else\\n                    u=*v2>>1;\\n            }\\n            else\\n                u=std::nullopt;\\n        }\\n        auto& v=dp[m-1][n-1];\\n        if(v)\\n            return v->test(0);\\n        else\\n            return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        typedef std::bitset<100> v1_t;\\n        typedef std::optional<v1_t> v_t;\\n        int m=grid.size(),n=grid[0].size();\\n        std::vector<std::vector<v_t>> dp(m,std::vector<v_t>(n));\\n        for(auto i=0;i<m;++i)for(auto j=0;j<n;++j)\\n        {\\n            v_t v1=std::nullopt,v2=std::nullopt;\\n            auto& u=dp[i][j];\\n            if(i==0&&j==0)\\n            {\\n                if(grid[i][j]==\\'(\\')\\n                    u=1<<1;\\n                else\\n                    return false;\\n                continue;\\n            }\\n            if(i>0)\\n                v2=dp[i-1][j];\\n            if(j>0)\\n                v1=dp[i][j-1];\\n                \\n            if(grid[i][j]==\\')\\')\\n            {\\n                if(v1&&v1->none())\\n                    v1=std::nullopt;\\n                if(v2&&v2->none())\\n                    v2=std::nullopt;\\n            }\\n            \\n            if(v1&&v2)\\n            {\\n                if(grid[i][j]==\\'(\\')\\n                    u=*v1<<1|*v2<<1;\\n                else\\n                    u=*v1>>1|*v2>>1;\\n            }\\n            else if(v1)\\n            {\\n                if(grid[i][j]==\\'(\\')\\n                    u=*v1<<1;\\n                else\\n                    u=*v1>>1;\\n            }\\n            else if(v2)\\n            {\\n                if(grid[i][j]==\\'(\\')\\n                    u=*v2<<1;\\n                else\\n                    u=*v2>>1;\\n            }\\n            else\\n                u=std::nullopt;\\n        }\\n        auto& v=dp[m-1][n-1];\\n        if(v)\\n            return v->test(0);\\n        else\\n            return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002800,
                "title": "easy-peasy-c-using-recursion-memoisation-hard-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public:\\n    int m;\\n    int n;\\n    bool solve(int i , int j , int countopen , vector<vector<char>> &grid , vector<vector<vector<int>>> &dp){\\n        if(i<0 || i>=n || j<0 || j>=m) return false;\\n\\n        if(grid[i][j] == \\'(\\') countopen++;\\n\\n        else if(grid[i][j] == \\')\\') countopen--;\\n\\n        if(i == n-1 && j== m-1) return countopen==0;\\n\\n        if(countopen < 0) return false;\\n\\n        if(dp[i][j][countopen] != -1) return dp[i][j][countopen];\\n\\n        bool down = solve(i+1 , j , countopen , grid , dp);\\n        bool right = solve(i , j+1 , countopen , grid, dp);\\n\\n        return dp[i][j][countopen] = down || right;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        n= grid.size();\\n        m= grid[0].size();\\n        vector<vector<vector<int>>> dp(n , vector<vector<int>>(m, vector<int>(201, -1)));\\n        return solve(0 , 0 , 0 , grid , dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n    int m;\\n    int n;\\n    bool solve(int i , int j , int countopen , vector<vector<char>> &grid , vector<vector<vector<int>>> &dp){\\n        if(i<0 || i>=n || j<0 || j>=m) return false;\\n\\n        if(grid[i][j] == \\'(\\') countopen++;\\n\\n        else if(grid[i][j] == \\')\\') countopen--;\\n\\n        if(i == n-1 && j== m-1) return countopen==0;\\n\\n        if(countopen < 0) return false;\\n\\n        if(dp[i][j][countopen] != -1) return dp[i][j][countopen];\\n\\n        bool down = solve(i+1 , j , countopen , grid , dp);\\n        bool right = solve(i , j+1 , countopen , grid, dp);\\n\\n        return dp[i][j][countopen] = down || right;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        n= grid.size();\\n        m= grid[0].size();\\n        vector<vector<vector<int>>> dp(n , vector<vector<int>>(m, vector<int>(201, -1)));\\n        return solve(0 , 0 , 0 , grid , dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829609,
                "title": "c-top-down-3d-dp-beginner-friendly",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int m;\\n    int n;\\n    vector<vector<vector<int>>> dp; \\n    vector<pair<int,int>> dirs{{1,0},{0,1}};\\n    bool solve(vector<vector<char>>& grid,int cr,int cc,int balance){\\n        if(balance<0) return false;\\n        if(cr==m-1 && cc==n-1) return (balance==0);\\n        if(dp[cr][cc][balance]!=-1) return dp[cr][cc][balance];\\n        bool answer=false;\\n        for(auto dir : dirs){\\n            int nr=cr+dir.first;\\n            int nc=cc+dir.second;\\n            if(nr>=0 &&nr<m && nc>=0 &&nc<n)\\n                answer|=solve(grid,nr,nc,balance+(grid[nr][nc]==\\'(\\')-(grid[nr][nc]==\\')\\'));\\n            if(answer) break;\\n        }\\n        return dp[cr][cc][balance]=answer;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        m=grid.size();\\n        n=grid[0].size();\\n        dp.resize(m,vector<vector<int>>(n,vector<int>(1000,-1)));\\n        return solve(grid,0,0,0+(grid[0][0]==\\'(\\')-(grid[0][0]==\\')\\'));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m;\\n    int n;\\n    vector<vector<vector<int>>> dp; \\n    vector<pair<int,int>> dirs{{1,0},{0,1}};\\n    bool solve(vector<vector<char>>& grid,int cr,int cc,int balance){\\n        if(balance<0) return false;\\n        if(cr==m-1 && cc==n-1) return (balance==0);\\n        if(dp[cr][cc][balance]!=-1) return dp[cr][cc][balance];\\n        bool answer=false;\\n        for(auto dir : dirs){\\n            int nr=cr+dir.first;\\n            int nc=cc+dir.second;\\n            if(nr>=0 &&nr<m && nc>=0 &&nc<n)\\n                answer|=solve(grid,nr,nc,balance+(grid[nr][nc]==\\'(\\')-(grid[nr][nc]==\\')\\'));\\n            if(answer) break;\\n        }\\n        return dp[cr][cc][balance]=answer;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        m=grid.size();\\n        n=grid[0].size();\\n        dp.resize(m,vector<vector<int>>(n,vector<int>(1000,-1)));\\n        return solve(grid,0,0,0+(grid[0][0]==\\'(\\')-(grid[0][0]==\\')\\'));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823909,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(rows * cols * (rows + cols))\\n * Space Complexity: O(rows * cols * (rows + cols))\\n * where `rows` is the number of the rows of the matrix `grid`\\n *       `cols` is the number of the columns of the matrix `grid`\\n */\\nclass Solution {\\n public:\\n  bool hasValidPath(const vector<vector<char>> &grid) {\\n    constexpr int range = 2;\\n    constexpr char open = \\'(\\';\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    bool dp[range][cols][rows + cols];\\n    memset(dp, 0, sizeof(dp));\\n    int previous = 0;\\n    int current = 1;\\n    dp[previous][0][0] = true;\\n    for (const vector<char> &row : grid) {\\n      for (int c = 0; c < cols; ++c) {\\n        const int cell = row[c] == open ? 1 : -1;\\n        for (int previous_cell = max(0, -cell); previous_cell < rows + cols; ++previous_cell) {\\n          const int current_cell = previous_cell + cell;\\n          if (dp[previous][c][previous_cell] || (c > 0 && dp[current][c - 1][previous_cell])) {\\n            dp[current][c][current_cell] = true;\\n          }\\n        }\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n      memset(dp[current], 0, sizeof(dp[current]));\\n    }\\n    return dp[previous][cols - 1][0];\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(rows * cols * (rows + cols))\\n * Space Complexity: O(rows * cols * (rows + cols))\\n * where `rows` is the number of the rows of the matrix `grid`\\n *       `cols` is the number of the columns of the matrix `grid`\\n */\\nclass Solution {\\n public:\\n  bool hasValidPath(const vector<vector<char>> &grid) {\\n    constexpr int range = 2;\\n    constexpr char open = \\'(\\';\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    bool dp[range][cols][rows + cols];\\n    memset(dp, 0, sizeof(dp));\\n    int previous = 0;\\n    int current = 1;\\n    dp[previous][0][0] = true;\\n    for (const vector<char> &row : grid) {\\n      for (int c = 0; c < cols; ++c) {\\n        const int cell = row[c] == open ? 1 : -1;\\n        for (int previous_cell = max(0, -cell); previous_cell < rows + cols; ++previous_cell) {\\n          const int current_cell = previous_cell + cell;\\n          if (dp[previous][c][previous_cell] || (c > 0 && dp[current][c - 1][previous_cell])) {\\n            dp[current][c][current_cell] = true;\\n          }\\n        }\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n      memset(dp[current], 0, sizeof(dp[current]));\\n    }\\n    return dp[previous][cols - 1][0];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808009,
                "title": "java-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea here is simple..Just try all possible path !\\nBut  trying all possible path using DFS **always** have repeated sub problem which results can be stored and used later when faced again!\\n\\nThe `is_visited `   is used to store whether we have visisted the cell with `open` number of open brackets. if it is true then we have vissited and the further journey will not give any valid parenthesis.\\n\\n\\nThe dp combination is no.of.open brackets possible at any moment * i*j; \\n`is_visited = new boolean[201][grid.length][grid[0].length];\\n`\\n\\nEg : is_visited[10][12][15] can be taken as When we have 5 open brackets reamining at grid[12][15] and is we have encountered the secenario or not ! ... if the is_visited[10][12][15] is `false` then we have to explore this path ..if not we have already explored and exploring the same path is unnecessary. \\n\\n\\n# Complexity\\n- Time complexity: O( (m+n) * m * n) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O( (m+n) * m * n) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    boolean[][][] is_visited ;\\n    public boolean hasValidPath(char[][] grid) {\\n        if(grid[0][0] != \\'(\\' && grid[grid.length-1][grid[0].length-1] !=\\')\\') return false ;\\n        is_visited = new boolean[201][grid.length][grid[0].length];\\n        \\n        return algo(0 , 0 , grid ,0 );  \\n    }\\n    public boolean algo(int i , int j , char[][] grid , int open ){\\n        if( i>= grid.length || i< 0 || j>= grid[0].length || j<0) return false;\\n\\n        if(grid[i][j] == \\'(\\') open++; \\n        else open--;\\n        if( i== grid.length-1 && j== grid[0].length-1) {\\n            if(open != 0) return false ;\\n            return true;\\n        };\\n\\n        if(open < 0 || is_visited[open][i][j] != false) return false;\\n        //right \\n        if( algo(i+1 ,j ,grid , open)) return true;\\n        //down\\n        if(algo(i , j+1 , grid , open)) return true ;\\n        is_visited[open][i][j] = true;\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    boolean[][][] is_visited ;\\n    public boolean hasValidPath(char[][] grid) {\\n        if(grid[0][0] != \\'(\\' && grid[grid.length-1][grid[0].length-1] !=\\')\\') return false ;\\n        is_visited = new boolean[201][grid.length][grid[0].length];\\n        \\n        return algo(0 , 0 , grid ,0 );  \\n    }\\n    public boolean algo(int i , int j , char[][] grid , int open ){\\n        if( i>= grid.length || i< 0 || j>= grid[0].length || j<0) return false;\\n\\n        if(grid[i][j] == \\'(\\') open++; \\n        else open--;\\n        if( i== grid.length-1 && j== grid[0].length-1) {\\n            if(open != 0) return false ;\\n            return true;\\n        };\\n\\n        if(open < 0 || is_visited[open][i][j] != false) return false;\\n        //right \\n        if( algo(i+1 ,j ,grid , open)) return true;\\n        //down\\n        if(algo(i , j+1 , grid , open)) return true ;\\n        is_visited[open][i][j] = true;\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684064,
                "title": "c-recursive-solution",
                "content": "# Intuition\\nCan br done by recursive function because we have to check all cases.\\nSince overlapping subproblems are here, thus we can use DP \\n\\n# Approach\\n1. if m+n is even then length od string will be odd and that can\\'t be valid\\n2. In anywhere path if opening bracket numbers fall below zero, is also invalid path\\n3. if opening bracket number goes above (m+n)/2, this will be also invalid path.\\n4. if first char is \\')\\' or last char is \\'(\\', this will be also discarded\\n5. take or of both the cases (right and down).\\n6. memoise it vith 3-D dp array\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool f(vector<vector<char>>& grid, int i, int j, int m , int n, int open, vector<vector<vector<int>>> &dp){\\n        if(i==n-1 && j==m-1 ){\\n            if(open==0) return true;\\n            return false;\\n        } \\n        if(open<0 || open>(m+n)/2) return false;\\n\\n        if(dp[i][j][open]!=-1) return dp[i][j][open];\\n        bool a=false, b=false;\\n        if(j<m-1){\\n            if(grid[i][j+1]==\\'(\\') a=f(grid, i, j+1, m, n, open+1, dp);\\n            else a=f(grid, i, j+1, m, n, open-1, dp);\\n        }\\n        if(i<n-1){\\n            if(grid[i+1][j]==\\'(\\') b=f(grid, i+1, j, m, n, open+1, dp);\\n            else b=f(grid, i+1, j, m, n, open-1, dp);\\n        }\\n\\n        return dp[i][j][open]= a||b;\\n        \\n\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if((m+n)%2==0) return false;\\n        if(grid[0][0]==\\')\\' || grid[n-1][m-1]==\\'(\\') return false;\\n        vector<vector<vector<int>>> dp(n,vector<vector<int>>(m, vector<int>((m+n)/2+1, -1)));\\n        return f(grid, 0,0,m, n, 1, dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(vector<vector<char>>& grid, int i, int j, int m , int n, int open, vector<vector<vector<int>>> &dp){\\n        if(i==n-1 && j==m-1 ){\\n            if(open==0) return true;\\n            return false;\\n        } \\n        if(open<0 || open>(m+n)/2) return false;\\n\\n        if(dp[i][j][open]!=-1) return dp[i][j][open];\\n        bool a=false, b=false;\\n        if(j<m-1){\\n            if(grid[i][j+1]==\\'(\\') a=f(grid, i, j+1, m, n, open+1, dp);\\n            else a=f(grid, i, j+1, m, n, open-1, dp);\\n        }\\n        if(i<n-1){\\n            if(grid[i+1][j]==\\'(\\') b=f(grid, i+1, j, m, n, open+1, dp);\\n            else b=f(grid, i+1, j, m, n, open-1, dp);\\n        }\\n\\n        return dp[i][j][open]= a||b;\\n        \\n\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if((m+n)%2==0) return false;\\n        if(grid[0][0]==\\')\\' || grid[n-1][m-1]==\\'(\\') return false;\\n        vector<vector<vector<int>>> dp(n,vector<vector<int>>(m, vector<int>((m+n)/2+1, -1)));\\n        return f(grid, 0,0,m, n, 1, dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670177,
                "title": "why-it-should-be-dp-not-a-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nI got tons of TLE with Backtracking and Passed after add memoizaion\\n\\nSure, I used params as dp way, shrink parmas size and limit string\\'s size (Like minus when `)` comes)\\n\\nBut as i thought, it doesn\\'t matter with DP or DFS, cause all the cases could be feed-forward `Right Or Down` and it\\'s constraints is `M*N <= 10**4`\\n\\nAnyone knows why it should be DP ?\\n\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n\\n        m, n = len(grid), len(grid[0])\\n        if grid[0][0] != \"(\" or grid[-1][-1] != \")\":\\n            return False\\n        \\n        dp = defaultdict(lambda : -1)\\n\\n        \\n        def backtracking(i,j, stack):\\n            if dp[(i,j, stack)] != -1:\\n                return dp[(i,j, stack)]\\n            \\n            if i == m-1 and j == n-1:\\n                if len(stack)==0:\\n                    dp[(i,j, stack)]= True\\n                    return True\\n                dp[(i,j, stack)] = False\\n                return False\\n            \\n            \\n            if i+1 < m:\\n                if len(stack) and grid[i+1][j] == \")\":\\n                    if backtracking(i+1, j, stack[:-1]):\\n                        dp[(i,j, stack)]= True\\n                        return True\\n                elif (len(stack) == 0 and grid[i+1][j] != \")\" ) or grid[i+1][j] == \"(\":\\n                    if backtracking(i+1, j, stack+grid[i+1][j]):\\n                        dp[(i,j, stack)]= True\\n                        return True\\n\\n            if j+1 < n:\\n                if len(stack) and grid[i][j+1] == \")\":\\n                    if backtracking(i, j+1, stack[:-1]):\\n                        dp[(i,j, stack)]= True\\n                        return True\\n                elif (len(stack) == 0 and grid[i][j+1] != \")\" )  or grid[i][j+1] == \"(\":\\n                    if backtracking(i, j+1, stack+grid[i][j+1]):\\n                        dp[(i,j, stack)]= True\\n                        return True\\n            dp[(i,j, stack)]= False\\n            return False\\n        \\n        return backtracking(0,0, grid[0][0])\\n                \\n\\n                \\n                \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n\\n        m, n = len(grid), len(grid[0])\\n        if grid[0][0] != \"(\" or grid[-1][-1] != \")\":\\n            return False\\n        \\n        dp = defaultdict(lambda : -1)\\n\\n        \\n        def backtracking(i,j, stack):\\n            if dp[(i,j, stack)] != -1:\\n                return dp[(i,j, stack)]\\n            \\n            if i == m-1 and j == n-1:\\n                if len(stack)==0:\\n                    dp[(i,j, stack)]= True\\n                    return True\\n                dp[(i,j, stack)] = False\\n                return False\\n            \\n            \\n            if i+1 < m:\\n                if len(stack) and grid[i+1][j] == \")\":\\n                    if backtracking(i+1, j, stack[:-1]):\\n                        dp[(i,j, stack)]= True\\n                        return True\\n                elif (len(stack) == 0 and grid[i+1][j] != \")\" ) or grid[i+1][j] == \"(\":\\n                    if backtracking(i+1, j, stack+grid[i+1][j]):\\n                        dp[(i,j, stack)]= True\\n                        return True\\n\\n            if j+1 < n:\\n                if len(stack) and grid[i][j+1] == \")\":\\n                    if backtracking(i, j+1, stack[:-1]):\\n                        dp[(i,j, stack)]= True\\n                        return True\\n                elif (len(stack) == 0 and grid[i][j+1] != \")\" )  or grid[i][j+1] == \"(\":\\n                    if backtracking(i, j+1, stack+grid[i][j+1]):\\n                        dp[(i,j, stack)]= True\\n                        return True\\n            dp[(i,j, stack)]= False\\n            return False\\n        \\n        return backtracking(0,0, grid[0][0])\\n                \\n\\n                \\n                \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650686,
                "title": "simple-fast-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def hasValidPath(self, A):\\n        m, n = len(A), len(A[0])\\n        dp = defaultdict(set)\\n        dp[0, -1] = dp[-1, 0] = {0}\\n        for i in range(m):\\n            for j in range(n):\\n                d = 1 if A[i][j] == \\'(\\' else -1\\n                dp[i,j] |= {a + d for a in dp[i-1,j] | dp[i,j-1] if a + d >= 0}\\n        return 0 in dp[m - 1, n - 1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def hasValidPath(self, A):\\n        m, n = len(A), len(A[0])\\n        dp = defaultdict(set)\\n        dp[0, -1] = dp[-1, 0] = {0}\\n        for i in range(m):\\n            for j in range(n):\\n                d = 1 if A[i][j] == \\'(\\' else -1\\n                dp[i,j] |= {a + d for a in dp[i-1,j] | dp[i,j-1] if a + d >= 0}\\n        return 0 in dp[m - 1, n - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644364,
                "title": "dp-with-sets",
                "content": "# Intuition\\n\\nEach path can be described by a walk $S$ on integers. If the the path goes through a field of the grid containing `\\'(\\'` then the walk steps up otherwise down. \\nSo $S_k$ is the difference of the opening and closing parantheses among the first $k$ element of the path.\\n\\nA path is valid if $S$ stays on the non-negative half-line.\\n\\n \\nFor each position in the grid let `dp[i][j]` be the set of final positions of possible valid paths connecting `0,0` and `i,j`.\\n\\nThe answer is `true` if $0\\\\in \\\\text{dp}_{m-1,n-1}$ and `false` otherwise.\\n\\nThe relation for computing `dp` is\\n$$\\n    \\\\text{dp}_{i,j} = \\\\{p+d\\\\colon p \\\\in \\\\text{dp}_{i-1, j}\\\\cup \\\\text{dp}_{i, j-1}\\\\}, \\\\quad\\\\text{where $d=\\\\pm1$ depending on  $\\\\text{grid}_{i,j}$}\\n$$\\n\\n# Complexity\\n- Time complexity: $$O(m*n*(m+n))$$, where $(m,n)$ is the size of the grid\\n\\n- Space complexity: $$O(n*(m+n))$$\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n\\n        if (m+n)&1==0 or grid[0][0]!=\"(\" or grid[-1][-1]!=\")\":\\n            return False\\n\\n        dp = [{0}] + [set() for _ in range(1, n)]\\n        for i in range(m):\\n            prev_set = set()\\n            all_empty = True\\n            for j in range(n):\\n                d = 1 if grid[i][j] == \"(\" else -1\\n                max_pos = n-j+m-i-2\\n                prev_set = {pos + d for pos in prev_set.union(dp[j]) if 0 <= pos + d <= max_pos}\\n                dp[j] = prev_set\\n                if prev_set:\\n                    all_empty = False\\n            if all_empty:\\n                return False\\n        return 0 in dp[-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n\\n        if (m+n)&1==0 or grid[0][0]!=\"(\" or grid[-1][-1]!=\")\":\\n            return False\\n\\n        dp = [{0}] + [set() for _ in range(1, n)]\\n        for i in range(m):\\n            prev_set = set()\\n            all_empty = True\\n            for j in range(n):\\n                d = 1 if grid[i][j] == \"(\" else -1\\n                max_pos = n-j+m-i-2\\n                prev_set = {pos + d for pos in prev_set.union(dp[j]) if 0 <= pos + d <= max_pos}\\n                dp[j] = prev_set\\n                if prev_set:\\n                    all_empty = False\\n            if all_empty:\\n                return False\\n        return 0 in dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604560,
                "title": "c-bottomup-dp",
                "content": "```\\npublic class Solution {\\n    int MIN=-9999;\\n    public bool HasValidPath(char[][] grid) {\\n        int n=grid.Length; int m=grid[0].Length;\\n        HashSet<int>[] dp=new  HashSet<int>[m];\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                HashSet<int> hs=new HashSet<int>();\\n                int t=grid[i][j] == \\'(\\' ? 1 :-1;\\n                if(i>0){\\n                    foreach(int s in dp[j])\\n                        if(s+t>=0) hs.Add(s+t);\\n                }\\n                \\n                if(j>0){\\n                    foreach(int s in dp[j-1])\\n                        if(s+t>=0)  hs.Add(s+t);\\n                }\\n                if(i==0 && j==0)\\n                    if(t>0 ) hs.Add(t); else return false;\\n                \\n                if(hs.Count==0)\\n                    hs.Add(MIN);\\n                \\n                dp[j]=hs;\\n                \\n            }\\n            \\n        }\\n        \\n        foreach(int s in dp[m-1])\\n            if(s==0)\\n                return true;\\n        \\n        return false;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    int MIN=-9999;\\n    public bool HasValidPath(char[][] grid) {\\n        int n=grid.Length; int m=grid[0].Length;\\n        HashSet<int>[] dp=new  HashSet<int>[m];\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                HashSet<int> hs=new HashSet<int>();\\n                int t=grid[i][j] == \\'(\\' ? 1 :-1;\\n                if(i>0){\\n                    foreach(int s in dp[j])\\n                        if(s+t>=0) hs.Add(s+t);\\n                }\\n                \\n                if(j>0){\\n                    foreach(int s in dp[j-1])\\n                        if(s+t>=0)  hs.Add(s+t);\\n                }\\n                if(i==0 && j==0)\\n                    if(t>0 ) hs.Add(t); else return false;\\n                \\n                if(hs.Count==0)\\n                    hs.Add(MIN);\\n                \\n                dp[j]=hs;\\n                \\n            }\\n            \\n        }\\n        \\n        foreach(int s in dp[m-1])\\n            if(s==0)\\n                return true;\\n        \\n        return false;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594206,
                "title": "python-easy-pfs",
                "content": "# bfs solution\\n  bfs solution but a bit slow \\n```\\nclass Solution(object):\\n    def hasValidPath(self, grid):\\n      #get number of rows and columns \\n      r,n=len(grid),len(grid[0])\\n      #start point     \\n      i,j=0,0 \\n      #direction down ,right   \\n      directions=[(1,0),(0,1)]\\n      #quick failure test cases \\n      if grid[0][0]==\")\": return False\\n      if grid[-1][-1]==\"(\": return False\\n      if (r+n)%2==0: return False     \\n      visited=set()\\n      # x,y,number of barenthese \\n      queue=[[i,j,0]]\\n      while queue:\\n        i,j,num=queue.pop(0)\\n        num+=1 if grid[i][j]==\"(\" else -1\\n        if i==r-1 and j==n-1 and not num:\\n            return True\\n        for x,y in  directions:\\n          next_x,next_y=x+i,j+y\\n          if 0<=next_x<r and 0<=next_y<n and num>=0 and (next_x,next_y,num) not in s:\\n              queue.append([next_x,next_y,num])\\n              s.add((next_x,next_y,num))\\n      return False\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def hasValidPath(self, grid):\\n      #get number of rows and columns \\n      r,n=len(grid),len(grid[0])\\n      #start point     \\n      i,j=0,0 \\n      #direction down ,right   \\n      directions=[(1,0),(0,1)]\\n      #quick failure test cases \\n      if grid[0][0]==\")\": return False\\n      if grid[-1][-1]==\"(\": return False\\n      if (r+n)%2==0: return False     \\n      visited=set()\\n      # x,y,number of barenthese \\n      queue=[[i,j,0]]\\n      while queue:\\n        i,j,num=queue.pop(0)\\n        num+=1 if grid[i][j]==\"(\" else -1\\n        if i==r-1 and j==n-1 and not num:\\n            return True\\n        for x,y in  directions:\\n          next_x,next_y=x+i,j+y\\n          if 0<=next_x<r and 0<=next_y<n and num>=0 and (next_x,next_y,num) not in s:\\n              queue.append([next_x,next_y,num])\\n              s.add((next_x,next_y,num))\\n      return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453294,
                "title": "java-o-m-n-m-n-c-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntotal forward and backward bracket in a valid path will be (M+N)/2 each.\\nincrease variable sum when forward bracket comes and add backward only when sum is greater than 0.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int M,N, MID;\\n    Boolean[][][] dp;\\n    public boolean hasValidPath(char[][] grid) {\\n        M = grid.length;\\n        N = grid[0].length;\\n        MID = (M+N)/2;\\n        dp = new Boolean[M][N][MID+1];\\n        return rec(0, 0, grid, 0);\\n    }\\n\\n    boolean rec(int i, int j, char[][] grid, int sum) {\\n        if(i==M-1 && j==N-1) {\\n            if(sum==1 && grid[i][j]==\\')\\') {\\n                return true;\\n            }\\n            return false;\\n        }\\n        \\n        if(dp[i][j][sum]!=null)\\n        return dp[i][j][sum];\\n\\n        boolean ans = false;\\n        if(grid[i][j]==\\'(\\' && sum<MID) {\\n            if(i<M-1)\\n            ans = ans || rec(i+1,j, grid, sum+1);\\n            if(j<N-1)\\n            ans = ans || rec(i, j+1, grid, sum+1);\\n        } else if(grid[i][j]==\\')\\' && sum>0){\\n            if(i<M-1)\\n            ans = ans || rec(i+1,j, grid, sum-1);\\n            if(j<N-1)\\n            ans = ans || rec(i, j+1, grid, sum-1);\\n        }\\n        dp[i][j][sum]=ans;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int M,N, MID;\\n    Boolean[][][] dp;\\n    public boolean hasValidPath(char[][] grid) {\\n        M = grid.length;\\n        N = grid[0].length;\\n        MID = (M+N)/2;\\n        dp = new Boolean[M][N][MID+1];\\n        return rec(0, 0, grid, 0);\\n    }\\n\\n    boolean rec(int i, int j, char[][] grid, int sum) {\\n        if(i==M-1 && j==N-1) {\\n            if(sum==1 && grid[i][j]==\\')\\') {\\n                return true;\\n            }\\n            return false;\\n        }\\n        \\n        if(dp[i][j][sum]!=null)\\n        return dp[i][j][sum];\\n\\n        boolean ans = false;\\n        if(grid[i][j]==\\'(\\' && sum<MID) {\\n            if(i<M-1)\\n            ans = ans || rec(i+1,j, grid, sum+1);\\n            if(j<N-1)\\n            ans = ans || rec(i, j+1, grid, sum+1);\\n        } else if(grid[i][j]==\\')\\' && sum>0){\\n            if(i<M-1)\\n            ans = ans || rec(i+1,j, grid, sum-1);\\n            if(j<N-1)\\n            ans = ans || rec(i, j+1, grid, sum-1);\\n        }\\n        dp[i][j][sum]=ans;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439212,
                "title": "add-a-little-pruning-for-the-dp-solution-to-make-it-a-little-bit-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nObservations:\\n1. if grid[0][0] == \")\" or grid[-1][-1] == \"(\", it would not work--> False\\n2. The total number of items in the path would be row + col -1. This number has to be even in order for the parenthese to be valid.\\n3. Using dp set, use defaultdict(set) is much faster\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(mn*(m + n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n \\n        row, col = len(grid), len(grid[0])\\n        if grid[0][0] == \")\" or grid[-1][-1] == \"(\" or (row + col - 1) % 2:\\n            return False\\n\\n        dp = defaultdict(set)\\n        dp[0, 0] = {1}\\n\\n        for r in range(row):\\n            for c in range(col):\\n                sign = 1 if grid[r][c] == \"(\" else -1\\n                dp[r, c] |= set([val + sign  for val in dp[(r -1, c)] | dp[(r, c- 1)] if val + sign >= 0])\\n        \\n        return 0 in dp[(row-1, col -1)]\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n \\n        row, col = len(grid), len(grid[0])\\n        if grid[0][0] == \")\" or grid[-1][-1] == \"(\" or (row + col - 1) % 2:\\n            return False\\n\\n        dp = defaultdict(set)\\n        dp[0, 0] = {1}\\n\\n        for r in range(row):\\n            for c in range(col):\\n                sign = 1 if grid[r][c] == \"(\" else -1\\n                dp[r, c] |= set([val + sign  for val in dp[(r -1, c)] | dp[(r, c- 1)] if val + sign >= 0])\\n        \\n        return 0 in dp[(row-1, col -1)]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437743,
                "title": "java-easy-to-understand-dfs-dp",
                "content": "```\\nclass Solution {\\n    Boolean[][][] dp;\\n    private boolean solve(char[][] grid, int i, int j, int path){\\n        if(i == grid.length || j == grid[0].length) return false;\\n        path += (grid[i][j] == \\'(\\' ? 1 : -1);\\n        if(i == grid.length - 1 && j == grid[0].length - 1)\\n            return path == 0;\\n        if(path < 0) return false;\\n        if(dp[i][j][path] != null) return dp[i][j][path];\\n        return dp[i][j][path] = solve(grid, i + 1, j, path) || solve(grid, i, j + 1, path);\\n    }\\n    public boolean hasValidPath(char[][] grid) {\\n        dp = new Boolean[grid.length][grid[0].length][210];\\n        return solve(grid, 0, 0, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    Boolean[][][] dp;\\n    private boolean solve(char[][] grid, int i, int j, int path){\\n        if(i == grid.length || j == grid[0].length) return false;\\n        path += (grid[i][j] == \\'(\\' ? 1 : -1);\\n        if(i == grid.length - 1 && j == grid[0].length - 1)\\n            return path == 0;\\n        if(path < 0) return false;\\n        if(dp[i][j][path] != null) return dp[i][j][path];\\n        return dp[i][j][path] = solve(grid, i + 1, j, path) || solve(grid, i, j + 1, path);\\n    }\\n    public boolean hasValidPath(char[][] grid) {\\n        dp = new Boolean[grid.length][grid[0].length][210];\\n        return solve(grid, 0, 0, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386251,
                "title": "bottom-up-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        if(grid[0][0] == \\')\\' || grid[n-1][m-1] == \\'(\\'){\\n            return false;\\n        }\\n        \\n        // \\'(\\' -> + 1\\n        // \\')\\' -> -1\\n        vector<vector<vector<bool>>> dp(n,vector<vector<bool>> (m,vector<bool> (203,false)));\\n        \\n        dp[0][0][1] = true;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==0 && j==0){\\n                    continue;\\n                }\\n                \\n                for(int k=0;k<202;k++){\\n                    if(i>0){\\n                        if(grid[i][j] == \\'(\\'){\\n                            if(k>0){\\n                               dp[i][j][k] = dp[i][j][k] | dp[i-1][j][k-1]; \\n                            }\\n                        }else{\\n                            dp[i][j][k] = dp[i][j][k] | dp[i-1][j][k+1];\\n                        }\\n                        \\n                    }\\n                    if(j>0){\\n                        if(grid[i][j] == \\'(\\'){\\n                            if(k>0){\\n                               dp[i][j][k] = dp[i][j][k] | dp[i][j-1][k-1]; \\n                            }\\n                        }else{\\n                            dp[i][j][k] = dp[i][j][k] | dp[i][j-1][k+1];\\n                        }\\n                    }\\n                        \\n                }\\n                \\n            }\\n        }\\n        return dp[n-1][m-1][0];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        if(grid[0][0] == \\')\\' || grid[n-1][m-1] == \\'(\\'){\\n            return false;\\n        }\\n        \\n        // \\'(\\' -> + 1\\n        // \\')\\' -> -1\\n        vector<vector<vector<bool>>> dp(n,vector<vector<bool>> (m,vector<bool> (203,false)));\\n        \\n        dp[0][0][1] = true;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==0 && j==0){\\n                    continue;\\n                }\\n                \\n                for(int k=0;k<202;k++){\\n                    if(i>0){\\n                        if(grid[i][j] == \\'(\\'){\\n                            if(k>0){\\n                               dp[i][j][k] = dp[i][j][k] | dp[i-1][j][k-1]; \\n                            }\\n                        }else{\\n                            dp[i][j][k] = dp[i][j][k] | dp[i-1][j][k+1];\\n                        }\\n                        \\n                    }\\n                    if(j>0){\\n                        if(grid[i][j] == \\'(\\'){\\n                            if(k>0){\\n                               dp[i][j][k] = dp[i][j][k] | dp[i][j-1][k-1]; \\n                            }\\n                        }else{\\n                            dp[i][j][k] = dp[i][j][k] | dp[i][j-1][k+1];\\n                        }\\n                    }\\n                        \\n                }\\n                \\n            }\\n        }\\n        return dp[n-1][m-1][0];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295403,
                "title": "easy-dfs-dp-solution-approach-cpp",
                "content": "# Intuition and Approach\\n* write simple dfs recursion for traversing.\\n* for valid parenthessis string keep a variable which is initialize from zero.it will increse by 1 if current cell char is \\'(\\' and decrease by 1 if current cell char is \\')\\'.\\n* whenever u find this variable becomes negative return false. because there must be one open bracket before we include one close bracket.\\n* if you reach to bottom right and your variable is zero then return true else return false.\\n* short your dfs calls by using or gate.\\n* take care of index if it goes beyond bounds.\\n* prepare a 3d dp array of size rows x cols x (rows+cols+1).\\n* (rows+ cols)==> for the variable which we initialize from zero. its max value is row + cols, because this is max no of moves to reach bottom right from top left.\\n* keep ans in dp whenever calculated before returning.\\n* check ans in dp before entering recursion.  \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check (vector<vector<char>>& grid,int m,int n,int i,int j,int flag,vector<vector<vector<int>>>& dp){\\n        \\n        if(flag<0 || i>=m || j>=n)return false;\\n        if(dp[i][j][flag]!=-1)return dp[i][j][flag];\\n        int temp=flag;\\n        if(grid[i][j]==\\'(\\')flag++;\\n        else flag--;\\n        if(i==m-1 && j==n-1){\\n            if(flag==0)return true;\\n            else return false;\\n        }\\n        \\n        return dp[i][j][temp]=(check(grid,m,n,i+1,j,flag,dp) || check(grid,m,n,i,j+1,flag,dp));\\n    }\\n\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int k=(m+n+10);\\n        int flag=0;\\n        vector<vector<vector<int>>>dp(m,vector<vector<int>>(n,vector<int>(k,-1)));\\n        return check(grid,grid.size(),grid[0].size(),0,0,flag,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check (vector<vector<char>>& grid,int m,int n,int i,int j,int flag,vector<vector<vector<int>>>& dp){\\n        \\n        if(flag<0 || i>=m || j>=n)return false;\\n        if(dp[i][j][flag]!=-1)return dp[i][j][flag];\\n        int temp=flag;\\n        if(grid[i][j]==\\'(\\')flag++;\\n        else flag--;\\n        if(i==m-1 && j==n-1){\\n            if(flag==0)return true;\\n            else return false;\\n        }\\n        \\n        return dp[i][j][temp]=(check(grid,m,n,i+1,j,flag,dp) || check(grid,m,n,i,j+1,flag,dp));\\n    }\\n\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int k=(m+n+10);\\n        int flag=0;\\n        vector<vector<vector<int>>>dp(m,vector<vector<int>>(n,vector<int>(k,-1)));\\n        return check(grid,grid.size(),grid[0].size(),0,0,flag,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236615,
                "title": "very-to-understand-simple-dfs-memoization",
                "content": "# Code\\n```\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\nclass Solution {\\npublic:\\n    vector<vector<vector<int>>>dp;\\n    bool hasValidPath(vector<vector<char>>& grid) \\n    {\\n        //initializing the dp form memoization\\n        dp.resize(grid.size()+1,vector<vector<int>>(grid[0].size()+1,vector<int>(205,-1)));\\n\\n        //row and col for traversing the grid\\n        int row = 0;\\n        int col = 0;\\n        \\n        //mainitng a variable to keep the track of the open and the close bracket\\n        int k = 0;\\n\\n        //fun function will return if there exist any path from top to bottom with valid vps\\n        return fun(grid,row,col,k);    \\n    }\\n    int fun(vector<vector<char>>&grid,int row,int col,int k)\\n    {\\n          if(row<0 or row>=grid.size() or col<0 or col>=grid[0].size())\\n          {\\n              return false;\\n          }\\n\\n          if(grid[row][col] == \\'(\\')\\n          {\\n              k++;\\n          }      \\n          else if(grid[row][col] == \\')\\')\\n          {\\n              k--;\\n          }\\n\\n          if(k < 0) //no of cloing brackets are now more than no of opening brackets return flase\\n          return false;\\n\\n          if(row == grid.size()-1 and col == grid[0].size()-1)   //if we reach the destination\\n          {\\n                if(k > 0)  //this means no of opening are more than closing \\n                return false;\\n\\n                if(k == 0)  //this means all the brackets are balances\\n                return true;\\n\\n                if(k < 0)   //no of closing brackets are more than no of opening brackets\\n                return false;\\n          }\\n          \\n          //if the state is currently computed\\n          if(dp[row][col][k]!=-1)\\n          return dp[row][col][k];\\n     \\n          //checking all the possibility \\n          int choise1 = fun(grid,row+1,col,k);\\n          int choise2 = fun(grid,row,col+1,k);\\n\\n          return dp[row][col][k] = choise1 or choise2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\nclass Solution {\\npublic:\\n    vector<vector<vector<int>>>dp;\\n    bool hasValidPath(vector<vector<char>>& grid) \\n    {\\n        //initializing the dp form memoization\\n        dp.resize(grid.size()+1,vector<vector<int>>(grid[0].size()+1,vector<int>(205,-1)));\\n\\n        //row and col for traversing the grid\\n        int row = 0;\\n        int col = 0;\\n        \\n        //mainitng a variable to keep the track of the open and the close bracket\\n        int k = 0;\\n\\n        //fun function will return if there exist any path from top to bottom with valid vps\\n        return fun(grid,row,col,k);    \\n    }\\n    int fun(vector<vector<char>>&grid,int row,int col,int k)\\n    {\\n          if(row<0 or row>=grid.size() or col<0 or col>=grid[0].size())\\n          {\\n              return false;\\n          }\\n\\n          if(grid[row][col] == \\'(\\')\\n          {\\n              k++;\\n          }      \\n          else if(grid[row][col] == \\')\\')\\n          {\\n              k--;\\n          }\\n\\n          if(k < 0) //no of cloing brackets are now more than no of opening brackets return flase\\n          return false;\\n\\n          if(row == grid.size()-1 and col == grid[0].size()-1)   //if we reach the destination\\n          {\\n                if(k > 0)  //this means no of opening are more than closing \\n                return false;\\n\\n                if(k == 0)  //this means all the brackets are balances\\n                return true;\\n\\n                if(k < 0)   //no of closing brackets are more than no of opening brackets\\n                return false;\\n          }\\n          \\n          //if the state is currently computed\\n          if(dp[row][col][k]!=-1)\\n          return dp[row][col][k];\\n     \\n          //checking all the possibility \\n          int choise1 = fun(grid,row+1,col,k);\\n          int choise2 = fun(grid,row,col+1,k);\\n\\n          return dp[row][col][k] = choise1 or choise2;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3131177,
                "title": "c-dp-recursive-fast-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<vector<int>>> &dp, vector<vector<char>> &grid, int i, int j, int open)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        if(open < 0)return false;\\n        if(dp[i][j][open]!=-1)return dp[i][j][open];\\n        if(i == n-1 && j == m-1)\\n        {\\n            if(grid[i][j] == \\')\\' && open == 1)return dp[i][j][open] = true;\\n            return dp[i][j][open] = false;\\n        }\\n        bool ans = false;\\n        if(grid[i][j] == \\'(\\')\\n        {\\n            if(i+1 < n)ans = ans | solve(dp, grid, i+1, j, open+1);\\n            if(j+1 < m)ans = ans | solve(dp, grid, i, j+1, open+1);\\n        }\\n        else\\n        {\\n            if(i+1 < n)ans = ans | solve(dp, grid, i+1, j, open-1);\\n            if(j+1 < m)ans = ans | solve(dp, grid, i, j+1, open-1);\\n        }\\n        return dp[i][j][open] = ans;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid){\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>> (m, vector<int> (m+n, -1)));\\n        return solve(dp, grid, 0,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<vector<int>>> &dp, vector<vector<char>> &grid, int i, int j, int open)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        if(open < 0)return false;\\n        if(dp[i][j][open]!=-1)return dp[i][j][open];\\n        if(i == n-1 && j == m-1)\\n        {\\n            if(grid[i][j] == \\')\\' && open == 1)return dp[i][j][open] = true;\\n            return dp[i][j][open] = false;\\n        }\\n        bool ans = false;\\n        if(grid[i][j] == \\'(\\')\\n        {\\n            if(i+1 < n)ans = ans | solve(dp, grid, i+1, j, open+1);\\n            if(j+1 < m)ans = ans | solve(dp, grid, i, j+1, open+1);\\n        }\\n        else\\n        {\\n            if(i+1 < n)ans = ans | solve(dp, grid, i+1, j, open-1);\\n            if(j+1 < m)ans = ans | solve(dp, grid, i, j+1, open-1);\\n        }\\n        return dp[i][j][open] = ans;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid){\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>> (m, vector<int> (m+n, -1)));\\n        return solve(dp, grid, 0,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030477,
                "title": "best-optimised-c-coolution-please-upvote-if-u-like-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N*M)+O(N+M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int n, m;\\n    bool solve(int x, int y, int open, vector<vector<char>>& grid, vector<vector<vector<int>>> &dp)\\n    {\\n        if(x >= n || y >= m) return false;\\n        if(grid[x][y] == \\'(\\')\\n            open++;\\n        else\\n            open--;\\n        if(open < 0)\\n            return false;\\n        if(dp[x][y][open] != -1)\\n            return dp[x][y][open];\\n        if(x == n-1 && y == m-1)\\n        {\\n           return open==0;\\n        }\\n        bool ans = solve(x+1, y, open, grid, dp) ||solve(x, y+1, open, grid, dp);\\n        return dp[x][y][open] = ans;\\n    }\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        vector<vector<vector<int>>> dp(n+1, vector<vector<int>> (m+1, vector<int> (201, -1)));\\n        return solve(0,0,0,grid,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Stack",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int n, m;\\n    bool solve(int x, int y, int open, vector<vector<char>>& grid, vector<vector<vector<int>>> &dp)\\n    {\\n        if(x >= n || y >= m) return false;\\n        if(grid[x][y] == \\'(\\')\\n            open++;\\n        else\\n            open--;\\n        if(open < 0)\\n            return false;\\n        if(dp[x][y][open] != -1)\\n            return dp[x][y][open];\\n        if(x == n-1 && y == m-1)\\n        {\\n           return open==0;\\n        }\\n        bool ans = solve(x+1, y, open, grid, dp) ||solve(x, y+1, open, grid, dp);\\n        return dp[x][y][open] = ans;\\n    }\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        vector<vector<vector<int>>> dp(n+1, vector<vector<int>> (m+1, vector<int> (201, -1)));\\n        return solve(0,0,0,grid,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019025,
                "title": "dfs-dp",
                "content": "# Intuition\\nsimple DP+DFS;\\n\\n# Approach\\nApply DFS and memoize all the places and count k which is count of \\'(\\' if current position in \\'(\\' then k++ else k--. if it goes to end and k==0 then we get a valid  parenthesis path other wise not a valid parenthesis;\\n\\n# Complexity\\n- Time complexity:\\nO(n*m*k);\\n\\n- Space complexity:\\no(n*m);\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[100][100][205];\\n    int n,m;\\n    bool getSolution(vector<vector<char>>& grid , int i, int j , int k){\\n        if(i>=n|| j>=m){\\n            return false;\\n        }\\n        if(grid[i][j]==\\'(\\'){\\n            k++;\\n        }\\n        else{\\n            k--;\\n        }\\n        if(k<0){\\n            return false;\\n        }\\n        if(i==(n-1)&&j==(m-1)){\\n            return k==0;\\n        }\\n        int &ans=dp[i][j][k];\\n        if(ans!=-1){\\n            return ans;\\n        }\\n        return ans = getSolution(grid,i+1,j,k)| getSolution(grid,i,j+1,k);  \\n    }\\n\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        n=grid.size();\\n        m=grid[0].size();\\n    memset(dp,-1,sizeof(dp));\\n    return getSolution(grid,0,0,0);    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[100][100][205];\\n    int n,m;\\n    bool getSolution(vector<vector<char>>& grid , int i, int j , int k){\\n        if(i>=n|| j>=m){\\n            return false;\\n        }\\n        if(grid[i][j]==\\'(\\'){\\n            k++;\\n        }\\n        else{\\n            k--;\\n        }\\n        if(k<0){\\n            return false;\\n        }\\n        if(i==(n-1)&&j==(m-1)){\\n            return k==0;\\n        }\\n        int &ans=dp[i][j][k];\\n        if(ans!=-1){\\n            return ans;\\n        }\\n        return ans = getSolution(grid,i+1,j,k)| getSolution(grid,i,j+1,k);  \\n    }\\n\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        n=grid.size();\\n        m=grid[0].size();\\n    memset(dp,-1,sizeof(dp));\\n    return getSolution(grid,0,0,0);    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975133,
                "title": "python3-java-top-down-dp",
                "content": "```\\nPython3\\n\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m,n = len(grid),len(grid[0])\\n        @cache\\n        def dp(r,c,k):\\n            if r == m or c == n:\\n                return False\\n            if grid[r][c] == \"(\":\\n                k += 1\\n            else:\\n                k -= 1\\n            if k < 0:\\n                return False\\n            if r == m-1 and c == n-1:\\n                return k == 0\\n            return dp(r+1,c,k) or dp(r,c+1,k)\\n        return dp(0,0,0)\\n```\\n```\\nJava\\n\\nclass Solution {\\n    int m,n;\\n    Boolean[][][] dp = new Boolean[100][100][200];\\n    public boolean dfs(int r,int c,int k,char[][] grid){\\n        if( r == m || c == n){\\n            return false;\\n        }\\n        if (grid[r][c] == \\'(\\'){\\n            k++;\\n        }\\n        else{\\n            k--;\\n        }\\n        if( k < 0){\\n            return false;\\n        }\\n        if (r == m - 1 && c == n - 1){\\n            return k == 0 ? true : false;\\n        }\\n        if (dp[r][c][k] != null){\\n            return dp[r][c][k];\\n        }\\n        return dp[r][c][k] = dfs(r+1,c,k,grid) || dfs(r,c+1,k,grid);\\n        \\n    }\\n    public boolean hasValidPath(char[][] grid) {\\n        m = grid.length ; n = grid[0].length;\\n        return dfs(0,0,0,grid);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nPython3\\n\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m,n = len(grid),len(grid[0])\\n        @cache\\n        def dp(r,c,k):\\n            if r == m or c == n:\\n                return False\\n            if grid[r][c] == \"(\":\\n                k += 1\\n            else:\\n                k -= 1\\n            if k < 0:\\n                return False\\n            if r == m-1 and c == n-1:\\n                return k == 0\\n            return dp(r+1,c,k) or dp(r,c+1,k)\\n        return dp(0,0,0)\\n```\n```\\nJava\\n\\nclass Solution {\\n    int m,n;\\n    Boolean[][][] dp = new Boolean[100][100][200];\\n    public boolean dfs(int r,int c,int k,char[][] grid){\\n        if( r == m || c == n){\\n            return false;\\n        }\\n        if (grid[r][c] == \\'(\\'){\\n            k++;\\n        }\\n        else{\\n            k--;\\n        }\\n        if( k < 0){\\n            return false;\\n        }\\n        if (r == m - 1 && c == n - 1){\\n            return k == 0 ? true : false;\\n        }\\n        if (dp[r][c][k] != null){\\n            return dp[r][c][k];\\n        }\\n        return dp[r][c][k] = dfs(r+1,c,k,grid) || dfs(r,c+1,k,grid);\\n        \\n    }\\n    public boolean hasValidPath(char[][] grid) {\\n        m = grid.length ; n = grid[0].length;\\n        return dfs(0,0,0,grid);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957808,
                "title": "3d-dynamic-programming-c-fast-simple-clean-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll dp[101][101][201];\\n\\n    ll solve(vector<vector<char>>&grid,ll i,ll j,ll count,ll n,ll m){\\n        if(i==n-1 && j==m-1){\\n            if(grid[i][j]==\\'(\\' || count!=1){\\n                return 0;\\n            }\\n            return 1;\\n        }\\n        if(dp[i][j][count]!=-1){\\n            return dp[i][j][count];\\n        }\\n        bool answer=0;\\n        if(i+1<n){\\n            if(grid[i][j]==\\'(\\'){\\n                answer+=solve(grid,i+1,j,count+1,n,m);\\n            }\\n            else if(count>0){\\n                answer+=solve(grid,i+1,j,count-1,n,m);\\n            }\\n        }\\n        if(j+1<m){\\n            if(grid[i][j]==\\'(\\'){\\n                answer+=solve(grid,i,j+1,count+1,n,m);\\n            }\\n            else if(count>0){\\n                answer+=solve(grid,i,j+1,count-1,n,m);\\n            }\\n        }\\n        return dp[i][j][count]=answer;\\n    }\\n\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        ll n=grid.size(),m=grid[0].size();memset(dp,-1,sizeof(dp));\\n        return solve(grid,0,0,0,n,m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll dp[101][101][201];\\n\\n    ll solve(vector<vector<char>>&grid,ll i,ll j,ll count,ll n,ll m){\\n        if(i==n-1 && j==m-1){\\n            if(grid[i][j]==\\'(\\' || count!=1){\\n                return 0;\\n            }\\n            return 1;\\n        }\\n        if(dp[i][j][count]!=-1){\\n            return dp[i][j][count];\\n        }\\n        bool answer=0;\\n        if(i+1<n){\\n            if(grid[i][j]==\\'(\\'){\\n                answer+=solve(grid,i+1,j,count+1,n,m);\\n            }\\n            else if(count>0){\\n                answer+=solve(grid,i+1,j,count-1,n,m);\\n            }\\n        }\\n        if(j+1<m){\\n            if(grid[i][j]==\\'(\\'){\\n                answer+=solve(grid,i,j+1,count+1,n,m);\\n            }\\n            else if(count>0){\\n                answer+=solve(grid,i,j+1,count-1,n,m);\\n            }\\n        }\\n        return dp[i][j][count]=answer;\\n    }\\n\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        ll n=grid.size(),m=grid[0].size();memset(dp,-1,sizeof(dp));\\n        return solve(grid,0,0,0,n,m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942771,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\n/**\\n * @param {character[][]} grid\\n * @return {boolean}\\n */\\nvar hasValidPath = function(grid) {\\n  let visiting = new Set();\\n  let cache = new Set();\\n  return dfs([0, 0], grid, visiting, 0, cache);\\n};\\n\\nfunction dfs(cell, grid, visiting, currentSum, cache) {\\n  let [row, col] = cell;\\n  let val = grid[row][col] === \"(\" ? 1 : -1;\\n  let remainingSum = 0 - (currentSum + val);\\n  if (cache.has(`${row}_${col}_${remainingSum}`)) {\\n    return false;\\n  }\\n  if (currentSum + val < 0) {\\n    return false;\\n  }\\n  \\n  if (row === grid.length - 1 && col === grid[0].length - 1) {\\n    // reached the end\\n    return (currentSum + val === 0);\\n  }\\n  \\n  // add it to visiting\\n  visiting.add(`${row}_${col}`);\\n  \\n  // visit all neighbors\\n  for (let [i, j] of [[1, 0], [0, 1]]) {\\n    if (isValid(grid, row + i, col + j) &&\\n      !visiting.has(`${row + i}_${col + j}`)) {\\n      \\n      // add neighbor to search\\n      if (dfs([row + i, col + j], grid, visiting, currentSum + val, cache)) {\\n        return true;\\n      }\\n    }\\n  }\\n  \\n  visiting.delete(`${row}_${col}`);\\n  cache.add(`${row}_${col}_${remainingSum}`);\\n  \\n  return false;\\n}\\n\\nfunction isValid(grid, row, col) {\\n  if (row >= 0 && col >= 0 && row < grid.length && col < grid[0].length) {\\n    return true;\\n  }\\n  return false;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n\\n/**\\n * @param {character[][]} grid\\n * @return {boolean}\\n */\\nvar hasValidPath = function(grid) {\\n  let visiting = new Set();\\n  let cache = new Set();\\n  return dfs([0, 0], grid, visiting, 0, cache);\\n};\\n\\nfunction dfs(cell, grid, visiting, currentSum, cache) {\\n  let [row, col] = cell;\\n  let val = grid[row][col] === \"(\" ? 1 : -1;\\n  let remainingSum = 0 - (currentSum + val);\\n  if (cache.has(`${row}_${col}_${remainingSum}`)) {\\n    return false;\\n  }\\n  if (currentSum + val < 0) {\\n    return false;\\n  }\\n  \\n  if (row === grid.length - 1 && col === grid[0].length - 1) {\\n    // reached the end\\n    return (currentSum + val === 0);\\n  }\\n  \\n  // add it to visiting\\n  visiting.add(`${row}_${col}`);\\n  \\n  // visit all neighbors\\n  for (let [i, j] of [[1, 0], [0, 1]]) {\\n    if (isValid(grid, row + i, col + j) &&\\n      !visiting.has(`${row + i}_${col + j}`)) {\\n      \\n      // add neighbor to search\\n      if (dfs([row + i, col + j], grid, visiting, currentSum + val, cache)) {\\n        return true;\\n      }\\n    }\\n  }\\n  \\n  visiting.delete(`${row}_${col}`);\\n  cache.add(`${row}_${col}_${remainingSum}`);\\n  \\n  return false;\\n}\\n\\nfunction isValid(grid, row, col) {\\n  if (row >= 0 && col >= 0 && row < grid.length && col < grid[0].length) {\\n    return true;\\n  }\\n  return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2937462,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hasValidPath(self, grid):\\n        m, n = len(grid), len(grid[0])\\n\\n        @lru_cache(None)\\n        def dfs(i,j,total):\\n            if grid[i][j] == \"(\":\\n                total += 1\\n            else:\\n                total -= 1  \\n \\n            if total < 0:\\n                return False\\n\\n            if i == m-1 and j == n-1 and total == 0:\\n                return True\\n\\n            if i+1 < m and dfs(i+1,j,total):\\n                return True\\n\\n            if j+1 < n and dfs(i,j+1,total):\\n                return True\\n\\n        return dfs(0,0,0)\\n\\n        \\n\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid):\\n        m, n = len(grid), len(grid[0])\\n\\n        @lru_cache(None)\\n        def dfs(i,j,total):\\n            if grid[i][j] == \"(\":\\n                total += 1\\n            else:\\n                total -= 1  \\n \\n            if total < 0:\\n                return False\\n\\n            if i == m-1 and j == n-1 and total == 0:\\n                return True\\n\\n            if i+1 < m and dfs(i+1,j,total):\\n                return True\\n\\n            if j+1 < n and dfs(i,j+1,total):\\n                return True\\n\\n        return dfs(0,0,0)\\n\\n        \\n\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724242,
                "title": "python-dfs-faster-than-100",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        def dfs(y, x, t):\\n            if ans[0] or (y, x, t) in seen: return\\n            if x + y + 1 == l:\\n                if t == 0: ans[0] = True\\n                return\\n            if t + x + y + 1 > l: return\\n            seen.add((y, x, t))\\n            for yy, xx in (y + 1, x), (y, x + 1):\\n                if not (0 <= xx < n and 0 <= yy < m): continue\\n                tt = t + (-1) ** (grid[yy][xx] == \\')\\')\\n                if (yy, xx, tt) in seen or tt < 0: continue\\n                dfs(yy, xx, tt)\\n                \\n        m, n, l = len(grid), len(grid[0]), len(grid) + len(grid[0]) - 1\\n        if l % 2: return False\\n        seen, ans = set(), [False]\\n        dfs(0, -1, 0)\\n        return ans[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        def dfs(y, x, t):\\n            if ans[0] or (y, x, t) in seen: return\\n            if x + y + 1 == l:\\n                if t == 0: ans[0] = True\\n                return\\n            if t + x + y + 1 > l: return\\n            seen.add((y, x, t))\\n            for yy, xx in (y + 1, x), (y, x + 1):\\n                if not (0 <= xx < n and 0 <= yy < m): continue\\n                tt = t + (-1) ** (grid[yy][xx] == \\')\\')\\n                if (yy, xx, tt) in seen or tt < 0: continue\\n                dfs(yy, xx, tt)\\n                \\n        m, n, l = len(grid), len(grid[0]), len(grid) + len(grid[0]) - 1\\n        if l % 2: return False\\n        seen, ans = set(), [False]\\n        dfs(0, -1, 0)\\n        return ans[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666464,
                "title": "greedy-dp-concepts",
                "content": "```\\nif it is \\'(\\' increment score else decrement it\\nif you don\\'t know why i am doing that check out these problems first \\nhttps://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/\\nhttps://leetcode.com/problems/check-if-a-parentheses-string-can-be-valid/\\nhttps://leetcode.com/problems/valid-parenthesis-string/\\n\\n\\n\\nnow, for every valid cell, we can either move down or move right \\nat the end of the moves, i.e right end of the cell\\nif score == 0, we are good to go else return false;\\n\\nclass Solution {\\npublic:\\n    \\n    bool solve(int x, int y, int x_bound, int y_bound, int score,vector<vector<char>>&table, vector<vector<vector<int>>>&dp){\\n           // at each point score must be greater than or equal to 0\\n         bool move_down=false, move_right= false;\\n          \\n          if(x < x_bound && y < y_bound){\\n                   \\n                \\n                  if(table[x][y]==\\'(\\')++score;\\n                  else score --;\\n                  \\n                  if(score < 0)return false;\\n                 \\n                    if(dp[x][y][score]!=-1)return dp[x][y][score];\\n              \\n                   move_down = solve(x+1,y,x_bound,y_bound, score,table,dp);\\n                   move_right = solve(x, y+1, x_bound, y_bound, score, table,dp);\\n          }\\n          \\n          else if( (x==x_bound-1 && y==y_bound ) || (x==x_bound && y==y_bound-1)){\\n               \\n                 return score==0;\\n          }\\n          \\n        \\n          return dp[x][y][score]=move_down|| move_right;\\n           \\n          \\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n         \\n        vector<vector<vector<int>>>dp(grid.size()+1, vector<vector<int>>(grid[0].size()+1,vector<int>(grid.size()+grid[0].size(),-1)));\\n        \\n        return solve(0,0,grid.size(), grid[0].size(),0,grid,dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nif it is \\'(\\' increment score else decrement it\\nif you don\\'t know why i am doing that check out these problems first \\nhttps://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/\\nhttps://leetcode.com/problems/check-if-a-parentheses-string-can-be-valid/\\nhttps://leetcode.com/problems/valid-parenthesis-string/\\n\\n\\n\\nnow, for every valid cell, we can either move down or move right \\nat the end of the moves, i.e right end of the cell\\nif score == 0, we are good to go else return false;\\n\\nclass Solution {\\npublic:\\n    \\n    bool solve(int x, int y, int x_bound, int y_bound, int score,vector<vector<char>>&table, vector<vector<vector<int>>>&dp){\\n           // at each point score must be greater than or equal to 0\\n         bool move_down=false, move_right= false;\\n          \\n          if(x < x_bound && y < y_bound){\\n                   \\n                \\n                  if(table[x][y]==\\'(\\')++score;\\n                  else score --;\\n                  \\n                  if(score < 0)return false;\\n                 \\n                    if(dp[x][y][score]!=-1)return dp[x][y][score];\\n              \\n                   move_down = solve(x+1,y,x_bound,y_bound, score,table,dp);\\n                   move_right = solve(x, y+1, x_bound, y_bound, score, table,dp);\\n          }\\n          \\n          else if( (x==x_bound-1 && y==y_bound ) || (x==x_bound && y==y_bound-1)){\\n               \\n                 return score==0;\\n          }\\n          \\n        \\n          return dp[x][y][score]=move_down|| move_right;\\n           \\n          \\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n         \\n        vector<vector<vector<int>>>dp(grid.size()+1, vector<vector<int>>(grid[0].size()+1,vector<int>(grid.size()+grid[0].size(),-1)));\\n        \\n        return solve(0,0,grid.size(), grid[0].size(),0,grid,dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2644712,
                "title": "simple-dfs-dp-solution-2-ways",
                "content": "Normal DFS + DP, Java/C++/JS folk friendly\\n\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        numRows, numCols = len(grid), len(grid[0])\\n        dp = [[[-1] * (numRows + numCols + 1) for _ in range(numCols)] for _ in range(numRows)]\\n        \\n        def dfs(row: int, col: int, balance: int) -> bool:\\n            nonlocal grid, dp\\n            if row >= numRows or col >= numCols:\\n                return 0\\n            if grid[row][col] == \\'(\\':\\n                balance += 1\\n            else:\\n                balance -= 1\\n            if balance < 0:\\n                return 0\\n            if row == numRows - 1 and col == numCols - 1:\\n                return balance == 0\\n            if dp[row][col][balance] != -1:\\n                return dp[row][col][balance]\\n            dp[row][col][balance] = dfs(row + 1, col, balance) or dfs(row, col + 1, balance)\\n            return dp[row][col][balance]\\n        \\n        return dfs(0, 0, 0)\\n```\\n\\nUsing @cache: Python-specific\\n\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        numRows, numCols = len(grid), len(grid[0])\\n        \\n        @cache\\n        def dfs(row: int, col: int, balance: int) -> bool:\\n            nonlocal grid\\n            if row >= numRows or col >= numCols:\\n                return 0\\n            if grid[row][col] == \\'(\\':\\n                balance += 1\\n            else:\\n                balance -= 1\\n            if balance < 0:\\n                return 0\\n            if row == numRows - 1 and col == numCols - 1:\\n                return balance == 0\\n            return dfs(row + 1, col, balance) or dfs(row, col + 1, balance)\\n        \\n        return dfs(0, 0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        numRows, numCols = len(grid), len(grid[0])\\n        dp = [[[-1] * (numRows + numCols + 1) for _ in range(numCols)] for _ in range(numRows)]\\n        \\n        def dfs(row: int, col: int, balance: int) -> bool:\\n            nonlocal grid, dp\\n            if row >= numRows or col >= numCols:\\n                return 0\\n            if grid[row][col] == \\'(\\':\\n                balance += 1\\n            else:\\n                balance -= 1\\n            if balance < 0:\\n                return 0\\n            if row == numRows - 1 and col == numCols - 1:\\n                return balance == 0\\n            if dp[row][col][balance] != -1:\\n                return dp[row][col][balance]\\n            dp[row][col][balance] = dfs(row + 1, col, balance) or dfs(row, col + 1, balance)\\n            return dp[row][col][balance]\\n        \\n        return dfs(0, 0, 0)\\n```\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        numRows, numCols = len(grid), len(grid[0])\\n        \\n        @cache\\n        def dfs(row: int, col: int, balance: int) -> bool:\\n            nonlocal grid\\n            if row >= numRows or col >= numCols:\\n                return 0\\n            if grid[row][col] == \\'(\\':\\n                balance += 1\\n            else:\\n                balance -= 1\\n            if balance < 0:\\n                return 0\\n            if row == numRows - 1 and col == numCols - 1:\\n                return balance == 0\\n            return dfs(row + 1, col, balance) or dfs(row, col + 1, balance)\\n        \\n        return dfs(0, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597457,
                "title": "python3",
                "content": "class Solution:\\n\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        cache = {}\\n        m,n = len(grid),len(grid[0])\\n        lRow,lCol = m-1,n-1\\n        \\n        def dfs(i,j,bal):\\n            if i in [-1,m] or j in [-1,n] or bal<0:\\n                return False\\n            if (i,j,bal) not in cache:\\n                updatedBal = bal+(1 if grid[i][j]==\\'(\\' else -1)\\n                if (i,j) == (lRow,lCol) and updatedBal==0:\\n                    return True\\n                valid = dfs(i+1,j,updatedBal) or dfs(i,j+1,updatedBal)\\n                cache[(i,j,bal)] = valid\\n            return cache[(i,j,bal)]\\n        \\n        return dfs(0,0,0)",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        cache = {}",
                "codeTag": "Java"
            },
            {
                "id": 2489279,
                "title": "dp-cpp-solution",
                "content": "`****`\\nclass Solution {\\npublic:\\n    bool fun(vector<vector<char>> &grid,int i,int j,int a,int m,int n,vector<vector<vector<int>>> &dp){\\n        if(i==(m-1) && j==(n-1)){\\n            if(grid[i][j]==\\')\\' && a==1)\\n                return true;\\n            return false;\\n        }\\n        if(a<0)\\n            return false;\\n        if(dp[i][j][a]!=-1)\\n            return dp[i][j][a];\\n        int p=a;\\n        if(grid[i][j]==\\'(\\')\\n            p+=1;\\n        else\\n            p-=1;\\n        if(i<(m-1) && j<(n-1))\\n            return dp[i][j][a]=(fun(grid,i,j+1,p,m,n,dp) || fun(grid,i+1,j,p,m,n,dp));\\n        if(i<(m-1))\\n            return dp[i][j][a]=fun(grid,i+1,j,p,m,n,dp);\\n        else\\n            return dp[i][j][a]=fun(grid,i,j+1,p,m,n,dp);\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<vector<int>>> dp(m,vector<vector<int>>(n,vector<int>(m+n,-1)));\\n        return fun(grid,0,0,0,m,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool fun(vector<vector<char>> &grid,int i,int j,int a,int m,int n,vector<vector<vector<int>>> &dp){\\n        if(i==(m-1) && j==(n-1)){\\n            if(grid[i][j]==\\')\\' && a==1)\\n                return true;\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2453497,
                "title": "rust-dynamic-programming",
                "content": "~~~\\n// the important step is to use the first index to trace: # of \\'(\\' - # of \\')\\' and\\n// to ignore those invalid cases where  # of \\'(\\' < # of \\')\\'\\nimpl Solution {\\n    pub fn has_valid_path(grid: Vec<Vec<char>>) -> bool {\\n        let (m, n) = (grid.len(), grid[0].len());\\n        let mut dp = vec![vec![vec![-1; m + n]; n] ; m];\\n        \\n        Self::solve(&grid, &mut dp, 0, 0, 0) == 1\\n    }\\n    \\n    fn solve(grid: &Vec<Vec<char>>, dp: &mut Vec<Vec<Vec<i32>>>, i: usize, j: usize, k: usize) -> i32 {\\n        let (m, n) = (grid.len(), grid[0].len());\\n        if i == m || j == n { return 0 }\\n        \\n        let mut k = k as i32;\\n        k += if grid[i][j] == \\'(\\' { 1 } else { -1 };\\n        if (k < 0) { return 0 }\\n        let k = k as usize;\\n        \\n        if i == m - 1 && j == n - 1 { \\n            return if k == 0 { 1 } else { 0 }\\n        }\\n        \\n        if dp[i][j][k] != -1 { return dp[i][j][k] }\\n        dp[i][j][k] = if Self::solve(grid, dp, i + 1, j, k) == 1 || Self::solve(grid, dp, i, j + 1, k) == 1 { 1 } else { 0 };\\n        \\n        dp[i][j][k]\\n    }\\n}\\n~~~",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "~~~\\n// the important step is to use the first index to trace: # of \\'(\\' - # of \\')\\' and\\n// to ignore those invalid cases where  # of \\'(\\' < # of \\')\\'\\nimpl Solution {\\n    pub fn has_valid_path(grid: Vec<Vec<char>>) -> bool {\\n        let (m, n) = (grid.len(), grid[0].len());\\n        let mut dp = vec![vec![vec![-1; m + n]; n] ; m];\\n        \\n        Self::solve(&grid, &mut dp, 0, 0, 0) == 1\\n    }\\n    \\n    fn solve(grid: &Vec<Vec<char>>, dp: &mut Vec<Vec<Vec<i32>>>, i: usize, j: usize, k: usize) -> i32 {\\n        let (m, n) = (grid.len(), grid[0].len());\\n        if i == m || j == n { return 0 }\\n        \\n        let mut k = k as i32;\\n        k += if grid[i][j] == \\'(\\' { 1 } else { -1 };\\n        if (k < 0) { return 0 }\\n        let k = k as usize;\\n        \\n        if i == m - 1 && j == n - 1 { \\n            return if k == 0 { 1 } else { 0 }\\n        }\\n        \\n        if dp[i][j][k] != -1 { return dp[i][j][k] }\\n        dp[i][j][k] = if Self::solve(grid, dp, i + 1, j, k) == 1 || Self::solve(grid, dp, i, j + 1, k) == 1 { 1 } else { 0 };\\n        \\n        dp[i][j][k]\\n    }\\n}\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2443083,
                "title": "simple-and-clean-python-solution-with-dp-o-mn-m-n",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        R, C = len(grid), len(grid[0])\\n        dp = [[[False for i in range(R+C+1)] for c in range(C+1)] for r in range(R+1)]\\n        dp[R][C-1][0] = True\\n        dp[R-1][C][0] = True\\n        for r in range(R-1, -1, -1):\\n            for c in range(C-1, -1, -1):\\n                for i in range(R+C):\\n                    nxt = [1,-1][grid[r][c] == \")\"]\\n                    dp[r][c][i] = dp[r+1][c][i+nxt] or dp[r][c+1][i+nxt]\\n        return dp[0][0][0]\\n                    \\n```\\n**EDIT:**\\nThe solution can be made 2 times faster by running the innermost loop only till ```(R+C)//2 + 1``` as the bracket overhead above it can never be fulfilled. It really makes a difference particularly in this question.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        R, C = len(grid), len(grid[0])\\n        dp = [[[False for i in range(R+C+1)] for c in range(C+1)] for r in range(R+1)]\\n        dp[R][C-1][0] = True\\n        dp[R-1][C][0] = True\\n        for r in range(R-1, -1, -1):\\n            for c in range(C-1, -1, -1):\\n                for i in range(R+C):\\n                    nxt = [1,-1][grid[r][c] == \")\"]\\n                    dp[r][c][i] = dp[r+1][c][i+nxt] or dp[r][c+1][i+nxt]\\n        return dp[0][0][0]\\n                    \\n```\n```(R+C)//2 + 1```",
                "codeTag": "Java"
            },
            {
                "id": 2379590,
                "title": "javascript-beat-100",
                "content": "```\\nvar hasValidPath = function (grid) {\\n  let m = grid.length;\\n  let n = grid[0].length;\\n  let visited = {};\\n\\n  if ((m + n - 1) % 2 !== 0) return false;\\n  if (grid[0][0] !== \"(\" || grid[m - 1][n - 1] !== \")\") return false;\\n\\n  function helper(i, j, bal) {\\n    if (i >= m || j >= n) return false;\\n    if (bal > m + n - i - j) return false;\\n\\n    if (grid[i][j] === \"(\") bal++;\\n    else bal--;\\n    if (bal < 0) return false;\\n    if (i === m - 1 && j === n - 1) return bal === 0;\\n\\n    let key = `${i},${j},${bal}`;\\n    if (visited[key] !== undefined) return visited[key];\\n    return (visited[key] = helper(i + 1, j, bal) || helper(i, j + 1, bal));\\n  }\\n  return helper(0, 0, 0);\\n};",
                "solutionTags": [],
                "code": "```\\nvar hasValidPath = function (grid) {\\n  let m = grid.length;\\n  let n = grid[0].length;\\n  let visited = {};\\n\\n  if ((m + n - 1) % 2 !== 0) return false;\\n  if (grid[0][0] !== \"(\" || grid[m - 1][n - 1] !== \")\") return false;\\n\\n  function helper(i, j, bal) {\\n    if (i >= m || j >= n) return false;\\n    if (bal > m + n - i - j) return false;\\n\\n    if (grid[i][j] === \"(\") bal++;\\n    else bal--;\\n    if (bal < 0) return false;\\n    if (i === m - 1 && j === n - 1) return bal === 0;\\n\\n    let key = `${i},${j},${bal}`;\\n    if (visited[key] !== undefined) return visited[key];\\n    return (visited[key] = helper(i + 1, j, bal) || helper(i, j + 1, bal));\\n  }\\n  return helper(0, 0, 0);\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2377927,
                "title": "simple-c-solution-no-showoff",
                "content": "```\\nclass Solution {\\npublic:\\n    bool ans = false;\\n    int dp[100][100][200];\\n    bool solve(int i, int j, int balance, vector<vector<char>>& g) {\\n        \\n        if(balance < 0) return false;\\n\\n        if(i == g.size() - 1 && j == g[0].size() - 1)  return balance == 0;\\n        if(dp[i][j][balance] != -1) return dp[i][j][balance];\\n        \\n        \\n        \\n        bool ans = false;\\n        if(i + 1 < g.size()) {\\n            int newBalance = (g[i + 1][j] == \\'(\\' ? balance + 1 : balance - 1);\\n            if(newBalance >= 0) ans = ans or solve(i + 1, j, newBalance, g);\\n            if(ans) return dp[i][j][balance] = ans;\\n        } \\n        \\n        if(j + 1 < g[0].size()) {\\n            int newBalance = (g[i][j + 1] == \\'(\\' ? balance + 1 : balance - 1);\\n            if(newBalance >= 0) ans = ans or solve(i, j + 1, newBalance, g);\\n            if(ans) return dp[i][j][balance] = ans;\\n        }\\n        \\n        return dp[i][j][balance] = ans;\\n    }\\n    bool hasValidPath(vector<vector<char>>& g) {\\n        memset(dp, -1, sizeof(dp));\\n        int balance = g[0][0] == \\'(\\' ? 1 : -1;\\n        if(balance < 0) return false;\\n        return solve(0, 0, balance, g);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool ans = false;\\n    int dp[100][100][200];\\n    bool solve(int i, int j, int balance, vector<vector<char>>& g) {\\n        \\n        if(balance < 0) return false;\\n\\n        if(i == g.size() - 1 && j == g[0].size() - 1)  return balance == 0;\\n        if(dp[i][j][balance] != -1) return dp[i][j][balance];\\n        \\n        \\n        \\n        bool ans = false;\\n        if(i + 1 < g.size()) {\\n            int newBalance = (g[i + 1][j] == \\'(\\' ? balance + 1 : balance - 1);\\n            if(newBalance >= 0) ans = ans or solve(i + 1, j, newBalance, g);\\n            if(ans) return dp[i][j][balance] = ans;\\n        } \\n        \\n        if(j + 1 < g[0].size()) {\\n            int newBalance = (g[i][j + 1] == \\'(\\' ? balance + 1 : balance - 1);\\n            if(newBalance >= 0) ans = ans or solve(i, j + 1, newBalance, g);\\n            if(ans) return dp[i][j][balance] = ans;\\n        }\\n        \\n        return dp[i][j][balance] = ans;\\n    }\\n    bool hasValidPath(vector<vector<char>>& g) {\\n        memset(dp, -1, sizeof(dp));\\n        int balance = g[0][0] == \\'(\\' ? 1 : -1;\\n        if(balance < 0) return false;\\n        return solve(0, 0, balance, g);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300021,
                "title": "leetcode-the-hard-way-dfs-dp-with-memo",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star and watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way).\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n = grid.size(), m = grid[0].size(), mxN = 105;\\n        vector<vector<vector<int>>> dp(mxN, vector<vector<int>>(mxN, vector<int>(mxN * 2, -1)));\\n        function<bool(int, int, int)> dfs = [&](int i, int j, int k) -> bool {\\n            // out of bound - return false\\n            if (i == n || j == m) return false;\\n            // count the overall balance\\n            k += grid[i][j] == \\'(\\' ? 1 : -1;\\n            // negative balance - return false\\n            // e.g. ()) is invalid (k = -1)\\n            if (k < 0) return false;\\n            // if it reaches the target cell \\n            // and the balance is 0, e.g. ((()))\\n            // then return true \\n            if (i == n - 1 && j == m - 1 && k == 0) return true;\\n            // if the result is calculated before, return it directly\\n            if (dp[i][j][k] != -1) return dp[i][j][k];\\n            // otherwise, we either move right or move down\\n            return dp[i][j][k] = dfs(i + 1, j, k) || dfs(i, j + 1, k);\\n        };\\n        // starting from top left cell with balance = 0\\n        return dfs(0, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n = grid.size(), m = grid[0].size(), mxN = 105;\\n        vector<vector<vector<int>>> dp(mxN, vector<vector<int>>(mxN, vector<int>(mxN * 2, -1)));\\n        function<bool(int, int, int)> dfs = [&](int i, int j, int k) -> bool {\\n            // out of bound - return false\\n            if (i == n || j == m) return false;\\n            // count the overall balance\\n            k += grid[i][j] == \\'(\\' ? 1 : -1;\\n            // negative balance - return false\\n            // e.g. ()) is invalid (k = -1)\\n            if (k < 0) return false;\\n            // if it reaches the target cell \\n            // and the balance is 0, e.g. ((()))\\n            // then return true \\n            if (i == n - 1 && j == m - 1 && k == 0) return true;\\n            // if the result is calculated before, return it directly\\n            if (dp[i][j][k] != -1) return dp[i][j][k];\\n            // otherwise, we either move right or move down\\n            return dp[i][j][k] = dfs(i + 1, j, k) || dfs(i, j + 1, k);\\n        };\\n        // starting from top left cell with balance = 0\\n        return dfs(0, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2281138,
                "title": "c-solution",
                "content": "Approach:\\n```\\n#define vvvi vector<vector<vector<int>>>\\n#define vvc vector<vector<char>> \\n\\nclass Solution {\\npublic:\\n    \\n    bool f(int i, int j, int close, vvc &grid, vvvi &dp) {\\n        if(i < 0 || j < 0 || close < 0) return 0;\\n        \\n        // What did u encounter at current cell? \\n        // Rem: Traversing right to left in a potential Valid VPS\\n        if(grid[i][j] == \\')\\') close++;\\n        else close--;\\n        \\n        if(i == 0 and j == 0) {\\n            // Top-Left cell\\n            return (close == 0);\\n        }\\n        \\n        if(close < 0) return 0;\\n        \\n        if(dp[i][j][close] != -1) return dp[i][j][close];\\n        \\n        // Move up(i-1, j) or move left(i, j-1)\\n        // Now u should move up or left only when u are still satisfying vps\\n        \\n        return dp[i][j][close] = (f(i-1, j, close, grid, dp) || f(i, j-1, close, grid, dp));\\n    }\\n    \\n    \\n    // Idea is while moving left or right, go only where u can make a valid path\\n    // Check validity while choosing.\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vvvi dp(m, vector<vector<int>> (n, vector<int> (201, -1)));\\n        \\n        // I am starting from bottom-right cell meaning back of a possible vps\\n        // So, I should encounter closing brackets from end )\\n        \\n        return f(m-1, n-1, 0, grid, dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define vvvi vector<vector<vector<int>>>\\n#define vvc vector<vector<char>> \\n\\nclass Solution {\\npublic:\\n    \\n    bool f(int i, int j, int close, vvc &grid, vvvi &dp) {\\n        if(i < 0 || j < 0 || close < 0) return 0;\\n        \\n        // What did u encounter at current cell? \\n        // Rem: Traversing right to left in a potential Valid VPS\\n        if(grid[i][j] == \\')\\') close++;\\n        else close--;\\n        \\n        if(i == 0 and j == 0) {\\n            // Top-Left cell\\n            return (close == 0);\\n        }\\n        \\n        if(close < 0) return 0;\\n        \\n        if(dp[i][j][close] != -1) return dp[i][j][close];\\n        \\n        // Move up(i-1, j) or move left(i, j-1)\\n        // Now u should move up or left only when u are still satisfying vps\\n        \\n        return dp[i][j][close] = (f(i-1, j, close, grid, dp) || f(i, j-1, close, grid, dp));\\n    }\\n    \\n    \\n    // Idea is while moving left or right, go only where u can make a valid path\\n    // Check validity while choosing.\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vvvi dp(m, vector<vector<int>> (n, vector<int> (201, -1)));\\n        \\n        // I am starting from bottom-right cell meaning back of a possible vps\\n        // So, I should encounter closing brackets from end )\\n        \\n        return f(m-1, n-1, 0, grid, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2174607,
                "title": "why-bfs-wth-backtracking-got-tle-how-can-i-memoise",
                "content": "class Solution {\\npublic:\\n    int m,n;\\n    int dx[2]={1,0};\\n    int dy[2]={0,1};\\n    vector<vector<int>>vis;\\n    bool hasValidPath(vector<vector<char>>& grid) \\n    {\\n        m=grid.size();\\n        n=grid[0].size();\\n        vis.resize(m,vector<int>(n,false));\\n        if(grid[0][0]==\\')\\')\\n        {\\n            return false;\\n        }\\n        queue<pair<int,pair<int,int>>>q;\\n        q.push({0,{0,1}});\\n        vis[0][0]=true;\\n        while(!q.empty())\\n        {   \\n            auto it=q.front();\\n            q.pop();\\n            int i=it.first;\\n            int j=it.second.first;\\n            int cnt=it.second.second;\\n            if(i==m-1 && j==n-1 && cnt==0)\\n            {\\n                return true;\\n            }\\n            for(int k=0;k<2;k++)\\n            {\\n                int newi=i+dx[k];\\n                int newj=j+dy[k];\\n                if(newi>=0 && newi<m && newj>=0 && newj<n && grid[newi][newj]==\\')\\' && !vis[newi][newj])\\n                {\\n                    vis[newi][newj]=true;\\n                    q.push({newi,{newj,cnt-1}});\\n                    vis[newi][newj]=false;\\n                }\\n                else if(newi>=0 && newi<m && newj>=0 && newj<n && grid[newi][newj]==\\'(\\' && !vis[newi][newj])\\n                {\\n                    vis[newi][newj]=true;\\n                    q.push({newi,{newj,cnt+1}});\\n                    vis[newi][newj]=false;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int m,n;\\n    int dx[2]={1,0}",
                "codeTag": "Java"
            },
            {
                "id": 2169233,
                "title": "python-go-blazing-fast-dp-w-backtracking-o-mn-m-n",
                "content": "*Python* solution w/ bitset in 321ms beat 98% :)\\n\\n```python\\ndef hasValidPath(self, grid):\\n    dp = [[0] * 101 for _ in range(101)]\\n    dp[0][1] = 1\\n    for i, row in enumerate(grid, 1):                               # O(M)\\n        for j, c in enumerate(row, 1):                              # O(N)\\n            dp[i][j] = dp[i][j - 1] | dp[i - 1][j]                  # O(M+N) bitset union\\n            dp[i][j] = dp[i][j] << 1 if c == \"(\" else dp[i][j] >> 1 # O(M+N) bitset shift\\n    return dp[i][j] & 1\\n```\\n\\n*Go* solution w/ bitset in 3ms beat 100% :)\\n\\n```go\\ntype bitset [2]uint64\\n\\nfunc (x *bitset) set0()        { x[0] = 1 }\\nfunc (x *bitset) get0() uint64 { return x[0] & 1 }\\nfunc (x *bitset) union(y bitset) bitset {\\n\\tvar z bitset\\n\\tz[0] = x[0] | y[0]\\n\\tz[1] = x[1] | y[1]\\n\\treturn z\\n}\\nfunc (x *bitset) lsh1() {\\n\\ty := x[0]\\n\\ty >>= 63\\n\\tx[0] <<= 1\\n\\tx[1] <<= 1\\n\\tx[1] |= y\\n}\\nfunc (x *bitset) rsh1() {\\n\\ty := x[1]\\n\\ty <<= 63\\n\\tx[1] >>= 1\\n\\tx[0] >>= 1\\n\\tx[0] |= y\\n}\\n\\nfunc hasValidPath(grid [][]byte) bool {\\n\\tvar (\\n\\t\\tm  = len(grid)\\n\\t\\tn  = len(grid[0])\\n\\t\\tdp [101][101]bitset\\n\\t)\\n\\tdp[0][1].set0()\\n\\tfor i, x := 0, 1; i < m; i, x = i+1, x+1 {\\n\\t\\tfor j, y := 0, 1; j < n; j, y = j+1, y+1 {\\n\\t\\t\\tdp[x][y] = dp[i][y].union(dp[x][j])\\n\\t\\t\\tif grid[i][j] == \\'(\\' {\\n\\t\\t\\t\\tdp[x][y].lsh1()\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdp[x][y].rsh1()\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[m][n].get0() == 1\\n}\\n```\\n\\n*Go* solution w/ boolean array\\n\\n```go\\nfunc hasValidPath(grid [][]byte) bool {\\n\\tvar (\\n\\t\\tm = len(grid)\\n\\t\\tn = len(grid[0])\\n\\t\\tl = m + n\\n\\t)\\n\\tdp := make([][][]bool, m+1)\\n\\tfor i := 0; i <= m; i++ {\\n\\t\\tdp[i] = make([][]bool, n+1)\\n\\t\\tfor j := 0; j <= n; j++ {\\n\\t\\t\\tdp[i][j] = make([]bool, l+1)\\n\\t\\t}\\n\\t}\\n\\tdp[0][1][0] = true\\n\\tfor i, x := 0, 1; i < m; i, x = i+1, x+1 {\\n\\t\\tfor j, y := 0, 1; j < n; j, y = j+1, y+1 {\\n\\t\\t\\tfor k := 0; k <= l; k++ {\\n\\t\\t\\t\\tdp[x][y][k] = dp[i][y][k] || dp[x][j][k]\\n\\t\\t\\t}\\n\\t\\t\\tif grid[i][j] == \\'(\\' {\\n\\t\\t\\t\\tfor k := l; k >= 1; k-- {\\n\\t\\t\\t\\t\\tdp[x][y][k] = dp[x][y][k-1]\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdp[x][y][0] = false\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor k := 0; k < l; k++ {\\n\\t\\t\\t\\t\\tdp[x][y][k] = dp[x][y][k+1]\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[m][n][0]\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\ndef hasValidPath(self, grid):\\n    dp = [[0] * 101 for _ in range(101)]\\n    dp[0][1] = 1\\n    for i, row in enumerate(grid, 1):                               # O(M)\\n        for j, c in enumerate(row, 1):                              # O(N)\\n            dp[i][j] = dp[i][j - 1] | dp[i - 1][j]                  # O(M+N) bitset union\\n            dp[i][j] = dp[i][j] << 1 if c == \"(\" else dp[i][j] >> 1 # O(M+N) bitset shift\\n    return dp[i][j] & 1\\n```\n```go\\ntype bitset [2]uint64\\n\\nfunc (x *bitset) set0()        { x[0] = 1 }\\nfunc (x *bitset) get0() uint64 { return x[0] & 1 }\\nfunc (x *bitset) union(y bitset) bitset {\\n\\tvar z bitset\\n\\tz[0] = x[0] | y[0]\\n\\tz[1] = x[1] | y[1]\\n\\treturn z\\n}\\nfunc (x *bitset) lsh1() {\\n\\ty := x[0]\\n\\ty >>= 63\\n\\tx[0] <<= 1\\n\\tx[1] <<= 1\\n\\tx[1] |= y\\n}\\nfunc (x *bitset) rsh1() {\\n\\ty := x[1]\\n\\ty <<= 63\\n\\tx[1] >>= 1\\n\\tx[0] >>= 1\\n\\tx[0] |= y\\n}\\n\\nfunc hasValidPath(grid [][]byte) bool {\\n\\tvar (\\n\\t\\tm  = len(grid)\\n\\t\\tn  = len(grid[0])\\n\\t\\tdp [101][101]bitset\\n\\t)\\n\\tdp[0][1].set0()\\n\\tfor i, x := 0, 1; i < m; i, x = i+1, x+1 {\\n\\t\\tfor j, y := 0, 1; j < n; j, y = j+1, y+1 {\\n\\t\\t\\tdp[x][y] = dp[i][y].union(dp[x][j])\\n\\t\\t\\tif grid[i][j] == \\'(\\' {\\n\\t\\t\\t\\tdp[x][y].lsh1()\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdp[x][y].rsh1()\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[m][n].get0() == 1\\n}\\n```\n```go\\nfunc hasValidPath(grid [][]byte) bool {\\n\\tvar (\\n\\t\\tm = len(grid)\\n\\t\\tn = len(grid[0])\\n\\t\\tl = m + n\\n\\t)\\n\\tdp := make([][][]bool, m+1)\\n\\tfor i := 0; i <= m; i++ {\\n\\t\\tdp[i] = make([][]bool, n+1)\\n\\t\\tfor j := 0; j <= n; j++ {\\n\\t\\t\\tdp[i][j] = make([]bool, l+1)\\n\\t\\t}\\n\\t}\\n\\tdp[0][1][0] = true\\n\\tfor i, x := 0, 1; i < m; i, x = i+1, x+1 {\\n\\t\\tfor j, y := 0, 1; j < n; j, y = j+1, y+1 {\\n\\t\\t\\tfor k := 0; k <= l; k++ {\\n\\t\\t\\t\\tdp[x][y][k] = dp[i][y][k] || dp[x][j][k]\\n\\t\\t\\t}\\n\\t\\t\\tif grid[i][j] == \\'(\\' {\\n\\t\\t\\t\\tfor k := l; k >= 1; k-- {\\n\\t\\t\\t\\t\\tdp[x][y][k] = dp[x][y][k-1]\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdp[x][y][0] = false\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor k := 0; k < l; k++ {\\n\\t\\t\\t\\t\\tdp[x][y][k] = dp[x][y][k+1]\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[m][n][0]\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2164785,
                "title": "python-lru-cache",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, x: List[List[str]]) -> bool:\\n        m,n=len(x),len(x[0])    \\n        @lru_cache(None)\\n        def f(i,j,c):\\n            if i==m-1 and j==n-1:return not c\\n            ans=False\\n            for d,e in ((i+1,j),(i,j+1)):\\n                if d<m and e<n:\\n                    if x[d][e]==\\'(\\':\\n                        ans=ans or f(d,e,c+1)\\n                    else:\\n                        if c:\\n                            ans=ans or f(d,e,c-1)\\n            return ans\\n        return False if x[0][0]==\\')\\' else f(0,0,1) \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, x: List[List[str]]) -> bool:\\n        m,n=len(x),len(x[0])    \\n        @lru_cache(None)\\n        def f(i,j,c):\\n            if i==m-1 and j==n-1:return not c\\n            ans=False\\n            for d,e in ((i+1,j),(i,j+1)):\\n                if d<m and e<n:\\n                    if x[d][e]==\\'(\\':\\n                        ans=ans or f(d,e,c+1)\\n                    else:\\n                        if c:\\n                            ans=ans or f(d,e,c-1)\\n            return ans\\n        return False if x[0][0]==\\')\\' else f(0,0,1) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2159103,
                "title": "python-solution-easy-to-understand-caching",
                "content": "The way this solution works is\\n1. There is a stack variable which acts as a Counter, so if the value of stack is 0 it means the stack is empty. On \"(\" we increment the value (append) of stack and on \")\" we decrement the value (pop) from stack.\\n2. lru_cache is used to avoid the calculation of same values again (Memoization). \\n```\\nn,m=len(grid),len(grid[0])\\nstack=0\\n@lru_cache(None)\\ndef recursion(row,col,stack):\\n\\t#Checking the indexes are within the range\\n\\tif row<0 or row>=n or col<0 or col>=m:\\n\\t\\treturn False\\n\\n\\t#Check that on reaching the last block value of stack is 1 and the parenthesis is closing\\t\\n\\tif row==n-1 and col==m-1:\\n\\t\\tif stack==1 and grid[row][col]==\")\":\\n\\t\\t\\treturn True\\n\\t\\treturn False\\n\\n\\t#Updating the stack based on the input\\n\\tif grid[row][col]==\"(\":\\n\\t\\tstack+=1\\n\\telse:\\n\\t\\tif stack:\\n\\t\\t\\tstack-=1\\n\\t\\telse:\\n\\t\\t\\treturn False\\n\\n\\tfor index in [[row+1,col],[row,col+1]]:\\n\\t#if a valid path is found we don\\'t calculate for other paths and return\\n\\t\\tif recursion(index[0],index[1],stack):\\n\\t\\t\\treturn True\\n\\treturn False\\nreturn recursion(0,0,stack)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "The way this solution works is\\n1. There is a stack variable which acts as a Counter, so if the value of stack is 0 it means the stack is empty. On \"(\" we increment the value (append) of stack and on \")\" we decrement the value (pop) from stack.\\n2. lru_cache is used to avoid the calculation of same values again (Memoization). \\n```\\nn,m=len(grid),len(grid[0])\\nstack=0\\n@lru_cache(None)\\ndef recursion(row,col,stack):\\n\\t#Checking the indexes are within the range\\n\\tif row<0 or row>=n or col<0 or col>=m:\\n\\t\\treturn False\\n\\n\\t#Check that on reaching the last block value of stack is 1 and the parenthesis is closing\\t\\n\\tif row==n-1 and col==m-1:\\n\\t\\tif stack==1 and grid[row][col]==\")\":\\n\\t\\t\\treturn True\\n\\t\\treturn False\\n\\n\\t#Updating the stack based on the input\\n\\tif grid[row][col]==\"(\":\\n\\t\\tstack+=1\\n\\telse:\\n\\t\\tif stack:\\n\\t\\t\\tstack-=1\\n\\t\\telse:\\n\\t\\t\\treturn False\\n\\n\\tfor index in [[row+1,col],[row,col+1]]:\\n\\t#if a valid path is found we don\\'t calculate for other paths and return\\n\\t\\tif recursion(index[0],index[1],stack):\\n\\t\\t\\treturn True\\n\\treturn False\\nreturn recursion(0,0,stack)",
                "codeTag": "Python3"
            },
            {
                "id": 2130285,
                "title": "c-simple-dfs",
                "content": "```\\nclass Solution {\\n    int dp[100][100][200];\\n    bool dfs(vector<vector<char>>& g, int x, int y, int balance) {\\n        if (x == g.size() || y == g[0].size())\\n            return false;\\n        if (g[x][y] == \\'(\\')\\n            balance++;\\n        else\\n            balance--;\\n        if (balance < 0)\\n            return false;\\n        if (x == g.size() - 1 && y == g[0].size() - 1)\\n            return balance == 0;\\n        if (dp[x][y][balance] == -1)\\n            dp[x][y][balance] = dfs(g, x + 1, y, balance) || dfs(g, x, y + 1, balance);\\n        return dp[x][y][balance];\\n    }\\npublic:\\n    bool hasValidPath(vector<vector<char>>& g) {\\n        memset(dp, -1, sizeof(dp));\\n        return dfs(g, 0, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int dp[100][100][200];\\n    bool dfs(vector<vector<char>>& g, int x, int y, int balance) {\\n        if (x == g.size() || y == g[0].size())\\n            return false;\\n        if (g[x][y] == \\'(\\')\\n            balance++;\\n        else\\n            balance--;\\n        if (balance < 0)\\n            return false;\\n        if (x == g.size() - 1 && y == g[0].size() - 1)\\n            return balance == 0;\\n        if (dp[x][y][balance] == -1)\\n            dp[x][y][balance] = dfs(g, x + 1, y, balance) || dfs(g, x, y + 1, balance);\\n        return dp[x][y][balance];\\n    }\\npublic:\\n    bool hasValidPath(vector<vector<char>>& g) {\\n        memset(dp, -1, sizeof(dp));\\n        return dfs(g, 0, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2119954,
                "title": "java-recursion-with-memorization",
                "content": "It\\'s more like a top-down DP.\\n\\nI find that TLE is very strict. If I use set or map to memorize it will get TLE while 3D array pass.\\n\\n```\\n    public boolean hasValidPath(char[][] grid) {\\n        if (null==grid) {\\n            return false;\\n        }\\n        int rc=grid.length;\\n        int cc=grid[0].length;\\n        if (grid[0][0]!=\\'(\\'||grid[rc-1][cc-1]!=\\')\\') {\\n            return false;\\n        }\\n        int[][][] dp=new int[101][101][202];\\n        for (int i=0;i<101;i++) {\\n            for (int j=0;j<101;j++) {\\n                Arrays.fill(dp[i][j],-1);\\n            }\\n        }\\n        int b=helper(1,0,0,rc,cc,grid,dp);\\n        return b==1;\\n    }\\n\\n    private int helper(int count, int ri, int ci, int rc, int cc, char[][] grid, int[][][] dp) {\\n        if (count<0) {\\n            return 0;\\n        }\\n        if (-1!=dp[ri][ci][count]) {\\n            return dp[ri][ci][count];\\n        }\\n        if (count==0&&ri==rc-1&&ci==cc-1) {\\n            return 1;\\n        }\\n        int ret=-1;\\n        if (ri<rc-1) {\\n            if (grid[ri+1][ci]==\\'(\\') {\\n                ret=helper(count+1,ri+1,ci,rc,cc,grid,dp);\\n            }\\n            if (ret!=1&&grid[ri+1][ci]==\\')\\') {\\n                ret=helper(count-1,ri+1,ci,rc,cc,grid,dp);\\n            }\\n        }\\n        if (ret!=1&&ci<cc-1) {\\n            if (grid[ri][ci+1]==\\'(\\') {\\n                ret=helper(count+1,ri,ci+1,rc,cc,grid,dp);\\n            }\\n            if (ret!=1&&grid[ri][ci+1]==\\')\\') {\\n                ret=helper(count-1,ri,ci+1,rc,cc,grid,dp);\\n            }\\n        }\\n        if (ret!=1) {\\n            dp[ri][ci][count]=0;\\n        }\\n        return ret;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean hasValidPath(char[][] grid) {\\n        if (null==grid) {\\n            return false;\\n        }\\n        int rc=grid.length;\\n        int cc=grid[0].length;\\n        if (grid[0][0]!=\\'(\\'||grid[rc-1][cc-1]!=\\')\\') {\\n            return false;\\n        }\\n        int[][][] dp=new int[101][101][202];\\n        for (int i=0;i<101;i++) {\\n            for (int j=0;j<101;j++) {\\n                Arrays.fill(dp[i][j],-1);\\n            }\\n        }\\n        int b=helper(1,0,0,rc,cc,grid,dp);\\n        return b==1;\\n    }\\n\\n    private int helper(int count, int ri, int ci, int rc, int cc, char[][] grid, int[][][] dp) {\\n        if (count<0) {\\n            return 0;\\n        }\\n        if (-1!=dp[ri][ci][count]) {\\n            return dp[ri][ci][count];\\n        }\\n        if (count==0&&ri==rc-1&&ci==cc-1) {\\n            return 1;\\n        }\\n        int ret=-1;\\n        if (ri<rc-1) {\\n            if (grid[ri+1][ci]==\\'(\\') {\\n                ret=helper(count+1,ri+1,ci,rc,cc,grid,dp);\\n            }\\n            if (ret!=1&&grid[ri+1][ci]==\\')\\') {\\n                ret=helper(count-1,ri+1,ci,rc,cc,grid,dp);\\n            }\\n        }\\n        if (ret!=1&&ci<cc-1) {\\n            if (grid[ri][ci+1]==\\'(\\') {\\n                ret=helper(count+1,ri,ci+1,rc,cc,grid,dp);\\n            }\\n            if (ret!=1&&grid[ri][ci+1]==\\')\\') {\\n                ret=helper(count-1,ri,ci+1,rc,cc,grid,dp);\\n            }\\n        }\\n        if (ret!=1) {\\n            dp[ri][ci][count]=0;\\n        }\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2119317,
                "title": "c-beginners-dp-dfs-easy-understanding",
                "content": "TL DR : **if at any point open < 0 then the path is not balanced**\\n\\n**Q ) int dp[101][101][201] ? Why 201 ?**\\nA ) As the longest possible path from top left to bottom right is of (m+n-1) length.\\n(The path only ever moves down or right.)\\n\\nNow, we have to go from the top left to bottom right by moving either down or right, the first point we get is to have a valid parantheses, the count of open = close, so if at any point the count of open < 0, then the path is not balanced and we return false.\\n\\nHere the changing variables are i, j ( curr grid pos ) and the count of open and close brackets, it\\'ll be much complex to consider anothet variable for closed brackets count so we add +1 to open when we see a \\'( \\' & subtract -1 when we see a \\')\\'.\\n\\nfrom each position we can go either to the down (i+1, j) or right ( i, j+1), so we make 2 calls and we return true if either one of them returns true and assign it to dp[i][j][open].\\n\\nIf we somehow reach the bottom left, then we return true only when the count of open == 0 else we return false.\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[100][100][201];\\n    bool helper(vector<vector<char>>& grid, int i, int j, int open){\\n        if(i >= grid.size() || j >= grid[0].size()){\\n            return false;\\n        }\\n        \\n        if(grid[i][j] == \\'(\\'){\\n            open++;\\n        }\\n        else{\\n            open--;\\n        }\\n        if(open < 0){\\n            return false;\\n        }\\n        if(dp[i][j][open] != -1){\\n            return dp[i][j][open];\\n        }\\n        if(i == grid.size() - 1 && j == grid[0].size() - 1){\\n            if(open == 0){\\n                return true;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        int next = helper(grid, i+1, j, open) || helper(grid, i, j+1, open);\\n        return dp[i][j][open] = next;\\n    }\\n    \\n    \\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        if(grid[0][0] == \\')\\'){\\n            return false;\\n        }\\n        memset(dp, -1, sizeof(dp));\\n        bool ans = helper(grid, 0, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[100][100][201];\\n    bool helper(vector<vector<char>>& grid, int i, int j, int open){\\n        if(i >= grid.size() || j >= grid[0].size()){\\n            return false;\\n        }\\n        \\n        if(grid[i][j] == \\'(\\'){\\n            open++;\\n        }\\n        else{\\n            open--;\\n        }\\n        if(open < 0){\\n            return false;\\n        }\\n        if(dp[i][j][open] != -1){\\n            return dp[i][j][open];\\n        }\\n        if(i == grid.size() - 1 && j == grid[0].size() - 1){\\n            if(open == 0){\\n                return true;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        int next = helper(grid, i+1, j, open) || helper(grid, i, j+1, open);\\n        return dp[i][j][open] = next;\\n    }\\n    \\n    \\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        if(grid[0][0] == \\')\\'){\\n            return false;\\n        }\\n        memset(dp, -1, sizeof(dp));\\n        bool ans = helper(grid, 0, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2068029,
                "title": "python-dp-easy-top-down-recursive",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        @cache\\n        def dfs(i, j, trace):\\n            nonlocal m, n\\n            trace += (1 if grid[i][j] == \\'(\\' else -1)\\n            if trace < 0:\\n                return False\\n            if i == m-1 and j == n-1 and trace == 0:\\n                return True\\n            right = down = False\\n            if i + 1 < m:\\n                right = dfs(i+1, j, trace)\\n            if j + 1 < n:\\n                down = dfs(i, j+1, trace)\\n            return right or down\\n        \\n        return dfs(0,0,0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        @cache\\n        def dfs(i, j, trace):\\n            nonlocal m, n\\n            trace += (1 if grid[i][j] == \\'(\\' else -1)\\n            if trace < 0:\\n                return False\\n            if i == m-1 and j == n-1 and trace == 0:\\n                return True\\n            right = down = False\\n            if i + 1 < m:\\n                right = dfs(i+1, j, trace)\\n            if j + 1 < n:\\n                down = dfs(i, j+1, trace)\\n            return right or down\\n        \\n        return dfs(0,0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065236,
                "title": "c-dp-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int r,c;\\n    int dp[101][101][205];\\n    bool solve(vector<vector<char>>& g,int i,int j,int op){\\n        if(i<0 || i>=r || j<0 || j>=c) return false;\\n        if(g[i][j]==\\'(\\')op++;\\n        else op--;        \\n        if(op<0) return false;\\n        if(dp[i][j][op]!=-1) return  dp[i][j][op]==1;\\n        if(i==r-1 && j==c-1 && op==0){\\n           dp[i][j][op]=1; \\n           return true; \\n        }  \\n        return dp[i][j][op]=solve(g,i+1,j,op)||solve(g,i,j+1,op);        \\n    }\\n    bool hasValidPath(vector<vector<char>>& g) {\\n        r=g.size(),c=g[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        if(g[0][0]==\\')\\' || g[r-1][c-1]==\\'(\\') return false;\\n        solve(g,0,0,0);\\n        return dp[r-1][c-1][0]==1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int r,c;\\n    int dp[101][101][205];\\n    bool solve(vector<vector<char>>& g,int i,int j,int op){\\n        if(i<0 || i>=r || j<0 || j>=c) return false;\\n        if(g[i][j]==\\'(\\')op++;\\n        else op--;        \\n        if(op<0) return false;\\n        if(dp[i][j][op]!=-1) return  dp[i][j][op]==1;\\n        if(i==r-1 && j==c-1 && op==0){\\n           dp[i][j][op]=1; \\n           return true; \\n        }  \\n        return dp[i][j][op]=solve(g,i+1,j,op)||solve(g,i,j+1,op);        \\n    }\\n    bool hasValidPath(vector<vector<char>>& g) {\\n        r=g.size(),c=g[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        if(g[0][0]==\\')\\' || g[r-1][c-1]==\\'(\\') return false;\\n        solve(g,0,0,0);\\n        return dp[r-1][c-1][0]==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046814,
                "title": "java-dfs-dp",
                "content": "\\n```\\nclass Solution {\\n    char[][] grid;\\n    int m, n;\\n    public static final char LFTPAR = \\'(\\';\\n    public static final char RGTPAR = \\')\\';\\n    public boolean hasValidPath(char[][] grid) {\\n        this.grid = grid;\\n        this.m = grid.length;\\n        this.n = grid[0].length;\\n        \\n        Boolean[][][] dp = new Boolean[m][n][m+n+1];\\n        \\n        if (grid[0][0] == RGTPAR)\\n            return false;\\n        if (grid[m-1][n-1] == LFTPAR)\\n            return false;\\n        \\n        if ( (m + n) % 2 == 0)\\n            return false;\\n        \\n        return dfs(0, 0, 0, 0, dp);\\n    }\\n    private boolean dfs(int u, int v, int open, int close,  Boolean[][][] dp){\\n        if (grid[u][v] == LFTPAR){\\n            open++;\\n        } else {\\n            close++;\\n        }\\n        if (u == m-1 && v == n -1){\\n            return open == close;\\n        }\\n        if (open < close){\\n            return false;\\n        }\\n        if (dp[u][v][open-close] != null){\\n            return dp[u][v][open - close];\\n        }\\n        if (u == m - 1){\\n            if (grid[u][v] == LFTPAR){\\n                return dp[u][v][open-close] = dfs(u, v+1, open, close, dp);\\n            } else {\\n                return dp[u][v][open-close] = dfs(u, v+1, open, close, dp);\\n            }\\n        }\\n        if (v == n-1){\\n            if (grid[u][v] == LFTPAR){\\n                return dfs(u+1, v, open, close, dp);\\n            } else {\\n                return dfs(u+1, v, open, close, dp);\\n            }\\n        }\\n            \\n        boolean rslt = false;\\n        if (grid[u][v] == LFTPAR){\\n            rslt = dfs(u+1, v, open, close, dp) || \\n                    dfs(u, v+1, open, close, dp);\\n        } else {\\n            rslt = dfs(u, v+1, open, close, dp) ||\\n                    dfs(u + 1, v, open, close, dp);\\n        }\\n        dp[u][v][open-close] = rslt;\\n        return rslt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    char[][] grid;\\n    int m, n;\\n    public static final char LFTPAR = \\'(\\';\\n    public static final char RGTPAR = \\')\\';\\n    public boolean hasValidPath(char[][] grid) {\\n        this.grid = grid;\\n        this.m = grid.length;\\n        this.n = grid[0].length;\\n        \\n        Boolean[][][] dp = new Boolean[m][n][m+n+1];\\n        \\n        if (grid[0][0] == RGTPAR)\\n            return false;\\n        if (grid[m-1][n-1] == LFTPAR)\\n            return false;\\n        \\n        if ( (m + n) % 2 == 0)\\n            return false;\\n        \\n        return dfs(0, 0, 0, 0, dp);\\n    }\\n    private boolean dfs(int u, int v, int open, int close,  Boolean[][][] dp){\\n        if (grid[u][v] == LFTPAR){\\n            open++;\\n        } else {\\n            close++;\\n        }\\n        if (u == m-1 && v == n -1){\\n            return open == close;\\n        }\\n        if (open < close){\\n            return false;\\n        }\\n        if (dp[u][v][open-close] != null){\\n            return dp[u][v][open - close];\\n        }\\n        if (u == m - 1){\\n            if (grid[u][v] == LFTPAR){\\n                return dp[u][v][open-close] = dfs(u, v+1, open, close, dp);\\n            } else {\\n                return dp[u][v][open-close] = dfs(u, v+1, open, close, dp);\\n            }\\n        }\\n        if (v == n-1){\\n            if (grid[u][v] == LFTPAR){\\n                return dfs(u+1, v, open, close, dp);\\n            } else {\\n                return dfs(u+1, v, open, close, dp);\\n            }\\n        }\\n            \\n        boolean rslt = false;\\n        if (grid[u][v] == LFTPAR){\\n            rslt = dfs(u+1, v, open, close, dp) || \\n                    dfs(u, v+1, open, close, dp);\\n        } else {\\n            rslt = dfs(u, v+1, open, close, dp) ||\\n                    dfs(u + 1, v, open, close, dp);\\n        }\\n        dp[u][v][open-close] = rslt;\\n        return rslt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046560,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef hasValidPath(self, grid: List[List[str]]) -> bool:\\n\\t\\t\\tm = len(grid)\\n\\t\\t\\tn = len(grid[0])\\n\\t\\t\\t@cache\\n\\t\\t\\tdef dfs(i, j, cnt):\\n\\t\\t\\t\\tif i < 0 or i > m - 1 or j < 0 or j > n - 1 or grid[i][j] == \"#\":\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tif grid[i][j] == \"(\":\\n\\t\\t\\t\\t\\tcnt += 1\\n\\t\\t\\t\\tif grid[i][j] == \")\":\\n\\t\\t\\t\\t\\tcnt -= 1\\n\\t\\t\\t\\tif cnt < 0:\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tif i == m - 1 and j == n - 1 and cnt == 0:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tcur = grid[i][j]\\n\\t\\t\\t\\tgrid[i][j] = \"#\"\\n\\t\\t\\t\\tif dfs(i + 1, j, cnt) or dfs(i, j + 1, cnt):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tgrid[i][j] = cur\\n\\t\\t\\treturn dfs(0, 0, 0)",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef hasValidPath(self, grid: List[List[str]]) -> bool:\\n\\t\\t\\tm = len(grid)\\n\\t\\t\\tn = len(grid[0])\\n\\t\\t\\t@cache\\n\\t\\t\\tdef dfs(i, j, cnt):\\n\\t\\t\\t\\tif i < 0 or i > m - 1 or j < 0 or j > n - 1 or grid[i][j] == \"#\":\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tif grid[i][j] == \"(\":\\n\\t\\t\\t\\t\\tcnt += 1\\n\\t\\t\\t\\tif grid[i][j] == \")\":\\n\\t\\t\\t\\t\\tcnt -= 1\\n\\t\\t\\t\\tif cnt < 0:\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tif i == m - 1 and j == n - 1 and cnt == 0:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tcur = grid[i][j]\\n\\t\\t\\t\\tgrid[i][j] = \"#\"\\n\\t\\t\\t\\tif dfs(i + 1, j, cnt) or dfs(i, j + 1, cnt):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tgrid[i][j] = cur\\n\\t\\t\\treturn dfs(0, 0, 0)",
                "codeTag": "Java"
            },
            {
                "id": 2046276,
                "title": "c-dp-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) \\n    {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        bool f[m][n][101];\\n        for(int i=0;i<m;i++)for(int j=0;j<n;j++)for(int k=0;k<=100;k++)f[i][j][k]=false;\\n        if(grid[0][0]==\\')\\')return false;\\n        f[0][0][1]=true;\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                for(int k=0;k<=100;k++)\\n                {\\n                    if(grid[i][j]==\\'(\\')\\n                    {\\n                        if(i-1>=0&&f[i-1][j][k]&&k+1<=100)f[i][j][k+1]=true;\\n                        if(j-1>=0&&f[i][j-1][k]&&k+1<=100)f[i][j][k+1]=true;\\n                    }else\\n                    {\\n                        if(i-1>=0&&f[i-1][j][k]&&k-1>=0)f[i][j][k-1]=true;\\n                        if(j-1>=0&&f[i][j-1][k]&&k-1>=0)f[i][j][k-1]=true;\\n                    }\\n                }\\n        return f[m-1][n-1][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) \\n    {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        bool f[m][n][101];\\n        for(int i=0;i<m;i++)for(int j=0;j<n;j++)for(int k=0;k<=100;k++)f[i][j][k]=false;\\n        if(grid[0][0]==\\')\\')return false;\\n        f[0][0][1]=true;\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                for(int k=0;k<=100;k++)\\n                {\\n                    if(grid[i][j]==\\'(\\')\\n                    {\\n                        if(i-1>=0&&f[i-1][j][k]&&k+1<=100)f[i][j][k+1]=true;\\n                        if(j-1>=0&&f[i][j-1][k]&&k+1<=100)f[i][j][k+1]=true;\\n                    }else\\n                    {\\n                        if(i-1>=0&&f[i-1][j][k]&&k-1>=0)f[i][j][k-1]=true;\\n                        if(j-1>=0&&f[i][j-1][k]&&k-1>=0)f[i][j][k-1]=true;\\n                    }\\n                }\\n        return f[m-1][n-1][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039382,
                "title": "java-dp-bottom-up-approach",
                "content": "\\n```\\nclass Solution {\\n    \\n     Boolean dp[][][];\\n     public boolean hasValidPath(char[][] grid) {\\n        if(grid[0][0] == \\')\\' || grid[grid.length-1][grid[0].length -1] == \\'(\\') return false;\\n        dp = new Boolean[grid.length][grid[0].length][101];\\n\\n        int rows = grid.length;\\n        int col = grid[0].length;\\n\\n        Arrays.fill(dp[rows - 1][col - 1],false);\\n        dp[rows - 1][col -1][0] = true;\\n\\n        for(int i = rows - 1;i>=0;i--){\\n            for(int j = col - 1;j>=0;j--){\\n                if(i == rows - 1 && j == col -1) continue;\\n                if(j + 1 < col){\\n                    for(int k = 0; k <= 100; k++){\\n                        if(dp[i][j+1][k]!=null && dp[i][j+1][k]){\\n                            if(grid[i][j+1]==\\'(\\' ){\\n                                if(k-1>=0) {\\n                                    dp[i][j][k - 1] = true;\\n                                }\\n                            }else {\\n                                if(k+1<=100) {\\n                                dp[i][j][k+1] = true;\\n                                }\\n                            }\\n                        }\\n\\n                    }\\n                }\\n                if(i+1 < rows){\\n                    for(int k = 0; k <= 100; k++){\\n                        if(dp[i+1][j][k]!=null && dp[i+1][j][k]){\\n                            if(grid[i+1][j]==\\'(\\' ){\\n                                if(k-1>=0) {\\n                                    dp[i][j][k - 1] = true;\\n                                }\\n                            }else {\\n                                if(k+1<=100) {\\n                                dp[i][j][k+1] = true;\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n\\n            }\\n        }\\n\\n        return dp[0][0][1]!=null && dp[0][0][1];\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n     Boolean dp[][][];\\n     public boolean hasValidPath(char[][] grid) {\\n        if(grid[0][0] == \\')\\' || grid[grid.length-1][grid[0].length -1] == \\'(\\') return false;\\n        dp = new Boolean[grid.length][grid[0].length][101];\\n\\n        int rows = grid.length;\\n        int col = grid[0].length;\\n\\n        Arrays.fill(dp[rows - 1][col - 1],false);\\n        dp[rows - 1][col -1][0] = true;\\n\\n        for(int i = rows - 1;i>=0;i--){\\n            for(int j = col - 1;j>=0;j--){\\n                if(i == rows - 1 && j == col -1) continue;\\n                if(j + 1 < col){\\n                    for(int k = 0; k <= 100; k++){\\n                        if(dp[i][j+1][k]!=null && dp[i][j+1][k]){\\n                            if(grid[i][j+1]==\\'(\\' ){\\n                                if(k-1>=0) {\\n                                    dp[i][j][k - 1] = true;\\n                                }\\n                            }else {\\n                                if(k+1<=100) {\\n                                dp[i][j][k+1] = true;\\n                                }\\n                            }\\n                        }\\n\\n                    }\\n                }\\n                if(i+1 < rows){\\n                    for(int k = 0; k <= 100; k++){\\n                        if(dp[i+1][j][k]!=null && dp[i+1][j][k]){\\n                            if(grid[i+1][j]==\\'(\\' ){\\n                                if(k-1>=0) {\\n                                    dp[i][j][k - 1] = true;\\n                                }\\n                            }else {\\n                                if(k+1<=100) {\\n                                dp[i][j][k+1] = true;\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n\\n            }\\n        }\\n\\n        return dp[0][0][1]!=null && dp[0][0][1];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039247,
                "title": "dfs-memorize",
                "content": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        Boolean[][][] memory = new Boolean[m][n][(m+n)/2 + 1];\\n        return dfs(0, 0, 0, grid, memory);\\n    }\\n    \\n    private boolean dfs(int leftCnt, int x, int y, char[][] grid, Boolean[][][] memory) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        // boundary check\\n        if(x < 0 || y < 0 || x >= m || y >= n) {\\n            return false;\\n        }\\n        \\n        if(grid[x][y] == \\'(\\') {\\n            leftCnt++;\\n        } else if (grid[x][y] == \\')\\') {\\n            leftCnt--;\\n        }\\n        \\n            \\n        if(leftCnt < 0 || leftCnt > (m+n)/2) {\\n            // memory[x][y][leftCnt] = false;\\n            return false; \\n        }\\n        \\n       if(memory[x][y][leftCnt] != null) return memory[x][y][leftCnt]; \\n        \\n        if(x == m -1 && y == n -1 && leftCnt == 0) {\\n            memory[x][y][leftCnt]  = true;\\n            return true;\\n        }\\n        \\n        boolean valid =  dfs(leftCnt, x + 1, y, grid, memory) || dfs(leftCnt, x, y + 1, grid, memory);\\n        memory[x][y][leftCnt]  = valid;\\n        return valid;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        Boolean[][][] memory = new Boolean[m][n][(m+n)/2 + 1];\\n        return dfs(0, 0, 0, grid, memory);\\n    }\\n    \\n    private boolean dfs(int leftCnt, int x, int y, char[][] grid, Boolean[][][] memory) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        // boundary check\\n        if(x < 0 || y < 0 || x >= m || y >= n) {\\n            return false;\\n        }\\n        \\n        if(grid[x][y] == \\'(\\') {\\n            leftCnt++;\\n        } else if (grid[x][y] == \\')\\') {\\n            leftCnt--;\\n        }\\n        \\n            \\n        if(leftCnt < 0 || leftCnt > (m+n)/2) {\\n            // memory[x][y][leftCnt] = false;\\n            return false; \\n        }\\n        \\n       if(memory[x][y][leftCnt] != null) return memory[x][y][leftCnt]; \\n        \\n        if(x == m -1 && y == n -1 && leftCnt == 0) {\\n            memory[x][y][leftCnt]  = true;\\n            return true;\\n        }\\n        \\n        boolean valid =  dfs(leftCnt, x + 1, y, grid, memory) || dfs(leftCnt, x, y + 1, grid, memory);\\n        memory[x][y][leftCnt]  = valid;\\n        return valid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036439,
                "title": "python-faster-than-99-dp",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        if grid[-1][-1] == \"(\": return False\\n        if grid[0][0] == \")\": return False\\n        m, n = len(grid), len(grid[0])\\n        if (m+n) % 2 == 0: return False\\n        @cache\\n        def pos(i, j, cur):\\n            if cur == \")\": return False\\n            if i == m-1 and j == n-1:\\n                if cur == \"(\": return True\\n                return False\\n            if i >= m: return False\\n            if j >= n: return False\\n            if cur and grid[i][j] == \")\" and cur[-1] == \"(\":\\n                cur = cur[:-1]\\n            else:\\n                cur += grid[i][j]\\n            return pos(i+1, j, cur) or pos(i, j+1, cur)\\n        return pos(0,0,\"\")\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        if grid[-1][-1] == \"(\": return False\\n        if grid[0][0] == \")\": return False\\n        m, n = len(grid), len(grid[0])\\n        if (m+n) % 2 == 0: return False\\n        @cache\\n        def pos(i, j, cur):\\n            if cur == \")\": return False\\n            if i == m-1 and j == n-1:\\n                if cur == \"(\": return True\\n                return False\\n            if i >= m: return False\\n            if j >= n: return False\\n            if cur and grid[i][j] == \")\" and cur[-1] == \"(\":\\n                cur = cur[:-1]\\n            else:\\n                cur += grid[i][j]\\n            return pos(i+1, j, cur) or pos(i, j+1, cur)\\n        return pos(0,0,\"\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2032799,
                "title": "help-needed-memo-with-tle",
                "content": "For the below JS code still getting a TLE\\nPlease help.\\n```\\nvar hasValidPath = function(a) {\\n    const [m, n] = [a.length-1, a[a.length-1].length - 1]\\n    const me = {}\\n    const getNeighbours = ([i, j]) => [[i+1, j], [i, j+1]].filter(([i, j]) => a[i]?.[j])\\n    const hasValidPathUtil = ([i, j], s) => {\\n        if(me[[i, j, s]] !== undefined) {\\n            return me[[i, j, s]]\\n        }\\n        let result = false;\\n        const val = a[i][j]\\n        if (val === \\'\\\\)\\') {\\n            if(s.length) s.pop()\\n            else {\\n                me[[i, j, s]] = result;\\n                return result;\\n            }\\n        } else {\\n            s.push(\\'\\\\(\\')\\n        }\\n        if(i === m && j === n && s.length === 0) {\\n            \\n            result = true\\n        } else {\\n            const neighbours = getNeighbours([i, j])\\n            for(let x = 0; x< neighbours.length; x++) {\\n                const [i, j] = neighbours[x]\\n                if(hasValidPathUtil([i, j], [...s])) {\\n                    result = true\\n                    break\\n                }\\n            }\\n        }\\n        me[[i, j, s]] = result;\\n        return result;\\n    }\\n\\n    let res = hasValidPathUtil([0, 0], [])\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar hasValidPath = function(a) {\\n    const [m, n] = [a.length-1, a[a.length-1].length - 1]\\n    const me = {}\\n    const getNeighbours = ([i, j]) => [[i+1, j], [i, j+1]].filter(([i, j]) => a[i]?.[j])\\n    const hasValidPathUtil = ([i, j], s) => {\\n        if(me[[i, j, s]] !== undefined) {\\n            return me[[i, j, s]]\\n        }\\n        let result = false;\\n        const val = a[i][j]\\n        if (val === \\'\\\\)\\') {\\n            if(s.length) s.pop()\\n            else {\\n                me[[i, j, s]] = result;\\n                return result;\\n            }\\n        } else {\\n            s.push(\\'\\\\(\\')\\n        }\\n        if(i === m && j === n && s.length === 0) {\\n            \\n            result = true\\n        } else {\\n            const neighbours = getNeighbours([i, j])\\n            for(let x = 0; x< neighbours.length; x++) {\\n                const [i, j] = neighbours[x]\\n                if(hasValidPathUtil([i, j], [...s])) {\\n                    result = true\\n                    break\\n                }\\n            }\\n        }\\n        me[[i, j, s]] = result;\\n        return result;\\n    }\\n\\n    let res = hasValidPathUtil([0, 0], [])\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2032444,
                "title": "3d-dynamic-programming-easy-to-understand",
                "content": "```\\nclass Solution {\\n    \\nint dp[101][101][210];\\npublic:\\n//     // Method 1: Backtracking\\n//     bool solve(vector<vector<char>> &grid, int m, int n, int i, int j, stack<char> &st, vector<vector<bool>> &vis)\\n//     {\\n//         char poop = \\'*\\';\\n//         if (st.empty())\\n//             st.push(grid[i][j]);\\n//         else\\n//         {\\n//             if (st.top() == \\'(\\' && grid[i][j] == \\')\\')\\n//             {\\n//                 st.pop();\\n//                 poop = \\'(\\';\\n//             }\\n//             else if (st.top() == \\')\\' && grid[i][j] == \\'(\\')\\n//                 return false;\\n//             else\\n//                 st.push(grid[i][j]);\\n//         }\\n        \\n//         // cout << \"i: \" << i << \" j: \" << j << endl;\\n//         if (i == m - 1 && j == n - 1)\\n//         {\\n//             if (st.empty())\\n//                 return true;\\n//         }\\n//         else\\n//         {\\n//             vector<pair<int, int>> dir = {{1, 0}, {0, 1}};\\n//             for (int a = 0; a < 2; a++)\\n//             {\\n//                 int ni = i + dir[a].first;\\n//                 int nj = j + dir[a].second;\\n                \\n//                 if (ni >= 0 && ni < m && nj >= 0 && nj < n && !vis[ni][nj])\\n//                 {\\n//                     vis[ni][nj] = true;\\n//                     if (solve(grid, m, n, ni, nj, st, vis) == true)\\n//                         return true;\\n//                     vis[ni][nj] = false;\\n//                 }\\n//             }\\n//         }\\n//         if (poop == \\'(\\')\\n//             st.push(\\'(\\');\\n//         else\\n//             st.pop();\\n//         return false;\\n//     }\\n//     bool hasValidPath(vector<vector<char>>& grid) {\\n//         int m = grid.size();\\n//         int n = grid[0].size();\\n        \\n//         vector<vector<bool>> vis(m, vector<bool> (n, false));\\n        \\n//         stack<char> st;\\n        \\n//         vis[0][0] = true;\\n//         bool ans = solve(grid, m, n, 0, 0, st, vis);\\n//         vis[0][0] = true;\\n//         return ans;\\n//     }\\n \\n    // DP\\n    int solve(vector<vector<char>> &grid, int m, int n, int i, int j, int k)\\n    {\\n        if (i >= m || j >= n)\\n            return 0;\\n        \\n        // First we need to update k and then only see if dp[][][] != -1\\n        if (grid[i][j] == \\'(\\')\\n            k++;\\n        else\\n        {\\n            k--;\\n            if (k < 0)\\n                return 0;\\n        }\\n       \\n        if (dp[i][j][k] != -1)\\n            return dp[i][j][k];\\n        \\n        if (i == m - 1 && j == n - 1)\\n            return dp[i][j][k] = (k == 0);\\n        else       \\n        {\\n            int o1 = solve(grid, m, n, i + 1, j, k);\\n            int o2 = solve(grid, m, n, i, j + 1, k);\\n            \\n            dp[i][j][k] = (o1 | o2);\\n            return dp[i][j][k];\\n        }\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        return solve(grid, m, n, 0, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\nint dp[101][101][210];\\npublic:\\n//     // Method 1: Backtracking\\n//     bool solve(vector<vector<char>> &grid, int m, int n, int i, int j, stack<char> &st, vector<vector<bool>> &vis)\\n//     {\\n//         char poop = \\'*\\';\\n//         if (st.empty())\\n//             st.push(grid[i][j]);\\n//         else\\n//         {\\n//             if (st.top() == \\'(\\' && grid[i][j] == \\')\\')\\n//             {\\n//                 st.pop();\\n//                 poop = \\'(\\';\\n//             }\\n//             else if (st.top() == \\')\\' && grid[i][j] == \\'(\\')\\n//                 return false;\\n//             else\\n//                 st.push(grid[i][j]);\\n//         }\\n        \\n//         // cout << \"i: \" << i << \" j: \" << j << endl;\\n//         if (i == m - 1 && j == n - 1)\\n//         {\\n//             if (st.empty())\\n//                 return true;\\n//         }\\n//         else\\n//         {\\n//             vector<pair<int, int>> dir = {{1, 0}, {0, 1}};\\n//             for (int a = 0; a < 2; a++)\\n//             {\\n//                 int ni = i + dir[a].first;\\n//                 int nj = j + dir[a].second;\\n                \\n//                 if (ni >= 0 && ni < m && nj >= 0 && nj < n && !vis[ni][nj])\\n//                 {\\n//                     vis[ni][nj] = true;\\n//                     if (solve(grid, m, n, ni, nj, st, vis) == true)\\n//                         return true;\\n//                     vis[ni][nj] = false;\\n//                 }\\n//             }\\n//         }\\n//         if (poop == \\'(\\')\\n//             st.push(\\'(\\');\\n//         else\\n//             st.pop();\\n//         return false;\\n//     }\\n//     bool hasValidPath(vector<vector<char>>& grid) {\\n//         int m = grid.size();\\n//         int n = grid[0].size();\\n        \\n//         vector<vector<bool>> vis(m, vector<bool> (n, false));\\n        \\n//         stack<char> st;\\n        \\n//         vis[0][0] = true;\\n//         bool ans = solve(grid, m, n, 0, 0, st, vis);\\n//         vis[0][0] = true;\\n//         return ans;\\n//     }\\n \\n    // DP\\n    int solve(vector<vector<char>> &grid, int m, int n, int i, int j, int k)\\n    {\\n        if (i >= m || j >= n)\\n            return 0;\\n        \\n        // First we need to update k and then only see if dp[][][] != -1\\n        if (grid[i][j] == \\'(\\')\\n            k++;\\n        else\\n        {\\n            k--;\\n            if (k < 0)\\n                return 0;\\n        }\\n       \\n        if (dp[i][j][k] != -1)\\n            return dp[i][j][k];\\n        \\n        if (i == m - 1 && j == n - 1)\\n            return dp[i][j][k] = (k == 0);\\n        else       \\n        {\\n            int o1 = solve(grid, m, n, i + 1, j, k);\\n            int o2 = solve(grid, m, n, i, j + 1, k);\\n            \\n            dp[i][j][k] = (o1 | o2);\\n            return dp[i][j][k];\\n        }\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        return solve(grid, m, n, 0, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2032255,
                "title": "python-3-simple-recursive-memoization",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        @lru_cache(None)\\n        def helper(i, j, score):\\n            if i == m or j == n:\\n                return False\\n            if i == m - 1 and j == n - 1:\\n                return score == 1 and grid[i][j] == \\')\\'\\n            \\n            if grid[i][j] == \\'(\\':\\n                return helper(i + 1, j, score + 1) or helper(i, j + 1, score + 1)\\n            if score == 0:\\n                return False\\n            return helper(i + 1, j, score - 1) or helper(i, j + 1, score - 1)\\n        \\n        return helper(0, 0, 0)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        @lru_cache(None)\\n        def helper(i, j, score):\\n            if i == m or j == n:\\n                return False\\n            if i == m - 1 and j == n - 1:\\n                return score == 1 and grid[i][j] == \\')\\'\\n            \\n            if grid[i][j] == \\'(\\':\\n                return helper(i + 1, j, score + 1) or helper(i, j + 1, score + 1)\\n            if score == 0:\\n                return False\\n            return helper(i + 1, j, score - 1) or helper(i, j + 1, score - 1)\\n        \\n        return helper(0, 0, 0)",
                "codeTag": "Java"
            },
            {
                "id": 2032043,
                "title": "simple-python-solution-dp-o-mn-time-and-space-complexity",
                "content": "```\\n\"\"\"\\nBasic idea:\\n===========\\n1.  For a parenthesis to be valid:\\n    As we traverse the path, we count the total left and right brackets encountered so far.\\n    At any point along the path, the following must always be true:\\n\\n        total left brackets >= total right brackets \\n\\n2.  We define a list of lists of m x n dimensions named \"brackets\". \\n    Each element in \"brackets\" contains a set of tuples.\\n    Each tuple is defined as (total left brackets, total right brackets).\\n    The set represents all the possible combinations of the tuples at the current row / column.\\n\\n3.  brackets@current position = brackets@top + brackets@left\\n    => brackets[r][c] = brackets[r-1][c] + brackets[r+1][c]\\n    We allow addition only if before and after adding, total left brackets >= total right brackets.\\n\\n4.  At the bottom right of the grid, return:\\n    True - if there exists a tuple such that total left brackets == total right brackets;\\n    False- if there are no tuples where total left brackets == total right brackets.\\n\"\"\"\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        def addBracket(r, c, prev_r, prev_c):\\n            nonlocal brackets\\n            if 0 <= prev_r < m and 0 <= prev_c < n:                \\n                for left, right in brackets[prev_r][prev_c]:\\n                    if left >= right:\\n                        new_left = left + (1 if grid[r][c] == \\'(\\' else 0)\\n                        new_right = right + (1 if grid[r][c] == \\')\\' else 0)\\n                        if new_left >= new_right:\\n                            brackets[r][c].add((new_left, new_right))\\n            \\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        brackets = [[set() for i in range(n)] for j in range(m)]\\n        brackets[0][0].add((1 if grid[0][0] == \\'(\\' else 0, 1 if grid[0][0] == \\')\\' else 0))\\n        for i in range(m):\\n            for j in range(n):\\n                addBracket(i, j, i-1, j)\\n                addBracket(i, j, i, j-1)\\n        \\n        pathFound = False\\n        for left, right in brackets[m-1][n-1]:\\n            if left == right:\\n                pathFound = True\\n                break\\n        return pathFound\\n```",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\nBasic idea:\\n===========\\n1.  For a parenthesis to be valid:\\n    As we traverse the path, we count the total left and right brackets encountered so far.\\n    At any point along the path, the following must always be true:\\n\\n        total left brackets >= total right brackets \\n\\n2.  We define a list of lists of m x n dimensions named \"brackets\". \\n    Each element in \"brackets\" contains a set of tuples.\\n    Each tuple is defined as (total left brackets, total right brackets).\\n    The set represents all the possible combinations of the tuples at the current row / column.\\n\\n3.  brackets@current position = brackets@top + brackets@left\\n    => brackets[r][c] = brackets[r-1][c] + brackets[r+1][c]\\n    We allow addition only if before and after adding, total left brackets >= total right brackets.\\n\\n4.  At the bottom right of the grid, return:\\n    True - if there exists a tuple such that total left brackets == total right brackets;\\n    False- if there are no tuples where total left brackets == total right brackets.\\n\"\"\"\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        def addBracket(r, c, prev_r, prev_c):\\n            nonlocal brackets\\n            if 0 <= prev_r < m and 0 <= prev_c < n:                \\n                for left, right in brackets[prev_r][prev_c]:\\n                    if left >= right:\\n                        new_left = left + (1 if grid[r][c] == \\'(\\' else 0)\\n                        new_right = right + (1 if grid[r][c] == \\')\\' else 0)\\n                        if new_left >= new_right:\\n                            brackets[r][c].add((new_left, new_right))\\n            \\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        brackets = [[set() for i in range(n)] for j in range(m)]\\n        brackets[0][0].add((1 if grid[0][0] == \\'(\\' else 0, 1 if grid[0][0] == \\')\\' else 0))\\n        for i in range(m):\\n            for j in range(n):\\n                addBracket(i, j, i-1, j)\\n                addBracket(i, j, i, j-1)\\n        \\n        pathFound = False\\n        for left, right in brackets[m-1][n-1]:\\n            if left == right:\\n                pathFound = True\\n                break\\n        return pathFound\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031202,
                "title": "c-dfs-dp",
                "content": "```\\npublic class Solution\\n{\\n    private int[][][] dp = new int[100][][];\\n\\n    public bool DFS(char[][] grid, int i, int j, int k)\\n    {\\n        if (i >= grid.Length || j >= grid[0].Length)\\n        {\\n            return false;\\n        }\\n\\n        if (grid[i][j] == \\'(\\')\\n        {\\n            k++;\\n        }\\n        else\\n        {\\n            k--;\\n        }\\n\\n        if (k < 0)\\n        {\\n            return false;\\n        }\\n\\n        if (i == grid.Length - 1 && j == grid[0].Length - 1)\\n        {\\n            return k == 0;\\n        }\\n\\n        if (dp[i][j][k] != -1)\\n        {\\n            return Convert.ToBoolean(dp[i][j][k]);\\n        }\\n\\n        dp[i][j][k] = Convert.ToInt32(DFS(grid, i + 1, j, k) | DFS(grid, i, j + 1, k));\\n        return Convert.ToBoolean(dp[i][j][k]);\\n    }\\n    \\n    public bool HasValidPath(char[][] grid)\\n    {\\n        for (int i = 0; i < dp.Length; i++)\\n        {\\n            dp[i] = new int[100][];\\n            for (int j = 0; j < dp[i].Length; j++)\\n            {\\n                dp[i][j] = new int[205];\\n                Array.Fill(dp[i][j], -1);\\n            }\\n        }\\n        return DFS(grid, 0, 0, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\npublic class Solution\\n{\\n    private int[][][] dp = new int[100][][];\\n\\n    public bool DFS(char[][] grid, int i, int j, int k)\\n    {\\n        if (i >= grid.Length || j >= grid[0].Length)\\n        {\\n            return false;\\n        }\\n\\n        if (grid[i][j] == \\'(\\')\\n        {\\n            k++;\\n        }\\n        else\\n        {\\n            k--;\\n        }\\n\\n        if (k < 0)\\n        {\\n            return false;\\n        }\\n\\n        if (i == grid.Length - 1 && j == grid[0].Length - 1)\\n        {\\n            return k == 0;\\n        }\\n\\n        if (dp[i][j][k] != -1)\\n        {\\n            return Convert.ToBoolean(dp[i][j][k]);\\n        }\\n\\n        dp[i][j][k] = Convert.ToInt32(DFS(grid, i + 1, j, k) | DFS(grid, i, j + 1, k));\\n        return Convert.ToBoolean(dp[i][j][k]);\\n    }\\n    \\n    public bool HasValidPath(char[][] grid)\\n    {\\n        for (int i = 0; i < dp.Length; i++)\\n        {\\n            dp[i] = new int[100][];\\n            for (int j = 0; j < dp[i].Length; j++)\\n            {\\n                dp[i][j] = new int[205];\\n                Array.Fill(dp[i][j], -1);\\n            }\\n        }\\n        return DFS(grid, 0, 0, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031136,
                "title": "c-solution",
                "content": "```\\nvoid right(int i, int j, int** list, int* count){\\n    int copy[200];\\n    int Count = 0;\\n    int a = 0;\\n    int b = 0;\\n    while (a < count[j] || b < count[j+1]){\\n        if (a >= count[j]){\\n            while (b < count[j+1]){\\n                copy[Count] = list[j+1][b];\\n                Count++;\\n                b++;\\n            }\\n        } else if (b >= count[j+1]){\\n            while (a < count[j]){\\n                copy[Count] = list[j][a];\\n                Count++;\\n                a++;\\n            }\\n        } else if (list[j][a] > list[j+1][b]){\\n            copy[Count] = list[j+1][b];\\n            Count++;\\n            b++;\\n        } else if (list[j][a] < list[j+1][b]){\\n            copy[Count] = list[j][a];\\n            Count++;\\n            a++;\\n        } else {\\n            copy[Count] = list[j][a];\\n            Count++;\\n            a++;\\n            b++;\\n        }\\n    }\\n    while (Count > 0 && copy[Count-1] > 99){\\n        Count--;\\n    }\\n    for (int i = 0 ; i < Count ; i++){\\n        list[j][i] = copy[i]+1;\\n    }\\n    count[j] = Count;\\n}\\n\\nvoid left(int i, int j, int** list, int* count){\\n    int copy[200];\\n    int Count = 0;\\n    int a = 0;\\n    int b = 0;\\n    while (a < count[j] || b < count[j+1]){\\n        if (a >= count[j]){\\n            while (b < count[j+1]){\\n                copy[Count] = list[j+1][b];\\n                Count++;\\n                b++;\\n            }\\n        } else if (b >= count[j+1]){\\n            while (a < count[j]){\\n                copy[Count] = list[j][a];\\n                Count++;\\n                a++;\\n            }\\n        } else if (list[j][a] > list[j+1][b]){\\n            copy[Count] = list[j+1][b];\\n            Count++;\\n            b++;\\n        } else if (list[j][a] < list[j+1][b]){\\n            copy[Count] = list[j][a];\\n            Count++;\\n            a++;\\n        } else {\\n            copy[Count] = list[j][a];\\n            Count++;\\n            a++;\\n            b++;\\n        }\\n    }\\n    int h = 0;\\n    while (h < Count && copy[h] < 1){\\n        h++;\\n    }\\n    count[j] = 0;\\n    for (; h < Count ; h++){\\n        list[j][count[j]] = copy[h]-1;\\n        count[j]++;\\n    }\\n}\\n\\nbool hasValidPath(char** grid, int gridSize, int* gridColSize){\\n    int x = gridSize-1;\\n    int y = *gridColSize-1;\\n    if (grid[x][y] == \\'(\\' || grid[0][0] == \\')\\'  || (x+y) % 2 == 0){\\n        return false;\\n    }\\n    \\n    int** list = malloc(sizeof(int*)*(*gridColSize));\\n    for (int i = 0 ; i < (*gridColSize) ; i++){\\n        list[i] = malloc(sizeof(int)*100);\\n    }\\n    int* count = calloc(101,sizeof(int));\\n    list[y][0] = 1;\\n    count[y]++;\\n    \\n    for (int j = y-1 ; j >= 0 ; j--){\\n        if (list[j+1][0] >= 0){\\n            if (grid[x][j] == \\')\\'){\\n                list[j][0] = list[j+1][0]+1;\\n                count[j]++;\\n            } else {\\n                list[j][0] = list[j+1][0]-1;\\n                if (list[j][count[j]] >= 0){\\n                    count[j]++;\\n                }\\n            }\\n        } else {\\n            list[j][0] = -1;\\n        }\\n    }\\n    \\n    for (int i = x-1 ; i >= 0 ; i--){\\n        if (list[y][0] >= 0){\\n            if (grid[i][y] == \\')\\'){\\n                list[y][0]++;\\n            } else {\\n                list[y][0]--;\\n                if (list[y][0] < 0){\\n                    count[y]--;\\n                }\\n            }\\n        }\\n        for (int j = y-1 ; j >= 0 ; j--){\\n            if (grid[i][j] == \\')\\'){\\n                right( i, j, list, count);\\n            } else {\\n                left( i, j, list, count);\\n            }\\n        }\\n    }\\n    int ans = list[0][0];\\n    for (int i = 0 ; i < *gridColSize ; i++){\\n        free(list[i]);\\n    }\\n    free(list);\\n    return ans == 0 ? true : false;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid right(int i, int j, int** list, int* count){\\n    int copy[200];\\n    int Count = 0;\\n    int a = 0;\\n    int b = 0;\\n    while (a < count[j] || b < count[j+1]){\\n        if (a >= count[j]){\\n            while (b < count[j+1]){\\n                copy[Count] = list[j+1][b];\\n                Count++;\\n                b++;\\n            }\\n        } else if (b >= count[j+1]){\\n            while (a < count[j]){\\n                copy[Count] = list[j][a];\\n                Count++;\\n                a++;\\n            }\\n        } else if (list[j][a] > list[j+1][b]){\\n            copy[Count] = list[j+1][b];\\n            Count++;\\n            b++;\\n        } else if (list[j][a] < list[j+1][b]){\\n            copy[Count] = list[j][a];\\n            Count++;\\n            a++;\\n        } else {\\n            copy[Count] = list[j][a];\\n            Count++;\\n            a++;\\n            b++;\\n        }\\n    }\\n    while (Count > 0 && copy[Count-1] > 99){\\n        Count--;\\n    }\\n    for (int i = 0 ; i < Count ; i++){\\n        list[j][i] = copy[i]+1;\\n    }\\n    count[j] = Count;\\n}\\n\\nvoid left(int i, int j, int** list, int* count){\\n    int copy[200];\\n    int Count = 0;\\n    int a = 0;\\n    int b = 0;\\n    while (a < count[j] || b < count[j+1]){\\n        if (a >= count[j]){\\n            while (b < count[j+1]){\\n                copy[Count] = list[j+1][b];\\n                Count++;\\n                b++;\\n            }\\n        } else if (b >= count[j+1]){\\n            while (a < count[j]){\\n                copy[Count] = list[j][a];\\n                Count++;\\n                a++;\\n            }\\n        } else if (list[j][a] > list[j+1][b]){\\n            copy[Count] = list[j+1][b];\\n            Count++;\\n            b++;\\n        } else if (list[j][a] < list[j+1][b]){\\n            copy[Count] = list[j][a];\\n            Count++;\\n            a++;\\n        } else {\\n            copy[Count] = list[j][a];\\n            Count++;\\n            a++;\\n            b++;\\n        }\\n    }\\n    int h = 0;\\n    while (h < Count && copy[h] < 1){\\n        h++;\\n    }\\n    count[j] = 0;\\n    for (; h < Count ; h++){\\n        list[j][count[j]] = copy[h]-1;\\n        count[j]++;\\n    }\\n}\\n\\nbool hasValidPath(char** grid, int gridSize, int* gridColSize){\\n    int x = gridSize-1;\\n    int y = *gridColSize-1;\\n    if (grid[x][y] == \\'(\\' || grid[0][0] == \\')\\'  || (x+y) % 2 == 0){\\n        return false;\\n    }\\n    \\n    int** list = malloc(sizeof(int*)*(*gridColSize));\\n    for (int i = 0 ; i < (*gridColSize) ; i++){\\n        list[i] = malloc(sizeof(int)*100);\\n    }\\n    int* count = calloc(101,sizeof(int));\\n    list[y][0] = 1;\\n    count[y]++;\\n    \\n    for (int j = y-1 ; j >= 0 ; j--){\\n        if (list[j+1][0] >= 0){\\n            if (grid[x][j] == \\')\\'){\\n                list[j][0] = list[j+1][0]+1;\\n                count[j]++;\\n            } else {\\n                list[j][0] = list[j+1][0]-1;\\n                if (list[j][count[j]] >= 0){\\n                    count[j]++;\\n                }\\n            }\\n        } else {\\n            list[j][0] = -1;\\n        }\\n    }\\n    \\n    for (int i = x-1 ; i >= 0 ; i--){\\n        if (list[y][0] >= 0){\\n            if (grid[i][y] == \\')\\'){\\n                list[y][0]++;\\n            } else {\\n                list[y][0]--;\\n                if (list[y][0] < 0){\\n                    count[y]--;\\n                }\\n            }\\n        }\\n        for (int j = y-1 ; j >= 0 ; j--){\\n            if (grid[i][j] == \\')\\'){\\n                right( i, j, list, count);\\n            } else {\\n                left( i, j, list, count);\\n            }\\n        }\\n    }\\n    int ans = list[0][0];\\n    for (int i = 0 ; i < *gridColSize ; i++){\\n        free(list[i]);\\n    }\\n    free(list);\\n    return ans == 0 ? true : false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2030005,
                "title": "easy-and-intuitive-java-memoization-and-tabulation-codes",
                "content": "Method 1 : Memoization \\n\\n```\\nclass Solution {\\n    Boolean dp[][][];\\n    \\n    public boolean hasValidPath(char[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        dp = new Boolean[rows][cols][rows+cols];\\n        return hasValidPath(grid,0,0,rows,cols,0);\\n    }\\n    \\n    private boolean hasValidPath(char grid[][],int row,int col,int rows,int cols,int count){\\n        if(row>=rows||col>=cols) return false;\\n        \\n        char bracket = grid[row][col];\\n        \\n        if(bracket==\\'(\\') count++;\\n        else count--;\\n        \\n        if(count<0) return false;\\n        \\n        if(row==rows-1&&col==cols-1) return count==0;\\n        \\n        if(dp[row][col][count]!=null) return dp[row][col][count];\\n        \\n        return dp[row][col][count] = hasValidPath(grid,row,col+1,rows,cols,count)\\n                                   ||hasValidPath(grid,row+1,col,rows,cols,count);\\n    }\\n}\\n```\\n\\nMethod 2 : Tabulation\\n```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        boolean dp[][][] = new boolean[rows][cols][rows+cols];\\n        \\n        for(int row=rows-1;row>=0;row--){\\n            \\n            for(int col=cols-1;col>=0;col--){\\n                char bracket = grid[row][col];\\n                \\n                for(int count = 0;count<rows+cols;count++){\\n                    int nextCount = count;\\n                    if(bracket==\\'(\\') nextCount++;\\n                    else nextCount--;\\n                    \\n                    if(nextCount<0) continue;\\n                    \\n                    if(row==rows-1&&col==cols-1) dp[row][col][count] = (nextCount==0);\\n                    else if(nextCount<rows+cols){\\n                        if(col+1<cols) dp[row][col][count]|=dp[row][col+1][nextCount];\\n                        if(row+1<rows) dp[row][col][count]|=dp[row+1][col][nextCount];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0][0];\\n    }\\n}\\n```\\n\\nBoth codes have time and space complexity of O(rows*cols*(rows+cols))\\n\\nEdit : Method 2 space optimized , works in O(cols*(rows+cols)) space : \\n\\n```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        boolean dp[][][] = new boolean[2][cols][rows+cols];\\n        \\n        for(int row=rows-1;row>=0;row--){\\n            \\n            for(int col=cols-1;col>=0;col--){\\n                char bracket = grid[row][col];\\n                \\n                for(int count = 0;count<rows+cols;count++){\\n                    int nextCount = count;\\n                    if(bracket==\\'(\\') nextCount++;\\n                    else nextCount--;\\n                    \\n                    if(nextCount<0) continue;\\n                    \\n                    if(row==rows-1&&col==cols-1) dp[0][col][count] = (nextCount==0);\\n                    else if(nextCount<rows+cols){\\n                        if(col+1<cols) dp[0][col][count]|=dp[0][col+1][nextCount];\\n                        if(row+1<rows) dp[0][col][count]|=dp[1][col][nextCount];\\n                    }\\n                }\\n            }\\n            \\n            if(row>0){\\n                for(int col=cols-1;col>=0;col--){\\n                    for(int count = 0;count<rows+cols;count++){\\n                        dp[1][col][count] = dp[0][col][count];\\n                        dp[0][col][count] = false;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0][0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    Boolean dp[][][];\\n    \\n    public boolean hasValidPath(char[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        dp = new Boolean[rows][cols][rows+cols];\\n        return hasValidPath(grid,0,0,rows,cols,0);\\n    }\\n    \\n    private boolean hasValidPath(char grid[][],int row,int col,int rows,int cols,int count){\\n        if(row>=rows||col>=cols) return false;\\n        \\n        char bracket = grid[row][col];\\n        \\n        if(bracket==\\'(\\') count++;\\n        else count--;\\n        \\n        if(count<0) return false;\\n        \\n        if(row==rows-1&&col==cols-1) return count==0;\\n        \\n        if(dp[row][col][count]!=null) return dp[row][col][count];\\n        \\n        return dp[row][col][count] = hasValidPath(grid,row,col+1,rows,cols,count)\\n                                   ||hasValidPath(grid,row+1,col,rows,cols,count);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        boolean dp[][][] = new boolean[rows][cols][rows+cols];\\n        \\n        for(int row=rows-1;row>=0;row--){\\n            \\n            for(int col=cols-1;col>=0;col--){\\n                char bracket = grid[row][col];\\n                \\n                for(int count = 0;count<rows+cols;count++){\\n                    int nextCount = count;\\n                    if(bracket==\\'(\\') nextCount++;\\n                    else nextCount--;\\n                    \\n                    if(nextCount<0) continue;\\n                    \\n                    if(row==rows-1&&col==cols-1) dp[row][col][count] = (nextCount==0);\\n                    else if(nextCount<rows+cols){\\n                        if(col+1<cols) dp[row][col][count]|=dp[row][col+1][nextCount];\\n                        if(row+1<rows) dp[row][col][count]|=dp[row+1][col][nextCount];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0][0];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        boolean dp[][][] = new boolean[2][cols][rows+cols];\\n        \\n        for(int row=rows-1;row>=0;row--){\\n            \\n            for(int col=cols-1;col>=0;col--){\\n                char bracket = grid[row][col];\\n                \\n                for(int count = 0;count<rows+cols;count++){\\n                    int nextCount = count;\\n                    if(bracket==\\'(\\') nextCount++;\\n                    else nextCount--;\\n                    \\n                    if(nextCount<0) continue;\\n                    \\n                    if(row==rows-1&&col==cols-1) dp[0][col][count] = (nextCount==0);\\n                    else if(nextCount<rows+cols){\\n                        if(col+1<cols) dp[0][col][count]|=dp[0][col+1][nextCount];\\n                        if(row+1<rows) dp[0][col][count]|=dp[1][col][nextCount];\\n                    }\\n                }\\n            }\\n            \\n            if(row>0){\\n                for(int col=cols-1;col>=0;col--){\\n                    for(int count = 0;count<rows+cols;count++){\\n                        dp[1][col][count] = dp[0][col][count];\\n                        dp[0][col][count] = false;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2029706,
                "title": "brute-force",
                "content": "This works due to small constraints. Save all possible balances at every cell. Use these balances to populate all possible balances in the right and down cell. Then return true if 0 balance is possible in bottom right cell \\n\\n```import java.util.*;\\n\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        Set<Integer>[][] sets = new Set[m][n];\\n\\n        if (grid[0][0] != \\'(\\' || grid[m-1][n-1] != \\')\\') {\\n            return false;\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                sets[i][j] = new HashSet<>();\\n                if(i == 0 && j == 0) {\\n                    sets[0][0].add(1);\\n                    continue;\\n                }\\n                int toAdd = grid[i][j] == \\')\\' ? -1 : 1;\\n\\n                if (i-1 >= 0) {\\n                    Iterator<Integer> it = sets[i-1][j].iterator();\\n                    while(it.hasNext()) {\\n                        int val = it.next() + toAdd;\\n                        if (val >= 0) {\\n                            sets[i][j].add(val);\\n                        }\\n                        \\n                    }\\n                }\\n                if (j-1 >= 0) {\\n                    Iterator<Integer> it = sets[i][j-1].iterator();\\n                    while (it.hasNext()) {\\n                        int val = it.next() + toAdd;\\n                        if (val >= 0) {\\n                            sets[i][j].add(val);\\n                        }\\n                    }\\n\\n                }\\n            }\\n        }\\n\\n        return sets[m-1][n-1].contains(0);\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "```import java.util.*;\\n\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        Set<Integer>[][] sets = new Set[m][n];\\n\\n        if (grid[0][0] != \\'(\\' || grid[m-1][n-1] != \\')\\') {\\n            return false;\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                sets[i][j] = new HashSet<>();\\n                if(i == 0 && j == 0) {\\n                    sets[0][0].add(1);\\n                    continue;\\n                }\\n                int toAdd = grid[i][j] == \\')\\' ? -1 : 1;\\n\\n                if (i-1 >= 0) {\\n                    Iterator<Integer> it = sets[i-1][j].iterator();\\n                    while(it.hasNext()) {\\n                        int val = it.next() + toAdd;\\n                        if (val >= 0) {\\n                            sets[i][j].add(val);\\n                        }\\n                        \\n                    }\\n                }\\n                if (j-1 >= 0) {\\n                    Iterator<Integer> it = sets[i][j-1].iterator();\\n                    while (it.hasNext()) {\\n                        int val = it.next() + toAdd;\\n                        if (val >= 0) {\\n                            sets[i][j].add(val);\\n                        }\\n                    }\\n\\n                }\\n            }\\n        }\\n\\n        return sets[m-1][n-1].contains(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2029374,
                "title": "java-dfs-solution",
                "content": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        boolean[][][] visited = new boolean[grid.length][grid[0].length][grid.length + grid[0].length];\\n        return dfs(0, 0, grid, visited, 0);\\n    }\\n\\n    private boolean dfs(int col, int row, char[][] grid, boolean[][][] visited, int parenthesesCounter) {\\n        if (col > grid.length - 1 || row > grid[0].length - 1) return false;\\n        parenthesesCounter += grid[col][row] == \\'(\\' ? 1 : - 1;\\n        if (parenthesesCounter < 0 || parenthesesCounter > (grid.length + grid[0].length) / 2 || visited[col][row][parenthesesCounter]) return false;\\n        visited[col][row][parenthesesCounter] = true;\\n        if (col == grid.length - 1 && row == grid[0].length - 1 && parenthesesCounter == 0) return true;\\n        return dfs(col + 1, row, grid, visited, parenthesesCounter) || dfs(col, row + 1, grid, visited, parenthesesCounter);\\n\\t\\t}\\n\\t}\\n  \\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        boolean[][][] visited = new boolean[grid.length][grid[0].length][grid.length + grid[0].length];\\n        return dfs(0, 0, grid, visited, 0);\\n    }\\n\\n    private boolean dfs(int col, int row, char[][] grid, boolean[][][] visited, int parenthesesCounter) {\\n        if (col > grid.length - 1 || row > grid[0].length - 1) return false;\\n        parenthesesCounter += grid[col][row] == \\'(\\' ? 1 : - 1;\\n        if (parenthesesCounter < 0 || parenthesesCounter > (grid.length + grid[0].length) / 2 || visited[col][row][parenthesesCounter]) return false;\\n        visited[col][row][parenthesesCounter] = true;\\n        if (col == grid.length - 1 && row == grid[0].length - 1 && parenthesesCounter == 0) return true;\\n        return dfs(col + 1, row, grid, visited, parenthesesCounter) || dfs(col, row + 1, grid, visited, parenthesesCounter);\\n\\t\\t}\\n\\t}\\n  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2027606,
                "title": "java-dp-set",
                "content": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        char L = \\'(\\';\\n        char R = \\')\\';\\n        \\n        if(!(grid[0][0] == L && grid[n - 1][m - 1] == R)) return false;\\n\\n        Set<Integer>[][] dp = new HashSet[n][m];\\n        Set<Integer> init = new HashSet<>();\\n        init.add(1);\\n        dp[0][0] = init;\\n        \\n        // top\\n        for(int j = 1; j < m; j++){\\n            Set<Integer> curr = new HashSet<>();\\n            \\n            if(grid[0][j] == R){\\n                for(int val : dp[0][j - 1]){\\n                    if(val >= 0){\\n                        curr.add(val - 1);\\n                    }\\n                }\\n            }else{\\n                for(int val : dp[0][j - 1]){\\n                    if(val >= 0){\\n                        curr.add(val + 1);\\n                    }\\n                }\\n            }\\n            dp[0][j] = curr;\\n        }\\n        \\n        // left\\n        for(int i = 1; i < n; i++){\\n            Set<Integer> curr = new HashSet<>();\\n            if(dp[i - 1][0].contains(-1)){\\n                curr.add(-1);\\n                dp[i][0] = curr;\\n                continue;\\n            }\\n            \\n            \\n            if(grid[i][0] == R){\\n                for(int val : dp[i - 1][0]){\\n                    if(val >= 0){\\n                        curr.add(val - 1);\\n                    }\\n                }\\n            }else{\\n                for(int val : dp[i - 1][0]){\\n                    if(val >= 0){\\n                        curr.add(val + 1);\\n                    }\\n                }\\n            }\\n            dp[i][0] = curr;\\n        }\\n        \\n        // regular\\n        for(int i = 1; i < n; i++){\\n            for(int j = 1; j < m; j++){\\n                Set<Integer> curr = new HashSet<>();\\n                \\n                if(dp[i - 1][j].contains(-1) && dp[i][j - 1].contains(-1)){\\n                    curr.add(-1);\\n                    dp[i][j] = curr;\\n                    continue;\\n                }\\n                \\n                if(grid[i][j] == R){\\n                    for(int val : dp[i][j - 1]){\\n                        if(val - 1 >= 0){\\n                            curr.add(val - 1);\\n                        }\\n                    }\\n                    \\n                    for(int val : dp[i - 1][j]){\\n                        if(val - 1 >= 0){\\n                            curr.add(val - 1);\\n                        }\\n                    }\\n                    \\n                }else{\\n                    for(int val : dp[i][j - 1]){\\n                        if(val >= 0){\\n                            curr.add(val + 1);\\n                        }\\n                    }\\n                    \\n                    for(int val : dp[i - 1][j]){\\n                        if(val >= 0){\\n                            curr.add(val + 1);\\n                        }\\n                    }\\n                }\\n                \\n                dp[i][j] = curr;\\n            }\\n        }\\n        \\n        return dp[n - 1][m - 1].contains(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        char L = \\'(\\';\\n        char R = \\')\\';\\n        \\n        if(!(grid[0][0] == L && grid[n - 1][m - 1] == R)) return false;\\n\\n        Set<Integer>[][] dp = new HashSet[n][m];\\n        Set<Integer> init = new HashSet<>();\\n        init.add(1);\\n        dp[0][0] = init;\\n        \\n        // top\\n        for(int j = 1; j < m; j++){\\n            Set<Integer> curr = new HashSet<>();\\n            \\n            if(grid[0][j] == R){\\n                for(int val : dp[0][j - 1]){\\n                    if(val >= 0){\\n                        curr.add(val - 1);\\n                    }\\n                }\\n            }else{\\n                for(int val : dp[0][j - 1]){\\n                    if(val >= 0){\\n                        curr.add(val + 1);\\n                    }\\n                }\\n            }\\n            dp[0][j] = curr;\\n        }\\n        \\n        // left\\n        for(int i = 1; i < n; i++){\\n            Set<Integer> curr = new HashSet<>();\\n            if(dp[i - 1][0].contains(-1)){\\n                curr.add(-1);\\n                dp[i][0] = curr;\\n                continue;\\n            }\\n            \\n            \\n            if(grid[i][0] == R){\\n                for(int val : dp[i - 1][0]){\\n                    if(val >= 0){\\n                        curr.add(val - 1);\\n                    }\\n                }\\n            }else{\\n                for(int val : dp[i - 1][0]){\\n                    if(val >= 0){\\n                        curr.add(val + 1);\\n                    }\\n                }\\n            }\\n            dp[i][0] = curr;\\n        }\\n        \\n        // regular\\n        for(int i = 1; i < n; i++){\\n            for(int j = 1; j < m; j++){\\n                Set<Integer> curr = new HashSet<>();\\n                \\n                if(dp[i - 1][j].contains(-1) && dp[i][j - 1].contains(-1)){\\n                    curr.add(-1);\\n                    dp[i][j] = curr;\\n                    continue;\\n                }\\n                \\n                if(grid[i][j] == R){\\n                    for(int val : dp[i][j - 1]){\\n                        if(val - 1 >= 0){\\n                            curr.add(val - 1);\\n                        }\\n                    }\\n                    \\n                    for(int val : dp[i - 1][j]){\\n                        if(val - 1 >= 0){\\n                            curr.add(val - 1);\\n                        }\\n                    }\\n                    \\n                }else{\\n                    for(int val : dp[i][j - 1]){\\n                        if(val >= 0){\\n                            curr.add(val + 1);\\n                        }\\n                    }\\n                    \\n                    for(int val : dp[i - 1][j]){\\n                        if(val >= 0){\\n                            curr.add(val + 1);\\n                        }\\n                    }\\n                }\\n                \\n                dp[i][j] = curr;\\n            }\\n        }\\n        \\n        return dp[n - 1][m - 1].contains(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2025540,
                "title": "one-pass-over-all-cells-88-speed",
                "content": "![image](https://assets.leetcode.com/users/images/43f1130f-7346-4900-a3ce-711a6a37be3d_1652181745.882908.png)\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        rows, cols = len(grid), len(grid[0])\\n        if ((rows + cols - 1) % 2 or grid[0][0] == \")\"\\n                or grid[rows - 1][cols - 1] == \"(\"):\\n            return False\\n        opened = [[set() for _ in range(cols)] for _ in range(rows)]\\n        opened[0][0].add(1)\\n        row = 0\\n        for col in range(1, cols):\\n            if grid[row][col] == \"(\":\\n                opened[row][col].update(n + 1 for n in opened[row][col - 1])\\n            else:\\n                opened[row][col].update(n - 1 for n in opened[row][col - 1]\\n                                        if n > 0)\\n        col = 0\\n        for row in range(1, rows):\\n            if grid[row][col] == \"(\":\\n                opened[row][col].update(n + 1 for n in opened[row - 1][col])\\n            else:\\n                opened[row][col].update(n - 1 for n in opened[row - 1][col]\\n                                        if n > 0)\\n        for row in range(1, rows):\\n            for col in range(1, cols):\\n                opened[row - 1][col].update(opened[row][col - 1])\\n                if grid[row][col] == \"(\":\\n                    opened[row][col].update(n + 1 for n in\\n                                            opened[row - 1][col])\\n                else:\\n                    opened[row][col].update(n - 1 for n in\\n                                            opened[row - 1][col] if n > 0)\\n        return 0 in opened[rows - 1][cols - 1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        rows, cols = len(grid), len(grid[0])\\n        if ((rows + cols - 1) % 2 or grid[0][0] == \")\"\\n                or grid[rows - 1][cols - 1] == \"(\"):\\n            return False\\n        opened = [[set() for _ in range(cols)] for _ in range(rows)]\\n        opened[0][0].add(1)\\n        row = 0\\n        for col in range(1, cols):\\n            if grid[row][col] == \"(\":\\n                opened[row][col].update(n + 1 for n in opened[row][col - 1])\\n            else:\\n                opened[row][col].update(n - 1 for n in opened[row][col - 1]\\n                                        if n > 0)\\n        col = 0\\n        for row in range(1, rows):\\n            if grid[row][col] == \"(\":\\n                opened[row][col].update(n + 1 for n in opened[row - 1][col])\\n            else:\\n                opened[row][col].update(n - 1 for n in opened[row - 1][col]\\n                                        if n > 0)\\n        for row in range(1, rows):\\n            for col in range(1, cols):\\n                opened[row - 1][col].update(opened[row][col - 1])\\n                if grid[row][col] == \"(\":\\n                    opened[row][col].update(n + 1 for n in\\n                                            opened[row - 1][col])\\n                else:\\n                    opened[row][col].update(n - 1 for n in\\n                                            opened[row - 1][col] if n > 0)\\n        return 0 in opened[rows - 1][cols - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024346,
                "title": "java-hashsets-clean-code",
                "content": "```java\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        Set<Integer>[][] dp = new Set[m][n];\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                dp[i][j] = new HashSet<Integer>();\\n            }   \\n        }\\n        dp[0][0].add(grid[0][0] == \\'(\\' ? 1 : -1);\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                int inc = grid[i][j] == \\'(\\' ? 1 : -1;\\n                if (i-1 >= 0) addValue(dp[i-1][j], dp[i][j], inc);\\n                if (j-1 >= 0) addValue(dp[i][j-1], dp[i][j], inc);\\n            }\\n        }\\n        \\n        return dp[m-1][n-1].contains(0);\\n    }\\n    \\n    private void addValue(Set<Integer> src, Set<Integer> dst, int inc) {\\n        for(Integer value : src) {\\n            if (value.intValue() < 0) continue;\\n            int val = value.intValue() + inc;\\n            if (val >= 0) dst.add(val);\\n        } \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        Set<Integer>[][] dp = new Set[m][n];\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                dp[i][j] = new HashSet<Integer>();\\n            }   \\n        }\\n        dp[0][0].add(grid[0][0] == \\'(\\' ? 1 : -1);\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                int inc = grid[i][j] == \\'(\\' ? 1 : -1;\\n                if (i-1 >= 0) addValue(dp[i-1][j], dp[i][j], inc);\\n                if (j-1 >= 0) addValue(dp[i][j-1], dp[i][j], inc);\\n            }\\n        }\\n        \\n        return dp[m-1][n-1].contains(0);\\n    }\\n    \\n    private void addValue(Set<Integer> src, Set<Integer> dst, int inc) {\\n        for(Integer value : src) {\\n            if (value.intValue() < 0) continue;\\n            int val = value.intValue() + inc;\\n            if (val >= 0) dst.add(val);\\n        } \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024304,
                "title": "rust-dfs-hashmap-o-rows-cols-rows-cols",
                "content": "Simplify \\n`*f.get(&(r, c, cnt)).unwrap_or(&false);`\\nto\\n`f[&(r, c, cnt)];`\\n```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn has_valid_path(grid: Vec<Vec<char>>) -> bool {\\n        fn dfs(r: usize, c: usize, mut cnt: i32, grid: &Vec<Vec<char>>, f: &mut HashMap<(usize, usize, i32), bool>) -> bool {\\n            let rows = grid.len();\\n            let cols = grid[0].len();\\n            let mut ans = false;\\n            \\n            if r >= rows || c >= cols {\\n                f.insert((r,c,cnt), false);\\n                return false;\\n            }\\n            if grid[r][c] == \\'(\\' {\\n                cnt += 1;\\n            } else {\\n                cnt -= 1;\\n            }\\n            if cnt < 0 {\\n                f.insert((r,c,cnt), false);\\n                return false;\\n            }\\n            if r == rows - 1 && c == cols - 1 && cnt == 0 {\\n                f.insert((r,c,cnt), true);\\n                return true;\\n            }\\n            \\n            if f.contains_key(&(r, c, cnt)) {\\n                return f[&(r, c, cnt)];\\n            }\\n\\n            let ans = dfs(r+1, c, cnt, &grid, f) || dfs(r, c+1, cnt, &grid, f);\\n            f.insert((r,c,cnt), ans);\\n            ans\\n        }\\n        \\n        let mut f: HashMap<(usize, usize, i32), bool> = HashMap::new();\\n        \\n        let ans = dfs(0, 0, 0, &grid, &mut f);\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn has_valid_path(grid: Vec<Vec<char>>) -> bool {\\n        fn dfs(r: usize, c: usize, mut cnt: i32, grid: &Vec<Vec<char>>, f: &mut HashMap<(usize, usize, i32), bool>) -> bool {\\n            let rows = grid.len();\\n            let cols = grid[0].len();\\n            let mut ans = false;\\n            \\n            if r >= rows || c >= cols {\\n                f.insert((r,c,cnt), false);\\n                return false;\\n            }\\n            if grid[r][c] == \\'(\\' {\\n                cnt += 1;\\n            } else {\\n                cnt -= 1;\\n            }\\n            if cnt < 0 {\\n                f.insert((r,c,cnt), false);\\n                return false;\\n            }\\n            if r == rows - 1 && c == cols - 1 && cnt == 0 {\\n                f.insert((r,c,cnt), true);\\n                return true;\\n            }\\n            \\n            if f.contains_key(&(r, c, cnt)) {\\n                return f[&(r, c, cnt)];\\n            }\\n\\n            let ans = dfs(r+1, c, cnt, &grid, f) || dfs(r, c+1, cnt, &grid, f);\\n            f.insert((r,c,cnt), ans);\\n            ans\\n        }\\n        \\n        let mut f: HashMap<(usize, usize, i32), bool> = HashMap::new();\\n        \\n        let ans = dfs(0, 0, 0, &grid, &mut f);\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2023737,
                "title": "python-dp-memoization-simple-solution",
                "content": "```\\nclass Solution:\\n    def dp(self, grid, r, c, balance, lookup):\\n        if grid[r][c] == \\'(\\':\\n            balance += 1\\n        else:\\n            balance -= 1\\n        \\n        if r == len(grid)-1 and c == len(grid[0])-1:\\n            return balance == 0\\n        \\n        key = (r, c, balance)\\n        if key not in lookup:\\n            isValid = False\\n\\n            for dr, dc in [[r, c+1], [r+1, c]]:\\n                if dr < len(grid) and dc < len(grid[0]) and (balance > 0 or grid[dr][dc] == \\'(\\'):\\n                    if self.dp(grid, dr, dc, balance, lookup) or self.dp(grid, dr, dc, balance, lookup):\\n                        isValid = True\\n                        break\\n            lookup[key] = isValid\\n        return lookup[key]\\n    \\n    \\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        if grid[0][0] == \\')\\' or grid[-1][-1] == \\'(\\' or len(grid) == len(grid[0]) == 1:\\n            return False\\n        \\n        return self.dp(grid, 0, 0, 0, {})\\n        \\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def dp(self, grid, r, c, balance, lookup):\\n        if grid[r][c] == \\'(\\':\\n            balance += 1\\n        else:\\n            balance -= 1\\n        \\n        if r == len(grid)-1 and c == len(grid[0])-1:\\n            return balance == 0\\n        \\n        key = (r, c, balance)\\n        if key not in lookup:\\n            isValid = False\\n\\n            for dr, dc in [[r, c+1], [r+1, c]]:\\n                if dr < len(grid) and dc < len(grid[0]) and (balance > 0 or grid[dr][dc] == \\'(\\'):\\n                    if self.dp(grid, dr, dc, balance, lookup) or self.dp(grid, dr, dc, balance, lookup):\\n                        isValid = True\\n                        break\\n            lookup[key] = isValid\\n        return lookup[key]\\n    \\n    \\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        if grid[0][0] == \\')\\' or grid[-1][-1] == \\'(\\' or len(grid) == len(grid[0]) == 1:\\n            return False\\n        \\n        return self.dp(grid, 0, 0, 0, {})\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2023546,
                "title": "java-dfs-memo",
                "content": "```java\\nclass Solution {\\n    private int m;\\n    private int n;\\n    private char[][] grid;\\n    private Map<String, Boolean> memo;\\n\\n\\n    public boolean hasValidPath(char[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        this.grid = grid;\\n        memo = new HashMap<>();\\n\\n        // basic case: the path should start with \\'(\\' and end with \\')\\'\\n        if (grid[0][0] != \\'(\\' || grid[m - 1][n - 1] != \\')\\') {\\n            return false;\\n        }\\n\\n        // basic case: the count of value in the path should be even.\\n        // so m+n should be odd\\n        if ((m + n) % 2 == 0) {\\n            return false;\\n        }\\n\\n        // dfs\\n        return traverse(0, 0, 0);\\n    }\\n\\n\\n    private boolean traverse(int i, int j, int count) {\\n        if (i >= m || j >= n) {\\n            return false;\\n        }\\n\\n        // calculate the number of \\'(\\'\\n        char c = grid[i][j];\\n        if (c == \\'(\\') {\\n            count++;\\n        } else {\\n            // when encounter with \\')\\', offset one \\'(\\'\\n            count--;\\n        }\\n\\n        // arrive the end position\\n        if (i == m - 1 && j == n - 1) {\\n            // perfect pair\\n            if (count == 0) {\\n                return true;\\n            }\\n        }\\n\\n        // if count < 0, the path will start with \\')\\', illegal.\\n        // if count > (m + n - 1) / 2, there would be no enough \\')\\' left to offset the \\'(\\'\\n        if (count < 0 || count > (m + n - 1) / 2) {\\n            return false;\\n        }\\n\\n        // check the memo\\n        String key = generateKey(i, j, count);\\n        if (memo.containsKey(key)) {\\n            return memo.get(key);\\n        }\\n\\n        // traverse next position. right or down.\\n        boolean ans = traverse(i, j + 1, count) || traverse(i + 1, j, count);\\n        // add to memo\\n        memo.put(key, ans);\\n        return ans;\\n    }\\n\\n    /**\\n     * generate some kind of key. we use \\'-\\' to split elements here.\\n     *\\n     * @param i\\n     * @param j\\n     * @param currentCount\\n     * @return\\n     */\\n    private String generateKey(int i, int j, int currentCount) {\\n        return i + \"-\" + j + \"-\" + currentCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```java\\nclass Solution {\\n    private int m;\\n    private int n;\\n    private char[][] grid;\\n    private Map<String, Boolean> memo;\\n\\n\\n    public boolean hasValidPath(char[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        this.grid = grid;\\n        memo = new HashMap<>();\\n\\n        // basic case: the path should start with \\'(\\' and end with \\')\\'\\n        if (grid[0][0] != \\'(\\' || grid[m - 1][n - 1] != \\')\\') {\\n            return false;\\n        }\\n\\n        // basic case: the count of value in the path should be even.\\n        // so m+n should be odd\\n        if ((m + n) % 2 == 0) {\\n            return false;\\n        }\\n\\n        // dfs\\n        return traverse(0, 0, 0);\\n    }\\n\\n\\n    private boolean traverse(int i, int j, int count) {\\n        if (i >= m || j >= n) {\\n            return false;\\n        }\\n\\n        // calculate the number of \\'(\\'\\n        char c = grid[i][j];\\n        if (c == \\'(\\') {\\n            count++;\\n        } else {\\n            // when encounter with \\')\\', offset one \\'(\\'\\n            count--;\\n        }\\n\\n        // arrive the end position\\n        if (i == m - 1 && j == n - 1) {\\n            // perfect pair\\n            if (count == 0) {\\n                return true;\\n            }\\n        }\\n\\n        // if count < 0, the path will start with \\')\\', illegal.\\n        // if count > (m + n - 1) / 2, there would be no enough \\')\\' left to offset the \\'(\\'\\n        if (count < 0 || count > (m + n - 1) / 2) {\\n            return false;\\n        }\\n\\n        // check the memo\\n        String key = generateKey(i, j, count);\\n        if (memo.containsKey(key)) {\\n            return memo.get(key);\\n        }\\n\\n        // traverse next position. right or down.\\n        boolean ans = traverse(i, j + 1, count) || traverse(i + 1, j, count);\\n        // add to memo\\n        memo.put(key, ans);\\n        return ans;\\n    }\\n\\n    /**\\n     * generate some kind of key. we use \\'-\\' to split elements here.\\n     *\\n     * @param i\\n     * @param j\\n     * @param currentCount\\n     * @return\\n     */\\n    private String generateKey(int i, int j, int currentCount) {\\n        return i + \"-\" + j + \"-\" + currentCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2023471,
                "title": "c-simple-recursive-solution-with-dp",
                "content": "class Solution {\\n    int m, n;\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        \\n        m = grid.size(), n = grid[0].size();\\n        vector<vector<vector<int>>> dp(100, vector<vector<int>> (100, vector<int> (205, -1)));\\n        return helper(grid, 0, 0, 0, dp);\\n    }\\n    \\n    bool helper(vector<vector<char>> &grid, int i, int j, int a, vector<vector<vector<int>>> &dp)\\n    {\\n        if(i >= m || j >= n)\\n            return !a && (i == m - 1 || j == n - 1);\\n        \\n        if(grid[i][j] == \\'(\\')\\n            a++;\\n        else\\n            a--;\\n        \\n        if(a < 0)\\n            return false;\\n        \\n        if(dp[i][j][a] != -1)\\n            return dp[i][j][a];\\n        \\n        return dp[i][j][a] = helper(grid, i + 1, j, a, dp) || helper(grid, i, j + 1, a, dp);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    int m, n;\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        \\n        m = grid.size(), n = grid[0].size();\\n        vector<vector<vector<int>>> dp(100, vector<vector<int>> (100, vector<int> (205, -1)));\\n        return helper(grid, 0, 0, 0, dp);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2023371,
                "title": "python3-solution-with-explanation-from-bottom-right-to-top-left",
                "content": "```\\ndef hasValidPath(self, grid: List[List[str]]) -> bool:\\n        # in this function we check how many \"(\" are needed at location [i][j]\\n        # starting from grid[m-1][n-1], and move up and left\\n        # if grid[m-1][n-1]==\"(\", there is no way to form a valid parentheses string path\\n        # else, the \"(\" needed is 1. so we start with 1\\n        # if grid[i][j]==\")\", add 1 to the value\\n        # if grid[i][j]==\"(\", minus 1 to the value\\n        # only keep records of values greater or equal to 0\\n        m = len(grid)\\n        n = len(grid[0])\\n        # use a matrix brackets to keep records of how many \"(\" are needed at each location\\n        brackets = [[0]*n for i in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                brackets[i][j] = set()\\n            \\n        \\n        j = n-1\\n        i = m-1\\n        if grid[i][j]==\")\":\\n            # 1. initialize brackets[m-1][n-1]\\n            brackets[i][j].add(1)\\n            # 2. initialize the last column of values based on brackets[i+1][j]. note that we only need to keep values greater or equal to 0.\\n            i -= 1\\n            while i>=0:\\n                if grid[i][j]==\")\":\\n                    if len(brackets[i+1][j])>0:\\n                        brackets[i][j].add(list(brackets[i+1][j])[0] + 1)\\n                else:\\n                    if len(brackets[i+1][j])>0:\\n                        if list(brackets[i+1][j])[0] - 1>=0:\\n                            brackets[i][j].add(list(brackets[i+1][j])[0] - 1)\\n                i -= 1\\n            # 3. initialize the last row of values based on brackets[i][j+1]\\n            j = n-2\\n            i = m-1\\n            while j>=0:\\n                if grid[i][j]==\")\":\\n                    if len(brackets[i][j+1])>0:\\n                        brackets[i][j].add(list(brackets[i][j+1])[0] + 1)\\n                else:\\n                    if len(brackets[i][j+1])>0:\\n                        if list(brackets[i][j+1])[0] - 1>=0:\\n                            brackets[i][j].add(list(brackets[i][j+1])[0] - 1)\\n                j -= 1\\n            \\n            # 4. from brackets[m-2][n-2], for brackets[i][j]: obtain how many \"(\" are needed based on numbers from brackets[i][j+1] and brackets[i+1][j]\\n            i = m-2\\n            while i>=0:\\n                j = n-2\\n                while j>=0:\\n                    if grid[i][j]==\")\":\\n                        for x in brackets[i][j+1]|brackets[i+1][j]:\\n                            brackets[i][j].add(x + 1)\\n                        \\n                    else:\\n                        for x in brackets[i][j+1]|brackets[i+1][j]:\\n                            if x-1>=0:\\n                                brackets[i][j].add(x - 1)\\n                        \\n                    j -= 1\\n                i -= 1    \\n                \\n            # 5. if 0 is needed, then return True; otherwise, return False\\n            return (0 in brackets[0][0])\\n        else:\\n            # if the last element is \"(\", then there\\'s no way to form a valid parentheses string path\\n            return False\\n\\t```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef hasValidPath(self, grid: List[List[str]]) -> bool:\\n        # in this function we check how many \"(\" are needed at location [i][j]\\n        # starting from grid[m-1][n-1], and move up and left\\n        # if grid[m-1][n-1]==\"(\", there is no way to form a valid parentheses string path\\n        # else, the \"(\" needed is 1. so we start with 1\\n        # if grid[i][j]==\")\", add 1 to the value\\n        # if grid[i][j]==\"(\", minus 1 to the value\\n        # only keep records of values greater or equal to 0\\n        m = len(grid)\\n        n = len(grid[0])\\n        # use a matrix brackets to keep records of how many \"(\" are needed at each location\\n        brackets = [[0]*n for i in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                brackets[i][j] = set()\\n            \\n        \\n        j = n-1\\n        i = m-1\\n        if grid[i][j]==\")\":\\n            # 1. initialize brackets[m-1][n-1]\\n            brackets[i][j].add(1)\\n            # 2. initialize the last column of values based on brackets[i+1][j]. note that we only need to keep values greater or equal to 0.\\n            i -= 1\\n            while i>=0:\\n                if grid[i][j]==\")\":\\n                    if len(brackets[i+1][j])>0:\\n                        brackets[i][j].add(list(brackets[i+1][j])[0] + 1)\\n                else:\\n                    if len(brackets[i+1][j])>0:\\n                        if list(brackets[i+1][j])[0] - 1>=0:\\n                            brackets[i][j].add(list(brackets[i+1][j])[0] - 1)\\n                i -= 1\\n            # 3. initialize the last row of values based on brackets[i][j+1]\\n            j = n-2\\n            i = m-1\\n            while j>=0:\\n                if grid[i][j]==\")\":\\n                    if len(brackets[i][j+1])>0:\\n                        brackets[i][j].add(list(brackets[i][j+1])[0] + 1)\\n                else:\\n                    if len(brackets[i][j+1])>0:\\n                        if list(brackets[i][j+1])[0] - 1>=0:\\n                            brackets[i][j].add(list(brackets[i][j+1])[0] - 1)\\n                j -= 1\\n            \\n            # 4. from brackets[m-2][n-2], for brackets[i][j]: obtain how many \"(\" are needed based on numbers from brackets[i][j+1] and brackets[i+1][j]\\n            i = m-2\\n            while i>=0:\\n                j = n-2\\n                while j>=0:\\n                    if grid[i][j]==\")\":\\n                        for x in brackets[i][j+1]|brackets[i+1][j]:\\n                            brackets[i][j].add(x + 1)\\n                        \\n                    else:\\n                        for x in brackets[i][j+1]|brackets[i+1][j]:\\n                            if x-1>=0:\\n                                brackets[i][j].add(x - 1)\\n                        \\n                    j -= 1\\n                i -= 1    \\n                \\n            # 5. if 0 is needed, then return True; otherwise, return False\\n            return (0 in brackets[0][0])\\n        else:\\n            # if the last element is \"(\", then there\\'s no way to form a valid parentheses string path\\n            return False\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 2023210,
                "title": "3d-dp",
                "content": "int dp[105][105][105]; // dp[i][j][k]=> 0 or 1 accordingly if we are at i,j and have k opening bracket \\n    \\n    int sol(int x,int y,int ob,int cb,int &p,vector<vector<char>>& grid)\\n    {\\n        if(cb>ob || (ob>p || cb>p))\\n        {\\n            return 0;\\n        }\\n        \\n        if(x==grid.size()-1 && y==grid[0].size()-1)\\n        {\\n            if(ob==cb)\\n            {\\n                return 1;\\n            }\\n            \\n            return 0;\\n        }\\n        \\n        if(dp[x][y][ob]!=-1)\\n        {\\n            return dp[x][y][ob];\\n        }\\n        \\n        int ans=0;\\n        \\n        if(x+1<grid.size())\\n        {\\n            if(grid[x+1][y]==\\'(\\')\\n            ans=ans|sol(x+1,y,ob+1,cb,p,grid);\\n            else\\n            ans=ans|sol(x+1,y,ob,cb+1,p,grid);\\n        }\\n        \\n        if(y+1<grid[0].size())\\n        {\\n            if(grid[x][y+1]==\\'(\\')\\n            ans=ans|sol(x,y+1,ob+1,cb,p,grid);\\n            else\\n            ans=ans|sol(x,y+1,ob,cb+1,p,grid);\\n        }\\n        \\n        return dp[x][y][ob]=ans;\\n    }\\n    \\n    bool hasValidPath(vector<vector<char>>& grid) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        int n=grid.size(),m=grid[0].size();\\n        if((n+m-1)%2 || grid[0][0]==\\')\\' || grid[n-1][m-1]==\\'(\\')\\n        {\\n            return false;\\n        }\\n        \\n        int p=(n+m-1)/2; // this is the size of final valid string and it must have (n+m-1)/2 opening bracket and closing bracket and hence opening and closing bracket should not cross (n+m-1)/2.\\n\\n        return sol(0,0,1,0,p,grid);\\n    }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "int dp[105][105][105]; // dp[i][j][k]=> 0 or 1 accordingly if we are at i,j and have k opening bracket \\n    \\n    int sol(int x,int y,int ob,int cb,int &p,vector<vector<char>>& grid)\\n    {\\n        if(cb>ob || (ob>p || cb>p))\\n        {\\n            return 0;\\n        }\\n        \\n        if(x==grid.size()-1 && y==grid[0].size()-1)\\n        {\\n            if(ob==cb)\\n            {\\n                return 1;\\n            }\\n            \\n            return 0;\\n        }\\n        \\n        if(dp[x][y][ob]!=-1)\\n        {\\n            return dp[x][y][ob];\\n        }\\n        \\n        int ans=0;\\n        \\n        if(x+1<grid.size())\\n        {\\n            if(grid[x+1][y]==\\'(\\')\\n            ans=ans|sol(x+1,y,ob+1,cb,p,grid);\\n            else\\n            ans=ans|sol(x+1,y,ob,cb+1,p,grid);\\n        }\\n        \\n        if(y+1<grid[0].size())\\n        {\\n            if(grid[x][y+1]==\\'(\\')\\n            ans=ans|sol(x,y+1,ob+1,cb,p,grid);\\n            else\\n            ans=ans|sol(x,y+1,ob,cb+1,p,grid);\\n        }\\n        \\n        return dp[x][y][ob]=ans;\\n    }\\n    \\n    bool hasValidPath(vector<vector<char>>& grid) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        int n=grid.size(),m=grid[0].size();\\n        if((n+m-1)%2 || grid[0][0]==\\')\\' || grid[n-1][m-1]==\\'(\\')\\n        {\\n            return false;\\n        }\\n        \\n        int p=(n+m-1)/2; // this is the size of final valid string and it must have (n+m-1)/2 opening bracket and closing bracket and hence opening and closing bracket should not cross (n+m-1)/2.\\n\\n        return sol(0,0,1,0,p,grid);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2022904,
                "title": "python-dfs-memo-ignoring-bad-paths-with-counters",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        size = m+n-1\\n        if size % 2 == 1 or grid[0][0] == \\')\\' or grid[m-1][n-1] == \\'(\\':\\n            return False\\n        \\n        @cache\\n        def trav(r, c, cnt, step):\\n            if grid[r][c] == \\'(\\':\\n                newCnt = cnt+1\\n            else:\\n                newCnt = cnt-1\\n            \\n            if step == size:\\n                if newCnt == 0:\\n                    return True\\n                return False\\n        \\n            diffs = [(0,1), (1,0)]\\n            for dr, dc in diffs:\\n                newR, newC = r+dr, c+dc\\n                \\n                if newR < m and newC < n:\\n                    if newCnt > 0:\\n                        if trav(newR, newC, newCnt, step+1):\\n                            return True\\n                    elif grid[newR][newC] == \\'(\\':\\n                        if trav(newR, newC, newCnt, step+1):\\n                            return True\\n                        \\n            return False\\n                    \\n        return trav(0, 0, 0, 1)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        size = m+n-1\\n        if size % 2 == 1 or grid[0][0] == \\')\\' or grid[m-1][n-1] == \\'(\\':\\n            return False\\n        \\n        @cache\\n        def trav(r, c, cnt, step):\\n            if grid[r][c] == \\'(\\':\\n                newCnt = cnt+1\\n            else:\\n                newCnt = cnt-1\\n            \\n            if step == size:\\n                if newCnt == 0:\\n                    return True\\n                return False\\n        \\n            diffs = [(0,1), (1,0)]\\n            for dr, dc in diffs:\\n                newR, newC = r+dr, c+dc\\n                \\n                if newR < m and newC < n:\\n                    if newCnt > 0:\\n                        if trav(newR, newC, newCnt, step+1):\\n                            return True\\n                    elif grid[newR][newC] == \\'(\\':\\n                        if trav(newR, newC, newCnt, step+1):\\n                            return True\\n                        \\n            return False\\n                    \\n        return trav(0, 0, 0, 1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2022500,
                "title": "java-bottom-up-dp-using-hashset",
                "content": "**Intuition**\\nFor any given cell (x,y), it is possible to have a valid string starting from (0,0) only if number of open brackets upto (x,y) are 0. A path is invalid if number of \\')\\' exceeds number of \\'(\\'. \\n\\n**Approach**\\nFor each cell (i,j) of dp array, maintain a hashset and store the number of open brackets, updating the values in the hashset from dp[i-1][j] and dp[i][j-1].\\nif current character is \\'(\\', then increment the values from hashsets of dp[i-1][j] and dp[i][j-1].\\nif current character is \\')\\', thendecrement the values from hashsets of dp[i-1][j] and dp[i][j-1], ignoring negative values.\\nTrue is returned only if hashset of last cell has 0.\\n**Code**\\n```\\nclass Solution {\\n    class hs{\\n        HashSet<Integer> s;\\n        public hs(){\\n            s = new HashSet<>();\\n        }\\n       \\n    }\\n    public boolean hasValidPath(char[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        hs[][] dp = new hs[n][m];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                dp[i][j] = new hs();\\n            }\\n        }\\n        dp[0][0].s.add(1);\\n        for(int i=1;i<m;i++){\\n            int k = (grid[0][i]==\\'(\\'?1:-1);\\n            for(int x: dp[0][i-1].s){\\n                if(x+k<0){\\n                    continue;\\n                }\\n                dp[0][i].s.add(x+k);\\n                \\n            }\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            int k = (grid[i][0]==\\'(\\'?1:-1);\\n               \\n            for(int x: dp[i-1][0].s){\\n                if(x+k<0){\\n                    continue;\\n                }\\n                dp[i][0].s.add(x+k);\\n                \\n            }\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n               int k = (grid[i][j]==\\'(\\'?1:-1);\\n                for(int x: dp[i-1][j].s){\\n                    if(x+k<0){\\n                        continue;\\n                    }\\n                    dp[i][j].s.add(x+k);\\n                }\\n                for(int x: dp[i][j-1].s){\\n                    if(x+k<0){\\n                        continue;\\n                    }\\n                    dp[i][j].s.add(x+k);\\n                    }\\n                \\n            }\\n        }\\n        \\n        \\n        return dp[n-1][m-1].s.contains(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    class hs{\\n        HashSet<Integer> s;\\n        public hs(){\\n            s = new HashSet<>();\\n        }\\n       \\n    }\\n    public boolean hasValidPath(char[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        hs[][] dp = new hs[n][m];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                dp[i][j] = new hs();\\n            }\\n        }\\n        dp[0][0].s.add(1);\\n        for(int i=1;i<m;i++){\\n            int k = (grid[0][i]==\\'(\\'?1:-1);\\n            for(int x: dp[0][i-1].s){\\n                if(x+k<0){\\n                    continue;\\n                }\\n                dp[0][i].s.add(x+k);\\n                \\n            }\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            int k = (grid[i][0]==\\'(\\'?1:-1);\\n               \\n            for(int x: dp[i-1][0].s){\\n                if(x+k<0){\\n                    continue;\\n                }\\n                dp[i][0].s.add(x+k);\\n                \\n            }\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n               int k = (grid[i][j]==\\'(\\'?1:-1);\\n                for(int x: dp[i-1][j].s){\\n                    if(x+k<0){\\n                        continue;\\n                    }\\n                    dp[i][j].s.add(x+k);\\n                }\\n                for(int x: dp[i][j-1].s){\\n                    if(x+k<0){\\n                        continue;\\n                    }\\n                    dp[i][j].s.add(x+k);\\n                    }\\n                \\n            }\\n        }\\n        \\n        \\n        return dp[n-1][m-1].s.contains(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2022400,
                "title": "getting-tle-don-t-know-why",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[101][101][202];\\n    int m, n;\\n    bool rec(int i , int j, int cnt, vector<vector<char>>& grid)\\n    {\\n        if(i >= m || j >= n || cnt < 0)return 0;\\n        if(i == m-1 && j == n-1){\\n            if(grid[i][j] == \\'(\\')cnt++;\\n            else cnt--;\\n            return cnt == 0;\\n        }\\n        if(dp[i][j][cnt]!=-1)return dp[i][j][cnt];\\n        bool ans = false;\\n        if(grid[i][j] == \\'(\\')cnt++;\\n        else cnt--;\\n        ans = rec(i+1, j, cnt, grid) || rec(i,j+1, cnt, grid);\\n        if(cnt < 0)return false;\\n        return dp[i][j][cnt] = ans;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) \\n    {\\n        m = grid.size();\\n        n = grid[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        return rec(0,0,0,grid);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][101][202];\\n    int m, n;\\n    bool rec(int i , int j, int cnt, vector<vector<char>>& grid)\\n    {\\n        if(i >= m || j >= n || cnt < 0)return 0;\\n        if(i == m-1 && j == n-1){\\n            if(grid[i][j] == \\'(\\')cnt++;\\n            else cnt--;\\n            return cnt == 0;\\n        }\\n        if(dp[i][j][cnt]!=-1)return dp[i][j][cnt];\\n        bool ans = false;\\n        if(grid[i][j] == \\'(\\')cnt++;\\n        else cnt--;\\n        ans = rec(i+1, j, cnt, grid) || rec(i,j+1, cnt, grid);\\n        if(cnt < 0)return false;\\n        return dp[i][j][cnt] = ans;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) \\n    {\\n        m = grid.size();\\n        n = grid[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        return rec(0,0,0,grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021904,
                "title": "python-easy-to-read-and-understand",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        def check(i, j, x, memo=set()):\\n            if i >= n or j >= m:\\n                return False\\n            \\n\\t\\t\\t# x is the parenthesis score till now; add by 1 if the cell is ( else subtract by 1\\n            x += 1 if grid[i][j] == \\'(\\' else -1\\n            \\n\\t\\t\\t# If the score is negative then the sequence is already invalid\\n\\t\\t\\t# or if the score is greater than half of the path length then the sequence is invalid\\n\\t\\t\\t# or if it is already visited then return False\\n            if x < 0 or x > (m+n)//2 or (i,j,x) in memo:\\n                return False\\n            \\n            memo.add((i,j,x))\\n            \\n\\t\\t\\t\\n\\t\\t\\t# if it\\'s the last cell and score is 0 then it is a valid sequence\\n            if i == n-1 and j == m-1 and x == 0:\\n                return True\\n            \\n            return check(i+1, j, x, memo) or check(i, j+1, x, memo)\\n    \\n        n, m = len(grid), len(grid[0])\\n\\t\\t\\n\\t\\t# if the path length is odd: return False\\n\\t\\t# if the first cell is ): return False\\n\\t\\t# if the last cell is (: return False\\n        if (n+m-1)%2 or grid[0][0] == \\')\\' or grid[-1][-1] == \\'(\\':\\n            return False\\n        \\n        return check(0, 0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        def check(i, j, x, memo=set()):\\n            if i >= n or j >= m:\\n                return False\\n            \\n\\t\\t\\t# x is the parenthesis score till now; add by 1 if the cell is ( else subtract by 1\\n            x += 1 if grid[i][j] == \\'(\\' else -1\\n            \\n\\t\\t\\t# If the score is negative then the sequence is already invalid\\n\\t\\t\\t# or if the score is greater than half of the path length then the sequence is invalid\\n\\t\\t\\t# or if it is already visited then return False\\n            if x < 0 or x > (m+n)//2 or (i,j,x) in memo:\\n                return False\\n            \\n            memo.add((i,j,x))\\n            \\n\\t\\t\\t\\n\\t\\t\\t# if it\\'s the last cell and score is 0 then it is a valid sequence\\n            if i == n-1 and j == m-1 and x == 0:\\n                return True\\n            \\n            return check(i+1, j, x, memo) or check(i, j+1, x, memo)\\n    \\n        n, m = len(grid), len(grid[0])\\n\\t\\t\\n\\t\\t# if the path length is odd: return False\\n\\t\\t# if the first cell is ): return False\\n\\t\\t# if the last cell is (: return False\\n        if (n+m-1)%2 or grid[0][0] == \\')\\' or grid[-1][-1] == \\'(\\':\\n            return False\\n        \\n        return check(0, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021889,
                "title": "python-dp",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        n=len(grid)-1\\n        m=len(grid[0])-1\\n        @cache\\n        def dp(i,j,o):\\n            if i==n and j==m:return o==0\\n            ni=i+1\\n            if ni<=n:\\n                if grid[ni][j]==\"(\":\\n                    if dp(ni,j,o+1):return True\\n                elif (o-1)>=0:\\n                    if dp(ni,j,o-1):return True\\n            nj=j+1\\n            if nj<=m:\\n                if grid[i][nj]==\"(\":\\n                    if dp(i,nj,o+1):return True\\n                elif (o-1)>=0:\\n                    if dp(i,nj,o-1):return True\\n            return False\\n        if grid[0][0]!=\"(\":return False\\n        return dp(0,0,1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        n=len(grid)-1\\n        m=len(grid[0])-1\\n        @cache\\n        def dp(i,j,o):\\n            if i==n and j==m:return o==0\\n            ni=i+1\\n            if ni<=n:\\n                if grid[ni][j]==\"(\":\\n                    if dp(ni,j,o+1):return True\\n                elif (o-1)>=0:\\n                    if dp(ni,j,o-1):return True\\n            nj=j+1\\n            if nj<=m:\\n                if grid[i][nj]==\"(\":\\n                    if dp(i,nj,o+1):return True\\n                elif (o-1)>=0:\\n                    if dp(i,nj,o-1):return True\\n            return False\\n        if grid[0][0]!=\"(\":return False\\n        return dp(0,0,1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021334,
                "title": "dfs-dp",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint dp[101][101][1001],m,n;\\n\\n\\t\\tint path(vector<vector<char>>&grid, int i, int j,int total){\\n\\t\\t\\tif(i==n or j==m) return 0;\\n\\t\\t\\tgrid[i][j]==\\')\\'?total--:total++;\\n\\t\\t\\tif(total<0) return 0;\\n\\t\\t\\tif(i == n-1 and j == m-1) return total==0;\\n\\t\\t\\tif(dp[i][j][total]!=-1) return dp[i][j][total];\\n\\t\\t\\treturn dp[i][j][total] = path(grid,i+1,j,total) or path(grid,i,j+1,total);\\n\\t\\t}\\n\\n\\t\\tbool hasValidPath(vector<vector<char>>& grid) {\\n\\t\\t\\t memset(dp,-1,sizeof dp);\\n\\t\\t\\t n = grid.size();\\n\\t\\t\\t m = grid[0].size();\\n\\t\\t\\t if(grid[0][0]==\\')\\') return false;\\n\\t\\t\\t return path(grid,0,0,0);\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint dp[101][101][1001],m,n;\\n\\n\\t\\tint path(vector<vector<char>>&grid, int i, int j,int total){\\n\\t\\t\\tif(i==n or j==m) return 0;\\n\\t\\t\\tgrid[i][j]==\\')\\'?total--:total++;\\n\\t\\t\\tif(total<0) return 0;\\n\\t\\t\\tif(i == n-1 and j == m-1) return total==0;\\n\\t\\t\\tif(dp[i][j][total]!=-1) return dp[i][j][total];\\n\\t\\t\\treturn dp[i][j][total] = path(grid,i+1,j,total) or path(grid,i,j+1,total);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2021274,
                "title": "java-dp-solution",
                "content": "```\\nclass Solution {\\n    Boolean[][][] dp;\\n    public boolean valid(int r,  int c , int balance , char[][] grid){\\n        if(balance < 0) return false; // if closing brackets exceeds open then it can never be a valid path\\n        if(r == grid.length - 1 && c == grid[0].length - 1) return balance == 0; \\n        if(dp[r][c][balance] != null) return dp[r][c][balance];\\n        boolean res = false;\\n        if(r + 1 < grid.length){\\n            res |= valid(r + 1 , c , balance + (grid[r+1][c] == \\'(\\' ? 1 : -1) , grid);\\n        }\\n        if(c + 1 < grid[0].length){\\n            res |= valid(r, c + 1 , balance + (grid[r][c+1] == \\'(\\' ? 1 : -1) , grid);\\n        }\\n        dp[r][c][balance] = res;\\n        return res;\\n    }\\n    \\n    public boolean hasValidPath(char[][] grid) {\\n        if(grid[0][0] == \\')\\') return false; // if first character in path is ) then its not a valid path\\n        dp = new Boolean[101][101][202];\\n        return valid(0,0,1,grid);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    Boolean[][][] dp;\\n    public boolean valid(int r,  int c , int balance , char[][] grid){\\n        if(balance < 0) return false; // if closing brackets exceeds open then it can never be a valid path\\n        if(r == grid.length - 1 && c == grid[0].length - 1) return balance == 0; \\n        if(dp[r][c][balance] != null) return dp[r][c][balance];\\n        boolean res = false;\\n        if(r + 1 < grid.length){\\n            res |= valid(r + 1 , c , balance + (grid[r+1][c] == \\'(\\' ? 1 : -1) , grid);\\n        }\\n        if(c + 1 < grid[0].length){\\n            res |= valid(r, c + 1 , balance + (grid[r][c+1] == \\'(\\' ? 1 : -1) , grid);\\n        }\\n        dp[r][c][balance] = res;\\n        return res;\\n    }\\n    \\n    public boolean hasValidPath(char[][] grid) {\\n        if(grid[0][0] == \\')\\') return false; // if first character in path is ) then its not a valid path\\n        dp = new Boolean[101][101][202];\\n        return valid(0,0,1,grid);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020914,
                "title": "c-17-fast-and-easy-to-understand-bottom-up-dp-using-bitset-and-bit-shifts-in-60ms",
                "content": "### [C++17] fast and easy-to-understand Bottom-Up DP using bitset and bit-shifts, in ~60ms\\n\\n#### Approach and Ideas:\\n##### helper ideas:\\n* parenthesis-path-sum:\\n  Let `(` be +1, and `)` be `-1`, then the parenthesis path sum is a simple sum of these `+1`s\\n  and `-1`s.\\n* classification of paths wrt the parenthesis-path-sum:\\n  A path is invalid if its path-sum becomes negative.\\n  A path is perfect if its path-sum is 0.\\n  A path is quasi-valid if its path-sum is positive.\\n#### Core Ideas:\\n1. DP:\\nLet f[r][c] be the set of integers where each integer representing the parenthesis-path-sum of\\nsome path(s) from [0][0] to [r][c]. In other words, f maps [r][c] to bitset<N>.\\nIn the general case, we have:\\n f[r][c] =\\n     a) add one element-wise, to (f[r][c-1] U f[r-1][c]), if grid[r][c] == \\'(\\';\\n     b) subtract one element-wise, from (f[r][c-1] U f[r-1][c]), if grid[r][c] == \\')\\'; Note that\\n     here we\\'ll remove all negative parenthesis-path-sums because they are invalid paths.\\nThe original problem becomes checking whether 0 is in the set at f[m-1][n-1].\\n\\n2. Accelerating the computation by ~25X, using bitset<N>:\\n* Using bitset<N> instead of unordered_set<int> to represent the set of valid\\nparenthesis-path-sums.\\n* Using bitset\\'s left-shifts `<<` for the element-wise `+1` operation, and using right-shifts\\n`>>` for the element-wise `-1` operation, and using the xor `^` operation to clear the bits.\\n\\n3. There are several cases where we can return early. Please see the code for details.\\n\\n##### Running time:\\n* Using bitset<100>:        59ms ~ 63ms\\n* using unordered_set<int>: ~1500ms\\n\\n\\n```\\n// 2267. Check if There Is a Valid Parentheses String Path\\n// Approach and Ideas:\\n// helper ideas:\\n// * parenthesis-path-sum:\\n//   Let `(` be +1, and `)` be `-1`, then the parenthesis path sum is a simple sum of these `+1`s\\n//   and `-1`s.\\n// * classification of paths wrt the parenthesis-path-sum:\\n//   A path is invalid if its path-sum becomes negative.\\n//   A path is perfect if its path-sum is 0.\\n//   A path is quasi-valid if its path-sum is positive.\\n//\\n// Core Ideas:\\n// 1. DP:\\n// Let f[r][c] be the set of integers where each integer representing the parenthesis-path-sum of\\n// some path(s) from [0][0] to [r][c]. In other words, f maps [r][c] to bitset<N>.\\n// In the general case, we have:\\n//  f[r][c] =\\n//      a) add one element-wise, to (f[r][c-1] U f[r-1][c]), if grid[r][c] == \\'(\\';\\n//      b) subtract one element-wise, from (f[r][c-1] U f[r-1][c]), if grid[r][c] == \\')\\'; Note that\\n//      here we\\'ll remove all negative parenthesis-path-sums because they are invalid paths.\\n// The original problem becomes checking whether 0 is in the set at f[m-1][n-1].\\n//\\n// 2. Accelerating the computation by ~25X, using bitset<N>:\\n// * Using bitset<N> instead of unordered_set<int> to represent the set of valid\\n// parenthesis-path-sums.\\n// * Using bitset\\'s left-shifts `<<` for the element-wise `+1` operation, and using right-shifts\\n// `>>` for the element-wise `-1` operation, and using the xor `^` operation to clear the bits.\\n//\\n// Running times:\\n// * Using bitset<100>:        59ms ~ 63ms\\n// * using unordered_set<int>: ~1500ms\\nclass Solution { // DP with BitSets and Shifts ops\\n    // the problem constraint says that: 1 <= m, n <= 100.\\n    // so there are at most 100 left-parentheses in a valid path.\\n    // We can adjust this constant if the problem-size goes up.\\n    constexpr static int ProblemSize = 100;\\n    using BitSet = bitset<ProblemSize>;\\n\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        const int m = grid.size(), n = grid[0].size();\\n        const int maxPathLen = m + n - 1;\\n        if (maxPathLen & 1) { // if this is odd, it\\'s impossible to have valid parenthesis-path\\n            return false;\\n        }\\n\\n        // DP tables:\\n        // f is the `previous` row, g is the `current` row\\n        vector<BitSet> f(n), g(n);\\n        // initialize\\n        {\\n            if (ToNumeric(grid[0][0]) < 0) {\\n                return false; // if the starting point is invalid, all paths are invalid.\\n            }\\n            f[0][1] = true;\\n            for (int c = 1; c < n; ++c) {\\n                AddToEachElementAndRemoveInvalidElement(f[c - 1], ToNumeric(grid[0][c]), f[c]);\\n            }\\n        }\\n        // general cases for each row\\n        for (int r = 1; r < m; ++r) {\\n            // first element of the row\\n            AddToEachElementAndRemoveInvalidElement(f[0], ToNumeric(grid[r][0]), g[0]);\\n            bool allEmpty = (g[0].count() == 0);\\n            for (int c = 1; c < n; ++c) {\\n                int parenNumeric = ToNumeric(grid[r][c]);\\n                // paths from grid[r-1][c]\\n                AddToEachElementAndRemoveInvalidElement(f[c], parenNumeric, g[c]);\\n                // paths from grid[r][c-1]\\n                AddToEachElementAndRemoveInvalidElement(g[c - 1], parenNumeric, g[c]);\\n                allEmpty &= (g[c].count() == 0);\\n            }\\n            if (allEmpty) { // since this row is all empty, there won\\'t be valid path.\\n                return false; // so, return earlier.\\n            }\\n            g.swap(f);\\n            ClearEachSet(g);\\n        }\\n        // the set of the parenthesis-path-sums for the destination cell contains 0,\\n        // it means there is a valid parenthesis path.\\n        return f[n - 1][0];\\n    }\\n\\nprivate:\\n    static void ClearEachSet(vector<BitSet>& dpRow) {\\n        for (auto& theSet : dpRow) {\\n            theSet ^= theSet;\\n        }\\n    }\\n    static void AddToEachElementAndRemoveInvalidElement(\\n            const BitSet& originalSet,\\n            const int parenNumeric,\\n            BitSet& resultingSet) {\\n        if (parenNumeric == 1) { // +1: left-shift\\n            resultingSet |= (originalSet << 1);\\n        } else { // -1: right-shift\\n            resultingSet |= (originalSet >> 1);\\n        }\\n    }\\n\\n    static inline int ToNumeric(char parenthesis) {\\n        if (parenthesis == \\'(\\') {\\n            return 1;\\n        } else {\\n            return -1;\\n        }\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n// 2267. Check if There Is a Valid Parentheses String Path\\n// Approach and Ideas:\\n// helper ideas:\\n// * parenthesis-path-sum:\\n//   Let `(` be +1, and `)` be `-1`, then the parenthesis path sum is a simple sum of these `+1`s\\n//   and `-1`s.\\n// * classification of paths wrt the parenthesis-path-sum:\\n//   A path is invalid if its path-sum becomes negative.\\n//   A path is perfect if its path-sum is 0.\\n//   A path is quasi-valid if its path-sum is positive.\\n//\\n// Core Ideas:\\n// 1. DP:\\n// Let f[r][c] be the set of integers where each integer representing the parenthesis-path-sum of\\n// some path(s) from [0][0] to [r][c]. In other words, f maps [r][c] to bitset<N>.\\n// In the general case, we have:\\n//  f[r][c] =\\n//      a) add one element-wise, to (f[r][c-1] U f[r-1][c]), if grid[r][c] == \\'(\\';\\n//      b) subtract one element-wise, from (f[r][c-1] U f[r-1][c]), if grid[r][c] == \\')\\'; Note that\\n//      here we\\'ll remove all negative parenthesis-path-sums because they are invalid paths.\\n// The original problem becomes checking whether 0 is in the set at f[m-1][n-1].\\n//\\n// 2. Accelerating the computation by ~25X, using bitset<N>:\\n// * Using bitset<N> instead of unordered_set<int> to represent the set of valid\\n// parenthesis-path-sums.\\n// * Using bitset\\'s left-shifts `<<` for the element-wise `+1` operation, and using right-shifts\\n// `>>` for the element-wise `-1` operation, and using the xor `^` operation to clear the bits.\\n//\\n// Running times:\\n// * Using bitset<100>:        59ms ~ 63ms\\n// * using unordered_set<int>: ~1500ms\\nclass Solution { // DP with BitSets and Shifts ops\\n    // the problem constraint says that: 1 <= m, n <= 100.\\n    // so there are at most 100 left-parentheses in a valid path.\\n    // We can adjust this constant if the problem-size goes up.\\n    constexpr static int ProblemSize = 100;\\n    using BitSet = bitset<ProblemSize>;\\n\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        const int m = grid.size(), n = grid[0].size();\\n        const int maxPathLen = m + n - 1;\\n        if (maxPathLen & 1) { // if this is odd, it\\'s impossible to have valid parenthesis-path\\n            return false;\\n        }\\n\\n        // DP tables:\\n        // f is the `previous` row, g is the `current` row\\n        vector<BitSet> f(n), g(n);\\n        // initialize\\n        {\\n            if (ToNumeric(grid[0][0]) < 0) {\\n                return false; // if the starting point is invalid, all paths are invalid.\\n            }\\n            f[0][1] = true;\\n            for (int c = 1; c < n; ++c) {\\n                AddToEachElementAndRemoveInvalidElement(f[c - 1], ToNumeric(grid[0][c]), f[c]);\\n            }\\n        }\\n        // general cases for each row\\n        for (int r = 1; r < m; ++r) {\\n            // first element of the row\\n            AddToEachElementAndRemoveInvalidElement(f[0], ToNumeric(grid[r][0]), g[0]);\\n            bool allEmpty = (g[0].count() == 0);\\n            for (int c = 1; c < n; ++c) {\\n                int parenNumeric = ToNumeric(grid[r][c]);\\n                // paths from grid[r-1][c]\\n                AddToEachElementAndRemoveInvalidElement(f[c], parenNumeric, g[c]);\\n                // paths from grid[r][c-1]\\n                AddToEachElementAndRemoveInvalidElement(g[c - 1], parenNumeric, g[c]);\\n                allEmpty &= (g[c].count() == 0);\\n            }\\n            if (allEmpty) { // since this row is all empty, there won\\'t be valid path.\\n                return false; // so, return earlier.\\n            }\\n            g.swap(f);\\n            ClearEachSet(g);\\n        }\\n        // the set of the parenthesis-path-sums for the destination cell contains 0,\\n        // it means there is a valid parenthesis path.\\n        return f[n - 1][0];\\n    }\\n\\nprivate:\\n    static void ClearEachSet(vector<BitSet>& dpRow) {\\n        for (auto& theSet : dpRow) {\\n            theSet ^= theSet;\\n        }\\n    }\\n    static void AddToEachElementAndRemoveInvalidElement(\\n            const BitSet& originalSet,\\n            const int parenNumeric,\\n            BitSet& resultingSet) {\\n        if (parenNumeric == 1) { // +1: left-shift\\n            resultingSet |= (originalSet << 1);\\n        } else { // -1: right-shift\\n            resultingSet |= (originalSet >> 1);\\n        }\\n    }\\n\\n    static inline int ToNumeric(char parenthesis) {\\n        if (parenthesis == \\'(\\') {\\n            return 1;\\n        } else {\\n            return -1;\\n        }\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020643,
                "title": "python-3-dp-with-pruning",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        \\n        m, n = len(grid), len(grid[0])\\n        if grid[0][0] == \\')\\' or (m + n - 1) % 2: return False\\n        \\n        @lru_cache(None)\\n        def dp(x, y, ops):\\n\\t\\t\\t# if unpaired close bracket or remaining cannot match open brackets\\n            if ops < 0 or ops > (m + n - 1) // 2: return False\\n            if x == m - 1 and y == n - 1:\\n                return not ops\\n            \\n            for dx, dy in [(0, 1), (1, 0)]:\\n                nx, ny = x + dx, y + dy\\n                if not(0 <= nx < m and 0 <= ny < n): continue\\n                tmp = 1 if grid[nx][ny] == \\'(\\' else -1\\n                if dp(nx, ny, ops + tmp):\\n                    return True\\n            return False\\n        \\n        \\n        return dp(0, 0, 1)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        \\n        m, n = len(grid), len(grid[0])\\n        if grid[0][0] == \\')\\' or (m + n - 1) % 2: return False\\n        \\n        @lru_cache(None)\\n        def dp(x, y, ops):\\n\\t\\t\\t# if unpaired close bracket or remaining cannot match open brackets\\n            if ops < 0 or ops > (m + n - 1) // 2: return False\\n            if x == m - 1 and y == n - 1:\\n                return not ops\\n            \\n            for dx, dy in [(0, 1), (1, 0)]:\\n                nx, ny = x + dx, y + dy\\n                if not(0 <= nx < m and 0 <= ny < n): continue\\n                tmp = 1 if grid[nx][ny] == \\'(\\' else -1\\n                if dp(nx, ny, ops + tmp):\\n                    return True\\n            return False\\n        \\n        \\n        return dp(0, 0, 1)",
                "codeTag": "Java"
            },
            {
                "id": 2020499,
                "title": "java-dp-o-mn-m-n-2",
                "content": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int MID = (row + col + 1) / 2;\\n        if(grid[0][0] != \\'(\\' || grid[row - 1][col - 1] != \\')\\') return false;\\n        boolean[][][] dp = new boolean[row][col][MID + 1];\\n        dp[0][0][1] = true;\\n        for(int i = 1; i < row; i++) {\\n            for(int j = 0; j <= MID; j++) {\\n                if(grid[i][0] == \\'(\\' && j - 1 >= 0) {\\n                    dp[i][0][j] = dp[i - 1][0][j - 1];\\n                }\\n                else if(grid[i][0] == \\')\\' && j + 1 <= MID) {\\n                    dp[i][0][j] = dp[i - 1][0][j + 1];\\n                }\\n            }\\n        }\\n        \\n        for(int i = 1; i < col; i++) {\\n            for(int j = 0; j <= MID; j++) {\\n                if(grid[0][i] == \\'(\\' && j - 1 >= 0) {\\n                    dp[0][i][j] = dp[0][i - 1][j - 1];\\n                }\\n                else if(grid[0][i] == \\')\\' && j + 1 <= MID) {\\n                    dp[0][i][j] = dp[0][i - 1][j + 1];\\n                }\\n            }\\n        }\\n        \\n        for(int i = 1; i < row; i++) {\\n            for(int j = 1; j < col; j++) {\\n                for(int k = 0; k <= MID; k++) {\\n                    if(grid[i][j] == \\'(\\' && k - 1 >= 0) {\\n                        dp[i][j][k] = dp[i - 1][j][k - 1] || dp[i][j - 1][k - 1];\\n                    }\\n                    else if(grid[i][j] == \\')\\' && k + 1 <= MID) {\\n                        dp[i][j][k] = dp[i - 1][j][k + 1] || dp[i][j - 1][k + 1];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[row - 1][col - 1][0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int MID = (row + col + 1) / 2;\\n        if(grid[0][0] != \\'(\\' || grid[row - 1][col - 1] != \\')\\') return false;\\n        boolean[][][] dp = new boolean[row][col][MID + 1];\\n        dp[0][0][1] = true;\\n        for(int i = 1; i < row; i++) {\\n            for(int j = 0; j <= MID; j++) {\\n                if(grid[i][0] == \\'(\\' && j - 1 >= 0) {\\n                    dp[i][0][j] = dp[i - 1][0][j - 1];\\n                }\\n                else if(grid[i][0] == \\')\\' && j + 1 <= MID) {\\n                    dp[i][0][j] = dp[i - 1][0][j + 1];\\n                }\\n            }\\n        }\\n        \\n        for(int i = 1; i < col; i++) {\\n            for(int j = 0; j <= MID; j++) {\\n                if(grid[0][i] == \\'(\\' && j - 1 >= 0) {\\n                    dp[0][i][j] = dp[0][i - 1][j - 1];\\n                }\\n                else if(grid[0][i] == \\')\\' && j + 1 <= MID) {\\n                    dp[0][i][j] = dp[0][i - 1][j + 1];\\n                }\\n            }\\n        }\\n        \\n        for(int i = 1; i < row; i++) {\\n            for(int j = 1; j < col; j++) {\\n                for(int k = 0; k <= MID; k++) {\\n                    if(grid[i][j] == \\'(\\' && k - 1 >= 0) {\\n                        dp[i][j][k] = dp[i - 1][j][k - 1] || dp[i][j - 1][k - 1];\\n                    }\\n                    else if(grid[i][j] == \\')\\' && k + 1 <= MID) {\\n                        dp[i][j][k] = dp[i - 1][j][k + 1] || dp[i][j - 1][k + 1];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[row - 1][col - 1][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020475,
                "title": "my-c-solution-time-space-beat-100",
                "content": "A \\'(\\' will add the count by 1, and a \\')\\' will decrease the count by 1.\\nTrack whether a certain position in the matrix with a certain count has been visited or not to prune the dfs.\\n\\n```\\nclass Solution {\\nprivate:\\n    bool v[100][100][100];\\n    \\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        return dfs(grid, 0, 0, 0);\\n    }\\n    \\n    bool dfs(vector<vector<char>>& grid, int i, int j, int cnt) {\\n        if (i >= grid.size() || j >= grid[0].size()) {\\n            return false;\\n        }\\n        \\n        cnt += (grid[i][j] == \\'(\\' ? 1 : -1);\\n        \\n        if (cnt < 0 || cnt >= 100 || v[i][j][cnt]) {\\n            return false;\\n        }\\n                \\n        if (i == grid.size()-1 && j == grid[0].size()-1 && cnt == 0) {\\n            return true;\\n        }\\n        \\n        if (dfs(grid, i, j+1, cnt) || dfs(grid, i+1, j, cnt)) {\\n            return true;\\n        }\\n        else {\\n            v[i][j][cnt] = true;\\n            return false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool v[100][100][100];\\n    \\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        return dfs(grid, 0, 0, 0);\\n    }\\n    \\n    bool dfs(vector<vector<char>>& grid, int i, int j, int cnt) {\\n        if (i >= grid.size() || j >= grid[0].size()) {\\n            return false;\\n        }\\n        \\n        cnt += (grid[i][j] == \\'(\\' ? 1 : -1);\\n        \\n        if (cnt < 0 || cnt >= 100 || v[i][j][cnt]) {\\n            return false;\\n        }\\n                \\n        if (i == grid.size()-1 && j == grid[0].size()-1 && cnt == 0) {\\n            return true;\\n        }\\n        \\n        if (dfs(grid, i, j+1, cnt) || dfs(grid, i+1, j, cnt)) {\\n            return true;\\n        }\\n        else {\\n            v[i][j][cnt] = true;\\n            return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020462,
                "title": "java-from-recursion-memoization-easy",
                "content": "Recursion-->>\\n\\n```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        if(grid[0][0] == \\')\\' || grid[grid.length-1][grid[0].length-1]==\\'(\\')return false;\\n        return solve(0,0,grid,0);\\n    }\\n    public boolean solve(int i, int j ,char[][] grid,int open){\\n        if(i>=grid.length || j>=grid[0].length)return false;\\n        open += grid[i][j] == \\'(\\' ? 1 : -1;\\n        if(open<0) return false;\\n        if(i==grid.length-1 && j==grid[0].length-1){\\n            if(open==0)\\n            return true;\\n        }\\n        \\n        \\n        \\n        if( solve(i+1,j,grid,open))\\n            return true;\\n        if( solve(i,j+1,grid,open))\\n            return true;\\n            \\n        return false;\\n        }\\n}\\n```\\n\\nMemoization -->>\\n\\n```\\nclass Solution {\\n\\n    public boolean hasValidPath(char[][] grid) {\\n        if (grid[0][0] == \\')\\' || grid[grid.length - 1][grid[0].length - 1] == \\'(\\') return false;\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        Boolean[][][] dp = new Boolean[n][m][n + m];\\n        return solve(0, 0, grid, 0, dp);\\n    }\\n\\n    public boolean solve(int i, int j, char[][] grid, int open, Boolean[][][] dp) {\\n        if (i >= grid.length || j >= grid[0].length) return false;\\n\\n        open += grid[i][j] == \\'(\\' ? 1 : -1;\\n        if (open < 0) return false;\\n\\n        if (i == grid.length - 1 && j == grid[0].length - 1) {\\n            if (open == 0) return true;\\n        }\\n        if (dp[i][j][open] != null) return dp[i][j][open];\\n\\n        if (solve(i + 1, j, grid, open, dp)) {\\n            return dp[i][j][open] = true;\\n        }\\n        if (solve(i, j + 1, grid, open, dp)) {\\n            return dp[i][j][open] = true;\\n        }\\n\\n        return dp[i][j][open] = false;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        if(grid[0][0] == \\')\\' || grid[grid.length-1][grid[0].length-1]==\\'(\\')return false;\\n        return solve(0,0,grid,0);\\n    }\\n    public boolean solve(int i, int j ,char[][] grid,int open){\\n        if(i>=grid.length || j>=grid[0].length)return false;\\n        open += grid[i][j] == \\'(\\' ? 1 : -1;\\n        if(open<0) return false;\\n        if(i==grid.length-1 && j==grid[0].length-1){\\n            if(open==0)\\n            return true;\\n        }\\n        \\n        \\n        \\n        if( solve(i+1,j,grid,open))\\n            return true;\\n        if( solve(i,j+1,grid,open))\\n            return true;\\n            \\n        return false;\\n        }\\n}\\n```\n```\\nclass Solution {\\n\\n    public boolean hasValidPath(char[][] grid) {\\n        if (grid[0][0] == \\')\\' || grid[grid.length - 1][grid[0].length - 1] == \\'(\\') return false;\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        Boolean[][][] dp = new Boolean[n][m][n + m];\\n        return solve(0, 0, grid, 0, dp);\\n    }\\n\\n    public boolean solve(int i, int j, char[][] grid, int open, Boolean[][][] dp) {\\n        if (i >= grid.length || j >= grid[0].length) return false;\\n\\n        open += grid[i][j] == \\'(\\' ? 1 : -1;\\n        if (open < 0) return false;\\n\\n        if (i == grid.length - 1 && j == grid[0].length - 1) {\\n            if (open == 0) return true;\\n        }\\n        if (dp[i][j][open] != null) return dp[i][j][open];\\n\\n        if (solve(i + 1, j, grid, open, dp)) {\\n            return dp[i][j][open] = true;\\n        }\\n        if (solve(i, j + 1, grid, open, dp)) {\\n            return dp[i][j][open] = true;\\n        }\\n\\n        return dp[i][j][open] = false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020399,
                "title": "c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        int i, j, k;\\n        vector<vector<vector<bool>>> dp(rows, vector<vector<bool>> (cols, vector<bool> (rows + cols)));\\n        \\n        if(grid[0][0] == \\')\\' || grid[rows - 1][cols - 1] == \\'(\\'){\\n            return false;\\n        }\\n        \\n        dp[0][0][1] = true;\\n        for(i = 1; i < cols; i++){\\n            if(grid[0][i] == \\')\\'){\\n                for(j = 0; j < rows + cols - 1; j++){\\n                    dp[0][i][j] = dp[0][i - 1][j + 1];\\n                }\\n            }\\n            else{\\n                for(j = 1; j < rows + cols; j++){\\n                    dp[0][i][j] = dp[0][i - 1][j - 1];\\n                }\\n            }\\n        }\\n        \\n        for(i = 1; i < rows; i++){\\n            if(grid[i][0] == \\')\\'){\\n                for(j = 0; j < rows + cols - 1; j++){\\n                    dp[i][0][j] = dp[i - 1][0][j + 1];\\n                }\\n            }\\n            else{\\n                for(j = 1; j < rows + cols; j++){\\n                    dp[i][0][j] = dp[i - 1][0][j - 1];\\n                }\\n            }\\n        }\\n                \\n        for(i = 1; i < rows; i++){\\n            for(j = 1; j < cols; j++){\\n                if(grid[i][j] == \\')\\'){\\n                    for(k = 0; k < rows + cols - 1; k++){\\n                        dp[i][j][k] = dp[i][j - 1][k + 1] || dp[i - 1][j][k + 1];\\n                    }\\n                }\\n                else{\\n                    for(k = 1; k < rows + cols; k++){\\n                        dp[i][j][k] = dp[i][j - 1][k - 1] || dp[i - 1][j][k - 1];\\n                    }\\n                }\\n            }\\n        }\\n        return dp[rows - 1][cols - 1][0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        int i, j, k;\\n        vector<vector<vector<bool>>> dp(rows, vector<vector<bool>> (cols, vector<bool> (rows + cols)));\\n        \\n        if(grid[0][0] == \\')\\' || grid[rows - 1][cols - 1] == \\'(\\'){\\n            return false;\\n        }\\n        \\n        dp[0][0][1] = true;\\n        for(i = 1; i < cols; i++){\\n            if(grid[0][i] == \\')\\'){\\n                for(j = 0; j < rows + cols - 1; j++){\\n                    dp[0][i][j] = dp[0][i - 1][j + 1];\\n                }\\n            }\\n            else{\\n                for(j = 1; j < rows + cols; j++){\\n                    dp[0][i][j] = dp[0][i - 1][j - 1];\\n                }\\n            }\\n        }\\n        \\n        for(i = 1; i < rows; i++){\\n            if(grid[i][0] == \\')\\'){\\n                for(j = 0; j < rows + cols - 1; j++){\\n                    dp[i][0][j] = dp[i - 1][0][j + 1];\\n                }\\n            }\\n            else{\\n                for(j = 1; j < rows + cols; j++){\\n                    dp[i][0][j] = dp[i - 1][0][j - 1];\\n                }\\n            }\\n        }\\n                \\n        for(i = 1; i < rows; i++){\\n            for(j = 1; j < cols; j++){\\n                if(grid[i][j] == \\')\\'){\\n                    for(k = 0; k < rows + cols - 1; k++){\\n                        dp[i][j][k] = dp[i][j - 1][k + 1] || dp[i - 1][j][k + 1];\\n                    }\\n                }\\n                else{\\n                    for(k = 1; k < rows + cols; k++){\\n                        dp[i][j][k] = dp[i][j - 1][k - 1] || dp[i - 1][j][k - 1];\\n                    }\\n                }\\n            }\\n        }\\n        return dp[rows - 1][cols - 1][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576750,
                "content": [
                    {
                        "username": "StormAlex",
                        "content": "**How to read my post?**\\nJust match the Diagram number with the number mentioned in code.\\n\\nVariables used **r** =Total  rows, **c** = total columns, **x,y** are coordinates and **count** = No of opening brackets visited\\n\\n**Thought Process**\\n![image](https://assets.leetcode.com/users/images/64229d1d-1631-4f04-ba0c-b139882099d0_1652527273.4110048.png)\\n\\n**Let\\'s connect the thought with code:**\\n*Note: Thanks to @LarryNY for a easily understandable python code*\\n![image](https://assets.leetcode.com/users/images/1cee98cd-f0bb-4eb1-8396-c70ea0b82268_1652527350.5416386.png)\\n\\n**Important point:** @cache is a decorator in python which helps to memoize the recursive function. Without that decorator this code will give TLE. You can always try to memoize it in your own way.\\n\\n"
                    },
                    {
                        "username": "VVHack",
                        "content": "I tried solving this using BFS + caching and DFS + caching, DFS was much faster. Why was DFS faster? Is it because BFS tries to run all paths at the same time and find the shortest whereas DFS just looks for any valid path?"
                    },
                    {
                        "username": "taakasj",
                        "content": "There are many wrong test cases for this question.\\nFor ex: The expected output for input [[\"(\",\"(\"]] is \\'true\\' but the accepted response should be \\'false\\'\\n\\nAnother example : [[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\"],[\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\"],[\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\"],[\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\"]] \\n\\nThe expected answer is \\'false\\' but correct answer should be \\'true\\'.\\n\\nIs everyone facing the same issue ?"
                    },
                    {
                        "username": "enigmaHere",
                        "content": "why is this approach not working\\n\\nclass Solution {\\n    public boolean hasValidPath(char[][] arr) {\\n        int r = arr.length;\\n        int c = arr[0].length;\\n        Byte dp[][] = new Byte[r][c];\\n        Stack<Character> stack = new Stack<Character>();\\n        if(arr[0][0] == \\'(\\')\\n            stack.push(\\'(\\');\\n        else\\n            return false;\\n        rec(arr,r,c,0,0,dp,stack);\\n        return (dp[0][0] == 0)? false : true;\\n\\n        // return dynamic(arr);\\n    }\\n\\n    Byte rec(char[][] arr,int r,int c,int x , int y,Byte[][] dp,Stack<Character> stack){\\n        if(x == r-1 && y == c-1)\\n            return (stack.empty())? (byte)1 : (byte)0;\\n        \\n        if(dp[x][y] != null)\\n            return dp[x][y];\\n\\n        byte right = 0,down = 0;\\n        //move right\\n        if(y < c-1){\\n            char ch = arr[x][y+1];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n\\n        //move down\\n        if(x < r-1){\\n            char ch = arr[x+1][y];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n        return dp[x][y] = (byte)Math.max((int)right , (int)down);\\n    }\\n\\n}"
                    },
                    {
                        "username": "bigfatcoder",
                        "content": "This is a classic medium problem. Shouldn\\'t be labelled as hard."
                    },
                    {
                        "username": "themaniac",
                        "content": "Why is this solution not accepted?\nI got TLE for it but others who have a similar solution got accepted?\nPlease let me know..\n\n `\nclass Solution {\npublic:\n    int dp[101][101][201];\n    bool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\n        \n        if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==')') {\n            return true;\n        }\n        if(i==grid.size() || j == grid[0].size()) return false;\n        \n        if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\n        \n        if (grid[i][j] == '(')\n            lefts++;\n        else if(grid[i][j]==')' && lefts>0)\n            lefts--;\n        else \n            return dp[i][j][lefts]=false;\n        \n        bool found = false;\n        if(i+1<grid.size())\n            found |= recurse( grid, i+1, j, lefts);\n        if(j+1<grid[0].size())\n            found |= recurse( grid, i, j+1, lefts);\n        \n        return dp[i][j][lefts]=found;\n            \n    }\n    bool hasValidPath(vector<vector<char>>& grid) {\n        memset(dp, -1, sizeof(dp));\n        return recurse(grid, 0, 0, 0);     \n    }\n};\n`"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "[@user7613o](/user7613o) Memoization does work"
                    },
                    {
                        "username": "vishal-",
                        "content": "You are modifying lefts and storing result in dp[i][j][lefts].\\n\\nUse a temp variable to store lefts before modfying.\\n\\n```\\nclass Solution {\\npublic:\\nint dp[101][101][201];\\nbool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\\n\\n    if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==\\')\\') {\\n        return true;\\n    }\\n    if(i==grid.size() || j == grid[0].size()) return false;\\n    \\n    if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\\n    \\n    // We can\\'t use dp[i][j][lefts] as we are modifying lefts,\\n    // store lefts value in another variable.\\n    int prev_lefts = lefts;\\n\\n    if (grid[i][j] == \\'(\\')\\n        lefts++;\\n    else if(grid[i][j]==\\')\\' && lefts>0)\\n        lefts--;\\n    else \\n        return dp[i][j][prev_lefts]=false;\\n    \\n    bool found = false;\\n    if(i+1<grid.size())\\n        found |= recurse( grid, i+1, j, lefts);\\n    if(j+1<grid[0].size())\\n        found |= recurse( grid, i, j+1, lefts);\\n    \\n    return dp[i][j][prev_lefts]=found;\\n        \\n}\\nbool hasValidPath(vector<vector<char>>& grid) {\\n    memset(dp, -1, sizeof(dp));\\n    return recurse(grid, 0, 0, 0);     \\n}\\n};\\n```"
                    },
                    {
                        "username": "user7613o",
                        "content": "bro memoization does not work in this qn you have to try tabulation form \\n"
                    }
                ]
            },
            {
                "id": 1570877,
                "content": [
                    {
                        "username": "StormAlex",
                        "content": "**How to read my post?**\\nJust match the Diagram number with the number mentioned in code.\\n\\nVariables used **r** =Total  rows, **c** = total columns, **x,y** are coordinates and **count** = No of opening brackets visited\\n\\n**Thought Process**\\n![image](https://assets.leetcode.com/users/images/64229d1d-1631-4f04-ba0c-b139882099d0_1652527273.4110048.png)\\n\\n**Let\\'s connect the thought with code:**\\n*Note: Thanks to @LarryNY for a easily understandable python code*\\n![image](https://assets.leetcode.com/users/images/1cee98cd-f0bb-4eb1-8396-c70ea0b82268_1652527350.5416386.png)\\n\\n**Important point:** @cache is a decorator in python which helps to memoize the recursive function. Without that decorator this code will give TLE. You can always try to memoize it in your own way.\\n\\n"
                    },
                    {
                        "username": "VVHack",
                        "content": "I tried solving this using BFS + caching and DFS + caching, DFS was much faster. Why was DFS faster? Is it because BFS tries to run all paths at the same time and find the shortest whereas DFS just looks for any valid path?"
                    },
                    {
                        "username": "taakasj",
                        "content": "There are many wrong test cases for this question.\\nFor ex: The expected output for input [[\"(\",\"(\"]] is \\'true\\' but the accepted response should be \\'false\\'\\n\\nAnother example : [[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\"],[\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\"],[\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\"],[\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\"]] \\n\\nThe expected answer is \\'false\\' but correct answer should be \\'true\\'.\\n\\nIs everyone facing the same issue ?"
                    },
                    {
                        "username": "enigmaHere",
                        "content": "why is this approach not working\\n\\nclass Solution {\\n    public boolean hasValidPath(char[][] arr) {\\n        int r = arr.length;\\n        int c = arr[0].length;\\n        Byte dp[][] = new Byte[r][c];\\n        Stack<Character> stack = new Stack<Character>();\\n        if(arr[0][0] == \\'(\\')\\n            stack.push(\\'(\\');\\n        else\\n            return false;\\n        rec(arr,r,c,0,0,dp,stack);\\n        return (dp[0][0] == 0)? false : true;\\n\\n        // return dynamic(arr);\\n    }\\n\\n    Byte rec(char[][] arr,int r,int c,int x , int y,Byte[][] dp,Stack<Character> stack){\\n        if(x == r-1 && y == c-1)\\n            return (stack.empty())? (byte)1 : (byte)0;\\n        \\n        if(dp[x][y] != null)\\n            return dp[x][y];\\n\\n        byte right = 0,down = 0;\\n        //move right\\n        if(y < c-1){\\n            char ch = arr[x][y+1];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n\\n        //move down\\n        if(x < r-1){\\n            char ch = arr[x+1][y];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n        return dp[x][y] = (byte)Math.max((int)right , (int)down);\\n    }\\n\\n}"
                    },
                    {
                        "username": "bigfatcoder",
                        "content": "This is a classic medium problem. Shouldn\\'t be labelled as hard."
                    },
                    {
                        "username": "themaniac",
                        "content": "Why is this solution not accepted?\nI got TLE for it but others who have a similar solution got accepted?\nPlease let me know..\n\n `\nclass Solution {\npublic:\n    int dp[101][101][201];\n    bool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\n        \n        if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==')') {\n            return true;\n        }\n        if(i==grid.size() || j == grid[0].size()) return false;\n        \n        if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\n        \n        if (grid[i][j] == '(')\n            lefts++;\n        else if(grid[i][j]==')' && lefts>0)\n            lefts--;\n        else \n            return dp[i][j][lefts]=false;\n        \n        bool found = false;\n        if(i+1<grid.size())\n            found |= recurse( grid, i+1, j, lefts);\n        if(j+1<grid[0].size())\n            found |= recurse( grid, i, j+1, lefts);\n        \n        return dp[i][j][lefts]=found;\n            \n    }\n    bool hasValidPath(vector<vector<char>>& grid) {\n        memset(dp, -1, sizeof(dp));\n        return recurse(grid, 0, 0, 0);     \n    }\n};\n`"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "[@user7613o](/user7613o) Memoization does work"
                    },
                    {
                        "username": "vishal-",
                        "content": "You are modifying lefts and storing result in dp[i][j][lefts].\\n\\nUse a temp variable to store lefts before modfying.\\n\\n```\\nclass Solution {\\npublic:\\nint dp[101][101][201];\\nbool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\\n\\n    if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==\\')\\') {\\n        return true;\\n    }\\n    if(i==grid.size() || j == grid[0].size()) return false;\\n    \\n    if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\\n    \\n    // We can\\'t use dp[i][j][lefts] as we are modifying lefts,\\n    // store lefts value in another variable.\\n    int prev_lefts = lefts;\\n\\n    if (grid[i][j] == \\'(\\')\\n        lefts++;\\n    else if(grid[i][j]==\\')\\' && lefts>0)\\n        lefts--;\\n    else \\n        return dp[i][j][prev_lefts]=false;\\n    \\n    bool found = false;\\n    if(i+1<grid.size())\\n        found |= recurse( grid, i+1, j, lefts);\\n    if(j+1<grid[0].size())\\n        found |= recurse( grid, i, j+1, lefts);\\n    \\n    return dp[i][j][prev_lefts]=found;\\n        \\n}\\nbool hasValidPath(vector<vector<char>>& grid) {\\n    memset(dp, -1, sizeof(dp));\\n    return recurse(grid, 0, 0, 0);     \\n}\\n};\\n```"
                    },
                    {
                        "username": "user7613o",
                        "content": "bro memoization does not work in this qn you have to try tabulation form \\n"
                    }
                ]
            },
            {
                "id": 1576729,
                "content": [
                    {
                        "username": "StormAlex",
                        "content": "**How to read my post?**\\nJust match the Diagram number with the number mentioned in code.\\n\\nVariables used **r** =Total  rows, **c** = total columns, **x,y** are coordinates and **count** = No of opening brackets visited\\n\\n**Thought Process**\\n![image](https://assets.leetcode.com/users/images/64229d1d-1631-4f04-ba0c-b139882099d0_1652527273.4110048.png)\\n\\n**Let\\'s connect the thought with code:**\\n*Note: Thanks to @LarryNY for a easily understandable python code*\\n![image](https://assets.leetcode.com/users/images/1cee98cd-f0bb-4eb1-8396-c70ea0b82268_1652527350.5416386.png)\\n\\n**Important point:** @cache is a decorator in python which helps to memoize the recursive function. Without that decorator this code will give TLE. You can always try to memoize it in your own way.\\n\\n"
                    },
                    {
                        "username": "VVHack",
                        "content": "I tried solving this using BFS + caching and DFS + caching, DFS was much faster. Why was DFS faster? Is it because BFS tries to run all paths at the same time and find the shortest whereas DFS just looks for any valid path?"
                    },
                    {
                        "username": "taakasj",
                        "content": "There are many wrong test cases for this question.\\nFor ex: The expected output for input [[\"(\",\"(\"]] is \\'true\\' but the accepted response should be \\'false\\'\\n\\nAnother example : [[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\"],[\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\"],[\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\"],[\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\"]] \\n\\nThe expected answer is \\'false\\' but correct answer should be \\'true\\'.\\n\\nIs everyone facing the same issue ?"
                    },
                    {
                        "username": "enigmaHere",
                        "content": "why is this approach not working\\n\\nclass Solution {\\n    public boolean hasValidPath(char[][] arr) {\\n        int r = arr.length;\\n        int c = arr[0].length;\\n        Byte dp[][] = new Byte[r][c];\\n        Stack<Character> stack = new Stack<Character>();\\n        if(arr[0][0] == \\'(\\')\\n            stack.push(\\'(\\');\\n        else\\n            return false;\\n        rec(arr,r,c,0,0,dp,stack);\\n        return (dp[0][0] == 0)? false : true;\\n\\n        // return dynamic(arr);\\n    }\\n\\n    Byte rec(char[][] arr,int r,int c,int x , int y,Byte[][] dp,Stack<Character> stack){\\n        if(x == r-1 && y == c-1)\\n            return (stack.empty())? (byte)1 : (byte)0;\\n        \\n        if(dp[x][y] != null)\\n            return dp[x][y];\\n\\n        byte right = 0,down = 0;\\n        //move right\\n        if(y < c-1){\\n            char ch = arr[x][y+1];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n\\n        //move down\\n        if(x < r-1){\\n            char ch = arr[x+1][y];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n        return dp[x][y] = (byte)Math.max((int)right , (int)down);\\n    }\\n\\n}"
                    },
                    {
                        "username": "bigfatcoder",
                        "content": "This is a classic medium problem. Shouldn\\'t be labelled as hard."
                    },
                    {
                        "username": "themaniac",
                        "content": "Why is this solution not accepted?\nI got TLE for it but others who have a similar solution got accepted?\nPlease let me know..\n\n `\nclass Solution {\npublic:\n    int dp[101][101][201];\n    bool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\n        \n        if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==')') {\n            return true;\n        }\n        if(i==grid.size() || j == grid[0].size()) return false;\n        \n        if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\n        \n        if (grid[i][j] == '(')\n            lefts++;\n        else if(grid[i][j]==')' && lefts>0)\n            lefts--;\n        else \n            return dp[i][j][lefts]=false;\n        \n        bool found = false;\n        if(i+1<grid.size())\n            found |= recurse( grid, i+1, j, lefts);\n        if(j+1<grid[0].size())\n            found |= recurse( grid, i, j+1, lefts);\n        \n        return dp[i][j][lefts]=found;\n            \n    }\n    bool hasValidPath(vector<vector<char>>& grid) {\n        memset(dp, -1, sizeof(dp));\n        return recurse(grid, 0, 0, 0);     \n    }\n};\n`"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "[@user7613o](/user7613o) Memoization does work"
                    },
                    {
                        "username": "vishal-",
                        "content": "You are modifying lefts and storing result in dp[i][j][lefts].\\n\\nUse a temp variable to store lefts before modfying.\\n\\n```\\nclass Solution {\\npublic:\\nint dp[101][101][201];\\nbool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\\n\\n    if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==\\')\\') {\\n        return true;\\n    }\\n    if(i==grid.size() || j == grid[0].size()) return false;\\n    \\n    if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\\n    \\n    // We can\\'t use dp[i][j][lefts] as we are modifying lefts,\\n    // store lefts value in another variable.\\n    int prev_lefts = lefts;\\n\\n    if (grid[i][j] == \\'(\\')\\n        lefts++;\\n    else if(grid[i][j]==\\')\\' && lefts>0)\\n        lefts--;\\n    else \\n        return dp[i][j][prev_lefts]=false;\\n    \\n    bool found = false;\\n    if(i+1<grid.size())\\n        found |= recurse( grid, i+1, j, lefts);\\n    if(j+1<grid[0].size())\\n        found |= recurse( grid, i, j+1, lefts);\\n    \\n    return dp[i][j][prev_lefts]=found;\\n        \\n}\\nbool hasValidPath(vector<vector<char>>& grid) {\\n    memset(dp, -1, sizeof(dp));\\n    return recurse(grid, 0, 0, 0);     \\n}\\n};\\n```"
                    },
                    {
                        "username": "user7613o",
                        "content": "bro memoization does not work in this qn you have to try tabulation form \\n"
                    }
                ]
            },
            {
                "id": 2072858,
                "content": [
                    {
                        "username": "StormAlex",
                        "content": "**How to read my post?**\\nJust match the Diagram number with the number mentioned in code.\\n\\nVariables used **r** =Total  rows, **c** = total columns, **x,y** are coordinates and **count** = No of opening brackets visited\\n\\n**Thought Process**\\n![image](https://assets.leetcode.com/users/images/64229d1d-1631-4f04-ba0c-b139882099d0_1652527273.4110048.png)\\n\\n**Let\\'s connect the thought with code:**\\n*Note: Thanks to @LarryNY for a easily understandable python code*\\n![image](https://assets.leetcode.com/users/images/1cee98cd-f0bb-4eb1-8396-c70ea0b82268_1652527350.5416386.png)\\n\\n**Important point:** @cache is a decorator in python which helps to memoize the recursive function. Without that decorator this code will give TLE. You can always try to memoize it in your own way.\\n\\n"
                    },
                    {
                        "username": "VVHack",
                        "content": "I tried solving this using BFS + caching and DFS + caching, DFS was much faster. Why was DFS faster? Is it because BFS tries to run all paths at the same time and find the shortest whereas DFS just looks for any valid path?"
                    },
                    {
                        "username": "taakasj",
                        "content": "There are many wrong test cases for this question.\\nFor ex: The expected output for input [[\"(\",\"(\"]] is \\'true\\' but the accepted response should be \\'false\\'\\n\\nAnother example : [[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\"],[\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\"],[\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\"],[\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\"]] \\n\\nThe expected answer is \\'false\\' but correct answer should be \\'true\\'.\\n\\nIs everyone facing the same issue ?"
                    },
                    {
                        "username": "enigmaHere",
                        "content": "why is this approach not working\\n\\nclass Solution {\\n    public boolean hasValidPath(char[][] arr) {\\n        int r = arr.length;\\n        int c = arr[0].length;\\n        Byte dp[][] = new Byte[r][c];\\n        Stack<Character> stack = new Stack<Character>();\\n        if(arr[0][0] == \\'(\\')\\n            stack.push(\\'(\\');\\n        else\\n            return false;\\n        rec(arr,r,c,0,0,dp,stack);\\n        return (dp[0][0] == 0)? false : true;\\n\\n        // return dynamic(arr);\\n    }\\n\\n    Byte rec(char[][] arr,int r,int c,int x , int y,Byte[][] dp,Stack<Character> stack){\\n        if(x == r-1 && y == c-1)\\n            return (stack.empty())? (byte)1 : (byte)0;\\n        \\n        if(dp[x][y] != null)\\n            return dp[x][y];\\n\\n        byte right = 0,down = 0;\\n        //move right\\n        if(y < c-1){\\n            char ch = arr[x][y+1];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n\\n        //move down\\n        if(x < r-1){\\n            char ch = arr[x+1][y];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n        return dp[x][y] = (byte)Math.max((int)right , (int)down);\\n    }\\n\\n}"
                    },
                    {
                        "username": "bigfatcoder",
                        "content": "This is a classic medium problem. Shouldn\\'t be labelled as hard."
                    },
                    {
                        "username": "themaniac",
                        "content": "Why is this solution not accepted?\nI got TLE for it but others who have a similar solution got accepted?\nPlease let me know..\n\n `\nclass Solution {\npublic:\n    int dp[101][101][201];\n    bool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\n        \n        if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==')') {\n            return true;\n        }\n        if(i==grid.size() || j == grid[0].size()) return false;\n        \n        if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\n        \n        if (grid[i][j] == '(')\n            lefts++;\n        else if(grid[i][j]==')' && lefts>0)\n            lefts--;\n        else \n            return dp[i][j][lefts]=false;\n        \n        bool found = false;\n        if(i+1<grid.size())\n            found |= recurse( grid, i+1, j, lefts);\n        if(j+1<grid[0].size())\n            found |= recurse( grid, i, j+1, lefts);\n        \n        return dp[i][j][lefts]=found;\n            \n    }\n    bool hasValidPath(vector<vector<char>>& grid) {\n        memset(dp, -1, sizeof(dp));\n        return recurse(grid, 0, 0, 0);     \n    }\n};\n`"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "[@user7613o](/user7613o) Memoization does work"
                    },
                    {
                        "username": "vishal-",
                        "content": "You are modifying lefts and storing result in dp[i][j][lefts].\\n\\nUse a temp variable to store lefts before modfying.\\n\\n```\\nclass Solution {\\npublic:\\nint dp[101][101][201];\\nbool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\\n\\n    if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==\\')\\') {\\n        return true;\\n    }\\n    if(i==grid.size() || j == grid[0].size()) return false;\\n    \\n    if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\\n    \\n    // We can\\'t use dp[i][j][lefts] as we are modifying lefts,\\n    // store lefts value in another variable.\\n    int prev_lefts = lefts;\\n\\n    if (grid[i][j] == \\'(\\')\\n        lefts++;\\n    else if(grid[i][j]==\\')\\' && lefts>0)\\n        lefts--;\\n    else \\n        return dp[i][j][prev_lefts]=false;\\n    \\n    bool found = false;\\n    if(i+1<grid.size())\\n        found |= recurse( grid, i+1, j, lefts);\\n    if(j+1<grid[0].size())\\n        found |= recurse( grid, i, j+1, lefts);\\n    \\n    return dp[i][j][prev_lefts]=found;\\n        \\n}\\nbool hasValidPath(vector<vector<char>>& grid) {\\n    memset(dp, -1, sizeof(dp));\\n    return recurse(grid, 0, 0, 0);     \\n}\\n};\\n```"
                    },
                    {
                        "username": "user7613o",
                        "content": "bro memoization does not work in this qn you have to try tabulation form \\n"
                    }
                ]
            },
            {
                "id": 1922483,
                "content": [
                    {
                        "username": "StormAlex",
                        "content": "**How to read my post?**\\nJust match the Diagram number with the number mentioned in code.\\n\\nVariables used **r** =Total  rows, **c** = total columns, **x,y** are coordinates and **count** = No of opening brackets visited\\n\\n**Thought Process**\\n![image](https://assets.leetcode.com/users/images/64229d1d-1631-4f04-ba0c-b139882099d0_1652527273.4110048.png)\\n\\n**Let\\'s connect the thought with code:**\\n*Note: Thanks to @LarryNY for a easily understandable python code*\\n![image](https://assets.leetcode.com/users/images/1cee98cd-f0bb-4eb1-8396-c70ea0b82268_1652527350.5416386.png)\\n\\n**Important point:** @cache is a decorator in python which helps to memoize the recursive function. Without that decorator this code will give TLE. You can always try to memoize it in your own way.\\n\\n"
                    },
                    {
                        "username": "VVHack",
                        "content": "I tried solving this using BFS + caching and DFS + caching, DFS was much faster. Why was DFS faster? Is it because BFS tries to run all paths at the same time and find the shortest whereas DFS just looks for any valid path?"
                    },
                    {
                        "username": "taakasj",
                        "content": "There are many wrong test cases for this question.\\nFor ex: The expected output for input [[\"(\",\"(\"]] is \\'true\\' but the accepted response should be \\'false\\'\\n\\nAnother example : [[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\"],[\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\"],[\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\"],[\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\"]] \\n\\nThe expected answer is \\'false\\' but correct answer should be \\'true\\'.\\n\\nIs everyone facing the same issue ?"
                    },
                    {
                        "username": "enigmaHere",
                        "content": "why is this approach not working\\n\\nclass Solution {\\n    public boolean hasValidPath(char[][] arr) {\\n        int r = arr.length;\\n        int c = arr[0].length;\\n        Byte dp[][] = new Byte[r][c];\\n        Stack<Character> stack = new Stack<Character>();\\n        if(arr[0][0] == \\'(\\')\\n            stack.push(\\'(\\');\\n        else\\n            return false;\\n        rec(arr,r,c,0,0,dp,stack);\\n        return (dp[0][0] == 0)? false : true;\\n\\n        // return dynamic(arr);\\n    }\\n\\n    Byte rec(char[][] arr,int r,int c,int x , int y,Byte[][] dp,Stack<Character> stack){\\n        if(x == r-1 && y == c-1)\\n            return (stack.empty())? (byte)1 : (byte)0;\\n        \\n        if(dp[x][y] != null)\\n            return dp[x][y];\\n\\n        byte right = 0,down = 0;\\n        //move right\\n        if(y < c-1){\\n            char ch = arr[x][y+1];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n\\n        //move down\\n        if(x < r-1){\\n            char ch = arr[x+1][y];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n        return dp[x][y] = (byte)Math.max((int)right , (int)down);\\n    }\\n\\n}"
                    },
                    {
                        "username": "bigfatcoder",
                        "content": "This is a classic medium problem. Shouldn\\'t be labelled as hard."
                    },
                    {
                        "username": "themaniac",
                        "content": "Why is this solution not accepted?\nI got TLE for it but others who have a similar solution got accepted?\nPlease let me know..\n\n `\nclass Solution {\npublic:\n    int dp[101][101][201];\n    bool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\n        \n        if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==')') {\n            return true;\n        }\n        if(i==grid.size() || j == grid[0].size()) return false;\n        \n        if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\n        \n        if (grid[i][j] == '(')\n            lefts++;\n        else if(grid[i][j]==')' && lefts>0)\n            lefts--;\n        else \n            return dp[i][j][lefts]=false;\n        \n        bool found = false;\n        if(i+1<grid.size())\n            found |= recurse( grid, i+1, j, lefts);\n        if(j+1<grid[0].size())\n            found |= recurse( grid, i, j+1, lefts);\n        \n        return dp[i][j][lefts]=found;\n            \n    }\n    bool hasValidPath(vector<vector<char>>& grid) {\n        memset(dp, -1, sizeof(dp));\n        return recurse(grid, 0, 0, 0);     \n    }\n};\n`"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "[@user7613o](/user7613o) Memoization does work"
                    },
                    {
                        "username": "vishal-",
                        "content": "You are modifying lefts and storing result in dp[i][j][lefts].\\n\\nUse a temp variable to store lefts before modfying.\\n\\n```\\nclass Solution {\\npublic:\\nint dp[101][101][201];\\nbool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\\n\\n    if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==\\')\\') {\\n        return true;\\n    }\\n    if(i==grid.size() || j == grid[0].size()) return false;\\n    \\n    if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\\n    \\n    // We can\\'t use dp[i][j][lefts] as we are modifying lefts,\\n    // store lefts value in another variable.\\n    int prev_lefts = lefts;\\n\\n    if (grid[i][j] == \\'(\\')\\n        lefts++;\\n    else if(grid[i][j]==\\')\\' && lefts>0)\\n        lefts--;\\n    else \\n        return dp[i][j][prev_lefts]=false;\\n    \\n    bool found = false;\\n    if(i+1<grid.size())\\n        found |= recurse( grid, i+1, j, lefts);\\n    if(j+1<grid[0].size())\\n        found |= recurse( grid, i, j+1, lefts);\\n    \\n    return dp[i][j][prev_lefts]=found;\\n        \\n}\\nbool hasValidPath(vector<vector<char>>& grid) {\\n    memset(dp, -1, sizeof(dp));\\n    return recurse(grid, 0, 0, 0);     \\n}\\n};\\n```"
                    },
                    {
                        "username": "user7613o",
                        "content": "bro memoization does not work in this qn you have to try tabulation form \\n"
                    }
                ]
            },
            {
                "id": 1732637,
                "content": [
                    {
                        "username": "StormAlex",
                        "content": "**How to read my post?**\\nJust match the Diagram number with the number mentioned in code.\\n\\nVariables used **r** =Total  rows, **c** = total columns, **x,y** are coordinates and **count** = No of opening brackets visited\\n\\n**Thought Process**\\n![image](https://assets.leetcode.com/users/images/64229d1d-1631-4f04-ba0c-b139882099d0_1652527273.4110048.png)\\n\\n**Let\\'s connect the thought with code:**\\n*Note: Thanks to @LarryNY for a easily understandable python code*\\n![image](https://assets.leetcode.com/users/images/1cee98cd-f0bb-4eb1-8396-c70ea0b82268_1652527350.5416386.png)\\n\\n**Important point:** @cache is a decorator in python which helps to memoize the recursive function. Without that decorator this code will give TLE. You can always try to memoize it in your own way.\\n\\n"
                    },
                    {
                        "username": "VVHack",
                        "content": "I tried solving this using BFS + caching and DFS + caching, DFS was much faster. Why was DFS faster? Is it because BFS tries to run all paths at the same time and find the shortest whereas DFS just looks for any valid path?"
                    },
                    {
                        "username": "taakasj",
                        "content": "There are many wrong test cases for this question.\\nFor ex: The expected output for input [[\"(\",\"(\"]] is \\'true\\' but the accepted response should be \\'false\\'\\n\\nAnother example : [[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\"],[\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\"],[\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\"],[\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\"]] \\n\\nThe expected answer is \\'false\\' but correct answer should be \\'true\\'.\\n\\nIs everyone facing the same issue ?"
                    },
                    {
                        "username": "enigmaHere",
                        "content": "why is this approach not working\\n\\nclass Solution {\\n    public boolean hasValidPath(char[][] arr) {\\n        int r = arr.length;\\n        int c = arr[0].length;\\n        Byte dp[][] = new Byte[r][c];\\n        Stack<Character> stack = new Stack<Character>();\\n        if(arr[0][0] == \\'(\\')\\n            stack.push(\\'(\\');\\n        else\\n            return false;\\n        rec(arr,r,c,0,0,dp,stack);\\n        return (dp[0][0] == 0)? false : true;\\n\\n        // return dynamic(arr);\\n    }\\n\\n    Byte rec(char[][] arr,int r,int c,int x , int y,Byte[][] dp,Stack<Character> stack){\\n        if(x == r-1 && y == c-1)\\n            return (stack.empty())? (byte)1 : (byte)0;\\n        \\n        if(dp[x][y] != null)\\n            return dp[x][y];\\n\\n        byte right = 0,down = 0;\\n        //move right\\n        if(y < c-1){\\n            char ch = arr[x][y+1];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n\\n        //move down\\n        if(x < r-1){\\n            char ch = arr[x+1][y];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n        return dp[x][y] = (byte)Math.max((int)right , (int)down);\\n    }\\n\\n}"
                    },
                    {
                        "username": "bigfatcoder",
                        "content": "This is a classic medium problem. Shouldn\\'t be labelled as hard."
                    },
                    {
                        "username": "themaniac",
                        "content": "Why is this solution not accepted?\nI got TLE for it but others who have a similar solution got accepted?\nPlease let me know..\n\n `\nclass Solution {\npublic:\n    int dp[101][101][201];\n    bool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\n        \n        if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==')') {\n            return true;\n        }\n        if(i==grid.size() || j == grid[0].size()) return false;\n        \n        if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\n        \n        if (grid[i][j] == '(')\n            lefts++;\n        else if(grid[i][j]==')' && lefts>0)\n            lefts--;\n        else \n            return dp[i][j][lefts]=false;\n        \n        bool found = false;\n        if(i+1<grid.size())\n            found |= recurse( grid, i+1, j, lefts);\n        if(j+1<grid[0].size())\n            found |= recurse( grid, i, j+1, lefts);\n        \n        return dp[i][j][lefts]=found;\n            \n    }\n    bool hasValidPath(vector<vector<char>>& grid) {\n        memset(dp, -1, sizeof(dp));\n        return recurse(grid, 0, 0, 0);     \n    }\n};\n`"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "[@user7613o](/user7613o) Memoization does work"
                    },
                    {
                        "username": "vishal-",
                        "content": "You are modifying lefts and storing result in dp[i][j][lefts].\\n\\nUse a temp variable to store lefts before modfying.\\n\\n```\\nclass Solution {\\npublic:\\nint dp[101][101][201];\\nbool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\\n\\n    if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==\\')\\') {\\n        return true;\\n    }\\n    if(i==grid.size() || j == grid[0].size()) return false;\\n    \\n    if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\\n    \\n    // We can\\'t use dp[i][j][lefts] as we are modifying lefts,\\n    // store lefts value in another variable.\\n    int prev_lefts = lefts;\\n\\n    if (grid[i][j] == \\'(\\')\\n        lefts++;\\n    else if(grid[i][j]==\\')\\' && lefts>0)\\n        lefts--;\\n    else \\n        return dp[i][j][prev_lefts]=false;\\n    \\n    bool found = false;\\n    if(i+1<grid.size())\\n        found |= recurse( grid, i+1, j, lefts);\\n    if(j+1<grid[0].size())\\n        found |= recurse( grid, i, j+1, lefts);\\n    \\n    return dp[i][j][prev_lefts]=found;\\n        \\n}\\nbool hasValidPath(vector<vector<char>>& grid) {\\n    memset(dp, -1, sizeof(dp));\\n    return recurse(grid, 0, 0, 0);     \\n}\\n};\\n```"
                    },
                    {
                        "username": "user7613o",
                        "content": "bro memoization does not work in this qn you have to try tabulation form \\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Obstacle Removal to Reach Corner",
        "question_content": "<p>You are given a <strong>0-indexed</strong> 2D integer array <code>grid</code> of size <code>m x n</code>. Each cell has one of two values:</p>\n\n<ul>\n\t<li><code>0</code> represents an <strong>empty</strong> cell,</li>\n\t<li><code>1</code> represents an <strong>obstacle</strong> that may be removed.</li>\n</ul>\n\n<p>You can move up, down, left, or right from and to an empty cell.</p>\n\n<p>Return <em>the <strong>minimum</strong> number of <strong>obstacles</strong> to <strong>remove</strong> so you can move from the upper left corner </em><code>(0, 0)</code><em> to the lower right corner </em><code>(m - 1, n - 1)</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/06/example1drawio-1.png\" style=\"width: 605px; height: 246px;\" />\n<pre>\n<strong>Input:</strong> grid = [[0,1,1],[1,1,0],[1,1,0]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2).\nIt can be shown that we need to remove at least 2 obstacles, so we return 2.\nNote that there may be other ways to remove 2 obstacles to create a path.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/06/example1drawio.png\" style=\"width: 405px; height: 246px;\" />\n<pre>\n<strong>Input:</strong> grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> We can move from (0, 0) to (2, 4) without removing any obstacles, so we return 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>2 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>grid[i][j]</code> is either <code>0</code> <strong>or</strong> <code>1</code>.</li>\n\t<li><code>grid[0][0] == grid[m - 1][n - 1] == 0</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 2086036,
                "title": "let-s-solve-this-problem-based-on-never-give-up-explained-failure-point",
                "content": "While giving the contest the first intuition which came to my mind is dp. Yes, Off-course after solving a bunch of dp problems in the beginning I am also the person who wants to see dp everywhere.\\n\\nSo, Here is my code for using dp which failed 2nd test case though. But still, I have written something which I can analyze.\\n```\\n\\nclass Solution {\\n    int [][]grid;\\n    int n,m;\\n    boolean [][]seen;\\n    int []dx = new int[]{0,0,1,-1};\\n    int []dy = new int[]{1,-1,0,0};\\n    int [][]dp;\\n    int finalres;\\n    private boolean isValid(int i, int j) {\\n        return Math.min(i,j)>=0 && i<n && j<m && !seen[i][j];\\n    }\\n    \\n    private int solve(int i, int j, int cnt) {\\n        if(cnt>=finalres) return finalres;\\n        if(i == n-1 && j == m-1) {\\n            return cnt;\\n        }\\n        if(dp[i][j]!=Integer.MAX_VALUE) return dp[i][j];\\n        int res = n*m+1;\\n        seen[i][j]=true;\\n        for(int k=0;k<4;k++) {\\n            int newI = i+dx[k], newJ = j+dy[k];\\n            if(isValid(newI, newJ)) {\\n                res = Math.min(res, solve(newI, newJ, cnt+grid[i][j]));\\n            }\\n        }\\n        seen[i][j]=false;\\n        return dp[i][j]=Math.min(dp[i][j], res);\\n    }\\n    \\n    public int minimumObstacles(int[][] grid) {\\n        this.grid = grid;\\n        this.n = grid.length;\\n        this.m = grid[0].length;\\n        this.seen = new boolean[n][m];\\n        dp = new int[n][m];\\n        finalres = n*m+1;\\n        for(int []row:dp) Arrays.fill(row, Integer.MAX_VALUE);\\n        return solve(0,0,0);\\n    }\\n}\\n```\\n\\n**But It didn\\'t work.**\\n# Why?\\nsince once I store the result of (i,j) using path let\\'s say \"*path*\" then whenever I again come to (i,j), I just used the already saved result. So here is what my code assumes once we get the result for (i,j) then it\\'s the optimal. But there is the possibility that a path from a different *path* that contributed to saving the dp result will be coming with less cost(i.e. cost == the number of blockers that needs to remove). That\\'s why it\\'s failed.\\n\\n**Ok so let\\'s try another way**\\nSo at this point of time, I was confirmed that, dp wouldn\\'t help here. So what next I can try?\\nSince from (0,0) to (n-1,m-1) I can have multiple paths and I need the path which has the minimum number of blockers(not exactly the path just count). So yeah here I thought let\\'s do bfs so that each path will be running in the queue with their context and wouldn\\'t merge as in dp.\\n\\nSo here is the BFS code : \\n\\n```\\nclass Solution {\\n    int n,m;\\n    int []dx = new int[]{0,0,1,-1};\\n    int []dy = new int[]{1,-1,0,0};\\n    int [][]dp;\\n    private boolean isValid(int i, int j) {\\n        return Math.min(i,j)>=0 && i<n && j<m;\\n    }\\n    \\n    public int minimumObstacles(int[][] grid) {\\n        this.n = grid.length;\\n        this.m = grid[0].length;\\n        dp = new int[n][m];\\n        for(int []row:dp)Arrays.fill(row,Integer.MAX_VALUE);\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{0,0,0});\\n        int res = n*m+1;// At most i have to remove all the blockers.\\n        \\n        while(!queue.isEmpty()) {\\n            int thisLevel = queue.size();\\n            while(thisLevel-->0 ) {\\n                int []temp = queue.remove();\\n                int i=temp[0], j=temp[1];\\n                if(i==n-1 && j == m-1) {\\n                    res = Math.min(res, temp[2]);\\n                    continue;\\n                }\\n                \\n               for(int k=0;k<4;k++) {\\n                    int newI = i+dx[k], newJ = j+dy[k];\\n                   \\n                   // if newi and newj is valid and which is not increasing the cost for newi and newj which already i have achieved.\\n                    if(isValid(newI, newJ) && dp[newI][newJ]>temp[2]+grid[newI][newJ]) {\\n                        dp[newI][newJ]=temp[2]+grid[newI][newJ];\\n                        queue.add(new int[]{newI, newJ, dp[newI][newJ]});\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n**But again this code is given tle.**\\n# Why?\\nSo after doing analysis, I come to the point that, I was checking for any node (newI, newJ) which is going to be added to the queue that is, whether it is increasing the blocker count that I have already achieved for this node or not? Yeah, this is right and I should do that. But I skipped that If the same node (newI, newJ) is already in the queue with the greater number of blockers that we\\'re getting now.\\nSo why this is making an issue?\\nSince the node in the queue must be removed because we got a path to reach the (newI, newJ) with less blocker. If we don\\'t remove this path this path again will start adding the node in the queue which gives the result as TLE.\\nok so now let\\'s update it.\\n\\n```\\nclass Solution {\\n    int n,m;\\n    int []dx = new int[]{0,0,1,-1};\\n    int []dy = new int[]{1,-1,0,0};\\n    int [][]dp;\\n    int [][]grid;\\n    private boolean isValid(int i, int j, int cost) {\\n        boolean valid = (Math.min(i,j)>=0 && i<n && j<m && dp[i][j]>cost+grid[i][j]);\\n        if(valid) dp[i][j]=cost+grid[i][j];\\n        return valid;\\n    }\\n    \\n    public int minimumObstacles(int[][] grid) {\\n        this.grid = grid;\\n        this.n = grid.length;\\n        this.m = grid[0].length;\\n        dp = new int[n][m];\\n        for(int []row:dp)Arrays.fill(row,Integer.MAX_VALUE);\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{0,0,0});\\n        int res = n*m+1;// At most i have to remove all the blockers.\\n        \\n        while(!queue.isEmpty()) {\\n            int thisLevel = queue.size();\\n            while(thisLevel-->0 ) {\\n                int []temp = queue.remove();\\n                int i=temp[0], j=temp[1];\\n                if(i==n-1 && j == m-1) {\\n                    res = Math.min(res, temp[2]);\\n                    continue;\\n                }\\n                \\n                if(temp[2]>dp[i][j]) {\\n                    // This is invalid path because we have achived better which already might be running in the queue\\n                    continue;\\n                }\\n                \\n               for(int k=0;k<4;k++) {\\n                    int newI = i+dx[k], newJ = j+dy[k];\\n                   \\n                   // if newi and newj is valid and which is not increasing the cost for newi and newj which already i have achieved.\\n                    if(isValid(newI, newJ, temp[2])) {\\n                        queue.add(new int[]{newI, newJ, dp[newI][newJ]});\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n**Aaahhha it\\'s accepted**\\nLater when I came to the discussion page and read some code. Then I remember this code is most likely the Dijkstra algorithm.\\n# So morel is\\nInstead of remembering the Algorithms just understand the actual concept and the problem for which any algorithms are made. Later in the future, you\\'ll be building the same algorithms again and again without remembering.\\n\\n**Please upvote if it\\'s fun and knowledgeable for you.**\\n\\nHappy coding!",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\n    int [][]grid;\\n    int n,m;\\n    boolean [][]seen;\\n    int []dx = new int[]{0,0,1,-1};\\n    int []dy = new int[]{1,-1,0,0};\\n    int [][]dp;\\n    int finalres;\\n    private boolean isValid(int i, int j) {\\n        return Math.min(i,j)>=0 && i<n && j<m && !seen[i][j];\\n    }\\n    \\n    private int solve(int i, int j, int cnt) {\\n        if(cnt>=finalres) return finalres;\\n        if(i == n-1 && j == m-1) {\\n            return cnt;\\n        }\\n        if(dp[i][j]!=Integer.MAX_VALUE) return dp[i][j];\\n        int res = n*m+1;\\n        seen[i][j]=true;\\n        for(int k=0;k<4;k++) {\\n            int newI = i+dx[k], newJ = j+dy[k];\\n            if(isValid(newI, newJ)) {\\n                res = Math.min(res, solve(newI, newJ, cnt+grid[i][j]));\\n            }\\n        }\\n        seen[i][j]=false;\\n        return dp[i][j]=Math.min(dp[i][j], res);\\n    }\\n    \\n    public int minimumObstacles(int[][] grid) {\\n        this.grid = grid;\\n        this.n = grid.length;\\n        this.m = grid[0].length;\\n        this.seen = new boolean[n][m];\\n        dp = new int[n][m];\\n        finalres = n*m+1;\\n        for(int []row:dp) Arrays.fill(row, Integer.MAX_VALUE);\\n        return solve(0,0,0);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int n,m;\\n    int []dx = new int[]{0,0,1,-1};\\n    int []dy = new int[]{1,-1,0,0};\\n    int [][]dp;\\n    private boolean isValid(int i, int j) {\\n        return Math.min(i,j)>=0 && i<n && j<m;\\n    }\\n    \\n    public int minimumObstacles(int[][] grid) {\\n        this.n = grid.length;\\n        this.m = grid[0].length;\\n        dp = new int[n][m];\\n        for(int []row:dp)Arrays.fill(row,Integer.MAX_VALUE);\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{0,0,0});\\n        int res = n*m+1;// At most i have to remove all the blockers.\\n        \\n        while(!queue.isEmpty()) {\\n            int thisLevel = queue.size();\\n            while(thisLevel-->0 ) {\\n                int []temp = queue.remove();\\n                int i=temp[0], j=temp[1];\\n                if(i==n-1 && j == m-1) {\\n                    res = Math.min(res, temp[2]);\\n                    continue;\\n                }\\n                \\n               for(int k=0;k<4;k++) {\\n                    int newI = i+dx[k], newJ = j+dy[k];\\n                   \\n                   // if newi and newj is valid and which is not increasing the cost for newi and newj which already i have achieved.\\n                    if(isValid(newI, newJ) && dp[newI][newJ]>temp[2]+grid[newI][newJ]) {\\n                        dp[newI][newJ]=temp[2]+grid[newI][newJ];\\n                        queue.add(new int[]{newI, newJ, dp[newI][newJ]});\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int n,m;\\n    int []dx = new int[]{0,0,1,-1};\\n    int []dy = new int[]{1,-1,0,0};\\n    int [][]dp;\\n    int [][]grid;\\n    private boolean isValid(int i, int j, int cost) {\\n        boolean valid = (Math.min(i,j)>=0 && i<n && j<m && dp[i][j]>cost+grid[i][j]);\\n        if(valid) dp[i][j]=cost+grid[i][j];\\n        return valid;\\n    }\\n    \\n    public int minimumObstacles(int[][] grid) {\\n        this.grid = grid;\\n        this.n = grid.length;\\n        this.m = grid[0].length;\\n        dp = new int[n][m];\\n        for(int []row:dp)Arrays.fill(row,Integer.MAX_VALUE);\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{0,0,0});\\n        int res = n*m+1;// At most i have to remove all the blockers.\\n        \\n        while(!queue.isEmpty()) {\\n            int thisLevel = queue.size();\\n            while(thisLevel-->0 ) {\\n                int []temp = queue.remove();\\n                int i=temp[0], j=temp[1];\\n                if(i==n-1 && j == m-1) {\\n                    res = Math.min(res, temp[2]);\\n                    continue;\\n                }\\n                \\n                if(temp[2]>dp[i][j]) {\\n                    // This is invalid path because we have achived better which already might be running in the queue\\n                    continue;\\n                }\\n                \\n               for(int k=0;k<4;k++) {\\n                    int newI = i+dx[k], newJ = j+dy[k];\\n                   \\n                   // if newi and newj is valid and which is not increasing the cost for newi and newj which already i have achieved.\\n                    if(isValid(newI, newJ, temp[2])) {\\n                        queue.add(new int[]{newI, newJ, dp[newI][newJ]});\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085640,
                "title": "java-python-3-2-codes-shortest-path-bfs-w-brief-explanation-analysis-and-similar-problems",
                "content": "**Q & A**\\n\\nQ1: Why do we not need to keep track of which nodes we\\'ve already visited? Is this code perhaps already implicitly tracking the nodes we\\'ve visited? According to the implementation of Lazy Dijkstra [here](http://nmamano.com/blog/dijkstra/dijkstra.html), we need to keep track of which nodes we\\'ve already visited. \\nA1: The `PriorityQueue/heap` always keep track of the cell that we currently can reach with shortest path, and `grid[i][j] + o < dist[i][j]` makes sure we don\\'t need to visit the cell again if we can not reach it with less obstacles. \\nQ2: .Is it possible to optimize backtracking code with dp for this problem?\\n[@Mikey98](https://leetcode.com/Mikey98)   [@Adithya_U_Bhat](https://leetcode.com/Adithya_U_Bhat) contributed the following anwer.\\nA2: No. In this question `1 <= m, n <= 10`<sup>5</sup>, which is toooo big for backtracking; You cannot use dp here as there are 4 directions and revisiting a node again can give you minimum answer so dp fails here , remember one thing if its given 4 direction always go with graphs\\n\\n**End of Q & A**\\n\\n----\\n\\n**Method 1: Shortest Path**\\n\\n1. Initialize `dist` with `Integer.MAX_VALUE/math.inf`, and use `dist[i][j]` to indicate the currently minimum obstacles need to remove to reach `(i, j)`;\\n2. Starting from `(0, 0)`, put `[grid[0][0], 0, 0]` into a `PriorityQueue/heap` to begin to search by **Shortest Path**; Once we can reach any `(i, j)` from its neighbor with fewer obstacles, we update it with the less value and put the corresponding information array `[dist[i][j], i, j]` into `PriorityQueue/heap`, repeat till we find a path to `(m - 1, n - 1)`.\\n\\n```java\\n    private static final int[] d = {0, 1, 0, -1, 0};\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dist = new int[m][n];\\n        for (int[] di : dist) {\\n            Arrays.fill(di, Integer.MAX_VALUE);\\n        }\\n        dist[0][0] = grid[0][0];\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));\\n        pq.offer(new int[]{dist[0][0], 0,  0});\\n        while (!pq.isEmpty()) {\\n            int[] cur = pq.poll();\\n            int o = cur[0], r = cur[1], c = cur[2];\\n            if (r == m - 1 && c == n - 1) {\\n                return o;\\n            }\\n            for (int k = 0; k < 4; ++k) {\\n                int i = r + d[k], j = c + d[k + 1];\\n                if (0 <= i && i < m && 0 <= j && j < n && o + grid[i][j] < dist[i][j]) {\\n                    dist[i][j] = o + grid[i][j];\\n                    pq.offer(new int[]{dist[i][j], i, j});\\n                }\\n            }\\n        }\\n        return dist[m - 1][n - 1];\\n    }\\n```\\n```python\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = map(len, (grid, grid[0]))\\n        dist = [[inf] * n for _ in range(m)]\\n        dist[0][0] = grid[0][0]\\n        hp = [(dist[0][0], 0, 0)]\\n        while hp:\\n            o, r, c = heappop(hp)\\n            if (r, c) == (m - 1, n - 1):\\n                return o\\n            for i, j in (r + 1, c), (r - 1, c), (r, c + 1), (r, c - 1):\\n                if m > i >= 0 <= j < n and grid[i][j] + o < dist[i][j]:\\n                    dist[i][j] = grid[i][j] + o\\n                    heappush(hp, (dist[i][j], i, j))\\n```\\n\\n**Analysis:**\\n\\nTime: `O(m * n log(m * n))`, space: `O(m * n)`.\\n\\n----\\n\\n**Method 2: Modified BFS** -- credit to **@Doskarin**.\\n1. Initialize `dist` with `Integer.MAX_VALUE/math.inf`, and use `dist[i][j]` to indicate the currently minimum obstacles need to remove to reach `(i, j)`;\\n2. Starting from `(0, 0)`, put `[grid[0][0], 0, 0]` into a `Deque` to begin BFS, and use `dist` value to avoid duplicates;\\n3. **Whenever encountering an empty cell neighbor, the `dist` value is same and hence we can put it to the front of the `Deque`;**  Otherwise, put it to the back of the `Deque`;\\n4. Repeat 2. and 3. and update `dist` accordingly till the `Deque` is empty;\\n5. return `dist[m - 1][n - 1]` as solution.\\n\\n```java\\n    private static final int[] d = {0, 1, 0, -1, 0};\\n    private static final int M = Integer.MAX_VALUE;\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dist = new int[m][n];\\n        for (int[] di : dist) {\\n            Arrays.fill(di, M);\\n        }\\n        dist[0][0] = 0;\\n        Deque<int[]> dq = new ArrayDeque<>();\\n        dq.offer(new int[3]);\\n        while (!dq.isEmpty()) {\\n            int[] cur = dq.poll();\\n            int o = cur[0], r = cur[1], c = cur[2];\\n            for (int k = 0; k < 4; ++k) {\\n                int i = r + d[k], j = c + d[k + 1];\\n                if (0 <= i && i < m && 0 <= j && j < n && dist[i][j] == M) {\\n                    if (grid[i][j] == 1) {\\n                        dist[i][j] = o + 1;\\n                        dq.offer(new int[]{o + 1, i, j});\\n                    }else {\\n                        dist[i][j] = o;\\n                        dq.offerFirst(new int[]{o, i, j});\\n                    }\\n                }\\n            }\\n        }\\n        return dist[m - 1][n - 1];\\n    }\\n```\\n```python\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = map(len, (grid, grid[0]))\\n        dist = [[inf] * n for _ in range(m)]\\n        dist[0][0] = 0\\n        dq = deque([(0, 0, 0)])\\n        while dq:\\n            o, r, c = dq.popleft()\\n            for i, j in (r + 1, c), (r - 1, c), (r, c + 1), (r, c - 1):\\n                if m > i >= 0 <= j < n and dist[i][j] == inf:\\n                    if grid[i][j] == 1:\\n                        dist[i][j] = o + 1\\n                        dq.append((o + 1, i, j))\\n                    else:\\n                        dist[i][j] = o\\n                        dq.appendleft((o, i, j))    \\n        return dist[-1][-1]\\n```\\n**Analysis:**\\n\\nSince each cell is visited at most once, therefore\\n\\nTime & space: `O(m * n)`.\\n\\n----\\n\\nIn case you are NOT familiar with Bellman Ford and Dijkstra\\'s algorithm, the following links are excellent materials for you to learn:\\n\\n**Bellman Ford algorithm:**\\nhttps://algs4.cs.princeton.edu/44sp/\\nhttps://algs4.cs.princeton.edu/44sp/BellmanFordSP.java.html\\nhttps://web.stanford.edu/class/archive/cs/cs161/cs161.1168/lecture14.pdf\\nhttps://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm\\nhttps://www.geeks for geeks.org/bellman-ford-algorithm-dp-23/(remove the 2 spaces among the links to make it valid)\\n\\n**Dijkstra\\'s algorithm:**\\nhttps://algs4.cs.princeton.edu/44sp/\\nhttps://algs4.cs.princeton.edu/44sp/DijkstraSP.java.html\\nhttps://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\\nhttps://www.geeks for geeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/ (remove the 2 spaces among the links to make it valid)\\n\\nSimilar problems:\\n\\n[407. Trapping Rain Water II](https://leetcode.com/problems/trapping-rain-water-ii)\\n[499. The Maze III](https://leetcode.com/problems/the-maze-iii)\\n[505. The Maze II](https://leetcode.com/problems/the-maze-ii)\\n[743. Network Delay Time](https://leetcode.com/problems/network-delay-time/)\\n[778. Swim in Rising Water](https://leetcode.com/problems/swim-in-rising-water/description/)\\n[787. Cheapest Flights Within K Stops](https://leetcode.com/problems/cheapest-flights-within-k-stops/)\\n[1102. Path With Maximum Minimum Value](https://leetcode.com/problems/path-with-maximum-minimum-value) **Premium**\\n[1514. Path with Maximum Probability](https://leetcode.com/problems/path-with-maximum-probability/discuss/731767/JavaPython-3-2-codes%3A-Bellman-Ford-and-Dijkstra\\'s-algorithm-w-brief-explanation-and-analysis.)\\n[1631. Path With Minimum Effort](https://leetcode.com/problems/path-with-minimum-effort/discuss/909002/JavaPython-3-3-codes%3A-Binary-Search-Bellman-Ford-and-Dijkstra-w-brief-explanation-and-analysis.)\\n[2290. Minimum Obstacle Removal to Reach Corner](https://leetcode.com/problems/minimum-obstacle-removal-to-reach-corner/discuss/2085640/JavaPython-3-Shortest-Path-w-brief-explanation-and-analysis.)",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```java\\n    private static final int[] d = {0, 1, 0, -1, 0};\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dist = new int[m][n];\\n        for (int[] di : dist) {\\n            Arrays.fill(di, Integer.MAX_VALUE);\\n        }\\n        dist[0][0] = grid[0][0];\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));\\n        pq.offer(new int[]{dist[0][0], 0,  0});\\n        while (!pq.isEmpty()) {\\n            int[] cur = pq.poll();\\n            int o = cur[0], r = cur[1], c = cur[2];\\n            if (r == m - 1 && c == n - 1) {\\n                return o;\\n            }\\n            for (int k = 0; k < 4; ++k) {\\n                int i = r + d[k], j = c + d[k + 1];\\n                if (0 <= i && i < m && 0 <= j && j < n && o + grid[i][j] < dist[i][j]) {\\n                    dist[i][j] = o + grid[i][j];\\n                    pq.offer(new int[]{dist[i][j], i, j});\\n                }\\n            }\\n        }\\n        return dist[m - 1][n - 1];\\n    }\\n```\n```python\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = map(len, (grid, grid[0]))\\n        dist = [[inf] * n for _ in range(m)]\\n        dist[0][0] = grid[0][0]\\n        hp = [(dist[0][0], 0, 0)]\\n        while hp:\\n            o, r, c = heappop(hp)\\n            if (r, c) == (m - 1, n - 1):\\n                return o\\n            for i, j in (r + 1, c), (r - 1, c), (r, c + 1), (r, c - 1):\\n                if m > i >= 0 <= j < n and grid[i][j] + o < dist[i][j]:\\n                    dist[i][j] = grid[i][j] + o\\n                    heappush(hp, (dist[i][j], i, j))\\n```\n```java\\n    private static final int[] d = {0, 1, 0, -1, 0};\\n    private static final int M = Integer.MAX_VALUE;\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dist = new int[m][n];\\n        for (int[] di : dist) {\\n            Arrays.fill(di, M);\\n        }\\n        dist[0][0] = 0;\\n        Deque<int[]> dq = new ArrayDeque<>();\\n        dq.offer(new int[3]);\\n        while (!dq.isEmpty()) {\\n            int[] cur = dq.poll();\\n            int o = cur[0], r = cur[1], c = cur[2];\\n            for (int k = 0; k < 4; ++k) {\\n                int i = r + d[k], j = c + d[k + 1];\\n                if (0 <= i && i < m && 0 <= j && j < n && dist[i][j] == M) {\\n                    if (grid[i][j] == 1) {\\n                        dist[i][j] = o + 1;\\n                        dq.offer(new int[]{o + 1, i, j});\\n                    }else {\\n                        dist[i][j] = o;\\n                        dq.offerFirst(new int[]{o, i, j});\\n                    }\\n                }\\n            }\\n        }\\n        return dist[m - 1][n - 1];\\n    }\\n```\n```python\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = map(len, (grid, grid[0]))\\n        dist = [[inf] * n for _ in range(m)]\\n        dist[0][0] = 0\\n        dq = deque([(0, 0, 0)])\\n        while dq:\\n            o, r, c = dq.popleft()\\n            for i, j in (r + 1, c), (r - 1, c), (r, c + 1), (r, c - 1):\\n                if m > i >= 0 <= j < n and dist[i][j] == inf:\\n                    if grid[i][j] == 1:\\n                        dist[i][j] = o + 1\\n                        dq.append((o + 1, i, j))\\n                    else:\\n                        dist[i][j] = o\\n                        dq.appendleft((o, i, j))    \\n        return dist[-1][-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2086235,
                "title": "0-1-bfs-c",
                "content": "**Solution in short :**\\nStandard 0-1 BFS.\\nUse deque and push the grid without obstacle to the front and the grid with obstacle to the end and do a normal BFS.\\n\\n**Intuition**\\nThe idea is similar to that of Djikstra. Dijkstra uses a set or priority queue because at every iteration edge with smallest cost is required. So an additional time of sorting the edges is involved at each step. Here we have a special weighted graph where every edge has a weight of either 0 or 1. In this kind of graph, Dijkstra can be further optimized to avoid sorting at every iteration.\\nFor every node that you visit, push all its **unvisited neighbours** to the queue in the following manner.\\n\\n* Every unvisited neighbour with cost 1 (having an obstacle), push to the end of the queue \\n* Every unvisited neighbour with cost 0 (having no obstacle), push to the beginning of the queue.\\n\\nBy the time you push a node to the queue, compute and store its distance in dp array.\\n\\n**I think it is enough to push any node only once in the queue using the visited flag. You can easily prove that the queue will always be sorted by the distances**\\n\\n\\n```\\nint dx[] = {1,-1,0,0};\\nint dy[] = {0,0,1,-1};\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n,INT_MAX));\\n        vector<vector<bool>> vis(m, vector<bool>(n,0));\\n        deque<pair<int,int>> q;\\n        q.push_front({0,0});\\n        dp[0][0] = 0;\\n        while(q.size()) {\\n            pair<int,int> p = q.front();\\n            q.pop_front();\\n            int cx = p.first;\\n            int cy = p.second;\\n            for(int i=0;i<4;i++) {\\n                int tx = cx + dx[i];\\n                int ty = cy + dy[i];\\n                if(tx >=0 && tx < m && ty >=0 && ty < n) {                    \\n                    if(!vis[tx][ty]) {\\n                        dp[tx][ty] = dp[cx][cy] + (grid[tx][ty] == 1);\\n                        if(grid[tx][ty] == 1) {\\n                            q.push_back({tx,ty});\\n                        } else {\\n                            q.push_front({tx,ty});\\n                        }\\n                        vis[tx][ty] = true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nint dx[] = {1,-1,0,0};\\nint dy[] = {0,0,1,-1};\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n,INT_MAX));\\n        vector<vector<bool>> vis(m, vector<bool>(n,0));\\n        deque<pair<int,int>> q;\\n        q.push_front({0,0});\\n        dp[0][0] = 0;\\n        while(q.size()) {\\n            pair<int,int> p = q.front();\\n            q.pop_front();\\n            int cx = p.first;\\n            int cy = p.second;\\n            for(int i=0;i<4;i++) {\\n                int tx = cx + dx[i];\\n                int ty = cy + dy[i];\\n                if(tx >=0 && tx < m && ty >=0 && ty < n) {                    \\n                    if(!vis[tx][ty]) {\\n                        dp[tx][ty] = dp[cx][cy] + (grid[tx][ty] == 1);\\n                        if(grid[tx][ty] == 1) {\\n                            q.push_back({tx,ty});\\n                        } else {\\n                            q.push_front({tx,ty});\\n                        }\\n                        vis[tx][ty] = true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2088276,
                "title": "two-methods-0-1-bfs-dijkastras-algo-100-faster-resources-included",
                "content": "# **Dijkastras algo method**\\n* **When do we use dijkastras,**\\n    1. When there is a weighted graph and there are one or multiple destinations possible\\n*   **What do we do in this** \\n    1.We need to store the minimum distance between nodes \\n    2.In order to do this we use a data structure like set or a priority queue \\n*  **In questions point of view**  :-\\n1.   Consider the edge weight from a free node to obstacle node to be 1 and from free node to free node 0\\n2.   Now apply dijkastras algo\\n```\\n int m=grid.size(), n=grid[0].size();\\n        vector<int> dir={0,1,0,-1,0};\\n        vector<vector<int>> dist(m, vector<int> (n,INT_MAX));\\n        dist[0][0]=0;\\n        priority_queue<pair<int,pair<int,int>>, std::vector<pair<int,pair<int,int>>>, std::greater<pair<int,pair<int,int>>> > pq;\\n        pq.push({0,{0,0}});\\n        while(!pq.empty())\\n        {\\n            auto v=pq.top();\\n            pq.pop();\\n            int i=v.second.first, j=v.second.second, d=v.first;\\n            for(int k=0;k<4;k++)\\n            {\\n                int x=i+dir[k], y=j+dir[k+1];\\n                if(x<0 || x>=m || y<0 || y>=n) continue;\\n                int wt;\\n                if(grid[x][y]==1)\\n                {\\n                    wt=1;\\n                }\\n                else\\n                {\\n                    wt=0;\\n                }\\n                \\n                if(d+wt<dist[x][y])\\n                {\\n                    dist[x][y]=d+wt;\\n                    pq.push({dist[x][y],{x,y}});\\n                }\\n            }\\n        }\\n        return dist[m-1][n-1];  \\n    }\\n```\\n\\t\\nThis approach gives us the answer but its time complexity is **(O(V+E)logN)**\\nExtra logN comes because of the use of Priority Queue\\n*TIME TO THINK* == > Do we really need dijkastras algo. No we don\\'t because we have only 2 different kinds of weights so we have a better and faster approach i.e 0-1 BFS.\\n\\n\\n# 0-1BFS Method\\n![image](https://assets.leetcode.com/users/images/5dfb0909-0ad5-4e16-a0c9-e331889fa4a1_1653894467.547596.png)\\n\\nLet me try to explain when we use 0-1 bfs and what are the advantages :-\\n* This is used when only two types of states/ weights are present\\n* This works using a deque so the complexity is **O(V+E)** like a normal bfs traversal\\n*   Links to refer for 0-1 BFS \\n      1. [https://cp-algorithms.com/graph/01_bfs.html](http://)\\n      2. [https://www.youtube.com/watch?v=SQOQ99stCas&list=PLauivoElc3ghxyYSr_sVnDUc_ynPk6iXE&index=14](http://)\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n      int m=grid.size(), n=grid[0].size();\\n        vector<int> dir={0,1,0,-1,0};\\n        vector<vector<int>> dist(m, vector<int> (n,INT_MAX));\\n        vector<vector<bool>> vis(m, vector<bool>(n,0));\\n        deque<pair<int,int>>q;\\n        dist[0][0]=0;\\n        q.push_front({0,0});\\n        while(!q.empty())\\n        {\\n            auto cur=q.front();\\n            q.pop_front();\\n            int x=cur.first;\\n            int y=cur.second;\\n            for(int i=0;i<4;i++)\\n            {\\n                int cx=x+dir[i];\\n                int cy=y+dir[i+1];\\n            if(cx>=0 and cy>=0 and cx<m and cy<n)\\n            {\\n                if(!vis[cx][cy])\\n                {\\n                    dist[cx][cy]=dist[x][y]+(grid[cx][cy]==1);\\n                    if(grid[cx][cy]==1)\\n                        q.push_back({cx,cy});//obstacle cell pushed at the end\\n                    else\\n                    q.push_front({cx,cy}); //empty cell pushed on top\\n                    vis[cx][cy] = true;\\n                }\\n            }\\n        }\\n    }\\n        return dist[m-1][n-1];\\n    }\\n};\\n```\\n\\nPlease do upvote if this helps!!!!",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n int m=grid.size(), n=grid[0].size();\\n        vector<int> dir={0,1,0,-1,0};\\n        vector<vector<int>> dist(m, vector<int> (n,INT_MAX));\\n        dist[0][0]=0;\\n        priority_queue<pair<int,pair<int,int>>, std::vector<pair<int,pair<int,int>>>, std::greater<pair<int,pair<int,int>>> > pq;\\n        pq.push({0,{0,0}});\\n        while(!pq.empty())\\n        {\\n            auto v=pq.top();\\n            pq.pop();\\n            int i=v.second.first, j=v.second.second, d=v.first;\\n            for(int k=0;k<4;k++)\\n            {\\n                int x=i+dir[k], y=j+dir[k+1];\\n                if(x<0 || x>=m || y<0 || y>=n) continue;\\n                int wt;\\n                if(grid[x][y]==1)\\n                {\\n                    wt=1;\\n                }\\n                else\\n                {\\n                    wt=0;\\n                }\\n                \\n                if(d+wt<dist[x][y])\\n                {\\n                    dist[x][y]=d+wt;\\n                    pq.push({dist[x][y],{x,y}});\\n                }\\n            }\\n        }\\n        return dist[m-1][n-1];  \\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n      int m=grid.size(), n=grid[0].size();\\n        vector<int> dir={0,1,0,-1,0};\\n        vector<vector<int>> dist(m, vector<int> (n,INT_MAX));\\n        vector<vector<bool>> vis(m, vector<bool>(n,0));\\n        deque<pair<int,int>>q;\\n        dist[0][0]=0;\\n        q.push_front({0,0});\\n        while(!q.empty())\\n        {\\n            auto cur=q.front();\\n            q.pop_front();\\n            int x=cur.first;\\n            int y=cur.second;\\n            for(int i=0;i<4;i++)\\n            {\\n                int cx=x+dir[i];\\n                int cy=y+dir[i+1];\\n            if(cx>=0 and cy>=0 and cx<m and cy<n)\\n            {\\n                if(!vis[cx][cy])\\n                {\\n                    dist[cx][cy]=dist[x][y]+(grid[cx][cy]==1);\\n                    if(grid[cx][cy]==1)\\n                        q.push_back({cx,cy});//obstacle cell pushed at the end\\n                    else\\n                    q.push_front({cx,cy}); //empty cell pushed on top\\n                    vis[cx][cy] = true;\\n                }\\n            }\\n        }\\n    }\\n        return dist[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086338,
                "title": "python-0-1-bfs",
                "content": "Classic 0-1 BFS implementation with a little caveat : we need to process elements in the queue with less obstacles first. This will make sure our destination will have the smallest obstacles removed.\\n\\nTime Complexity : ```O(R * C)``` - each cell in the grid is processed once as we traverse\\nSpace Complexity : ```O(R * C)``` - we need 2D helper array \"distance\" in order to record shortest obstacles removed for each cell\\n\\nCode\\n```\\nclass Solution(object):\\n    def minimumObstacles(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        R, C = len(grid), len(grid[0])\\n        \\n        d = [(1,0),(-1,0),(0,1),(0,-1)]\\n        \\n        distances = [[-1] * C for _ in range(R)]\\n        \\n        q = deque([(0, 0, 0)])\\n        \\n        while q:\\n            for _ in range(len(q)):\\n                dist, r, c = q.popleft()\\n                \\n                for dr, dc in d:\\n                    rr, cc = r + dr, c + dc\\n\\t\\t\\t\\t\\t#Check if the cell is inbounds and has not been visited before\\n                    if 0 <= rr < R and 0 <= cc < C and distances[rr][cc] == -1:\\n                        \\n                        #If the cell is an obstacle - assign current distance + 1 to its value\\n\\t\\t\\t\\t\\t\\tif grid[rr][cc] == 1:\\n                            distances[rr][cc] = dist + 1\\n                            q.append((dist + 1, rr, cc))\\n                            \\n                        else:\\n                            #Make sure we process cells with less obstacles first hence appendleft\\n                            distances[rr][cc] = dist\\n                            q.appendleft((dist, rr, cc))\\n                            \\n        return distances[R - 1][C - 1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Shortest Path"
                ],
                "code": "```O(R * C)```\n```O(R * C)```\n```\\nclass Solution(object):\\n    def minimumObstacles(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        R, C = len(grid), len(grid[0])\\n        \\n        d = [(1,0),(-1,0),(0,1),(0,-1)]\\n        \\n        distances = [[-1] * C for _ in range(R)]\\n        \\n        q = deque([(0, 0, 0)])\\n        \\n        while q:\\n            for _ in range(len(q)):\\n                dist, r, c = q.popleft()\\n                \\n                for dr, dc in d:\\n                    rr, cc = r + dr, c + dc\\n\\t\\t\\t\\t\\t#Check if the cell is inbounds and has not been visited before\\n                    if 0 <= rr < R and 0 <= cc < C and distances[rr][cc] == -1:\\n                        \\n                        #If the cell is an obstacle - assign current distance + 1 to its value\\n\\t\\t\\t\\t\\t\\tif grid[rr][cc] == 1:\\n                            distances[rr][cc] = dist + 1\\n                            q.append((dist + 1, rr, cc))\\n                            \\n                        else:\\n                            #Make sure we process cells with less obstacles first hence appendleft\\n                            distances[rr][cc] = dist\\n                            q.appendleft((dist, rr, cc))\\n                            \\n        return distances[R - 1][C - 1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085755,
                "title": "c-djkstra",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m, 1e5 + 1));\\n        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> pq;\\n        \\n        pq.push({grid[0][0], 0, 0});\\n        int dirs[4][2] = {{0, 1},{-1, 0},{1, 0},{0, -1}};\\n        while (!pq.empty()) {\\n            auto [c, i, j] = pq.top();\\n            pq.pop();\\n            \\n            if (i == n - 1 && j == m - 1) {\\n                return c;\\n            }\\n            \\n            for (auto &d: dirs) {\\n                int x = d[0] + i;\\n                int y = d[1] + j;\\n                \\n                if (x < 0 || y < 0 || x >= n || y >= m)\\n                    continue;\\n                \\n                if (dp[x][y] > grid[x][y] + c) {\\n                    dp[x][y] = grid[x][y] + c;\\n                    pq.push({grid[x][y] + c, x, y});\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m, 1e5 + 1));\\n        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> pq;\\n        \\n        pq.push({grid[0][0], 0, 0});\\n        int dirs[4][2] = {{0, 1},{-1, 0},{1, 0},{0, -1}};\\n        while (!pq.empty()) {\\n            auto [c, i, j] = pq.top();\\n            pq.pop();\\n            \\n            if (i == n - 1 && j == m - 1) {\\n                return c;\\n            }\\n            \\n            for (auto &d: dirs) {\\n                int x = d[0] + i;\\n                int y = d[1] + j;\\n                \\n                if (x < 0 || y < 0 || x >= n || y >= m)\\n                    continue;\\n                \\n                if (dp[x][y] > grid[x][y] + c) {\\n                    dp[x][y] = grid[x][y] + c;\\n                    pq.push({grid[x][y] + c, x, y});\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111406,
                "title": "minesweeper",
                "content": "I initially solved this problem using Djikstra (see the second approach below), though I find DFS approach more interesting (and it\\u2019s faster).\\n\\n#### Minesweeper\\nThis is a modified BFS, which reminds me of the Minesweeper game. We explore all empty cells, till we hit a wall of obstacles. We remove that wall, and explore new areas of empty cells. We repeat until we reach the destination, and the result is the number of walls we removed.\\n\\n![image](https://assets.leetcode.com/users/images/25ec20b1-b9ff-4718-811c-5866513728e5_1654415206.5237103.png)\\n\\n**C++**\\nWe can use a single deque, pushing empty cells to the front, and obstacles to the back. Instead, we use two queues in the code below - I think it may be a bit easier for me to understand the algorithm. \\n```cpp\\npair<int, int> dirs[4] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\nint minimumObstacles(vector<vector<int>>& g) {\\n    int m = g.size(), n = g[0].size(), res = 0;\\n    deque<array<int, 2>> emp{{0, 0}}, obs;\\n    while (!emp.empty() || !obs.empty()) {\\n        if (emp.empty()) {\\n            ++res;\\n            swap(emp, obs);                \\n        }\\n        const auto [i, j] = emp.front(); emp.pop_front();\\n        if (i == m - 1 && j == n - 1)\\n            break;\\n        for (const auto [dx, dy] : dirs) {\\n            int x = i + dx, y = j + dy;\\n            if (min(x, y) >= 0 && x < m && y < n && g[x][y] >= 0) {\\n                if (g[x][y])\\n                    obs.push_back({x, y});\\n                else\\n                    emp.push_back({x, y});\\n                g[x][y] = -1;\\n            }\\n        } \\n    }\\n    return res;\\n}\\n```\\n\\n#### Djikstra\\nA shortest path here is the one with the least number of obstacles.\\n\\n**C++**\\n```cpp\\nvector<pair<int, int>> dirs{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\nint minimumObstacles(vector<vector<int>>& g) {\\n    int m = g.size(), n = g[0].size();\\n    vector<vector<int>> vis(m, vector<int>(n, INT_MIN));\\n    priority_queue<array<int, 3>> pq;\\n    pq.push({0, 0, 0});\\n    vis[0][0] = 0;\\n    while (!pq.empty() && (pq.top()[1] != m - 1 || pq.top()[2] != n - 1)) {\\n        auto [obs, i, j] = pq.top(); pq.pop();\\n        if (obs > vis[i][j])\\n            continue;\\n        for (auto [dx, dy] : dirs) {\\n            int x = i + dx, y = j + dy;\\n            if (min(x, y) >= 0 && x < m && y < n)\\n                if (vis[x][y] < obs - g[x][y]) {\\n                    vis[x][y] = obs - g[x][y];\\n                    pq.push({obs - g[x][y], x, y});\\n                }\\n        }\\n    }\\n    return -vis[m - 1][n - 1];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\npair<int, int> dirs[4] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\nint minimumObstacles(vector<vector<int>>& g) {\\n    int m = g.size(), n = g[0].size(), res = 0;\\n    deque<array<int, 2>> emp{{0, 0}}, obs;\\n    while (!emp.empty() || !obs.empty()) {\\n        if (emp.empty()) {\\n            ++res;\\n            swap(emp, obs);                \\n        }\\n        const auto [i, j] = emp.front(); emp.pop_front();\\n        if (i == m - 1 && j == n - 1)\\n            break;\\n        for (const auto [dx, dy] : dirs) {\\n            int x = i + dx, y = j + dy;\\n            if (min(x, y) >= 0 && x < m && y < n && g[x][y] >= 0) {\\n                if (g[x][y])\\n                    obs.push_back({x, y});\\n                else\\n                    emp.push_back({x, y});\\n                g[x][y] = -1;\\n            }\\n        } \\n    }\\n    return res;\\n}\\n```\n```cpp\\nvector<pair<int, int>> dirs{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\nint minimumObstacles(vector<vector<int>>& g) {\\n    int m = g.size(), n = g[0].size();\\n    vector<vector<int>> vis(m, vector<int>(n, INT_MIN));\\n    priority_queue<array<int, 3>> pq;\\n    pq.push({0, 0, 0});\\n    vis[0][0] = 0;\\n    while (!pq.empty() && (pq.top()[1] != m - 1 || pq.top()[2] != n - 1)) {\\n        auto [obs, i, j] = pq.top(); pq.pop();\\n        if (obs > vis[i][j])\\n            continue;\\n        for (auto [dx, dy] : dirs) {\\n            int x = i + dx, y = j + dy;\\n            if (min(x, y) >= 0 && x < m && y < n)\\n                if (vis[x][y] < obs - g[x][y]) {\\n                    vis[x][y] = obs - g[x][y];\\n                    pq.push({obs - g[x][y], x, y});\\n                }\\n        }\\n    }\\n    return -vis[m - 1][n - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2086396,
                "title": "c-solution-using-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& mat) {\\n         vector<pair<int,int>>d={{-1,0},{0,1},{1,0},{0,-1}};\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        vector<vector<int>>dp(n,vector<int>(m,INT_MAX));\\n        dp[0][0]=0;\\n        while(q.size())\\n        {\\n            int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                auto temp=q.front();\\n                q.pop();\\n                int x=temp.first;\\n                int y=temp.second;\\n                for(auto it:d)\\n                {\\n                    int nx=x+it.first;\\n                    int ny=y+it.second;\\n                    if(nx>=0&&ny>=0&&nx<n&&ny<m&&dp[x][y]+mat[nx][ny]<dp[nx][ny])\\n                    {\\n                        dp[nx][ny]=dp[x][y]+mat[nx][ny];\\n                         q.push({nx,ny});\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n                \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& mat) {\\n         vector<pair<int,int>>d={{-1,0},{0,1},{1,0},{0,-1}};\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        vector<vector<int>>dp(n,vector<int>(m,INT_MAX));\\n        dp[0][0]=0;\\n        while(q.size())\\n        {\\n            int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                auto temp=q.front();\\n                q.pop();\\n                int x=temp.first;\\n                int y=temp.second;\\n                for(auto it:d)\\n                {\\n                    int nx=x+it.first;\\n                    int ny=y+it.second;\\n                    if(nx>=0&&ny>=0&&nx<n&&ny<m&&dp[x][y]+mat[nx][ny]<dp[nx][ny])\\n                    {\\n                        dp[nx][ny]=dp[x][y]+mat[nx][ny];\\n                         q.push({nx,ny});\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n                \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086516,
                "title": "java-c-o-mn-86ms-explained-updated-on-09-08-22",
                "content": "> **Update on 09/08/2022: C++ BFS solution added**\\n> \\n#### Foreword\\nI saw a lot of solutions with `O(MN*log(MN))`, but we can do better than that. \\nHere I am providing 2 solutions. I think solution 2 may be more straightforward.\\nBoth solutions run in `O(MN)`.\\n\\n#### Solution 1 (Java) - BFS + DFS\\nLet\\'s slowly expand the reachable areas with BFS eliminating walls and then explore with DFS.\\n\\n- Perform a BFS with each BFS layer with a counter (num of elimination required).\\n\\n- Within each BFS, we perform a DFS from each cell in the BFS queue.\\n- Within each DFS, we explore all the cells and enqueue all the walls we can reach back into the BFS queue.\\n- If we are able to reach the end and it is not a wall, we return the current counter.\\n- If not, then we do BFS again and destroy all the walls enqueued in step 1 by marking it as 0\\n- Remember to mark all the cells we\\'ve visited as seen to avoid infinite loop.\\n\\nThe time complexity of this BFS + DFS approach is O(MN) because each cell is only explored at most 2 times. \\n`Time O(MN)`\\n`Space O(MN)`\\n```Java\\nclass Solution {\\n    int m, n;\\n    public int minimumObstacles(int[][] grid) {\\n        m = grid.length; n = grid[0].length;\\n        Queue<int[]> queue = new ArrayDeque<>();\\n        queue.offer(new int[]{0, 0});\\n        for (int i = 0; ; i++){ // i = num of elimination required.\\n            for (int j = queue.size(); j > 0; j--){\\n                int[] p = queue.poll();\\n                grid[p[0]][p[1]] = 0; // eliminate this wall, mark it as 0\\n                if (explore(p[0], p[1], grid, queue))\\n                    return i;\\n            }\\n        }\\n    }\\n\\n    private boolean explore(int i, int j, int[][] grid, Queue<int[]> queue){\\n        if (i < 0 || j < 0 || i == m || j == n || grid[i][j] < 0)\\n            return false;\\n        if (grid[i][j] == 1){\\n            grid[i][j] = -1; // mark as seen so it doesn\\'t get enqueued again\\n            queue.add(new int[]{i, j});\\n            return false;\\n        }\\n        if (i+j == n+m-2)\\n            return true;\\n        grid[i][j] = -1;\\n        return explore(i + 1, j, grid, queue)\\n            || explore(i - 1, j, grid, queue)\\n            || explore(i, j + 1, grid, queue)\\n            || explore(i, j - 1, grid, queue);\\n    }\\n}\\n```\\n\\n#### Solution 2 (C++) - BFS\\nI was reviewing problem and now I found it more straight forward to just do BFS. \\nI have since switched from being a Java user to C++, hence the below.\\n\\nThe idea is more or less the same, but this time we mark it inside BFS. \\nMore details can be found in the comments below.\\n\\n`Time O(MN)`\\n`Space O(MN)`\\n```C++\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int m = size(grid), n = size(grid[0]);\\n        queue<pair<int,int>> q, nq;\\n        vector<vector<bool>> seen(m, vector<bool>(n));\\n        seen[0][0] = 1;\\n        q.push({0, 0});\\n        int dx[4]{0, 0, -1, 1};\\n        int dy[4]{1, -1, 0, 0};\\n        for (int i = 0; ;++i){\\n            while(!q.empty()){ // q is the current queue\\n                auto [x, y] = q.front();\\n                if (x+y==m+n-2){\\n                    return i;\\n                }\\n                q.pop();\\n                for (int k = 0; k < 4; ++k){ // explore all 4 directions\\n                    int nx = x + dx[k];\\n                    int ny = y + dy[k];\\n                    if (nx < 0 || ny < 0 || nx == m || ny == n || seen[nx][ny]){\\n                        continue;\\n                    }\\n                    if (grid[nx][ny]){ // if it is an obstacle, put it in for the next queue\\n                        nq.push({nx, ny});\\n                    }else{ // otherwise it is for the current queue\\n                        q.push({nx, ny});\\n                    }\\n                    seen[nx][ny] = 1; // mark it seen in both cases\\n                }\\n            }\\n            swap(q, nq);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```Java\\nclass Solution {\\n    int m, n;\\n    public int minimumObstacles(int[][] grid) {\\n        m = grid.length; n = grid[0].length;\\n        Queue<int[]> queue = new ArrayDeque<>();\\n        queue.offer(new int[]{0, 0});\\n        for (int i = 0; ; i++){ // i = num of elimination required.\\n            for (int j = queue.size(); j > 0; j--){\\n                int[] p = queue.poll();\\n                grid[p[0]][p[1]] = 0; // eliminate this wall, mark it as 0\\n                if (explore(p[0], p[1], grid, queue))\\n                    return i;\\n            }\\n        }\\n    }\\n\\n    private boolean explore(int i, int j, int[][] grid, Queue<int[]> queue){\\n        if (i < 0 || j < 0 || i == m || j == n || grid[i][j] < 0)\\n            return false;\\n        if (grid[i][j] == 1){\\n            grid[i][j] = -1; // mark as seen so it doesn\\'t get enqueued again\\n            queue.add(new int[]{i, j});\\n            return false;\\n        }\\n        if (i+j == n+m-2)\\n            return true;\\n        grid[i][j] = -1;\\n        return explore(i + 1, j, grid, queue)\\n            || explore(i - 1, j, grid, queue)\\n            || explore(i, j + 1, grid, queue)\\n            || explore(i, j - 1, grid, queue);\\n    }\\n}\\n```\n```C++\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int m = size(grid), n = size(grid[0]);\\n        queue<pair<int,int>> q, nq;\\n        vector<vector<bool>> seen(m, vector<bool>(n));\\n        seen[0][0] = 1;\\n        q.push({0, 0});\\n        int dx[4]{0, 0, -1, 1};\\n        int dy[4]{1, -1, 0, 0};\\n        for (int i = 0; ;++i){\\n            while(!q.empty()){ // q is the current queue\\n                auto [x, y] = q.front();\\n                if (x+y==m+n-2){\\n                    return i;\\n                }\\n                q.pop();\\n                for (int k = 0; k < 4; ++k){ // explore all 4 directions\\n                    int nx = x + dx[k];\\n                    int ny = y + dy[k];\\n                    if (nx < 0 || ny < 0 || nx == m || ny == n || seen[nx][ny]){\\n                        continue;\\n                    }\\n                    if (grid[nx][ny]){ // if it is an obstacle, put it in for the next queue\\n                        nq.push({nx, ny});\\n                    }else{ // otherwise it is for the current queue\\n                        q.push({nx, ny});\\n                    }\\n                    seen[nx][ny] = 1; // mark it seen in both cases\\n                }\\n            }\\n            swap(q, nq);\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085913,
                "title": "why-tle-in-queue-vector-int-st",
                "content": "I had used **queue<vector< int>> st**, in contest, in the same code below, and it was not accepted and giving TLE, but if i am using **queue<pair<int,int>> st**, it is getting accepted. Why???\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> v;\\n    int n,m;\\n    vector<int> dx={-1,0,1,0};\\n    vector<int> dy={0,1,0,-1};\\n    void bfs(vector<vector<int>>& g){\\n        queue<pair<int,int>> st;\\n        v=vector<vector<int>>(n,vector<int>(m,INT_MAX));\\n        st.push({0,0});\\n        v[0][0]=0;\\n        while(!st.empty()){\\n            auto it=(st.front());\\n            st.pop();\\n            int i=it.first;\\n            int j=it.second;\\n            for(int z=0;z<4;z++){\\n                int x=i+dx[z];\\n                int y=j+dy[z];\\n                if(x<0||y<0||x>=n||y>=m||v[i][j]+g[x][y]>=v[x][y]) continue;\\n                v[x][y]=v[i][j]+g[x][y];\\n                st.push({x,y});\\n            }\\n        }\\n        return ;\\n    }\\n    int minimumObstacles(vector<vector<int>>& g) {\\n        n=g.size(),m=g[0].size();\\n        bfs(g);\\n        return v[n-1][m-1]; \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> v;\\n    int n,m;\\n    vector<int> dx={-1,0,1,0}",
                "codeTag": "Java"
            },
            {
                "id": 2085733,
                "title": "java-a-very-simple-o-mn-bfs-solution-with-explanation-by-drying-run-examples",
                "content": "Please help to upvote if the post is helpful to you, it will help this post to go to top and more people can read it. Thank you.\\n\\nThe idea is that we will move to next obstacle cells in each step.\\n\\n**Dry run Example 1:**\\n![image](https://assets.leetcode.com/uploads/2022/04/06/example1drawio-1.png)\\nStep 0: states = [[0, 0]] // all empty cells can be reached from [0, 0]\\nStep 1: states = [[0, 1], [1, 0]] // all obstacle neighbors can be reached from Step 0\\nStep 2: states = [[2, 0], [1, 1], [0, 2]] // all obstacle neighbors can be reached from Step 1\\nNow, we can reach target cell from [1, 1] or [0, 2], so 2 will be the result (need to remove 1 cell in Step 1 and 1 cell in Step 2).\\n\\n**Dry run Example 2:**\\n![image](https://assets.leetcode.com/uploads/2022/04/06/example1drawio.png)\\nStep 0: states = [[0, 0], [1, 0], [2, 0], [2, 1], [2, 2], [1, 2], [0, 2], [0, 3], [0, 4],  [1, 4], [2, 4]] // all empty cells can be reached from [0, 0]\\nWe can reach target from step 0, so 0 will be the result\\n\\nHere\\'s the detail implementation\\n\\n```\\nclass Solution {\\n    \\n    int[] d = {-1, 0, 1, 0, -1};\\n    \\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\t\\tQueue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0, 0});\\n        grid[0][0] = -1; // [0, 0]  was visited\\n        int step = 0;\\n        while (!q.isEmpty()) {\\n\\t\\t\\tQueue<int[]> q2 = new LinkedList<>(); // q2 will store obstacle cells can be reached from q\\n            while (!q.isEmpty()) {\\n                int[] node = q.poll();\\n                if (node[0] == m - 1 && node[1] == n - 1) {\\n                    return step;\\n                }\\n                for (int k = 0; k < 4; ++k) {\\n                    int x = node[0] + d[k];\\n                    int y = node[1] + d[k+1];\\n                    if (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] != -1) {\\n                        if (grid[x][y] == 0) {\\n                            q.add(new int[]{x, y});\\n                        } else { // grid[x][y] == 1 (obstacle)\\n                            q2.add(new int[]{x, y});\\n                        }\\n                        grid[x][y] = -1; // [x, y]  was visited\\n                    }\\n                }\\n            }\\n            q = q2;\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nTime complexity: O(mn)\\nSpace complexity: O(mn)",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int[] d = {-1, 0, 1, 0, -1};\\n    \\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\t\\tQueue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0, 0});\\n        grid[0][0] = -1; // [0, 0]  was visited\\n        int step = 0;\\n        while (!q.isEmpty()) {\\n\\t\\t\\tQueue<int[]> q2 = new LinkedList<>(); // q2 will store obstacle cells can be reached from q\\n            while (!q.isEmpty()) {\\n                int[] node = q.poll();\\n                if (node[0] == m - 1 && node[1] == n - 1) {\\n                    return step;\\n                }\\n                for (int k = 0; k < 4; ++k) {\\n                    int x = node[0] + d[k];\\n                    int y = node[1] + d[k+1];\\n                    if (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] != -1) {\\n                        if (grid[x][y] == 0) {\\n                            q.add(new int[]{x, y});\\n                        } else { // grid[x][y] == 1 (obstacle)\\n                            q2.add(new int[]{x, y});\\n                        }\\n                        grid[x][y] = -1; // [x, y]  was visited\\n                    }\\n                }\\n            }\\n            q = q2;\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085671,
                "title": "dijkstra-s-algo-java",
                "content": "```\\npublic int minimumObstacles(int[][] grid) {\\n        PriorityQueue<int[]> q = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        int[][] dir = new int[][] {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        int m = grid.length, n = grid[0].length;\\n        int[][] count = new int[m][n];\\n        for(int i = 0;i < m;i++) {\\n            Arrays.fill(count[i], Integer.MAX_VALUE);\\n        }\\n        count[0][0] = 0;\\n        q.offer(new int[]{0, 0, 0});\\n        while(!q.isEmpty()) {\\n            int[] cur = q.poll();\\n            int x = cur[0];\\n            int y = cur[1];\\n            int cost = cur[2];\\n            if(x == m - 1 && y == n - 1) {\\n                return cost;\\n            }\\n            for(int i = 0;i < 4;i++) {\\n                int nx = x + dir[i][0];\\n                int ny = y + dir[i][1];\\n                if(nx < 0 || ny < 0 || nx >= m || ny >= n) {\\n                    continue;\\n                }\\n                int now = cur[2];\\n                if(grid[nx][ny] == 1) {\\n                    now++;\\n                }\\n                if(now >= count[nx][ny]) {\\n                    continue;\\n                }\\n                \\n                count[nx][ny] = now;\\n                q.offer(new int[] {nx, ny, now});\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minimumObstacles(int[][] grid) {\\n        PriorityQueue<int[]> q = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        int[][] dir = new int[][] {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        int m = grid.length, n = grid[0].length;\\n        int[][] count = new int[m][n];\\n        for(int i = 0;i < m;i++) {\\n            Arrays.fill(count[i], Integer.MAX_VALUE);\\n        }\\n        count[0][0] = 0;\\n        q.offer(new int[]{0, 0, 0});\\n        while(!q.isEmpty()) {\\n            int[] cur = q.poll();\\n            int x = cur[0];\\n            int y = cur[1];\\n            int cost = cur[2];\\n            if(x == m - 1 && y == n - 1) {\\n                return cost;\\n            }\\n            for(int i = 0;i < 4;i++) {\\n                int nx = x + dir[i][0];\\n                int ny = y + dir[i][1];\\n                if(nx < 0 || ny < 0 || nx >= m || ny >= n) {\\n                    continue;\\n                }\\n                int now = cur[2];\\n                if(grid[nx][ny] == 1) {\\n                    now++;\\n                }\\n                if(now >= count[nx][ny]) {\\n                    continue;\\n                }\\n                \\n                count[nx][ny] = now;\\n                q.offer(new int[] {nx, ny, now});\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2086607,
                "title": "python-easy-to-understand-dijkstra",
                "content": "Perhaps there can be slightly more efficient solutions, however i think this solution is very simple to understand and easy to implement.\\n\\nq - min heap which uses the number of obstacles so far as a key.\\ndist - array of shortest path distances to each cell.\\nobs - minimum number of obstacles we had to pass in order to get to the currect cell.\\n\\n\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        q = [(0, 0, 0)]\\n        dist = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]\\n\\n        while q:\\n            size = len(q)\\n            for _ in range(size):\\n                obs, x, y = heapq.heappop(q)\\n                if dist[x][y] < float(\\'inf\\'): continue\\n                obs += grid[x][y]\\n                dist[x][y] = obs\\n                if x + 1 < m: heapq.heappush(q, (obs, x + 1, y))\\n                if x > 0: heapq.heappush(q, (obs, x - 1, y))\\n                if y + 1 < n: heapq.heappush(q, (obs, x, y + 1))\\n                if y > 0: heapq.heappush(q, (obs, x, y - 1))\\n        return dist[m - 1][n - 1]\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        q = [(0, 0, 0)]\\n        dist = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]\\n\\n        while q:\\n            size = len(q)\\n            for _ in range(size):\\n                obs, x, y = heapq.heappop(q)\\n                if dist[x][y] < float(\\'inf\\'): continue\\n                obs += grid[x][y]\\n                dist[x][y] = obs\\n                if x + 1 < m: heapq.heappush(q, (obs, x + 1, y))\\n                if x > 0: heapq.heappush(q, (obs, x - 1, y))\\n                if y + 1 < n: heapq.heappush(q, (obs, x, y + 1))\\n                if y > 0: heapq.heappush(q, (obs, x, y - 1))\\n        return dist[m - 1][n - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086125,
                "title": "solution-using-0-1-bfs",
                "content": "```\\nconst int dx[4]={0, 0, 1, -1};\\nconst int dy[4]={1, -1, 0, 0};\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        vector<vector<int>> dist(n+1, vector<int>(m+1, 1e9));\\n        dist[0][0]=0;\\n        \\n        deque<pair<int, int>> qq;\\n        qq.push_front({0, 0});\\n        \\n        \\n        while(!qq.empty())\\n        {\\n            auto [x, y]=qq.front();\\n            qq.pop_front();\\n            \\n            for(int k=0; k<4; k++)\\n            {\\n                int xx=x+dx[k];\\n                int yy=y+dy[k];\\n                \\n                if(xx>=0 && yy>=0 && xx<n && yy<m && dist[xx][yy]>dist[x][y]+grid[xx][yy])\\n                {\\n                    dist[xx][yy]=dist[x][y]+grid[xx][yy];\\n                    if(grid[xx][yy])\\n                        qq.push_back({xx, yy});\\n                    else\\n                        qq.push_front({xx, yy});\\n                }\\n            }\\n        }\\n        return dist[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nconst int dx[4]={0, 0, 1, -1};\\nconst int dy[4]={1, -1, 0, 0};\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        vector<vector<int>> dist(n+1, vector<int>(m+1, 1e9));\\n        dist[0][0]=0;\\n        \\n        deque<pair<int, int>> qq;\\n        qq.push_front({0, 0});\\n        \\n        \\n        while(!qq.empty())\\n        {\\n            auto [x, y]=qq.front();\\n            qq.pop_front();\\n            \\n            for(int k=0; k<4; k++)\\n            {\\n                int xx=x+dx[k];\\n                int yy=y+dy[k];\\n                \\n                if(xx>=0 && yy>=0 && xx<n && yy<m && dist[xx][yy]>dist[x][y]+grid[xx][yy])\\n                {\\n                    dist[xx][yy]=dist[x][y]+grid[xx][yy];\\n                    if(grid[xx][yy])\\n                        qq.push_back({xx, yy});\\n                    else\\n                        qq.push_front({xx, yy});\\n                }\\n            }\\n        }\\n        return dist[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2097032,
                "title": "c-dfs-dijkstra-s-algorithm-without-priority-queue-vector-queue",
                "content": "Runtime: 894 ms, faster than 74.67% of C++ online submissions for Minimum Obstacle Removal to Reach Corner.\\nMemory Usage: 104.2 MB, less than 60.23% of C++ online submissions for Minimum Obstacle Removal to Reach Corner.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        \\n        vector<vector<int >> dp(m + 1, vector<int>(n + 1, 10000001));\\n        queue<pair<int,int >> q;\\n        q.push({0, 0});\\n        \\n        dp[0][0] = 0;\\n        \\n        int dx[] = {-1, 1, 0, 0};\\n        int dy[] = {0, 0, -1, 1};\\n        while(!q.empty()){\\n            auto curr = q.front(); q.pop();\\n            for(int i = 0; i < 4; i++){\\n                int x = dx[i] + curr.first, y = dy[i] + curr.second;\\n                \\n                if(x >= 0 && y >= 0 && x < m && y < n && grid[x][y] + dp[curr.first][curr.second] < dp[x][y]){\\n                    dp[x][y] = grid[x][y] + dp[curr.first][curr.second];\\n                    q.push({x, y});\\n                }\\n            }\\n        }\\n        \\n        return dp[m - 1][n - 1];\\n    }\\n};\\n```\\n\\nplease hit like. Thanks.",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        \\n        vector<vector<int >> dp(m + 1, vector<int>(n + 1, 10000001));\\n        queue<pair<int,int >> q;\\n        q.push({0, 0});\\n        \\n        dp[0][0] = 0;\\n        \\n        int dx[] = {-1, 1, 0, 0};\\n        int dy[] = {0, 0, -1, 1};\\n        while(!q.empty()){\\n            auto curr = q.front(); q.pop();\\n            for(int i = 0; i < 4; i++){\\n                int x = dx[i] + curr.first, y = dy[i] + curr.second;\\n                \\n                if(x >= 0 && y >= 0 && x < m && y < n && grid[x][y] + dp[curr.first][curr.second] < dp[x][y]){\\n                    dp[x][y] = grid[x][y] + dp[curr.first][curr.second];\\n                    q.push({x, y});\\n                }\\n            }\\n        }\\n        \\n        return dp[m - 1][n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086669,
                "title": "bfs-solution-using-multiset-c",
                "content": "**Hello guys,**\\nthis is a very simple explanation for `Minimum Obstacle Removal to Reach Corner` problem.\\n\\ninsert a[0][0] in multiset initially\\nnow get ms.begin(), it will give shortest distance path till now,\\n`pair<int,pair<int,int>>p=*ms.begin();`\\n`int x=p.second.first, y=p.second.second;` // current node\\'s position\\n\\nlet check for further path in all possible 4 directions means means (x-1,y), (x+1,y), (x,y-1) & (x,y+1)\\nand check if neighbour nodes are unvisited and theirs distance are greater `dis[x][y]+a[x][y]`\\n\\n**Here** `dis[x][y]` gives minimum number of Obstacle removal to reach (i,j)\\n\\n**for eg.**\\nwe are checking node (x-1,y) then,\\n```\\nif(x-1>=0 && vis[x-1][y]==0) { \\n\\tif(dis[x-1][y]>dis[x][y]+a[x][y]) // check if dis is greater\\n\\t{\\n\\t\\tdis[x-1][y]=dis[x][y]+a[x][y]; // update distance\\n\\t\\tms.insert({dis[x-1][y], {x-1,y}});\\n\\t}\\n}\\n```\\nwe get minimum number of Obstacle removal count in `dis[n-1][m-1]`\\n\\n**Code:**\\n\\n```\\n#define pb push_back\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& a) {\\n        \\n        int n=a.size(), m=a[0].size();\\n        int node=n*m;\\n        \\n        int vis[n+1][m+1];\\n        memset(vis, 0, sizeof(vis));\\n        \\n        int dis[n+1][m+1];\\n        for(int i=0;i<=n;++i) for(int j=0;j<=m;++j) dis[i][j]=1e7;\\n        dis[0][0]=a[0][0];\\n        \\n        multiset<pair<int,pair<int,int>>>ms;\\n        ms.insert({dis[0][0],{0,0}});\\n        \\n        while(ms.size())\\n        {\\n            pair<int,pair<int,int>>p=*ms.begin();\\n            ms.erase(ms.begin());\\n            \\n            int d=p.first;\\n            int x=p.second.first, y=p.second.second;\\n            if(vis[x][y]) continue;\\n            vis[x][y]=1;\\n            \\n            if(x-1>=0 && vis[x-1][y]==0) {\\n                if(dis[x-1][y]>dis[x][y]+a[x][y])\\n                {\\n                    dis[x-1][y]=dis[x][y]+a[x][y];\\n                    ms.insert({dis[x-1][y], {x-1,y}});\\n                }\\n            }\\n            if(x+1<n && vis[x+1][y]==0) {\\n                if(dis[x+1][y]>dis[x][y]+a[x][y])\\n                {\\n                    dis[x+1][y]=dis[x][y]+a[x][y];\\n                    ms.insert({dis[x+1][y], {x+1,y}});\\n                }\\n            }\\n            if(y-1>=0 && vis[x][y-1]==0) {\\n                if(dis[x][y-1]>dis[x][y]+a[x][y])\\n                {\\n                    dis[x][y-1]=dis[x][y]+a[x][y];\\n                    ms.insert({dis[x][y-1], {x,y-1}});\\n                }\\n            }\\n            if(y+1<m && vis[x][y+1]==0) {\\n                if(dis[x][y+1]>dis[x][y]+a[x][y])\\n                {\\n                    dis[x][y+1]=dis[x][y]+a[x][y];\\n                    ms.insert({dis[x][y+1], {x,y+1}});\\n                }\\n            }\\n        }\\n        \\n        return dis[n-1][m-1];\\n        \\n    }\\n};\\n```\\n\\nThanks...",
                "solutionTags": [
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nif(x-1>=0 && vis[x-1][y]==0) { \\n\\tif(dis[x-1][y]>dis[x][y]+a[x][y]) // check if dis is greater\\n\\t{\\n\\t\\tdis[x-1][y]=dis[x][y]+a[x][y]; // update distance\\n\\t\\tms.insert({dis[x-1][y], {x-1,y}});\\n\\t}\\n}\\n```\n```\\n#define pb push_back\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& a) {\\n        \\n        int n=a.size(), m=a[0].size();\\n        int node=n*m;\\n        \\n        int vis[n+1][m+1];\\n        memset(vis, 0, sizeof(vis));\\n        \\n        int dis[n+1][m+1];\\n        for(int i=0;i<=n;++i) for(int j=0;j<=m;++j) dis[i][j]=1e7;\\n        dis[0][0]=a[0][0];\\n        \\n        multiset<pair<int,pair<int,int>>>ms;\\n        ms.insert({dis[0][0],{0,0}});\\n        \\n        while(ms.size())\\n        {\\n            pair<int,pair<int,int>>p=*ms.begin();\\n            ms.erase(ms.begin());\\n            \\n            int d=p.first;\\n            int x=p.second.first, y=p.second.second;\\n            if(vis[x][y]) continue;\\n            vis[x][y]=1;\\n            \\n            if(x-1>=0 && vis[x-1][y]==0) {\\n                if(dis[x-1][y]>dis[x][y]+a[x][y])\\n                {\\n                    dis[x-1][y]=dis[x][y]+a[x][y];\\n                    ms.insert({dis[x-1][y], {x-1,y}});\\n                }\\n            }\\n            if(x+1<n && vis[x+1][y]==0) {\\n                if(dis[x+1][y]>dis[x][y]+a[x][y])\\n                {\\n                    dis[x+1][y]=dis[x][y]+a[x][y];\\n                    ms.insert({dis[x+1][y], {x+1,y}});\\n                }\\n            }\\n            if(y-1>=0 && vis[x][y-1]==0) {\\n                if(dis[x][y-1]>dis[x][y]+a[x][y])\\n                {\\n                    dis[x][y-1]=dis[x][y]+a[x][y];\\n                    ms.insert({dis[x][y-1], {x,y-1}});\\n                }\\n            }\\n            if(y+1<m && vis[x][y+1]==0) {\\n                if(dis[x][y+1]>dis[x][y]+a[x][y])\\n                {\\n                    dis[x][y+1]=dis[x][y]+a[x][y];\\n                    ms.insert({dis[x][y+1], {x,y+1}});\\n                }\\n            }\\n        }\\n        \\n        return dis[n-1][m-1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085938,
                "title": "why-dp-fails-explanation-and-dijkstra-s-algo-bfs-solution",
                "content": "This question was asked to me in Hackwithinfy 2022 1st round \\nIf it was given two direction we could always go with DP (graph also works) , but since its given 4 directions dp fails  , graph saves\\n\\nOne of the example where DP fails :\\n\\n0 1 0 0\\n0 0 0 0\\n1 1 1 0\\n\\nBecause here u revisit some states number of times as first visit might not give minimum answer ( but if u use DP u wont be allowed to visit again because u memoize it during first visit only ) \\n\\nBFS based implementation : \\n\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;\\n        vector<vector<bool>> vis(n+1,vector<bool>(m+1,false));\\n        int cnt = 0;\\n        if(grid[0][0]==1){\\n            cnt++;\\n        }\\n        \\n        pq.push({cnt,{0,0}});\\n        vis[0][0]=true;\\n        vector<vector<int>> dir = {{1,0},{0,1},{-1,0},{0,-1}};\\n        while(pq.empty()==false){\\n            long long x = pq.top().second.first;\\n            long long y = pq.top().second.second;\\n            long long dist = pq.top().first;\\n            pq.pop();\\n            if(x==n-1 && y==m-1){\\n                return dist;\\n            }\\n            for(auto &mov : dir){\\n                long long newx = x + mov[0];\\n                long long newy = y + mov[1];\\n                if(newx>=0 && newx<n && newy>=0 && newy<m && vis[newx][newy]==false){\\n                    if(grid[newx][newy]==0){\\n                        pq.push({dist,{newx,newy}});\\n                        vis[newx][newy]=true;\\n                    }\\n                    else{\\n                        pq.push({dist+1,{newx,newy}});\\n                        vis[newx][newy]=true;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nShortest Path - Dijkstra\\'s algo\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<long long>> dist(n+1,vector<long long>(m+1,1e8));\\n        queue<pair<int,int>> q;\\n        int cnt = 0;\\n        if(grid[0][0]==1){\\n            cnt++;\\n        }\\n        q.push({0,0});\\n        dist[0][0]=cnt;\\n        vector<vector<int>> dir = {{1,0},{0,1},{-1,0},{0,-1}};\\n        while(q.empty()==false){\\n            long long x = q.front().first;\\n            long long y = q.front().second;\\n            q.pop();\\n            for(auto &mov : dir){\\n                long long newx = x + mov[0];\\n                long long newy = y + mov[1];\\n                if(newx>=0 && newx<n && newy>=0 && newy<m && dist[x][y]+grid[newx][newy]<dist[newx][newy]){\\n                    dist[newx][newy] = dist[x][y]+grid[newx][newy];\\n                    q.push({newx,newy});\\n                }\\n            }\\n        }\\n        return dist[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;\\n        vector<vector<bool>> vis(n+1,vector<bool>(m+1,false));\\n        int cnt = 0;\\n        if(grid[0][0]==1){\\n            cnt++;\\n        }\\n        \\n        pq.push({cnt,{0,0}});\\n        vis[0][0]=true;\\n        vector<vector<int>> dir = {{1,0},{0,1},{-1,0},{0,-1}};\\n        while(pq.empty()==false){\\n            long long x = pq.top().second.first;\\n            long long y = pq.top().second.second;\\n            long long dist = pq.top().first;\\n            pq.pop();\\n            if(x==n-1 && y==m-1){\\n                return dist;\\n            }\\n            for(auto &mov : dir){\\n                long long newx = x + mov[0];\\n                long long newy = y + mov[1];\\n                if(newx>=0 && newx<n && newy>=0 && newy<m && vis[newx][newy]==false){\\n                    if(grid[newx][newy]==0){\\n                        pq.push({dist,{newx,newy}});\\n                        vis[newx][newy]=true;\\n                    }\\n                    else{\\n                        pq.push({dist+1,{newx,newy}});\\n                        vis[newx][newy]=true;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<long long>> dist(n+1,vector<long long>(m+1,1e8));\\n        queue<pair<int,int>> q;\\n        int cnt = 0;\\n        if(grid[0][0]==1){\\n            cnt++;\\n        }\\n        q.push({0,0});\\n        dist[0][0]=cnt;\\n        vector<vector<int>> dir = {{1,0},{0,1},{-1,0},{0,-1}};\\n        while(q.empty()==false){\\n            long long x = q.front().first;\\n            long long y = q.front().second;\\n            q.pop();\\n            for(auto &mov : dir){\\n                long long newx = x + mov[0];\\n                long long newy = y + mov[1];\\n                if(newx>=0 && newx<n && newy>=0 && newy<m && dist[x][y]+grid[newx][newy]<dist[newx][newy]){\\n                    dist[newx][newy] = dist[x][y]+grid[newx][newy];\\n                    q.push({newx,newy});\\n                }\\n            }\\n        }\\n        return dist[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705274,
                "title": "python-3-0-1-bfs-easy-to-understand",
                "content": "# Intuition\\nFind the shortest path with the weight is only 0 or 1 => 0-1 BFS\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ncan refer 0-1 BFS [here](https://cp-algorithms.com/graph/01_bfs.html#algorithm)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(E)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(E)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        distance = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]\\n        distance[0][0] = 0\\n        q = collections.deque([(0, 0, 0)])\\n        while q:\\n            d, i, j = q.popleft()\\n            if i == m - 1 and j == n - 1: return d\\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                ci, cj = i + di, j + dj\\n                if 0 <= ci < m and 0 <= cj < n:\\n                    if d + grid[ci][cj] < distance[ci][cj]:\\n                        distance[ci][cj] = d + grid[ci][cj]\\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\\n                        else: q.appendleft((distance[ci][cj], ci, cj))\\n        return distance[m - 1][n - 1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        distance = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]\\n        distance[0][0] = 0\\n        q = collections.deque([(0, 0, 0)])\\n        while q:\\n            d, i, j = q.popleft()\\n            if i == m - 1 and j == n - 1: return d\\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                ci, cj = i + di, j + dj\\n                if 0 <= ci < m and 0 <= cj < n:\\n                    if d + grid[ci][cj] < distance[ci][cj]:\\n                        distance[ci][cj] = d + grid[ci][cj]\\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\\n                        else: q.appendleft((distance[ci][cj], ci, cj))\\n        return distance[m - 1][n - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2366676,
                "title": "solve-using-01-bfs",
                "content": "* We can solve this problem with Dijktra\\'s algo thats quite obvious but when the weights of the graph is not large or it limited to small number lets say k i.e. weight ranges from 1 to k we can use BFS. \\n* Here in this question its given that weight is either 0 or 1 so instead of using Dijktra we can go for 01 BFS. \\n* Attaching some video links and tutorial links which you can refer to understand this concept.\\n https://www.youtube.com/watch?v=Xqq7uELiYnE&t=63s\\n https://www.youtube.com/watch?v=4DiOHNuO8To\\n https://cp-algorithms.com/graph/01_bfs.html\\n\\n```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        int[][] dist = new int[n][m];\\n        \\n        for(int[] d: dist){\\n            Arrays.fill(d,Integer.MAX_VALUE);\\n        }\\n        \\n        int dx[]={-1,1,0,0};\\n        int dy[]={0,0,-1,1};\\n        \\n        LinkedList<int[]> q = new LinkedList<>();\\n        \\n        dist[0][0] = grid[0][0];\\n        \\n        q.addFirst(new int[]{dist[0][0],0,0});\\n        \\n        while(!q.isEmpty()){\\n            int sz=q.size();\\n            while(sz-->0){\\n                int[] cur = q.poll();\\n                int cost = cur[0], x = cur[1], y = cur[2];\\n                \\n                for(int k=0;k<4;k++){\\n                    int nx=x+dx[k];\\n                    int ny=y+dy[k];\\n                    if(nx>=0 && nx<n && ny>=0 && ny<m && dist[nx][ny]>grid[nx][ny]+cost) {\\n                        dist[nx][ny]=grid[nx][ny]+cost;\\n                        \\n                        if(grid[nx][ny]==0){\\n                            q.addFirst(new int[]{dist[nx][ny],nx,ny});\\n                        }else{\\n                            q.addLast(new int[]{dist[nx][ny],nx,ny});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dist[n-1][m-1];\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        int[][] dist = new int[n][m];\\n        \\n        for(int[] d: dist){\\n            Arrays.fill(d,Integer.MAX_VALUE);\\n        }\\n        \\n        int dx[]={-1,1,0,0};\\n        int dy[]={0,0,-1,1};\\n        \\n        LinkedList<int[]> q = new LinkedList<>();\\n        \\n        dist[0][0] = grid[0][0];\\n        \\n        q.addFirst(new int[]{dist[0][0],0,0});\\n        \\n        while(!q.isEmpty()){\\n            int sz=q.size();\\n            while(sz-->0){\\n                int[] cur = q.poll();\\n                int cost = cur[0], x = cur[1], y = cur[2];\\n                \\n                for(int k=0;k<4;k++){\\n                    int nx=x+dx[k];\\n                    int ny=y+dy[k];\\n                    if(nx>=0 && nx<n && ny>=0 && ny<m && dist[nx][ny]>grid[nx][ny]+cost) {\\n                        dist[nx][ny]=grid[nx][ny]+cost;\\n                        \\n                        if(grid[nx][ny]==0){\\n                            q.addFirst(new int[]{dist[nx][ny],nx,ny});\\n                        }else{\\n                            q.addLast(new int[]{dist[nx][ny],nx,ny});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dist[n-1][m-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207665,
                "title": "python-bfs-easy",
                "content": "here seen is used to track the state of the cells , i.e, the min number of obstacles removed from the start to reach current position.  it is pruning, removing the paths which demands equal or more obstables to reach the position.\\n\\n```\\ndef minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m,n=len(grid),len(grid[0])\\n        q=[]\\n        heappush(q,[0,0,0]) ## [# obstacles, x, y]\\n        seen=[[float(\"inf\") for j in range(n)] for i in range(m)]\\n        seen[0][0]=0 ## min obstables on the path\\n        dirs=[0,1,0,-1,0]\\n        while q:\\n            obs,r,c=heappop(q)\\n            if r==m-1 and c==n-1:\\n                return obs\\n            for i in range(4):\\n                x,y=dirs[i],dirs[i+1]\\n                nr,nc=r+x,c+y\\n                if nr<0 or nr>=m or nc<0 or nc>=n:continue\\n                new_obs=obs+grid[nr][nc]\\n                if new_obs>=seen[nr][nc]:continue\\n                heappush(q, [new_obs,nr,nc])\\n                seen[nr][nc]=new_obs                \\n        return m+n-2",
                "solutionTags": [],
                "code": "here seen is used to track the state of the cells , i.e, the min number of obstacles removed from the start to reach current position.  it is pruning, removing the paths which demands equal or more obstables to reach the position.\\n\\n```\\ndef minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m,n=len(grid),len(grid[0])\\n        q=[]\\n        heappush(q,[0,0,0]) ## [# obstacles, x, y]\\n        seen=[[float(\"inf\") for j in range(n)] for i in range(m)]\\n        seen[0][0]=0 ## min obstables on the path\\n        dirs=[0,1,0,-1,0]\\n        while q:\\n            obs,r,c=heappop(q)\\n            if r==m-1 and c==n-1:\\n                return obs\\n            for i in range(4):\\n                x,y=dirs[i],dirs[i+1]\\n                nr,nc=r+x,c+y\\n                if nr<0 or nr>=m or nc<0 or nc>=n:continue\\n                new_obs=obs+grid[nr][nc]\\n                if new_obs>=seen[nr][nc]:continue\\n                heappush(q, [new_obs,nr,nc])\\n                seen[nr][nc]=new_obs                \\n        return m+n-2",
                "codeTag": "Python3"
            },
            {
                "id": 2086710,
                "title": "c-simple-dijkstras-straight-forward-no-dp-matrix-clean-code",
                "content": "```\\n int minimumObstacles(vector<vector<int>>& grid) {\\n        \\n        int m =grid.size();\\n        int n=grid[0].size();\\n        \\n        int dx[4]={ 1 , -1 , 0 , 0};\\n        int dy[4]={ 0 , 0 , 1 , -1};\\n        \\n        priority_queue< pair<int , pair<int ,int>> , vector<pair<int , pair<int ,int>>> , greater<pair<int , pair<int ,int>>> > pq;\\n        \\n        pq.push({0 , {0,0}});\\n        \\n        // obs , x , y\\n        \\n        grid[0][0]=-1;\\n        \\n        // visited \\n        \\n        \\n         while(!pq.empty())\\n         {\\n             int obs= pq.top().first;\\n             int x=pq.top().second.first;\\n             \\n             int y=pq.top().second.second;\\n             \\n             pq.pop();\\n             \\n             if(x==m-1 && y==n-1)\\n             {\\n                 return obs;\\n             }\\n             \\n             for(int k=0;k<4;k++)\\n             {\\n                 int newx=x+dx[k];\\n                 int newy=y+dy[k];\\n                 \\n                 if(newx>=0 && newy>=0 && newx<m && newy<n && grid[newx][newy]!=-1)\\n                 {\\n                     pq.push({obs + grid[newx][newy] ,{newx , newy}});\\n                     grid[newx][newy]=-1;\\n                 }\\n             }\\n         }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n int minimumObstacles(vector<vector<int>>& grid) {\\n        \\n        int m =grid.size();\\n        int n=grid[0].size();\\n        \\n        int dx[4]={ 1 , -1 , 0 , 0};\\n        int dy[4]={ 0 , 0 , 1 , -1};\\n        \\n        priority_queue< pair<int , pair<int ,int>> , vector<pair<int , pair<int ,int>>> , greater<pair<int , pair<int ,int>>> > pq;\\n        \\n        pq.push({0 , {0,0}});\\n        \\n        // obs , x , y\\n        \\n        grid[0][0]=-1;\\n        \\n        // visited \\n        \\n        \\n         while(!pq.empty())\\n         {\\n             int obs= pq.top().first;\\n             int x=pq.top().second.first;\\n             \\n             int y=pq.top().second.second;\\n             \\n             pq.pop();\\n             \\n             if(x==m-1 && y==n-1)\\n             {\\n                 return obs;\\n             }\\n             \\n             for(int k=0;k<4;k++)\\n             {\\n                 int newx=x+dx[k];\\n                 int newy=y+dy[k];\\n                 \\n                 if(newx>=0 && newy>=0 && newx<m && newy<n && grid[newx][newy]!=-1)\\n                 {\\n                     pq.push({obs + grid[newx][newy] ,{newx , newy}});\\n                     grid[newx][newy]=-1;\\n                 }\\n             }\\n         }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2086192,
                "title": "c-100-memory-efficient-in-c-submissions",
                "content": "```\\n#define pii pair<int,int>\\n#define pipii pair<int,pii>\\n#define F first\\n#define S second\\nclass Solution {\\npublic:\\n    int x[4] = {0, 0, -1, 1};\\n    int y[4] = {1, -1, 0, 0};\\n    bool isValidLocation(int i, int j, int n, int m)\\n    {\\n        return (i>=0 && j>=0 && i<n && j<m);\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        priority_queue<pipii, vector<pipii>, greater<pipii>> q;\\n        vector<vector<bool>> vis(n, vector<bool>(m, false));\\n        q.push({0, {0, 0}});\\n        vis[0][0] = true;\\n        while(!q.empty())\\n        {\\n            pipii front = q.top();\\n            q.pop();\\n            \\n            if(front.S.F == n-1 && front.S.S == m-1)\\n                return front.F;\\n            \\n            for(int k=0; k<4; k++)\\n            {\\n                int cx = front.S.F + x[k];\\n                int cy = front.S.S + y[k];\\n                \\n                if(isValidLocation(cx, cy, n, m) && !vis[cx][cy])\\n                {\\n                    vis[cx][cy] = true;\\n                    \\n                    if(grid[cx][cy])\\n                        q.push({front.F+1, {cx, cy}});\\n                    else\\n                        q.push({front.F, {cx, cy}});\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n#define pii pair<int,int>\\n#define pipii pair<int,pii>\\n#define F first\\n#define S second\\nclass Solution {\\npublic:\\n    int x[4] = {0, 0, -1, 1};\\n    int y[4] = {1, -1, 0, 0};\\n    bool isValidLocation(int i, int j, int n, int m)\\n    {\\n        return (i>=0 && j>=0 && i<n && j<m);\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        priority_queue<pipii, vector<pipii>, greater<pipii>> q;\\n        vector<vector<bool>> vis(n, vector<bool>(m, false));\\n        q.push({0, {0, 0}});\\n        vis[0][0] = true;\\n        while(!q.empty())\\n        {\\n            pipii front = q.top();\\n            q.pop();\\n            \\n            if(front.S.F == n-1 && front.S.S == m-1)\\n                return front.F;\\n            \\n            for(int k=0; k<4; k++)\\n            {\\n                int cx = front.S.F + x[k];\\n                int cy = front.S.S + y[k];\\n                \\n                if(isValidLocation(cx, cy, n, m) && !vis[cx][cy])\\n                {\\n                    vis[cx][cy] = true;\\n                    \\n                    if(grid[cx][cy])\\n                        q.push({front.F+1, {cx, cy}});\\n                    else\\n                        q.push({front.F, {cx, cy}});\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085899,
                "title": "dp-error",
                "content": "**Can some 1 tell me whats wrong with this dp approach**\\n\\nclass Solution {\\npublic:\\n    int mn=INT_MAX;\\nint f(vector<vector<int>>&grid,int i,int j,vector<vector<int>>&dp){\\n    if(i==0 && j==0){\\n        return grid[i][j];\\n    }\\n    if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size()){\\n        return INT_MAX;\\n    }\\n    if(dp[i][j]!=-1){\\n        return dp[i][j];\\n\\n    }\\n    int cnt1=grid[i][j]+f(grid,i-1,j,dp);\\n    int cnt2=grid[i][j]+f(grid,i+1,j,dp);\\n    int cnt3=grid[i][j]+f(grid,i,j-1,dp);\\n    int cnt4=grid[i][j]+f(grid,i,j+1,dp);\\n     dp[i][j]=min(cnt1,min(cnt2,min(cnt3,cnt4)));\\n\\n}\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n   int n=grid[0].size();\\n        if(grid[0][0]!=0 || grid[m-1][n-1]!=0){\\n            return 0;\\n        }\\n   vector<vector<int>>dp(m,vector<int>(n,-1));\\n   int x=f(grid,m-1,n-1,dp);\\n return  x;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int mn=INT_MAX;\\nint f(vector<vector<int>>&grid,int i,int j,vector<vector<int>>&dp){\\n    if(i==0 && j==0){\\n        return grid[i][j];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2085872,
                "title": "java-dijkstra-priority-queue",
                "content": "```\\nclass pair{\\n    int ii;\\n    int jj;\\n    int val;\\n    pair(int ii,int jj,int val){\\n        this.ii=ii;\\n        this.jj=jj;\\n        this.val=val;\\n    }\\n}\\nclass Solution {\\n    public boolean valid(int i,int j,int m,int n,boolean[][] visited){\\n        return i>=0&&j>=0&&i<m&&j<n&&!visited[i][j];\\n    }\\n    public int minimumObstacles(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int[][] dp=new int[m][n];\\n        boolean[][] visited=new boolean[m][n];\\n        PriorityQueue<pair> q=new PriorityQueue<pair>((a,b)->(a.val-b.val));\\n        q.add(new pair(0,0,0));\\n        visited[0][0]=true;\\n        while(q.size()!=0){\\n            pair p=q.poll();\\n            if(valid(p.ii-1,p.jj,m,n,visited)){\\n                dp[p.ii-1][p.jj]=grid[p.ii-1][p.jj]+dp[p.ii][p.jj];\\n                q.add(new pair(p.ii-1,p.jj,dp[p.ii-1][p.jj]));\\n                visited[p.ii-1][p.jj]=true;\\n            }\\n            if(valid(p.ii+1,p.jj,m,n,visited)){\\n                dp[p.ii+1][p.jj]=grid[p.ii+1][p.jj]+dp[p.ii][p.jj];\\n                q.add(new pair(p.ii+1,p.jj,dp[p.ii+1][p.jj]));\\n                visited[p.ii+1][p.jj]=true;\\n            }\\n            if(valid(p.ii,p.jj-1,m,n,visited)){\\n                dp[p.ii][p.jj-1]=grid[p.ii][p.jj-1]+dp[p.ii][p.jj];\\n                q.add(new pair(p.ii,p.jj-1,dp[p.ii][p.jj-1]));\\n                visited[p.ii][p.jj-1]=true;\\n            }\\n            if(valid(p.ii,p.jj+1,m,n,visited)){\\n                dp[p.ii][p.jj+1]=grid[p.ii][p.jj+1]+dp[p.ii][p.jj];\\n                q.add(new pair(p.ii,p.jj+1,dp[p.ii][p.jj+1]));\\n                visited[p.ii][p.jj+1]=true;\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass pair{\\n    int ii;\\n    int jj;\\n    int val;\\n    pair(int ii,int jj,int val){\\n        this.ii=ii;\\n        this.jj=jj;\\n        this.val=val;\\n    }\\n}\\nclass Solution {\\n    public boolean valid(int i,int j,int m,int n,boolean[][] visited){\\n        return i>=0&&j>=0&&i<m&&j<n&&!visited[i][j];\\n    }\\n    public int minimumObstacles(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int[][] dp=new int[m][n];\\n        boolean[][] visited=new boolean[m][n];\\n        PriorityQueue<pair> q=new PriorityQueue<pair>((a,b)->(a.val-b.val));\\n        q.add(new pair(0,0,0));\\n        visited[0][0]=true;\\n        while(q.size()!=0){\\n            pair p=q.poll();\\n            if(valid(p.ii-1,p.jj,m,n,visited)){\\n                dp[p.ii-1][p.jj]=grid[p.ii-1][p.jj]+dp[p.ii][p.jj];\\n                q.add(new pair(p.ii-1,p.jj,dp[p.ii-1][p.jj]));\\n                visited[p.ii-1][p.jj]=true;\\n            }\\n            if(valid(p.ii+1,p.jj,m,n,visited)){\\n                dp[p.ii+1][p.jj]=grid[p.ii+1][p.jj]+dp[p.ii][p.jj];\\n                q.add(new pair(p.ii+1,p.jj,dp[p.ii+1][p.jj]));\\n                visited[p.ii+1][p.jj]=true;\\n            }\\n            if(valid(p.ii,p.jj-1,m,n,visited)){\\n                dp[p.ii][p.jj-1]=grid[p.ii][p.jj-1]+dp[p.ii][p.jj];\\n                q.add(new pair(p.ii,p.jj-1,dp[p.ii][p.jj-1]));\\n                visited[p.ii][p.jj-1]=true;\\n            }\\n            if(valid(p.ii,p.jj+1,m,n,visited)){\\n                dp[p.ii][p.jj+1]=grid[p.ii][p.jj+1]+dp[p.ii][p.jj];\\n                q.add(new pair(p.ii,p.jj+1,dp[p.ii][p.jj+1]));\\n                visited[p.ii][p.jj+1]=true;\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085829,
                "title": "python-clean-simple-heap-dp",
                "content": "- Use min-heap to always get the minimum obstacle removed step at front\\n- Use a 2D table to memorize what is the mininum removed count for a cell\\n\\n```python\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        # minimum removed obstacles table\\n        dp = [[inf for _ in range(n)] for _ in range(m)]\\n        dp[0][0] = grid[0][0]\\n        \\n        # removed obstacles count, i, j\\n        heap = [(0, 0, 0)]\\n\\t\\t\\n        while heap:\\n            removed, i, j = heappop(heap)\\n            if i == m-1 and j == n-1:\\n                return removed\\n            for ii, jj in [(i, j+1), (i+1, j), (i, j-1), (i-1, j)]:\\n                if (0 <= ii < m and 0 <= jj < n) and grid[ii][jj] + removed < dp[ii][jj]:\\n                    dp[ii][jj] = grid[ii][jj] + removed\\n                    heappush(heap, (dp[ii][jj], ii, jj))\\n        return dp[-1][-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        # minimum removed obstacles table\\n        dp = [[inf for _ in range(n)] for _ in range(m)]\\n        dp[0][0] = grid[0][0]\\n        \\n        # removed obstacles count, i, j\\n        heap = [(0, 0, 0)]\\n\\t\\t\\n        while heap:\\n            removed, i, j = heappop(heap)\\n            if i == m-1 and j == n-1:\\n                return removed\\n            for ii, jj in [(i, j+1), (i+1, j), (i, j-1), (i-1, j)]:\\n                if (0 <= ii < m and 0 <= jj < n) and grid[ii][jj] + removed < dp[ii][jj]:\\n                    dp[ii][jj] = grid[ii][jj] + removed\\n                    heappush(heap, (dp[ii][jj], ii, jj))\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944516,
                "title": "c-dijkstra-algorithm-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(n*m*log(n*m))\\n\\n- Space complexity:O(n*m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isvalid(int i, int j, int n, int m){\\n        return i>=0 && i<n && j>=0 && j<m;\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        vector<vector<int>>v(n, vector<int>(m, 1e9));\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>>q;\\n        v[0][0]=grid[0][0];\\n        q.push({v[0][0], {0, 0}});\\n        while(!q.empty()){\\n            int wt=q.top().first, x=q.top().second.first, y=q.top().second.second;\\n            q.pop();\\n            int r[4]={1, 0, -1, 0};\\n            int c[4]={0, 1, 0, -1};\\n            for(int i=0; i<4; i++){\\n                int row=r[i]+x, col=c[i]+y;\\n                if(isvalid(row, col, n, m)){\\n                    if(wt+grid[row][col]<v[row][col]){\\n                        v[row][col]=grid[row][col]+wt;\\n                        q.push({v[row][col], {row, col}});\\n                    }\\n                }\\n            }\\n        }\\n        return v[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int i, int j, int n, int m){\\n        return i>=0 && i<n && j>=0 && j<m;\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        vector<vector<int>>v(n, vector<int>(m, 1e9));\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>>q;\\n        v[0][0]=grid[0][0];\\n        q.push({v[0][0], {0, 0}});\\n        while(!q.empty()){\\n            int wt=q.top().first, x=q.top().second.first, y=q.top().second.second;\\n            q.pop();\\n            int r[4]={1, 0, -1, 0};\\n            int c[4]={0, 1, 0, -1};\\n            for(int i=0; i<4; i++){\\n                int row=r[i]+x, col=c[i]+y;\\n                if(isvalid(row, col, n, m)){\\n                    if(wt+grid[row][col]<v[row][col]){\\n                        v[row][col]=grid[row][col]+wt;\\n                        q.push({v[row][col], {row, col}});\\n                    }\\n                }\\n            }\\n        }\\n        return v[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919143,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    BFS 2D\\n\\n# Code\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n#define pii pair<int, int>\\n#define maxn 100005\\nint fx[] = {-1, 1, 0, 0};\\nint fy[] = {0, 0, -1, 1};\\n\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<int>> vis, dis;\\n\\n    bool valid(int x, int y)\\n    {\\n        if(x >= 0 and x < n and y >= 0 and y < m and !vis[x][y]) return true;\\n        else return false;\\n    }\\n\\n    void bfs(int sx, int sy, vector<vector<int>>& grid)\\n    {\\n        vis[sx][sy] = 1;\\n        dis[sx][sy] = 0;\\n        deque<pii> q;\\n        q.push_front({sx, sy});\\n        while(!q.empty()) {\\n            pii top = q.front();\\n            int x = top.first;\\n            int y = top.second;\\n            q.pop_front();\\n            for(int k=0; k<4; k++) {\\n                int tx = x + fx[k];\\n                int ty = y + fy[k];\\n                if(valid(tx, ty)) {\\n                    vis[tx][ty] = 1;\\n                    if(grid[tx][ty] == 1) {\\n                        dis[tx][ty] = dis[x][y] + 1;\\n                        q.push_back({tx, ty});\\n                    }\\n                    else {\\n                        dis[tx][ty] = dis[x][y];\\n                        q.push_front({tx, ty});\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        vector<int> v;\\n        for(int j=0; j<m; j++) v.push_back(0);\\n        for(int i=0; i<n; i++) {\\n            vis.push_back(v);\\n            dis.push_back(v);\\n        }\\n\\n        bfs(0, 0, grid);\\n\\n        int ans = dis[n-1][m-1];\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n#define pii pair<int, int>\\n#define maxn 100005\\nint fx[] = {-1, 1, 0, 0};\\nint fy[] = {0, 0, -1, 1};\\n\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<int>> vis, dis;\\n\\n    bool valid(int x, int y)\\n    {\\n        if(x >= 0 and x < n and y >= 0 and y < m and !vis[x][y]) return true;\\n        else return false;\\n    }\\n\\n    void bfs(int sx, int sy, vector<vector<int>>& grid)\\n    {\\n        vis[sx][sy] = 1;\\n        dis[sx][sy] = 0;\\n        deque<pii> q;\\n        q.push_front({sx, sy});\\n        while(!q.empty()) {\\n            pii top = q.front();\\n            int x = top.first;\\n            int y = top.second;\\n            q.pop_front();\\n            for(int k=0; k<4; k++) {\\n                int tx = x + fx[k];\\n                int ty = y + fy[k];\\n                if(valid(tx, ty)) {\\n                    vis[tx][ty] = 1;\\n                    if(grid[tx][ty] == 1) {\\n                        dis[tx][ty] = dis[x][y] + 1;\\n                        q.push_back({tx, ty});\\n                    }\\n                    else {\\n                        dis[tx][ty] = dis[x][y];\\n                        q.push_front({tx, ty});\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        vector<int> v;\\n        for(int j=0; j<m; j++) v.push_back(0);\\n        for(int i=0; i<n; i++) {\\n            vis.push_back(v);\\n            dis.push_back(v);\\n        }\\n\\n        bfs(0, 0, grid);\\n\\n        int ans = dis[n-1][m-1];\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2438923,
                "title": "bfs-cpp-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        \\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>q;\\n        \\n        q.push({0,{0,0}});\\n        \\n        dist[0][0]=0;       \\n        while(!q.empty()){\\n            auto a=q.top();\\n            q.pop();\\n            \\n            int dis=a.first;\\n            int i=a.second.first,j=a.second.second;\\n            \\n            if(i+1<m){\\n                int d=dis+grid[i+1][j];\\n                if(d<dist[i+1][j]){\\n                    \\n                    dist[i+1][j]=d;\\n                    q.push({d,{i+1,j}});\\n                }\\n            }\\n            \\n            if(i-1>=0){\\n                int d=dis+grid[i-1][j];\\n                if(d<dist[i-1][j]){\\n                    \\n                    dist[i-1][j]=d;\\n                    q.push({d,{i-1,j}});\\n                }\\n            }\\n            \\n            if(j+1<n){\\n                 int d=dis+grid[i][j+1];\\n                if(d<dist[i][j+1]){\\n                    \\n                    dist[i][j+1]=d;\\n                    q.push({d,{i,j+1}});\\n                }\\n            }\\n            \\n            if(j-1>=0){\\n                 int d=dis+grid[i][j-1];\\n                if(d<dist[i][j-1]){\\n                    \\n                    dist[i][j-1]=d;\\n                    q.push({d,{i,j-1}});\\n                }\\n            }\\n        }\\n        \\n        return dist[m-1][n-1];\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        \\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>q;\\n        \\n        q.push({0,{0,0}",
                "codeTag": "Java"
            },
            {
                "id": 2308469,
                "title": "c-bfs-dijkstra",
                "content": "```\\n#define pi pair<int,int>\\n\\nclass Solution {\\npublic:\\n    bool isvalid(int i, int j, vector<vector<int>> &grid, int m, int n) {\\n        return i >= 0 and i < m and j >= 0 and j < n and grid[i][j] != -1;\\n    }\\n    \\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        \\n        int m(size(grid)), n(size(grid[0]));\\n        \\n        int dir[] = {1,0,-1,0,1};\\n        \\n        priority_queue<pair<int,pi>, vector<pair<int,pi>>, greater<pair<int,pi>>> pq;\\n        vector<vector<int>> dist(m, vector<int>(n,INT_MAX));\\n        dist[0][0] = 0;\\n        pq.push({0,{0,0}});\\n        grid[0][0] = -1;\\n    \\n        while(!pq.empty()) {\\n            \\n            auto cell = pq.top();\\n            pq.pop();\\n            int prevdist = cell.first;\\n            int r = cell.second.first;\\n            int c = cell.second.second;\\n            \\n            if(r + c == m + n - 2) return prevdist;\\n            \\n            for(int i = 0; i < 4; i++) {\\n                int x = r + dir[i];\\n                int y = c + dir[i+1];\\n                \\n                if(isvalid(x,y,grid,m,n) and prevdist + grid[x][y] < dist[x][y]) {\\n                    \\n                    dist[x][y] = prevdist + grid[x][y];\\n                    pq.push({dist[x][y],{x,y}});\\n                    grid[x][y] = -1;\\n                }\\n            }\\n        }\\n        \\n        \\n        return 0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#define pi pair<int,int>\\n\\nclass Solution {\\npublic:\\n    bool isvalid(int i, int j, vector<vector<int>> &grid, int m, int n) {\\n        return i >= 0 and i < m and j >= 0 and j < n and grid[i][j] != -1;\\n    }\\n    \\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        \\n        int m(size(grid)), n(size(grid[0]));\\n        \\n        int dir[] = {1,0,-1,0,1};\\n        \\n        priority_queue<pair<int,pi>, vector<pair<int,pi>>, greater<pair<int,pi>>> pq;\\n        vector<vector<int>> dist(m, vector<int>(n,INT_MAX));\\n        dist[0][0] = 0;\\n        pq.push({0,{0,0}});\\n        grid[0][0] = -1;\\n    \\n        while(!pq.empty()) {\\n            \\n            auto cell = pq.top();\\n            pq.pop();\\n            int prevdist = cell.first;\\n            int r = cell.second.first;\\n            int c = cell.second.second;\\n            \\n            if(r + c == m + n - 2) return prevdist;\\n            \\n            for(int i = 0; i < 4; i++) {\\n                int x = r + dir[i];\\n                int y = c + dir[i+1];\\n                \\n                if(isvalid(x,y,grid,m,n) and prevdist + grid[x][y] < dist[x][y]) {\\n                    \\n                    dist[x][y] = prevdist + grid[x][y];\\n                    pq.push({dist[x][y],{x,y}});\\n                    grid[x][y] = -1;\\n                }\\n            }\\n        }\\n        \\n        \\n        return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2127967,
                "title": "c-solution-minesweeper-bfs-traversal",
                "content": "So, this is my first post around here. For this solution, I took inspiration from **\"votrubac\\'s\"** explanation. \\nThe code is as follows:\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isValid(int i,int j,int n,int m)\\n    {\\n        if(i<0||j<0) return false;\\n        if(i>=n||j>=m) return false;\\n        return true;\\n    }\\n    \\n    int dx[4]={0,1,0,-1};\\n    int dy[4]={-1,0,1,0};\\n    \\n    // function\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>> vis(n, vector<int> (m,-1));\\n        int wall=0;                         // minesweeper wall\\n        queue<pair<int,int>> obs,trs;       // obs == obstacle queue  &   trs == traversal queue\\n        \\n        \\n        // bfs starts\\n        \\n        vis[0][0]=wall;\\n        //q.push({0,0});\\n        trs.push({0,0});\\n        while(!trs.empty())\\n        {\\n            int a=trs.size();\\n            for(int i=0;i<a;i++)\\n            {\\n\\t\\t\\t\\t// visiting all the 4 adjacent cells\\n                for(int j=0;j<4;j++)\\n                {\\n                    if(isValid(trs.front().first+dy[j],trs.front().second+dx[j],n,m))\\n                    {\\n                        if(grid[trs.front().first+dy[j]][trs.front().second+dx[j]]==1&& vis[trs.front().first+dy[j]][trs.front().second+dx[j]]==-1)\\n                        {\\n                            vis[trs.front().first+dy[j]][trs.front().second+dx[j]]=wall+1;\\n                            obs.push({trs.front().first+dy[j],trs.front().second+dx[j]});\\n                        }\\n                        else if(grid[trs.front().first+dy[j]][trs.front().second+dx[j]]==0&& vis[trs.front().first+dy[j]][trs.front().second+dx[j]]==-1)\\n                        {\\n                            vis[trs.front().first+dy[j]][trs.front().second+dx[j]]=wall;\\n                            trs.push({trs.front().first+dy[j],trs.front().second+dx[j]});\\n                        }\\n                    }\\n                }\\n                trs.pop();\\n            }\\n            if(vis[n-1][m-1]!=-1)\\n            {\\n                return vis[n-1][m-1];\\n            }\\n            \\n            \\n            // swapping trs and obs when trs is empty but obs is not to simulate that a wall has been reached \\n            // ans we need to break it to get past\\n            \\n            if(trs.empty())\\n            {\\n                while(!obs.empty())\\n                {\\n                    trs.push(obs.front());\\n                    obs.pop();\\n                }\\n                wall++;\\n            }\\n        }\\n        \\n        // bfs ends here\\n        \\n        return vis[n-1][m-1];\\n    }\\n};\\n```\\n\\nSo, this was my code. Thank you.\\nAnd a special thanks to https://leetcode.com/votrubac/",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isValid(int i,int j,int n,int m)\\n    {\\n        if(i<0||j<0) return false;\\n        if(i>=n||j>=m) return false;\\n        return true;\\n    }\\n    \\n    int dx[4]={0,1,0,-1};\\n    int dy[4]={-1,0,1,0};\\n    \\n    // function\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>> vis(n, vector<int> (m,-1));\\n        int wall=0;                         // minesweeper wall\\n        queue<pair<int,int>> obs,trs;       // obs == obstacle queue  &   trs == traversal queue\\n        \\n        \\n        // bfs starts\\n        \\n        vis[0][0]=wall;\\n        //q.push({0,0});\\n        trs.push({0,0});\\n        while(!trs.empty())\\n        {\\n            int a=trs.size();\\n            for(int i=0;i<a;i++)\\n            {\\n\\t\\t\\t\\t// visiting all the 4 adjacent cells\\n                for(int j=0;j<4;j++)\\n                {\\n                    if(isValid(trs.front().first+dy[j],trs.front().second+dx[j],n,m))\\n                    {\\n                        if(grid[trs.front().first+dy[j]][trs.front().second+dx[j]]==1&& vis[trs.front().first+dy[j]][trs.front().second+dx[j]]==-1)\\n                        {\\n                            vis[trs.front().first+dy[j]][trs.front().second+dx[j]]=wall+1;\\n                            obs.push({trs.front().first+dy[j],trs.front().second+dx[j]});\\n                        }\\n                        else if(grid[trs.front().first+dy[j]][trs.front().second+dx[j]]==0&& vis[trs.front().first+dy[j]][trs.front().second+dx[j]]==-1)\\n                        {\\n                            vis[trs.front().first+dy[j]][trs.front().second+dx[j]]=wall;\\n                            trs.push({trs.front().first+dy[j],trs.front().second+dx[j]});\\n                        }\\n                    }\\n                }\\n                trs.pop();\\n            }\\n            if(vis[n-1][m-1]!=-1)\\n            {\\n                return vis[n-1][m-1];\\n            }\\n            \\n            \\n            // swapping trs and obs when trs is empty but obs is not to simulate that a wall has been reached \\n            // ans we need to break it to get past\\n            \\n            if(trs.empty())\\n            {\\n                while(!obs.empty())\\n                {\\n                    trs.push(obs.front());\\n                    obs.pop();\\n                }\\n                wall++;\\n            }\\n        }\\n        \\n        // bfs ends here\\n        \\n        return vis[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105588,
                "title": "c-classic-bfs-problem-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    const int dx[4] = {-1,0,1,0} ;\\n    const int dy[4] = {0,1,0,-1} ;\\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int r = grid.size() , c = grid[0].size() ;\\n        vector<vector<int>> dp(r,vector<int>(c,r*c)) ;\\n        \\n        queue<pair<int,int>>q ; q.push({0,0}) ; dp[0][0] = 0 ;\\n        while(q.size()){\\n            \\n            auto [i,j] = q.front() ; q.pop() ;\\n\\t\\t\\t//itr loop iterates for every direction up , right , down, left \\n            for(int itr = 0 ; itr < 4 ; ++itr ){\\n                int ii = i + dx[itr] , jj = j + dy[itr] ;\\n                if(ii >= 0 and jj >= 0 and ii < r and jj < c){\\n                    if(dp[ii][jj] > dp[i][j] + (grid[ii][jj] == 1)){\\n\\t\\t\\t\\t\\t//if a better path is available only then explore it !\\n                        dp[ii][jj] = dp[i][j] + (grid[ii][jj] == 1) ;\\n                        q.push({ii,jj}) ;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return dp[r - 1][c - 1] ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int dx[4] = {-1,0,1,0} ;\\n    const int dy[4] = {0,1,0,-1} ;\\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int r = grid.size() , c = grid[0].size() ;\\n        vector<vector<int>> dp(r,vector<int>(c,r*c)) ;\\n        \\n        queue<pair<int,int>>q ; q.push({0,0}) ; dp[0][0] = 0 ;\\n        while(q.size()){\\n            \\n            auto [i,j] = q.front() ; q.pop() ;\\n\\t\\t\\t//itr loop iterates for every direction up , right , down, left \\n            for(int itr = 0 ; itr < 4 ; ++itr ){\\n                int ii = i + dx[itr] , jj = j + dy[itr] ;\\n                if(ii >= 0 and jj >= 0 and ii < r and jj < c){\\n                    if(dp[ii][jj] > dp[i][j] + (grid[ii][jj] == 1)){\\n\\t\\t\\t\\t\\t//if a better path is available only then explore it !\\n                        dp[ii][jj] = dp[i][j] + (grid[ii][jj] == 1) ;\\n                        q.push({ii,jj}) ;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return dp[r - 1][c - 1] ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099932,
                "title": "python-bfs-o-m-n-very-interesting-approach-faster-than-95",
                "content": "Imagine this algorithm as water, it flows as much as it can.\\nIf it fills every reachable space, it\\'s pressure will increase and it will break every wall it currently touches.\\nAnd again, it flows as much as it can, if it doesn\\'t reach end, it breaks another layer of walls...\\n\\n```\\n#Already occupied space\\nused = set([(0,0)])\\n\\n#Unreached space\\nbfs = collections.deque([(0,0)])\\n#Current walls\\nwalls = collections.deque()\\n\\n#Directions\\ndirs = [(0,1),(1,0),(-1,0),(0,-1)]\\n#Size\\nm,n = len(grid), len(grid[0])\\n#Counter of broken walls\\nout = 0\\n\\n#Single iteration of outer while loop representes Water Expansion + Breaking 1 layer of wall\\nwhile True:\\n\\n\\t#Breadth first search all space and mark all walls to another queue\\n\\twhile bfs:\\n\\t\\tx,y = bfs.popleft()\\n\\t\\tif x == m-1 and y == n-1:\\n\\t\\t\\treturn out\\n\\t\\tfor d in dirs:\\n\\t\\t\\ta = (d[0]+x, d[1]+y)\\n\\t\\t\\t#Illegal, continue\\n\\t\\t\\tif a[0] < 0 or a[0] >= m or a[1] < 0 or a[1] >= n or a in used:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t#Wall, mark it in second queue\\n\\t\\t\\telif grid[a[0]][a[1]] == 1:\\n\\t\\t\\t\\twalls.append(a)\\n\\t\\t\\t#Space, expand\\n\\t\\t\\telse:\\n\\t\\t\\t\\tbfs.append(a)\\n\\t\\t\\tused.add(a)\\n\\t#It filled everything but it didn\\'t reach end, so we break 1 layer and repeat process\\n\\tout += 1\\n\\t#Now the walls are the space we expand to, and new walls become empty\\n\\tbfs = walls\\n\\twalls = collections.deque()\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\n#Already occupied space\\nused = set([(0,0)])\\n\\n#Unreached space\\nbfs = collections.deque([(0,0)])\\n#Current walls\\nwalls = collections.deque()\\n\\n#Directions\\ndirs = [(0,1),(1,0),(-1,0),(0,-1)]\\n#Size\\nm,n = len(grid), len(grid[0])\\n#Counter of broken walls\\nout = 0\\n\\n#Single iteration of outer while loop representes Water Expansion + Breaking 1 layer of wall\\nwhile True:\\n\\n\\t#Breadth first search all space and mark all walls to another queue\\n\\twhile bfs:\\n\\t\\tx,y = bfs.popleft()\\n\\t\\tif x == m-1 and y == n-1:\\n\\t\\t\\treturn out\\n\\t\\tfor d in dirs:\\n\\t\\t\\ta = (d[0]+x, d[1]+y)\\n\\t\\t\\t#Illegal, continue\\n\\t\\t\\tif a[0] < 0 or a[0] >= m or a[1] < 0 or a[1] >= n or a in used:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t#Wall, mark it in second queue\\n\\t\\t\\telif grid[a[0]][a[1]] == 1:\\n\\t\\t\\t\\twalls.append(a)\\n\\t\\t\\t#Space, expand\\n\\t\\t\\telse:\\n\\t\\t\\t\\tbfs.append(a)\\n\\t\\t\\tused.add(a)\\n\\t#It filled everything but it didn\\'t reach end, so we break 1 layer and repeat process\\n\\tout += 1\\n\\t#Now the walls are the space we expand to, and new walls become empty\\n\\tbfs = walls\\n\\twalls = collections.deque()\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2093145,
                "title": "java-javascript-c-solution",
                "content": "**Java**\\n```\\nimport java.util.Arrays;\\nimport java.util.LinkedList;\\n\\npublic class Solution {\\n\\n    private static final record Point(int row, int column, int removedObstacles){}\\n    int rows;\\n    int columns;\\n    private static final int[][] moves = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n\\n    public int minimumObstacles(int[][] matrix) {\\n        rows = matrix.length;\\n        columns = matrix[0].length;\\n        return findPathWithMinObstaclesBy01BreadthFirstSearch(matrix);\\n    }\\n\\n    private int findPathWithMinObstaclesBy01BreadthFirstSearch(int[][] matrix) {\\n        LinkedList<Point> queue = new LinkedList<>();\\n        queue.add(new Point(0, 0, matrix[0][0]));\\n\\n        int[][] minRemovedObstacles = new int[rows][columns];\\n        for (int r = 0; r < rows; ++r) {\\n            Arrays.fill(minRemovedObstacles[r], Integer.MAX_VALUE);\\n        }\\n        minRemovedObstacles[0][0] = 0;\\n\\n        while (!queue.isEmpty()) {\\n\\n            Point current = queue.poll();\\n            if (current.row == rows - 1 && current.column == columns - 1) {\\n                break;\\n            }\\n\\n            for (int[] move : moves) {\\n                int nextRow = current.row + move[0];\\n                int nextColumn = current.column + move[1];\\n\\n                if (isInMatrix(nextRow, nextColumn) && minRemovedObstacles[nextRow][nextColumn] > current.removedObstacles + matrix[nextRow][nextColumn]) {\\n                    Point next = new Point(nextRow, nextColumn, current.removedObstacles + matrix[nextRow][nextColumn]);\\n                    minRemovedObstacles[nextRow][nextColumn] = next.removedObstacles;\\n\\n                    if (matrix[nextRow][nextColumn] == 0) {\\n                        queue.addFirst(next);\\n                    } else {\\n                        queue.addLast(next);\\n                    }\\n                }\\n            }\\n        }\\n        return minRemovedObstacles[rows - 1][columns - 1];\\n    }\\n\\n    private boolean isInMatrix(int row, int column) {\\n        return row >= 0 && row < rows && column >= 0 && column < columns;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\n/**\\n * @param {number[][]} matrix\\n * @return {number}\\n */\\nvar minimumObstacles = function (matrix) {\\n    this.moves = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n    this.rows = matrix.length;\\n    this.columns = matrix[0].length;\\n    return findPathWithMinObstaclesBy01BreadthFirstSearch(matrix);\\n};\\n\\n/**\\n * @param {number[][]} matrix\\n * @return {number}\\n */\\nfunction findPathWithMinObstaclesBy01BreadthFirstSearch(matrix) {\\n    const queue = new DoubleEndedQueue();\\n    queue.addFront(new Point(0, 0, matrix[0][0]));\\n\\n    const minRemovedObstacles = Array.from(new Array(this.rows), () => new Array(this.columns).fill(Number.MAX_SAFE_INTEGER));\\n    minRemovedObstacles[0][0] = 0;\\n\\n    while (!queue.isEmpty()) {\\n\\n        const current = queue.removeFront();\\n        if (current.row === this.rows - 1 && current.column === this.columns - 1) {\\n            break;\\n        }\\n\\n        for (let move of this.moves) {\\n            let nextRow = current.row + move[0];\\n            let nextColumn = current.column + move[1];\\n\\n            if (isInMatrix(nextRow, nextColumn) && minRemovedObstacles[nextRow][nextColumn] > current.removedObstacles + matrix[nextRow][nextColumn]) {\\n                const next = new Point(nextRow, nextColumn, current.removedObstacles + matrix[nextRow][nextColumn]);\\n                minRemovedObstacles[nextRow][nextColumn] = next.removedObstacles;\\n\\n                if (matrix[nextRow][nextColumn] === 0) {\\n                    queue.addFront(next);\\n                } else {\\n                    queue.addBack(next);\\n                }\\n            }\\n        }\\n    }\\n    return minRemovedObstacles[rows - 1][columns - 1];\\n}\\n\\n/**\\n * @param {number} row\\n * @param {number} column \\n * @return {boolean}\\n */\\nfunction isInMatrix(row, column) {\\n    return row >= 0 && row < this.rows && column >= 0 && column < this.columns;\\n}\\n\\n/**\\n * @param {number} row\\n * @param {number} column \\n * @param {number} removedObstacles\\n */\\nfunction Point(row, column, removedObstacles) {\\n    this.row = row;\\n    this.column = column;\\n    this.removedObstacles = removedObstacles;\\n}\\n\\nfunction QueueNode(value) {\\n    this.value = value;\\n    this.next = null;\\n    this.previous = null;\\n}\\n\\nclass DoubleEndedQueue {\\n\\n    constructor() {\\n        this.size = 0;\\n        this.front = null;\\n        this.back = null;\\n    }\\n\\n    addFront(value) {\\n        let node = new QueueNode(value);\\n\\n        if (this.size === 0) {\\n            this.front = node;\\n            this.back = this.front;\\n        } else {\\n            this.front.previous = node;\\n            node.next = this.front;\\n            this.front = node;\\n        }\\n        ++this.size;\\n    }\\n\\n    addBack(value) {\\n        let node = new QueueNode(value);\\n\\n        if (this.size === 0) {\\n            this.back = node;\\n            this.front = this.back;\\n        } else {\\n            this.back.next = node;\\n            node.previous = this.back;\\n            this.back = node;\\n        }\\n        ++this.size;\\n    }\\n\\n    removeFront() {\\n        if (this.size === 0) {\\n            throw \"List is empty.\";\\n        }\\n\\n        let storeFront = this.front;\\n        if (--this.size > 0) {\\n            this.front = this.front.next;\\n            this.front.previous = null;\\n        } else {\\n            this.front = null;\\n            this.back = null;\\n        }\\n        return storeFront.value;\\n    }\\n\\n    removeBack() {\\n        if (this.size === 0) {\\n            throw \"List is empty.\";\\n        }\\n\\n        let storeBack = this.back;\\n        if (--this.size > 0) {\\n            this.back = this.back.previous;\\n            this.back.next = null;\\n        } else {\\n            this.front = null;\\n            this.back = null;\\n        }\\n        return storeBack.value;\\n    }\\n\\n    isEmpty() {\\n        return this.size === 0;\\n    }\\n}\\n```\\n**C++**\\n```\\n#include <array>\\n#include <queue>\\n#include <vector>\\nusing namespace std;\\n\\nstruct Point {\\n    \\n    int row{};\\n    int column{};\\n    int removedObstacles{};\\n    \\n    Point(int row, int column, int removedObstacles) : row {row}, column {column}, removedObstacles {removedObstacles}{}\\n\\n    Point() = default;\\n    virtual ~Point() = default; //virtual: no derived structs but for the sake of good practice.\\n\\n    Point(const Point& point) = default;\\n    Point& operator=(const Point& point) = default;\\n\\n    Point(Point&& point) noexcept = default;\\n    Point& operator=(Point&& point) noexcept = default;\\n};\\n\\nclass Solution {\\n    \\n    size_t rows;\\n    size_t columns;\\n    inline static const array<array<int, 2>, 4> moves{ {{-1, 0}, {1, 0}, {0, -1}, {0, 1}} };\\n\\npublic:\\n    int minimumObstacles(vector<vector<int>>& matrix) {\\n        rows = matrix.size();\\n        columns = matrix[0].size();\\n        return findPathWithMinObstaclesBy01BreadthFirstSearch(matrix);\\n    }\\n\\nprivate:\\n    int findPathWithMinObstaclesBy01BreadthFirstSearch(const vector<vector<int>>& matrix) {\\n        deque<Point> queue;\\n        queue.push_back(Point(0, 0, matrix[0][0]));\\n\\n        vector<vector<int>> minRemovedObstacles(rows, vector<int>(columns, INT_MAX));\\n        minRemovedObstacles[0][0] = 0;\\n\\n        while (!queue.empty()) {\\n\\n            Point current = queue.front();\\n            queue.pop_front();\\n\\n            if (current.row == rows - 1 && current.column == columns - 1) {\\n                break;\\n            }\\n\\n            for (const auto& move : moves) {\\n                int nextRow = current.row + move[0];\\n                int nextColumn = current.column + move[1];\\n\\n                if (isInMatrix(nextRow, nextColumn) && minRemovedObstacles[nextRow][nextColumn] > current.removedObstacles + matrix[nextRow][nextColumn]) {\\n                    Point next(nextRow, nextColumn, current.removedObstacles + matrix[nextRow][nextColumn]);\\n                    minRemovedObstacles[nextRow][nextColumn] = next.removedObstacles;\\n\\n                    if (matrix[nextRow][nextColumn] == 0) {\\n                        queue.push_front(next);\\n                    } else {\\n                        queue.push_back(next);\\n                    }\\n                }\\n            }\\n        }\\n        return minRemovedObstacles[rows - 1][columns - 1];\\n    }\\n\\n    bool isInMatrix(int row, int column) {\\n        return row >= 0 && row < rows && column >= 0 && column < columns;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nimport java.util.Arrays;\\nimport java.util.LinkedList;\\n\\npublic class Solution {\\n\\n    private static final record Point(int row, int column, int removedObstacles){}\\n    int rows;\\n    int columns;\\n    private static final int[][] moves = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n\\n    public int minimumObstacles(int[][] matrix) {\\n        rows = matrix.length;\\n        columns = matrix[0].length;\\n        return findPathWithMinObstaclesBy01BreadthFirstSearch(matrix);\\n    }\\n\\n    private int findPathWithMinObstaclesBy01BreadthFirstSearch(int[][] matrix) {\\n        LinkedList<Point> queue = new LinkedList<>();\\n        queue.add(new Point(0, 0, matrix[0][0]));\\n\\n        int[][] minRemovedObstacles = new int[rows][columns];\\n        for (int r = 0; r < rows; ++r) {\\n            Arrays.fill(minRemovedObstacles[r], Integer.MAX_VALUE);\\n        }\\n        minRemovedObstacles[0][0] = 0;\\n\\n        while (!queue.isEmpty()) {\\n\\n            Point current = queue.poll();\\n            if (current.row == rows - 1 && current.column == columns - 1) {\\n                break;\\n            }\\n\\n            for (int[] move : moves) {\\n                int nextRow = current.row + move[0];\\n                int nextColumn = current.column + move[1];\\n\\n                if (isInMatrix(nextRow, nextColumn) && minRemovedObstacles[nextRow][nextColumn] > current.removedObstacles + matrix[nextRow][nextColumn]) {\\n                    Point next = new Point(nextRow, nextColumn, current.removedObstacles + matrix[nextRow][nextColumn]);\\n                    minRemovedObstacles[nextRow][nextColumn] = next.removedObstacles;\\n\\n                    if (matrix[nextRow][nextColumn] == 0) {\\n                        queue.addFirst(next);\\n                    } else {\\n                        queue.addLast(next);\\n                    }\\n                }\\n            }\\n        }\\n        return minRemovedObstacles[rows - 1][columns - 1];\\n    }\\n\\n    private boolean isInMatrix(int row, int column) {\\n        return row >= 0 && row < rows && column >= 0 && column < columns;\\n    }\\n}\\n```\n```\\n/**\\n * @param {number[][]} matrix\\n * @return {number}\\n */\\nvar minimumObstacles = function (matrix) {\\n    this.moves = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n    this.rows = matrix.length;\\n    this.columns = matrix[0].length;\\n    return findPathWithMinObstaclesBy01BreadthFirstSearch(matrix);\\n};\\n\\n/**\\n * @param {number[][]} matrix\\n * @return {number}\\n */\\nfunction findPathWithMinObstaclesBy01BreadthFirstSearch(matrix) {\\n    const queue = new DoubleEndedQueue();\\n    queue.addFront(new Point(0, 0, matrix[0][0]));\\n\\n    const minRemovedObstacles = Array.from(new Array(this.rows), () => new Array(this.columns).fill(Number.MAX_SAFE_INTEGER));\\n    minRemovedObstacles[0][0] = 0;\\n\\n    while (!queue.isEmpty()) {\\n\\n        const current = queue.removeFront();\\n        if (current.row === this.rows - 1 && current.column === this.columns - 1) {\\n            break;\\n        }\\n\\n        for (let move of this.moves) {\\n            let nextRow = current.row + move[0];\\n            let nextColumn = current.column + move[1];\\n\\n            if (isInMatrix(nextRow, nextColumn) && minRemovedObstacles[nextRow][nextColumn] > current.removedObstacles + matrix[nextRow][nextColumn]) {\\n                const next = new Point(nextRow, nextColumn, current.removedObstacles + matrix[nextRow][nextColumn]);\\n                minRemovedObstacles[nextRow][nextColumn] = next.removedObstacles;\\n\\n                if (matrix[nextRow][nextColumn] === 0) {\\n                    queue.addFront(next);\\n                } else {\\n                    queue.addBack(next);\\n                }\\n            }\\n        }\\n    }\\n    return minRemovedObstacles[rows - 1][columns - 1];\\n}\\n\\n/**\\n * @param {number} row\\n * @param {number} column \\n * @return {boolean}\\n */\\nfunction isInMatrix(row, column) {\\n    return row >= 0 && row < this.rows && column >= 0 && column < this.columns;\\n}\\n\\n/**\\n * @param {number} row\\n * @param {number} column \\n * @param {number} removedObstacles\\n */\\nfunction Point(row, column, removedObstacles) {\\n    this.row = row;\\n    this.column = column;\\n    this.removedObstacles = removedObstacles;\\n}\\n\\nfunction QueueNode(value) {\\n    this.value = value;\\n    this.next = null;\\n    this.previous = null;\\n}\\n\\nclass DoubleEndedQueue {\\n\\n    constructor() {\\n        this.size = 0;\\n        this.front = null;\\n        this.back = null;\\n    }\\n\\n    addFront(value) {\\n        let node = new QueueNode(value);\\n\\n        if (this.size === 0) {\\n            this.front = node;\\n            this.back = this.front;\\n        } else {\\n            this.front.previous = node;\\n            node.next = this.front;\\n            this.front = node;\\n        }\\n        ++this.size;\\n    }\\n\\n    addBack(value) {\\n        let node = new QueueNode(value);\\n\\n        if (this.size === 0) {\\n            this.back = node;\\n            this.front = this.back;\\n        } else {\\n            this.back.next = node;\\n            node.previous = this.back;\\n            this.back = node;\\n        }\\n        ++this.size;\\n    }\\n\\n    removeFront() {\\n        if (this.size === 0) {\\n            throw \"List is empty.\";\\n        }\\n\\n        let storeFront = this.front;\\n        if (--this.size > 0) {\\n            this.front = this.front.next;\\n            this.front.previous = null;\\n        } else {\\n            this.front = null;\\n            this.back = null;\\n        }\\n        return storeFront.value;\\n    }\\n\\n    removeBack() {\\n        if (this.size === 0) {\\n            throw \"List is empty.\";\\n        }\\n\\n        let storeBack = this.back;\\n        if (--this.size > 0) {\\n            this.back = this.back.previous;\\n            this.back.next = null;\\n        } else {\\n            this.front = null;\\n            this.back = null;\\n        }\\n        return storeBack.value;\\n    }\\n\\n    isEmpty() {\\n        return this.size === 0;\\n    }\\n}\\n```\n```\\n#include <array>\\n#include <queue>\\n#include <vector>\\nusing namespace std;\\n\\nstruct Point {\\n    \\n    int row{};\\n    int column{};\\n    int removedObstacles{};\\n    \\n    Point(int row, int column, int removedObstacles) : row {row}, column {column}, removedObstacles {removedObstacles}{}\\n\\n    Point() = default;\\n    virtual ~Point() = default; //virtual: no derived structs but for the sake of good practice.\\n\\n    Point(const Point& point) = default;\\n    Point& operator=(const Point& point) = default;\\n\\n    Point(Point&& point) noexcept = default;\\n    Point& operator=(Point&& point) noexcept = default;\\n};\\n\\nclass Solution {\\n    \\n    size_t rows;\\n    size_t columns;\\n    inline static const array<array<int, 2>, 4> moves{ {{-1, 0}, {1, 0}, {0, -1}, {0, 1}} };\\n\\npublic:\\n    int minimumObstacles(vector<vector<int>>& matrix) {\\n        rows = matrix.size();\\n        columns = matrix[0].size();\\n        return findPathWithMinObstaclesBy01BreadthFirstSearch(matrix);\\n    }\\n\\nprivate:\\n    int findPathWithMinObstaclesBy01BreadthFirstSearch(const vector<vector<int>>& matrix) {\\n        deque<Point> queue;\\n        queue.push_back(Point(0, 0, matrix[0][0]));\\n\\n        vector<vector<int>> minRemovedObstacles(rows, vector<int>(columns, INT_MAX));\\n        minRemovedObstacles[0][0] = 0;\\n\\n        while (!queue.empty()) {\\n\\n            Point current = queue.front();\\n            queue.pop_front();\\n\\n            if (current.row == rows - 1 && current.column == columns - 1) {\\n                break;\\n            }\\n\\n            for (const auto& move : moves) {\\n                int nextRow = current.row + move[0];\\n                int nextColumn = current.column + move[1];\\n\\n                if (isInMatrix(nextRow, nextColumn) && minRemovedObstacles[nextRow][nextColumn] > current.removedObstacles + matrix[nextRow][nextColumn]) {\\n                    Point next(nextRow, nextColumn, current.removedObstacles + matrix[nextRow][nextColumn]);\\n                    minRemovedObstacles[nextRow][nextColumn] = next.removedObstacles;\\n\\n                    if (matrix[nextRow][nextColumn] == 0) {\\n                        queue.push_front(next);\\n                    } else {\\n                        queue.push_back(next);\\n                    }\\n                }\\n            }\\n        }\\n        return minRemovedObstacles[rows - 1][columns - 1];\\n    }\\n\\n    bool isInMatrix(int row, int column) {\\n        return row >= 0 && row < rows && column >= 0 && column < columns;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2089402,
                "title": "simple-dijkastras-algorithm-using-priority-queue-c",
                "content": "class Solution {\\n    \\n    bool isSafe(int x,int y,int n,int m){\\n        \\n        if(x<0 or y<0 or x>=n or y>=m) return false;\\n        return true;\\n    }\\n    \\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        \\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> dist(n,vector<int>(m,INT_MAX));\\n        dist[0][0]=0;\\n        priority_queue <tuple<int,int,int>, vector<tuple<int,int,int>>, greater<tuple<int,int,int>> > pq; \\n        pq.push({0,0,0}); // weight , x cor, y cor\\n        \\n        while(!pq.empty()){\\n            \\n            int wt,x,y;\\n            tie(wt,x,y) = pq.top();\\n            pq.pop();\\n            if(isSafe(x-1,y,n,m) and dist[x-1][y]>wt+grid[x][y]){\\n                \\n                dist[x-1][y]=wt+grid[x][y];\\n                pq.push(make_tuple(dist[x-1][y],x-1,y));\\n            }\\n            \\n            if(isSafe(x+1,y,n,m) and dist[x+1][y]>wt+grid[x][y]){\\n                \\n                dist[x+1][y]=wt+grid[x][y];\\n                pq.push(make_tuple(dist[x+1][y],x+1,y));\\n            }\\n            \\n            if(isSafe(x,y-1,n,m) and dist[x][y-1]>wt+grid[x][y]){\\n                \\n                dist[x][y-1]=wt+grid[x][y];\\n                pq.push(make_tuple(dist[x][y-1],x,y-1));\\n            }\\n            \\n            if(isSafe(x,y+1,n,m) and dist[x][y+1]>wt+grid[x][y]){\\n                \\n                dist[x][y+1]=wt+grid[x][y];\\n                pq.push(make_tuple(dist[x][y+1],x,y+1));\\n            }\\n            \\n        }\\n        return dist[n-1][m-1];\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    \\n    bool isSafe(int x,int y,int n,int m){\\n        \\n        if(x<0 or y<0 or x>=n or y>=m) return false;\\n        return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2087604,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Priority Queue***\\n\\n* ***Time Complexity : O(N * M)***\\n\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    struct node\\n    {\\n        int a;   // this will store minimum obstacle\\n        \\n        int b;   // this will store the x cordinate of cell\\n        \\n        int c;   // this will store the y cordinate of cell\\n        \\n        node(int x, int y, int z)\\n        {\\n            a = x;\\n            \\n            b = y;\\n            \\n            c = z;\\n        }\\n    };\\n    \\n    struct mycomp\\n    {\\n        bool operator() (node* &node1, node* &node2)\\n        {\\n            return node1 -> a > node2 -> a;\\n        }\\n    };\\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        \\n        int m = grid[0].size();\\n        \\n        vector<int> dx = {-1, 0, 1, 0};\\n    \\n        vector<int> dy = {0, 1, 0, -1};\\n\\t\\t\\n\\t\\t// declare a min. heap\\n        \\n        priority_queue<node*, vector<node*>, mycomp> pq;\\n        \\n        node* new_node = new node(0, 0, 0);\\n        \\n        pq.push(new_node);\\n        \\n        grid[0][0] = -1;\\n        \\n        while(!pq.empty())\\n        {\\n            node* curr_node = pq.top();\\n            \\n            int min_obstacle = curr_node -> a;\\n            \\n            int x = curr_node -> b;\\n            \\n            int y = curr_node -> c;\\n            \\n            pq.pop();\\n\\t\\t\\t\\n\\t\\t\\t// if last cell is reached\\n            \\n            if(x == n - 1 && y == m - 1)\\n            {\\n                return min_obstacle;\\n            }\\n            \\n            for(int k = 0; k < 4; k++)\\n            {\\n                int new_row = x + dx[k];\\n                \\n                int new_col = y + dy[k];\\n                \\n                if(new_row >= 0 && new_col >= 0 && new_row < n && new_col < m && grid[new_row][new_col] != -1)\\n                {\\n                    node* new_node = new node(min_obstacle + grid[new_row][new_col], new_row, new_col);\\n                    \\n                    pq.push(new_node);\\n                    \\n                    grid[new_row][new_col] = -1;\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    struct node\\n    {\\n        int a;   // this will store minimum obstacle\\n        \\n        int b;   // this will store the x cordinate of cell\\n        \\n        int c;   // this will store the y cordinate of cell\\n        \\n        node(int x, int y, int z)\\n        {\\n            a = x;\\n            \\n            b = y;\\n            \\n            c = z;\\n        }\\n    };\\n    \\n    struct mycomp\\n    {\\n        bool operator() (node* &node1, node* &node2)\\n        {\\n            return node1 -> a > node2 -> a;\\n        }\\n    };\\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        \\n        int m = grid[0].size();\\n        \\n        vector<int> dx = {-1, 0, 1, 0};\\n    \\n        vector<int> dy = {0, 1, 0, -1};\\n\\t\\t\\n\\t\\t// declare a min. heap\\n        \\n        priority_queue<node*, vector<node*>, mycomp> pq;\\n        \\n        node* new_node = new node(0, 0, 0);\\n        \\n        pq.push(new_node);\\n        \\n        grid[0][0] = -1;\\n        \\n        while(!pq.empty())\\n        {\\n            node* curr_node = pq.top();\\n            \\n            int min_obstacle = curr_node -> a;\\n            \\n            int x = curr_node -> b;\\n            \\n            int y = curr_node -> c;\\n            \\n            pq.pop();\\n\\t\\t\\t\\n\\t\\t\\t// if last cell is reached\\n            \\n            if(x == n - 1 && y == m - 1)\\n            {\\n                return min_obstacle;\\n            }\\n            \\n            for(int k = 0; k < 4; k++)\\n            {\\n                int new_row = x + dx[k];\\n                \\n                int new_col = y + dy[k];\\n                \\n                if(new_row >= 0 && new_col >= 0 && new_row < n && new_col < m && grid[new_row][new_col] != -1)\\n                {\\n                    node* new_node = new node(min_obstacle + grid[new_row][new_col], new_row, new_col);\\n                    \\n                    pq.push(new_node);\\n                    \\n                    grid[new_row][new_col] = -1;\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086041,
                "title": "dijkstra-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> dx = {0, 0, 1, -1};\\n    vector<int> dy = {1, -1, 0, 0};\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        vector<vector<int>> res(row, vector<int>(col, INT_MAX));\\n        res[0][0] = 0;\\n        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, std::greater<tuple<int, int, int>>> pq;\\n        pq.push({grid[0][0], 0, 0});\\n        \\n        while (!pq.empty()) {\\n            auto [current, x, y] = pq.top();\\n            pq.pop();\\n            \\n            if (x == row - 1 && y == col - 1) {\\n                return current + grid[x][y]; // reached destination\\n            }\\n            \\n            for (int i = 0; i < 4; i++) {\\n                auto xx = x + dx[i];\\n                auto yy = y + dy[i];\\n                \\n                if (xx < 0 || yy < 0 || xx >= row || yy >= col) continue;\\n                \\n                if (res[xx][yy] > current + grid[xx][yy]) {\\n                    res[xx][yy] = current+ grid[xx][yy]; // new path more optimal\\n                    pq.push({current + grid[xx][yy], xx, yy});\\n                }\\n            }\\n        }\\n        \\n        return res[row - 1][col - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dx = {0, 0, 1, -1};\\n    vector<int> dy = {1, -1, 0, 0};\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        vector<vector<int>> res(row, vector<int>(col, INT_MAX));\\n        res[0][0] = 0;\\n        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, std::greater<tuple<int, int, int>>> pq;\\n        pq.push({grid[0][0], 0, 0});\\n        \\n        while (!pq.empty()) {\\n            auto [current, x, y] = pq.top();\\n            pq.pop();\\n            \\n            if (x == row - 1 && y == col - 1) {\\n                return current + grid[x][y]; // reached destination\\n            }\\n            \\n            for (int i = 0; i < 4; i++) {\\n                auto xx = x + dx[i];\\n                auto yy = y + dy[i];\\n                \\n                if (xx < 0 || yy < 0 || xx >= row || yy >= col) continue;\\n                \\n                if (res[xx][yy] > current + grid[xx][yy]) {\\n                    res[xx][yy] = current+ grid[xx][yy]; // new path more optimal\\n                    pq.push({current + grid[xx][yy], xx, yy});\\n                }\\n            }\\n        }\\n        \\n        return res[row - 1][col - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086012,
                "title": "c-dijkstra-s-algorithm-easy-to-understand-clean-simple",
                "content": "In the given question, **Dijkstra Algo** can be used to solve it. \\n* Consider all the blockages as weights of value **1** and non blocked cells as weights of value **0**. \\n* Now consider the matrix as a graph with each node connected to up, down,left and right node.\\n* Now the question boils down to calculate the shortest sum of weight/dist from start node to end node.\\n\\n****\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int i,int j,int n,int m)\\n    {\\n        return i>=0 and j>=0 and i<n and j<m;\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) \\n    {\\n        vector<vector<int>> dir= {{1,0},{-1,0},{0,1},{0,-1}}; //this would be used to traverse a node\\'s up, down, left and right\\n\\t\\t\\n\\t\\t//taking row and column size\\n        int n = grid.size();  \\n        int m = grid[0].size();\\n        \\n        vector<vector<int>> dist(n,vector<int>(m,INT_MAX));  \\n        multiset< pair<int, pair<int,int>>> q; //{dist,{i,j}}\\n        //instead of multiset, priority queue can also be used\\n        \\n\\t\\t//Since source is (0,0) , the distance would be 0 for source \\n\\t\\tdist[0][0]=0;\\n        q.insert({0,{0,0}});\\n        \\n        while(!q.empty())\\n        {\\n            int nodeDist = (q.begin())->first;\\n            int nodex = (q.begin())->second.first;\\n            int nodey = (q.begin())->second.second;\\n            q.erase(q.begin());\\n            \\n            for(auto &it:dir)\\n            {\\n                int i = nodex + it[0];\\n                int j = nodey + it[1];\\n                if(isPossible(i,j,n,m))\\n                {\\n                    int childDist = grid[i][j];\\n                    if(nodeDist+childDist<dist[i][j])\\n                    {\\n                        dist[i][j]=nodeDist+childDist;\\n                        q.insert({dist[i][j],{i,j}});\\n                    }\\n                }\\n            }\\n        }\\n        return dist[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int i,int j,int n,int m)\\n    {\\n        return i>=0 and j>=0 and i<n and j<m;\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) \\n    {\\n        vector<vector<int>> dir= {{1,0},{-1,0},{0,1},{0,-1}}; //this would be used to traverse a node\\'s up, down, left and right\\n\\t\\t\\n\\t\\t//taking row and column size\\n        int n = grid.size();  \\n        int m = grid[0].size();\\n        \\n        vector<vector<int>> dist(n,vector<int>(m,INT_MAX));  \\n        multiset< pair<int, pair<int,int>>> q; //{dist,{i,j}}\\n        //instead of multiset, priority queue can also be used\\n        \\n\\t\\t//Since source is (0,0) , the distance would be 0 for source \\n\\t\\tdist[0][0]=0;\\n        q.insert({0,{0,0}});\\n        \\n        while(!q.empty())\\n        {\\n            int nodeDist = (q.begin())->first;\\n            int nodex = (q.begin())->second.first;\\n            int nodey = (q.begin())->second.second;\\n            q.erase(q.begin());\\n            \\n            for(auto &it:dir)\\n            {\\n                int i = nodex + it[0];\\n                int j = nodey + it[1];\\n                if(isPossible(i,j,n,m))\\n                {\\n                    int childDist = grid[i][j];\\n                    if(nodeDist+childDist<dist[i][j])\\n                    {\\n                        dist[i][j]=nodeDist+childDist;\\n                        q.insert({dist[i][j],{i,j}});\\n                    }\\n                }\\n            }\\n        }\\n        return dist[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085884,
                "title": "using-0-1-bfs-and-obstacle-removal-simple-c-solution-with-comments",
                "content": "The idea is very similar to what we do in 0-1 BFS and Obstacle Elimination Questions.\\n\\nFor each cell we will mark the minimum no of obstacles broken by a path which passes through it. And if any other path visits which has broken lesser obstacles we allow it to visit the cell again else don\\'t.\\n\\nIn terms of adding cells to Queue we will give prefarance to cells which are already 0 and add them to front since they would not add anything to our answer similar to what we do in 0-1 bfs.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        \\n       int  m = grid.size();\\n       int n = grid[0].size();\\n       \\n        int vis[m][n];\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++) vis[i][j] =-1;\\n        }\\n        // Creating a Deque since we need double sided insertion\\n        deque<pair<int,pair<int,int>>> q;\\n        q.push_front({0,{0,0}});\\n        int dx[]={1,0,-1,0};\\n        int dy[]={0,1,0,-1};\\n        while(!q.empty())\\n        {\\n            pair<int,pair<int,int>> p =q.front(); q.pop_front();\\n            \\n            if(p.second.first == m-1 && p.second.second == n-1)\\n            {\\n               return p.first; \\n              \\n            }\\n            \\n            int x=p.second.first; int y=p.second.second;\\n            for(int i=0;i<4;i++)\\n            {\\n                int nx=x+dx[i];\\n                int ny=y+dy[i];\\n                \\n                if(nx>=0 && nx<m && ny>=0 && ny< n)\\n                {\\n\\t\\t\\t\\t// if the cell is empty\\n                    if(grid[nx][ny] == 0  && (vis[nx][ny]==-1 || vis[nx][ny] > p.first))\\n                    {\\n                        q.push_front({p.first,{nx,ny}});\\n                        vis[nx][ny]=p.first;\\n                    }\\n\\t\\t\\t\\t\\t// if cell has obstacle we will need to add 1 to answer.\\n                    else if(grid[nx][ny] ==1 && ((vis[nx][ny]==-1 || vis[nx][ny] > p.first+1)))\\n                    {\\n                        q.push_back({p.first+1,{nx,ny}});\\n                        vis[nx][ny]=p.first+1;\\n                    }\\n                }\\n            }\\n             \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        \\n       int  m = grid.size();\\n       int n = grid[0].size();\\n       \\n        int vis[m][n];\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++) vis[i][j] =-1;\\n        }\\n        // Creating a Deque since we need double sided insertion\\n        deque<pair<int,pair<int,int>>> q;\\n        q.push_front({0,{0,0}});\\n        int dx[]={1,0,-1,0};\\n        int dy[]={0,1,0,-1};\\n        while(!q.empty())\\n        {\\n            pair<int,pair<int,int>> p =q.front(); q.pop_front();\\n            \\n            if(p.second.first == m-1 && p.second.second == n-1)\\n            {\\n               return p.first; \\n              \\n            }\\n            \\n            int x=p.second.first; int y=p.second.second;\\n            for(int i=0;i<4;i++)\\n            {\\n                int nx=x+dx[i];\\n                int ny=y+dy[i];\\n                \\n                if(nx>=0 && nx<m && ny>=0 && ny< n)\\n                {\\n\\t\\t\\t\\t// if the cell is empty\\n                    if(grid[nx][ny] == 0  && (vis[nx][ny]==-1 || vis[nx][ny] > p.first))\\n                    {\\n                        q.push_front({p.first,{nx,ny}});\\n                        vis[nx][ny]=p.first;\\n                    }\\n\\t\\t\\t\\t\\t// if cell has obstacle we will need to add 1 to answer.\\n                    else if(grid[nx][ny] ==1 && ((vis[nx][ny]==-1 || vis[nx][ny] > p.first+1)))\\n                    {\\n                        q.push_back({p.first+1,{nx,ny}});\\n                        vis[nx][ny]=p.first+1;\\n                    }\\n                }\\n            }\\n             \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085875,
                "title": "c-priority-queue-bfs-easy-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) \\n    {\\n        int arr[4]  = {1,-1,0,0};\\n        int brr[4] = {0,0,-1,1};\\n        int r = grid.size();\\n        int c = grid[0].size();\\n      priority_queue< pair<int,pair<int,int>>, vector<  pair<int,pair<int,int>>>, greater<>>pq;\\n       \\n        pq.push({0,{0,0}});\\n        grid[0][0]= -1;\\n        while(pq.size()>0)\\n        {\\n            auto it = pq.top();\\n            pq.pop();\\n            int an = it.first;\\n            int x  =it.second.first;\\n            int y  = it.second.second;\\n             if(x==r-1 && y==c-1)\\n                        return an;\\n                \\n            for(int  i = 0;i<4;i++)\\n            {\\n                int xx = x + arr[i];\\n                int yy = y  + brr[i];\\n                if(xx>=0 && xx<r && yy>=0 && yy<c && grid[xx][yy]!=-1)\\n                {\\n                    if(xx==r-1 && yy==c-1)\\n                        return an;\\n                    \\n                    if(grid[xx][yy]==0)\\n                    {\\n                        pq.push({an,{xx,yy}});\\n                    }\\n                    else if(grid[xx][yy]==1)\\n                    {\\n                        pq.push({an+1, {xx,yy}});\\n                    }\\n                    grid[xx][yy] = -1;\\n                    \\n                }\\n            }\\n           \\n        }\\n        return -1;\\n       \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) \\n    {\\n        int arr[4]  = {1,-1,0,0};\\n        int brr[4] = {0,0,-1,1};\\n        int r = grid.size();\\n        int c = grid[0].size();\\n      priority_queue< pair<int,pair<int,int>>, vector<  pair<int,pair<int,int>>>, greater<>>pq;\\n       \\n        pq.push({0,{0,0}});\\n        grid[0][0]= -1;\\n        while(pq.size()>0)\\n        {\\n            auto it = pq.top();\\n            pq.pop();\\n            int an = it.first;\\n            int x  =it.second.first;\\n            int y  = it.second.second;\\n             if(x==r-1 && y==c-1)\\n                        return an;\\n                \\n            for(int  i = 0;i<4;i++)\\n            {\\n                int xx = x + arr[i];\\n                int yy = y  + brr[i];\\n                if(xx>=0 && xx<r && yy>=0 && yy<c && grid[xx][yy]!=-1)\\n                {\\n                    if(xx==r-1 && yy==c-1)\\n                        return an;\\n                    \\n                    if(grid[xx][yy]==0)\\n                    {\\n                        pq.push({an,{xx,yy}});\\n                    }\\n                    else if(grid[xx][yy]==1)\\n                    {\\n                        pq.push({an+1, {xx,yy}});\\n                    }\\n                    grid[xx][yy] = -1;\\n                    \\n                }\\n            }\\n           \\n        }\\n        return -1;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085797,
                "title": "dijkstra-s-algo-c",
                "content": "# **Only use Dijkstra\\'S with optimize ways:**\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& v) {\\n        int n=v.size();\\n        int m=v[0].size();\\n        set<pair<int,pair<int,int>> >st;\\n        st.insert({v[0][0],{0,0}});\\n        \\n        int dx[]={-1,1,0,0};\\n        int dy[]={0,0,-1,1};\\n        \\n        int dis[n][m];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                dis[i][j]=1e9;\\n            }\\n        }\\n        \\n        \\n        bool vis[n][m];\\n        memset(vis,false,sizeof(vis));\\n        while(!st.empty()){\\n            int x,y,w;\\n            auto it=st.begin();\\n            x=it->second.first;\\n            y=it->second.second;\\n            w=it->first;\\n            st.erase(st.begin());\\n            if(dis[x][y]<w) continue;\\n            if(vis[x][y]) continue;\\n            dis[x][y]=min(dis[x][y],w);\\n            if(x==n-1 and y==m-1) return w; \\n            vis[x][y]=true;\\n            for(int i=0;i<4;i++){\\n                int nx,ny;\\n                nx=x+dx[i];\\n                ny=y+dy[i];\\n                if(nx>=0 and ny>=0 and nx<n and ny<m){\\n                    if(dis[nx][ny]>w+v[nx][ny])\\n                    {st.insert({w+v[nx][ny],{nx,ny}}); dis[nx][ny]=w+v[nx][ny]; }\\n                }\\n            }\\n            \\n        }\\n        \\n        return dis[n-1][m-1];\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "Graph"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& v) {\\n        int n=v.size();\\n        int m=v[0].size();\\n        set<pair<int,pair<int,int>> >st;\\n        st.insert({v[0][0],{0,0}",
                "codeTag": "Java"
            },
            {
                "id": 3913393,
                "title": "easy-to-understand-approach-using-simple-bfs-and-priority-queue",
                "content": "# Complexity\\n- Time complexity:\\n O(n * m)\\nn->Number of rows of the grid\\nm->Number of columns of the grid\\n\\n- Space complexity:\\nO(n * m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0)); //declare a visited array\\n        priority_queue<pair<int,pair<int,int>>,\\n        vector<pair<int,pair<int,int>>>,\\n        greater<pair<int,pair<int,int>>>> q;\\n        q.push({0,{0,0}});\\n        vis[0][0]=1;\\n        while(!q.empty()){\\n            int wt=q.top().first;\\n            int r=q.top().second.first;\\n            int c=q.top().second.second;\\n            q.pop();\\n            if(r==n-1 && c== m-1) return wt; //return weight if the final cell is found\\n            int dir[]={-1,1,0,0};//direction array for row\\n            int dic[]={0,0,1,-1};//direction array for column\\n            for(int i=0;i<4;i++){\\n                int row=dir[i]+r;\\n                int col=dic[i]+c;\\n                if(row>=0 && row<n && col>=0 && col<m && \\n                !vis[row][col]){\\n    //(wt+grid[row][col]) denotes the weight of the next cell \\n                q.push({wt+grid[row][col],{row,col}});\\n                vis[row][col]=1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0)); //declare a visited array\\n        priority_queue<pair<int,pair<int,int>>,\\n        vector<pair<int,pair<int,int>>>,\\n        greater<pair<int,pair<int,int>>>> q;\\n        q.push({0,{0,0}});\\n        vis[0][0]=1;\\n        while(!q.empty()){\\n            int wt=q.top().first;\\n            int r=q.top().second.first;\\n            int c=q.top().second.second;\\n            q.pop();\\n            if(r==n-1 && c== m-1) return wt; //return weight if the final cell is found\\n            int dir[]={-1,1,0,0};//direction array for row\\n            int dic[]={0,0,1,-1};//direction array for column\\n            for(int i=0;i<4;i++){\\n                int row=dir[i]+r;\\n                int col=dic[i]+c;\\n                if(row>=0 && row<n && col>=0 && col<m && \\n                !vis[row][col]){\\n    //(wt+grid[row][col]) denotes the weight of the next cell \\n                q.push({wt+grid[row][col],{row,col}});\\n                vis[row][col]=1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841206,
                "title": "hhm-simple-dijkstra-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDijkstra according to no of obstacles\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmake dist[] array which contains no of obstacles till each coordinate in the path and apply dijkstra accordingly.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//dijkstra according to no of obstacles\\n//make dist[] array which contains no of obstacles till each coordinate in the path\\n\\nclass Solution {\\n    class tuple{\\n        int a,b,c;\\n        tuple(int a,int b,int c){\\n            this.a=a;\\n            this.b=b;\\n            this.c=c;\\n        }\\n    }\\n    public int minimumObstacles(int[][] grid) {\\n        int m=grid.length,n=grid[0].length;\\n        int dist[][]=new int[m][n];\\n        for(int i[]:dist){\\n            Arrays.fill(i,1000000);\\n        }\\n        dist[0][0]=0;\\n        //(number of Obstacles removed till then,x,y)\\n        PriorityQueue<tuple>q=new PriorityQueue<>((z,v)->z.a-v.a);\\n        q.offer(new tuple(0,0,0));\\n        int rx[]={-1,1,0,0};\\n        int ry[]={0,0,-1,1};\\n        while(!q.isEmpty()){\\n            tuple t=q.poll();\\n            for(int i=0;i<4;i++)\\n            {\\n                int x=rx[i]+t.b;\\n                int y=ry[i]+t.c;\\n                if(x>=0&&y>=0&&x<m&&y<n){\\n                    if(grid[x][y]==0){\\n                        if(dist[x][y]>t.a){\\n                        dist[x][y]=t.a;\\n                        q.offer(new tuple(dist[x][y],x,y));\\n                        }\\n                    }\\n                    else{\\n                        if(dist[x][y]>t.a+1){\\n                            dist[x][y]=t.a+1;\\n                            q.offer(new tuple(dist[x][y],x,y));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dist[m-1][n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//dijkstra according to no of obstacles\\n//make dist[] array which contains no of obstacles till each coordinate in the path\\n\\nclass Solution {\\n    class tuple{\\n        int a,b,c;\\n        tuple(int a,int b,int c){\\n            this.a=a;\\n            this.b=b;\\n            this.c=c;\\n        }\\n    }\\n    public int minimumObstacles(int[][] grid) {\\n        int m=grid.length,n=grid[0].length;\\n        int dist[][]=new int[m][n];\\n        for(int i[]:dist){\\n            Arrays.fill(i,1000000);\\n        }\\n        dist[0][0]=0;\\n        //(number of Obstacles removed till then,x,y)\\n        PriorityQueue<tuple>q=new PriorityQueue<>((z,v)->z.a-v.a);\\n        q.offer(new tuple(0,0,0));\\n        int rx[]={-1,1,0,0};\\n        int ry[]={0,0,-1,1};\\n        while(!q.isEmpty()){\\n            tuple t=q.poll();\\n            for(int i=0;i<4;i++)\\n            {\\n                int x=rx[i]+t.b;\\n                int y=ry[i]+t.c;\\n                if(x>=0&&y>=0&&x<m&&y<n){\\n                    if(grid[x][y]==0){\\n                        if(dist[x][y]>t.a){\\n                        dist[x][y]=t.a;\\n                        q.offer(new tuple(dist[x][y],x,y));\\n                        }\\n                    }\\n                    else{\\n                        if(dist[x][y]>t.a+1){\\n                            dist[x][y]=t.a+1;\\n                            q.offer(new tuple(dist[x][y],x,y));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dist[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834388,
                "title": "java-easy-just-like-shortest-path",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n\\n\\n\\n\\n\\n\\n```\\n//<---------DFS  ---- TLE ----approach>\\n\\nclass Solution {\\n    int min_removal= Integer.MAX_VALUE;\\n    public int minimumObstacles(int[][] grid) {\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        dfs(0,0,grid,0,visited);\\n        return min_removal;\\n    }\\n    public void  dfs(int i,int j, int[][] grid,int count,boolean[][] visited)\\n \\n        // if we are on the last index then we will return min removal\\n        \\n        if(i<0 ||  j<0 || i>=grid.length || j>=grid[0].length || visited[i][j]==true){\\n            return;\\n        }\\n        if(i==grid.length-1 && j==grid[0].length-1){\\n            min_removal = Math.min(min_removal,count);\\n            return;\\n        }\\n        visited[i][j]= true;\\n        //we can remove as much obstcale we can but we need to return minimum;\\n        if(grid[i][j]==1){\\n            count++;\\n        }\\n        //dfs\\n        dfs(i+1,j,grid,count,visited);\\n        dfs(i-1,j,grid,count,visited);\\n        dfs(i,j+1,grid,count,visited);\\n        dfs(i,j-1,grid,count,visited);\\n        visited[i][j] = false;\\n\\n    }\\n}\\n\\n\\n\\n\\n//<-----------------------Bfs approach --------------------->\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public class pair{\\n        int r;\\n        int c;\\n        int val;\\n        pair(int r,int c,int val){\\n            this.r = r;\\n            this.c = c;\\n            this.val = val;\\n        }\\n    }\\n    int min = Integer.MAX_VALUE;\\n    public int minimumObstacles(int[][] grid) {\\n        //The shortest number of removal we can go for it\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        PriorityQueue<pair> pq = new PriorityQueue<>((a,b)->a.val-b.val);\\n    \\n        pq.add(new pair(0,0,0));\\n        while(!pq.isEmpty()){\\n            pair rs =pq.poll();\\n            int i = rs.r;\\n            int j  = rs.c;\\n            int step =rs.val;\\n            if(i==grid.length-1 && j==grid[0].length-1){\\n                min = Math.min(min,step);\\n            }\\n            if(isValid(i+1,j,grid,visited)){\\n                visited[i+1][j]=true;\\n                if(grid[i+1][j]==1){\\n                    pq.add(new pair(i+1,j,step+1));\\n                }\\n                else{\\n                    pq.add(new pair(i+1,j,step));\\n                }\\n            }\\n            if(isValid(i-1,j,grid,visited)){\\n                visited[i-1][j]=true;\\n                if(grid[i-1][j]==1){\\n                    pq.add(new pair(i-1,j,step+1));\\n                }\\n                else{\\n                    pq.add(new pair(i-1,j,step));\\n                }\\n            }\\n            if(isValid(i,j+1,grid,visited)){\\n                visited[i][j+1]=true;\\n                if(grid[i][j+1]==1){\\n                    pq.add(new pair(i,j+1,step+1));\\n                }\\n                else{\\n                    pq.add(new pair(i,j+1,step));\\n                }\\n            }\\n            if(isValid(i,j-1,grid,visited)){\\n                visited[i][j-1]=true;\\n                if(grid[i][j-1]==1){\\n                    pq.add(new pair(i,j-1,step+1));\\n                }\\n                else{\\n                    pq.add(new pair(i,j-1,step));\\n                }\\n            }\\n        }\\n        return min;\\n\\n        \\n    }\\n    public boolean isValid(int i,int j, int[][] grid,boolean[][] visited){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || visited[i][j]==true){\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n//<---------DFS  ---- TLE ----approach>\\n\\nclass Solution {\\n    int min_removal= Integer.MAX_VALUE;\\n    public int minimumObstacles(int[][] grid) {\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        dfs(0,0,grid,0,visited);\\n        return min_removal;\\n    }\\n    public void  dfs(int i,int j, int[][] grid,int count,boolean[][] visited)\\n \\n        // if we are on the last index then we will return min removal\\n        \\n        if(i<0 ||  j<0 || i>=grid.length || j>=grid[0].length || visited[i][j]==true){\\n            return;\\n        }\\n        if(i==grid.length-1 && j==grid[0].length-1){\\n            min_removal = Math.min(min_removal,count);\\n            return;\\n        }\\n        visited[i][j]= true;\\n        //we can remove as much obstcale we can but we need to return minimum;\\n        if(grid[i][j]==1){\\n            count++;\\n        }\\n        //dfs\\n        dfs(i+1,j,grid,count,visited);\\n        dfs(i-1,j,grid,count,visited);\\n        dfs(i,j+1,grid,count,visited);\\n        dfs(i,j-1,grid,count,visited);\\n        visited[i][j] = false;\\n\\n    }\\n}\\n\\n\\n\\n\\n//<-----------------------Bfs approach --------------------->\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public class pair{\\n        int r;\\n        int c;\\n        int val;\\n        pair(int r,int c,int val){\\n            this.r = r;\\n            this.c = c;\\n            this.val = val;\\n        }\\n    }\\n    int min = Integer.MAX_VALUE;\\n    public int minimumObstacles(int[][] grid) {\\n        //The shortest number of removal we can go for it\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        PriorityQueue<pair> pq = new PriorityQueue<>((a,b)->a.val-b.val);\\n    \\n        pq.add(new pair(0,0,0));\\n        while(!pq.isEmpty()){\\n            pair rs =pq.poll();\\n            int i = rs.r;\\n            int j  = rs.c;\\n            int step =rs.val;\\n            if(i==grid.length-1 && j==grid[0].length-1){\\n                min = Math.min(min,step);\\n            }\\n            if(isValid(i+1,j,grid,visited)){\\n                visited[i+1][j]=true;\\n                if(grid[i+1][j]==1){\\n                    pq.add(new pair(i+1,j,step+1));\\n                }\\n                else{\\n                    pq.add(new pair(i+1,j,step));\\n                }\\n            }\\n            if(isValid(i-1,j,grid,visited)){\\n                visited[i-1][j]=true;\\n                if(grid[i-1][j]==1){\\n                    pq.add(new pair(i-1,j,step+1));\\n                }\\n                else{\\n                    pq.add(new pair(i-1,j,step));\\n                }\\n            }\\n            if(isValid(i,j+1,grid,visited)){\\n                visited[i][j+1]=true;\\n                if(grid[i][j+1]==1){\\n                    pq.add(new pair(i,j+1,step+1));\\n                }\\n                else{\\n                    pq.add(new pair(i,j+1,step));\\n                }\\n            }\\n            if(isValid(i,j-1,grid,visited)){\\n                visited[i][j-1]=true;\\n                if(grid[i][j-1]==1){\\n                    pq.add(new pair(i,j-1,step+1));\\n                }\\n                else{\\n                    pq.add(new pair(i,j-1,step));\\n                }\\n            }\\n        }\\n        return min;\\n\\n        \\n    }\\n    public boolean isValid(int i,int j, int[][] grid,boolean[][] visited){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || visited[i][j]==true){\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738536,
                "title": "fast-compact-elegant-and-clean-dijkstra-solution",
                "content": "The idea is to consider obstacles as cells having weights of 1 and others as 0.\\nThen simply find the shortest path to the bottom-right corner using the weight as priority(essence of dijkstra)\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        const int row = grid.size(), col = grid[0].size(), oo = INT_MAX;\\n        using T = tuple<int, int, int>;\\n        \\n        vector<pair<int, int> > directions = { {0,1}, {0,-1}, {1,0}, {-1,0} };\\n        vector<vector<int>>distance(row, vector<int>(col, oo));\\n        priority_queue<T, vector<T>, greater<T>> pq;\\n        \\n        pq.push({0,0,0});\\n        distance[0][0] = 0;\\n        \\n        while(!pq.empty()){\\n             \\n            auto [dist, r, c] = pq.top();  pq.pop();\\n            \\n            if(row-1 ==r and col-1 == c)return dist;\\n            \\n            if(distance[r][c] != dist) continue;\\n            \\n            for(auto& dir : directions){\\n                  int x = dir.first + r, y = dir.second + c;\\n                  if(min(x,y) < 0 or x >=row or y>= col) continue;\\n                  \\n                  if(dist + grid[x][y] < distance[x][y]){\\n                       pq.push({distance[x][y] = dist + grid[x][y], x, y});\\n                  }\\n            }\\n        }\\n        \\n        return distance[row-1][col-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        const int row = grid.size(), col = grid[0].size(), oo = INT_MAX;\\n        using T = tuple<int, int, int>;\\n        \\n        vector<pair<int, int> > directions = { {0,1}, {0,-1}, {1,0}, {-1,0} };\\n        vector<vector<int>>distance(row, vector<int>(col, oo));\\n        priority_queue<T, vector<T>, greater<T>> pq;\\n        \\n        pq.push({0,0,0});\\n        distance[0][0] = 0;\\n        \\n        while(!pq.empty()){\\n             \\n            auto [dist, r, c] = pq.top();  pq.pop();\\n            \\n            if(row-1 ==r and col-1 == c)return dist;\\n            \\n            if(distance[r][c] != dist) continue;\\n            \\n            for(auto& dir : directions){\\n                  int x = dir.first + r, y = dir.second + c;\\n                  if(min(x,y) < 0 or x >=row or y>= col) continue;\\n                  \\n                  if(dist + grid[x][y] < distance[x][y]){\\n                       pq.push({distance[x][y] = dist + grid[x][y], x, y});\\n                  }\\n            }\\n        }\\n        \\n        return distance[row-1][col-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730827,
                "title": "shortest-paths-problem-0-1-bfs-easy-to-understand",
                "content": "**Intuition and Approach :** \\nImagine the problem as the obstacles in the path are the weights and we have to find the path with lowest weight aka the shortest path . Then it reduces down to shortest path problem in a weighted graph where you can apply dijsktra or further optimize it by 0-1 BFS because we just have 0 and 1 weighted paths .\\nSo we can get our answer in TC of O(n*m) and also space complexity is O(n*m) for storing the levels and for our deque .\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int i , int j , vector<vector<int>>&grid){\\n         return (i >= 0 && j >= 0 && i < grid.size() && j < grid[0].size());\\n    }\\n    \\n    int X[4] = {0,0,1,-1};\\n    int Y[4] = {1,-1,0,0};\\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size() , m = grid[0].size() ;\\n        \\n        deque<pair<int,int>> dq ;\\n        \\n        vector<int>level(m*n,1e6);\\n        \\n        vector<vector<int>> mp(n , vector<int>(m , 0));\\n        \\n        int k = 0 ;\\n        for(int i=0 ; i<n ; ++i){\\n            for(int j=0 ; j<m ; ++j){\\n                mp[i][j] = k++;\\n            }\\n        }\\n        \\n        \\n        dq.push_back({0,0});\\n        level[mp[0][0]] = 0 ; \\n        \\n        while(!dq.empty()){\\n            auto curr = dq.front(); \\n            int x = curr.first , y = curr.second ;\\n            dq.pop_front();\\n            if(x == n-1 && y == m-1) return level[mp[n-1][m-1]];\\n            \\n            for(int i = 0 ; i < 4 ; ++i){\\n                int newx = x + X[i] , newy = y + Y[i] ;\\n                if(isValid(newx,newy,grid)){\\n                    if(level[mp[x][y]] + grid[newx][newy] < level[mp[newx][newy]]){\\n                        \\n                        level[mp[newx][newy]] = level[mp[x][y]] + grid[newx][newy];\\n                        \\n                        if(grid[newx][newy] == 1){\\n                            dq.push_back({newx,newy});\\n                        }else{\\n                            dq.push_front({newx,newy});\\n                        }\\n                        \\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return level[mp[n-1][m-1]];\\n        \\n        \\n        \\n    }\\n};\\n```\\n\\n**For Further Reading:** https://cp-algorithms.com/graph/01_bfs.html\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int i , int j , vector<vector<int>>&grid){\\n         return (i >= 0 && j >= 0 && i < grid.size() && j < grid[0].size());\\n    }\\n    \\n    int X[4] = {0,0,1,-1};\\n    int Y[4] = {1,-1,0,0};\\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size() , m = grid[0].size() ;\\n        \\n        deque<pair<int,int>> dq ;\\n        \\n        vector<int>level(m*n,1e6);\\n        \\n        vector<vector<int>> mp(n , vector<int>(m , 0));\\n        \\n        int k = 0 ;\\n        for(int i=0 ; i<n ; ++i){\\n            for(int j=0 ; j<m ; ++j){\\n                mp[i][j] = k++;\\n            }\\n        }\\n        \\n        \\n        dq.push_back({0,0});\\n        level[mp[0][0]] = 0 ; \\n        \\n        while(!dq.empty()){\\n            auto curr = dq.front(); \\n            int x = curr.first , y = curr.second ;\\n            dq.pop_front();\\n            if(x == n-1 && y == m-1) return level[mp[n-1][m-1]];\\n            \\n            for(int i = 0 ; i < 4 ; ++i){\\n                int newx = x + X[i] , newy = y + Y[i] ;\\n                if(isValid(newx,newy,grid)){\\n                    if(level[mp[x][y]] + grid[newx][newy] < level[mp[newx][newy]]){\\n                        \\n                        level[mp[newx][newy]] = level[mp[x][y]] + grid[newx][newy];\\n                        \\n                        if(grid[newx][newy] == 1){\\n                            dq.push_back({newx,newy});\\n                        }else{\\n                            dq.push_front({newx,newy});\\n                        }\\n                        \\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return level[mp[n-1][m-1]];\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2915997,
                "title": "using-set-similar-like-dijkastra",
                "content": "# Intuition\\nbasically i saw the hint in te box ..\\n\\n# Approach\\nmaking a graph with nodes as matrix points and edges cost is the matrix value and now using dijkastra algortihm like approach. Here the only different thing i did was to use a single dimensional array instead of a multidimensional array.\\n\\n# Complexity\\n- Time complexity:\\nnlogn\\n\\n- Space complexity:\\nm*n \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        \\n      int m=grid.size();\\n      int n=grid[0].size();\\n      int i,j;\\n      vector<vector<pair< int, int> >> adj(m*n);\\n\\n      for(i=0;i<m;i++){\\n          for(j=0;j<n;j++){\\n      \\n      int c=n*i+j;\\n    \\n           if(i!=0){\\n            adj[c].push_back(make_pair(grid[i-1][j],n*(i-1)+j));\\n           }\\n           if(i!=m-1){\\n           adj[c].push_back(make_pair(grid[i+1][j],n*(i+1)+j));\\n           }\\n           if(j!=0){\\n           adj[c].push_back(make_pair(grid[i][j-1],n*i+j-1));\\n           }\\n           if(j!=n-1){\\n           adj[c].push_back(make_pair(grid[i][j+1],n*i+j+1 ));\\n           }\\n\\n          }\\n      }\\n\\n      set<pair<int,int>> s;\\n      \\n      s.insert(make_pair(0,0));\\n      vector<int> visited(m*n);\\n      for(i=0;i<m*n;i++){\\n          visited[i]=0;\\n      }\\n      visited[0]=1;\\n    \\n      while(s.empty()!=1){\\n       \\n       pair<int,int> p=*(s.begin());\\n\\n       visited[p.second]=1;\\n       if(p.second==m*n-1){\\n           return p.first;\\n       }\\n       s.erase(s.begin());\\n      for(j=0;j<adj[p.second].size();j++){\\n\\n         \\n           if(visited[adj[p.second][j].second]==0){\\n             s.insert(make_pair(p.first+adj[p.second][j].first,adj[p.second][j].second));\\n            \\n           }\\n      }\\n\\n\\n      }\\n\\n\\n     return (n+m-3);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        \\n      int m=grid.size();\\n      int n=grid[0].size();\\n      int i,j;\\n      vector<vector<pair< int, int> >> adj(m*n);\\n\\n      for(i=0;i<m;i++){\\n          for(j=0;j<n;j++){\\n      \\n      int c=n*i+j;\\n    \\n           if(i!=0){\\n            adj[c].push_back(make_pair(grid[i-1][j],n*(i-1)+j));\\n           }\\n           if(i!=m-1){\\n           adj[c].push_back(make_pair(grid[i+1][j],n*(i+1)+j));\\n           }\\n           if(j!=0){\\n           adj[c].push_back(make_pair(grid[i][j-1],n*i+j-1));\\n           }\\n           if(j!=n-1){\\n           adj[c].push_back(make_pair(grid[i][j+1],n*i+j+1 ));\\n           }\\n\\n          }\\n      }\\n\\n      set<pair<int,int>> s;\\n      \\n      s.insert(make_pair(0,0));\\n      vector<int> visited(m*n);\\n      for(i=0;i<m*n;i++){\\n          visited[i]=0;\\n      }\\n      visited[0]=1;\\n    \\n      while(s.empty()!=1){\\n       \\n       pair<int,int> p=*(s.begin());\\n\\n       visited[p.second]=1;\\n       if(p.second==m*n-1){\\n           return p.first;\\n       }\\n       s.erase(s.begin());\\n      for(j=0;j<adj[p.second].size();j++){\\n\\n         \\n           if(visited[adj[p.second][j].second]==0){\\n             s.insert(make_pair(p.first+adj[p.second][j].first,adj[p.second][j].second));\\n            \\n           }\\n      }\\n\\n\\n      }\\n\\n\\n     return (n+m-3);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2698821,
                "title": "tc-93-simple-dijkstra-python",
                "content": "```\\ndef minimumObstacles(self, grid: List[List[int]]) -> int:\\n    #find the min cost path from (0,0) to (m-1, n-1)\\n    m = len(grid); n = len(grid[0])\\n    \\n    heap = [[grid[0][0], 0, 0]]\\n    visited = [[0]*n for _ in range(m)]\\n    visited[0][0] = 1\\n    while heap:\\n        c_cost, c_i, c_j = heappop(heap)\\n        if (c_i,c_j) == (m-1,n-1):\\n            return c_cost\\n        for n_i,n_j in [[c_i-1,c_j], [c_i,c_j+1], [c_i+1,c_j], [c_i,c_j-1]]:\\n            if 0<=n_i<m and 0<=n_j<n and not visited[n_i][n_j]:\\n                visited[n_i][n_j] = 1\\n                heappush(heap, [c_cost + grid[n_i][n_j], n_i, n_j])\\n    \\n    return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Graph"
                ],
                "code": "```\\ndef minimumObstacles(self, grid: List[List[int]]) -> int:\\n    #find the min cost path from (0,0) to (m-1, n-1)\\n    m = len(grid); n = len(grid[0])\\n    \\n    heap = [[grid[0][0], 0, 0]]\\n    visited = [[0]*n for _ in range(m)]\\n    visited[0][0] = 1\\n    while heap:\\n        c_cost, c_i, c_j = heappop(heap)\\n        if (c_i,c_j) == (m-1,n-1):\\n            return c_cost\\n        for n_i,n_j in [[c_i-1,c_j], [c_i,c_j+1], [c_i+1,c_j], [c_i,c_j-1]]:\\n            if 0<=n_i<m and 0<=n_j<n and not visited[n_i][n_j]:\\n                visited[n_i][n_j] = 1\\n                heappush(heap, [c_cost + grid[n_i][n_j], n_i, n_j])\\n    \\n    return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2332889,
                "title": "faster-than-94-dijkastras-python",
                "content": "![image](https://assets.leetcode.com/users/images/6a346351-6041-471a-ae66-2dd6e49e4f96_1658769406.335623.png)\\n```\\nclass Solution:\\n    def minimumObstacles(self, g: List[List[int]]) -> int:\\n        n=len(g)\\n        m=len(g[0])\\n        d=[(0,0,0)]\\n        heapify(d)\\n        v={(0,0):0}\\n        while d:\\n            w,x,y=heappop(d)\\n            if x==n-1 and y==m-1:\\n                return w\\n            for i,j in [(1,0),(-1,0),(0,1),(0,-1)]:\\n                o=i+x\\n                p=j+y\\n                if o<n and p<m and o>=0 and p>=0 and (o,p)not in v:\\n                    v[(o,p)]=0\\n                    heappush(d,(g[o][p]+w,o,p))",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def minimumObstacles(self, g: List[List[int]]) -> int:\\n        n=len(g)\\n        m=len(g[0])\\n        d=[(0,0,0)]\\n        heapify(d)\\n        v={(0,0):0}",
                "codeTag": "Java"
            },
            {
                "id": 2313936,
                "title": "python3-dijkstra-s-algo",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/7a598e64fb507fc966a3025d8edd0c8e7caf0bec) for solutions of weekly 295. \\n\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dist = [[inf]*n for _ in range(m)]\\n        dist[0][0] = 0\\n        pq = [(0, 0, 0)]\\n        while pq: \\n            x, i, j = heappop(pq)\\n            if i == m-1 and j == n-1: return x\\n            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                if 0 <= ii < m and 0 <= jj < n and x + grid[ii][jj] < dist[ii][jj]: \\n                    dist[ii][jj] = x + grid[ii][jj]\\n                    heappush(pq, (dist[ii][jj], ii, jj))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dist = [[inf]*n for _ in range(m)]\\n        dist[0][0] = 0\\n        pq = [(0, 0, 0)]\\n        while pq: \\n            x, i, j = heappop(pq)\\n            if i == m-1 and j == n-1: return x\\n            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                if 0 <= ii < m and 0 <= jj < n and x + grid[ii][jj] < dist[ii][jj]: \\n                    dist[ii][jj] = x + grid[ii][jj]\\n                    heappush(pq, (dist[ii][jj], ii, jj))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303474,
                "title": "c-0-1-bfs-deque",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size(), n = grid[0].size();\\n       \\n        vector<vector<int>> dp(m, vector<int>(n, INT_MAX));\\n        vector<vector<bool>> vis(m, vector<bool>(n, 0));\\n        deque<pair<int, int>> q;\\n        \\n        q.push_front({0, 0});\\n        dp[0][0] = 0;\\n        \\n        int dx[] = {1, -1, 0, 0};\\n        int dy[] = {0, 0, 1, -1};\\n        \\n        while (!q.empty())\\n        {\\n            pair<int, int> p = q.front();\\n            q.pop_front();\\n            \\n            int x = p.first, y = p.second;\\n            for (int i = 0; i < 4; i++)\\n            {\\n                int xx = x + dx[i], yy = y + dy[i];\\n                if (xx >= 0 && yy >= 0 && xx < m && yy < n)\\n                {\\n                    if(!vis[xx][yy])\\n                    {\\n                        dp[xx][yy] = dp[x][y] + (grid[xx][yy] == 1);\\n                        grid[xx][yy] ? q.push_back({xx, yy}) : q.push_front({xx, yy});\\n                    }\\n                    vis[xx][yy] = true;\\n                }    \\n            }\\n        }\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size(), n = grid[0].size();\\n       \\n        vector<vector<int>> dp(m, vector<int>(n, INT_MAX));\\n        vector<vector<bool>> vis(m, vector<bool>(n, 0));\\n        deque<pair<int, int>> q;\\n        \\n        q.push_front({0, 0});\\n        dp[0][0] = 0;\\n        \\n        int dx[] = {1, -1, 0, 0};\\n        int dy[] = {0, 0, 1, -1};\\n        \\n        while (!q.empty())\\n        {\\n            pair<int, int> p = q.front();\\n            q.pop_front();\\n            \\n            int x = p.first, y = p.second;\\n            for (int i = 0; i < 4; i++)\\n            {\\n                int xx = x + dx[i], yy = y + dy[i];\\n                if (xx >= 0 && yy >= 0 && xx < m && yy < n)\\n                {\\n                    if(!vis[xx][yy])\\n                    {\\n                        dp[xx][yy] = dp[x][y] + (grid[xx][yy] == 1);\\n                        grid[xx][yy] ? q.push_back({xx, yy}) : q.push_front({xx, yy});\\n                    }\\n                    vis[xx][yy] = true;\\n                }    \\n            }\\n        }\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300713,
                "title": "c-dijkastras",
                "content": "```\\nclass Solution {\\npublic:\\n    int dx[4] = {1 , 0 , -1 , 0};\\n    int dy[4] = {0 , 1 , 0 , -1};\\n    int minimumObstacles(vector<vector<int>> &a) {\\n        int n = a.size();\\n        int m = a[0].size();\\n        priority_queue<pair<int , pair<int , int>> , vector<pair<int , pair<int , int>>> , greater<pair<int , pair<int , int>>>> q;\\n        vector<vector<int>> dist(n , vector<int>(m , 1e9));\\n        dist[0][0] = 0;\\n        q.push({0 , {0 , 0}});\\n        while(!q.empty()) {\\n            pair<int , pair<int , int>> p = q.top();\\n            q.pop();\\n            int cost = p.first;\\n            int x = p.second.first , y = p.second.second;\\n            for(int i=0 ; i<4 ; i++) {\\n                int nx = x + dx[i];\\n                int ny = y + dy[i];\\n                if(nx >= 0 && ny >= 0 && nx < n && ny < m) {\\n                    if(a[nx][ny] && dist[nx][ny] > cost + 1) {\\n                        dist[nx][ny] = cost + 1;\\n                        q.push({cost + 1 , {nx , ny}});\\n                    } else if(!a[nx][ny] && dist[nx][ny] > cost) {\\n                        dist[nx][ny] = cost;\\n                        q.push({cost , {nx , ny}});\\n                    }\\n                }\\n            }\\n        }\\n        return dist[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4] = {1 , 0 , -1 , 0};\\n    int dy[4] = {0 , 1 , 0 , -1};\\n    int minimumObstacles(vector<vector<int>> &a) {\\n        int n = a.size();\\n        int m = a[0].size();\\n        priority_queue<pair<int , pair<int , int>> , vector<pair<int , pair<int , int>>> , greater<pair<int , pair<int , int>>>> q;\\n        vector<vector<int>> dist(n , vector<int>(m , 1e9));\\n        dist[0][0] = 0;\\n        q.push({0 , {0 , 0}});\\n        while(!q.empty()) {\\n            pair<int , pair<int , int>> p = q.top();\\n            q.pop();\\n            int cost = p.first;\\n            int x = p.second.first , y = p.second.second;\\n            for(int i=0 ; i<4 ; i++) {\\n                int nx = x + dx[i];\\n                int ny = y + dy[i];\\n                if(nx >= 0 && ny >= 0 && nx < n && ny < m) {\\n                    if(a[nx][ny] && dist[nx][ny] > cost + 1) {\\n                        dist[nx][ny] = cost + 1;\\n                        q.push({cost + 1 , {nx , ny}});\\n                    } else if(!a[nx][ny] && dist[nx][ny] > cost) {\\n                        dist[nx][ny] = cost;\\n                        q.push({cost , {nx , ny}});\\n                    }\\n                }\\n            }\\n        }\\n        return dist[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2253061,
                "title": "python-bfs-min-heap",
                "content": "```\\ndef minimumObstacles(self, grid: List[List[int]]) -> int:\\n\\t# 1) Set variables: BFS related variables:\\n\\tROWS, COLS = len(grid), len(grid[0])\\n\\tdirections = [[0,1], [0,-1], [1,0], [-1,0]]\\n\\tdestination = (ROWS-1, COLS-1)\\n\\tvisited = set()\\n\\tqueue = []          \\n\\n\\t# 2) Initiate variables:\\n\\t# row, col, and obstacles:\\n\\tqueue.append((0, 0, 0))\\n\\tvisited.add((0, 0))\\n\\n\\t# Create min heap:\\n\\theapq.heapify(queue)\\n\\n\\t# 3) Perform BFS loop:\\n\\twhile queue:\\n\\t\\t# a) Unpack data from heap:\\n\\t\\tobsc, row, col = heapq.heappop(queue)\\n\\n\\t\\t# a) Check if destination is reached:\\n\\t\\tif (row, col) == destination:\\n\\t\\t\\treturn obsc\\n\\n\\t\\t# b) Explore neighbour directions:\\n\\t\\tfor rd, cd in directions:\\n\\t\\t\\tr = rd + row\\n\\t\\t\\tc = cd + col\\n\\n\\t\\t\\t# c) Check boundaries and visited cells:\\n\\t\\t\\tif r in range(0, ROWS) and c in range(0, COLS) and (r, c) not in visited:\\n\\t\\t\\t\\t# Increase number of obstacles to remove if\\n\\t\\t\\t\\t# any of the neighbour cells is an obstacle:\\n\\t\\t\\t\\tnewObsc = obsc + grid[r][c]\\n\\n\\t\\t\\t\\t# Add new number of obstacles, if any, to\\n\\t\\t\\t\\t# min heap so it will be sorted accordingly:\\n\\t\\t\\t\\theapq.heappush(queue, (newObsc, r, c))\\n\\t\\t\\t\\tvisited.add((r, c))\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef minimumObstacles(self, grid: List[List[int]]) -> int:\\n\\t# 1) Set variables: BFS related variables:\\n\\tROWS, COLS = len(grid), len(grid[0])\\n\\tdirections = [[0,1], [0,-1], [1,0], [-1,0]]\\n\\tdestination = (ROWS-1, COLS-1)\\n\\tvisited = set()\\n\\tqueue = []          \\n\\n\\t# 2) Initiate variables:\\n\\t# row, col, and obstacles:\\n\\tqueue.append((0, 0, 0))\\n\\tvisited.add((0, 0))\\n\\n\\t# Create min heap:\\n\\theapq.heapify(queue)\\n\\n\\t# 3) Perform BFS loop:\\n\\twhile queue:\\n\\t\\t# a) Unpack data from heap:\\n\\t\\tobsc, row, col = heapq.heappop(queue)\\n\\n\\t\\t# a) Check if destination is reached:\\n\\t\\tif (row, col) == destination:\\n\\t\\t\\treturn obsc\\n\\n\\t\\t# b) Explore neighbour directions:\\n\\t\\tfor rd, cd in directions:\\n\\t\\t\\tr = rd + row\\n\\t\\t\\tc = cd + col\\n\\n\\t\\t\\t# c) Check boundaries and visited cells:\\n\\t\\t\\tif r in range(0, ROWS) and c in range(0, COLS) and (r, c) not in visited:\\n\\t\\t\\t\\t# Increase number of obstacles to remove if\\n\\t\\t\\t\\t# any of the neighbour cells is an obstacle:\\n\\t\\t\\t\\tnewObsc = obsc + grid[r][c]\\n\\n\\t\\t\\t\\t# Add new number of obstacles, if any, to\\n\\t\\t\\t\\t# min heap so it will be sorted accordingly:\\n\\t\\t\\t\\theapq.heappush(queue, (newObsc, r, c))\\n\\t\\t\\t\\tvisited.add((r, c))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2175710,
                "title": "python-easy-to-read-and-undertand-01-bfs",
                "content": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        if grid[0][0] == 0:\\n            q = [(0, 0, 0)]\\n        else:\\n            q = [(0, 0, 1)]\\n        visit = set()\\n        \\n        while q:\\n            cost, x, y = q.pop(0)\\n            #print(x, y, cost)\\n            if x == m-1 and y == n-1:\\n                return cost\\n            if x > 0 and (x-1, y) not in visit:\\n                visit.add((x-1, y))\\n                if grid[x-1][y] == 0:\\n                    q.insert(0, (cost, x-1, y))\\n                else:\\n                    q.append((cost+1, x-1, y))\\n            if y > 0 and (x, y-1) not in visit:\\n                visit.add((x, y-1))\\n                if grid[x][y-1] == 0:\\n                    q.insert(0, (cost, x, y-1))\\n                else:\\n                    q.append((cost+1, x, y-1))\\n            if x < m-1 and (x+1, y) not in visit:\\n                visit.add((x+1, y))\\n                if grid[x+1][y] == 0:\\n                    q.insert(0, (cost, x+1, y))\\n                else:\\n                    q.append((cost+1, x+1, y))\\n            if y < n-1 and (x, y+1) not in visit:\\n                visit.add((x, y+1))\\n                if grid[x][y+1] == 0:\\n                    q.insert(0, (cost, x, y+1))\\n                else:\\n                    q.append((cost+1, x, y+1))",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        if grid[0][0] == 0:\\n            q = [(0, 0, 0)]\\n        else:\\n            q = [(0, 0, 1)]\\n        visit = set()\\n        \\n        while q:\\n            cost, x, y = q.pop(0)\\n            #print(x, y, cost)\\n            if x == m-1 and y == n-1:\\n                return cost\\n            if x > 0 and (x-1, y) not in visit:\\n                visit.add((x-1, y))\\n                if grid[x-1][y] == 0:\\n                    q.insert(0, (cost, x-1, y))\\n                else:\\n                    q.append((cost+1, x-1, y))\\n            if y > 0 and (x, y-1) not in visit:\\n                visit.add((x, y-1))\\n                if grid[x][y-1] == 0:\\n                    q.insert(0, (cost, x, y-1))\\n                else:\\n                    q.append((cost+1, x, y-1))\\n            if x < m-1 and (x+1, y) not in visit:\\n                visit.add((x+1, y))\\n                if grid[x+1][y] == 0:\\n                    q.insert(0, (cost, x+1, y))\\n                else:\\n                    q.append((cost+1, x+1, y))\\n            if y < n-1 and (x, y+1) not in visit:\\n                visit.add((x, y+1))\\n                if grid[x][y+1] == 0:\\n                    q.insert(0, (cost, x, y+1))\\n                else:\\n                    q.append((cost+1, x, y+1))",
                "codeTag": "Java"
            },
            {
                "id": 2144721,
                "title": "straightforward-java-bfs",
                "content": "```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        Queue<int[]> q = new LinkedList<>();\\n        \\n        int[][] dir = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n\\n\\n        q.add(new int[]{0, 0});\\n        \\n        int[][] dist = new int[m][n];\\n        for (int[] row: dist) {\\n            Arrays.fill(row, Integer.MAX_VALUE);\\n        }\\n        dist[0][0] = 0;\\n        \\n        while (!q.isEmpty()) {\\n            \\n\\n            int[] curr = q.poll();\\n\\n            for (int i = 0; i < 4; i++) {\\n                int newrow = curr[0] + dir[i][0];\\n                int newcol = curr[1] + dir[i][1];\\n\\n\\n                if (newrow < 0 || newcol < 0 || newrow >= grid.length || newcol >= grid[0].length) {\\n                    // skipped while:\\n                    // out of bound\\n                    continue; \\n                }\\n\\n\\n                if (grid[newrow][newcol] == 1) {\\n                    if (dist[curr[0]][curr[1]] + 1 < dist[newrow][newcol]) {\\n                        dist[newrow][newcol] = dist[curr[0]][curr[1]] + 1;\\n                        q.add(new int[]{newrow, newcol});\\n                    }\\n                } else if (grid[newrow][newcol] == 0) {\\n                    if (dist[curr[0]][curr[1]] < dist[newrow][newcol]) {\\n                        dist[newrow][newcol] = dist[curr[0]][curr[1]];\\n                        q.add(new int[]{newrow, newcol});\\n                    }\\n                } \\n            }\\n\\n        }\\n        return dist[m - 1][n - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        Queue<int[]> q = new LinkedList<>();\\n        \\n        int[][] dir = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n\\n\\n        q.add(new int[]{0, 0});\\n        \\n        int[][] dist = new int[m][n];\\n        for (int[] row: dist) {\\n            Arrays.fill(row, Integer.MAX_VALUE);\\n        }\\n        dist[0][0] = 0;\\n        \\n        while (!q.isEmpty()) {\\n            \\n\\n            int[] curr = q.poll();\\n\\n            for (int i = 0; i < 4; i++) {\\n                int newrow = curr[0] + dir[i][0];\\n                int newcol = curr[1] + dir[i][1];\\n\\n\\n                if (newrow < 0 || newcol < 0 || newrow >= grid.length || newcol >= grid[0].length) {\\n                    // skipped while:\\n                    // out of bound\\n                    continue; \\n                }\\n\\n\\n                if (grid[newrow][newcol] == 1) {\\n                    if (dist[curr[0]][curr[1]] + 1 < dist[newrow][newcol]) {\\n                        dist[newrow][newcol] = dist[curr[0]][curr[1]] + 1;\\n                        q.add(new int[]{newrow, newcol});\\n                    }\\n                } else if (grid[newrow][newcol] == 0) {\\n                    if (dist[curr[0]][curr[1]] < dist[newrow][newcol]) {\\n                        dist[newrow][newcol] = dist[curr[0]][curr[1]];\\n                        q.add(new int[]{newrow, newcol});\\n                    }\\n                } \\n            }\\n\\n        }\\n        return dist[m - 1][n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136101,
                "title": "c-bfs-dijkstras-0-1-bfs",
                "content": "**DFS *(Accecpted)***\\n**Note -** for example like `[[0, 1], [0, 1]]` in this case `(1, 1)` cell visit twice, 1st time from `(0, 1)` cell with cost `2` and 2nd time from `(1, 0)` cell with cost `1` even though `1` is better, queue contains both. Meanwhile `dp` got updated at time of `enqueue`, so the `savior` condition will not allow those expensive paths.\\n\\n**for CPP users avoid using vector**\\n\\n*Time complexity :* `greater than O(H * W)` cause a cell can be visited more than once, or it might be `O(V + E)` \\u2248 `O(H * (W - 1)) + O(W * (H - 1))` \\nwhere  `H = grid.size(), W = grid[0].size(), V = no. of vertices, E = no. of edges`\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        const auto INF = int(1e5) + 5;\\n        const vector<pair<int, int>> DIR = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        int H = (int) grid.size(), W = (int) grid[0].size();\\n        // vector<vector<int>> dp(H, vector<int> (W, INF));\\n        int dp[H][W];\\n        \\n        for (int i = 0; i < H; i++)\\n            for (int j = 0; j < W; j++)\\n                dp[i][j] = INF;\\n        \\n        queue<tuple<int, int, int>> q;\\n        q.push(make_tuple(0, 0, grid[0][0]));\\n        \\n        while (!q.empty()) {\\n            for (int i = q.size(); i > 0; i--) {\\n                auto [r, c, cost] = q.front();\\n                q.pop();\\n\\n                if (r == H - 1 && c == W - 1) {\\n                    ans = min(ans, cost);\\n                    continue;\\n                }\\n\\n                if (dp[r][c] < cost)  // saved me from getting TLE\\n                    continue;\\n\\n                for (auto [x, y] : DIR) \\n                    if (r + x >= 0 && c + y >= 0 && r + x < H && c + y < W) \\n                        if (cost + grid[r + x][c + y] < dp[r + x][c + y]) {\\n                            dp[r + x][c + y] = cost + grid[r + x][c + y];\\n                            q.push(make_tuple(r + x, c + y, cost + grid[r + x][c + y]));\\n                        }\\n            }\\n        }      \\n        \\n        return dp[H - 1][W - 1];\\n    }\\n};\\n```\\n**Dijktras *(Accepted)***\\n*Time complexity :* `O(H * W * Log(H * W))`\\n```\\nclass Solution {\\n\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        const auto INF = int(1e5) + 5;\\n        const vector<pair<int, int>> DIR = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        int H = (int) grid.size(), W = (int) grid[0].size();\\n        // vector<vector<int>> dp(H, vector<int> (W, INF));\\n        int dp[H][W];\\n        \\n        for (int i = 0; i < H; i++)\\n            for (int j = 0; j < W; j++)\\n                dp[i][j] = INF;\\n        \\n        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<>> pq;\\n        pq.push(make_tuple(0, 0, grid[0][0]));\\n        int ans = INF;\\n        \\n        while (!pq.empty()) {\\n            auto [cost, r, c] = pq.top();\\n            pq.pop();\\n            \\n            if (r == H - 1 && c == W - 1) {\\n                ans = cost;\\n                break;\\n            }\\n            \\n            for (auto [x, y] : DIR) \\n                if (r + x >= 0 && c + y >= 0 && r + x < H && c + y < W) \\n                    if (cost + grid[r + x][c + y] < dp[r + x][c + y]) {\\n                        dp[r + x][c + y] = cost + grid[r + x][c + y];\\n                        pq.push(make_tuple(cost + grid[r + x][c + y], r + x, c + y));\\n                    }\\n        }      \\n        \\n        // return dp[H - 1][W - 1]; // it will also work obviously \\n        return ans;\\n    }\\n};\\n```\\n**Modified BFS or 0-1 BFS (Accepted)**\\n*Time complexity :* O(H * W)\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        const auto INF = int(1e5) + 5;\\n        const vector<pair<int, int>> DIR = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        int H = (int) grid.size(), W = (int) grid[0].size();\\n        // vector<vector<int>> dp(H, vector<int> (W, INF));\\n        int dp[H][W];\\n        \\n        for (int i = 0; i < H; i++)\\n            for (int j = 0; j < W; j++)\\n                dp[i][j] = INF;\\n        \\n        deque<pair<int, int>> dq;\\n        dp[0][0] = 0;\\n        dq.push_front(make_pair(0, 0));\\n        \\n        while (!dq.empty()) {\\n            auto [r, c] = dq.front();\\n            dq.pop_front();\\n            \\n            if (r == H - 1 && c == W - 1)\\n                return dp[r][c];\\n            \\n            for (auto [x, y] : DIR) \\n                if (r + x >= 0 && c + y >= 0 && r + x < H && c + y < W && grid[r + x][c + y] != 2) {\\n                    if (!grid[r + x][c + y])\\n                        dq.push_front({r + x, c + y});\\n                    else\\n                        dq.push_back({r + x, c + y});\\n                    \\n                    dp[r + x][c + y] = dp[r][c] + grid[r + x][c + y];\\n                    grid[r + x][c + y] = 2;\\n                }\\n        }\\n        \\n        return dp[H - 1][W - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        const auto INF = int(1e5) + 5;\\n        const vector<pair<int, int>> DIR = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        int H = (int) grid.size(), W = (int) grid[0].size();\\n        // vector<vector<int>> dp(H, vector<int> (W, INF));\\n        int dp[H][W];\\n        \\n        for (int i = 0; i < H; i++)\\n            for (int j = 0; j < W; j++)\\n                dp[i][j] = INF;\\n        \\n        queue<tuple<int, int, int>> q;\\n        q.push(make_tuple(0, 0, grid[0][0]));\\n        \\n        while (!q.empty()) {\\n            for (int i = q.size(); i > 0; i--) {\\n                auto [r, c, cost] = q.front();\\n                q.pop();\\n\\n                if (r == H - 1 && c == W - 1) {\\n                    ans = min(ans, cost);\\n                    continue;\\n                }\\n\\n                if (dp[r][c] < cost)  // saved me from getting TLE\\n                    continue;\\n\\n                for (auto [x, y] : DIR) \\n                    if (r + x >= 0 && c + y >= 0 && r + x < H && c + y < W) \\n                        if (cost + grid[r + x][c + y] < dp[r + x][c + y]) {\\n                            dp[r + x][c + y] = cost + grid[r + x][c + y];\\n                            q.push(make_tuple(r + x, c + y, cost + grid[r + x][c + y]));\\n                        }\\n            }\\n        }      \\n        \\n        return dp[H - 1][W - 1];\\n    }\\n};\\n```\n```\\nclass Solution {\\n\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        const auto INF = int(1e5) + 5;\\n        const vector<pair<int, int>> DIR = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        int H = (int) grid.size(), W = (int) grid[0].size();\\n        // vector<vector<int>> dp(H, vector<int> (W, INF));\\n        int dp[H][W];\\n        \\n        for (int i = 0; i < H; i++)\\n            for (int j = 0; j < W; j++)\\n                dp[i][j] = INF;\\n        \\n        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<>> pq;\\n        pq.push(make_tuple(0, 0, grid[0][0]));\\n        int ans = INF;\\n        \\n        while (!pq.empty()) {\\n            auto [cost, r, c] = pq.top();\\n            pq.pop();\\n            \\n            if (r == H - 1 && c == W - 1) {\\n                ans = cost;\\n                break;\\n            }\\n            \\n            for (auto [x, y] : DIR) \\n                if (r + x >= 0 && c + y >= 0 && r + x < H && c + y < W) \\n                    if (cost + grid[r + x][c + y] < dp[r + x][c + y]) {\\n                        dp[r + x][c + y] = cost + grid[r + x][c + y];\\n                        pq.push(make_tuple(cost + grid[r + x][c + y], r + x, c + y));\\n                    }\\n        }      \\n        \\n        // return dp[H - 1][W - 1]; // it will also work obviously \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        const auto INF = int(1e5) + 5;\\n        const vector<pair<int, int>> DIR = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        int H = (int) grid.size(), W = (int) grid[0].size();\\n        // vector<vector<int>> dp(H, vector<int> (W, INF));\\n        int dp[H][W];\\n        \\n        for (int i = 0; i < H; i++)\\n            for (int j = 0; j < W; j++)\\n                dp[i][j] = INF;\\n        \\n        deque<pair<int, int>> dq;\\n        dp[0][0] = 0;\\n        dq.push_front(make_pair(0, 0));\\n        \\n        while (!dq.empty()) {\\n            auto [r, c] = dq.front();\\n            dq.pop_front();\\n            \\n            if (r == H - 1 && c == W - 1)\\n                return dp[r][c];\\n            \\n            for (auto [x, y] : DIR) \\n                if (r + x >= 0 && c + y >= 0 && r + x < H && c + y < W && grid[r + x][c + y] != 2) {\\n                    if (!grid[r + x][c + y])\\n                        dq.push_front({r + x, c + y});\\n                    else\\n                        dq.push_back({r + x, c + y});\\n                    \\n                    dp[r + x][c + y] = dp[r][c] + grid[r + x][c + y];\\n                    grid[r + x][c + y] = 2;\\n                }\\n        }\\n        \\n        return dp[H - 1][W - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2125920,
                "title": "dijekstra",
                "content": "\\tclass Node{\\n    public:\\n    int r,c,w;\\n    Node(int row,int col,int weight){\\n        r=row;\\n        c=col;\\n        w=weight;\\n    }\\n\\t};\\n\\tclass comparator{\\n    public:\\n    bool operator()(Node &a,Node&b){\\n        return a.w>b.w;\\n    }\\n\\t};\\n\\tclass Solution {\\n\\tpublic:\\n    vector<vector<int>>dir={{0,1},{0,-1},{1,0},{-1,0}};\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>matrix(n,vector<int>(m,INT_MAX));\\n        priority_queue<Node,vector<Node>,comparator>pq;\\n   \\n      if(grid[0][0]==0){\\n          pq.push({0,0,0});\\n          matrix[0][0]=0;\\n      }else{\\n          pq.push({0,0,1});\\n          matrix[0][0]=1;\\n      }  \\n      while(!pq.empty()){\\n       Node curr=pq.top();\\n          pq.pop();\\n          if(curr.r==n-1 && curr.c==m-1){\\n              if(grid[n-1][m-1]==1)\\n                  return curr.w+1;\\n              else \\n                  return curr.w;\\n          }\\n          for(auto &x:dir){\\n              int r=curr.r+x[0];\\n              int c=curr.c+x[1];\\n              if(r>=0 && c>=0 && r<n && c<m && matrix[curr.r][curr.c]+grid[r][c]<matrix[r][c]){\\n                  matrix[r][c]=matrix[curr.r][curr.c]+grid[r][c];\\n                  pq.push({r,c,matrix[r][c]});\\n              }\\n          }\\n              \\n      }\\n      return -1;  \\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    vector<vector<int>>dir={{0,1}",
                "codeTag": "Java"
            },
            {
                "id": 2118287,
                "title": "java-simple-bfs",
                "content": "This isn\\'t a hard problem, just a simple bfs.\\n\\n```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        int[][] dirs = new int[][] { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n        \\n        Queue<State> q = new PriorityQueue<>((a, b) -> a.removed - b.removed);\\n        q.add(new State(0, 0, 0));\\n        \\n        boolean[][] visited = new boolean[n][m];\\n        visited[0][0] = true;\\n        \\n        while (!q.isEmpty()) {\\n            State state = q.poll();\\n            \\n            if (state.r == n - 1 && state.c == m - 1)\\n                return state.removed;\\n            \\n            for (int[] d : dirs) {\\n                int nr = state.r + d[0];\\n                int nc = state.c + d[1];\\n                \\n                if (nr < 0 || nc < 0 || nr == n || nc == m || visited[nr][nc])\\n                    continue;\\n                \\n                visited[nr][nc] = true;\\n                \\n                State next = new State(nr, nc, state.removed);\\n                \\n                if (grid[nr][nc] == 1)\\n                    next.removed++;\\n                \\n                q.add(next);\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    class State {\\n        int r;\\n        int c;\\n        int removed;\\n        \\n        State(int r, int c, int removed) {\\n            this.r = r;\\n            this.c = c;\\n            this.removed = removed;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        int[][] dirs = new int[][] { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n        \\n        Queue<State> q = new PriorityQueue<>((a, b) -> a.removed - b.removed);\\n        q.add(new State(0, 0, 0));\\n        \\n        boolean[][] visited = new boolean[n][m];\\n        visited[0][0] = true;\\n        \\n        while (!q.isEmpty()) {\\n            State state = q.poll();\\n            \\n            if (state.r == n - 1 && state.c == m - 1)\\n                return state.removed;\\n            \\n            for (int[] d : dirs) {\\n                int nr = state.r + d[0];\\n                int nc = state.c + d[1];\\n                \\n                if (nr < 0 || nc < 0 || nr == n || nc == m || visited[nr][nc])\\n                    continue;\\n                \\n                visited[nr][nc] = true;\\n                \\n                State next = new State(nr, nc, state.removed);\\n                \\n                if (grid[nr][nc] == 1)\\n                    next.removed++;\\n                \\n                q.add(next);\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    class State {\\n        int r;\\n        int c;\\n        int removed;\\n        \\n        State(int r, int c, int removed) {\\n            this.r = r;\\n            this.c = c;\\n            this.removed = removed;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2116006,
                "title": "simple-java-solution-using-priorityqueue",
                "content": "```\\nclass Solution {\\n    int[][] dirt = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        pq.offer(new int[]{0, 0, 0});\\n        while (!pq.isEmpty()) {\\n            int[] cur = pq.poll();\\n            if (cur[0] == m - 1 && cur[1] == n - 1) return cur[2];\\n            for (int[] d : dirt) {\\n                int x = d[0] + cur[0], y = d[1] + cur[1];\\n                if (x >= 0 && x < m && y >= 0 && y < n && !visited[x][y]) {\\n                    visited[x][y] = true;\\n                    if (grid[x][y] == 1) {\\n                        pq.offer(new int[]{x, y, cur[2] + 1});\\n                    } else {\\n                        pq.offer(new int[]{x, y, cur[2]});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dirt = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        pq.offer(new int[]{0, 0, 0});\\n        while (!pq.isEmpty()) {\\n            int[] cur = pq.poll();\\n            if (cur[0] == m - 1 && cur[1] == n - 1) return cur[2];\\n            for (int[] d : dirt) {\\n                int x = d[0] + cur[0], y = d[1] + cur[1];\\n                if (x >= 0 && x < m && y >= 0 && y < n && !visited[x][y]) {\\n                    visited[x][y] = true;\\n                    if (grid[x][y] == 1) {\\n                        pq.offer(new int[]{x, y, cur[2] + 1});\\n                    } else {\\n                        pq.offer(new int[]{x, y, cur[2]});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115349,
                "title": "c-bfs-dynamic-programming-solution-with-explanation",
                "content": "Intution:At very first instance this problem looks like a Dynamic programming problem.But Dynamic programming will not work here because here we have neighbours in four directions so minimum value for each node is also dependent on path from which it is arrived there (because we are marking previous nodes as visited ).\\n\\n**Upvote if you liked post.**\\nDynamic Programmig solution(Gives Wrong Answer)\\n```\\nclass Solution {\\n\\n    int dfs(vector<vector<int>>& grid,int r,int c, vector<vector<int>> &visited,vector<vector<int>> &mp)\\n    {\\n        if(r<0 || r>=grid.size() || c<0 || c>=grid[0].size())return INT_MAX-1;\\n        if(visited[r][c]!=-1)return visited[r][c];\\n        if(mp[r][c]!=-1)return INT_MAX-1;\\n        if(r==grid.size()-1 && c==grid[0].size()-1)return  grid[r][c];\\n        int count=INT_MAX-1;\\n        int x=grid[r][c];\\n        mp[r][c]=1;\\n      //  visited[r][c]=INT_MAX-1;\\n        count=min(count,dfs(grid,r+1,c,visited,mp));\\n        count=min(count,dfs(grid,r,c-1,visited,mp));\\n        count=min(count,dfs(grid,r,c+1,visited,mp));\\n        \\n        count=min(count,dfs(grid,r-1,c,visited,mp));\\n        mp[r][c]=-1;\\n        count+=x;\\n        return visited[r][c]=count;\\n        \\n    }\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        vector<vector<int>>visited(grid.size(),vector<int>(grid[0].size(),-1));\\n        vector<vector<int>>mp(grid.size(),vector<int>(grid[0].size(),-1));\\n        int ans= dfs(grid,0,0,visited,mp);\\n       /* for(int i=0;i<visited.size();i++)\\n        {\\n            for(int j=0;j<visited[0].size();j++)\\n            {\\n                cout<<visited[i][j]<<\" \";\\n            }\\n            cout<<endl;\\n        }*/\\n        return ans;\\n    }\\n};\\n```\\nDijakastras Algorithm(Accepted)\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int weight,r,c;\\n        vector<vector<int>>visited(grid.size(),vector<int>(grid[0].size(),INT_MAX));\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>q;\\n        q.push(pair<int,pair<int,int>>(0,pair<int,int>(0,0)));\\n        visited[0][0]=0;\\n        while(!q.empty())\\n        {\\n            weight=q.top().first;\\n            r=q.top().second.first;\\n            c=q.top().second.second;\\n            if(r==grid.size()-1 && c==grid[0].size()-1)return weight;\\n            q.pop();\\n            weight+=grid[r][c];\\n            if(r-1>=0 && visited[r-1][c]>weight)\\n            {\\n                q.push(pair<int,pair<int,int>>(weight,pair<int,int>(r-1,c)));\\n                visited[r-1][c]=weight;\\n            }\\n            if(c-1>=0 && visited[r][c-1]>weight)\\n            {\\n                q.push(pair<int,pair<int,int>>(weight,pair<int,int>(r,c-1)));\\n                visited[r][c-1]=weight;\\n            }\\n             if(r+1<grid.size() && visited[r+1][c]>weight)\\n            {\\n                q.push(pair<int,pair<int,int>>(weight,pair<int,int>(r+1,c)));\\n                visited[r+1][c]=weight;\\n            }\\n            if(c+1<grid[0].size() && visited[r][c+1]>weight)\\n            {\\n                q.push(pair<int,pair<int,int>>(weight,pair<int,int>(r,c+1)));\\n                visited[r][c+1]=weight;\\n            }\\n            \\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n\\n    int dfs(vector<vector<int>>& grid,int r,int c, vector<vector<int>> &visited,vector<vector<int>> &mp)\\n    {\\n        if(r<0 || r>=grid.size() || c<0 || c>=grid[0].size())return INT_MAX-1;\\n        if(visited[r][c]!=-1)return visited[r][c];\\n        if(mp[r][c]!=-1)return INT_MAX-1;\\n        if(r==grid.size()-1 && c==grid[0].size()-1)return  grid[r][c];\\n        int count=INT_MAX-1;\\n        int x=grid[r][c];\\n        mp[r][c]=1;\\n      //  visited[r][c]=INT_MAX-1;\\n        count=min(count,dfs(grid,r+1,c,visited,mp));\\n        count=min(count,dfs(grid,r,c-1,visited,mp));\\n        count=min(count,dfs(grid,r,c+1,visited,mp));\\n        \\n        count=min(count,dfs(grid,r-1,c,visited,mp));\\n        mp[r][c]=-1;\\n        count+=x;\\n        return visited[r][c]=count;\\n        \\n    }\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        vector<vector<int>>visited(grid.size(),vector<int>(grid[0].size(),-1));\\n        vector<vector<int>>mp(grid.size(),vector<int>(grid[0].size(),-1));\\n        int ans= dfs(grid,0,0,visited,mp);\\n       /* for(int i=0;i<visited.size();i++)\\n        {\\n            for(int j=0;j<visited[0].size();j++)\\n            {\\n                cout<<visited[i][j]<<\" \";\\n            }\\n            cout<<endl;\\n        }*/\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int weight,r,c;\\n        vector<vector<int>>visited(grid.size(),vector<int>(grid[0].size(),INT_MAX));\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>q;\\n        q.push(pair<int,pair<int,int>>(0,pair<int,int>(0,0)));\\n        visited[0][0]=0;\\n        while(!q.empty())\\n        {\\n            weight=q.top().first;\\n            r=q.top().second.first;\\n            c=q.top().second.second;\\n            if(r==grid.size()-1 && c==grid[0].size()-1)return weight;\\n            q.pop();\\n            weight+=grid[r][c];\\n            if(r-1>=0 && visited[r-1][c]>weight)\\n            {\\n                q.push(pair<int,pair<int,int>>(weight,pair<int,int>(r-1,c)));\\n                visited[r-1][c]=weight;\\n            }\\n            if(c-1>=0 && visited[r][c-1]>weight)\\n            {\\n                q.push(pair<int,pair<int,int>>(weight,pair<int,int>(r,c-1)));\\n                visited[r][c-1]=weight;\\n            }\\n             if(r+1<grid.size() && visited[r+1][c]>weight)\\n            {\\n                q.push(pair<int,pair<int,int>>(weight,pair<int,int>(r+1,c)));\\n                visited[r+1][c]=weight;\\n            }\\n            if(c+1<grid[0].size() && visited[r][c+1]>weight)\\n            {\\n                q.push(pair<int,pair<int,int>>(weight,pair<int,int>(r,c+1)));\\n                visited[r][c+1]=weight;\\n            }\\n            \\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2106773,
                "title": "c-dijkstra-s-algorithm-implementation-based-on-set-stl",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // Approach : Dijkstra\\'s Algorithm ; Implementation Based On Set: STL\\n    // Time Complexity : o(mnlog(mn)) ; Space Complexity : O(mn)\\n    \\n    // Steps :\\n    \\n    // 1) Initialise the distances of all grid elements as INT_MAX in dp array\\n    // 2) Insert source into set where <distance, u, v>\\n    // 3) While set doesn\\'t become empty do,\\n    //   i) extract minimum distance from set, let extracted be (i, j)\\n    //   ii) loop through all the adjacents to (i, j) i.e. check in 4 directions \\n    //   iii) if(dp[x][y] > grid[x][y] + weight) \\n    //       # here, grid[x][y] is edge\\'s weight from (i,j)-->(x,y) \\n    //       # weight is minimum distance till (i,j)\\n    //       # dist[v] > dist[u] + cost (standard relaxation condition from dijkstra)\\n    //       # dp[x][y] > weight + grid[x][y]\\n    //       a) Update distance of dp[x][y] = grid[x][y] + weight\\n    //       b) If (dp[x][y], x, y) already in set remove them and insert with updated distances\\n    //       c) If (dp[x][y], x, y) not in set, insert it in set \\n    // 4) Finally, return distance of destination that will be minimum i.e dp[n-1][m-1]\\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n       \\n        vector<vector<int>> dp(n, vector<int>(m, INT_MAX));\\n\\n        set<tuple<int,int,int>> st;\\n\\n        st.insert({0,0,0});\\n        dp[0][0] = 0;\\n        \\n        int dx[4] = {0,0,1,-1};\\n        int dy[4] = {1,-1,0,0};\\n        \\n        \\n        while(!st.empty()){\\n            auto tmp = *(st.begin());\\n            st.erase(st.begin());\\n          \\n            int weight = get<0>(tmp);\\n            \\n            for(int k = 0 ; k < 4 ; k++){\\n                int x = dx[k] + get<1>(tmp);\\n                int y = dy[k] + get<2> (tmp);\\n                if(x >= 0 && x < n && y >= 0 && y < m){\\n                    if(dp[x][y] > grid[x][y] + weight){\\n                        if(dp[x][y] != INT_MAX) st.erase({dp[x][y], x, y});\\n                        dp[x][y] = grid[x][y] + weight;\\n                        st.insert({dp[x][y], x, y});\\n                    } \\n                }\\n            }\\n        }\\n        \\n        return dp[n-1][m-1];\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // Approach : Dijkstra\\'s Algorithm ; Implementation Based On Set: STL\\n    // Time Complexity : o(mnlog(mn)) ; Space Complexity : O(mn)\\n    \\n    // Steps :\\n    \\n    // 1) Initialise the distances of all grid elements as INT_MAX in dp array\\n    // 2) Insert source into set where <distance, u, v>\\n    // 3) While set doesn\\'t become empty do,\\n    //   i) extract minimum distance from set, let extracted be (i, j)\\n    //   ii) loop through all the adjacents to (i, j) i.e. check in 4 directions \\n    //   iii) if(dp[x][y] > grid[x][y] + weight) \\n    //       # here, grid[x][y] is edge\\'s weight from (i,j)-->(x,y) \\n    //       # weight is minimum distance till (i,j)\\n    //       # dist[v] > dist[u] + cost (standard relaxation condition from dijkstra)\\n    //       # dp[x][y] > weight + grid[x][y]\\n    //       a) Update distance of dp[x][y] = grid[x][y] + weight\\n    //       b) If (dp[x][y], x, y) already in set remove them and insert with updated distances\\n    //       c) If (dp[x][y], x, y) not in set, insert it in set \\n    // 4) Finally, return distance of destination that will be minimum i.e dp[n-1][m-1]\\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n       \\n        vector<vector<int>> dp(n, vector<int>(m, INT_MAX));\\n\\n        set<tuple<int,int,int>> st;\\n\\n        st.insert({0,0,0});\\n        dp[0][0] = 0;\\n        \\n        int dx[4] = {0,0,1,-1};\\n        int dy[4] = {1,-1,0,0};\\n        \\n        \\n        while(!st.empty()){\\n            auto tmp = *(st.begin());\\n            st.erase(st.begin());\\n          \\n            int weight = get<0>(tmp);\\n            \\n            for(int k = 0 ; k < 4 ; k++){\\n                int x = dx[k] + get<1>(tmp);\\n                int y = dy[k] + get<2> (tmp);\\n                if(x >= 0 && x < n && y >= 0 && y < m){\\n                    if(dp[x][y] > grid[x][y] + weight){\\n                        if(dp[x][y] != INT_MAX) st.erase({dp[x][y], x, y});\\n                        dp[x][y] = grid[x][y] + weight;\\n                        st.insert({dp[x][y], x, y});\\n                    } \\n                }\\n            }\\n        }\\n        \\n        return dp[n-1][m-1];\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2093694,
                "title": "c-solution",
                "content": "```\\nvoid input(int** grid, int gridSize, int gridColSize, int** list, int* count, int i, int j, int now){\\n    if (i < 0 || j < 0 || i >= gridSize || j >= gridColSize || grid[i][j] > 1){\\n        return;\\n    }\\n    if (grid[i][j] == 1){\\n        list[*count][0] = i;\\n        list[*count][1] = j;\\n        *count += 1;\\n        grid[i][j] = now+1;\\n        return;\\n    }\\n    grid[i][j] = now;\\n    input(grid, gridSize, gridColSize, list, count, i+1, j, now);\\n    input(grid, gridSize, gridColSize, list, count, i-1, j, now);\\n    input(grid, gridSize, gridColSize, list, count, i, j+1, now);\\n    input(grid, gridSize, gridColSize, list, count, i, j-1, now);\\n    return;\\n}\\n\\n\\nint minimumObstacles(int** grid, int gridSize, int* gridColSize){\\n    int p = gridSize*(*gridColSize);\\n    int** list = malloc(sizeof(int*)*p);\\n    for (int i = 0 ; i < p ; i++){\\n        list[i] = malloc(sizeof(int)*2);\\n    }\\n    int end = 0;\\n    int count = 0; \\n    int start = 0;\\n    int now = 2;\\n    input(grid, gridSize, *gridColSize, list, &count, 0, 0, now);\\n    while (grid[gridSize-1][*gridColSize-1] == 0){\\n        end = count;\\n        now++;\\n        for ( ; start < end ; start++){\\n            input(grid, gridSize, *gridColSize, list, &count, list[start][0]+1, list[start][1], now);\\n            input(grid, gridSize, *gridColSize, list, &count, list[start][0]-1, list[start][1], now);\\n            input(grid, gridSize, *gridColSize, list, &count, list[start][0], list[start][1]+1, now);\\n            input(grid, gridSize, *gridColSize, list, &count, list[start][0], list[start][1]-1, now);\\n        }\\n    }\\n    int ans = grid[gridSize-1][*gridColSize-1]-2;\\n    for (int i = 0 ; i < p ; i++){\\n        free(list[i]);\\n    }\\n    free(list);\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid input(int** grid, int gridSize, int gridColSize, int** list, int* count, int i, int j, int now){\\n    if (i < 0 || j < 0 || i >= gridSize || j >= gridColSize || grid[i][j] > 1){\\n        return;\\n    }\\n    if (grid[i][j] == 1){\\n        list[*count][0] = i;\\n        list[*count][1] = j;\\n        *count += 1;\\n        grid[i][j] = now+1;\\n        return;\\n    }\\n    grid[i][j] = now;\\n    input(grid, gridSize, gridColSize, list, count, i+1, j, now);\\n    input(grid, gridSize, gridColSize, list, count, i-1, j, now);\\n    input(grid, gridSize, gridColSize, list, count, i, j+1, now);\\n    input(grid, gridSize, gridColSize, list, count, i, j-1, now);\\n    return;\\n}\\n\\n\\nint minimumObstacles(int** grid, int gridSize, int* gridColSize){\\n    int p = gridSize*(*gridColSize);\\n    int** list = malloc(sizeof(int*)*p);\\n    for (int i = 0 ; i < p ; i++){\\n        list[i] = malloc(sizeof(int)*2);\\n    }\\n    int end = 0;\\n    int count = 0; \\n    int start = 0;\\n    int now = 2;\\n    input(grid, gridSize, *gridColSize, list, &count, 0, 0, now);\\n    while (grid[gridSize-1][*gridColSize-1] == 0){\\n        end = count;\\n        now++;\\n        for ( ; start < end ; start++){\\n            input(grid, gridSize, *gridColSize, list, &count, list[start][0]+1, list[start][1], now);\\n            input(grid, gridSize, *gridColSize, list, &count, list[start][0]-1, list[start][1], now);\\n            input(grid, gridSize, *gridColSize, list, &count, list[start][0], list[start][1]+1, now);\\n            input(grid, gridSize, *gridColSize, list, &count, list[start][0], list[start][1]-1, now);\\n        }\\n    }\\n    int ans = grid[gridSize-1][*gridColSize-1]-2;\\n    for (int i = 0 ; i < p ; i++){\\n        free(list[i]);\\n    }\\n    free(list);\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2091038,
                "title": "c-0-1-bfs-dijkstra",
                "content": "```\\n//0-1 BFS\\nclass Solution {\\npublic:\\n    #define vi vector<int>\\n    #define pii pair<int,int>\\n    #define inf 1e9+9\\n    #define f first\\n    #define s second\\n    \\n    int dx[4] = {-1,1,0,0};\\n    int dy[4] = {0,0,1,-1};\\n    vector<vector<pii>> buildGraph(vector<vector<int>>& grid,int n, int m){\\n        vector<vector<pii>> graph(n*m+1);\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int currCell = i*m+j;\\n                \\n                \\n                for(int d=0;d<4;d++){//all direction\\n                    int newR = i+dx[d];\\n                    int newC = j+dy[d];\\n                    \\n                    if(newR>=0 and newR<n and newC >= 0 and newC<m){\\n                        int newCell = newR*m+newC;\\n                        graph[currCell].push_back({newCell,grid[newR][newC]});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return graph;\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<vector<pii>> graph = buildGraph(grid,n,m);\\n        \\n        vi dist(n*m,inf);\\n        deque<int> dq;//curr node and wt\\n        \\n        dq.push_back(0);\\n        dist[0]=0;\\n        \\n        while(!dq.empty()){\\n            \\n            auto curr = dq.front();\\n            dq.pop_front();\\n            \\n            for(auto child: graph[curr]){\\n                int child_v = child.f;\\n                int wt = child.s;\\n                \\n                if(dist[curr]+wt < dist[child_v]){\\n                    dist[child_v] = dist[curr]+wt;\\n                    \\n                    if(wt == 1){\\n                        dq.push_back(child_v);\\n                    }\\n                    else{\\n                        dq.push_front(child_v);\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        \\n        return dist[n*m-1];\\n    }\\n};\\n```\\n\\n\\n```\\n//Dijkstra\\n\\nstruct cmp{\\n    bool operator() (const pair<int,int> &a,const pair<int,int> &b) const  {\\n        return a.second < b.second;\\n    }  \\n};\\n\\n\\nclass Solution {\\npublic:\\n    #define vi vector<int>\\n    #define pii pair<long long,long long>\\n    #define inf 1e9+9\\n    #define f first\\n    #define s second\\n    #define ll long long\\n    \\n    int dx[4] = {-1,1,0,0};\\n    int dy[4] = {0,0,1,-1};\\n    \\n    vector<vector<pii>> buildGraph(vector<vector<int>>& grid,int n, int m){\\n        vector<vector<pii>> graph(n*m+1);\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int currCell = i*m+j;\\n                \\n                \\n                for(int d=0;d<4;d++){//all direction\\n                    int newR = i+dx[d];\\n                    int newC = j+dy[d];\\n                    \\n                    if(newR>=0 and newR<n and newC >= 0 and newC<m){\\n                        int newCell = newR*m+newC;\\n                        graph[currCell].push_back({newCell,grid[newR][newC]});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return graph;\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<vector<pii>> graph = buildGraph(grid,n,m);\\n   \\n        //Dijistras algorithm\\n        \\n        /*\\n        1) build graph\\n        2) multiset(sort according to incraseing order of weight)\\n        3) ms.insert({0,0}) // curr node weight\\n        \\n        */\\n        vi vis(n*m,0);\\n        vi dist(n*m,inf);\\n        multiset<pii , cmp> ms;//node,weight\\n        ms.insert({0,0});\\n        dist[0] = 0;\\n        \\n        while(not ms.empty()){\\n            pii curr_node = *ms.begin();\\n            ms.erase(ms.begin());\\n            int v = curr_node.f;\\n            int dt = curr_node.s;\\n            if(vis[v]){\\n                continue;\\n            }\\n            vis[v] = 1;\\n            for(pii &child: graph[v]){\\n                int child_v = child.f;\\n                int wt = child.s;\\n                \\n                if(dist[v]+wt < dist[child_v]){\\n                    dist[child_v] = dist[v]+wt ;\\n                    ms.insert({child_v,dist[child_v]});\\n                }\\n            }\\n        }\\n        return dist[n*m-1];\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//0-1 BFS\\nclass Solution {\\npublic:\\n    #define vi vector<int>\\n    #define pii pair<int,int>\\n    #define inf 1e9+9\\n    #define f first\\n    #define s second\\n    \\n    int dx[4] = {-1,1,0,0};\\n    int dy[4] = {0,0,1,-1};\\n    vector<vector<pii>> buildGraph(vector<vector<int>>& grid,int n, int m){\\n        vector<vector<pii>> graph(n*m+1);\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int currCell = i*m+j;\\n                \\n                \\n                for(int d=0;d<4;d++){//all direction\\n                    int newR = i+dx[d];\\n                    int newC = j+dy[d];\\n                    \\n                    if(newR>=0 and newR<n and newC >= 0 and newC<m){\\n                        int newCell = newR*m+newC;\\n                        graph[currCell].push_back({newCell,grid[newR][newC]});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return graph;\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<vector<pii>> graph = buildGraph(grid,n,m);\\n        \\n        vi dist(n*m,inf);\\n        deque<int> dq;//curr node and wt\\n        \\n        dq.push_back(0);\\n        dist[0]=0;\\n        \\n        while(!dq.empty()){\\n            \\n            auto curr = dq.front();\\n            dq.pop_front();\\n            \\n            for(auto child: graph[curr]){\\n                int child_v = child.f;\\n                int wt = child.s;\\n                \\n                if(dist[curr]+wt < dist[child_v]){\\n                    dist[child_v] = dist[curr]+wt;\\n                    \\n                    if(wt == 1){\\n                        dq.push_back(child_v);\\n                    }\\n                    else{\\n                        dq.push_front(child_v);\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        \\n        return dist[n*m-1];\\n    }\\n};\\n```\n```\\n//Dijkstra\\n\\nstruct cmp{\\n    bool operator() (const pair<int,int> &a,const pair<int,int> &b) const  {\\n        return a.second < b.second;\\n    }  \\n};\\n\\n\\nclass Solution {\\npublic:\\n    #define vi vector<int>\\n    #define pii pair<long long,long long>\\n    #define inf 1e9+9\\n    #define f first\\n    #define s second\\n    #define ll long long\\n    \\n    int dx[4] = {-1,1,0,0};\\n    int dy[4] = {0,0,1,-1};\\n    \\n    vector<vector<pii>> buildGraph(vector<vector<int>>& grid,int n, int m){\\n        vector<vector<pii>> graph(n*m+1);\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int currCell = i*m+j;\\n                \\n                \\n                for(int d=0;d<4;d++){//all direction\\n                    int newR = i+dx[d];\\n                    int newC = j+dy[d];\\n                    \\n                    if(newR>=0 and newR<n and newC >= 0 and newC<m){\\n                        int newCell = newR*m+newC;\\n                        graph[currCell].push_back({newCell,grid[newR][newC]});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return graph;\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<vector<pii>> graph = buildGraph(grid,n,m);\\n   \\n        //Dijistras algorithm\\n        \\n        /*\\n        1) build graph\\n        2) multiset(sort according to incraseing order of weight)\\n        3) ms.insert({0,0}) // curr node weight\\n        \\n        */\\n        vi vis(n*m,0);\\n        vi dist(n*m,inf);\\n        multiset<pii , cmp> ms;//node,weight\\n        ms.insert({0,0});\\n        dist[0] = 0;\\n        \\n        while(not ms.empty()){\\n            pii curr_node = *ms.begin();\\n            ms.erase(ms.begin());\\n            int v = curr_node.f;\\n            int dt = curr_node.s;\\n            if(vis[v]){\\n                continue;\\n            }\\n            vis[v] = 1;\\n            for(pii &child: graph[v]){\\n                int child_v = child.f;\\n                int wt = child.s;\\n                \\n                if(dist[v]+wt < dist[child_v]){\\n                    dist[child_v] = dist[v]+wt ;\\n                    ms.insert({child_v,dist[child_v]});\\n                }\\n            }\\n        }\\n        return dist[n*m-1];\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089483,
                "title": "c-dijkstra-algorithm-0-1-bfs-both-clean-code",
                "content": "This is my Dijkstra Algo Approach\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        \\n        priority_queue<pair<int, pair<int,int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;\\n        vector<vector<int >> distance(n + 1, vector<int>(m + 1, INT_MAX)), vis(n + 1, vector<int>(m + 1, 0));\\n        pq.push({0, {0, 0}});\\n        distance[0][0] = 0;\\n        \\n        while(!pq.empty()){\\n            pair<int, pair<int, int>> currPath = pq.top();\\n            pq.pop();\\n            \\n            int dis = currPath.first;\\n            int x = currPath.second.first;\\n            int y = currPath.second.second;\\n            if(vis[x][y])\\n                continue;\\n            \\n            vis[x][y] = 1;\\n            int dx[] = {-1, 1, 0, 0};\\n            int dy[] = {0, 0, -1, 1};\\n            \\n            for(int i = 0; i < 4; ++i){\\n                int newx = dx[i] + x, newy = dy[i] + y;\\n                if(newx >= 0 and newy >= 0 and newx < n and newy < m){\\n                    int weight = grid[newx][newy];\\n                    if(dis + weight < distance[newx][newy]){\\n                        distance[newx][newy] = dis + weight;\\n                        \\n                        pq.push({distance[newx][newy], {newx, newy}});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return distance[n - 1][m - 1];\\n    }\\n};\\n```\\n\\nThis is my BFS Approach\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        \\n        vector<vector<int >> dis(n + 1, vector<int>(m + 1, INT_MAX));\\n        queue<pair<int,int >> q;\\n        q.push({0, 0});\\n        \\n        dis[0][0] = 0;\\n        \\n        while(!q.empty()){\\n            pair<int, int> curr = q.front();\\n            q.pop();\\n            \\n            int dx[] = {-1, 1, 0, 0};\\n            int dy[] = {0, 0, -1, 1};\\n            \\n            for(int i = 0; i < 4; ++i){\\n                int newx = dx[i] + curr.first, newy = dy[i] + curr.second;\\n                \\n                if(newx >= 0 and newy >= 0 and newx < n and newy < m){\\n                    int weight = grid[newx][newy];\\n                    int coming = dis[curr.first][curr.second];\\n                    if(coming + weight < dis[newx][newy]){\\n                        dis[newx][newy] = coming + weight;\\n                        q.push({newx, newy});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dis[n - 1][m - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        \\n        priority_queue<pair<int, pair<int,int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;\\n        vector<vector<int >> distance(n + 1, vector<int>(m + 1, INT_MAX)), vis(n + 1, vector<int>(m + 1, 0));\\n        pq.push({0, {0, 0}});\\n        distance[0][0] = 0;\\n        \\n        while(!pq.empty()){\\n            pair<int, pair<int, int>> currPath = pq.top();\\n            pq.pop();\\n            \\n            int dis = currPath.first;\\n            int x = currPath.second.first;\\n            int y = currPath.second.second;\\n            if(vis[x][y])\\n                continue;\\n            \\n            vis[x][y] = 1;\\n            int dx[] = {-1, 1, 0, 0};\\n            int dy[] = {0, 0, -1, 1};\\n            \\n            for(int i = 0; i < 4; ++i){\\n                int newx = dx[i] + x, newy = dy[i] + y;\\n                if(newx >= 0 and newy >= 0 and newx < n and newy < m){\\n                    int weight = grid[newx][newy];\\n                    if(dis + weight < distance[newx][newy]){\\n                        distance[newx][newy] = dis + weight;\\n                        \\n                        pq.push({distance[newx][newy], {newx, newy}});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return distance[n - 1][m - 1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        \\n        vector<vector<int >> dis(n + 1, vector<int>(m + 1, INT_MAX));\\n        queue<pair<int,int >> q;\\n        q.push({0, 0});\\n        \\n        dis[0][0] = 0;\\n        \\n        while(!q.empty()){\\n            pair<int, int> curr = q.front();\\n            q.pop();\\n            \\n            int dx[] = {-1, 1, 0, 0};\\n            int dy[] = {0, 0, -1, 1};\\n            \\n            for(int i = 0; i < 4; ++i){\\n                int newx = dx[i] + curr.first, newy = dy[i] + curr.second;\\n                \\n                if(newx >= 0 and newy >= 0 and newx < n and newy < m){\\n                    int weight = grid[newx][newy];\\n                    int coming = dis[curr.first][curr.second];\\n                    if(coming + weight < dis[newx][newy]){\\n                        dis[newx][newy] = coming + weight;\\n                        q.push({newx, newy});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dis[n - 1][m - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089476,
                "title": "c-easy-to-understand-simple-solution-using-dijkstra-s-algorithm",
                "content": "**Time Complexity O(NlogN)**\\n\\n```\\n//dijkstra\\'s Algorithm\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>> > pq;\\n        vector<pair<int,int>> dir(4);\\n        dir[0]={0,1};\\n        dir[1]={0,-1};\\n        dir[2]={1,0};\\n        dir[3]={-1,0};\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int> > dis(n,vector<int> (m,INT_MAX));\\n        vector<vector<bool> > vis(n,vector<bool> (m,false));\\n        pq.push({0,{0,0}});\\n        dis[0][0]=0;\\n        while(!pq.empty())\\n        {\\n            pair<int,pair<int,int>> ele=pq.top();\\n            pq.pop();\\n            int x,y,cost;\\n            cost=ele.first;\\n            x=ele.second.first;\\n            y=ele.second.second;\\n            vis[x][y]=true;\\n            if(x==n-1&&y==m-1)\\n            return cost;\\n            for(auto pr:dir)\\n            {\\n                int next_x,next_y;\\n                next_x=x+pr.first;\\n                next_y=y+pr.second;\\n                if(next_x>=0&&next_x<n&&next_y>=0&&next_y<m&&cost+grid[next_x][next_y]<dis[next_x][next_y]&&!vis[next_x][next_y])\\n                {\\n                    dis[next_x][next_y]=cost+grid[next_x][next_y];\\n                    pq.push({dis[next_x][next_y],{next_x,next_y}});\\n                }\\n            }\\n        }\\n        return dis[n-1][m-1];\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\n//dijkstra\\'s Algorithm\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>> > pq;\\n        vector<pair<int,int>> dir(4);\\n        dir[0]={0,1};\\n        dir[1]={0,-1};\\n        dir[2]={1,0};\\n        dir[3]={-1,0};\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int> > dis(n,vector<int> (m,INT_MAX));\\n        vector<vector<bool> > vis(n,vector<bool> (m,false));\\n        pq.push({0,{0,0}});\\n        dis[0][0]=0;\\n        while(!pq.empty())\\n        {\\n            pair<int,pair<int,int>> ele=pq.top();\\n            pq.pop();\\n            int x,y,cost;\\n            cost=ele.first;\\n            x=ele.second.first;\\n            y=ele.second.second;\\n            vis[x][y]=true;\\n            if(x==n-1&&y==m-1)\\n            return cost;\\n            for(auto pr:dir)\\n            {\\n                int next_x,next_y;\\n                next_x=x+pr.first;\\n                next_y=y+pr.second;\\n                if(next_x>=0&&next_x<n&&next_y>=0&&next_y<m&&cost+grid[next_x][next_y]<dis[next_x][next_y]&&!vis[next_x][next_y])\\n                {\\n                    dis[next_x][next_y]=cost+grid[next_x][next_y];\\n                    pq.push({dis[next_x][next_y],{next_x,next_y}});\\n                }\\n            }\\n        }\\n        return dis[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2088400,
                "title": "java-dijsktra-s-algo-bfs",
                "content": "```\\nclass Solution {\\n    int[][] dir = new int[][]{{1,0},{0,1},{-1,0},{0,-1}};\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        \\n        for(int i=0;i<m;i++)\\n            Arrays.fill(dp[i], Integer.MAX_VALUE);\\n        \\n        dp[0][0] = 0;\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b)->dp[a[0]][a[1]]-dp[b[0]][b[1]]);\\n        \\n        pq.offer(new int[]{0, 0});\\n        \\n        while(!pq.isEmpty()){\\n            \\n            int[] curr = pq.poll();\\n            \\n            if(curr[0] == m-1 && curr[1] == n-1)\\n                return dp[m-1][n-1];\\n            for(int j=0;j<4;j++){\\n                int x = dir[j][0]+curr[0];\\n                int y = dir[j][1]+curr[1];\\n                \\n                \\n                if(x<0 || y<0 || x >= m || y >= n)\\n                    continue;\\n                \\n                if(dp[x][y] > dp[curr[0]][curr[1]]+grid[curr[0]][curr[1]]){\\n                     dp[x][y] = dp[curr[0]][curr[1]]+grid[curr[0]][curr[1]];\\n                     pq.offer(new int[]{x, y});\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dir = new int[][]{{1,0},{0,1},{-1,0},{0,-1}};\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        \\n        for(int i=0;i<m;i++)\\n            Arrays.fill(dp[i], Integer.MAX_VALUE);\\n        \\n        dp[0][0] = 0;\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b)->dp[a[0]][a[1]]-dp[b[0]][b[1]]);\\n        \\n        pq.offer(new int[]{0, 0});\\n        \\n        while(!pq.isEmpty()){\\n            \\n            int[] curr = pq.poll();\\n            \\n            if(curr[0] == m-1 && curr[1] == n-1)\\n                return dp[m-1][n-1];\\n            for(int j=0;j<4;j++){\\n                int x = dir[j][0]+curr[0];\\n                int y = dir[j][1]+curr[1];\\n                \\n                \\n                if(x<0 || y<0 || x >= m || y >= n)\\n                    continue;\\n                \\n                if(dp[x][y] > dp[curr[0]][curr[1]]+grid[curr[0]][curr[1]]){\\n                     dp[x][y] = dp[curr[0]][curr[1]]+grid[curr[0]][curr[1]];\\n                     pq.offer(new int[]{x, y});\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087864,
                "title": "c-shortes-path-dijkstra-s",
                "content": "\\ttypedef tuple<int,int,int>tp;\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minimumObstacles(vector<vector<int>>& grid) {\\n\\t\\t\\tint n = grid.size(),m = grid[0].size();\\n\\t\\t\\tint dir[4][2] = {{-1,0},{0,-1},{1,0},{0,1}};\\n\\t\\t\\tvector<vector<int>>cost(n,vector<int>(m,INT_MAX));\\n\\t\\t\\tpriority_queue<tp,vector<tp>,greater<tp>>q;\\n\\t\\t\\tq.push({grid[0][0],0,0});\\n\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\tauto [c,x,y] = q.top();q.pop();\\n\\t\\t\\t\\tif(x==n-1 and y==m-1) return c;\\n\\t\\t\\t\\tfor(auto &d:dir){\\n\\t\\t\\t\\t\\tint i = d[0]+x,j = d[1]+y;\\n\\t\\t\\t\\t\\tif(i<0 or j<0 or i==n or j==m) continue;\\n\\t\\t\\t\\t\\tif(cost[i][j]>c+grid[i][j]){\\n\\t\\t\\t\\t\\t\\tcost[i][j] = c+grid[i][j];\\n\\t\\t\\t\\t\\t\\tq.push({c+grid[i][j],i,j});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minimumObstacles(vector<vector<int>>& grid) {\\n\\t\\t\\tint n = grid.size(),m = grid[0].size();\\n\\t\\t\\tint dir[4][2] = {{-1,0}",
                "codeTag": "Java"
            },
            {
                "id": 2087637,
                "title": "python-concise-solution-with-greedy-bfs",
                "content": "Just run a greedy BFS, Starting from cell `(0,0)` , push any unvisited adjacent empty cell to the front of the queue  and the unvisited wall cells to the back of the queue (We prefer paths with the most number of empty cells, pushing empty cells to the front of the queue ensure all the nearby empty cells would be visited first because they all have the same total weight as the current cell , when we have no empty cells that can be visited left, we will move to the nearest wall cells to continue exploring other possible paths.\\n\\n```python\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        from collections import deque \\n        q = deque([(0,0,0)])\\n        n, m = len(grid), len(grid[0])\\n        while q:\\n            i,j,v = q.popleft() \\n            if grid[i][j] != -1:\\n                grid[i][j] = -1\\n                if i == n-1 and j == m-1:\\n                    return v\\n                for (x,y) in (i+1,j),(i,j+1), (i-1, j), (i,j-1):\\n                    if 0 <= x < n and 0 <= y < m :\\n                        if grid[x][y] != -1:\\n                            getattr(q, f\\'append{\"\" if grid[x][y] else \"left\"}\\' )((x,y,v+grid[x][y]))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        from collections import deque \\n        q = deque([(0,0,0)])\\n        n, m = len(grid), len(grid[0])\\n        while q:\\n            i,j,v = q.popleft() \\n            if grid[i][j] != -1:\\n                grid[i][j] = -1\\n                if i == n-1 and j == m-1:\\n                    return v\\n                for (x,y) in (i+1,j),(i,j+1), (i-1, j), (i,j-1):\\n                    if 0 <= x < n and 0 <= y < m :\\n                        if grid[x][y] != -1:\\n                            getattr(q, f\\'append{\"\" if grid[x][y] else \"left\"}\\' )((x,y,v+grid[x][y]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087374,
                "title": "c-dijkstra",
                "content": "Dijkstra algorithm: two 4-connected cells in the grid have an edge of length\\n\\n- `0` if target cell doesn\\'t have an obstacle\\n- `1` if target cell has an obstacle\\n\\n**Code:**\\n\\n```\\npublic class Solution {\\n    \\n    public int MinimumObstacles(int[][] grid) {\\n        PriorityQueue<(int r, int c), int> agenda = new ();\\n        \\n        agenda.Enqueue((0, 0), grid[0][0]);\\n        \\n        Dictionary<(int r, int c), int> visited = new() {\\n            {(0, 0), grid[0][0]},  \\n        };\\n        \\n        while (agenda.Count > 0) {\\n            var node = agenda.Dequeue();\\n            \\n            for (int d = 0; d < 4; ++d) {\\n                int nr = node.r + (d - 1) % 2;\\n                int nc = node.c + (d - 2) % 2;\\n                \\n                if (nr < 0 || nr >= grid.Length || nc < 0 || nc >= grid[nr].Length)\\n                    continue;\\n                \\n                int cost = visited[(node.r, node.c)] + grid[node.r][node.c];\\n                \\n                if (visited.TryGetValue((nr, nc), out int oldCost) && oldCost <= cost)\\n                    continue;\\n                \\n                if (!visited.TryAdd((nr, nc), cost))\\n                    visited[(nr, nc)] = cost;\\n                \\n                agenda.Enqueue((nr, nc), cost);\\n            }\\n        }\\n        \\n        return visited[(grid.Length - 1, grid[grid.Length - 1].Length - 1)];\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    public int MinimumObstacles(int[][] grid) {\\n        PriorityQueue<(int r, int c), int> agenda = new ();\\n        \\n        agenda.Enqueue((0, 0), grid[0][0]);\\n        \\n        Dictionary<(int r, int c), int> visited = new() {\\n            {(0, 0), grid[0][0]},  \\n        };\\n        \\n        while (agenda.Count > 0) {\\n            var node = agenda.Dequeue();\\n            \\n            for (int d = 0; d < 4; ++d) {\\n                int nr = node.r + (d - 1) % 2;\\n                int nc = node.c + (d - 2) % 2;\\n                \\n                if (nr < 0 || nr >= grid.Length || nc < 0 || nc >= grid[nr].Length)\\n                    continue;\\n                \\n                int cost = visited[(node.r, node.c)] + grid[node.r][node.c];\\n                \\n                if (visited.TryGetValue((nr, nc), out int oldCost) && oldCost <= cost)\\n                    continue;\\n                \\n                if (!visited.TryAdd((nr, nc), cost))\\n                    visited[(nr, nc)] = cost;\\n                \\n                agenda.Enqueue((nr, nc), cost);\\n            }\\n        }\\n        \\n        return visited[(grid.Length - 1, grid[grid.Length - 1].Length - 1)];\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087258,
                "title": "c-using-max-heap-t-o-n-m-s-o-n-m",
                "content": "Start from the end (x=m-1, y=n-1) and do the BFS things, but this time, will always pick the minimum block count to go through.\\n\\nUsing the example 1:\\n```\\n| |x|x|\\n|x|x| |\\n|x|x| |\\n```\\nWe will create the dp grid as:\\n```\\n|2|2|1|\\n|2|1|0|\\n|2|1|0|\\n```\\n\\nThe time complexity will be O(m\\\\*n) (assume m = size of x & n = size of y) because we\\'ll always goes to each grid once.\\nThe space complexity will be O(n\\\\*n) because we need dp[x][y] to save minimum count.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        pair<int,int> dirs[4] = {{1,0}, {-1,0}, {0,1}, {0,-1}};\\n        // dp to save each grid\\'s min block count\\n        vector<vector<int>> dp (m, vector<int> (n, -1));\\n        // Min heap with {level, x, y} (level = block count)\\n        priority_queue<tuple<int,int,int>> pq;\\n        pq.push({0, m-1, n-1});\\n        dp[m-1][n-1] = 0;\\n        \\n        while (!pq.empty()) {\\n            // get top from min heap, current level is the minimam\\n            int level = -get<0>(pq.top());\\n            int x = get<1>(pq.top()), y = get<2>(pq.top());\\n            pq.pop();\\n            // 4 directions\\n            for (auto & dir: dirs) {\\n                int next_x = x + dir.first;\\n                int next_y = y + dir.second;\\n                \\n                // check if goes to dp[0][0]\\n                if (next_x == 0 && next_y == 0) return level + grid[next_x][next_y];\\n                \\n                if (next_x < m && next_y < n && next_x >= 0 && next_y >= 0 && dp[next_x][next_y] == -1) {\\n                    // if there is block, add 1 to previous level, else same as previous level\\n                    dp[next_x][next_y] = level + grid[next_x][next_y];\\n                    // priority default as max heap, therefor we negative level to get min heap\\n                    pq.push({-dp[next_x][next_y], next_x, next_y}); \\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n| |x|x|\\n|x|x| |\\n|x|x| |\\n```\n```\\n|2|2|1|\\n|2|1|0|\\n|2|1|0|\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        pair<int,int> dirs[4] = {{1,0}, {-1,0}, {0,1}, {0,-1}};\\n        // dp to save each grid\\'s min block count\\n        vector<vector<int>> dp (m, vector<int> (n, -1));\\n        // Min heap with {level, x, y} (level = block count)\\n        priority_queue<tuple<int,int,int>> pq;\\n        pq.push({0, m-1, n-1});\\n        dp[m-1][n-1] = 0;\\n        \\n        while (!pq.empty()) {\\n            // get top from min heap, current level is the minimam\\n            int level = -get<0>(pq.top());\\n            int x = get<1>(pq.top()), y = get<2>(pq.top());\\n            pq.pop();\\n            // 4 directions\\n            for (auto & dir: dirs) {\\n                int next_x = x + dir.first;\\n                int next_y = y + dir.second;\\n                \\n                // check if goes to dp[0][0]\\n                if (next_x == 0 && next_y == 0) return level + grid[next_x][next_y];\\n                \\n                if (next_x < m && next_y < n && next_x >= 0 && next_y >= 0 && dp[next_x][next_y] == -1) {\\n                    // if there is block, add 1 to previous level, else same as previous level\\n                    dp[next_x][next_y] = level + grid[next_x][next_y];\\n                    // priority default as max heap, therefor we negative level to get min heap\\n                    pq.push({-dp[next_x][next_y], next_x, next_y}); \\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087005,
                "title": "c-simple-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>>v(n,vector<int>(m,INT_MAX));\\n        v[0][0]=0;\\n        queue<pair<int,int>>q;\\n        int dir[][2]={{1,0},{0,1},{-1,0},{0,-1}};\\n        q.push({0,0});\\n        while(!q.empty())\\n        {\\n            auto [x,y]=q.front();\\n            q.pop();\\n            for(int i=0;i<4;i++)\\n            {\\n                int r=x+dir[i][0],c=y+dir[i][1];\\n                if(r<0 || c<0 || r>=n || c>=m || v[x][y]+grid[r][c]>=v[r][c])\\n                {\\n                    continue;\\n                }\\n                v[r][c]=v[x][y]+grid[r][c];\\n                q.push({r,c});\\n            }\\n        }\\n        return v[n-1][m-1];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>>v(n,vector<int>(m,INT_MAX));\\n        v[0][0]=0;\\n        queue<pair<int,int>>q;\\n        int dir[][2]={{1,0}",
                "codeTag": "Java"
            },
            {
                "id": 2086685,
                "title": "please-help-me-find-the-tle-issue-in-my-code",
                "content": "I am getting TLE in my code, anyone kindly help.\\n\\n```\\nclass Solution {\\npublic:\\n    set<pair<int, int>> visited;\\n    vector<int> dirs = {1, 0, -1, 0, 1};\\n    \\n   \\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid[0].size();\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> q;\\n        q.push({0, 0, 0});\\n        int res = m*n;\\n        visited.insert({0, 0});\\n        while(!q.empty()){\\n            int u  =q.top()[1];\\n            int v = q.top()[2];\\n            int val = q.top()[0];\\n            q.pop();\\n            for (int i = 0; i<4; i++){\\n                int nu = u+dirs[i], nv = v+dirs[i+1];\\n                if (nu>=0 and nu<m and nv>=0 and nv<n and visited.find({nu, nv})==visited.end()){\\n                    if (nu == m-1 and nv == n-1){\\n                        res = min(res, val+grid[nu][nv]);\\n                        continue;\\n                    }\\n                    visited.insert({nu, nv});\\n                    q.push({val+grid[nu][nv], nu, nv});\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    set<pair<int, int>> visited;\\n    vector<int> dirs = {1, 0, -1, 0, 1};\\n    \\n   \\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid[0].size();\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> q;\\n        q.push({0, 0, 0});\\n        int res = m*n;\\n        visited.insert({0, 0});\\n        while(!q.empty()){\\n            int u  =q.top()[1];\\n            int v = q.top()[2];\\n            int val = q.top()[0];\\n            q.pop();\\n            for (int i = 0; i<4; i++){\\n                int nu = u+dirs[i], nv = v+dirs[i+1];\\n                if (nu>=0 and nu<m and nv>=0 and nv<n and visited.find({nu, nv})==visited.end()){\\n                    if (nu == m-1 and nv == n-1){\\n                        res = min(res, val+grid[nu][nv]);\\n                        continue;\\n                    }\\n                    visited.insert({nu, nv});\\n                    q.push({val+grid[nu][nv], nu, nv});\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086214,
                "title": "javascript-simple-bfs-with-updating-distance",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar minimumObstacles = function(grid) {\\n    let dx=[[0,1],[0,-1],[1,0],[-1,0]];\\n    let distance=[];\\n    for(let i=0;i<grid.length;i++){\\n        distance[i]=[];\\n        for(let j=0;j<grid[i].length;j++){\\n            distance[i][j]=Number.MAX_SAFE_INTEGER;\\n        }\\n    }\\n    return bfs(0,0);\\n    \\n    function bfs(row,col){\\n        let queue=[];\\n        distance[row][col]=0;\\n        queue.push([row,col]);\\n        while(queue.length>0){\\n            let element = queue.shift();\\n            let row = element[0];\\n            let col = element[1];\\n            let originalDist = distance[row][col];\\n            for(let d=0;d<dx.length;d++){\\n                let i = row + dx[d][0];\\n                let j = col + dx[d][1];\\n                if(i>=0 && i<=grid.length-1 && j>=0 && j<=grid[i].length-1){\\n                    let dist = originalDist;\\n                    if(grid[i][j]===1){\\n                        dist++;\\n                    }\\n                    if(distance[i][j]>dist){//Update distance for this neighbour node if the new distance is smaller than the previous distance\\n                        queue.push([i,j]);\\n                        distance[i][j]=dist;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        //return the minimum distance for last cell after completing the process\\n        return distance[(grid.length-1)][(grid[row].length-1)];\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar minimumObstacles = function(grid) {\\n    let dx=[[0,1],[0,-1],[1,0],[-1,0]];\\n    let distance=[];\\n    for(let i=0;i<grid.length;i++){\\n        distance[i]=[];\\n        for(let j=0;j<grid[i].length;j++){\\n            distance[i][j]=Number.MAX_SAFE_INTEGER;\\n        }\\n    }\\n    return bfs(0,0);\\n    \\n    function bfs(row,col){\\n        let queue=[];\\n        distance[row][col]=0;\\n        queue.push([row,col]);\\n        while(queue.length>0){\\n            let element = queue.shift();\\n            let row = element[0];\\n            let col = element[1];\\n            let originalDist = distance[row][col];\\n            for(let d=0;d<dx.length;d++){\\n                let i = row + dx[d][0];\\n                let j = col + dx[d][1];\\n                if(i>=0 && i<=grid.length-1 && j>=0 && j<=grid[i].length-1){\\n                    let dist = originalDist;\\n                    if(grid[i][j]===1){\\n                        dist++;\\n                    }\\n                    if(distance[i][j]>dist){//Update distance for this neighbour node if the new distance is smaller than the previous distance\\n                        queue.push([i,j]);\\n                        distance[i][j]=dist;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        //return the minimum distance for last cell after completing the process\\n        return distance[(grid.length-1)][(grid[row].length-1)];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2086179,
                "title": "python-heap-bfs-solution",
                "content": "so the Algorithm will run like :  to  reach (i,j)th position of array, how much obstacles needs to be cleared\\n\\nalgorithm steps:\\n1. find next node which is unvisited with the lowest cost (used heap for searching)\\n2. if node is destination: return the cost\\n3. else: add children of that node into the heap\\n\\nTime Complexity : O(n^2)\\nSpace Complexity: O(n^2)\\n\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        m = len(grid[0])\\n        \\n        visited = [[False]*m for _ in range(n)]\\n        \\n        paths = [ (0,-1),(-1,0),(0,1),(1,0)]\\n        \\n        queue = [(0,0,0)]  #val, x,y will be pushed\\n\\n        while queue:\\n            val,i,j = heappop(queue)\\n            if i == n-1 and j==m-1:\\n                return val + grid[i][j]\\n\\n            for x,y in paths:\\n                x1 = i+x\\n                y1 = j+y\\n                \\n                if (x1>=0 and x1<n and y1>=0 and y1<m and not visited[x1][y1]):\\n                    visited[x1][y1] = True\\n                    heappush(queue, (val + grid[x1][y1], x1, y1))\\n                    \\n        return -1\\n```\\n\\nin case of any clarification please add comment\\nupvode if you like it..",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        m = len(grid[0])\\n        \\n        visited = [[False]*m for _ in range(n)]\\n        \\n        paths = [ (0,-1),(-1,0),(0,1),(1,0)]\\n        \\n        queue = [(0,0,0)]  #val, x,y will be pushed\\n\\n        while queue:\\n            val,i,j = heappop(queue)\\n            if i == n-1 and j==m-1:\\n                return val + grid[i][j]\\n\\n            for x,y in paths:\\n                x1 = i+x\\n                y1 = j+y\\n                \\n                if (x1>=0 and x1<n and y1>=0 and y1<m and not visited[x1][y1]):\\n                    visited[x1][y1] = True\\n                    heappush(queue, (val + grid[x1][y1], x1, y1))\\n                    \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085965,
                "title": "simple-bfs",
                "content": "I missed one line in the contest and got an TLE, but figured it out after the contest. :(\\n\\nThe idea is to find the \\'layer\\' in each step and process them in **q**. For the cells in the neighborhood of the cell from current layer (whose grid[i][j] == 1), we store them in **p**. The first layer is the connected component of (0, 0) with all grid[i][j] == 0. After processing one layer, we increase count by 1 meaning that we remove an obstacle.\\n\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        visited = [[True] * n for _ in  range(m)]\\n        visited[0][0] = False\\n        q = deque([(0, 0)])\\n        count = 0\\n        while True:\\n            p = deque([])\\n            while q:\\n                i, j = q.popleft()\\n                if i == m - 1 and j == n - 1:\\n                    return count\\n                for di, dj in [(i-1,j), (i+1,j), (i,j-1), (i,j+1)]:\\n                    if 0 <= di < m and 0 <= dj < n and visited[di][dj]:\\n                        visited[di][dj] = False\\n                        if grid[di][dj] == 0:\\n                            q.append((di, dj))\\n                        else:\\n                            p.append((di, dj))\\n            q = p\\n            count += 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        visited = [[True] * n for _ in  range(m)]\\n        visited[0][0] = False\\n        q = deque([(0, 0)])\\n        count = 0\\n        while True:\\n            p = deque([])\\n            while q:\\n                i, j = q.popleft()\\n                if i == m - 1 and j == n - 1:\\n                    return count\\n                for di, dj in [(i-1,j), (i+1,j), (i,j-1), (i,j+1)]:\\n                    if 0 <= di < m and 0 <= dj < n and visited[di][dj]:\\n                        visited[di][dj] = False\\n                        if grid[di][dj] == 0:\\n                            q.append((di, dj))\\n                        else:\\n                            p.append((di, dj))\\n            q = p\\n            count += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085951,
                "title": "ordered-bfs-python-o-m-n-time-and-space-commented",
                "content": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        noOfObstaclesToReach = [[-1]*n for _ in range(m)]   # s: O(m*n)\\n\\t\\tnoOfObstaclesToReach[0][0] = grid[0][0]\\n        nodeQueue = deque([(0,0)])                          # s: O(m*n)\\n        directions = [0,1,0,-1,0]\\n        \\n        while len(nodeQueue) > 0 and noOfObstaclesToReach[m-1][n-1] == -1:\\n            currNodeX, currNodeY = nodeQueue.popleft()      # each node gets in and out atmost once - O(m*n)\\n            for i in range(4):                              # O(1)\\n                neighborX, neighborY = currNodeX + directions[i], currNodeY + directions[i+1]\\n                if 0 <= neighborX < m and 0 <= neighborY < n and noOfObstaclesToReach[neighborX][neighborY] == -1:    # unvisited valid nodes\\n                    if grid[neighborX][neighborY] == 0:                # node without obstacle added to the beginning\\n                        noOfObstaclesToReach[neighborX][neighborY] = noOfObstaclesToReach[currNodeX][currNodeY]\\n                        nodeQueue.appendleft((neighborX, neighborY))\\n                    else:                                              # node with obstacle added to the end\\n                        noOfObstaclesToReach[neighborX][neighborY] = noOfObstaclesToReach[currNodeX][currNodeY] + 1\\n                        nodeQueue.append((neighborX, neighborY))\\n        return noOfObstaclesToReach[m-1][n-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        noOfObstaclesToReach = [[-1]*n for _ in range(m)]   # s: O(m*n)\\n\\t\\tnoOfObstaclesToReach[0][0] = grid[0][0]\\n        nodeQueue = deque([(0,0)])                          # s: O(m*n)\\n        directions = [0,1,0,-1,0]\\n        \\n        while len(nodeQueue) > 0 and noOfObstaclesToReach[m-1][n-1] == -1:\\n            currNodeX, currNodeY = nodeQueue.popleft()      # each node gets in and out atmost once - O(m*n)\\n            for i in range(4):                              # O(1)\\n                neighborX, neighborY = currNodeX + directions[i], currNodeY + directions[i+1]\\n                if 0 <= neighborX < m and 0 <= neighborY < n and noOfObstaclesToReach[neighborX][neighborY] == -1:    # unvisited valid nodes\\n                    if grid[neighborX][neighborY] == 0:                # node without obstacle added to the beginning\\n                        noOfObstaclesToReach[neighborX][neighborY] = noOfObstaclesToReach[currNodeX][currNodeY]\\n                        nodeQueue.appendleft((neighborX, neighborY))\\n                    else:                                              # node with obstacle added to the end\\n                        noOfObstaclesToReach[neighborX][neighborY] = noOfObstaclesToReach[currNodeX][currNodeY] + 1\\n                        nodeQueue.append((neighborX, neighborY))\\n        return noOfObstaclesToReach[m-1][n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085897,
                "title": "c-bfs-without-priority-queue-o-n-m",
                "content": "Instead of having a priority queue we can make an array of vector and then we will start from 0. Here the index of vector array denotes the steps required to reach last cell. We will increment the index from position 0 which means we will move only when all the cells reachable in 0 steps are processed. \\nIn this way we can remove the use of priority queue.\\n```\\n#pragma GCC optimize(\"O3,unroll-loops\")\\n#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\\nclass Solution\\n{\\npublic:\\n    int n, m;\\n    bool valid(int i, int j)\\n    {\\n        if (i >= 0 && i < n && j >= 0 && j < m)\\n            return true;\\n        return false;\\n    }\\n    int minimumObstacles(vector<vector<int>> &g)\\n    {\\n        n = g.size(), m = g[0].size();\\n        int dp[n][m];\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < m; j++)\\n                dp[i][j] = INT_MAX;\\n        dp[n - 1][m - 1] = 0;\\n        int ind = 0;\\n        vector<vector<int>> v[100005];\\n        v[0].push_back({n - 1, m - 1});\\n        while (1)\\n        {\\n            if (v[ind].size() == 0)\\n                ind++;\\n            if (v[ind].size() == 0)\\n                break;\\n            vector<int> x = v[ind].back();\\n            v[ind].pop_back();\\n            int i = x[0] - 1, j = x[1];\\n            if (valid(i, j) && dp[i][j] > dp[x[0]][x[1]] + g[i][j])\\n            {\\n                dp[i][j] = dp[x[0]][x[1]] + g[i][j];\\n                v[dp[i][j]].push_back({i, j});\\n            }\\n            i = x[0] + 1, j = x[1];\\n            if (valid(i, j) && dp[i][j] > dp[x[0]][x[1]] + g[i][j])\\n            {\\n                dp[i][j] = dp[x[0]][x[1]] + g[i][j];\\n                v[dp[i][j]].push_back({i, j});\\n            }\\n            i = x[0], j = x[1] - 1;\\n            if (valid(i, j) && dp[i][j] > dp[x[0]][x[1]] + g[i][j])\\n            {\\n                dp[i][j] = dp[x[0]][x[1]] + g[i][j];\\n                v[dp[i][j]].push_back({i, j});\\n            }\\n            i = x[0], j = x[1] + 1;\\n            if (valid(i, j) && dp[i][j] > dp[x[0]][x[1]] + g[i][j])\\n            {\\n                dp[i][j] = dp[x[0]][x[1]] + g[i][j];\\n                v[dp[i][j]].push_back({i, j});\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n#pragma GCC optimize(\"O3,unroll-loops\")\\n#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\\nclass Solution\\n{\\npublic:\\n    int n, m;\\n    bool valid(int i, int j)\\n    {\\n        if (i >= 0 && i < n && j >= 0 && j < m)\\n            return true;\\n        return false;\\n    }\\n    int minimumObstacles(vector<vector<int>> &g)\\n    {\\n        n = g.size(), m = g[0].size();\\n        int dp[n][m];\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < m; j++)\\n                dp[i][j] = INT_MAX;\\n        dp[n - 1][m - 1] = 0;\\n        int ind = 0;\\n        vector<vector<int>> v[100005];\\n        v[0].push_back({n - 1, m - 1});\\n        while (1)\\n        {\\n            if (v[ind].size() == 0)\\n                ind++;\\n            if (v[ind].size() == 0)\\n                break;\\n            vector<int> x = v[ind].back();\\n            v[ind].pop_back();\\n            int i = x[0] - 1, j = x[1];\\n            if (valid(i, j) && dp[i][j] > dp[x[0]][x[1]] + g[i][j])\\n            {\\n                dp[i][j] = dp[x[0]][x[1]] + g[i][j];\\n                v[dp[i][j]].push_back({i, j});\\n            }\\n            i = x[0] + 1, j = x[1];\\n            if (valid(i, j) && dp[i][j] > dp[x[0]][x[1]] + g[i][j])\\n            {\\n                dp[i][j] = dp[x[0]][x[1]] + g[i][j];\\n                v[dp[i][j]].push_back({i, j});\\n            }\\n            i = x[0], j = x[1] - 1;\\n            if (valid(i, j) && dp[i][j] > dp[x[0]][x[1]] + g[i][j])\\n            {\\n                dp[i][j] = dp[x[0]][x[1]] + g[i][j];\\n                v[dp[i][j]].push_back({i, j});\\n            }\\n            i = x[0], j = x[1] + 1;\\n            if (valid(i, j) && dp[i][j] > dp[x[0]][x[1]] + g[i][j])\\n            {\\n                dp[i][j] = dp[x[0]][x[1]] + g[i][j];\\n                v[dp[i][j]].push_back({i, j});\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085714,
                "title": "c-o-n-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& a) {\\n        int n = a.size();\\n        int m = a[0].size();\\n        deque <array<int, 3>> Q;\\n        int vis[n][m];\\n        memset(vis, -1, sizeof vis);\\n        Q.push_back({0, 0, 0});\\n        vis[0][0] = 0;\\n        const int dx[] = {1, -1, 0, 0};\\n        const int dy[] = {0, 0, 1, -1};\\n        auto inside = [&](int x, int y) {\\n          return x >= 0 and x < n and y >=0 and y < m;\\n        };\\n        while (!Q.empty()) {\\n          auto [x, y, d] = Q.front();\\n          Q.pop_front();\\n          for (int i = 0; i < 4; ++i) {\\n            int xx = x + dx[i];\\n            int yy = y + dy[i];\\n            if (inside(xx, yy) and vis[xx][yy] == -1) {\\n              if (a[xx][yy]) {\\n                vis[xx][yy] = vis[x][y] + 1;\\n                Q.push_back({xx, yy, 1});\\n              } else {\\n                vis[xx][yy] = vis[x][y];\\n                Q.push_front({xx, yy, 0});\\n              }\\n            }\\n          }\\n        }\\n        return vis[n - 1][m - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& a) {\\n        int n = a.size();\\n        int m = a[0].size();\\n        deque <array<int, 3>> Q;\\n        int vis[n][m];\\n        memset(vis, -1, sizeof vis);\\n        Q.push_back({0, 0, 0});\\n        vis[0][0] = 0;\\n        const int dx[] = {1, -1, 0, 0};\\n        const int dy[] = {0, 0, 1, -1};\\n        auto inside = [&](int x, int y) {\\n          return x >= 0 and x < n and y >=0 and y < m;\\n        };\\n        while (!Q.empty()) {\\n          auto [x, y, d] = Q.front();\\n          Q.pop_front();\\n          for (int i = 0; i < 4; ++i) {\\n            int xx = x + dx[i];\\n            int yy = y + dy[i];\\n            if (inside(xx, yy) and vis[xx][yy] == -1) {\\n              if (a[xx][yy]) {\\n                vis[xx][yy] = vis[x][y] + 1;\\n                Q.push_back({xx, yy, 1});\\n              } else {\\n                vis[xx][yy] = vis[x][y];\\n                Q.push_front({xx, yy, 0});\\n              }\\n            }\\n          }\\n        }\\n        return vis[n - 1][m - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085676,
                "title": "java-dijkstra",
                "content": "```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {\\n            return a[2] - b[2];\\n        });\\n        int[][] dirs = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        pq.add(new int[]{0, 0, 0});\\n        while (pq.size() != 0) {\\n            int[] rem = pq.remove();\\n            if (rem[0] == grid.length - 1 && rem[1] == grid[0].length - 1) {\\n                return rem[2];\\n            }\\n            for (int[] dir : dirs) {\\n                int nr = rem[0] + dir[0];\\n                int nc = rem[1] + dir[1];\\n                if (nr >= 0 && nc >= 0 && nr < grid.length && nc < grid[0].length && !visited[nr][nc]) {\\n                    visited[nr][nc] = true;\\n                    pq.add(new int[]{nr, nc, rem[2] + grid[nr][nc]});\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {\\n            return a[2] - b[2];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2085648,
                "title": "python-use-heap-to-find-the-next-step",
                "content": "This question is similar to [1293. Shortest Path in a Grid with Obstacles Elimination](https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/)\\n\\nQuestion 1293 is to find the shortest path. We use BFS, and FIFO queue can help us find the next step is the step with shortest path.\\n\\nFor this question, we need to find the path with minimal obstacles removal. We can use heap to find the next step with smallest k, while k means the number of obstacle we have removed. For search itself, we can copy the BFS function with a visited set to make sure we wont visit same place twice. \\n\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        heap = list()\\n        heapq.heappush(heap, (0, 0, 0))\\n        visited = set()\\n        visited.add((0,0))\\n        \\n        while len(heap) > 0:\\n            k, i, j = heapq.heappop(heap)\\n            if i == m-1 and j == n-1:\\n                return k\\n            for di,dj in [(-1,0), (1,0), (0,-1), (0,1)]:\\n                i1 = i + di\\n                j1 = j + dj\\n                if 0 <= i1 < m and 0<= j1 < n:\\n                    if (i1,j1) not in visited:\\n                        visited.add((i1,j1))\\n                        heapq.heappush(heap, (k+grid[i1][j1], i1, j1))\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        heap = list()\\n        heapq.heappush(heap, (0, 0, 0))\\n        visited = set()\\n        visited.add((0,0))\\n        \\n        while len(heap) > 0:\\n            k, i, j = heapq.heappop(heap)\\n            if i == m-1 and j == n-1:\\n                return k\\n            for di,dj in [(-1,0), (1,0), (0,-1), (0,1)]:\\n                i1 = i + di\\n                j1 = j + dj\\n                if 0 <= i1 < m and 0<= j1 < n:\\n                    if (i1,j1) not in visited:\\n                        visited.add((i1,j1))\\n                        heapq.heappush(heap, (k+grid[i1][j1], i1, j1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088485,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//use abbreviations when needed\\n#define pii pair<int,pair<int,int>>\\n\\nclass Solution \\n{\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) \\n    {\\n        //directions(top,right,bottom,left)\\n        //eases the task of traversing adjacent cells\\n        int dx[4]={0,1,0,-1};\\n        int dy[4]={-1,0,1,0};\\n\\n        int m,n;\\n        m=grid.size();\\n        n=grid[0].size();\\n        \\n        priority_queue<pii,vector<pii>,greater<pii>> pq;\\n        vector<vector<int>> dis(m,vector<int>(n,INT_MAX));\\n\\n        pq.push({0,{0,0}});\\n        dis[0][0]=0;\\n\\n        while(!pq.empty())\\n        {\\n            //d for distance and c for coordinates\\n            auto [d,c]=pq.top();\\n            pq.pop();\\n\\n            if(c.first==m-1 && c.second==n-1)\\n            {\\n                return d;\\n            }\\n\\n            for(int i=0;i<4;i++)\\n            {\\n                int x=c.first+dx[i];\\n                int y=c.second+dy[i];\\n\\n                if(x<0 || x>=m || y<0 || y>=n)\\n                {\\n                    continue;\\n                }\\n\\n                int currd=d+grid[x][y];\\n\\n                if(currd<dis[x][y])\\n                {\\n                    dis[x][y]=currd;\\n                    pq.push({currd,{x,y}});\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//use abbreviations when needed\\n#define pii pair<int,pair<int,int>>\\n\\nclass Solution \\n{\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) \\n    {\\n        //directions(top,right,bottom,left)\\n        //eases the task of traversing adjacent cells\\n        int dx[4]={0,1,0,-1};\\n        int dy[4]={-1,0,1,0};\\n\\n        int m,n;\\n        m=grid.size();\\n        n=grid[0].size();\\n        \\n        priority_queue<pii,vector<pii>,greater<pii>> pq;\\n        vector<vector<int>> dis(m,vector<int>(n,INT_MAX));\\n\\n        pq.push({0,{0,0}});\\n        dis[0][0]=0;\\n\\n        while(!pq.empty())\\n        {\\n            //d for distance and c for coordinates\\n            auto [d,c]=pq.top();\\n            pq.pop();\\n\\n            if(c.first==m-1 && c.second==n-1)\\n            {\\n                return d;\\n            }\\n\\n            for(int i=0;i<4;i++)\\n            {\\n                int x=c.first+dx[i];\\n                int y=c.second+dy[i];\\n\\n                if(x<0 || x>=m || y<0 || y>=n)\\n                {\\n                    continue;\\n                }\\n\\n                int currd=d+grid[x][y];\\n\\n                if(currd<dis[x][y])\\n                {\\n                    dis[x][y]=currd;\\n                    pq.push({currd,{x,y}});\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066270,
                "title": "0-1-bfs-typical-example-great-learning-opportunity-python-deque-beats-86",
                "content": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        dq = collections.deque([(0,0,0)])\\n        R  = len(grid)\\n        C  = len(grid[0])\\n        visited = set([(0,0)])\\n        dirs = [(1,0),(0,1),(0,-1),(-1,0)]\\n        \\n        while dq:\\n            r,c,obs = dq.popleft()\\n            if r == R-1 and c == C-1:\\n                return obs\\n            for d in dirs:\\n                dr,dc = d\\n                nr,nc = r+dr,c+dc\\n                \\n                if 0<=nr<R and 0<=nc<C and (nr,nc) not in visited:\\n                    visited.add((nr,nc))\\n                    if grid[nr][nc] == 1:\\n                        dq.append((nr,nc,obs+1))\\n                    else:\\n                        dq.appendleft((nr,nc,obs))",
                "solutionTags": [
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        dq = collections.deque([(0,0,0)])\\n        R  = len(grid)\\n        C  = len(grid[0])\\n        visited = set([(0,0)])\\n        dirs = [(1,0),(0,1),(0,-1),(-1,0)]\\n        \\n        while dq:\\n            r,c,obs = dq.popleft()\\n            if r == R-1 and c == C-1:\\n                return obs\\n            for d in dirs:\\n                dr,dc = d\\n                nr,nc = r+dr,c+dc\\n                \\n                if 0<=nr<R and 0<=nc<C and (nr,nc) not in visited:\\n                    visited.add((nr,nc))\\n                    if grid[nr][nc] == 1:\\n                        dq.append((nr,nc,obs+1))\\n                    else:\\n                        dq.appendleft((nr,nc,obs))",
                "codeTag": "Java"
            },
            {
                "id": 4060368,
                "title": "c-dijkstra-algo-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dist(n,vector<int>(m,1e9));\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,\\n        greater<pair<int,pair<int,int>>>> pq;\\n        pq.push({0,{0,0}});\\n        dist[0][0]=0;\\n        int dr[4]={-1,0,1,0};\\n        int dc[4]={0,1,0,-1};\\n        while(!pq.empty()){\\n            auto it=pq.top();\\n            int cost=it.first;\\n            int r=it.second.first;\\n            int c=it.second.second;\\n            pq.pop();\\n            for(int i=0;i<4;i++){\\n                int nr=r+dr[i];\\n                int nc=c+dc[i];\\n                if(nr>=0 && nr<n && nc>=0 && nc<m){\\n                    int cst=grid[nr][nc];\\n                    if(cost+cst<dist[nr][nc]){\\n                        dist[nr][nc]=cost+cst;\\n                        pq.push({dist[nr][nc],{nr,nc}});\\n                    }\\n                }\\n            }\\n        }\\n        return dist[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dist(n,vector<int>(m,1e9));\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,\\n        greater<pair<int,pair<int,int>>>> pq;\\n        pq.push({0,{0,0}});\\n        dist[0][0]=0;\\n        int dr[4]={-1,0,1,0};\\n        int dc[4]={0,1,0,-1};\\n        while(!pq.empty()){\\n            auto it=pq.top();\\n            int cost=it.first;\\n            int r=it.second.first;\\n            int c=it.second.second;\\n            pq.pop();\\n            for(int i=0;i<4;i++){\\n                int nr=r+dr[i];\\n                int nc=c+dc[i];\\n                if(nr>=0 && nr<n && nc>=0 && nc<m){\\n                    int cst=grid[nr][nc];\\n                    if(cost+cst<dist[nr][nc]){\\n                        dist[nr][nc]=cost+cst;\\n                        pq.push({dist[nr][nc],{nr,nc}});\\n                    }\\n                }\\n            }\\n        }\\n        return dist[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055534,
                "title": "bfs-deque-cpp-explained",
                "content": "# Intuition\\nThe goal of this problem is for us to travel from the cell (0,0) in the matrix to cell (n-1,m-1) n=number of rows m=number of columns and we have to choose such path where we need to remove either 0 or the minimum breakers that some cell might have.\\n\\n# Approach\\nThe approach that comes to mind seeing this grid problem is of dynamic programming but having tried that and getting WA gave an intuition  that we cannot assume that a path that is optimal for now will remain optimal for the rest of the traversal.\\n\\nSo the problems that led to take a deque instead of queue as the data structure of choice was we have to take both an empty cell and a cell with blockers because maybe the cell that is empty is trying to trick us and when we go further inside the matrix we might see we had one blocker to remove above if we haven\\'t chosen the empty cell now we have 3.\\n\\nSo we need to add both empty cell and blocker cell now there is a matter of preference that we should consider too.\\nWe have to take the empty cell whenever necessary if it doesn\\'t provide the optimal answer go for the blocker.\\nThus the birth of deque.\\n\\nNow take another matrix that will store the answer of every path we are going to traverse and give us the answer at the cell (n-1)(m-1).\\n\\nWhile using bfs we see whenever we find a empty cell we push it in front and blocker at the back.\\nGo on traversing till the deque is not empty.\\n\\n# Complexity\\n- Time complexity:\\nO((n*m)log(n*m));\\n\\n- Space complexity:O(n*m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n       vector<pair<int,int>> directions={{-1,0},{1,0},{0,1},{0,-1}};\\n       int n=grid.size();\\n       int m=grid[0].size();\\n      vector<vector<int>> dp(n,vector<int>(m,INT_MAX));\\n      vector<vector<int>> visited(n,vector<int>(m,0));\\n      deque<pair<int,int>> q;\\n      q.push_front({0,0});\\n      visited[0][0]=1;\\n      dp[0][0]=0;\\n      while(!q.empty()){\\n        auto curr=q.front();\\n        q.pop_front();\\n        for(auto direct:directions){\\n          int rrow=curr.first+direct.first;\\n          int ccol=curr.second+direct.second;\\n          if(rrow>=0 and rrow<n and ccol>=0 and ccol<m){\\n            if(!visited[rrow][ccol]){\\n              visited[rrow][ccol]=1;\\n              dp[rrow][ccol]=dp[curr.first][curr.second]+(grid[rrow][ccol]==1);\\n              if(grid[rrow][ccol]==1){\\n                q.push_back({rrow,ccol});\\n              }else q.push_front({rrow,ccol});\\n            }\\n          }\\n        }\\n      }\\n      return dp[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n       vector<pair<int,int>> directions={{-1,0},{1,0},{0,1},{0,-1}};\\n       int n=grid.size();\\n       int m=grid[0].size();\\n      vector<vector<int>> dp(n,vector<int>(m,INT_MAX));\\n      vector<vector<int>> visited(n,vector<int>(m,0));\\n      deque<pair<int,int>> q;\\n      q.push_front({0,0});\\n      visited[0][0]=1;\\n      dp[0][0]=0;\\n      while(!q.empty()){\\n        auto curr=q.front();\\n        q.pop_front();\\n        for(auto direct:directions){\\n          int rrow=curr.first+direct.first;\\n          int ccol=curr.second+direct.second;\\n          if(rrow>=0 and rrow<n and ccol>=0 and ccol<m){\\n            if(!visited[rrow][ccol]){\\n              visited[rrow][ccol]=1;\\n              dp[rrow][ccol]=dp[curr.first][curr.second]+(grid[rrow][ccol]==1);\\n              if(grid[rrow][ccol]==1){\\n                q.push_back({rrow,ccol});\\n              }else q.push_front({rrow,ccol});\\n            }\\n          }\\n        }\\n      }\\n      return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033903,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int dx[4] = {0,1,0,-1};\\n        int dy[4] = {1,0,-1,0};\\n        vector<vector<int>> obs(n, vector<int>(m, INT_MAX));\\n        \\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        obs[0][0] = 0;\\n        \\n        while(!q.empty()){\\n            int x = q.front().first, y = q.front().second;\\n            q.pop();\\n            \\n            for(int i=0; i<4; ++i){\\n                int x1 = x+dx[i], y1 = y+dy[i];\\n                if(x1<0 || x1>=n || y1<0 || y1>=m) continue;\\n                int blocks = obs[x][y] + grid[x1][y1];\\n                if(blocks >= obs[x1][y1]) continue;\\n                \\n                obs[x1][y1] = blocks;\\n                q.push({x1,y1});\\n            }\\n        }\\n        return obs[n-1][m-1];\\n    }\\n};\\n```\\nplease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int dx[4] = {0,1,0,-1};\\n        int dy[4] = {1,0,-1,0};\\n        vector<vector<int>> obs(n, vector<int>(m, INT_MAX));\\n        \\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        obs[0][0] = 0;\\n        \\n        while(!q.empty()){\\n            int x = q.front().first, y = q.front().second;\\n            q.pop();\\n            \\n            for(int i=0; i<4; ++i){\\n                int x1 = x+dx[i], y1 = y+dy[i];\\n                if(x1<0 || x1>=n || y1<0 || y1>=m) continue;\\n                int blocks = obs[x][y] + grid[x1][y1];\\n                if(blocks >= obs[x1][y1]) continue;\\n                \\n                obs[x1][y1] = blocks;\\n                q.push({x1,y1});\\n            }\\n        }\\n        return obs[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005542,
                "title": "easy-to-understand-python-solution-using-heap",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n*m*log(n*m))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n\\n        heap = [(0,0,0)]\\n\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        \\n        seen = set()\\n        dirs = [(0, 1), (1, 0), (-1, 0), (0, -1)]\\n\\n        res = float(\\'inf\\')\\n\\n        while heap:\\n            obstacles, x, y = heapq.heappop(heap)\\n            if (x,y) in seen:\\n                continue\\n            seen.add((x,y))\\n            if x == rows - 1 and y == cols - 1:\\n                return obstacles\\n            for dr, dc in dirs:\\n                r = x + dr\\n                c = y + dc\\n                if 0<=r< rows and 0<=c<cols and (r,c) not in seen:\\n                    if grid[r][c] == 1:\\n                        heapq.heappush(heap,(obstacles + 1, r,c))\\n                    else:\\n                        heapq.heappush(heap,(obstacles, r,c))\\n        \\n        return -1\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n\\n        heap = [(0,0,0)]\\n\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        \\n        seen = set()\\n        dirs = [(0, 1), (1, 0), (-1, 0), (0, -1)]\\n\\n        res = float(\\'inf\\')\\n\\n        while heap:\\n            obstacles, x, y = heapq.heappop(heap)\\n            if (x,y) in seen:\\n                continue\\n            seen.add((x,y))\\n            if x == rows - 1 and y == cols - 1:\\n                return obstacles\\n            for dr, dc in dirs:\\n                r = x + dr\\n                c = y + dc\\n                if 0<=r< rows and 0<=c<cols and (r,c) not in seen:\\n                    if grid[r][c] == 1:\\n                        heapq.heappush(heap,(obstacles + 1, r,c))\\n                    else:\\n                        heapq.heappush(heap,(obstacles, r,c))\\n        \\n        return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992021,
                "title": "easy-to-catch-beginners-friendly-c-beats-80-iit-roorkee",
                "content": "# Complexity\\n- Time complexity:O(N*N)\\n- Space complexity:O(N*N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid)\\n    {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,INT_MAX));\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        dp[0][0]=0;\\n        pq.push({0,{0,0}});\\n        int ar[]={1,-1,0,0};\\n        int br[]={0,0,1,-1};\\n        while(!pq.empty())\\n        {\\n            int x=pq.top().second.first;\\n            int y=pq.top().second.second;\\n            pq.pop();\\n            if((x==(n-1))&&(y==(m-1)))\\n            {\\n                return dp[x][y];\\n            }\\n            for(int i=0;i<4;i++)\\n            {\\n                int r=x+ar[i];\\n                int c=y+br[i];\\n                if((r>=0)&&(c>=0)&&(r<n)&&(c<m))\\n                {\\n                    if(grid[r][c]==1)\\n                    {\\n                        if(dp[r][c]>1+dp[x][y])\\n                        {\\n                            dp[r][c]=1+dp[x][y];\\n                            pq.push({dp[r][c],{r,c}});\\n                        }\\n                    }\\n                    else\\n                    {\\n                        if(dp[r][c]>dp[x][y])\\n                        {\\n                            dp[r][c]=dp[x][y];\\n                            pq.push({dp[r][c],{r,c}});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Matrix",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid)\\n    {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,INT_MAX));\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        dp[0][0]=0;\\n        pq.push({0,{0,0}});\\n        int ar[]={1,-1,0,0};\\n        int br[]={0,0,1,-1};\\n        while(!pq.empty())\\n        {\\n            int x=pq.top().second.first;\\n            int y=pq.top().second.second;\\n            pq.pop();\\n            if((x==(n-1))&&(y==(m-1)))\\n            {\\n                return dp[x][y];\\n            }\\n            for(int i=0;i<4;i++)\\n            {\\n                int r=x+ar[i];\\n                int c=y+br[i];\\n                if((r>=0)&&(c>=0)&&(r<n)&&(c<m))\\n                {\\n                    if(grid[r][c]==1)\\n                    {\\n                        if(dp[r][c]>1+dp[x][y])\\n                        {\\n                            dp[r][c]=1+dp[x][y];\\n                            pq.push({dp[r][c],{r,c}});\\n                        }\\n                    }\\n                    else\\n                    {\\n                        if(dp[r][c]>dp[x][y])\\n                        {\\n                            dp[r][c]=dp[x][y];\\n                            pq.push({dp[r][c],{r,c}});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989312,
                "title": "dijkstra-java-with-inline-comments-and-intuition",
                "content": "# Intuition\\nfind all routes from src to dest \\ncount all the obstacles along the way\\nroute having min number of obstacles + ( shortest one) along the way should be the best one?\\nthink about - minimum number of obstacles to remove \\n?dijkstra - consider obstacle path as cost to be paid \\n0 - path with no cost\\n1 - path with 1 cost\\nAdd the obstacle removal cost to distance \\nDijkstra - use PQ \\n\\n\\n# Complexity\\n**- Time complexity:**\\nInitializing the dist array with Integer.MAX_VALUE takes O(m * n), where m is the number of rows and n is the number of columns in the grid.\\nThe PriorityQueue (pq) can have at most m * n elements, and in the worst case, all cells are processed, so the loop will run a maximum of m * n times.\\nInside the loop, you have a loop that iterates over the four directions, which is a constant factor.\\nOverall, the time complexity of the code is **O(m * n + log(m * n))**, where log(m * n) comes from the PriorityQueue operations.\\n**- Space complexity:**\\nO(m * n) \\n# Code\\n```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dirs = {{0,1},{1,0},{0, -1}, {-1, 0}};\\n        // to capture the distance\\n        int[][] dist = new int[m][n];\\n        // initially populate the distance with Infinity\\n        for(int[]arr: dist) Arrays.fill(arr, Integer.MAX_VALUE);\\n        // Create PQ to hold grid positions and their distances\\n        // PQ will store {x, y, dist} as triplets sorted by dist asc \\n        Queue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        // add starting position to the queue which is upper left cornter\\n        // (0,0) with distance set to zero\\n        pq.offer(new int[]{0, 0, 0});\\n        dist[0][0] = 0;\\n        while(!pq.isEmpty()){\\n            int[] current = pq.poll(); // poll the one with smallest distance\\n            int x = current[0];\\n            int y = current[1];\\n            int distance = current[2];\\n            // check if we have reached destination\\n            if(x == m-1 && y==n-1) return distance;\\n            // now from current cell move in all 4 directions\\n            // below for loop creates new coordinates of the cell\\n            for(int[]dir: dirs) {\\n                int nx = x + dir[0]; //new x\\n                int ny = y + dir[1]; //new y\\n                //validate out of grid coordinates and reject them\\n                if(nx<0 || nx>=m || ny<0 || ny>=n) continue;\\n                //for valid coordinates re-compute the distance from previous source i.e {x, y}\\n                if(dist[nx][ny]> distance + grid[nx][ny]) {\\n                    dist[nx][ny] = distance + grid[nx][ny];\\n                    pq.offer(new int[]{nx, ny, dist[nx][ny]});\\n                }\\n            }\\n\\n        }\\n\\n        // dist[][] will contain the cost of reaching to m-1, n-1\\n        return dist[m-1][n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dirs = {{0,1},{1,0},{0, -1}, {-1, 0}};\\n        // to capture the distance\\n        int[][] dist = new int[m][n];\\n        // initially populate the distance with Infinity\\n        for(int[]arr: dist) Arrays.fill(arr, Integer.MAX_VALUE);\\n        // Create PQ to hold grid positions and their distances\\n        // PQ will store {x, y, dist} as triplets sorted by dist asc \\n        Queue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        // add starting position to the queue which is upper left cornter\\n        // (0,0) with distance set to zero\\n        pq.offer(new int[]{0, 0, 0});\\n        dist[0][0] = 0;\\n        while(!pq.isEmpty()){\\n            int[] current = pq.poll(); // poll the one with smallest distance\\n            int x = current[0];\\n            int y = current[1];\\n            int distance = current[2];\\n            // check if we have reached destination\\n            if(x == m-1 && y==n-1) return distance;\\n            // now from current cell move in all 4 directions\\n            // below for loop creates new coordinates of the cell\\n            for(int[]dir: dirs) {\\n                int nx = x + dir[0]; //new x\\n                int ny = y + dir[1]; //new y\\n                //validate out of grid coordinates and reject them\\n                if(nx<0 || nx>=m || ny<0 || ny>=n) continue;\\n                //for valid coordinates re-compute the distance from previous source i.e {x, y}\\n                if(dist[nx][ny]> distance + grid[nx][ny]) {\\n                    dist[nx][ny] = distance + grid[nx][ny];\\n                    pq.offer(new int[]{nx, ny, dist[nx][ny]});\\n                }\\n            }\\n\\n        }\\n\\n        // dist[][] will contain the cost of reaching to m-1, n-1\\n        return dist[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985864,
                "title": "java-simple-solution-with-dijkestra-very-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(M*N)\\n\\n- Space complexity:\\nO(M*N)\\n\\n# Code\\n```\\n\\nclass Solution {\\n       int[][] dirs = {{0,1},{0,-1}, {1,0},{-1,0}};\\n\\n         int[][] dist = null;\\n    public int minimumObstacles(int[][] grid) {\\n  int m = grid.length;\\n        int n = grid[0].length;\\n\\n        dist = new int[m][n];\\n\\n        for (int[] disArray : dist) {\\n            Arrays.fill(disArray, (int)1e9);\\n        }\\n\\n        dist[0][0] = grid[0][0];\\n\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> (a[2] - b[2]));\\n       \\n        pq.offer(new int[]{ 0,  0, dist[0][0]});\\n\\n        while (!pq.isEmpty()) {\\n\\n            int[] cur = pq.poll();\\n\\n            int x = cur[0];\\n            int y = cur[1];\\n            int currCost = cur[2];\\n\\n            if (x == m - 1 && y == n - 1) {\\n                return currCost;\\n            }\\n\\n            for (int[] dir : dirs) {\\n\\n                int nx = x + dir[0];\\n                int ny = y + dir[1];\\n                if (nx >=0 && nx<m && ny >=0 && ny<n && currCost + grid[nx][ny] < dist[nx][ny]) {\\n                    dist[nx][ny] = currCost + grid[nx][ny];\\n                    pq.offer(new int[]{nx, ny,dist[nx][ny]});\\n                }\\n            }\\n        }\\n        return dist[m - 1][n - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n       int[][] dirs = {{0,1},{0,-1}, {1,0},{-1,0}};\\n\\n         int[][] dist = null;\\n    public int minimumObstacles(int[][] grid) {\\n  int m = grid.length;\\n        int n = grid[0].length;\\n\\n        dist = new int[m][n];\\n\\n        for (int[] disArray : dist) {\\n            Arrays.fill(disArray, (int)1e9);\\n        }\\n\\n        dist[0][0] = grid[0][0];\\n\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> (a[2] - b[2]));\\n       \\n        pq.offer(new int[]{ 0,  0, dist[0][0]});\\n\\n        while (!pq.isEmpty()) {\\n\\n            int[] cur = pq.poll();\\n\\n            int x = cur[0];\\n            int y = cur[1];\\n            int currCost = cur[2];\\n\\n            if (x == m - 1 && y == n - 1) {\\n                return currCost;\\n            }\\n\\n            for (int[] dir : dirs) {\\n\\n                int nx = x + dir[0];\\n                int ny = y + dir[1];\\n                if (nx >=0 && nx<m && ny >=0 && ny<n && currCost + grid[nx][ny] < dist[nx][ny]) {\\n                    dist[nx][ny] = currCost + grid[nx][ny];\\n                    pq.offer(new int[]{nx, ny,dist[nx][ny]});\\n                }\\n            }\\n        }\\n        return dist[m - 1][n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983119,
                "title": "cpp-solution-using-dijkstra-s-algorithm",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n         int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> cost(n , vector<int> (m , INT_MAX));\\n        set<pair<int , pair<int , int>>> store;\\n        cost[0][0] = 0;\\n        store.insert({0 , {0 , 0}});\\n        int ROW[] = {0 , 0 , 1 , -1};\\n        int COL[] = {1 , -1 , 0 , 0};\\n        while(!store.empty())\\n        {\\n            auto begin = *(store.begin());\\n            int posCost = begin.first;\\n            int i = begin.second.first;\\n            int j = begin.second.second;\\n            store.erase(begin);\\n            if(i == n-1 && j == m-1) return posCost;\\n            for(int x = 0 ; x < 4 ; x++)\\n            {\\n                int I = i + ROW[x];\\n                int J = j + COL[x];\\n                if(I < 0 || J < 0 || I >= n || J >= m || cost[I][J] < posCost + 1) continue;\\n                if(grid[i][j] == 1)\\n                {\\n                    cost[I][J] = posCost + 1;\\n                    store.insert({posCost+1 , {I , J}});   \\n                }\\n                else\\n                {\\n                    cost[I][J] = posCost;\\n                    store.insert({posCost , {I , J}});   \\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n         int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> cost(n , vector<int> (m , INT_MAX));\\n        set<pair<int , pair<int , int>>> store;\\n        cost[0][0] = 0;\\n        store.insert({0 , {0 , 0}});\\n        int ROW[] = {0 , 0 , 1 , -1};\\n        int COL[] = {1 , -1 , 0 , 0};\\n        while(!store.empty())\\n        {\\n            auto begin = *(store.begin());\\n            int posCost = begin.first;\\n            int i = begin.second.first;\\n            int j = begin.second.second;\\n            store.erase(begin);\\n            if(i == n-1 && j == m-1) return posCost;\\n            for(int x = 0 ; x < 4 ; x++)\\n            {\\n                int I = i + ROW[x];\\n                int J = j + COL[x];\\n                if(I < 0 || J < 0 || I >= n || J >= m || cost[I][J] < posCost + 1) continue;\\n                if(grid[i][j] == 1)\\n                {\\n                    cost[I][J] = posCost + 1;\\n                    store.insert({posCost+1 , {I , J}});   \\n                }\\n                else\\n                {\\n                    cost[I][J] = posCost;\\n                    store.insert({posCost , {I , J}});   \\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979419,
                "title": "using-dijkstra-bfs-step-wise-commented-code",
                "content": "\\n# Approach\\nThe code uses a $priority$ $queue$ to perform a $modified$ $Dijkstra\\'s$ $algorithm$ to find the shortest path while keeping track of the number of obstacles encountered along the way. \\n\\nIt explores all possible directions from each cell and updates the priority queue with the new cell\\'s information. The algorithm terminates when the bottom-right corner is reached, and it returns the minimum number of obstacles encountered on that path.\\n\\n\\n\\n\\n\\n# Code\\n```\\n#define ppi pair<int, pair<int, int>>\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int dr[4] = {-1, 0, 1, 0}; // Direction arrays for moving up, right, down, left\\n        int dc[4] = {0, 1, 0, -1};\\n        int m = grid.size(); // Number of rows in the grid\\n        int n = grid[0].size(); // Number of columns in the grid\\n\\n        priority_queue<ppi, vector<ppi>, greater<ppi>> minh; // Priority queue to store path information\\n        vector<vector<int>> vis(m, vector<int>(n, 0)); // Matrix to keep track of visited cells\\n        \\n        // Push the starting cell (0, 0) into the priority queue\\n        if (grid[0][0] == 0)\\n            minh.push({0, {0, 0}});\\n        else\\n            minh.push({1, {0, 0}});\\n        vis[0][0] = 1; // Mark the starting cell as visited\\n        \\n        while (!minh.empty()) {\\n            auto it = minh.top(); // Get the current cell from the priority queue\\n            int r = it.second.first; // Row of the current cell\\n            int c = it.second.second; // Column of the current cell\\n            int count = it.first; // Number of obstacles encountered so far\\n            minh.pop(); // Remove the current cell from the priority queue\\n            \\n            // Explore all four possible directions\\n            for (int i = 0; i < 4; i++) {\\n                int nr = r + dr[i]; // New row after moving in direction i\\n                int nc = c + dc[i]; // New column after moving in direction i\\n                \\n                // Check if the new cell is within the grid boundaries and not visited yet\\n                if (nr >= 0 && nr < m && nc >= 0 && nc < n && !vis[nr][nc]) {\\n                    vis[nr][nc] = 1; // Mark the new cell as visited\\n                    \\n                    if (nr == m - 1 && nc == n - 1) // Check if the new cell is the destination\\n                        return count;\\n                    \\n                    // Push the new cell into the priority queue with updated obstacle count\\n                    if (grid[nr][nc] == 0)\\n                        minh.push({count, {nr, nc}});\\n                    else\\n                        minh.push({count + 1, {nr, nc}});\\n                }\\n            }\\n        }\\n        return 0; // If no path is found, return 0\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#define ppi pair<int, pair<int, int>>\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int dr[4] = {-1, 0, 1, 0}; // Direction arrays for moving up, right, down, left\\n        int dc[4] = {0, 1, 0, -1};\\n        int m = grid.size(); // Number of rows in the grid\\n        int n = grid[0].size(); // Number of columns in the grid\\n\\n        priority_queue<ppi, vector<ppi>, greater<ppi>> minh; // Priority queue to store path information\\n        vector<vector<int>> vis(m, vector<int>(n, 0)); // Matrix to keep track of visited cells\\n        \\n        // Push the starting cell (0, 0) into the priority queue\\n        if (grid[0][0] == 0)\\n            minh.push({0, {0, 0}});\\n        else\\n            minh.push({1, {0, 0}});\\n        vis[0][0] = 1; // Mark the starting cell as visited\\n        \\n        while (!minh.empty()) {\\n            auto it = minh.top(); // Get the current cell from the priority queue\\n            int r = it.second.first; // Row of the current cell\\n            int c = it.second.second; // Column of the current cell\\n            int count = it.first; // Number of obstacles encountered so far\\n            minh.pop(); // Remove the current cell from the priority queue\\n            \\n            // Explore all four possible directions\\n            for (int i = 0; i < 4; i++) {\\n                int nr = r + dr[i]; // New row after moving in direction i\\n                int nc = c + dc[i]; // New column after moving in direction i\\n                \\n                // Check if the new cell is within the grid boundaries and not visited yet\\n                if (nr >= 0 && nr < m && nc >= 0 && nc < n && !vis[nr][nc]) {\\n                    vis[nr][nc] = 1; // Mark the new cell as visited\\n                    \\n                    if (nr == m - 1 && nc == n - 1) // Check if the new cell is the destination\\n                        return count;\\n                    \\n                    // Push the new cell into the priority queue with updated obstacle count\\n                    if (grid[nr][nc] == 0)\\n                        minh.push({count, {nr, nc}});\\n                    else\\n                        minh.push({count + 1, {nr, nc}});\\n                }\\n            }\\n        }\\n        return 0; // If no path is found, return 0\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977719,
                "title": "don-t-think-just-start-applying-dijkstra-simple-thought",
                "content": "Don\\'t even think twice \\nApply Dijkstra in grid problem where all four direction movement is possible.\\nin first thought anyone will come up with some sort of recursive dfs solution with memoization but the thing here is to avoid revisiting the same cell again and again we need a visited array and here we f*** ek up bcz now u can\\'t actually memoize bcz u r changing state of visited array and that leads us to store visited array state as well that isn\\'t going to work and simple dfs with back track will give tle \\n\\nSo only way to solve this thing simply is to dijkstra algo with priority queue\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& g) \\n    {\\n        using p=pair<int, pair<int,int>>;\\n        priority_queue<p,vector<p>, greater<p>>pq;\\n        int n; int m;\\n        n=g.size();\\n        m=g[0].size();\\n        vector<vector<int>> dis(n, vector<int>(m,1e5+1));\\n        vector<vector<int>> v(n, vector<int>(m,0));\\n\\n        if(g[0][0]==1) \\n        {\\n            dis[0][0]=1;\\n            pq.push({1,{0,0}});\\n        }\\n        else \\n        {\\n            pq.push({0,{0,0}});\\n            dis[0][0]=0;\\n        }\\n        int dx[4]={0,0,-1,1};\\n        int dy[4]={-1,1,0,0};\\n        int ans=INT_MAX;\\n        while(!pq.empty())\\n        {\\n            auto p= pq.top();\\n            pq.pop();\\n            int c=p.first;\\n            int x=p.second.first;\\n            int y=p.second.second;\\n            if(x==n-1 && y==m-1)\\n            {\\n                ans= c;\\n                break;\\n            }\\n            if(v[x][y]) continue;  // if already visited the ignore \\n            v[x][y]=1;\\n            for(int i=0; i<4; i++)\\n            {\\n                int l=x+dx[i];\\n                int r=y+dy[i];\\n                if(l>=0 && l<n && r>=0 && r<m)\\n                {\\n                    int t=c;\\n                    if(g[l][r]) t=c+1;// need to remove obstacle\\n                    \\n                    if(dis[l][r]>t && v[l][r]==0)\\n                    {\\n                        dis[l][r]=t;\\n                        pq.push({t,{l,r}});\\n                    }\\n                }\\n            }\\n\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& g) \\n    {\\n        using p=pair<int, pair<int,int>>;\\n        priority_queue<p,vector<p>, greater<p>>pq;\\n        int n; int m;\\n        n=g.size();\\n        m=g[0].size();\\n        vector<vector<int>> dis(n, vector<int>(m,1e5+1));\\n        vector<vector<int>> v(n, vector<int>(m,0));\\n\\n        if(g[0][0]==1) \\n        {\\n            dis[0][0]=1;\\n            pq.push({1,{0,0}});\\n        }\\n        else \\n        {\\n            pq.push({0,{0,0}});\\n            dis[0][0]=0;\\n        }\\n        int dx[4]={0,0,-1,1};\\n        int dy[4]={-1,1,0,0};\\n        int ans=INT_MAX;\\n        while(!pq.empty())\\n        {\\n            auto p= pq.top();\\n            pq.pop();\\n            int c=p.first;\\n            int x=p.second.first;\\n            int y=p.second.second;\\n            if(x==n-1 && y==m-1)\\n            {\\n                ans= c;\\n                break;\\n            }\\n            if(v[x][y]) continue;  // if already visited the ignore \\n            v[x][y]=1;\\n            for(int i=0; i<4; i++)\\n            {\\n                int l=x+dx[i];\\n                int r=y+dy[i];\\n                if(l>=0 && l<n && r>=0 && r<m)\\n                {\\n                    int t=c;\\n                    if(g[l][r]) t=c+1;// need to remove obstacle\\n                    \\n                    if(dis[l][r]>t && v[l][r]==0)\\n                    {\\n                        dis[l][r]=t;\\n                        pq.push({t,{l,r}});\\n                    }\\n                }\\n            }\\n\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964565,
                "title": "easy-to-understand-dijkstra-algorithm-python",
                "content": "# Complexity\\n- Time complexity: O(m\\xD7nlog(m\\xD7n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m\\xD7n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom heapq import heappush, heappop\\nfrom typing import List\\n\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        if not grid or not grid[0]:\\n            return 0\\n        \\n        m, n = len(grid), len(grid[0])\\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n\\n        heap = [(grid[0][0], 0, 0)]\\n        visited = set((0, 0))\\n        \\n        while heap:\\n            obstacles, x, y = heappop(heap)\\n            \\n            if (x, y) == (m-1, n-1):\\n                return obstacles\\n            \\n            for dx, dy in directions:\\n                nx, ny = x + dx, y + dy\\n                \\n                if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited:\\n                    visited.add((nx, ny))\\n        \\n                    heappush(heap, (obstacles + grid[nx][ny], nx, ny))\\n\\n        return 0\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom heapq import heappush, heappop\\nfrom typing import List\\n\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        if not grid or not grid[0]:\\n            return 0\\n        \\n        m, n = len(grid), len(grid[0])\\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n\\n        heap = [(grid[0][0], 0, 0)]\\n        visited = set((0, 0))\\n        \\n        while heap:\\n            obstacles, x, y = heappop(heap)\\n            \\n            if (x, y) == (m-1, n-1):\\n                return obstacles\\n            \\n            for dx, dy in directions:\\n                nx, ny = x + dx, y + dy\\n                \\n                if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited:\\n                    visited.add((nx, ny))\\n        \\n                    heappush(heap, (obstacles + grid[nx][ny], nx, ny))\\n\\n        return 0\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948515,
                "title": "simple-striver-like-solution-short-and-easy-c-dijkstra-s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust maintain a pq, the int d, is basically the count of how many obstacles remove as we only have 0/1 in grid, if we encounter a d(i.e count) smaller than what we have then we just update our dist matrix that stores counts basically.\\n\\nGo through the code, its pretty self explainatory !\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>>dis(n,vector<int>(m,INT_MAX));\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n        pq.push({grid[0][0],0,0});\\n        dis[0][0]=grid[0][0];\\n        vis[0][0]=1;\\n        int drow[]={-1,0,1,0};\\n        int dcol[]={0,-1,0,1};\\n        while(!pq.empty()){\\n            int d=pq.top()[0];\\n            int r=pq.top()[1];\\n            int c=pq.top()[2];\\n            pq.pop();\\n            vis[r][c]=1;\\n            for(int k=0;k<4;k++){\\n                int nr=r+drow[k];\\n                int nc=c+dcol[k];\\n                if(nr<n and nc<m and nr>=0 and nc>=0 and !vis[nr][nc] and d+grid[nr][nc]<dis[nr][nc]){\\n                    dis[nr][nc]=d+grid[nr][nc];\\n                    pq.push({dis[nr][nc],nr,nc});\\n                }\\n            }\\n        }\\n        return dis[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>>dis(n,vector<int>(m,INT_MAX));\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n        pq.push({grid[0][0],0,0});\\n        dis[0][0]=grid[0][0];\\n        vis[0][0]=1;\\n        int drow[]={-1,0,1,0};\\n        int dcol[]={0,-1,0,1};\\n        while(!pq.empty()){\\n            int d=pq.top()[0];\\n            int r=pq.top()[1];\\n            int c=pq.top()[2];\\n            pq.pop();\\n            vis[r][c]=1;\\n            for(int k=0;k<4;k++){\\n                int nr=r+drow[k];\\n                int nc=c+dcol[k];\\n                if(nr<n and nc<m and nr>=0 and nc>=0 and !vis[nr][nc] and d+grid[nr][nc]<dis[nr][nc]){\\n                    dis[nr][nc]=d+grid[nr][nc];\\n                    pq.push({dis[nr][nc],nr,nc});\\n                }\\n            }\\n        }\\n        return dis[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933602,
                "title": "bfs-dfs-combined-solution-python-thought-process",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe naive intution for this problem is to use bfs or dfs to find all the path then figure out the path with minimum blocks to break. However, this will run into TLE or MLE. The reason is we some path are unnecessary. For example, for grid[x][y] if there is a path already been there with 0 breaks, other path with breaks larger than this shall not being added to the queue. \\n\\nThus, instead of a normal visit set to store visited cell, we need another state to store the breaks, which results in (x,y,breaks). We can check if the current path has a break less than current break state, if it is, we could add it, else it would be wrose and we dont need to add it into queue.\\n\\nThis method is logical correct. However, this might still not pass the test since sometimes it takes too much steps before the best path to find the way, and before that, multiple worse path has been visited this cell. So, how do we make the best path to the fastest to get to the end? \\n\\nIt took me a day to figure out some priority is needed. Inspired by another brilliant solution, I realized that we could add to queue depends on its breaks. If we haven\\'t break block in this step, we could add it to the front, else we could add this to the end. By doing this, we could allow the \\'best\\' path always goes first and prevent \\'bad\\' ways goes first.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        def valid(x,y):\\n            return 0<=x<m and 0<=y<n\\n        from collections import deque\\n        #define state: blk has removed\\n        q = deque()\\n        q.append((0,0,0))\\n        vmap=[[math.inf]*n for _ in range(m)]\\n        dirct=((1,0),(0,1),(-1,0),(0,-1))\\n        while len(q)>0:\\n            x,y,blk = q.popleft()\\n            for dx, dy in dirct:\\n                nx, ny = x+dx, y+dy\\n                if valid(nx,ny):\\n                    nblk = blk+grid[nx][ny]\\n                    if vmap[nx][ny]>nblk :\\n                        if nblk==blk:\\n                            vmap[nx][ny]=nblk\\n                            q.appendleft((nx,ny,nblk))\\n                        else:\\n                            vmap[nx][ny]=nblk\\n                            q.append((nx,ny,nblk))\\n        return vmap[m-1][n-1]\\n\\n  \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        def valid(x,y):\\n            return 0<=x<m and 0<=y<n\\n        from collections import deque\\n        #define state: blk has removed\\n        q = deque()\\n        q.append((0,0,0))\\n        vmap=[[math.inf]*n for _ in range(m)]\\n        dirct=((1,0),(0,1),(-1,0),(0,-1))\\n        while len(q)>0:\\n            x,y,blk = q.popleft()\\n            for dx, dy in dirct:\\n                nx, ny = x+dx, y+dy\\n                if valid(nx,ny):\\n                    nblk = blk+grid[nx][ny]\\n                    if vmap[nx][ny]>nblk :\\n                        if nblk==blk:\\n                            vmap[nx][ny]=nblk\\n                            q.appendleft((nx,ny,nblk))\\n                        else:\\n                            vmap[nx][ny]=nblk\\n                            q.append((nx,ny,nblk))\\n        return vmap[m-1][n-1]\\n\\n  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926393,
                "title": "trick-use-bfs-as-path-increasing-simultaneously-explain",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ntake the visited path explore all the path and then mask it as visited with the priority _queue data structure \\n\\n\\n**main trick if region grow simultaneously , think of haviG using of bfs**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nvis array mark for the assign \\npair<int,pair<int,int>>  for the dis, curX, curY;\\nmove all possible dirrections and then if reach at last derive the mini\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n*m)-vis matrix + size of priority_queue\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![upvote me please.png](https://assets.leetcode.com/users/images/e9583054-622d-4251-89ab-9dbaf6fa632d_1692354104.8582044.png)\\n\\n**UPVOTE TO GET THE HARD LEVEL SOLUTION**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int x_d[4]={-1,0,1,0};\\n    int mini=INT_MAX;\\n    int y_d[4]={0,1,0,-1};\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> q;\\n         q.push({0,{0,0}});\\n        vis[0][0]=1;\\n        \\n        while(!q.empty())\\n        {\\n             int sz=q.size();\\n            while(sz--)\\n            {\\n                int oldx=q.top().second.first;\\n                int oldy=q.top().second.second;\\n                int steps=q.top().first;\\n                q.pop();\\n                \\n                if(oldx==n-1 && oldy==m-1) {\\n                  mini=min(mini,steps);\\n                }\\n                \\n                for(int i=0;i<4;++i)\\n                {\\n                    int newx=oldx+x_d[i];\\n                    int newy=oldy+y_d[i];\\n                    if(newx>=0 && newx<n && newy>=0 && newy<m && !vis[newx][newy])\\n                    {\\n                        vis[newx][newy]=1;\\n                       if(grid[newx][newy]==1)\\n                       {\\n                           q.push({steps+1,{newx,newy}});\\n                           \\n                       }else\\n                       {\\n                           q.push({steps,{newx,newy}});\\n                               \\n                       }\\n                       \\n                    }        \\n                \\n\\n                }\\n            }\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Graph",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int x_d[4]={-1,0,1,0};\\n    int mini=INT_MAX;\\n    int y_d[4]={0,1,0,-1};\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> q;\\n         q.push({0,{0,0}});\\n        vis[0][0]=1;\\n        \\n        while(!q.empty())\\n        {\\n             int sz=q.size();\\n            while(sz--)\\n            {\\n                int oldx=q.top().second.first;\\n                int oldy=q.top().second.second;\\n                int steps=q.top().first;\\n                q.pop();\\n                \\n                if(oldx==n-1 && oldy==m-1) {\\n                  mini=min(mini,steps);\\n                }\\n                \\n                for(int i=0;i<4;++i)\\n                {\\n                    int newx=oldx+x_d[i];\\n                    int newy=oldy+y_d[i];\\n                    if(newx>=0 && newx<n && newy>=0 && newy<m && !vis[newx][newy])\\n                    {\\n                        vis[newx][newy]=1;\\n                       if(grid[newx][newy]==1)\\n                       {\\n                           q.push({steps+1,{newx,newy}});\\n                           \\n                       }else\\n                       {\\n                           q.push({steps,{newx,newy}});\\n                               \\n                       }\\n                       \\n                    }        \\n                \\n\\n                }\\n            }\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876861,
                "title": "python-heap-use-is-it-really-hard-explained",
                "content": "# Approach\\nIf you can break down the problem into smaller ideas u will find its a simple djisktra problem where we need to find the best path with min no of obstacles(treat obstacles as the cost)\\nNow how we summing up the no of obstacles? \\n`0 -> empty cell`\\n`1 -> brick in cell`\\n\\nso keep a track of obstacles removed yet till we reach a specific cell by summing up the `current cell val + path val` and always update the cell if we can reach it in more efficient manner i.e less no of obstacles.\\n\\nFinally return the last Cell value as it is the min of number of cells required to remove upto this cell.\\n\\n**You can either use visited set (like in solution) or use the condition:-**\\n```\\nif obRemove[r][c] > obstacles + grid[r][c]:\\n    obRemove[r][c] = obstacles + grid[r][c]\\n    heapq.heappush(bag, (obRemove[r][c], r, c))\\n```\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        ROWS = len(grid)\\n        COLS = len(grid[0])\\n        directions = [(1, 0), (0, 1), (0, -1), (-1, 0)]\\n        bag = []\\n        obRemove = [[inf]*COLS for _ in range(ROWS)]\\n        visited = set()\\n        obRemove[0][0] = grid[0][0]\\n        heapq.heappush(bag, (obRemove[0][0], 0, 0))\\n        visited.add((0, 0))\\n        while bag:\\n            obstacles, i, j = heapq.heappop(bag)\\n            for dr, dc in directions:\\n                r = i + dr\\n                c = j + dc\\n                if r in range(ROWS) and c in range(COLS) and (r, c) not in visited:\\n                    ob = obstacles + grid[r][c]\\n                    obRemove[r][c] = min(obRemove[r][c], ob)\\n                    visited.add((r, c))\\n                    heapq.heappush(bag, (obRemove[r][c], r, c))\\n        return obRemove[-1][-1]\\n        \\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nif obRemove[r][c] > obstacles + grid[r][c]:\\n    obRemove[r][c] = obstacles + grid[r][c]\\n    heapq.heappush(bag, (obRemove[r][c], r, c))\\n```\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        ROWS = len(grid)\\n        COLS = len(grid[0])\\n        directions = [(1, 0), (0, 1), (0, -1), (-1, 0)]\\n        bag = []\\n        obRemove = [[inf]*COLS for _ in range(ROWS)]\\n        visited = set()\\n        obRemove[0][0] = grid[0][0]\\n        heapq.heappush(bag, (obRemove[0][0], 0, 0))\\n        visited.add((0, 0))\\n        while bag:\\n            obstacles, i, j = heapq.heappop(bag)\\n            for dr, dc in directions:\\n                r = i + dr\\n                c = j + dc\\n                if r in range(ROWS) and c in range(COLS) and (r, c) not in visited:\\n                    ob = obstacles + grid[r][c]\\n                    obRemove[r][c] = min(obRemove[r][c], ob)\\n                    visited.add((r, c))\\n                    heapq.heappush(bag, (obRemove[r][c], r, c))\\n        return obRemove[-1][-1]\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854323,
                "title": "dijekstra-algorithm-solution-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        //dis[i][j] reprsent theminimum obstacles we have to remove to reach (i,j) from (0,0)\\n\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({grid[0][0],{0,0}});\\n        vector<vector<int>>dis(n,vector<int>(m,1e9));\\n        dis[0][0] = grid[0][0];\\n        int delrow[] = {0,-1,0,+1};\\n        int delcol[] = {+1,0,-1,0};\\n        while(pq.empty() == false){\\n            int distance = pq.top().first;\\n            int row = pq.top().second.first;\\n            int col = pq.top().second.second;\\n            pq.pop();\\n\\n            for(int i=0;i<4;i++){\\n                int nrow = row + delrow[i];\\n                int ncol = col + delcol[i];\\n                if(nrow>=0 && ncol>=0 && nrow<n && ncol<m){\\n                    if(dis[nrow][ncol] > (distance + (grid[nrow][ncol] == 1))){\\n                        dis[nrow][ncol] =distance + (grid[nrow][ncol] == 1);\\n                        pq.push({dis[nrow][ncol],{nrow,ncol}});\\n                    }\\n                }\\n            }\\n        }\\n        return dis[n-1][m-1];//dis[i][j] represent the minimum no of obstacles you have to remove \\n        //to reach to (i,j) from (0,0)\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        //dis[i][j] reprsent theminimum obstacles we have to remove to reach (i,j) from (0,0)\\n\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({grid[0][0],{0,0}});\\n        vector<vector<int>>dis(n,vector<int>(m,1e9));\\n        dis[0][0] = grid[0][0];\\n        int delrow[] = {0,-1,0,+1};\\n        int delcol[] = {+1,0,-1,0};\\n        while(pq.empty() == false){\\n            int distance = pq.top().first;\\n            int row = pq.top().second.first;\\n            int col = pq.top().second.second;\\n            pq.pop();\\n\\n            for(int i=0;i<4;i++){\\n                int nrow = row + delrow[i];\\n                int ncol = col + delcol[i];\\n                if(nrow>=0 && ncol>=0 && nrow<n && ncol<m){\\n                    if(dis[nrow][ncol] > (distance + (grid[nrow][ncol] == 1))){\\n                        dis[nrow][ncol] =distance + (grid[nrow][ncol] == 1);\\n                        pq.push({dis[nrow][ncol],{nrow,ncol}});\\n                    }\\n                }\\n            }\\n        }\\n        return dis[n-1][m-1];//dis[i][j] represent the minimum no of obstacles you have to remove \\n        //to reach to (i,j) from (0,0)\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795343,
                "title": "simple-c-solution",
                "content": "# Intuition\\nthis is a simple dijkastra related problem just find the minimum path sum from {0,0} to {n-1,m-1} \\n\\nif you cannot reach the last corner just return -1.\\nTip:try to reduce as much space as possible.Initially I used vector in priority queue it gave tle so i used pair<int,pair<int,int>> \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n       priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>dq;\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        dq.push({0,{0,0}});\\n       \\n        while(!dq.empty()){\\n            int i=dq.top().second.first,j=dq.top().second.second,d=dq.top().first;\\n            if(i==n-1&&j==m-1)return d;\\n            dq.pop();\\n           \\n            if(vis[i][j]==0){\\n                vis[i][j]=1;\\n              \\n                if(i+1<n&&vis[i+1][j]==0){\\n                  dq.push({d+grid[i+1][j],{i+1,j}});  \\n                }\\n                if(i-1>=0&&vis[i-1][j]==0){\\n                    dq.push({d+grid[i-1][j],{i-1,j}});\\n                }\\n                if(j+1<m&&vis[i][j+1]==0){\\n                   dq.push({d+grid[i][j+1],{i,j+1}}); \\n                }\\n                 if(j-1>=0&&vis[i][j-1]==0){\\n                    dq.push({d+grid[i][j-1],{i,j-1}});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n       priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>dq;\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        dq.push({0,{0,0}});\\n       \\n        while(!dq.empty()){\\n            int i=dq.top().second.first,j=dq.top().second.second,d=dq.top().first;\\n            if(i==n-1&&j==m-1)return d;\\n            dq.pop();\\n           \\n            if(vis[i][j]==0){\\n                vis[i][j]=1;\\n              \\n                if(i+1<n&&vis[i+1][j]==0){\\n                  dq.push({d+grid[i+1][j],{i+1,j}});  \\n                }\\n                if(i-1>=0&&vis[i-1][j]==0){\\n                    dq.push({d+grid[i-1][j],{i-1,j}});\\n                }\\n                if(j+1<m&&vis[i][j+1]==0){\\n                   dq.push({d+grid[i][j+1],{i,j+1}}); \\n                }\\n                 if(j-1>=0&&vis[i][j-1]==0){\\n                    dq.push({d+grid[i][j-1],{i,j-1}});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766288,
                "title": "java-solutions-using-0-1-bfs-and-dijkstra",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        return dijkstra(grid);\\n    }\\n\\n    // implement using 0 - 1 BFS\\n    // BFS since we need to calculate MIN obstacles to remove\\n    // if we encounter a 1 i.e an obstacle put it at the back of the queue\\n    // we need to process 1 if we run out of cells with 0 and didn\\'t reach \\n    // the end (m - 1, n - 1)\\n    // run BFS by popping from the front i.e preference to zeros\\n    // when all zeros are exhausted we will encounter a 1 and if we \\n    // encounter a zero again we will switch to processing 0 \\n    // since we append the cell with zero in the front\\n    // and for each 1 encountered increment the count.\\n\\n    private int zeroOneBFS(int[][] grid){\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int dirs[][] = {{1,0},{0,1},{-1,0},{0,-1}};\\n\\n        boolean[][] visited = new boolean[m][n];\\n\\n        Deque<int[]> queue = new LinkedList<>();\\n\\n        \\n        queue.offer(new int[]{0, 0, grid[0][0]});\\n        visited[0][0] = true;\\n\\n        while (!queue.isEmpty()){\\n            int[] curr = queue.removeFirst();\\n\\n            int r = curr[0], c = curr[1], k = curr[2];\\n\\n            if (r == m - 1 && c == n - 1)\\n                return k;\\n\\n            for (int[] d : dirs){\\n                int nr = r + d[0], nc = c + d[1];\\n                if (nr >= 0 && nr < m && nc >= 0 && nc < n && !visited[nr][nc]){                    \\n                    visited[nr][nc] = true;\\n                    if (grid[nr][nc] == 0){\\n                        queue.addFirst(new int[]{nr, nc, k});\\n                    } else {\\n                        queue.addLast(new int[]{nr, nc, k + 1});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    //using dijkstra\\n    // increment the cost ans use it is a priority value \\n    // when end is reched return the obstacles removed.\\n\\n    private int dijkstra(int[][] grid) {\\n\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> a[2] - b[2]);\\n\\n        int m = grid.length, n = grid[0].length;\\n\\n        boolean[][] visited = new boolean[m][n];\\n\\n        pq.offer(new int[]{0, 0, grid[0][0]});\\n\\n        visited[0][0] = true;\\n\\n        int dirs[][] = {{1,0}, {0,1}, {-1,0}, {0,-1}};\\n\\n        while (!pq.isEmpty()){\\n            int[] curr = pq.poll();\\n\\n            int r = curr[0], c = curr[1], k = curr[2];\\n\\n            if (r == m - 1 && c == n - 1)\\n                return k;\\n\\n            for (int[] d : dirs){\\n                int nr = r + d[0], nc = c + d[1];\\n                if (nr >= 0 && nr < m && nc >= 0 && nc < n && !visited[nr][nc]){                  visited[nr][nc] = true;\\n                    if (grid[nr][nc] == 0){\\n                        pq.offer(new int[]{nr, nc, k});\\n                    } else {\\n                        pq.offer(new int[]{nr, nc, k + 1});\\n                    }\\n                } \\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        return dijkstra(grid);\\n    }\\n\\n    // implement using 0 - 1 BFS\\n    // BFS since we need to calculate MIN obstacles to remove\\n    // if we encounter a 1 i.e an obstacle put it at the back of the queue\\n    // we need to process 1 if we run out of cells with 0 and didn\\'t reach \\n    // the end (m - 1, n - 1)\\n    // run BFS by popping from the front i.e preference to zeros\\n    // when all zeros are exhausted we will encounter a 1 and if we \\n    // encounter a zero again we will switch to processing 0 \\n    // since we append the cell with zero in the front\\n    // and for each 1 encountered increment the count.\\n\\n    private int zeroOneBFS(int[][] grid){\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int dirs[][] = {{1,0},{0,1},{-1,0},{0,-1}};\\n\\n        boolean[][] visited = new boolean[m][n];\\n\\n        Deque<int[]> queue = new LinkedList<>();\\n\\n        \\n        queue.offer(new int[]{0, 0, grid[0][0]});\\n        visited[0][0] = true;\\n\\n        while (!queue.isEmpty()){\\n            int[] curr = queue.removeFirst();\\n\\n            int r = curr[0], c = curr[1], k = curr[2];\\n\\n            if (r == m - 1 && c == n - 1)\\n                return k;\\n\\n            for (int[] d : dirs){\\n                int nr = r + d[0], nc = c + d[1];\\n                if (nr >= 0 && nr < m && nc >= 0 && nc < n && !visited[nr][nc]){                    \\n                    visited[nr][nc] = true;\\n                    if (grid[nr][nc] == 0){\\n                        queue.addFirst(new int[]{nr, nc, k});\\n                    } else {\\n                        queue.addLast(new int[]{nr, nc, k + 1});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    //using dijkstra\\n    // increment the cost ans use it is a priority value \\n    // when end is reched return the obstacles removed.\\n\\n    private int dijkstra(int[][] grid) {\\n\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> a[2] - b[2]);\\n\\n        int m = grid.length, n = grid[0].length;\\n\\n        boolean[][] visited = new boolean[m][n];\\n\\n        pq.offer(new int[]{0, 0, grid[0][0]});\\n\\n        visited[0][0] = true;\\n\\n        int dirs[][] = {{1,0}, {0,1}, {-1,0}, {0,-1}};\\n\\n        while (!pq.isEmpty()){\\n            int[] curr = pq.poll();\\n\\n            int r = curr[0], c = curr[1], k = curr[2];\\n\\n            if (r == m - 1 && c == n - 1)\\n                return k;\\n\\n            for (int[] d : dirs){\\n                int nr = r + d[0], nc = c + d[1];\\n                if (nr >= 0 && nr < m && nc >= 0 && nc < n && !visited[nr][nc]){                  visited[nr][nc] = true;\\n                    if (grid[nr][nc] == 0){\\n                        pq.offer(new int[]{nr, nc, k});\\n                    } else {\\n                        pq.offer(new int[]{nr, nc, k + 1});\\n                    }\\n                } \\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765002,
                "title": "simple-java-solution-with-bfs",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int [][]distance = new int[m][n];\\n        int [][]directions = {{0, 1}, {0, -1}, {1, 0},{-1, 0}};\\n        for(int []arr : distance) Arrays.fill(arr, Integer.MAX_VALUE);\\n        Deque<triple> dq = new ArrayDeque<>();\\n        dq.add(new triple(0, 0, 0));\\n        distance[0][0] = 0;\\n        while(!dq.isEmpty()){\\n            triple curr = dq.remove();\\n            int x = curr.x;\\n            int y = curr.y;\\n            int obs = curr.obs;\\n            for(int []dir : directions){\\n                int xx = x + dir[0];\\n                int yy = y + dir[1];\\n                if(xx < 0 || xx >= m || yy < 0 || yy >= n){ continue;}\\n                if(grid[xx][yy] + obs < distance[xx][yy]){\\n                    distance[xx][yy] = grid[xx][yy] + obs;\\n                    if(grid[xx][yy] == 0) dq.addFirst(new triple(xx,yy,distance[xx][yy]));\\n                    else dq.addLast(new triple(xx,yy,distance[xx][yy]));\\n                }\\n            }\\n        }\\n        return distance[m-1][n-1];\\n    }\\n}\\nclass triple {\\n    int x, y, obs;\\n    triple(int x, int y, int obs){\\n        this.x = x;\\n        this.y = y;\\n        this.obs = obs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int [][]distance = new int[m][n];\\n        int [][]directions = {{0, 1}, {0, -1}, {1, 0},{-1, 0}};\\n        for(int []arr : distance) Arrays.fill(arr, Integer.MAX_VALUE);\\n        Deque<triple> dq = new ArrayDeque<>();\\n        dq.add(new triple(0, 0, 0));\\n        distance[0][0] = 0;\\n        while(!dq.isEmpty()){\\n            triple curr = dq.remove();\\n            int x = curr.x;\\n            int y = curr.y;\\n            int obs = curr.obs;\\n            for(int []dir : directions){\\n                int xx = x + dir[0];\\n                int yy = y + dir[1];\\n                if(xx < 0 || xx >= m || yy < 0 || yy >= n){ continue;}\\n                if(grid[xx][yy] + obs < distance[xx][yy]){\\n                    distance[xx][yy] = grid[xx][yy] + obs;\\n                    if(grid[xx][yy] == 0) dq.addFirst(new triple(xx,yy,distance[xx][yy]));\\n                    else dq.addLast(new triple(xx,yy,distance[xx][yy]));\\n                }\\n            }\\n        }\\n        return distance[m-1][n-1];\\n    }\\n}\\nclass triple {\\n    int x, y, obs;\\n    triple(int x, int y, int obs){\\n        this.x = x;\\n        this.y = y;\\n        this.obs = obs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764025,
                "title": "python3-minheap-solution-very-easy-and-beginner-friendly",
                "content": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        R,C=len(grid),len(grid[0])\\n        minHeap=[]\\n        heappush(minHeap,[0,0,0])\\n        visited=[[0]*C for _ in range(R)]\\n        while minHeap:\\n            minObstacles,r,c=heappop(minHeap)\\n            if r==R-1 and c==C-1:\\n                return minObstacles\\n            for newR,newC in [[r+1,c],[r-1,c],[r,c+1],[r,c-1]]:\\n                if newR in range(R) and newC in range(C) and visited[newR][newC]==0:\\n                    if grid[newR][newC]:\\n                        heappush(minHeap,[minObstacles+1,newR,newC])\\n                    else:\\n                        heappush(minHeap,[minObstacles,newR,newC])\\n                    visited[newR][newC]=1\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        R,C=len(grid),len(grid[0])\\n        minHeap=[]\\n        heappush(minHeap,[0,0,0])\\n        visited=[[0]*C for _ in range(R)]\\n        while minHeap:\\n            minObstacles,r,c=heappop(minHeap)\\n            if r==R-1 and c==C-1:\\n                return minObstacles\\n            for newR,newC in [[r+1,c],[r-1,c],[r,c+1],[r,c-1]]:\\n                if newR in range(R) and newC in range(C) and visited[newR][newC]==0:\\n                    if grid[newR][newC]:\\n                        heappush(minHeap,[minObstacles+1,newR,newC])\\n                    else:\\n                        heappush(minHeap,[minObstacles,newR,newC])\\n                    visited[newR][newC]=1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763692,
                "title": "my-solution",
                "content": "**1. Use the `std::priority_queue`**\\n```\\n/**\\n * Time Complexity: O(rows * cols * log(rows * cols))\\n * Space Complexity: O(rows * cols)\\n * where `rows` is the number of the rows of the grid `grid`\\n *       `cols` is the number of the columns of the grid `grid`\\n */\\nclass Solution {\\n public:\\n  int minimumObstacles(const vector<vector<int>> &grid) {\\n    using pq_node_t = tuple<int, int, int>;   // {the number of erased obtacles, the row, the column}\\n    constexpr int directions[] = {0, 1, 0, -1, 0};\\n    constexpr int n_directions = 4;\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    priority_queue<pq_node_t, vector<pq_node_t>, greater<>> pq;\\n    bool visited[rows][cols];\\n    memset(visited, 0, sizeof(visited));\\n    pq.emplace(0, 0, 0);\\n    while (!pq.empty()) {\\n      const auto [e, r, c] = pq.top();\\n      if (r == rows - 1 && c == cols - 1) {\\n        return e;\\n      }\\n      pq.pop();\\n      if (visited[r][c]) {\\n        continue;\\n      }\\n      visited[r][c] = true;\\n      for (int d = 0; d < n_directions; ++d) {\\n        const int nr = r + directions[d];\\n        const int nc = c + directions[d + 1];\\n        if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && !visited[nr][nc]) {\\n          pq.emplace(e + grid[nr][nc], nr, nc);\\n        }\\n      }\\n    }\\n    throw \"impossible path\";\\n  }\\n};\\n```\\n**2. Use the `0-1 BFS`**\\n```\\n/**\\n * Time Complexity: O(rows * cols)\\n * Space Complexity: O(rows * cols)\\n * where `rows` is the number of the rows of the grid `grid`\\n *       `cols` is the number of the columns of the grid `grid`\\n */\\nclass Solution {\\n public:\\n  int minimumObstacles(const vector<vector<int>> &grid) {\\n    using dq_node_t = tuple<int, int, int>;   // {the number of erased obtacles, the row, the column}\\n    constexpr int directions[] = {0, 1, 0, -1, 0};\\n    constexpr int n_directions = 4;\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    deque<dq_node_t> dq;\\n    bool visited[rows][cols];\\n    memset(visited, 0, sizeof(visited));\\n    dq.emplace_back(0, 0, 0);\\n    while (!dq.empty()) {\\n      const auto [e, r, c] = dq.front();\\n      if (r == rows - 1 && c == cols - 1) {\\n        return e;\\n      }\\n      dq.pop_front();\\n      if (visited[r][c]) {\\n        continue;\\n      }\\n      visited[r][c] = true;\\n      for (int d = 0; d < n_directions; ++d) {\\n        const int nr = r + directions[d];\\n        const int nc = c + directions[d + 1];\\n        if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && !visited[nr][nc]) {\\n          if (grid[nr][nc] == 0) {\\n            dq.emplace_front(e, nr, nc);\\n          } else {\\n            dq.emplace_back(e + 1, nr, nc);\\n          }\\n        }\\n      }\\n    }\\n    throw \"impossible path\";\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(rows * cols * log(rows * cols))\\n * Space Complexity: O(rows * cols)\\n * where `rows` is the number of the rows of the grid `grid`\\n *       `cols` is the number of the columns of the grid `grid`\\n */\\nclass Solution {\\n public:\\n  int minimumObstacles(const vector<vector<int>> &grid) {\\n    using pq_node_t = tuple<int, int, int>;   // {the number of erased obtacles, the row, the column}\\n    constexpr int directions[] = {0, 1, 0, -1, 0};\\n    constexpr int n_directions = 4;\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    priority_queue<pq_node_t, vector<pq_node_t>, greater<>> pq;\\n    bool visited[rows][cols];\\n    memset(visited, 0, sizeof(visited));\\n    pq.emplace(0, 0, 0);\\n    while (!pq.empty()) {\\n      const auto [e, r, c] = pq.top();\\n      if (r == rows - 1 && c == cols - 1) {\\n        return e;\\n      }\\n      pq.pop();\\n      if (visited[r][c]) {\\n        continue;\\n      }\\n      visited[r][c] = true;\\n      for (int d = 0; d < n_directions; ++d) {\\n        const int nr = r + directions[d];\\n        const int nc = c + directions[d + 1];\\n        if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && !visited[nr][nc]) {\\n          pq.emplace(e + grid[nr][nc], nr, nc);\\n        }\\n      }\\n    }\\n    throw \"impossible path\";\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(rows * cols)\\n * Space Complexity: O(rows * cols)\\n * where `rows` is the number of the rows of the grid `grid`\\n *       `cols` is the number of the columns of the grid `grid`\\n */\\nclass Solution {\\n public:\\n  int minimumObstacles(const vector<vector<int>> &grid) {\\n    using dq_node_t = tuple<int, int, int>;   // {the number of erased obtacles, the row, the column}\\n    constexpr int directions[] = {0, 1, 0, -1, 0};\\n    constexpr int n_directions = 4;\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    deque<dq_node_t> dq;\\n    bool visited[rows][cols];\\n    memset(visited, 0, sizeof(visited));\\n    dq.emplace_back(0, 0, 0);\\n    while (!dq.empty()) {\\n      const auto [e, r, c] = dq.front();\\n      if (r == rows - 1 && c == cols - 1) {\\n        return e;\\n      }\\n      dq.pop_front();\\n      if (visited[r][c]) {\\n        continue;\\n      }\\n      visited[r][c] = true;\\n      for (int d = 0; d < n_directions; ++d) {\\n        const int nr = r + directions[d];\\n        const int nc = c + directions[d + 1];\\n        if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && !visited[nr][nc]) {\\n          if (grid[nr][nc] == 0) {\\n            dq.emplace_front(e, nr, nc);\\n          } else {\\n            dq.emplace_back(e + 1, nr, nc);\\n          }\\n        }\\n      }\\n    }\\n    throw \"impossible path\";\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702294,
                "title": "c-dijkstra-simple-observation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int R[4]={-1,1,0,0};\\n    const int C[4]={0,0,-1,1};\\n    //wall=>cost=1\\n    // else cost=0; \\n    void dijkstra(int srcx,int srcy,vector<vector<int>>&grid,vector<vector<int>>&dist,int n,int m){\\n         dist[srcx][srcy]=(grid[srcx][srcy]==1);\\n         set<array<int,3>> toExplore;\\n         toExplore.insert({0,srcx,srcy});\\n         while(toExplore.size()){\\n             array<int,3> top=*toExplore.begin();\\n             int distancesofar=top[0];\\n             int x=top[1];\\n             int y=top[2];\\n             toExplore.erase(top);\\n             for(int dr=0;dr<4;dr++){\\n                 int newx=x+C[dr];\\n                 int newy=y+R[dr];\\n                 if(!(newx>=0 and newx<=n-1 and newy>=0 and newy<=m-1)){\\n                     continue;\\n                 }\\n                 int addeddist=(grid[newx][newy]==1);\\n                 int newdist=addeddist+dist[x][y];\\n                 if(dist[newx][newy]>newdist){\\n                     toExplore.erase({dist[newx][newy],newx,newy});\\n                     dist[newx][newy]=newdist;\\n                     toExplore.insert({dist[newx][newy],newx,newy});\\n                 }\\n             }\\n         }\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dist(n,vector<int>(m,1e9));\\n        dijkstra(0,0,grid,dist,n,m);\\n        return dist[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int R[4]={-1,1,0,0};\\n    const int C[4]={0,0,-1,1};\\n    //wall=>cost=1\\n    // else cost=0; \\n    void dijkstra(int srcx,int srcy,vector<vector<int>>&grid,vector<vector<int>>&dist,int n,int m){\\n         dist[srcx][srcy]=(grid[srcx][srcy]==1);\\n         set<array<int,3>> toExplore;\\n         toExplore.insert({0,srcx,srcy});\\n         while(toExplore.size()){\\n             array<int,3> top=*toExplore.begin();\\n             int distancesofar=top[0];\\n             int x=top[1];\\n             int y=top[2];\\n             toExplore.erase(top);\\n             for(int dr=0;dr<4;dr++){\\n                 int newx=x+C[dr];\\n                 int newy=y+R[dr];\\n                 if(!(newx>=0 and newx<=n-1 and newy>=0 and newy<=m-1)){\\n                     continue;\\n                 }\\n                 int addeddist=(grid[newx][newy]==1);\\n                 int newdist=addeddist+dist[x][y];\\n                 if(dist[newx][newy]>newdist){\\n                     toExplore.erase({dist[newx][newy],newx,newy});\\n                     dist[newx][newy]=newdist;\\n                     toExplore.insert({dist[newx][newy],newx,newy});\\n                 }\\n             }\\n         }\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dist(n,vector<int>(m,1e9));\\n        dijkstra(0,0,grid,dist,n,m);\\n        return dist[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669169,
                "title": "faster-than-100-djikstra-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is a problem of finding the path with minimal weight from a point to another, therefore djikstra algorithm is perfectly fitted for this.\\nThe grid can be considered as a graph, where each cell is connected to its 4 neighbours with a weights that is either 0 if the neighbour cell is empty, and 1 if the neighbour cell contains an obstacle.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe djikstra algorithm works by considering each time the available unexplored edge with minimal weight. It is very similar to the BFS algorithm, but instead of using a simple queue, a heap is normally used to maintain ordering of weights.\\nBut in this case, we only have two weights for each edge : 0 (no obstacle) and 1. Using a heap structure for this is a huge overkill.\\n**Instead of using a heap to maintain the ordering of the edges to look at, we will use two queues** : \\n- A queue for edges with a weight of 0\\n- A queue for edges with a weight of 1\\n\\nWith this two queues, we only need to look at the leftmost edge (the one that was pushed the earlier) in the ZERO QUEUE if it isn\\'t empty, and if it is, we will look at the leftmost edge in the ONE QUEUE.\\n\\nThe algorithm ends when we reach the final cell.\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minimumObstacles(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n\\n        explored = [[False]*len(grid[0]) for i in range(len(grid))]\\n        explored[0][0] = True\\n\\n        zero_queue = collections.deque()\\n        one_queue = collections.deque()\\n        zero_queue.append((0, 0, 0))\\n\\n        while zero_queue or one_queue:\\n            \\n            x, y, w = zero_queue.popleft() if zero_queue else one_queue.popleft()   \\n\\n            if x == len(grid)-1 and y == len(grid[0])-1:\\n                return w\\n\\n            if x > 0 and not explored[x-1][y]:\\n                explored[x-1][y] = True\\n                if grid[x-1][y]:\\n                    one_queue.append((x-1, y, w+1))\\n                else:\\n                    zero_queue.append((x-1, y, w))\\n            if x<len(grid)-1 and not explored[x+1][y]:\\n                explored[x+1][y] = True\\n                if grid[x+1][y]:\\n                    one_queue.append((x+1, y, w+1))\\n                else:\\n                    zero_queue.append((x+1, y, w))\\n            if y > 0 and not explored[x][y-1]:\\n                explored[x][y-1] = True\\n                if grid[x][y-1]:\\n                    one_queue.append((x, y-1, w+1))\\n                else:\\n                    zero_queue.append((x, y-1, w))\\n            if y<len(grid[0])-1 and not explored[x][y+1]:\\n                explored[x][y+1] = True\\n                if grid[x][y+1]:\\n                    one_queue.append((x, y+1, w+1))\\n                else:\\n                    zero_queue.append((x, y+1, w))\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimumObstacles(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n\\n        explored = [[False]*len(grid[0]) for i in range(len(grid))]\\n        explored[0][0] = True\\n\\n        zero_queue = collections.deque()\\n        one_queue = collections.deque()\\n        zero_queue.append((0, 0, 0))\\n\\n        while zero_queue or one_queue:\\n            \\n            x, y, w = zero_queue.popleft() if zero_queue else one_queue.popleft()   \\n\\n            if x == len(grid)-1 and y == len(grid[0])-1:\\n                return w\\n\\n            if x > 0 and not explored[x-1][y]:\\n                explored[x-1][y] = True\\n                if grid[x-1][y]:\\n                    one_queue.append((x-1, y, w+1))\\n                else:\\n                    zero_queue.append((x-1, y, w))\\n            if x<len(grid)-1 and not explored[x+1][y]:\\n                explored[x+1][y] = True\\n                if grid[x+1][y]:\\n                    one_queue.append((x+1, y, w+1))\\n                else:\\n                    zero_queue.append((x+1, y, w))\\n            if y > 0 and not explored[x][y-1]:\\n                explored[x][y-1] = True\\n                if grid[x][y-1]:\\n                    one_queue.append((x, y-1, w+1))\\n                else:\\n                    zero_queue.append((x, y-1, w))\\n            if y<len(grid[0])-1 and not explored[x][y+1]:\\n                explored[x][y+1] = True\\n                if grid[x][y+1]:\\n                    one_queue.append((x, y+1, w+1))\\n                else:\\n                    zero_queue.append((x, y+1, w))\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632746,
                "title": "bfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n   int minimumObstacles(vector<vector<int>> &grid)\\n{\\n    int n = grid.size();\\n    int m = grid[0].size();\\n\\n    int rr[] = {-1, 0, 1, 0};\\n    int cc[] = {0, 1, 0, -1};\\n\\n    vector<vector<int>> visited(n, vector<int>(m, 0));\\n    vector<vector<int>> distance(n, vector<int>(m, 1e9));\\n    distance[0][0] = 1;\\n\\n    deque<pair<int, int>> q;\\n    q.push_back({0, 0});\\n\\n    while (!q.empty())\\n    {\\n        int row = q.front().first;\\n        int col = q.front().second;\\n        q.pop_front();\\n\\n        for (int i = 0; i < 4; i++)\\n        {\\n            int r = row + rr[i];\\n            int c = col + cc[i];\\n\\n            if (r < n and r >= 0 and c < m and c >= 0 and !visited[r][c])\\n            {\\n                visited[r][c] = 1;\\n                if (grid[r][c] == 1)\\n                {\\n                    q.push_back({r, c});\\n                    distance[r][c] = 1 + distance[row][col];\\n                }\\n                else\\n                {\\n                    q.push_front({r, c});\\n                    distance[r][c] = distance[row][col];\\n                }\\n            }\\n        }\\n    }\\n\\n    return distance[n - 1][m - 1] - 1;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int minimumObstacles(vector<vector<int>> &grid)\\n{\\n    int n = grid.size();\\n    int m = grid[0].size();\\n\\n    int rr[] = {-1, 0, 1, 0};\\n    int cc[] = {0, 1, 0, -1};\\n\\n    vector<vector<int>> visited(n, vector<int>(m, 0));\\n    vector<vector<int>> distance(n, vector<int>(m, 1e9));\\n    distance[0][0] = 1;\\n\\n    deque<pair<int, int>> q;\\n    q.push_back({0, 0});\\n\\n    while (!q.empty())\\n    {\\n        int row = q.front().first;\\n        int col = q.front().second;\\n        q.pop_front();\\n\\n        for (int i = 0; i < 4; i++)\\n        {\\n            int r = row + rr[i];\\n            int c = col + cc[i];\\n\\n            if (r < n and r >= 0 and c < m and c >= 0 and !visited[r][c])\\n            {\\n                visited[r][c] = 1;\\n                if (grid[r][c] == 1)\\n                {\\n                    q.push_back({r, c});\\n                    distance[r][c] = 1 + distance[row][col];\\n                }\\n                else\\n                {\\n                    q.push_front({r, c});\\n                    distance[r][c] = distance[row][col];\\n                }\\n            }\\n        }\\n    }\\n\\n    return distance[n - 1][m - 1] - 1;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618313,
                "title": "java-0-1-bfs-deque",
                "content": "```\\nclass Solution {\\n    int[][] directions = {{1,0},{-1,0},{0,1},{0,-1}};\\n    public int minimumObstacles(int[][] grid) {\\n        \\n        int endX = grid.length - 1;\\n        int endY = grid[0].length - 1;\\n        \\n        //0-1 BFS traversal(dequeue rather than priority queue)\\n        int[][] dist = new int[endX + 1][endY + 1];\\n        \\n        for(int[] arr : dist){\\n            Arrays.fill(arr,Integer.MAX_VALUE);\\n        }\\n        \\n        Deque<Pair> dq = new ArrayDeque<Pair>();\\n        \\n        dq.addFirst(new Pair(0,0,0));\\n        dist[0][0] = 0;\\n        \\n        while(!dq.isEmpty()){\\n            \\n            Pair last = dq.removeFirst();\\n            \\n            int x = last.x;\\n            int y = last.y;\\n            int obs = last.obs;\\n            \\n            for(int[] dir : directions){\\n                \\n                int xx = x + dir[0];\\n                int yy = y + dir[1];\\n                \\n                if(xx < 0 || yy < 0 || xx > endX || yy > endY){\\n                    continue;\\n                }\\n                \\n                if(dist[xx][yy] > grid[xx][yy] + obs){\\n                    \\n                    dist[xx][yy] = grid[xx][yy] + obs;\\n                        \\n                    if(grid[xx][yy] == 0){\\n                        //add first\\n                        dq.addFirst(new Pair(xx,yy,dist[xx][yy]));\\n                        \\n                    }else if(grid[xx][yy] == 1){\\n                        //add last\\n                         dq.addLast(new Pair(xx,yy,dist[xx][yy]));\\n                    }\\n                    \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        \\n        return dist[endX][endY];\\n    }\\n}\\n\\nclass Pair{\\n    int x;\\n    int y;\\n    int obs;\\n    \\n    public Pair(int x , int y, int obs){\\n        this.x = x;\\n        this.y = y;\\n        this.obs = obs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    int[][] directions = {{1,0},{-1,0},{0,1},{0,-1}};\\n    public int minimumObstacles(int[][] grid) {\\n        \\n        int endX = grid.length - 1;\\n        int endY = grid[0].length - 1;\\n        \\n        //0-1 BFS traversal(dequeue rather than priority queue)\\n        int[][] dist = new int[endX + 1][endY + 1];\\n        \\n        for(int[] arr : dist){\\n            Arrays.fill(arr,Integer.MAX_VALUE);\\n        }\\n        \\n        Deque<Pair> dq = new ArrayDeque<Pair>();\\n        \\n        dq.addFirst(new Pair(0,0,0));\\n        dist[0][0] = 0;\\n        \\n        while(!dq.isEmpty()){\\n            \\n            Pair last = dq.removeFirst();\\n            \\n            int x = last.x;\\n            int y = last.y;\\n            int obs = last.obs;\\n            \\n            for(int[] dir : directions){\\n                \\n                int xx = x + dir[0];\\n                int yy = y + dir[1];\\n                \\n                if(xx < 0 || yy < 0 || xx > endX || yy > endY){\\n                    continue;\\n                }\\n                \\n                if(dist[xx][yy] > grid[xx][yy] + obs){\\n                    \\n                    dist[xx][yy] = grid[xx][yy] + obs;\\n                        \\n                    if(grid[xx][yy] == 0){\\n                        //add first\\n                        dq.addFirst(new Pair(xx,yy,dist[xx][yy]));\\n                        \\n                    }else if(grid[xx][yy] == 1){\\n                        //add last\\n                         dq.addLast(new Pair(xx,yy,dist[xx][yy]));\\n                    }\\n                    \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        \\n        return dist[endX][endY];\\n    }\\n}\\n\\nclass Pair{\\n    int x;\\n    int y;\\n    int obs;\\n    \\n    public Pair(int x , int y, int obs){\\n        this.x = x;\\n        this.y = y;\\n        this.obs = obs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579908,
                "title": "0-1-bfs-c-readable-variable-names",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    //check for valid index\\n    bool isValid(int r, int c, const vector<vector<int>>& grid)\\n    {\\n        return r >= 0 && c >= 0 \\n            && r < grid.size() && c < grid.front().size();\\n    }\\n    \\n    int minimumObstacles(vector<vector<int>>& grid) \\n    {\\n        if(grid.empty())\\n            return 0;\\n        \\n        int nRows = grid.size();\\n        int nCols = grid.front().size();\\n        \\n        deque<pair<int,int>> dque;\\n        //initialize all costs to INT_MAX\\n        vector<vector<int>> min_cost(nRows, vector<int>(nCols, INT_MAX));\\n        \\n        //set the starting position cost to zero\\n        min_cost[0][0] = 0;\\n        dque.push_front({0,0});\\n        \\n        while(!dque.empty())\\n        {\\n            int curr_r = dque.front().first;\\n            int curr_c = dque.front().second;\\n            int curr_cost = min_cost[curr_r][curr_c];\\n            dque.pop_front();\\n            \\n            //found target\\n            if(curr_r== nRows-1 && curr_c == nCols-1)\\n                return min_cost[curr_r][curr_c];\\n            \\n            \\n            array<array<int,2>,4> directions{{{0,1}, {1,0}, {0,-1},{-1,0}}};\\n            \\n            for(auto d : directions)\\n            {\\n                int r = curr_r + d[0];\\n                int c = curr_c + d[1];\\n                \\n                //if invalid cells or if cell already visited\\n                if(!isValid(r,c,grid) || grid[r][c] == 2)\\n                    continue;\\n                \\n            \\n                // if this neigboring cell is not an obstacle,then its cost\\n                // is the same as the current cell\\n                int neighbor_local_cost = grid[r][c] == 0? curr_cost : curr_cost + 1;\\n                min_cost[r][c] = neighbor_local_cost;\\n                \\n                //mark as visited\\n                grid[r][c] = 2;\\n                \\n        \\n                if(neighbor_local_cost == curr_cost)\\n                    dque.push_front({r,c});\\n                else\\n                    dque.push_back({r,c}); \\n            }\\n            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    //check for valid index\\n    bool isValid(int r, int c, const vector<vector<int>>& grid)\\n    {\\n        return r >= 0 && c >= 0 \\n            && r < grid.size() && c < grid.front().size();\\n    }\\n    \\n    int minimumObstacles(vector<vector<int>>& grid) \\n    {\\n        if(grid.empty())\\n            return 0;\\n        \\n        int nRows = grid.size();\\n        int nCols = grid.front().size();\\n        \\n        deque<pair<int,int>> dque;\\n        //initialize all costs to INT_MAX\\n        vector<vector<int>> min_cost(nRows, vector<int>(nCols, INT_MAX));\\n        \\n        //set the starting position cost to zero\\n        min_cost[0][0] = 0;\\n        dque.push_front({0,0});\\n        \\n        while(!dque.empty())\\n        {\\n            int curr_r = dque.front().first;\\n            int curr_c = dque.front().second;\\n            int curr_cost = min_cost[curr_r][curr_c];\\n            dque.pop_front();\\n            \\n            //found target\\n            if(curr_r== nRows-1 && curr_c == nCols-1)\\n                return min_cost[curr_r][curr_c];\\n            \\n            \\n            array<array<int,2>,4> directions{{{0,1}, {1,0}, {0,-1},{-1,0}}};\\n            \\n            for(auto d : directions)\\n            {\\n                int r = curr_r + d[0];\\n                int c = curr_c + d[1];\\n                \\n                //if invalid cells or if cell already visited\\n                if(!isValid(r,c,grid) || grid[r][c] == 2)\\n                    continue;\\n                \\n            \\n                // if this neigboring cell is not an obstacle,then its cost\\n                // is the same as the current cell\\n                int neighbor_local_cost = grid[r][c] == 0? curr_cost : curr_cost + 1;\\n                min_cost[r][c] = neighbor_local_cost;\\n                \\n                //mark as visited\\n                grid[r][c] = 2;\\n                \\n        \\n                if(neighbor_local_cost == curr_cost)\\n                    dque.push_front({r,c});\\n                else\\n                    dque.push_back({r,c}); \\n            }\\n            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565304,
                "title": "minheap-bfs-easy-to-understand",
                "content": "# Intuition\\nusing priority queue in Breadth first search to find the path with least number of obstacles removed path.\\n\\n# Approach\\ninitialized  min heap with initial number of obstacles as 0,coordinates and present cell values.\\nBy iterating the que till end we will pop the values based on minimum number os obstacles path . \\nby Repeatedly popping and applying bfs to that respective cell at a particular point of time we will reach the Last coordinate , then we will return our number of obstacles removed count.\\n\\n# Complexity\\n- Time complexity:\\n O(M*N) where M=len(grid) and N= len(grid[0])\\n\\n- Space complexity:\\n O(N) used for Que  and Visit set.\\n\\n# Code\\n```\\nimport heapq\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        direc=[(1,0),(0,1),(-1,0),(0,-1)]\\n\\n        que=[[grid[0][0],grid[0][0],0,0]]\\n        \\n        visit=set()\\n        z=[]\\n        while que:\\n\\n\\n            for i in range(len(que)):\\n                obs,val,i,j=heapq.heappop(que)\\n    \\n                if i==len(grid)-1 and j==len(grid[0])-1:\\n                    return obs\\n\\n                if (i,j) in visit:\\n                    continue\\n\\n                visit.add((i,j))\\n\\n                \\n\\n                for r,c in direc:\\n                    row=r+i\\n                    col=c+j\\n\\n                    if row>=0 and col >=0 and row<len(grid) and col<len(grid[0]):\\n\\n                        heapq.heappush(que,(obs+grid[row][col],grid[row][col],row,col))\\n       \\n                    \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Heap (Priority Queue)",
                    "Iterator"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        direc=[(1,0),(0,1),(-1,0),(0,-1)]\\n\\n        que=[[grid[0][0],grid[0][0],0,0]]\\n        \\n        visit=set()\\n        z=[]\\n        while que:\\n\\n\\n            for i in range(len(que)):\\n                obs,val,i,j=heapq.heappop(que)\\n    \\n                if i==len(grid)-1 and j==len(grid[0])-1:\\n                    return obs\\n\\n                if (i,j) in visit:\\n                    continue\\n\\n                visit.add((i,j))\\n\\n                \\n\\n                for r,c in direc:\\n                    row=r+i\\n                    col=c+j\\n\\n                    if row>=0 and col >=0 and row<len(grid) and col<len(grid[0]):\\n\\n                        heapq.heappush(que,(obs+grid[row][col],grid[row][col],row,col))\\n       \\n                    \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552657,
                "title": "simple-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        M = len(grid)\\n        N = len(grid[0])\\n\\n        def dfs(row, col): # search through obstacle free path\\n            if (row, col) == (M-1, N-1):\\n                return True\\n            for d in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\\n                nrow, ncol = row + d[0], col + d[1]\\n                if (0 <= nrow < M) and (0 <= ncol < N) and ((nrow, ncol) not in visited):\\n                    if grid[nrow][ncol]:\\n                        obstacles.append((nrow, ncol))\\n                        visited.add((nrow, ncol))\\n                    else:\\n                        visited.add((nrow, ncol))\\n                        if dfs(nrow, ncol):\\n                            return True\\n            return False\\n        current = [(0, 0)]\\n        visited = set(current)\\n        for num_obstacles in count():\\n            obstacles = []\\n            for row, col in current:\\n                if dfs(row, col):\\n                    return num_obstacles\\n            current = obstacles\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        M = len(grid)\\n        N = len(grid[0])\\n\\n        def dfs(row, col): # search through obstacle free path\\n            if (row, col) == (M-1, N-1):\\n                return True\\n            for d in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\\n                nrow, ncol = row + d[0], col + d[1]\\n                if (0 <= nrow < M) and (0 <= ncol < N) and ((nrow, ncol) not in visited):\\n                    if grid[nrow][ncol]:\\n                        obstacles.append((nrow, ncol))\\n                        visited.add((nrow, ncol))\\n                    else:\\n                        visited.add((nrow, ncol))\\n                        if dfs(nrow, ncol):\\n                            return True\\n            return False\\n        current = [(0, 0)]\\n        visited = set(current)\\n        for num_obstacles in count():\\n            obstacles = []\\n            for row, col in current:\\n                if dfs(row, col):\\n                    return num_obstacles\\n            current = obstacles\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551415,
                "title": "simple-c-solution-with-clear-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nque looks like shortest path type. que can be solved using dijkstra with small variation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. here we will have a 2-D arr and v[r][c] -> no of obstacle removed to reach the {r,c}.in original dijkstra v[r][c] ->  shortest distance to reach {r,c}. (we can use dijkstra algo). \\n2. in priority_queue we will store {v[r][c],{r,c}}.\\nremember in original dijkstra we store the {distnace,node} but in matrix node is nothing but {r,c}.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m*log(n*m))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n         priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;\\n\\n        vector <vector<int>> v(n,vector<int>(m,1e9));\\n        \\n        v[0][0]=grid[0][0];\\n        //in simple dijkstra we store{dist,node} -> in matrix node is given by {r,c} \\n        pq.push({v[0][0],{0,0}}); // {dist,{r,c}}\\n        int delrow[4] = {-1,0,1,0};\\n        int delcol[4] = {0,1,0,-1};\\n\\n        while(!pq.empty()){\\n            int dist = pq.top().first;\\n            int r = pq.top().second.first;\\n            int c = pq.top().second.second;\\n            pq.pop();\\n\\n            for(int i=0;i<4;i++){\\n                int nrow = r+delrow[i];\\n                int ncol = c+delcol[i];\\n\\n                if(nrow<n && nrow>=0 && ncol<m && ncol>=0){\\n                    if(dist+grid[nrow][ncol] < v[nrow][ncol]){\\n                        v[nrow][ncol] = dist+grid[nrow][ncol];\\n                        pq.push({v[nrow][ncol],{nrow,ncol}});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return v[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n         priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;\\n\\n        vector <vector<int>> v(n,vector<int>(m,1e9));\\n        \\n        v[0][0]=grid[0][0];\\n        //in simple dijkstra we store{dist,node} -> in matrix node is given by {r,c} \\n        pq.push({v[0][0],{0,0}}); // {dist,{r,c}}\\n        int delrow[4] = {-1,0,1,0};\\n        int delcol[4] = {0,1,0,-1};\\n\\n        while(!pq.empty()){\\n            int dist = pq.top().first;\\n            int r = pq.top().second.first;\\n            int c = pq.top().second.second;\\n            pq.pop();\\n\\n            for(int i=0;i<4;i++){\\n                int nrow = r+delrow[i];\\n                int ncol = c+delcol[i];\\n\\n                if(nrow<n && nrow>=0 && ncol<m && ncol>=0){\\n                    if(dist+grid[nrow][ncol] < v[nrow][ncol]){\\n                        v[nrow][ncol] = dist+grid[nrow][ncol];\\n                        pq.push({v[nrow][ncol],{nrow,ncol}});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return v[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525763,
                "title": "easy-bfs-runtime-178-ms-beats-72-73",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumObstacles(int[][] arr) {\\n        \\n        int n = arr.length, m = arr[0].length;\\n\\n        Queue< int[] > queue = new LinkedList<>();\\n\\n        queue.add(new int[]{0,0});\\n\\n        int[][] cnt = new int[n][m];\\n\\n        for(int[] a : cnt) Arrays.fill(a,1000000);\\n\\n        cnt[0][0] = 0;\\n\\n        while(!queue.isEmpty()){\\n\\n            int[] cur = queue.remove();\\n\\n            int i = cur[0], j = cur[1];\\n            int add = 0;\\n            if(arr[i][j] == 1) add++;\\n\\n            if(i + 1 < n && cnt[i + 1][j] > cnt[i][j] + add){\\n                cnt[i + 1][j] = cnt[i][j] + add;\\n                queue.add(new int[]{i + 1, j});\\n            }\\n            if(j + 1 < m && cnt[i][j + 1] > cnt[i][j] + add){\\n                cnt[i][j + 1] = cnt[i][j] + add;\\n                queue.add(new int[]{i,j + 1});\\n            }\\n            if(i - 1 >= 0 && cnt[i - 1][j] > cnt[i][j] + add){\\n                cnt[i - 1][j] = cnt[i][j] + add;\\n                queue.add(new int[]{i - 1, j});\\n            }\\n            if(j - 1>= 0 && cnt[i][j - 1] > cnt[i][j] + add){\\n                cnt[i][j - 1] = cnt[i][j] + add;\\n                queue.add(new int[]{i, j - 1});\\n            }\\n        }\\n\\n        return cnt[n - 1][m -1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumObstacles(int[][] arr) {\\n        \\n        int n = arr.length, m = arr[0].length;\\n\\n        Queue< int[] > queue = new LinkedList<>();\\n\\n        queue.add(new int[]{0,0});\\n\\n        int[][] cnt = new int[n][m];\\n\\n        for(int[] a : cnt) Arrays.fill(a,1000000);\\n\\n        cnt[0][0] = 0;\\n\\n        while(!queue.isEmpty()){\\n\\n            int[] cur = queue.remove();\\n\\n            int i = cur[0], j = cur[1];\\n            int add = 0;\\n            if(arr[i][j] == 1) add++;\\n\\n            if(i + 1 < n && cnt[i + 1][j] > cnt[i][j] + add){\\n                cnt[i + 1][j] = cnt[i][j] + add;\\n                queue.add(new int[]{i + 1, j});\\n            }\\n            if(j + 1 < m && cnt[i][j + 1] > cnt[i][j] + add){\\n                cnt[i][j + 1] = cnt[i][j] + add;\\n                queue.add(new int[]{i,j + 1});\\n            }\\n            if(i - 1 >= 0 && cnt[i - 1][j] > cnt[i][j] + add){\\n                cnt[i - 1][j] = cnt[i][j] + add;\\n                queue.add(new int[]{i - 1, j});\\n            }\\n            if(j - 1>= 0 && cnt[i][j - 1] > cnt[i][j] + add){\\n                cnt[i][j - 1] = cnt[i][j] + add;\\n                queue.add(new int[]{i, j - 1});\\n            }\\n        }\\n\\n        return cnt[n - 1][m -1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508793,
                "title": "bfs-pq",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is esay to use template. It makes me think a hard problem as tag, actually should be easier than most of the medium problem.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- while bfs, need to add the number of blocks, if there is, add 1\\n- if no block, just add 0 into the pq\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m * n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n# Code\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        ROWS, COLS = len(grid), len(grid[0])\\n        steps = 1 if grid[0][0] else 0\\n        pq = [(steps, 0, 0)]\\n        visited = set([(0, 0)])\\n        while pq:\\n            n, x, y = heappop(pq)\\n            if x == ROWS - 1 and y == COLS - 1:\\n                return n\\n            for dr, dc in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\\n                r, c = x + dr, y + dc\\n                if 0 <= r < ROWS and 0 <= c < COLS and (r, c) not in visited:\\n                    visited.add((r, c))\\n                    if grid[r][c]:\\n                        heappush(pq, (n + 1, r, c))\\n                    else:\\n                        heappush(pq, (n, r, c))\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        ROWS, COLS = len(grid), len(grid[0])\\n        steps = 1 if grid[0][0] else 0\\n        pq = [(steps, 0, 0)]\\n        visited = set([(0, 0)])\\n        while pq:\\n            n, x, y = heappop(pq)\\n            if x == ROWS - 1 and y == COLS - 1:\\n                return n\\n            for dr, dc in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\\n                r, c = x + dr, y + dc\\n                if 0 <= r < ROWS and 0 <= c < COLS and (r, c) not in visited:\\n                    visited.add((r, c))\\n                    if grid[r][c]:\\n                        heappush(pq, (n + 1, r, c))\\n                    else:\\n                        heappush(pq, (n, r, c))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489271,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>d={{1,0},{-1,0},{0,1},{0,-1}};\\n    int m,n;\\n    int minimumObstacles(vector<vector<int>>& arr) {\\n        m=arr.size();\\n        n=arr[0].size();\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        priority_queue<pair<int,vector<int>>,vector<pair<int,vector<int>>>,\\n        greater<pair<int,vector<int>>>>pq;\\n        dist[0][0]=0;\\n        pq.push({0,{0,0}});\\n        while(!pq.empty())\\n        {\\n            int dis=pq.top().first;\\n            int cr=pq.top().second[0];\\n            int cc=pq.top().second[1];\\n            pq.pop();\\n            if(dist[cr][cc]<dis)\\n            {\\n                continue;\\n            }\\n            for(int i=0;i<d.size();i++)\\n            {\\n                int row=cr+d[i][0];\\n                int col=cc+d[i][1];\\n                if(isvalid(row,col) and dis+arr[row][col]<dist[row][col])\\n                {\\n                    dist[row][col]=dis+arr[row][col];\\n                    pq.push({dist[row][col],{row,col}});\\n                }\\n            }\\n        }\\n        return dist[m-1][n-1];\\n    }\\n    bool isvalid(int &row,int &col)\\n    {\\n        if(row<0 or col<0 or row>=m or col>=n)\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>d={{1,0},{-1,0},{0,1},{0,-1}};\\n    int m,n;\\n    int minimumObstacles(vector<vector<int>>& arr) {\\n        m=arr.size();\\n        n=arr[0].size();\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        priority_queue<pair<int,vector<int>>,vector<pair<int,vector<int>>>,\\n        greater<pair<int,vector<int>>>>pq;\\n        dist[0][0]=0;\\n        pq.push({0,{0,0}});\\n        while(!pq.empty())\\n        {\\n            int dis=pq.top().first;\\n            int cr=pq.top().second[0];\\n            int cc=pq.top().second[1];\\n            pq.pop();\\n            if(dist[cr][cc]<dis)\\n            {\\n                continue;\\n            }\\n            for(int i=0;i<d.size();i++)\\n            {\\n                int row=cr+d[i][0];\\n                int col=cc+d[i][1];\\n                if(isvalid(row,col) and dis+arr[row][col]<dist[row][col])\\n                {\\n                    dist[row][col]=dis+arr[row][col];\\n                    pq.push({dist[row][col],{row,col}});\\n                }\\n            }\\n        }\\n        return dist[m-1][n-1];\\n    }\\n    bool isvalid(int &row,int &col)\\n    {\\n        if(row<0 or col<0 or row>=m or col>=n)\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417154,
                "title": "dijkstra-s-algo-on-grid",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nshortest path from 0 to n-1 in 0/1 weighted graph\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*m)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n*m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n       \\n\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        int dr[] = {1,0,-1,0};\\n        int dc[] = {0,1,0,-1};\\n\\n        set<pair<int,pair<int,int>>> st;\\n        st.insert({0,{0,0}});\\n        vector<vector<int>> dist(n,vector<int>(m,INT_MAX));\\n        dist[0][0] = 0;\\n        while(!st.empty()){\\n            auto it = *(st.begin());\\n            int wt = it.first;\\n            int x = it.second.first;\\n            int y = it.second.second;\\n            st.erase(it);\\n\\n            for(int k = 0; k < 4; k++){\\n                int nr = x+dr[k];\\n                int nc = y+dc[k];\\n                if(nr >= 0 and nr < n and nc >= 0 and nc < m){\\n                    int adjwt = grid[nr][nc];\\n                    if(adjwt+wt < dist[nr][nc]){\\n                        dist[nr][nc] = adjwt+wt;\\n                        st.insert({dist[nr][nc],{nr,nc}});\\n                    }\\n                }\\n            }\\n        }\\n        return dist[n-1][m-1];\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n       \\n\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        int dr[] = {1,0,-1,0};\\n        int dc[] = {0,1,0,-1};\\n\\n        set<pair<int,pair<int,int>>> st;\\n        st.insert({0,{0,0}});\\n        vector<vector<int>> dist(n,vector<int>(m,INT_MAX));\\n        dist[0][0] = 0;\\n        while(!st.empty()){\\n            auto it = *(st.begin());\\n            int wt = it.first;\\n            int x = it.second.first;\\n            int y = it.second.second;\\n            st.erase(it);\\n\\n            for(int k = 0; k < 4; k++){\\n                int nr = x+dr[k];\\n                int nc = y+dc[k];\\n                if(nr >= 0 and nr < n and nc >= 0 and nc < m){\\n                    int adjwt = grid[nr][nc];\\n                    if(adjwt+wt < dist[nr][nc]){\\n                        dist[nr][nc] = adjwt+wt;\\n                        st.insert({dist[nr][nc],{nr,nc}});\\n                    }\\n                }\\n            }\\n        }\\n        return dist[n-1][m-1];\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3402238,
                "title": "c",
                "content": "```\\nusing PII = pair<int, int> ; //{x, y}\\nclass Solution {\\n    int m, n ;\\n    int dirs[4][2] = {{0,1},{0,-1},{1,0},{-1,0}} ;\\n    vector<vector<int>> gothrough(vector<vector<int>>&grid, vector<vector<bool>>&visited, int x0, int y0){\\n        queue<PII>q ;\\n        q.push({x0, y0}) ;\\n        vector<vector<int>>ret ;\\n        while(!q.empty()){\\n            int sz = q.size() ;\\n            for(int len = 0; len < sz; len++)\\n            {\\n                auto [x, y] = q.front() ;\\n                q.pop() ;\\n                for(int k = 0; k < 4; k++){\\n                    int xx = x + dirs[k][0] ;\\n                    int yy = y + dirs[k][1] ;\\n                    if(xx < 0 || yy < 0 || xx >= m || yy >= n)\\n                        continue ;\\n                    if(visited[xx][yy])\\n                        continue ;\\n                    visited[xx][yy] = true ;\\n                    if(grid[xx][yy] == 1)\\n                        ret.push_back({xx,yy}) ;\\n                    else{\\n                        if(xx == m-1 && yy == n-1){\\n                            ret.push_back({xx, yy}) ;\\n                            return ret ;\\n                        }\\n                        q.push({xx,yy}) ;    \\n                    }\\n                }\\n            }\\n        }\\n        return ret ;\\n    }\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        m = grid.size() ;\\n        n = grid[0].size() ;\\n        vector<vector<bool>>visited(m, vector<bool>(n)) ;\\n        queue<PII>q ;\\n        q.push({0,0}) ;\\n        visited[0][0] = true ;\\n        int step = 0 ;\\n        while(!q.empty())\\n        {\\n            int sz = q.size() ;\\n            for(int len = 0; len < sz; len++)\\n            {\\n                auto [x,y] = q.front() ;\\n                q.pop() ;\\n                for(int k = 0; k < 4; k++){\\n                    int xx = x + dirs[k][0] ;\\n                    int yy = y + dirs[k][1] ;\\n                    if(xx < 0 || yy < 0 || xx >= m || yy >= n)\\n                        continue ;\\n                    if(visited[xx][yy])\\n                        continue ;\\n                    visited[xx][yy] = true ;\\n                    if(grid[xx][yy] == 1)\\n                        q.push({xx, yy}) ;\\n                    else{\\n                        if(xx == m-1 && yy == n-1)\\n                            return step ;\\n                        auto next = gothrough(grid, visited, xx, yy) ;\\n                        for(int i = next.size()-1; i >=0; i--){\\n                            if(next[i][0] == m-1 && next[i][1] == n-1)\\n                                return step ;\\n                            q.push({next[i][0], next[i][1]}) ;\\n                        }\\n                    }\\n                }\\n            }\\n            step++ ;\\n        }\\n        return -1 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nusing PII = pair<int, int> ; //{x, y}\\nclass Solution {\\n    int m, n ;\\n    int dirs[4][2] = {{0,1},{0,-1},{1,0},{-1,0}} ;\\n    vector<vector<int>> gothrough(vector<vector<int>>&grid, vector<vector<bool>>&visited, int x0, int y0){\\n        queue<PII>q ;\\n        q.push({x0, y0}) ;\\n        vector<vector<int>>ret ;\\n        while(!q.empty()){\\n            int sz = q.size() ;\\n            for(int len = 0; len < sz; len++)\\n            {\\n                auto [x, y] = q.front() ;\\n                q.pop() ;\\n                for(int k = 0; k < 4; k++){\\n                    int xx = x + dirs[k][0] ;\\n                    int yy = y + dirs[k][1] ;\\n                    if(xx < 0 || yy < 0 || xx >= m || yy >= n)\\n                        continue ;\\n                    if(visited[xx][yy])\\n                        continue ;\\n                    visited[xx][yy] = true ;\\n                    if(grid[xx][yy] == 1)\\n                        ret.push_back({xx,yy}) ;\\n                    else{\\n                        if(xx == m-1 && yy == n-1){\\n                            ret.push_back({xx, yy}) ;\\n                            return ret ;\\n                        }\\n                        q.push({xx,yy}) ;    \\n                    }\\n                }\\n            }\\n        }\\n        return ret ;\\n    }\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        m = grid.size() ;\\n        n = grid[0].size() ;\\n        vector<vector<bool>>visited(m, vector<bool>(n)) ;\\n        queue<PII>q ;\\n        q.push({0,0}) ;\\n        visited[0][0] = true ;\\n        int step = 0 ;\\n        while(!q.empty())\\n        {\\n            int sz = q.size() ;\\n            for(int len = 0; len < sz; len++)\\n            {\\n                auto [x,y] = q.front() ;\\n                q.pop() ;\\n                for(int k = 0; k < 4; k++){\\n                    int xx = x + dirs[k][0] ;\\n                    int yy = y + dirs[k][1] ;\\n                    if(xx < 0 || yy < 0 || xx >= m || yy >= n)\\n                        continue ;\\n                    if(visited[xx][yy])\\n                        continue ;\\n                    visited[xx][yy] = true ;\\n                    if(grid[xx][yy] == 1)\\n                        q.push({xx, yy}) ;\\n                    else{\\n                        if(xx == m-1 && yy == n-1)\\n                            return step ;\\n                        auto next = gothrough(grid, visited, xx, yy) ;\\n                        for(int i = next.size()-1; i >=0; i--){\\n                            if(next[i][0] == m-1 && next[i][1] == n-1)\\n                                return step ;\\n                            q.push({next[i][0], next[i][1]}) ;\\n                        }\\n                    }\\n                }\\n            }\\n            step++ ;\\n        }\\n        return -1 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298141,
                "title": "c-simple-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int n, m;\\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        this->n = grid.size();\\n        this->m = grid[0].size();\\n        vector<vector<int>> dir = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        auto comp = [&] (vector<int>& a, vector<int>& b) {\\n            return a[2] > b[2];\\n        };\\n        priority_queue<vector<int>, vector<vector<int>>, decltype(comp)> q(comp);\\n        vector<vector<int>> visited(n, vector<int>(m, n * m));\\n        visited[0][0] = 0;\\n        q.push({0, 0, 0});\\n        while (!q.empty()) {\\n            if (q.top()[0] == n - 1 && q.top()[1] == m - 1) return q.top()[2];\\n            vector<int> curr = q.top();\\n            q.pop();\\n            for (auto& d : dir) {\\n                int x = curr[0] + d[0], y = curr[1] + d[1];\\n                if (isbound(x, y) && curr[2] + grid[x][y] < visited[x][y]) {\\n                    visited[x][y] = curr[2] + grid[x][y];\\n                    q.push({x, y, visited[x][y]});\\n                }\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n    \\n    bool isbound(int x, int y) {\\n        if (x < 0 || x >= n || y < 0 || y >= m) return false;\\n        return true;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int n, m;\\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        this->n = grid.size();\\n        this->m = grid[0].size();\\n        vector<vector<int>> dir = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        auto comp = [&] (vector<int>& a, vector<int>& b) {\\n            return a[2] > b[2];\\n        };\\n        priority_queue<vector<int>, vector<vector<int>>, decltype(comp)> q(comp);\\n        vector<vector<int>> visited(n, vector<int>(m, n * m));\\n        visited[0][0] = 0;\\n        q.push({0, 0, 0});\\n        while (!q.empty()) {\\n            if (q.top()[0] == n - 1 && q.top()[1] == m - 1) return q.top()[2];\\n            vector<int> curr = q.top();\\n            q.pop();\\n            for (auto& d : dir) {\\n                int x = curr[0] + d[0], y = curr[1] + d[1];\\n                if (isbound(x, y) && curr[2] + grid[x][y] < visited[x][y]) {\\n                    visited[x][y] = curr[2] + grid[x][y];\\n                    q.push({x, y, visited[x][y]});\\n                }\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n    \\n    bool isbound(int x, int y) {\\n        if (x < 0 || x >= n || y < 0 || y >= m) return false;\\n        return true;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292761,
                "title": "easy-to-understand",
                "content": "\\n\\n\\n# Code\\n```\\nstruct node{\\n    int x,y,remove;\\n    node(int _x,int _y, int _remove){\\n        x=_x;\\n        y=_y;\\n        remove=_remove;\\n    }\\n};\\nclass Solution {\\npublic:\\n\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        deque<node> q;\\n        q.push_front(node(0,0,0));\\n        vector<vector<int>> d(n,vector<int>(m,m*n));\\n        while(!q.empty()){\\n            int x= q.front().x;\\n            int y= q.front().y;\\n            int rv=q.front().remove;\\n            q.pop_front();\\n            int dx[]={1,-1,0,0};\\n            int dy[]={0,0,1,-1};\\n\\n            for(int i=0;i<4;i++){\\n                int newX= x+dx[i];\\n                int newY= y+ dy[i];\\n                if(newX>=0 && newY >=0 && newX<n && newY <m){\\n                    if(grid[newX][newY] + rv < d[newX][newY]){\\n                        d[newX][newY] = grid[newX][newY] + rv;\\n                        if(grid[newX][newY]==0){\\n                            q.push_front(node(newX,newY,grid[newX][newY] + rv));\\n                        }\\n                        else{\\n                            q.push_back(node(newX,newY,grid[newX][newY] + rv));\\n                        }\\n                    }\\n                }\\n\\n            }\\n        }\\n        return d[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct node{\\n    int x,y,remove;\\n    node(int _x,int _y, int _remove){\\n        x=_x;\\n        y=_y;\\n        remove=_remove;\\n    }\\n};\\nclass Solution {\\npublic:\\n\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        deque<node> q;\\n        q.push_front(node(0,0,0));\\n        vector<vector<int>> d(n,vector<int>(m,m*n));\\n        while(!q.empty()){\\n            int x= q.front().x;\\n            int y= q.front().y;\\n            int rv=q.front().remove;\\n            q.pop_front();\\n            int dx[]={1,-1,0,0};\\n            int dy[]={0,0,1,-1};\\n\\n            for(int i=0;i<4;i++){\\n                int newX= x+dx[i];\\n                int newY= y+ dy[i];\\n                if(newX>=0 && newY >=0 && newX<n && newY <m){\\n                    if(grid[newX][newY] + rv < d[newX][newY]){\\n                        d[newX][newY] = grid[newX][newY] + rv;\\n                        if(grid[newX][newY]==0){\\n                            q.push_front(node(newX,newY,grid[newX][newY] + rv));\\n                        }\\n                        else{\\n                            q.push_back(node(newX,newY,grid[newX][newY] + rv));\\n                        }\\n                    }\\n                }\\n\\n            }\\n        }\\n        return d[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231443,
                "title": "bfs-using-priority-queue-in-c",
                "content": "# Complexity\\n- Time complexity:\\nO(MxNxLog(MxN))\\n\\n- Space complexity:\\n  O(MxN)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinimumObstacles(int[][] grid) {\\n            bool[,] visited = new bool[grid.Length, grid[0].Length];\\n            PriorityQueue<(int row, int col, int obs), int> q = new PriorityQueue<(int, int, int), int>();\\n            q.Enqueue((0, 0, 0), grid[0][0]);\\n            while (q.Count > 0){\\n                int r = q.Peek().row;\\n                int c = q.Peek().col;\\n                int obs = q.Peek().obs;\\n                q.Dequeue();\\n\\n                if (r == grid.Length - 1 && c == grid[0].Length - 1){\\n                    return obs;\\n                }\\n                if (!visited[r, c]){\\n                    visited[r, c] = true;\\n                    if(grid[r][c] == 1){\\n                        obs = obs+1;\\n                    }\\n                    if (r - 1 >= 0){\\n                        q.Enqueue((r - 1, c, obs), obs);\\n                    }\\n                    if (r + 1 <= grid.Length - 1){\\n                        q.Enqueue((r + 1, c, obs), obs);\\n                    }\\n                    if (c - 1 >= 0){\\n                        q.Enqueue((r, c - 1, obs), obs);\\n                    }\\n                    if (c + 1 <= grid[0].Length - 1){\\n                        q.Enqueue((r, c + 1, obs), obs);\\n                    }\\n                }\\n            }\\n            return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimumObstacles(int[][] grid) {\\n            bool[,] visited = new bool[grid.Length, grid[0].Length];\\n            PriorityQueue<(int row, int col, int obs), int> q = new PriorityQueue<(int, int, int), int>();\\n            q.Enqueue((0, 0, 0), grid[0][0]);\\n            while (q.Count > 0){\\n                int r = q.Peek().row;\\n                int c = q.Peek().col;\\n                int obs = q.Peek().obs;\\n                q.Dequeue();\\n\\n                if (r == grid.Length - 1 && c == grid[0].Length - 1){\\n                    return obs;\\n                }\\n                if (!visited[r, c]){\\n                    visited[r, c] = true;\\n                    if(grid[r][c] == 1){\\n                        obs = obs+1;\\n                    }\\n                    if (r - 1 >= 0){\\n                        q.Enqueue((r - 1, c, obs), obs);\\n                    }\\n                    if (r + 1 <= grid.Length - 1){\\n                        q.Enqueue((r + 1, c, obs), obs);\\n                    }\\n                    if (c - 1 >= 0){\\n                        q.Enqueue((r, c - 1, obs), obs);\\n                    }\\n                    if (c + 1 <= grid[0].Length - 1){\\n                        q.Enqueue((r, c + 1, obs), obs);\\n                    }\\n                }\\n            }\\n            return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185255,
                "title": "uniform-cost-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int kt[100001],F[100001];\\npriority_queue<tuple<int,int,int>,vector<tuple<int,int,int>>,greater<tuple<int,int,int>>> A; \\n    void check(int x,int y,int value,vector<vector<int>>& grid)\\n    {\\n        if(x>=0&&x<=grid[0].size()-1&&y>=0&&y<=grid.size()-1&&kt[y*grid[0].size()+x]==0&&F[y*grid[0].size()+x]>value+grid[y][x])\\n        {\\n            F[y*grid[0].size()+x]=value+grid[y][x];\\n            A.push(make_tuple(value+grid[y][x],x,y));\\n        }\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int value,x,y;\\n        A.push(make_tuple(0,0,0));\\n        memset(F,127,sizeof(F));\\n        while(A.empty()==0)\\n        {\\n            value=get<0>(A.top());\\n            x=get<1>(A.top());\\n            y=get<2>(A.top());\\n            A.pop();\\n            if(x==grid[0].size()-1&&y==grid.size()-1) return value;\\n            if(kt[y*grid[0].size()+x]==0)\\n            {\\n                kt[y*grid[0].size()+x]=1;\\n                check(x+1,y,value,grid);\\n                check(x-1,y,value,grid);\\n                check(x,y+1,value,grid);\\n                check(x,y-1,value,grid);\\n            }   \\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int kt[100001],F[100001];\\npriority_queue<tuple<int,int,int>,vector<tuple<int,int,int>>,greater<tuple<int,int,int>>> A; \\n    void check(int x,int y,int value,vector<vector<int>>& grid)\\n    {\\n        if(x>=0&&x<=grid[0].size()-1&&y>=0&&y<=grid.size()-1&&kt[y*grid[0].size()+x]==0&&F[y*grid[0].size()+x]>value+grid[y][x])\\n        {\\n            F[y*grid[0].size()+x]=value+grid[y][x];\\n            A.push(make_tuple(value+grid[y][x],x,y));\\n        }\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int value,x,y;\\n        A.push(make_tuple(0,0,0));\\n        memset(F,127,sizeof(F));\\n        while(A.empty()==0)\\n        {\\n            value=get<0>(A.top());\\n            x=get<1>(A.top());\\n            y=get<2>(A.top());\\n            A.pop();\\n            if(x==grid[0].size()-1&&y==grid.size()-1) return value;\\n            if(kt[y*grid[0].size()+x]==0)\\n            {\\n                kt[y*grid[0].size()+x]=1;\\n                check(x+1,y,value,grid);\\n                check(x-1,y,value,grid);\\n                check(x,y+1,value,grid);\\n                check(x,y-1,value,grid);\\n            }   \\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3179327,
                "title": "c-2-solution-dijkstra-and-0-1-bfs-o-n",
                "content": "**1. Djjkstra\\'s Algorithm: O(NlogN)**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;\\n        pq.push({0, {0, 0}});\\n        vector<vector<bool>> vis(m, vector<bool> (n, false));\\n        vis[0][0] = true;\\n        while(!pq.empty()){\\n            auto it = pq.top();\\n            pq.pop();\\n            int cost = it.first;\\n            if(it.second.first == m - 1 and it.second.second == n - 1) return cost;\\n            for(auto dir : dirs){\\n                int nx = it.second.first + dir[0];\\n                int ny = it.second.second + dir[1];\\n                if(nx >= 0 and nx < m and ny >= 0 and ny < n and !vis[nx][ny]){\\n                    vis[nx][ny] = true;\\n                    pq.push({cost + grid[nx][ny], {nx, ny}});\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\n**2. 0-1 BFS: 0(N)**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        deque<vector<int>> dq;\\n        dq.push_front({grid[0][0], 0, 0});\\n        vector<vector<bool>> vis(m, vector<bool> (n, false));\\n        vis[0][0] = true;\\n        while(!dq.empty()){\\n            auto it = dq.front();\\n            dq.pop_front();\\n            if(it[1] == m - 1 and it[2] == n - 1) return it[0];\\n            for(auto dir : dirs){\\n                int nx = it[1] + dir[0];\\n                int ny = it[2] + dir[1];\\n                if(nx >= 0 and nx < m and ny >= 0 and ny < n and !vis[nx][ny]){\\n                    vis[nx][ny] = true;\\n                    if(grid[nx][ny] == 1) dq.push_back({1 + it[0], nx, ny});\\n                    else dq.push_front({it[0], nx, ny});\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;\\n        pq.push({0, {0, 0}});\\n        vector<vector<bool>> vis(m, vector<bool> (n, false));\\n        vis[0][0] = true;\\n        while(!pq.empty()){\\n            auto it = pq.top();\\n            pq.pop();\\n            int cost = it.first;\\n            if(it.second.first == m - 1 and it.second.second == n - 1) return cost;\\n            for(auto dir : dirs){\\n                int nx = it.second.first + dir[0];\\n                int ny = it.second.second + dir[1];\\n                if(nx >= 0 and nx < m and ny >= 0 and ny < n and !vis[nx][ny]){\\n                    vis[nx][ny] = true;\\n                    pq.push({cost + grid[nx][ny], {nx, ny}});\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        deque<vector<int>> dq;\\n        dq.push_front({grid[0][0], 0, 0});\\n        vector<vector<bool>> vis(m, vector<bool> (n, false));\\n        vis[0][0] = true;\\n        while(!dq.empty()){\\n            auto it = dq.front();\\n            dq.pop_front();\\n            if(it[1] == m - 1 and it[2] == n - 1) return it[0];\\n            for(auto dir : dirs){\\n                int nx = it[1] + dir[0];\\n                int ny = it[2] + dir[1];\\n                if(nx >= 0 and nx < m and ny >= 0 and ny < n and !vis[nx][ny]){\\n                    vis[nx][ny] = true;\\n                    if(grid[nx][ny] == 1) dq.push_back({1 + it[0], nx, ny});\\n                    else dq.push_front({it[0], nx, ny});\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163655,
                "title": "c-easy-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n+m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int i,int j,int n,int m)\\n    {\\n        return (i<=n-1 and j<=m-1) and (i>=0 and j>=0);\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq;\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n            int drow[4]={-1,0,1,0};\\n            int dcol[4]={0,1,0,-1};\\n            if(grid[0][0]==0)\\n            pq.push({0,{0,0}});\\n            else\\n            pq.push({1,{0,0}});\\n            vis[0][0]=true;\\n            while(!pq.empty())\\n            {\\n                auto curr=pq.top();\\n                pq.pop();\\n                // /cout<<\"hi \";\\n                int dist=curr.first;\\n                int row=curr.second.first;\\n                int col=curr.second.second;\\n                // cout<<row<<\" \"<<col<<\"\\\\n\";\\n                // cout<<dist<<\" \";\\n                if(row==n-1 and col==m-1)\\n                return dist;\\n\\n                for(int i=0;i<4;i++)\\n                {\\n                    if(isValid(row+drow[i],col+dcol[i],n,m) and grid[row+drow[i]][col+dcol[i]]==1 and vis[row+drow[i]][col+dcol[i]]==false)\\n                    {\\n                        // cout<<\"hi\";\\n\\n                        vis[row+drow[i]][col+dcol[i]]=true;\\n                        pq.push({dist+1,{row+drow[i],col+dcol[i]}});\\n                    }\\n                    else if(isValid(row+drow[i],col+dcol[i],n,m) and grid[row+drow[i]][col+dcol[i]]==0 and vis[row+drow[i]][col+dcol[i]]==false)\\n                    {\\n                       vis[row+drow[i]][col+dcol[i]]=true;\\n                        pq.push({dist,{row+drow[i],col+dcol[i]}});\\n                    }\\n                }\\n            }\\n\\n            return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int i,int j,int n,int m)\\n    {\\n        return (i<=n-1 and j<=m-1) and (i>=0 and j>=0);\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq;\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n            int drow[4]={-1,0,1,0};\\n            int dcol[4]={0,1,0,-1};\\n            if(grid[0][0]==0)\\n            pq.push({0,{0,0}});\\n            else\\n            pq.push({1,{0,0}});\\n            vis[0][0]=true;\\n            while(!pq.empty())\\n            {\\n                auto curr=pq.top();\\n                pq.pop();\\n                // /cout<<\"hi \";\\n                int dist=curr.first;\\n                int row=curr.second.first;\\n                int col=curr.second.second;\\n                // cout<<row<<\" \"<<col<<\"\\\\n\";\\n                // cout<<dist<<\" \";\\n                if(row==n-1 and col==m-1)\\n                return dist;\\n\\n                for(int i=0;i<4;i++)\\n                {\\n                    if(isValid(row+drow[i],col+dcol[i],n,m) and grid[row+drow[i]][col+dcol[i]]==1 and vis[row+drow[i]][col+dcol[i]]==false)\\n                    {\\n                        // cout<<\"hi\";\\n\\n                        vis[row+drow[i]][col+dcol[i]]=true;\\n                        pq.push({dist+1,{row+drow[i],col+dcol[i]}});\\n                    }\\n                    else if(isValid(row+drow[i],col+dcol[i],n,m) and grid[row+drow[i]][col+dcol[i]]==0 and vis[row+drow[i]][col+dcol[i]]==false)\\n                    {\\n                       vis[row+drow[i]][col+dcol[i]]=true;\\n                        pq.push({dist,{row+drow[i],col+dcol[i]}});\\n                    }\\n                }\\n            }\\n\\n            return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3139576,
                "title": "dijkstra-s-algorithm",
                "content": "```python\\ndef minimumObstacles(self, grid: list[list[int]]) -> int:\\n\\tROWS, COLS = len(grid), len(grid[0])\\n\\tdistances = [[float(\"inf\")]*COLS for _ in range(ROWS)]\\n\\tdistances[0][0] = 0\\n\\tdirections = [(1,0),(-1,0),(0,1),(0,-1)]\\n\\tqueue = [[distances[0][0], 0, 0]]\\n\\n\\twhile queue:\\n\\t\\tdist, i, j = heapq.heappop(queue)\\n\\t\\tif dist > distances[i][j]: continue\\n\\t\\tdistances[i][j] = dist\\n\\t\\tfor rd, cd in directions:\\n\\t\\t\\trr, cc = i + rd, j + cd\\n\\t\\t\\tif rr >= 0 and rr < ROWS and cc >= 0 and cc < COLS:\\n\\t\\t\\t\\tnew_dist = dist + grid[rr][cc]\\n\\t\\t\\t\\tif new_dist < distances[rr][cc]:\\n\\t\\t\\t\\t\\tdistances[rr][cc] = new_dist\\n\\t\\t\\t\\t\\theapq.heappush(queue, [distances[rr][cc], rr, cc])\\n\\t\\tif i == ROWS-1 and j == COLS-1:\\n\\t\\t\\tbreak\\n\\treturn distances[ROWS-1][COLS-1] if distances[ROWS-1][COLS-1] != float(\"inf\") else -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\ndef minimumObstacles(self, grid: list[list[int]]) -> int:\\n\\tROWS, COLS = len(grid), len(grid[0])\\n\\tdistances = [[float(\"inf\")]*COLS for _ in range(ROWS)]\\n\\tdistances[0][0] = 0\\n\\tdirections = [(1,0),(-1,0),(0,1),(0,-1)]\\n\\tqueue = [[distances[0][0], 0, 0]]\\n\\n\\twhile queue:\\n\\t\\tdist, i, j = heapq.heappop(queue)\\n\\t\\tif dist > distances[i][j]: continue\\n\\t\\tdistances[i][j] = dist\\n\\t\\tfor rd, cd in directions:\\n\\t\\t\\trr, cc = i + rd, j + cd\\n\\t\\t\\tif rr >= 0 and rr < ROWS and cc >= 0 and cc < COLS:\\n\\t\\t\\t\\tnew_dist = dist + grid[rr][cc]\\n\\t\\t\\t\\tif new_dist < distances[rr][cc]:\\n\\t\\t\\t\\t\\tdistances[rr][cc] = new_dist\\n\\t\\t\\t\\t\\theapq.heappush(queue, [distances[rr][cc], rr, cc])\\n\\t\\tif i == ROWS-1 and j == COLS-1:\\n\\t\\t\\tbreak\\n\\treturn distances[ROWS-1][COLS-1] if distances[ROWS-1][COLS-1] != float(\"inf\") else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3127544,
                "title": "java-dijkestra-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[][] dir = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        Queue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        pq.offer(new int[] {0, grid[0][0]});\\n        visited[0][0] = true;\\n        \\n        while(!pq.isEmpty()) {\\n            int[] curr = pq.poll();\\n            int r = curr[0] / n;\\n            int c = curr[0] % n;\\n            int cost = curr[1];\\n            if(r == m - 1 && c == n - 1)\\n                return cost;\\n\\n            for(int[] d : dir) {\\n                int row = r + d[0];\\n                int col = c + d[1];\\n                if(!valid(m, n, row, col) || visited[row][col]) \\n                    continue;\\n  \\n                visited[row][col] = true;\\n                int cell = row * n + col;\\n                pq.offer(new int[] {cell, cost + grid[row][col]});\\n            }\\n        }\\n\\n        return -1;\\n    }\\n    public boolean valid(int m, int n, int r, int c) {\\n        return r >= 0 && c >= 0 && r < m && c < n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dir = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        Queue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        pq.offer(new int[] {0, grid[0][0]});\\n        visited[0][0] = true;\\n        \\n        while(!pq.isEmpty()) {\\n            int[] curr = pq.poll();\\n            int r = curr[0] / n;\\n            int c = curr[0] % n;\\n            int cost = curr[1];\\n            if(r == m - 1 && c == n - 1)\\n                return cost;\\n\\n            for(int[] d : dir) {\\n                int row = r + d[0];\\n                int col = c + d[1];\\n                if(!valid(m, n, row, col) || visited[row][col]) \\n                    continue;\\n  \\n                visited[row][col] = true;\\n                int cell = row * n + col;\\n                pq.offer(new int[] {cell, cost + grid[row][col]});\\n            }\\n        }\\n\\n        return -1;\\n    }\\n    public boolean valid(int m, int n, int r, int c) {\\n        return r >= 0 && c >= 0 && r < m && c < n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109851,
                "title": "simple-bfs-using-heap",
                "content": "we can insert (0, 0, 0) in a queue where first `0` signifies the removals and the remaining two are `(i, j)` of matrix.\\n\\nwe maintain `visited` map (with key as index of matrix) that stores the minimum number of removals we need to do to reach to that index from `(0, 0)`\\nNow, we do a bfs and go to its neighbors, identify the number of removals and insert it back into heap. We repeat this process unless the last cell is obtained.\\n```\\nimport heapq\\n\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n        we can try to solve this problem using priority queue \\n        and breadth first search\\n        \"\"\"\\n        m, n = len(grid), len(grid[0])\\n        heap = []\\n        heapq.heappush(heap, (0, 0, 0))\\n        visited = {(0, 0): 0}\\n\\n        def is_valid(i, j):\\n            return 0 <= i < m and 0 <= j < n\\n        \\n        def get_neis(i, j):\\n            return [(i+1,j), (i-1,j), (i,j-1), (i,j+1)]\\n\\n        while len(heap):\\n            removal, i, j = heapq.heappop(heap)\\n            if (i, j) == (m-1, n-1):\\n                return removal\\n            for x, y in get_neis(i, j):\\n                if is_valid(x, y):\\n                    val = grid[x][y]\\n                    if visited.get((x,y), float(\\'inf\\')) > removal + val:\\n                        visited[(x,y)] = removal + val\\n                        heapq.heappush(heap, (removal+val, x, y))\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n        we can try to solve this problem using priority queue \\n        and breadth first search\\n        \"\"\"\\n        m, n = len(grid), len(grid[0])\\n        heap = []\\n        heapq.heappush(heap, (0, 0, 0))\\n        visited = {(0, 0): 0}\\n\\n        def is_valid(i, j):\\n            return 0 <= i < m and 0 <= j < n\\n        \\n        def get_neis(i, j):\\n            return [(i+1,j), (i-1,j), (i,j-1), (i,j+1)]\\n\\n        while len(heap):\\n            removal, i, j = heapq.heappop(heap)\\n            if (i, j) == (m-1, n-1):\\n                return removal\\n            for x, y in get_neis(i, j):\\n                if is_valid(x, y):\\n                    val = grid[x][y]\\n                    if visited.get((x,y), float(\\'inf\\')) > removal + val:\\n                        visited[(x,y)] = removal + val\\n                        heapq.heappush(heap, (removal+val, x, y))\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067580,
                "title": "simple-dijakstra",
                "content": "```\\nclass Solution {\\npublic:\\n    bool issafe(int r,int c, set<pair<int,int>> &vis,vector<vector<int>>& grid )\\n    {\\n        if (vis.find({r,c})!=vis.end())\\n            return false;\\n        if (r<0 or r>=grid.size() or c<0 or c>=grid[0].size())\\n            return false;\\n        return true;\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n    set<pair<int,int>> visited;\\n    priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;\\n    pq.push({0,{0,0}});\\n    int r=grid.size()-1;\\n    visited.insert({0,0});\\n    int c=grid[0].size()-1;\\n    vector<vector<int>> directions={{0,-1},{0,1},{-1,0},{1,0}};\\n    while(pq.size()>0)\\n    {\\n        pair<int,pair<int,int>> p=pq.top();\\n        pq.pop();\\n        if (p.second.first==r && p.second.second==c)\\n            return p.first;\\n        int cr=p.second.first;\\n        int cc=p.second.second;\\n        for (int i=0;i<directions.size();i++)\\n        {\\n            int nr=directions[i][0]+cr;\\n            int nc=directions[i][1]+cc;\\n            if (issafe(nr,nc,visited,grid)==false)\\n                continue;\\n            visited.insert({nr,nc});\\n            int cost=grid[nr][nc]==1?1:0;\\n            cost+=p.first;\\n            pq.push({cost,{nr,nc}});\\n        }\\n        \\n        \\n    }\\n        return 0;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool issafe(int r,int c, set<pair<int,int>> &vis,vector<vector<int>>& grid )\\n    {\\n        if (vis.find({r,c})!=vis.end())\\n            return false;\\n        if (r<0 or r>=grid.size() or c<0 or c>=grid[0].size())\\n            return false;\\n        return true;\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n    set<pair<int,int>> visited;\\n    priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;\\n    pq.push({0,{0,0}});\\n    int r=grid.size()-1;\\n    visited.insert({0,0});\\n    int c=grid[0].size()-1;\\n    vector<vector<int>> directions={{0,-1},{0,1},{-1,0},{1,0}};\\n    while(pq.size()>0)\\n    {\\n        pair<int,pair<int,int>> p=pq.top();\\n        pq.pop();\\n        if (p.second.first==r && p.second.second==c)\\n            return p.first;\\n        int cr=p.second.first;\\n        int cc=p.second.second;\\n        for (int i=0;i<directions.size();i++)\\n        {\\n            int nr=directions[i][0]+cr;\\n            int nc=directions[i][1]+cc;\\n            if (issafe(nr,nc,visited,grid)==false)\\n                continue;\\n            visited.insert({nr,nc});\\n            int cost=grid[nr][nc]==1?1:0;\\n            cost+=p.first;\\n            pq.push({cost,{nr,nc}});\\n        }\\n        \\n        \\n    }\\n        return 0;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046965,
                "title": "c-dijkstra",
                "content": "# Intuition\\nDijkstra from last cell as source. Consider number of obstacles to minimise.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N * M (log(n * M)))\\n\\n- Space complexity:\\nO(N * M)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, unordered_map<int, int> > dis;\\n    unordered_map<int, unordered_map<int, bool> > f;\\n    \\n    int dir[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n    \\n    struct cmp {\\n        bool operator()(const pair<pair<int, int>, int>& a, const pair<pair<int, int>, int>& b) {\\n            return a.second > b.second;\\n        }\\n    };\\n    \\n    void assign(int n, int m) {\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                dis[i][j] = 1000000;\\n            }\\n        }\\n    }\\n    \\n    bool isValid(int r, int c, vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        return r >= 0 && r < n && c >= 0 && c < m;\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        assign(n, m);\\n        priority_queue<pair<pair<int, int> , int>, vector<pair<pair<int, int>, int> >, cmp> q;\\n        \\n        q.push({{n - 1, m - 1}, 0});\\n        \\n        dis[n - 1][m - 1] = 0;\\n        \\n        while (!q.empty()) {\\n            pair<pair<int, int>, int> node = q.top();\\n            q.pop();\\n            \\n            int r = node.first.first;\\n            int c = node.first.second;\\n            int wt = node.second;\\n            \\n            //cout<<r<<\" \"<<c<<\" \"<<wt<<endl;\\n            if (f[r][c]) {\\n                continue;\\n            }\\n            \\n            for (int d = 0; d < 4; d++) {\\n                int n_r = r + dir[d][0];\\n                int n_c = c + dir[d][1];\\n                \\n                if (!f[n_r][n_c] && isValid(n_r, n_c, grid)) {\\n                    if (grid[n_r][n_c] == 1) {\\n                        if (dis[n_r][n_c] > dis[r][c] + 1) {\\n                            dis[n_r][n_c] = dis[r][c] + 1;\\n                            q.push({{n_r, n_c}, dis[n_r][n_c]});\\n                        }\\n                    } else {\\n                        if (dis[n_r][n_c] > dis[r][c]) {\\n                            dis[n_r][n_c] = dis[r][c];\\n                            q.push({{n_r, n_c}, dis[n_r][n_c]});\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            f[r][c] = true;\\n            \\n        }\\n        \\n        return dis[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, unordered_map<int, int> > dis;\\n    unordered_map<int, unordered_map<int, bool> > f;\\n    \\n    int dir[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n    \\n    struct cmp {\\n        bool operator()(const pair<pair<int, int>, int>& a, const pair<pair<int, int>, int>& b) {\\n            return a.second > b.second;\\n        }\\n    };\\n    \\n    void assign(int n, int m) {\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                dis[i][j] = 1000000;\\n            }\\n        }\\n    }\\n    \\n    bool isValid(int r, int c, vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        return r >= 0 && r < n && c >= 0 && c < m;\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        assign(n, m);\\n        priority_queue<pair<pair<int, int> , int>, vector<pair<pair<int, int>, int> >, cmp> q;\\n        \\n        q.push({{n - 1, m - 1}, 0});\\n        \\n        dis[n - 1][m - 1] = 0;\\n        \\n        while (!q.empty()) {\\n            pair<pair<int, int>, int> node = q.top();\\n            q.pop();\\n            \\n            int r = node.first.first;\\n            int c = node.first.second;\\n            int wt = node.second;\\n            \\n            //cout<<r<<\" \"<<c<<\" \"<<wt<<endl;\\n            if (f[r][c]) {\\n                continue;\\n            }\\n            \\n            for (int d = 0; d < 4; d++) {\\n                int n_r = r + dir[d][0];\\n                int n_c = c + dir[d][1];\\n                \\n                if (!f[n_r][n_c] && isValid(n_r, n_c, grid)) {\\n                    if (grid[n_r][n_c] == 1) {\\n                        if (dis[n_r][n_c] > dis[r][c] + 1) {\\n                            dis[n_r][n_c] = dis[r][c] + 1;\\n                            q.push({{n_r, n_c}, dis[n_r][n_c]});\\n                        }\\n                    } else {\\n                        if (dis[n_r][n_c] > dis[r][c]) {\\n                            dis[n_r][n_c] = dis[r][c];\\n                            q.push({{n_r, n_c}, dis[n_r][n_c]});\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            f[r][c] = true;\\n            \\n        }\\n        \\n        return dis[0][0];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3044361,
                "title": "python-solution-slowish-yet-very-efficient-bfs",
                "content": "\\n![Screenshot 2023-01-13 at 10.19.29.png](https://assets.leetcode.com/users/images/39a3d388-6e3e-4eb6-a562-5792b23fff3e_1673598286.6098428.png)\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this algorithm is O(mn) because each point is visited once and the number of operations per point is constant. \\nAlso a note that the use of deque from python collections library is to improve the time complexity from O(mn) to O(m+n).\\n\\n- Space complexity:\\nThe space complexity is also O(mn) because it stores the distances of all points in the grid.\\n# Code\\n```\\nfrom collections import deque\\nfrom typing import List\\n\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dist = [[float(\\'inf\\')] * n for _ in range(m)]\\n        dist[0][0] = 0\\n        q = deque([(0, 0)])\\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        while q:\\n            x, y = q.popleft()\\n            for dx, dy in directions:\\n                i, j = x + dx, y + dy\\n                if 0 <= i < m and 0 <= j < n:\\n                    if grid[i][j] == 0:\\n                        if dist[i][j] > dist[x][y]:\\n                            dist[i][j] = dist[x][y]\\n                            q.append((i, j))\\n                    else:\\n                        if dist[i][j] > dist[x][y] + 1:\\n                            dist[i][j] = dist[x][y] + 1\\n                            q.append((i, j))\\n        return dist[m-1][n-1]\\n```\\n**Explanation**: This solution\\'s implementation of a Breadth-First Search algorithm starts by initializing the distance of the starting point to 0 and adding it to the queue. Then it repeatedly pops the next point in the queue and updates the distance of the neighbors if it is shorter than the current distance. Finally, it returns the distance of the end point.\\n\\nMore LeetCode solutions of mine at https://github.com/aurimas13/Solutions-To-Problems",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\nfrom typing import List\\n\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dist = [[float(\\'inf\\')] * n for _ in range(m)]\\n        dist[0][0] = 0\\n        q = deque([(0, 0)])\\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        while q:\\n            x, y = q.popleft()\\n            for dx, dy in directions:\\n                i, j = x + dx, y + dy\\n                if 0 <= i < m and 0 <= j < n:\\n                    if grid[i][j] == 0:\\n                        if dist[i][j] > dist[x][y]:\\n                            dist[i][j] = dist[x][y]\\n                            q.append((i, j))\\n                    else:\\n                        if dist[i][j] > dist[x][y] + 1:\\n                            dist[i][j] = dist[x][y] + 1\\n                            q.append((i, j))\\n        return dist[m-1][n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042466,
                "title": "c-dijkstra-solution-accurate-and-simple",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const vector<vector<int>> dir{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        const int N = grid.size();\\n        const int M = grid[0].size();\\n        vector<vector<int>> count(N, vector<int>(M, INT_MAX));\\n        priority_queue<Data, vector<Data>, Comp> q;\\n        count[0][0] = 0;\\n        q.push(make_data(0, 0, 0));\\n        int curr_r, curr_c;\\n\\n        while (q.empty() == false)\\n        {\\n            auto [cnt, r, c] = q.top();\\n            q.pop();\\n\\n            for (const vector<int>& d : dir)\\n            {\\n                curr_r = r + d[0];\\n                curr_c = c + d[1];\\n\\n                if (inRange(N, M, curr_r, curr_c) && count[curr_r][curr_c] > cnt + grid[curr_r][curr_c])\\n                    count[curr_r][curr_c] = cnt + grid[curr_r][curr_c], q.push(make_data(count[curr_r][curr_c], curr_r, curr_c));\\n            } \\n        }\\n\\n        return count[N - 1][M - 1];\\n\\n    }\\n\\nprivate:\\n    struct Data\\n    {\\n        int count;\\n        int row;\\n        int col;\\n        Data(const int& i, const int& j, const int& k) : count(i), row(j), col(k) {} \\n    };\\n\\n    Data make_data(const int& i, const int& j, const int& k) { return Data(i, j, k); }\\n\\n    class Comp\\n    {\\n    public:\\n        inline bool operator()(const Data& d1, const Data& d2) { return d1.count >= d2.count; }\\n    };\\n\\n    inline bool inRange(const int& N, const int& M, const int& row, const int& col) { return row >= 0 && row < N && col >= 0 && col < M; }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const vector<vector<int>> dir{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        const int N = grid.size();\\n        const int M = grid[0].size();\\n        vector<vector<int>> count(N, vector<int>(M, INT_MAX));\\n        priority_queue<Data, vector<Data>, Comp> q;\\n        count[0][0] = 0;\\n        q.push(make_data(0, 0, 0));\\n        int curr_r, curr_c;\\n\\n        while (q.empty() == false)\\n        {\\n            auto [cnt, r, c] = q.top();\\n            q.pop();\\n\\n            for (const vector<int>& d : dir)\\n            {\\n                curr_r = r + d[0];\\n                curr_c = c + d[1];\\n\\n                if (inRange(N, M, curr_r, curr_c) && count[curr_r][curr_c] > cnt + grid[curr_r][curr_c])\\n                    count[curr_r][curr_c] = cnt + grid[curr_r][curr_c], q.push(make_data(count[curr_r][curr_c], curr_r, curr_c));\\n            } \\n        }\\n\\n        return count[N - 1][M - 1];\\n\\n    }\\n\\nprivate:\\n    struct Data\\n    {\\n        int count;\\n        int row;\\n        int col;\\n        Data(const int& i, const int& j, const int& k) : count(i), row(j), col(k) {} \\n    };\\n\\n    Data make_data(const int& i, const int& j, const int& k) { return Data(i, j, k); }\\n\\n    class Comp\\n    {\\n    public:\\n        inline bool operator()(const Data& d1, const Data& d2) { return d1.count >= d2.count; }\\n    };\\n\\n    inline bool inRange(const int& N, const int& M, const int& row, const int& col) { return row >= 0 && row < N && col >= 0 && col < M; }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034684,
                "title": "golang-priority-queue",
                "content": "```go\\ntype PriorityQueue [][3]int\\n\\nfunc (pq PriorityQueue) Len() int           { return len(pq) }\\nfunc (pq PriorityQueue) Less(i, j int) bool { return pq[i][0] < pq[j][0] }\\nfunc (pq PriorityQueue) Swap(i, j int)      { pq[i], pq[j] = pq[j], pq[i] }\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n  *pq = append(*pq, x.([3]int))\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n  old := *pq\\n  n := len(old)\\n  item := old[n-1]\\n  *pq = old[:n-1]\\n  return item\\n}\\n\\nfunc (pq PriorityQueue) Top() interface{} {\\n  return pq[0]\\n}\\n\\nfunc minimumObstacles(grid [][]int) int {\\n  m, n := len(grid), len(grid[0])\\n  var pq PriorityQueue\\n  var res int\\n  heap.Push(&pq, [3]int{grid[0][0], 0, 0})\\n  directions := [4][2]int{{0, -1}, {-1, 0}, {0, 1}, {1, 0}}\\n  visited := make([][]bool, m)\\n  for i := 0; i < len(visited); i++ {\\n    visited[i] = make([]bool, n)\\n  }\\n  visited[0][0] = true\\n  for pq.Len() > 0 {\\n    top := heap.Pop(&pq).([3]int)\\n    x, y := top[1], top[2]\\n    if x == m-1 && y == n-1 {\\n      res = top[0]\\n      break\\n    }\\n    for _, dir := range directions {\\n      x1, y1 := x + dir[0], y + dir[1]\\n      if x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && !visited[x1][y1] {\\n        visited[x1][y1] = true\\n        heap.Push(&pq, [3]int{top[0] + grid[x1][y1], x1, y1})\\n      }\\n    }\\n  }\\n  return res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```go\\ntype PriorityQueue [][3]int\\n\\nfunc (pq PriorityQueue) Len() int           { return len(pq) }\\nfunc (pq PriorityQueue) Less(i, j int) bool { return pq[i][0] < pq[j][0] }\\nfunc (pq PriorityQueue) Swap(i, j int)      { pq[i], pq[j] = pq[j], pq[i] }\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n  *pq = append(*pq, x.([3]int))\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n  old := *pq\\n  n := len(old)\\n  item := old[n-1]\\n  *pq = old[:n-1]\\n  return item\\n}\\n\\nfunc (pq PriorityQueue) Top() interface{} {\\n  return pq[0]\\n}\\n\\nfunc minimumObstacles(grid [][]int) int {\\n  m, n := len(grid), len(grid[0])\\n  var pq PriorityQueue\\n  var res int\\n  heap.Push(&pq, [3]int{grid[0][0], 0, 0})\\n  directions := [4][2]int{{0, -1}, {-1, 0}, {0, 1}, {1, 0}}\\n  visited := make([][]bool, m)\\n  for i := 0; i < len(visited); i++ {\\n    visited[i] = make([]bool, n)\\n  }\\n  visited[0][0] = true\\n  for pq.Len() > 0 {\\n    top := heap.Pop(&pq).([3]int)\\n    x, y := top[1], top[2]\\n    if x == m-1 && y == n-1 {\\n      res = top[0]\\n      break\\n    }\\n    for _, dir := range directions {\\n      x1, y1 := x + dir[0], y + dir[1]\\n      if x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && !visited[x1][y1] {\\n        visited[x1][y1] = true\\n        heap.Push(&pq, [3]int{top[0] + grid[x1][y1], x1, y1})\\n      }\\n    }\\n  }\\n  return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2981077,
                "title": "python-simple-dijkstra-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid):\\n        m, n = len(grid), len(grid[0])\\n\\n        distance = collections.defaultdict(int)\\n\\n        for i in range(m):\\n            for j in range(n):\\n                distance[(i,j)] = float(\"inf\")\\n\\n        distance[(0,0)] = grid[0][0]\\n\\n        stack = [(0,0,0)]\\n\\n        while stack:\\n            weight, i, j = heapq.heappop(stack)\\n\\n            if i == m-1 and j == n-1:\\n                return weight\\n\\n            for ni,nj in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:\\n                if 0 <= ni < m and 0 <= nj < n and distance[(ni,nj)] > weight + grid[ni][nj]:\\n                    distance[(ni,nj)] = weight + grid[ni][nj]\\n                    heapq.heappush(stack,(weight+grid[ni][nj],ni,nj))\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid):\\n        m, n = len(grid), len(grid[0])\\n\\n        distance = collections.defaultdict(int)\\n\\n        for i in range(m):\\n            for j in range(n):\\n                distance[(i,j)] = float(\"inf\")\\n\\n        distance[(0,0)] = grid[0][0]\\n\\n        stack = [(0,0,0)]\\n\\n        while stack:\\n            weight, i, j = heapq.heappop(stack)\\n\\n            if i == m-1 and j == n-1:\\n                return weight\\n\\n            for ni,nj in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:\\n                if 0 <= ni < m and 0 <= nj < n and distance[(ni,nj)] > weight + grid[ni][nj]:\\n                    distance[(ni,nj)] = weight + grid[ni][nj]\\n                    heapq.heappush(stack,(weight+grid[ni][nj],ni,nj))\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2980448,
                "title": "python-simple-dfs-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid):\\n        m, n = len(grid), len(grid[0])\\n\\n        dict1 = collections.defaultdict(dict)\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if i > 0:\\n                    dict1[(i,j)][(i-1,j)] = grid[i-1][j]\\n                if i+1 < m:\\n                    dict1[(i,j)][(i+1,j)] = grid[i+1][j]\\n                if j > 0:\\n                    dict1[(i,j)][(i,j-1)] = grid[i][j-1]\\n                if j+1 < n:\\n                    dict1[(i,j)][(i,j+1)] = grid[i][j+1]\\n\\n\\n        stack, visited = [(grid[0][0],0,0)], set()\\n\\n        visited.add((0,0))\\n\\n        while stack:\\n            weight, i, j = heapq.heappop(stack)\\n\\n            if i == m-1 and j == n-1:\\n                return weight\\n\\n            for ni,nj in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:\\n                if 0 <= ni < m and 0 <= nj < n and (ni,nj) not in visited:\\n                    heapq.heappush(stack,(weight+dict1[(i,j)][(ni,nj)],ni,nj))\\n                    visited.add((ni,nj))\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid):\\n        m, n = len(grid), len(grid[0])\\n\\n        dict1 = collections.defaultdict(dict)\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if i > 0:\\n                    dict1[(i,j)][(i-1,j)] = grid[i-1][j]\\n                if i+1 < m:\\n                    dict1[(i,j)][(i+1,j)] = grid[i+1][j]\\n                if j > 0:\\n                    dict1[(i,j)][(i,j-1)] = grid[i][j-1]\\n                if j+1 < n:\\n                    dict1[(i,j)][(i,j+1)] = grid[i][j+1]\\n\\n\\n        stack, visited = [(grid[0][0],0,0)], set()\\n\\n        visited.add((0,0))\\n\\n        while stack:\\n            weight, i, j = heapq.heappop(stack)\\n\\n            if i == m-1 and j == n-1:\\n                return weight\\n\\n            for ni,nj in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:\\n                if 0 <= ni < m and 0 <= nj < n and (ni,nj) not in visited:\\n                    heapq.heappush(stack,(weight+dict1[(i,j)][(ni,nj)],ni,nj))\\n                    visited.add((ni,nj))\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970933,
                "title": "java-simple-bfs",
                "content": "```\\nclass Solution\\n{\\n    private int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    \\n    public int minimumObstacles(int[][] grid) \\n    {\\n        int n = grid.length, m = grid[0].length;\\n        \\n        Integer[][] removal = new Integer[n][m]; \\n        removal[0][0] =  grid[0][0];\\n        \\n        Queue<int[]> qu = new LinkedList<>();\\n        qu.add(new int[]{0, 0});\\n        \\n        while(!qu.isEmpty())\\n        {\\n            int[] curr = qu.remove();\\n            \\n            for(int[] dir : dirs)\\n            {\\n                int i = curr[0] + dir[0];\\n                int j = curr[1] + dir[1];\\n                if(i < n && j < m && i >= 0 && j >= 0)\\n                {\\n                    int nextEntry =  removal[curr[0]][curr[1]] + grid[i][j];\\n                    update_Removals(i, j, curr, removal, qu, nextEntry);\\n                }\\n            }\\n        }\\n        return removal[n - 1][m - 1];\\n    }\\n    \\n    private void update_Removals(int i, int j, int[] curr, Integer[][] removal, Queue<int[]> qu, int nextEntry)\\n    {\\n        if(removal[i][j] == null || removal[i][j] > nextEntry){\\n            removal[i][j] = nextEntry;\\n            qu.add(new int[]{i, j});\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution\\n{\\n    private int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    \\n    public int minimumObstacles(int[][] grid) \\n    {\\n        int n = grid.length, m = grid[0].length;\\n        \\n        Integer[][] removal = new Integer[n][m]; \\n        removal[0][0] =  grid[0][0];\\n        \\n        Queue<int[]> qu = new LinkedList<>();\\n        qu.add(new int[]{0, 0});\\n        \\n        while(!qu.isEmpty())\\n        {\\n            int[] curr = qu.remove();\\n            \\n            for(int[] dir : dirs)\\n            {\\n                int i = curr[0] + dir[0];\\n                int j = curr[1] + dir[1];\\n                if(i < n && j < m && i >= 0 && j >= 0)\\n                {\\n                    int nextEntry =  removal[curr[0]][curr[1]] + grid[i][j];\\n                    update_Removals(i, j, curr, removal, qu, nextEntry);\\n                }\\n            }\\n        }\\n        return removal[n - 1][m - 1];\\n    }\\n    \\n    private void update_Removals(int i, int j, int[] curr, Integer[][] removal, Queue<int[]> qu, int nextEntry)\\n    {\\n        if(removal[i][j] == null || removal[i][j] > nextEntry){\\n            removal[i][j] = nextEntry;\\n            qu.add(new int[]{i, j});\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952513,
                "title": "simple-fast-easy-solution-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        priority_queue< pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>> ,greater<pair<int,pair<int,int>>> >pq;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        pq.push({0,{0,0}});\\n        vis[0][0]=1;\\n        int nrow[]={-1,0,+1,0};\\n        int ncol[]={0,+1,0,-1};\\n        while(!pq.empty())\\n        {\\n            int x=pq.top().second.first;\\n            int y=pq.top().second.second;\\n            int obstacle=pq.top().first;\\n            pq.pop();\\n            if(x==n-1 && y==m-1)\\n            {\\n                return obstacle;\\n            }\\n            for(int i=0;i<4;i++)\\n            {\\n                int xnode=x+nrow[i];\\n                int ynode=y+ncol[i];\\n                if(xnode>=0 && xnode<n && ynode>=0 && ynode<m && vis[xnode][ynode]==0)\\n                {\\n                    if(grid[xnode][ynode]==0)\\n                    {\\n                        pq.push({obstacle,{xnode,ynode}});\\n                    }\\n                    else\\n                    {\\n                        pq.push({obstacle+1,{xnode,ynode}});\\n                    }\\n                    vis[xnode][ynode]=1;\\n                }\\n            }\\n\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        priority_queue< pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>> ,greater<pair<int,pair<int,int>>> >pq;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        pq.push({0,{0,0}});\\n        vis[0][0]=1;\\n        int nrow[]={-1,0,+1,0};\\n        int ncol[]={0,+1,0,-1};\\n        while(!pq.empty())\\n        {\\n            int x=pq.top().second.first;\\n            int y=pq.top().second.second;\\n            int obstacle=pq.top().first;\\n            pq.pop();\\n            if(x==n-1 && y==m-1)\\n            {\\n                return obstacle;\\n            }\\n            for(int i=0;i<4;i++)\\n            {\\n                int xnode=x+nrow[i];\\n                int ynode=y+ncol[i];\\n                if(xnode>=0 && xnode<n && ynode>=0 && ynode<m && vis[xnode][ynode]==0)\\n                {\\n                    if(grid[xnode][ynode]==0)\\n                    {\\n                        pq.push({obstacle,{xnode,ynode}});\\n                    }\\n                    else\\n                    {\\n                        pq.push({obstacle+1,{xnode,ynode}});\\n                    }\\n                    vis[xnode][ynode]=1;\\n                }\\n            }\\n\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945217,
                "title": "java-bfs-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        boolean vis[][]=new boolean[m][n];\\n        \\n        // max priority queue\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[0]-b[0]);\\n        if(grid[0][0]==0)\\n        pq.add(new int[]{0,0,0});\\n        else\\n        pq.add(new int[]{1,0,0});\\n\\n        vis[0][0]=true;\\n        int[][] directions = new int[][] {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};\\n\\n        while(!pq.isEmpty()){\\n            int current[]=pq.poll();\\n            // if reached to last index\\n            if(current[1]==m-1 && current[2]==n-1)\\n            return current[0];\\n            \\n            for(int dir[] :directions){\\n                int delrow=current[1]+dir[0];\\n                int delcol=current[2]+dir[1];\\n\\n                if(delrow<0 || delcol<0 || delrow==m ||delcol==n ||vis[delrow][delcol])\\n                continue;\\n                vis[delrow][delcol]=true;\\n\\n                if(grid[delrow][delcol]==1)\\n                pq.add(new int[] {current[0]+1,delrow,delcol});\\n                else\\n                pq.add(new int[]{current[0],delrow,delcol});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        boolean vis[][]=new boolean[m][n];\\n        \\n        // max priority queue\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[0]-b[0]);\\n        if(grid[0][0]==0)\\n        pq.add(new int[]{0,0,0});\\n        else\\n        pq.add(new int[]{1,0,0});\\n\\n        vis[0][0]=true;\\n        int[][] directions = new int[][] {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};\\n\\n        while(!pq.isEmpty()){\\n            int current[]=pq.poll();\\n            // if reached to last index\\n            if(current[1]==m-1 && current[2]==n-1)\\n            return current[0];\\n            \\n            for(int dir[] :directions){\\n                int delrow=current[1]+dir[0];\\n                int delcol=current[2]+dir[1];\\n\\n                if(delrow<0 || delcol<0 || delrow==m ||delcol==n ||vis[delrow][delcol])\\n                continue;\\n                vis[delrow][delcol]=true;\\n\\n                if(grid[delrow][delcol]==1)\\n                pq.add(new int[] {current[0]+1,delrow,delcol});\\n                else\\n                pq.add(new int[]{current[0],delrow,delcol});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939990,
                "title": "using-0-1-bfs",
                "content": "# Intuition\\nCan be converted into O-1 BFS\\n\\n# Approach\\nAdd the free cell at front and obstacles cells t back of deque.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```\\nimport java.util.*;\\n class Pair{\\n    int a ;\\n    int b;\\n    int c;\\n    Pair(int a ,int b){\\n        this.a = a;\\n        this.b= b;\\n    }\\n    Pair(int a,int b ,int c){\\n        this.a= a;\\n        this.b= b;\\n        this.c= c;\\n    }\\n}\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[][] distance = new int[n][m];\\n        for(int i=0;i<n;i++){\\n          for(int j=0;j<m;j++){\\n              distance[i][j]= Integer.MAX_VALUE;\\n          }\\n        }\\n    Deque<Pair> dequeue = new LinkedList<>();\\n    dequeue.add(new Pair(0,0,0));\\n    ArrayList<Pair> list = new ArrayList<>();\\n    list.add(new Pair(1,0));\\n    list.add(new Pair(-1,0));\\n    list.add(new Pair(0,1));\\n    list.add(new Pair(0,-1));\\n    distance[0][0]=0;\\n    while(!dequeue.isEmpty()){\\n        int x = dequeue.peekFirst().a;\\n        int y = dequeue.peekFirst().b;\\n        int obs = dequeue.peekFirst().c;\\n        dequeue.poll();\\n         for(Pair i:list){\\n             int r = x+i.a;\\n             int c = y+i.b;\\n             if(r>=0 && r<n && c>=0 &&c<m){\\n             if(grid[r][c]==0){\\n                 if(obs<distance[r][c]){\\n                 distance[r][c] = obs;\\n                dequeue.addFirst(new Pair(r,c,distance[r][c]));\\n                }\\n             }\\n            else{\\n                if(obs+1<distance[r][c]){\\n                    distance[r][c] =obs+1;\\n                dequeue.addLast(new Pair(r,c,distance[r][c]));\\n                }\\n            }\\n            }\\n            }\\n         }\\nreturn distance[n-1][m-1];\\n}\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "class Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[][] distance = new int[n][m];\\n        for(int i=0;i<n;i++){\\n          for(int j=0;j<m;j++){\\n              distance[i][j]= Integer.MAX_VALUE;\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 2915062,
                "title": "python-3-heap-easy-to-understand-with-comments",
                "content": "![image.png](https://assets.leetcode.com/users/images/e4d1cb6b-cee7-485a-a53e-51230590f939_1671119959.431977.png)\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        \\n        drt     = [[-1, 0], [0, -1], [1, 0], [0, 1]]\\n        visited = set()\\n        row_n   = len(grid)\\n        col_n   = len(grid[0])\\n\\n        # number of obstacles removed, obstacle in cell, r, c\\n        hpf = [(grid[0][0], grid[0][0], 0, 0,)] \\n        heapify(hpf)\\n\\n        while hpf:  # heap will always give to us cell with:\\n                    # 1. minimum obstacles removed\\n                    # 2. cell without obstacle\\n            # n - number of obstacles removed, v - obstacle in cell, \\n            # r - cell\\'s row, c - cell\\'s column\\n            (n, v, r, c) = heappop(hpf) \\n\\n            if (r, c) == (row_n - 1, col_n -1): return n\\n            if (r, c) in visited:               continue\\n            visited.add((r, c))\\n\\n            for r_dlt, c_dlt in drt:\\n                r_adj, c_adj = r + r_dlt, c + c_dlt\\n\\n                if 0 <= r_adj < row_n and \\\\\\n                   0 <= c_adj < col_n:\\n                    heappush(hpf, (n + v, grid[r_adj][c_adj], r_adj, c_adj))\\n\\n        return -1  # actually we don\\'t need this,\\n                   # because code will always reach the bottom-right corner\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        \\n        drt     = [[-1, 0], [0, -1], [1, 0], [0, 1]]\\n        visited = set()\\n        row_n   = len(grid)\\n        col_n   = len(grid[0])\\n\\n        # number of obstacles removed, obstacle in cell, r, c\\n        hpf = [(grid[0][0], grid[0][0], 0, 0,)] \\n        heapify(hpf)\\n\\n        while hpf:  # heap will always give to us cell with:\\n                    # 1. minimum obstacles removed\\n                    # 2. cell without obstacle\\n            # n - number of obstacles removed, v - obstacle in cell, \\n            # r - cell\\'s row, c - cell\\'s column\\n            (n, v, r, c) = heappop(hpf) \\n\\n            if (r, c) == (row_n - 1, col_n -1): return n\\n            if (r, c) in visited:               continue\\n            visited.add((r, c))\\n\\n            for r_dlt, c_dlt in drt:\\n                r_adj, c_adj = r + r_dlt, c + c_dlt\\n\\n                if 0 <= r_adj < row_n and \\\\\\n                   0 <= c_adj < col_n:\\n                    heappush(hpf, (n + v, grid[r_adj][c_adj], r_adj, c_adj))\\n\\n        return -1  # actually we don\\'t need this,\\n                   # because code will always reach the bottom-right corner\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849513,
                "title": "python-dijkstra-s-algo-optimized-with-0-1-bfs",
                "content": "Not sure why it\\'s tagged `HARD`. It\\'s just Dijkstra\\'s algo.\\n\\nThe same input example. Just added some text.\\n\\n![image](https://assets.leetcode.com/users/images/3b0d6073-3792-4dd8-963b-01be2ddc2462_1669450466.257272.png)\\n\\n**The story**\\nimagine that you have a maze with rooms. In order to enter a room you have to pay either 0 or 1 coins.\\nYour goal is to find the cheapest route from [0,0] to [ROWS - 1, COLS - 1].\\n\\nYou are located at room [0,0] and paid 0 coins. Entering room [ROWS - 1, COLS - 1] costs 0 coins.\\n\\n**DSA**\\nNow that we understand what we have and what we need let\\'s apply our knowledge.\\n\\nHow to represent the data that we have: room coordinates, cost, and price so far???\\nA room is [x,y], cost is either 0 or 1, and price is an integer.\\n\\nWhen you see that there is some connection between items and that connection has a property it should immediately trigger n\\u0336o\\u0336t\\u0336 \\u0336D\\u0336P\\u0336 that the data can be represented as **a graph**.\\n\\nSpecifically **a weighted graph**, where a vertex is a room with [x,y] coordinate and an edge - the cost [0 or 1] to enter the room.\\n\\n![image](https://assets.leetcode.com/users/images/a1fea158-3664-4ea3-a53c-887e5ee13aa1_1669451292.0073655.png)\\n\\n**The question** left to answer: how to find the cheapest way from node [0,0] to [ROWS - 1, COLS - 1]?\\n\\n**The answer**: [Dijkstra\\'s algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)\\n*For a given source node in the graph, the algorithm finds the shortest path between that node and every other.\\u200A It can also be **used for finding the shortest paths from a single node to a single destination node** by stopping the algorithm once the shortest path to the destination node has been determined.*\\n\\n*For example, if the **nodes represent cities** and **edge path costs** represent driving distances between pairs of cities connected by a direct road (for simplicity, ignore red lights, stop signs, toll roads and other obstructions), Dijkstra\\'s algorithm can be used to find the shortest route between one city and all other cities.*\\n\\nBack to our problem:\\n\\nDijkstra uses heap to find the shortest path. Thus `O(E + VlogV)`\\n\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        ROWS, COLS = len(grid), len(grid[0])\\n        \\n        dist = defaultdict(lambda: float(inf)) # price to get from [0,0] to [x,y]\\n        dist[(0,0)] = 0 # you start here. [0,0] your price arriving at [0,0] = 0\\n        \\n        heap = [(0,0,0)] # d,r,c. Min heap. Ordered by price to [r,c]\\n        \\n        while heap:\\n            d,r,c = heappop(heap)\\n            \\n            for dr,dc in [(0,1),(1,0),(-1,0),(0,-1)]:\\n                nr,nc = r+dr,c+dc # explore up,down,left,right\\n                if 0 <= nc < COLS and 0 <= nr < ROWS and d + grid[nr][nc] < dist[(nr,nc)]: # if found cheaper way to [nc,nr] -> update disctances (probably should be prices) and explore [nr,nc]\\n                    dist[(nr,nc)] = d + grid[nr][nc] # set dist[(nr,nc)] to a lower price\\n                    heappush(heap, (dist[(nr,nc)],nr,nc))\\n        \\n        return dist[(ROWS - 1, COLS - 1)]\\n```\\n\\n**How to optimize it???**\\nAs you can see we use only 2 coin values `0` or `1`.\\n\\nThere is a `0-1 BFS` algo .Why 0-1? Because this is like Dijkstra\\'s algo, but uses only 0 or 1 weights.\\nIf we do not need more than 0/1 values we can replace the heap `VlogV` with a `deque`.\\nDeque is used this way: if you need to place 0, you place it in front of the queue. if you need to add 1 - you add it to the end. Kind of custom heap with only 2 possible values 0 or 1 and thus we get O(1) for push/pop or `V` instead of `VlogV`. For `0-1 BFS` TC should be O(E+V).\\n\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        ROWS, COLS = len(grid), len(grid[0])\\n        \\n        dist = defaultdict(lambda: float(inf))\\n        dist[(0,0)] = 0\\n        \\n        queue = deque([(0,0)])\\n        visited = set()\\n        \\n        while queue:\\n            r,c = queue.popleft()\\n            for dr,dc in [(0,1),(0,-1),(1,0),(-1,0)]:\\n                nr,nc = r+dr,c+dc # ...\\n                if 0 <= nr < ROWS and 0 <= nc < COLS and (nr,nc) not in visited:\\n                    if dist[(r,c)] + grid[nr][nc] < dist[(nr,nc)]: # found better price?\\n                        dist[(nr,nc)] = dist[(r,c)] + grid[nr][nc]\\n                    \\n                    if grid[nr][nc] == 0: # if cost = 0 -> put in front of the queue\\n                        queue.appendleft((nr,nc))\\n                    else: # cost = 1, add to back\\n                        queue.append((nr,nc))\\n                        \\n                    visited.add((nr,nc))\\n        \\n        return dist[(ROWS - 1, COLS - 1)]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        ROWS, COLS = len(grid), len(grid[0])\\n        \\n        dist = defaultdict(lambda: float(inf)) # price to get from [0,0] to [x,y]\\n        dist[(0,0)] = 0 # you start here. [0,0] your price arriving at [0,0] = 0\\n        \\n        heap = [(0,0,0)] # d,r,c. Min heap. Ordered by price to [r,c]\\n        \\n        while heap:\\n            d,r,c = heappop(heap)\\n            \\n            for dr,dc in [(0,1),(1,0),(-1,0),(0,-1)]:\\n                nr,nc = r+dr,c+dc # explore up,down,left,right\\n                if 0 <= nc < COLS and 0 <= nr < ROWS and d + grid[nr][nc] < dist[(nr,nc)]: # if found cheaper way to [nc,nr] -> update disctances (probably should be prices) and explore [nr,nc]\\n                    dist[(nr,nc)] = d + grid[nr][nc] # set dist[(nr,nc)] to a lower price\\n                    heappush(heap, (dist[(nr,nc)],nr,nc))\\n        \\n        return dist[(ROWS - 1, COLS - 1)]\\n```\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        ROWS, COLS = len(grid), len(grid[0])\\n        \\n        dist = defaultdict(lambda: float(inf))\\n        dist[(0,0)] = 0\\n        \\n        queue = deque([(0,0)])\\n        visited = set()\\n        \\n        while queue:\\n            r,c = queue.popleft()\\n            for dr,dc in [(0,1),(0,-1),(1,0),(-1,0)]:\\n                nr,nc = r+dr,c+dc # ...\\n                if 0 <= nr < ROWS and 0 <= nc < COLS and (nr,nc) not in visited:\\n                    if dist[(r,c)] + grid[nr][nc] < dist[(nr,nc)]: # found better price?\\n                        dist[(nr,nc)] = dist[(r,c)] + grid[nr][nc]\\n                    \\n                    if grid[nr][nc] == 0: # if cost = 0 -> put in front of the queue\\n                        queue.appendleft((nr,nc))\\n                    else: # cost = 1, add to back\\n                        queue.append((nr,nc))\\n                        \\n                    visited.add((nr,nc))\\n        \\n        return dist[(ROWS - 1, COLS - 1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837300,
                "title": "bfs-dequeue",
                "content": "# Intuition\\nGet minumum distance bewteen node like 0 and 1 BFS travesal in tree to get level.\\n\\n# Approach\\nPush node which is 0 at front of queue and 1 at end of queue becuase all node with 0 have same distance or level so they can processed simulatniously in BFS traversal.\\n\\n# Complexity\\n- Time complexity:\\no m*n\\n\\n- Space complexity:\\no m*n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        int m=grid.length , n=grid[0].length;\\n\\n        int[][] dist = new int[m][n];\\n        for(int[] x : dist){\\n            Arrays.fill(x,Integer.MAX_VALUE);\\n        }\\n        Deque<int[]> dq= new LinkedList<>();\\n        dq.offer(new int[]{0,0});\\n        dist[0][0] = grid[0][0] ;\\n\\n        int[][] dir= {{0,1},{0,-1},{1,0},{-1,0}};\\n\\n        while(!dq.isEmpty()){\\n            int[] curr= dq.pop();\\n            for(int[] x : dir){\\n                int nx =curr[0] + x[0];\\n                int ny = curr[1] + x[1];\\n                if(nx >=0 && nx < m && ny >=0 && ny < n){\\n                      if(dist[nx][ny] > dist[curr[0]][curr[1]]+grid[nx][ny]) {\\n                          dist[nx][ny] = dist[curr[0]][curr[1]]+grid[nx][ny];\\n                          if(grid[nx][ny] == 1)\\n                            dq.addLast(new int[]{nx,ny});\\n                          else  \\n                            dq.add(new int[]{nx,ny});\\n                      } \\n                }\\n            }\\n        }\\n\\n        return dist[m-1][n-1] ==Integer.MAX_VALUE ? -1 : dist[m-1][n-1] ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        int m=grid.length , n=grid[0].length;\\n\\n        int[][] dist = new int[m][n];\\n        for(int[] x : dist){\\n            Arrays.fill(x,Integer.MAX_VALUE);\\n        }\\n        Deque<int[]> dq= new LinkedList<>();\\n        dq.offer(new int[]{0,0});\\n        dist[0][0] = grid[0][0] ;\\n\\n        int[][] dir= {{0,1},{0,-1},{1,0},{-1,0}};\\n\\n        while(!dq.isEmpty()){\\n            int[] curr= dq.pop();\\n            for(int[] x : dir){\\n                int nx =curr[0] + x[0];\\n                int ny = curr[1] + x[1];\\n                if(nx >=0 && nx < m && ny >=0 && ny < n){\\n                      if(dist[nx][ny] > dist[curr[0]][curr[1]]+grid[nx][ny]) {\\n                          dist[nx][ny] = dist[curr[0]][curr[1]]+grid[nx][ny];\\n                          if(grid[nx][ny] == 1)\\n                            dq.addLast(new int[]{nx,ny});\\n                          else  \\n                            dq.add(new int[]{nx,ny});\\n                      } \\n                }\\n            }\\n        }\\n\\n        return dist[m-1][n-1] ==Integer.MAX_VALUE ? -1 : dist[m-1][n-1] ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834113,
                "title": "c-failed-bfs-binary-search",
                "content": "Now I see, this problem can also be modeled as the graph problem. Consider each cell as the node and there will be an between two nodes if they are adjacent, and cost of the edge would be `1` if in the edge (u, v) `v` or `u` cell is blocked. \\n\\nAnd we run dijkstra on the graph, and get the minimum cost. \\n\\n```cpp\\nclass Node {\\npublic:\\n    int x;\\n    int y;\\n    int k;\\n};\\n\\nclass Solution {\\npublic:\\n    int n;\\n    int m;\\n    vector<vector<int>> mat;\\n    bool isPossible(int K) {\\n        queue<Node> q;\\n        auto isValidCell = [&] (const int &a, const int &b) {\\n            return (a >= 0 && b >= 0 && a < n && b < m);\\n        };\\n        //start cell can also have the obstacle\\n        q.push({0, 0, mat[0][0] == 1});\\n        vector<vector<vector<bool>>> seen(n, vector<vector<bool>>(m, vector<bool>(K + 1, false))) ;\\n        seen[0][0][mat[0][0] == 1] = true;\\n        while(q.size() > 0) {\\n            int N = q.size();\\n            while (N--) {\\n                Node node = q.front();\\n                q.pop();\\n                if (node.x == n - 1 && node.y == m - 1 && node.k <= K) return true;\\n                int dir[] = {-1, 0, 1, 0, -1};\\n                for (int k = 0; k < 4; ++k) {\\n                    int cur_k = node.k;\\n                    int u = node.x + dir[k];\\n                    int v = node.y + dir[k + 1];\\n                    if (isValidCell(u, v)) {\\n                        if (mat[u][v]) ++cur_k;\\n                        if (cur_k <= K && !seen[u][v][cur_k]) {\\n                            q.push({u, v, cur_k});\\n                            seen[u][v][cur_k] = true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        mat = grid;\\n        n = grid.size();\\n        m = grid[0].size();\\n        int low = 0;\\n        int high = m + n;\\n        int ans = high;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (isPossible(mid)) {\\n                ans = min(ans, mid);\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Node {\\npublic:\\n    int x;\\n    int y;\\n    int k;\\n};\\n\\nclass Solution {\\npublic:\\n    int n;\\n    int m;\\n    vector<vector<int>> mat;\\n    bool isPossible(int K) {\\n        queue<Node> q;\\n        auto isValidCell = [&] (const int &a, const int &b) {\\n            return (a >= 0 && b >= 0 && a < n && b < m);\\n        };\\n        //start cell can also have the obstacle\\n        q.push({0, 0, mat[0][0] == 1});\\n        vector<vector<vector<bool>>> seen(n, vector<vector<bool>>(m, vector<bool>(K + 1, false))) ;\\n        seen[0][0][mat[0][0] == 1] = true;\\n        while(q.size() > 0) {\\n            int N = q.size();\\n            while (N--) {\\n                Node node = q.front();\\n                q.pop();\\n                if (node.x == n - 1 && node.y == m - 1 && node.k <= K) return true;\\n                int dir[] = {-1, 0, 1, 0, -1};\\n                for (int k = 0; k < 4; ++k) {\\n                    int cur_k = node.k;\\n                    int u = node.x + dir[k];\\n                    int v = node.y + dir[k + 1];\\n                    if (isValidCell(u, v)) {\\n                        if (mat[u][v]) ++cur_k;\\n                        if (cur_k <= K && !seen[u][v][cur_k]) {\\n                            q.push({u, v, cur_k});\\n                            seen[u][v][cur_k] = true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        mat = grid;\\n        n = grid.size();\\n        m = grid[0].size();\\n        int low = 0;\\n        int high = m + n;\\n        int ans = high;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (isPossible(mid)) {\\n                ans = min(ans, mid);\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805432,
                "title": "python-dfs",
                "content": "```\\n\\tdef minimumObstacles(self, grid: List[List[int]]) -> int:\\n        # DFS with some extra properties??\\n        # Minimum number of obstacles removed...\\n        \\n        visited = set([(0,0)])\\n        q = deque([ [grid[0][0], [0,0]] ])\\n        \\n        while q:    \\n            v = q.popleft()\\n            x, y = v[1]\\n            if y == len(grid[0])-1 and x == len(grid)-1:\\n                return v[0]\\n            if x > 0:\\n                if (x-1, y) not in visited:\\n                    if grid[x-1][y]:\\n                        q.append([v[0]+1, [x-1, y]])\\n                    else:\\n                        q.appendleft([v[0], [x-1, y]])\\n                    visited.add((x-1, y))\\n            if y > 0:\\n                if (x, y-1) not in visited:\\n                    if grid[x][y-1]:\\n                        q.append([v[0]+1, [x, y-1]])\\n                    else:\\n                        q.appendleft([v[0], [x, y-1]])\\n                    visited.add((x, y-1))\\n                \\n            if x < len(grid)-1:\\n                if (x+1, y) not in visited:\\n                    if grid[x+1][y]:\\n                        q.append([v[0]+1, [x+1, y]])\\n                    else:\\n                        q.appendleft([v[0], [x+1, y]])\\n                    visited.add((x+1, y))\\n            \\n            if y < len(grid[0])-1:\\n                if (x, y+1) not in visited:\\n                    if grid[x][y+1]:\\n                        q.append([v[0]+1, [x, y+1]])\\n                    else:\\n                        q.appendleft([v[0], [x, y+1]])\\n                    visited.add((x, y+1))\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n\\tdef minimumObstacles(self, grid: List[List[int]]) -> int:\\n        # DFS with some extra properties??\\n        # Minimum number of obstacles removed...\\n        \\n        visited = set([(0,0)])\\n        q = deque([ [grid[0][0], [0,0]] ])\\n        \\n        while q:    \\n            v = q.popleft()\\n            x, y = v[1]\\n            if y == len(grid[0])-1 and x == len(grid)-1:\\n                return v[0]\\n            if x > 0:\\n                if (x-1, y) not in visited:\\n                    if grid[x-1][y]:\\n                        q.append([v[0]+1, [x-1, y]])\\n                    else:\\n                        q.appendleft([v[0], [x-1, y]])\\n                    visited.add((x-1, y))\\n            if y > 0:\\n                if (x, y-1) not in visited:\\n                    if grid[x][y-1]:\\n                        q.append([v[0]+1, [x, y-1]])\\n                    else:\\n                        q.appendleft([v[0], [x, y-1]])\\n                    visited.add((x, y-1))\\n                \\n            if x < len(grid)-1:\\n                if (x+1, y) not in visited:\\n                    if grid[x+1][y]:\\n                        q.append([v[0]+1, [x+1, y]])\\n                    else:\\n                        q.appendleft([v[0], [x+1, y]])\\n                    visited.add((x+1, y))\\n            \\n            if y < len(grid[0])-1:\\n                if (x, y+1) not in visited:\\n                    if grid[x][y+1]:\\n                        q.append([v[0]+1, [x, y+1]])\\n                    else:\\n                        q.appendleft([v[0], [x, y+1]])\\n                    visited.add((x, y+1))\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2762315,
                "title": "java-beat-25-dijsktra-template",
                "content": "```\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] distFromStart = new int[m][n];\\n\\n        for (int i = 0; i < m; i++) {\\n            Arrays.fill(distFromStart[i], -1);\\n        }\\n\\n        distFromStart[0][0] = grid[0][0];\\n        Queue<State> pq = new PriorityQueue<>((a, b) -> a.maxFromStart - b.maxFromStart);\\n        pq.offer(new State(0, 0, grid[0][0]));\\n\\n        while (!pq.isEmpty()) {\\n            //no matter which points, only check from start to which point is more close.\\n            State cur = pq.poll();\\n            int cx = cur.x, cy = cur.y, curFromStart = cur.maxFromStart;\\n            if (cx == m - 1 && cy == n - 1) return curFromStart;\\n\\n            for (int[] adj : getAdjs(grid, cx, cy, m, n)) {\\n                int nx = adj[0];\\n                int ny = adj[1];\\n\\n                int timeFromStart = distFromStart[cx][cy] + grid[nx][ny];\\n                //find the shorter time or deal with the initial reachable situation.\\n                if (timeFromStart < distFromStart[nx][ny] || distFromStart[nx][ny] == -1) {\\n                    distFromStart[nx][ny] = timeFromStart;\\n                    pq.offer(new State(nx, ny, timeFromStart));\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int[][] dirs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n\\n    //!!! no need to build graph, only need to return 4 directions\\' adj nodes.\\n    List<int[]> getAdjs(int[][] g, int x, int y, int m, int n) {\\n        List<int[]> adjs = new ArrayList<>();\\n        for (int[] d : dirs) {\\n            int nx = x + d[0];\\n            int ny = y + d[1];\\n\\n            if (nx >= m || ny >= n || nx < 0 || ny < 0) {\\n                continue;\\n            }\\n            adjs.add(new int[]{nx, ny});\\n        }\\n        return adjs;\\n    }\\n\\n\\n    class State {\\n        int x, y;\\n        int maxFromStart;\\n\\n        State(int x, int y, int maxFromStart) {\\n            this.x = x;\\n            this.y = y;\\n            this.maxFromStart = maxFromStart;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] distFromStart = new int[m][n];\\n\\n        for (int i = 0; i < m; i++) {\\n            Arrays.fill(distFromStart[i], -1);\\n        }\\n\\n        distFromStart[0][0] = grid[0][0];\\n        Queue<State> pq = new PriorityQueue<>((a, b) -> a.maxFromStart - b.maxFromStart);\\n        pq.offer(new State(0, 0, grid[0][0]));\\n\\n        while (!pq.isEmpty()) {\\n            //no matter which points, only check from start to which point is more close.\\n            State cur = pq.poll();\\n            int cx = cur.x, cy = cur.y, curFromStart = cur.maxFromStart;\\n            if (cx == m - 1 && cy == n - 1) return curFromStart;\\n\\n            for (int[] adj : getAdjs(grid, cx, cy, m, n)) {\\n                int nx = adj[0];\\n                int ny = adj[1];\\n\\n                int timeFromStart = distFromStart[cx][cy] + grid[nx][ny];\\n                //find the shorter time or deal with the initial reachable situation.\\n                if (timeFromStart < distFromStart[nx][ny] || distFromStart[nx][ny] == -1) {\\n                    distFromStart[nx][ny] = timeFromStart;\\n                    pq.offer(new State(nx, ny, timeFromStart));\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int[][] dirs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n\\n    //!!! no need to build graph, only need to return 4 directions\\' adj nodes.\\n    List<int[]> getAdjs(int[][] g, int x, int y, int m, int n) {\\n        List<int[]> adjs = new ArrayList<>();\\n        for (int[] d : dirs) {\\n            int nx = x + d[0];\\n            int ny = y + d[1];\\n\\n            if (nx >= m || ny >= n || nx < 0 || ny < 0) {\\n                continue;\\n            }\\n            adjs.add(new int[]{nx, ny});\\n        }\\n        return adjs;\\n    }\\n\\n\\n    class State {\\n        int x, y;\\n        int maxFromStart;\\n\\n        State(int x, int y, int maxFromStart) {\\n            this.x = x;\\n            this.y = y;\\n            this.maxFromStart = maxFromStart;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760115,
                "title": "java-99",
                "content": "```\\nclass Solution {\\n        public int minimumObstacles(int[][] A) {\\n            int m = A.length, n = A[0].length;\\n            Integer[][] visited = new Integer[m][n];\\n            int[][] dirs = new int[][] { {-1, 0}, {0, 1}, {1, 0}, {0, -1} };\\n\\n            ArrayDeque<int[]> q = new ArrayDeque<>();\\n            q.offer(new int[] { 0, 0, 0 });\\n            visited[0][0] = A[0][0];\\n            int p[], r, c;\\n            while (!q.isEmpty()) {\\n                p = q.poll();\\n                if (p[0] == m-1 && p[1] == n-1)\\n                    return visited[m-1][n-1];\\n\\n                for (int[] dir : dirs) {\\n                    r = p[0] + dir[0];\\n                    c = p[1] + dir[1];\\n                    if (r < 0 || c < 0 || r >= m || c >= n || visited[r][c] != null)\\n                        continue;\\n\\n                    visited[r][c] = A[r][c] + visited[p[0]][p[1]];\\n                    if (A[r][c] == 1)\\n                        q.offer(new int[] { r, c });\\n                    else\\n                        q.offerFirst(new int[] { r, c });\\n                }\\n            }\\n\\n            return visited[m-1][n-1];\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n        public int minimumObstacles(int[][] A) {\\n            int m = A.length, n = A[0].length;\\n            Integer[][] visited = new Integer[m][n];\\n            int[][] dirs = new int[][] { {-1, 0}, {0, 1}, {1, 0}, {0, -1} };\\n\\n            ArrayDeque<int[]> q = new ArrayDeque<>();\\n            q.offer(new int[] { 0, 0, 0 });\\n            visited[0][0] = A[0][0];\\n            int p[], r, c;\\n            while (!q.isEmpty()) {\\n                p = q.poll();\\n                if (p[0] == m-1 && p[1] == n-1)\\n                    return visited[m-1][n-1];\\n\\n                for (int[] dir : dirs) {\\n                    r = p[0] + dir[0];\\n                    c = p[1] + dir[1];\\n                    if (r < 0 || c < 0 || r >= m || c >= n || visited[r][c] != null)\\n                        continue;\\n\\n                    visited[r][c] = A[r][c] + visited[p[0]][p[1]];\\n                    if (A[r][c] == 1)\\n                        q.offer(new int[] { r, c });\\n                    else\\n                        q.offerFirst(new int[] { r, c });\\n                }\\n            }\\n\\n            return visited[m-1][n-1];\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759748,
                "title": "c-two-approaches-dijkstra-s-0-1-bfs",
                "content": "\\t// Dijkstra\\'s\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minimumObstacles(vector<vector<int>>& grid) {\\n\\t\\t\\tint dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; \\n\\t\\t\\tint m = grid.size();\\n\\t\\t\\tint n = grid[0].size();\\n\\t\\t\\tvector<vector<int>> dist(m, vector<int>(n, INT_MAX));\\n\\t\\t\\tset<pair<int, pair<int,int>>> PQ;\\n\\t\\t\\tPQ.insert({0, {0, 0}});\\n\\t\\t\\tdist[0][0] = 0;\\n\\t\\t\\twhile(!PQ.empty()) {\\n\\t\\t\\t\\tpair<int, pair<int,int>> curr = *PQ.begin();\\n\\t\\t\\t\\tPQ.erase(PQ.begin());\\n\\t\\t\\t\\tint ux = curr.second.first;\\n\\t\\t\\t\\tint uy = curr.second.second;\\n\\n\\t\\t\\t\\tfor(auto dir: dirs) {\\n\\t\\t\\t\\t\\tint vx = ux + dir[0];\\n\\t\\t\\t\\t\\tint vy = uy + dir[1];\\n\\n\\t\\t\\t\\t\\tif(vx < 0 || vy < 0 || vx >= m || vy >= n) \\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t\\tint cost = dist[ux][uy] + grid[vx][vy];\\n\\n\\t\\t\\t\\t\\tif(cost < dist[vx][vy]) {\\n\\t\\t\\t\\t\\t\\tauto iter = PQ.find({dist[vx][vy], {vx, vy}});\\n\\t\\t\\t\\t\\t\\tif(iter != PQ.end())\\n\\t\\t\\t\\t\\t\\t\\tPQ.erase(iter);\\n\\t\\t\\t\\t\\t\\tdist[vx][vy] = cost;\\n\\t\\t\\t\\t\\t\\tPQ.insert({dist[vx][vy], {vx, vy}});\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dist[m - 1][n - 1];\\n\\t\\t}\\n\\t};\\n\\t\\n\\t// 0-1 BFS - Better Approach\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minimumObstacles(vector<vector<int>>& grid) {\\n\\t\\t\\tint dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; \\n\\t\\t\\tint m = grid.size();\\n\\t\\t\\tint n = grid[0].size();\\n\\t\\t\\tvector<vector<bool>> visited(m, vector<bool>(n));\\n\\t\\t\\tvector<vector<int>> dist(m, vector<int>(n, INT_MAX));\\n\\t\\t\\tdeque<pair<int, int>> PQ;\\n\\t\\t\\tPQ.push_back({0, 0});\\n\\t\\t\\tvisited[0][0] = true;\\n\\t\\t\\tdist[0][0] = 0;\\n\\n\\t\\t\\twhile(!PQ.empty()) {\\n\\t\\t\\t\\tpair<int, int> curr = PQ.front();\\n\\t\\t\\t\\tPQ.pop_front();\\n\\n\\t\\t\\t\\tint ux = curr.first;\\n\\t\\t\\t\\tint uy = curr.second;\\n\\n\\t\\t\\t\\tfor(auto dir: dirs) {\\n\\t\\t\\t\\t\\tint vx = ux + dir[0];\\n\\t\\t\\t\\t\\tint vy = uy + dir[1];\\n\\n\\t\\t\\t\\t\\tif(vx < 0 || vy < 0 || vx >= m || vy >= n) \\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t\\tif(!visited[vx][vy]) {\\n\\t\\t\\t\\t\\t\\tvisited[vx][vy] = true;\\n\\n\\t\\t\\t\\t\\t\\tdist[vx][vy] = dist[ux][uy] + grid[vx][vy];\\n\\t\\t\\t\\t\\t\\tif(grid[vx][vy])\\n\\t\\t\\t\\t\\t\\t\\tPQ.push_back({vx, vy});\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tPQ.push_front({vx, vy});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dist[m - 1][n - 1];\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minimumObstacles(vector<vector<int>>& grid) {\\n\\t\\t\\tint dirs[4][2] = {{-1, 0}",
                "codeTag": "Java"
            },
            {
                "id": 2759408,
                "title": "java-solution-using-dijkstras",
                "content": "```\\nclass Solution {\\n   private static final int[][] directions = {{0,1},{0,-1}, {1,0},{-1,0}};\\n    private int[][] dist = null;\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        dist = new int[m][n];\\n\\n        for (int[] disArray : dist) {\\n            Arrays.fill(disArray, Integer.MAX_VALUE);\\n        }\\n\\n        dist[0][0] = grid[0][0];\\n\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> (a[2] - b[2]));\\n        // X, Y, Distance\\n        pq.offer(new int[]{ 0,  0, dist[0][0]});\\n\\n        while (!pq.isEmpty()) {\\n\\n            int[] cur = pq.poll();\\n\\n            int x = cur[0];\\n            int y = cur[1];\\n            int currCost = cur[2];\\n            //if we reached to destination then return cost\\n            if (x == m - 1 && y == n - 1) {\\n                return currCost;\\n            }\\n            //finding all valid routes and adding shortest path in queue\\n            for (int[] dir : directions) { \\n                int nextX = x + dir[0];\\n                int nextY = y + dir[1];\\n                if (nextX >=0 && nextX<m && nextY >=0 && nextY<n && currCost + grid[nextX][nextY] < dist[nextX][nextY]) {\\n                    dist[nextX][nextY] = currCost + grid[nextX][nextY];\\n                    pq.offer(new int[]{nextX, nextY,dist[nextX][nextY]});\\n                }\\n            }\\n        }\\n        return dist[m - 1][n - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   private static final int[][] directions = {{0,1},{0,-1}, {1,0},{-1,0}};\\n    private int[][] dist = null;\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        dist = new int[m][n];\\n\\n        for (int[] disArray : dist) {\\n            Arrays.fill(disArray, Integer.MAX_VALUE);\\n        }\\n\\n        dist[0][0] = grid[0][0];\\n\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> (a[2] - b[2]));\\n        // X, Y, Distance\\n        pq.offer(new int[]{ 0,  0, dist[0][0]});\\n\\n        while (!pq.isEmpty()) {\\n\\n            int[] cur = pq.poll();\\n\\n            int x = cur[0];\\n            int y = cur[1];\\n            int currCost = cur[2];\\n            //if we reached to destination then return cost\\n            if (x == m - 1 && y == n - 1) {\\n                return currCost;\\n            }\\n            //finding all valid routes and adding shortest path in queue\\n            for (int[] dir : directions) { \\n                int nextX = x + dir[0];\\n                int nextY = y + dir[1];\\n                if (nextX >=0 && nextX<m && nextY >=0 && nextY<n && currCost + grid[nextX][nextY] < dist[nextX][nextY]) {\\n                    dist[nextX][nextY] = currCost + grid[nextX][nextY];\\n                    pq.offer(new int[]{nextX, nextY,dist[nextX][nextY]});\\n                }\\n            }\\n        }\\n        return dist[m - 1][n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759360,
                "title": "python-modified-bfs",
                "content": "\\tclass Solution:\\n\\t\\tdef minimumObstacles(self, grid: List[List[int]]) -> int:\\n\\t\\t\\t\\n\\t\\t\\tdirections = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n\\t\\t\\tque = deque([(0, 0, 0)])\\n\\t\\t\\tobs = [[-1] * len(grid[0]) for _ in range(len(grid))]\\n\\t\\t\\tobs[0][0] = 0\\n\\t\\t\\t\\n\\t\\t\\twhile que:\\n\\t\\t\\t\\tx, y, cur_obs = que.popleft()\\n\\t\\t\\t\\tfor i in directions:\\n\\t\\t\\t\\t\\tn_x = x + i[0]\\n\\t\\t\\t\\t\\tn_y = y + i[1]\\n\\t\\t\\t\\t\\tif  0 <= n_x < len(grid) and 0 <= n_y < len(grid[0]) and obs[n_x][n_y] == -1:\\n\\t\\t\\t\\t\\t\\tif grid[n_x][n_y] == 1:\\n\\t\\t\\t\\t\\t\\t\\tobs[n_x][n_y] = cur_obs + 1\\n\\t\\t\\t\\t\\t\\t\\tque.append((n_x, n_y, cur_obs+1))\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tobs[n_x][n_y] = cur_obs\\n\\t\\t\\t\\t\\t\\t\\tque.appendleft((n_x, n_y, cur_obs))    \\n\\t\\t\\treturn obs[-1][-1]\\n\\t\\t\\t\\t",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef minimumObstacles(self, grid: List[List[int]]) -> int:\\n\\t\\t\\t\\n\\t\\t\\tdirections = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n\\t\\t\\tque = deque([(0, 0, 0)])\\n\\t\\t\\tobs = [[-1] * len(grid[0]) for _ in range(len(grid))]\\n\\t\\t\\tobs[0][0] = 0\\n\\t\\t\\t\\n\\t\\t\\twhile que:\\n\\t\\t\\t\\tx, y, cur_obs = que.popleft()\\n\\t\\t\\t\\tfor i in directions:\\n\\t\\t\\t\\t\\tn_x = x + i[0]\\n\\t\\t\\t\\t\\tn_y = y + i[1]\\n\\t\\t\\t\\t\\tif  0 <= n_x < len(grid) and 0 <= n_y < len(grid[0]) and obs[n_x][n_y] == -1:\\n\\t\\t\\t\\t\\t\\tif grid[n_x][n_y] == 1:\\n\\t\\t\\t\\t\\t\\t\\tobs[n_x][n_y] = cur_obs + 1\\n\\t\\t\\t\\t\\t\\t\\tque.append((n_x, n_y, cur_obs+1))\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tobs[n_x][n_y] = cur_obs\\n\\t\\t\\t\\t\\t\\t\\tque.appendleft((n_x, n_y, cur_obs))    \\n\\t\\t\\treturn obs[-1][-1]\\n\\t\\t\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 2759214,
                "title": "bfs-min-priorityqueue",
                "content": "```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        \\n        \\n        int r =  grid.length;\\n        int c = grid[0].length;\\n        \\n        boolean [][] visited = new boolean[r][c];\\n        \\n        //keep the min obstracle priority queue\\n        Queue< int [] > q = new PriorityQueue<>((a,b) -> a[2] - b[2]);\\n        \\n        //priority queue contains i, j, and minimul obstracle till i, j\\n        \\n        q.add(new int[]{0,0,grid[0][0]});\\n        \\n        int [][] dir = {{1,0},{-1,0}, {0, 1},{0, -1}};\\n        \\n        visited[0][0] = true;\\n        \\n        while(!q.isEmpty()){\\n            \\n            int [] p = q.poll();\\n            \\n            \\n            //reached destination return min number of obstracle \\n            if(p[0] == r -1 && p[1] == c-1){\\n                return p[2];\\n            }\\n            \\n            for( int [] d : dir){\\n                \\n                int newi = d[0] + p[0];\\n                int newj = d[1] + p[1];\\n                \\n                if(newi < 0 || newi > r-1 || newj < 0 || newj > c-1 || visited[newi][newj]) continue;\\n                \\n                q.add(new int[]{newi,newj,p[2] + grid[newi][newj]});\\n                \\n                visited[newi][newj] = true;\\n                \\n            }\\n            \\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        \\n        \\n        int r =  grid.length;\\n        int c = grid[0].length;\\n        \\n        boolean [][] visited = new boolean[r][c];\\n        \\n        //keep the min obstracle priority queue\\n        Queue< int [] > q = new PriorityQueue<>((a,b) -> a[2] - b[2]);\\n        \\n        //priority queue contains i, j, and minimul obstracle till i, j\\n        \\n        q.add(new int[]{0,0,grid[0][0]});\\n        \\n        int [][] dir = {{1,0},{-1,0}, {0, 1},{0, -1}};\\n        \\n        visited[0][0] = true;\\n        \\n        while(!q.isEmpty()){\\n            \\n            int [] p = q.poll();\\n            \\n            \\n            //reached destination return min number of obstracle \\n            if(p[0] == r -1 && p[1] == c-1){\\n                return p[2];\\n            }\\n            \\n            for( int [] d : dir){\\n                \\n                int newi = d[0] + p[0];\\n                int newj = d[1] + p[1];\\n                \\n                if(newi < 0 || newi > r-1 || newj < 0 || newj > c-1 || visited[newi][newj]) continue;\\n                \\n                q.add(new int[]{newi,newj,p[2] + grid[newi][newj]});\\n                \\n                visited[newi][newj] = true;\\n                \\n            }\\n            \\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757806,
                "title": "c-priority-queue",
                "content": "```\\nclass Solution {\\n  struct cmp {\\n    bool operator()(const std::tuple<int, int, int> &a,\\n                    const std::tuple<int, int, int> &b) const {\\n        return std::get<2>(a) > std::get<2>(b);\\n    } \\n  };\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        unordered_map<int, int> seen;\\n\\t\\t// min priority_queue\\n        std::priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, std::greater<>> q;\\n        q.push(make_tuple(0,0,0));\\n        int x, y, b, m = grid.size(), n = grid[0].size(),\\n        d[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\\n        const std::string del=\":\";\\n        int ans = 999999;\\n        seen[0] = 0;\\n        while (q.empty()==false) {\\n            tie(b,x, y) = q.top(); q.pop();\\n            if ((x == m-1) && (y == n-1)) {\\n                if (ans > b) {\\n                    ans = b;\\n                }\\n                continue;\\n            }\\n            for (int i = 0; i < 4; i++) {\\n                int nx = x + d[i][0], ny= y + d[i][1];\\n                if ((nx<0)||(ny<0)||(nx>=m)||(ny>=n)) continue;\\n                auto it = seen.find((nx*n)+ny);\\n                if (grid[nx][ny]==1) {\\n                    if ((it == seen.end()) ||\\n                        (it->second > b+1)) {\\n                        seen[(nx*n)+ny]=b+1;\\n                        q.push(make_tuple(b+1,nx, ny));\\n                    }\\n                } else {\\n                    if ((it == seen.end())||(it->second > b)) {\\n                        seen[(nx*n)+ny]=b;\\n                        q.push(make_tuple(b, nx, ny));\\n                    }                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  struct cmp {\\n    bool operator()(const std::tuple<int, int, int> &a,\\n                    const std::tuple<int, int, int> &b) const {\\n        return std::get<2>(a) > std::get<2>(b);\\n    } \\n  };\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        unordered_map<int, int> seen;\\n\\t\\t// min priority_queue\\n        std::priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, std::greater<>> q;\\n        q.push(make_tuple(0,0,0));\\n        int x, y, b, m = grid.size(), n = grid[0].size(),\\n        d[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\\n        const std::string del=\":\";\\n        int ans = 999999;\\n        seen[0] = 0;\\n        while (q.empty()==false) {\\n            tie(b,x, y) = q.top(); q.pop();\\n            if ((x == m-1) && (y == n-1)) {\\n                if (ans > b) {\\n                    ans = b;\\n                }\\n                continue;\\n            }\\n            for (int i = 0; i < 4; i++) {\\n                int nx = x + d[i][0], ny= y + d[i][1];\\n                if ((nx<0)||(ny<0)||(nx>=m)||(ny>=n)) continue;\\n                auto it = seen.find((nx*n)+ny);\\n                if (grid[nx][ny]==1) {\\n                    if ((it == seen.end()) ||\\n                        (it->second > b+1)) {\\n                        seen[(nx*n)+ny]=b+1;\\n                        q.push(make_tuple(b+1,nx, ny));\\n                    }\\n                } else {\\n                    if ((it == seen.end())||(it->second > b)) {\\n                        seen[(nx*n)+ny]=b;\\n                        q.push(make_tuple(b, nx, ny));\\n                    }                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735178,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nint dx[] = {1,-1,0,0};\\nint dy[] = {0,0,1,-1};\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n,INT_MAX));\\n        vector<vector<bool>> vis(m, vector<bool>(n,0));\\n        deque<pair<int,int>> q;\\n        q.push_front({0,0});\\n        dp[0][0] = 0;\\n        while(q.size()) {\\n            pair<int,int> p = q.front();\\n            q.pop_front();\\n            int cx = p.first;\\n            int cy = p.second;\\n            for(int i=0;i<4;i++) {\\n                int tx = cx + dx[i];\\n                int ty = cy + dy[i];\\n                if(tx >=0 && tx < m && ty >=0 && ty < n) {                    \\n                    if(!vis[tx][ty]) {\\n                        dp[tx][ty] = dp[cx][cy] + (grid[tx][ty] == 1);\\n                        if(grid[tx][ty] == 1) {\\n                            q.push_back({tx,ty});\\n                        } else {\\n                            q.push_front({tx,ty});\\n                        }\\n                        vis[tx][ty] = true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint dx[] = {1,-1,0,0};\\nint dy[] = {0,0,1,-1};\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n,INT_MAX));\\n        vector<vector<bool>> vis(m, vector<bool>(n,0));\\n        deque<pair<int,int>> q;\\n        q.push_front({0,0});\\n        dp[0][0] = 0;\\n        while(q.size()) {\\n            pair<int,int> p = q.front();\\n            q.pop_front();\\n            int cx = p.first;\\n            int cy = p.second;\\n            for(int i=0;i<4;i++) {\\n                int tx = cx + dx[i];\\n                int ty = cy + dy[i];\\n                if(tx >=0 && tx < m && ty >=0 && ty < n) {                    \\n                    if(!vis[tx][ty]) {\\n                        dp[tx][ty] = dp[cx][cy] + (grid[tx][ty] == 1);\\n                        if(grid[tx][ty] == 1) {\\n                            q.push_back({tx,ty});\\n                        } else {\\n                            q.push_front({tx,ty});\\n                        }\\n                        vis[tx][ty] = true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2685403,
                "title": "c-djikstra-s-ez",
                "content": "```\\n#define triple tuple<int,int,int>\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        priority_queue<triple,vector<triple>,greater<>> pq;\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>> dp(n,vector<int>(m,INT_MAX));\\n        pq.push({grid[0][0],0,0});\\n        int dirs[4][2]={{0,1},{0,-1},{1,0},{-1,0}};\\n        while(!pq.empty()) {\\n            auto [c,i,j] = pq.top();\\n            pq.pop();\\n            if(i==n-1 and j==m-1) return c;\\n            for(int k=0; k<4; k++) {\\n                int nx = i+dirs[k][0];\\n                int ny = j+dirs[k][1];\\n                if(nx>=0 and nx<n and ny>=0 and ny<m and grid[nx][ny]+c < dp[nx][ny]) {\\n                    pq.push({grid[nx][ny]+c,nx,ny});\\n                    dp[nx][ny]=grid[nx][ny]+c;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#define triple tuple<int,int,int>\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        priority_queue<triple,vector<triple>,greater<>> pq;\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>> dp(n,vector<int>(m,INT_MAX));\\n        pq.push({grid[0][0],0,0});\\n        int dirs[4][2]={{0,1},{0,-1},{1,0},{-1,0}};\\n        while(!pq.empty()) {\\n            auto [c,i,j] = pq.top();\\n            pq.pop();\\n            if(i==n-1 and j==m-1) return c;\\n            for(int k=0; k<4; k++) {\\n                int nx = i+dirs[k][0];\\n                int ny = j+dirs[k][1];\\n                if(nx>=0 and nx<n and ny>=0 and ny<m and grid[nx][ny]+c < dp[nx][ny]) {\\n                    pq.push({grid[nx][ny]+c,nx,ny});\\n                    dp[nx][ny]=grid[nx][ny]+c;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674456,
                "title": "c-0-1-bfs",
                "content": "reuse grid to store the min distance, and visit status. store a nagtive number x = -dis -1\\n```\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        const int n=grid.size(), m = grid[0].size();\\n        const vector<pair<int,int>> dirs = {{0,1}, {0, -1}, {1, 0}, {-1,0}};\\n        deque<tuple<int,int,int>> q; //-dis, i, j\\n        q.emplace_back(grid[0][0] = -1,0,0);\\n        while(!q.empty()){\\n            auto [dis, i, j] = q.front(); q.pop_front();            \\n            if(i == n-1 && j == m-1) return -dis-1; \\n            for(auto [di, dj] : dirs){\\n                int x = i+di, y = j+dj;\\n                if(x<0 || x>=n || y<0 || y>=m || grid[x][y] < 0) continue;\\n                int dis2 = dis - grid[x][y];\\n                if(dis2 == dis) q.emplace_front(dis2, x, y);\\n                else q.emplace_back(dis2, x, y);           \\n                grid[x][y] = dis2;\\n            }\\n        }\\n        return -1;\\n    }",
                "solutionTags": [],
                "code": "reuse grid to store the min distance, and visit status. store a nagtive number x = -dis -1\\n```\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        const int n=grid.size(), m = grid[0].size();\\n        const vector<pair<int,int>> dirs = {{0,1}, {0, -1}, {1, 0}, {-1,0}};\\n        deque<tuple<int,int,int>> q; //-dis, i, j\\n        q.emplace_back(grid[0][0] = -1,0,0);\\n        while(!q.empty()){\\n            auto [dis, i, j] = q.front(); q.pop_front();            \\n            if(i == n-1 && j == m-1) return -dis-1; \\n            for(auto [di, dj] : dirs){\\n                int x = i+di, y = j+dj;\\n                if(x<0 || x>=n || y<0 || y>=m || grid[x][y] < 0) continue;\\n                int dis2 = dis - grid[x][y];\\n                if(dis2 == dis) q.emplace_front(dis2, x, y);\\n                else q.emplace_back(dis2, x, y);           \\n                grid[x][y] = dis2;\\n            }\\n        }\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1976557,
                "content": [
                    {
                        "username": "Saiteja6",
                        "content": "all 54 test cases were executed successfully but still giving tle any suggestions to avoid this"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "What is the problem in this approach ,it is giving TLE  for large input\\n\\n if(r==grid.length-1 && c==grid[0].length-1){\\n            ans=Math.min(ans,obs);\\n            return;\\n        }\\n        vis[r][c]=true;\\n        if(grid[r][c]==1){\\n            solve(r-1,c,vis,grid,obs+1);\\n            solve(r+1,c,vis,grid,obs+1);\\n            solve(r,c-1,vis,grid,obs+1);\\n            solve(r,c+1,vis,grid,obs+1);\\n        }\\n        else{\\n             solve(r-1,c,vis,grid,obs);\\n            solve(r+1,c,vis,grid,obs);\\n            solve(r,c-1,vis,grid,obs);\\n            solve(r,c+1,vis,grid,obs);\\n        }\\n        vis[r][c]=false;"
                    },
                    {
                        "username": "navneetjain",
                        "content": "This looks like a DFS approach. We dont have to traverse every path but instead we should traverse path with current minimum obstacle. So, it should be modified dijkstra shortest path"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "I think you forgot to put the condition that if you are at the a particular cell than that cell is previously traversed or not."
                    },
                    {
                        "username": "layyy",
                        "content": "similar question as path with minimum effort"
                    },
                    {
                        "username": "Ansh_5",
                        "content": "Shouldn\\'t be marked as hard. Simple Dijkstra algorithm."
                    }
                ]
            },
            {
                "id": 1654854,
                "content": [
                    {
                        "username": "Saiteja6",
                        "content": "all 54 test cases were executed successfully but still giving tle any suggestions to avoid this"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "What is the problem in this approach ,it is giving TLE  for large input\\n\\n if(r==grid.length-1 && c==grid[0].length-1){\\n            ans=Math.min(ans,obs);\\n            return;\\n        }\\n        vis[r][c]=true;\\n        if(grid[r][c]==1){\\n            solve(r-1,c,vis,grid,obs+1);\\n            solve(r+1,c,vis,grid,obs+1);\\n            solve(r,c-1,vis,grid,obs+1);\\n            solve(r,c+1,vis,grid,obs+1);\\n        }\\n        else{\\n             solve(r-1,c,vis,grid,obs);\\n            solve(r+1,c,vis,grid,obs);\\n            solve(r,c-1,vis,grid,obs);\\n            solve(r,c+1,vis,grid,obs);\\n        }\\n        vis[r][c]=false;"
                    },
                    {
                        "username": "navneetjain",
                        "content": "This looks like a DFS approach. We dont have to traverse every path but instead we should traverse path with current minimum obstacle. So, it should be modified dijkstra shortest path"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "I think you forgot to put the condition that if you are at the a particular cell than that cell is previously traversed or not."
                    },
                    {
                        "username": "layyy",
                        "content": "similar question as path with minimum effort"
                    },
                    {
                        "username": "Ansh_5",
                        "content": "Shouldn\\'t be marked as hard. Simple Dijkstra algorithm."
                    }
                ]
            },
            {
                "id": 2071886,
                "content": [
                    {
                        "username": "Saiteja6",
                        "content": "all 54 test cases were executed successfully but still giving tle any suggestions to avoid this"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "What is the problem in this approach ,it is giving TLE  for large input\\n\\n if(r==grid.length-1 && c==grid[0].length-1){\\n            ans=Math.min(ans,obs);\\n            return;\\n        }\\n        vis[r][c]=true;\\n        if(grid[r][c]==1){\\n            solve(r-1,c,vis,grid,obs+1);\\n            solve(r+1,c,vis,grid,obs+1);\\n            solve(r,c-1,vis,grid,obs+1);\\n            solve(r,c+1,vis,grid,obs+1);\\n        }\\n        else{\\n             solve(r-1,c,vis,grid,obs);\\n            solve(r+1,c,vis,grid,obs);\\n            solve(r,c-1,vis,grid,obs);\\n            solve(r,c+1,vis,grid,obs);\\n        }\\n        vis[r][c]=false;"
                    },
                    {
                        "username": "navneetjain",
                        "content": "This looks like a DFS approach. We dont have to traverse every path but instead we should traverse path with current minimum obstacle. So, it should be modified dijkstra shortest path"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "I think you forgot to put the condition that if you are at the a particular cell than that cell is previously traversed or not."
                    },
                    {
                        "username": "layyy",
                        "content": "similar question as path with minimum effort"
                    },
                    {
                        "username": "Ansh_5",
                        "content": "Shouldn\\'t be marked as hard. Simple Dijkstra algorithm."
                    }
                ]
            },
            {
                "id": 2056447,
                "content": [
                    {
                        "username": "Saiteja6",
                        "content": "all 54 test cases were executed successfully but still giving tle any suggestions to avoid this"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "What is the problem in this approach ,it is giving TLE  for large input\\n\\n if(r==grid.length-1 && c==grid[0].length-1){\\n            ans=Math.min(ans,obs);\\n            return;\\n        }\\n        vis[r][c]=true;\\n        if(grid[r][c]==1){\\n            solve(r-1,c,vis,grid,obs+1);\\n            solve(r+1,c,vis,grid,obs+1);\\n            solve(r,c-1,vis,grid,obs+1);\\n            solve(r,c+1,vis,grid,obs+1);\\n        }\\n        else{\\n             solve(r-1,c,vis,grid,obs);\\n            solve(r+1,c,vis,grid,obs);\\n            solve(r,c-1,vis,grid,obs);\\n            solve(r,c+1,vis,grid,obs);\\n        }\\n        vis[r][c]=false;"
                    },
                    {
                        "username": "navneetjain",
                        "content": "This looks like a DFS approach. We dont have to traverse every path but instead we should traverse path with current minimum obstacle. So, it should be modified dijkstra shortest path"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "I think you forgot to put the condition that if you are at the a particular cell than that cell is previously traversed or not."
                    },
                    {
                        "username": "layyy",
                        "content": "similar question as path with minimum effort"
                    },
                    {
                        "username": "Ansh_5",
                        "content": "Shouldn\\'t be marked as hard. Simple Dijkstra algorithm."
                    }
                ]
            }
        ]
    }
]