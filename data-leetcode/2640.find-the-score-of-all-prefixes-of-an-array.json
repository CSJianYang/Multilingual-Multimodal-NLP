[
    {
        "title": "Find the Score of All Prefixes of an Array",
        "question_content": "We define the conversion array conver of an array arr as follows:\n\n\tconver[i] = arr[i] + max(arr[0..i]) where max(arr[0..i]) is the maximum value of arr[j] over 0 <= j <= i.\n\nWe also define the score of an array arr as the sum of the values of the conversion array of arr.\nGiven a 0-indexed integer array nums of length n, return an array ans of length n where ans[i] is the score of the prefix nums[0..i].\n&nbsp;\nExample 1:\n\nInput: nums = [2,3,7,5,10]\nOutput: [4,10,24,36,56]\nExplanation: \nFor the prefix [2], the conversion array is [4] hence the score is 4\nFor the prefix [2, 3], the conversion array is [4, 6] hence the score is 10\nFor the prefix [2, 3, 7], the conversion array is [4, 6, 14] hence the score is 24\nFor the prefix [2, 3, 7, 5], the conversion array is [4, 6, 14, 12] hence the score is 36\nFor the prefix [2, 3, 7, 5, 10], the conversion array is [4, 6, 14, 12, 20] hence the score is 56\n\nExample 2:\n\nInput: nums = [1,1,2,4,8,16]\nOutput: [2,4,8,16,32,64]\nExplanation: \nFor the prefix [1], the conversion array is [2] hence the score is 2\nFor the prefix [1, 1], the conversion array is [2, 2] hence the score is 4\nFor the prefix [1, 1, 2], the conversion array is [2, 2, 4] hence the score is 8\nFor the prefix [1, 1, 2, 4], the conversion array is [2, 2, 4, 8] hence the score is 16\nFor the prefix [1, 1, 2, 4, 8], the conversion array is [2, 2, 4, 8, 16] hence the score is 32\nFor the prefix [1, 1, 2, 4, 8, 16], the conversion array is [2, 2, 4, 8, 16, 32] hence the score is 64\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t1 <= nums[i] <= 109",
        "solutions": [
            {
                "id": 3420109,
                "title": "c-python3-prefix-sum",
                "content": "\\n# Intuition\\nFirst find `conver` array and then find its prefix sum\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n**Python3**:\\n```\\ndef findPrefixScore(self, nums: List[int]) -> List[int]:\\n    m, conver = 0, []\\n    for x in nums:\\n        m = max(m, x)\\n        conver.append(x + m)\\n    return accumulate(conver)\\n```\\n1 liner credits [@SunnyvaleCA](https://leetcode.com/SunnyvaleCA/):\\n```\\ndef findPrefixScore(self, A):\\n    return accumulate(n+maxN for n,maxN in zip(A, accumulate(A,max)))\\n\\n```\\n\\n**C++**:\\n```\\nvector<long long> findPrefixScore(vector<int>& nums) {\\n      vector<long long> pre;\\n      long long m = 0, s = 0;\\n      for(int x : nums) {\\n          m = max(m, (long long)x);\\n          s += x + m;\\n          pre.push_back(s);\\n      }\\n      return pre;\\n  }",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\ndef findPrefixScore(self, nums: List[int]) -> List[int]:\\n    m, conver = 0, []\\n    for x in nums:\\n        m = max(m, x)\\n        conver.append(x + m)\\n    return accumulate(conver)\\n```\n```\\ndef findPrefixScore(self, A):\\n    return accumulate(n+maxN for n,maxN in zip(A, accumulate(A,max)))\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3420907,
                "title": "c-easiest-approach-easy-to-understand-simple-logic-with-comments",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\nO(n)\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\nO(n)\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\r\\n        vector<long long> b;  \\r\\n        vector<long long> ans;\\r\\n        int n = nums.size();\\r\\n        int mm= INT_MIN;\\r\\n        long long aa = 0;\\r\\n        for(int  i = 0 ; i < n; i++){        //0, 1...\\r\\n            long long a  = 0;\\r\\n            mm = max(mm, nums[i]);        // 2 , 3...\\r\\n            a = nums[i] + mm;             //2+2 = 4, 3+3  = 6, ..\\r\\n            b.push_back(a);               // b=[4,6,]...\\r\\n            aa += b[i];                   //0+4 = 4, 4+6 = 10,...  \\r\\n            ans.push_back(aa);            //ans = [4,10,...]\\r\\n        }\\r\\n        return ans;                      \\r\\n    }\\r\\n};\\r\\n\\r\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\r\\npublic:\\r\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\r\\n        vector<long long> b;  \\r\\n        vector<long long> ans;\\r\\n        int n = nums.size();\\r\\n        int mm= INT_MIN;\\r\\n        long long aa = 0;\\r\\n        for(int  i = 0 ; i < n; i++){        //0, 1...\\r\\n            long long a  = 0;\\r\\n            mm = max(mm, nums[i]);        // 2 , 3...\\r\\n            a = nums[i] + mm;             //2+2 = 4, 3+3  = 6, ..\\r\\n            b.push_back(a);               // b=[4,6,]...\\r\\n            aa += b[i];                   //0+4 = 4, 4+6 = 10,...  \\r\\n            ans.push_back(aa);            //ans = [4,10,...]\\r\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3420302,
                "title": "prefix-sum-very-simple-easy-to-understand-solution",
                "content": "<b> Please Up Vote if you like the solution\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        long long sum = 0, mx = 0;\\n        for(auto n: nums){\\n            if(mx < n) mx = n;\\n            sum += n + mx;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nHere is an article of my recent interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        long long sum = 0, mx = 0;\\n        for(auto n: nums){\\n            if(mx < n) mx = n;\\n            sum += n + mx;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420254,
                "title": "c-prefix-sum-easy-to-understand-superfast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will use the prefix sum approach to make a `conver` vector and then `ans` vector by applying prefix sum approach on `conver` message.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Store `2*nums[0]` in `conver[0]`.\\n- Then run a loop and assign `conver[i] = nums[i] +0ll+ mx`, where `mx` is variable having the maximum running number.\\n- Then, at last simply make a prefix sum array `ans` of `conver` vector and return it.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long> ans(n);\\n        vector<long long> conver(n);\\n        conver[0] = 2*nums[0];\\n        int mx = nums[0];\\n        for(int i=1; i<n; i++){\\n            mx = max(mx, nums[i]);\\n            conver[i] = nums[i] +0ll+ mx;\\n        }\\n        ans[0]=conver[0];\\n        for(int i=1; i<n; i++){\\n            ans[i] = ans[i-1] + 0ll+conver[i];\\n        }\\n        return ans;\\n    }\\n};\\n\\n//  PLEASE UPVOTE IF YOU LIKE THE SOLUTION\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long> ans(n);\\n        vector<long long> conver(n);\\n        conver[0] = 2*nums[0];\\n        int mx = nums[0];\\n        for(int i=1; i<n; i++){\\n            mx = max(mx, nums[i]);\\n            conver[i] = nums[i] +0ll+ mx;\\n        }\\n        ans[0]=conver[0];\\n        for(int i=1; i<n; i++){\\n            ans[i] = ans[i-1] + 0ll+conver[i];\\n        }\\n        return ans;\\n    }\\n};\\n\\n//  PLEASE UPVOTE IF YOU LIKE THE SOLUTION\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420062,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        long ans[]=new long[n];\\n        int min=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(min<=nums[i])\\n            {\\n                min=nums[i];\\n            }\\n            ans[i]+=min+nums[i];\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        long ans[]=new long[n];\\n        int min=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(min<=nums[i])\\n            {\\n                min=nums[i];\\n            }\\n            ans[i]+=min+nums[i];\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420024,
                "title": "java-python-3-1-pass-codes",
                "content": "\\n\\n```java\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length;\\n        long[] score = new long[n + 1];\\n        for (int i = 0, max = 0; i < n; ++i) {\\n            max = Math.max(max, nums[i]);\\n            score[i + 1] += score[i] + max + nums[i];\\n        }\\n        return Arrays.copyOfRange(score, 1, n + 1);        \\n    }\\n```\\n```python\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        score, mx = [0], 0\\n        for num in nums:\\n            mx = max(mx, num)\\n            score.append(score[-1] + num + mx)\\n        return score[1 :]\\n```\\n\\n**Analysis:**\\n\\nTime & space: `O(n)`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length;\\n        long[] score = new long[n + 1];\\n        for (int i = 0, max = 0; i < n; ++i) {\\n            max = Math.max(max, nums[i]);\\n            score[i + 1] += score[i] + max + nums[i];\\n        }\\n        return Arrays.copyOfRange(score, 1, n + 1);        \\n    }\\n```\n```python\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        score, mx = [0], 0\\n        for num in nums:\\n            mx = max(mx, num)\\n            score.append(score[-1] + num + mx)\\n        return score[1 :]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3419972,
                "title": "c-java-python-intuition-with-explanation-simple-prefix-sum-time-o-n",
                "content": "# Intuition\\n$conver[i] = nums[i] + \\\\displaystyle\\\\max_{0 \\\\le j \\\\le i} (nums[j])$\\n$score(nums) = \\\\sum conver(nums)$\\n\\n$ans[i] = score(nums[0...i])$\\n$ans[i] = \\\\sum conver(nums[0...i])$\\n\\n$ans[i]$ is the the prefix sum of $conver[i]$\\n\\n$ans[i] = \\\\left(\\\\displaystyle\\\\sum conver(nums[0...i-1])\\\\right) + conver[i]$\\n$ans[i] = ans[i - 1] + conver[i]$\\n$ans[i] = ans[i - 1] + nums[i] + \\\\displaystyle\\\\max_{0 \\\\le j \\\\le i} (nums[j])$\\n\\n# Approach\\nMaintain $maximum$ value till current index.\\n$ans[i] = ans[i - 1] + nums[i] + maximum$\\n\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size(), maximum = nums[0];\\n        vector<long long> result(n);\\n        result[0] = 2 * nums[0];\\n        for (int i = 1; i < n; i++) {\\n            maximum = max(maximum, nums[i]);\\n            result[i] = result[i - 1] + nums[i] + maximum;\\n        }\\n        return result;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length, maximum = nums[0];\\n        long[] result = new long[n];\\n        result[0] = 2 * nums[0];\\n        for (int i = 1; i < n; i++) {\\n            maximum = Math.max(maximum, nums[i]);\\n            result[i] = result[i - 1] + nums[i] + maximum;\\n        }\\n        return result;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        maximum = nums[0]\\n        result = [2 * nums[0]]\\n        for i in range(1, len(nums)):\\n            maximum = max(maximum, nums[i])\\n            result.append(result[i - 1] + nums[i] + maximum)\\n        return result\\n```\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(n)$",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size(), maximum = nums[0];\\n        vector<long long> result(n);\\n        result[0] = 2 * nums[0];\\n        for (int i = 1; i < n; i++) {\\n            maximum = max(maximum, nums[i]);\\n            result[i] = result[i - 1] + nums[i] + maximum;\\n        }\\n        return result;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length, maximum = nums[0];\\n        long[] result = new long[n];\\n        result[0] = 2 * nums[0];\\n        for (int i = 1; i < n; i++) {\\n            maximum = Math.max(maximum, nums[i]);\\n            result[i] = result[i - 1] + nums[i] + maximum;\\n        }\\n        return result;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        maximum = nums[0]\\n        result = [2 * nums[0]]\\n        for i in range(1, len(nums)):\\n            maximum = max(maximum, nums[i])\\n            result.append(result[i - 1] + nums[i] + maximum)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420214,
                "title": "explained-simple-and-clear-python-code",
                "content": "# Intuition\\nTo calculate the score of each prefix of the input array nums, we need to calculate the conversion array conver for each prefix, and then sum up the elements of the conversion array to get the prefix score. To calculate the conver array for each prefix, we need to find the maximum value of the input array up to that index, and then add it to each element of the prefix.\\n\\n\\n# Approach\\n1. Initialize an array ans of length n with all elements initialized to 0.\\n2. Initialize a variable max_val to negative infinity.\\n3. Loop through the input array nums:\\na. Update the max_val variable to the maximum value seen so far.\\nb. Calculate the conversion value conver for the current index by adding the current element of the input array to the max_val.\\nc. Update the corresponding element of the ans array with the conver value.\\n4. Initialize an array res of length n with all elements initialized to 0.\\n5. Initialize a variable s to 0.\\n6. Loop through the ans array:\\na. Add the current element to the s variable.\\nb. Update the corresponding element of the res array with the current value of s.\\n7. Return the res array.\\n# Complexity\\n- Time complexity:\\nO(n), where n is the length of the input array nums. We need to loop through the array twice, once to calculate the ans array and once to calculate the res array, both of which take O(n) time.\\n- Space complexity:\\nO(n), we need to use two arrays of length n, ans and res, which take O(n) space in total. Additionally, we use a few constant variables, which take O(1) space.\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420127,
                "title": "clean-and-simple-solution-using-heap-100-faster",
                "content": "```class Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        heap = [-nums[0]]\\n        result = []\\n        runningSum = 0\\n        for num in nums:\\n            maxSum = max(num, -1 * heapq.heappop(heap))\\n            result.append(runningSum + num + maxSum)\\n            runningSum += maxSum+num\\n            heappush(heap,- maxSum)\\n        return result\\n        \\n        \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```class Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        heap = [-nums[0]]\\n        result = []\\n        runningSum = 0\\n        for num in nums:\\n            maxSum = max(num, -1 * heapq.heappop(heap))\\n            result.append(runningSum + num + maxSum)\\n            runningSum += maxSum+num\\n            heappush(heap,- maxSum)\\n        return result\\n        \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 3420054,
                "title": "short-clean-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] res = new long[nums.length];\\n        long max = 0;\\n        for(int i=0; i<nums.length; i++){\\n            max = Math.max(max,nums[i]);\\n            res[i] = nums[i] + max + (i==0 ? 0 : res[i-1]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] res = new long[nums.length];\\n        long max = 0;\\n        for(int i=0; i<nums.length; i++){\\n            max = Math.max(max,nums[i]);\\n            res[i] = nums[i] + max + (i==0 ? 0 : res[i-1]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420279,
                "title": "c-o-n-prefix-sum-clean-code",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> ans(n,-1);\\n        long long l=nums[0];\\n        //calculating the conver[i]\\n        for(int i=0;i<n;++i){\\n            if(l<nums[i])l = nums[i];\\n            ans[i]=nums[i]+l;\\n        }\\n        //taking the prefix sum\\n        for(int i=1;i<n;++i)ans[i]+=ans[i-1];\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> ans(n,-1);\\n        long long l=nums[0];\\n        //calculating the conver[i]\\n        for(int i=0;i<n;++i){\\n            if(l<nums[i])l = nums[i];\\n            ans[i]=nums[i]+l;\\n        }\\n        //taking the prefix sum\\n        for(int i=1;i<n;++i)ans[i]+=ans[i-1];\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420129,
                "title": "cpp-prefix-sum",
                "content": "```\\n\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& v) {\\n        vector<ll> ans;\\n        ll mx = 0LL, s = 0LL;\\n        for(int x : v) {\\n            mx = max(mx,(ll)x);\\n            s += (x + mx);\\n            ans.push_back(s);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\n\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& v) {\\n        vector<ll> ans;\\n        ll mx = 0LL, s = 0LL;\\n        for(int x : v) {\\n            mx = max(mx,(ll)x);\\n            s += (x + mx);\\n            ans.push_back(s);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421148,
                "title": "c-easy-prefix-sum",
                "content": "# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& a) {\\n        vector<long long>v;\\n        v.push_back(a[0]+a[0]);\\n        long long mx=a[0];\\n        for(int i=1;i<a.size();i++){\\n            long long an=a[i];\\n            if(mx<a[i])mx=a[i];\\n            an+=mx;\\n            long long h=v[i-1]+an;\\n            v.push_back(h);\\n        }\\n        return v;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/fcf80d18-7665-46c4-a0fb-5038ce657498_1681589962.770271.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& a) {\\n        vector<long long>v;\\n        v.push_back(a[0]+a[0]);\\n        long long mx=a[0];\\n        for(int i=1;i<a.size();i++){\\n            long long an=a[i];\\n            if(mx<a[i])mx=a[i];\\n            an+=mx;\\n            long long h=v[i-1]+an;\\n            v.push_back(h);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420130,
                "title": "simple-prefix-sum",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def findPrefixScore(self, nums):\\n        max_, sum_ = 0, 0\\n        res = []\\n        for num in nums:\\n            max_ = max(max_, num)\\n            res.append(num + max_)\\n        last = 0\\n        for i, val in enumerate(res):\\n            res[i] += last\\n            last += val\\n        return res\\n```\\nUpVote, if you like it **:)**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findPrefixScore(self, nums):\\n        max_, sum_ = 0, 0\\n        res = []\\n        for num in nums:\\n            max_ = max(max_, num)\\n            res.append(num + max_)\\n        last = 0\\n        for i, val in enumerate(res):\\n            res[i] += last\\n            last += val\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554506,
                "title": "c-time-o-n-space-o-n",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> v(n,0);\\n        v[0] += nums[0]*2;\\n        long long mx = nums[0];\\n        for(int i = 1; i < n; i++){\\n            mx = max(nums[i]*1LL,mx);\\n            v[i] = mx+nums[i];\\n            v[i] += v[i-1];\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> v(n,0);\\n        v[0] += nums[0]*2;\\n        long long mx = nums[0];\\n        for(int i = 1; i < n; i++){\\n            mx = max(nums[i]*1LL,mx);\\n            v[i] = mx+nums[i];\\n            v[i] += v[i-1];\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438048,
                "title": "short-and-crisp-beginner-friendly-one-pass-o-n-time-complexity",
                "content": "\\n\\n# Approach\\nJust keep track of maximum element before i+1 index and to take on prefix array to store values at same time.\\n\\n# Complexity\\n- Time complexity:\\no(n);\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        \\n        int n =  nums.size();\\n        vector<long long > ans(n,0);//prefix Array to return\\n        int maxi =  nums[0];\\n        ans[0] = 2*nums[0];\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            maxi = max(maxi,nums[i]); //track of maxi before i+1 index\\n            nums[i]+=maxi; \\n            ans[i]+=ans[i-1]+nums[i];//Making prefix array to return\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        \\n        int n =  nums.size();\\n        vector<long long > ans(n,0);//prefix Array to return\\n        int maxi =  nums[0];\\n        ans[0] = 2*nums[0];\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            maxi = max(maxi,nums[i]); //track of maxi before i+1 index\\n            nums[i]+=maxi; \\n            ans[i]+=ans[i-1]+nums[i];//Making prefix array to return\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423547,
                "title": "c-easiest-approach-prefix-sum-beginner-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will use Prefix-Sum method here to find maximum element till every i\\'th index.\\nThen we will add out prefix_max at i\\'th position to our original vector at i\\'th position.\\nAt last we will take sum upto every i\\'th index and push it into our answer vector.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        \\n        vector<long long> prefix_max;\\n        int max_current=nums[0];\\n        prefix_max.push_back(max_current);\\n        for(int i=1;i<n;i++)\\n        {\\n            max_current=max(max_current,nums[i]);\\n            prefix_max.push_back(max_current);\\n        }\\n        \\n        vector<long long> ans;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]+=prefix_max[i];\\n        }\\n        \\n        long long sum=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n            ans.push_back(sum);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n![2ddedd60-39d6-4167-9b77-88e10400f044_1673586388.8794823.jpeg](https://assets.leetcode.com/users/images/ca1f0d37-8838-454f-b4e8-dc22323e3ed3_1681647899.5235333.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        \\n        vector<long long> prefix_max;\\n        int max_current=nums[0];\\n        prefix_max.push_back(max_current);\\n        for(int i=1;i<n;i++)\\n        {\\n            max_current=max(max_current,nums[i]);\\n            prefix_max.push_back(max_current);\\n        }\\n        \\n        vector<long long> ans;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]+=prefix_max[i];\\n        }\\n        \\n        long long sum=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n            ans.push_back(sum);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421177,
                "title": "one-liner",
                "content": "**Python3**\\n```python\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        return accumulate(map(add, nums, accumulate(nums, max)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        return accumulate(map(add, nums, accumulate(nums, max)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420325,
                "title": "c-o-n-solution",
                "content": "\\n# Approach: Prefix Sum\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ for the answer array\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        long long maxy = 0, conver = 0, sum = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            maxy = nums[i] > maxy ? nums[i] : maxy;\\n            conver = maxy + nums[i];\\n            sum += conver;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        long long maxy = 0, conver = 0, sum = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            maxy = nums[i] > maxy ? nums[i] : maxy;\\n            conver = maxy + nums[i];\\n            sum += conver;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420219,
                "title": "simple-o-n",
                "content": "# Intuition\\nUse memoization\\n\\n# Approach\\nIterate the initial array. Store both max so far and score of i-1. For ith element max(i) = max(max(i-1), nums(i)), score(i) = score(i-1) + max(i) + nums(i).\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findPrefixScore = function(nums) {\\n    let sum = 0\\n    let max = nums[0]\\n    \\n    let res = []\\n    for(let i = 0; i < nums.length; i++){\\n        max = Math.max(nums[i], max);\\n        sum += (max + nums[i])\\n        res.push(sum);\\n    }\\n    \\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findPrefixScore = function(nums) {\\n    let sum = 0\\n    let max = nums[0]\\n    \\n    let res = []\\n    for(let i = 0; i < nums.length; i++){\\n        max = Math.max(nums[i], max);\\n        sum += (max + nums[i])\\n        res.push(sum);\\n    }\\n    \\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3419995,
                "title": "python-1-liner-solution",
                "content": "# **Explanation**\\nGet the accumulate max array of  `pre_max`\\nAnd return the accumulate sum of `A + max_acc`\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n\\n**Python**\\n```py\\n    def findPrefixScore(self, A: List[int]) -> List[int]:\\n        acc_max = accumulate(A, max)\\n        return list(accumulate(map(sum, zip(A, acc_max))))\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def findPrefixScore(self, A: List[int]) -> List[int]:\\n        acc_max = accumulate(A, max)\\n        return list(accumulate(map(sum, zip(A, acc_max))))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3443265,
                "title": "c-o-n-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHello guys, Here you just have to simply iterate the array and keep a max count  till  ith index.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n Here I am explaining my approach :\\n1.) Simply iterate the array from 1st index to last.\\n2.) Keep a max to keep account of maximum till the ith index. \\n3.) Simply add this max to current index to get the value.\\n4.) Now you have sum the elements of this ans array to get final result.\\n5.) Taken a cur pointer and with the help of it added them , this cur contains sum till (i-1)th index.\\n6.)Keep in mind to take long long variable otherwise you will get TLE\\n\\n# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N+N) \\ni.e. O(2*N) ~ O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(2*N) [for sum and ans array]\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        \\n        vector<long long > ans,sum;\\n        int n = nums.size();\\n\\n        long long max = nums[0];\\n        sum.push_back(2*nums[0]);\\n        ans.push_back(2*nums[0]);\\n\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>max) max = nums[i];\\n\\n            sum.push_back(nums[i]+max);\\n        }\\n        \\n        long long cur = sum[0];\\n        \\n        for(int i=1;i<n;i++){\\n            long long summ =0;\\n            summ = sum[i]+cur;\\n            ans.push_back(summ);\\n            cur = summ;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        \\n        vector<long long > ans,sum;\\n        int n = nums.size();\\n\\n        long long max = nums[0];\\n        sum.push_back(2*nums[0]);\\n        ans.push_back(2*nums[0]);\\n\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>max) max = nums[i];\\n\\n            sum.push_back(nums[i]+max);\\n        }\\n        \\n        long long cur = sum[0];\\n        \\n        for(int i=1;i<n;i++){\\n            long long summ =0;\\n            summ = sum[i]+cur;\\n            ans.push_back(summ);\\n            cur = summ;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420212,
                "title": "simple-c-solution-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long > temp(n);\\n        int maxval=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n             maxval=max(maxval,nums[i]);\\n             temp[i]=nums[i]+maxval;\\n            if(i>0)\\n            {\\n                temp[i]+=temp[i-1];\\n            }\\n           \\n            \\n        }\\n \\n        \\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long > temp(n);\\n        int maxval=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n             maxval=max(maxval,nums[i]);\\n             temp[i]=nums[i]+maxval;\\n            if(i>0)\\n            {\\n                temp[i]+=temp[i-1];\\n            }\\n           \\n            \\n        }\\n \\n        \\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420118,
                "title": "c-prefix-sum-short-sweet-easy-to-understand",
                "content": "````\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size(),i;\\n        vector<long long int> mx(n),dp(n);\\n        dp[0] = 2*nums[0],mx[0] = nums[0];\\n        for(i = 1; i < n; i++){\\n            mx[i] = max(mx[i-1],nums[i]*1LL);\\n        }\\n        for(i = 1; i < n; i++){\\n            dp[i] = nums[i]+dp[i-1]+mx[i];\\n        }\\n        return dp;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size(),i;\\n        vector<long long int> mx(n),dp(n);\\n        dp[0] = 2*nums[0],mx[0] = nums[0];\\n        for(i = 1; i < n; i++){\\n            mx[i] = max(mx[i-1],nums[i]*1LL);\\n        }\\n        for(i = 1; i < n; i++){\\n            dp[i] = nums[i]+dp[i-1]+mx[i];\\n        }\\n        return dp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420032,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<ll> ans;\\n        int n = nums.size();\\n        ll sum = 0,maxVal=0,val;\\n        for(int i=0;i<n;i++){\\n            maxVal = max(maxVal, (ll)nums[i]);\\n            val = nums[i] + maxVal;\\n            sum += val;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<ll> ans;\\n        int n = nums.size();\\n        ll sum = 0,maxVal=0,val;\\n        for(int i=0;i<n;i++){\\n            maxVal = max(maxVal, (ll)nums[i]);\\n            val = nums[i] + maxVal;\\n            sum += val;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966852,
                "title": "fastest-efficient-approach",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> conver;\\n        long long  prevMax = -1 ;\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            prevMax = max(prevMax, (long long)nums[i]) ;\\n            if(i == 0){\\n                conver.push_back(prevMax + nums[i]) ;\\n            }else{\\n                conver.push_back(prevMax + nums[i] + conver.back()) ;\\n            }\\n        }\\n        return conver ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> conver;\\n        long long  prevMax = -1 ;\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            prevMax = max(prevMax, (long long)nums[i]) ;\\n            if(i == 0){\\n                conver.push_back(prevMax + nums[i]) ;\\n            }else{\\n                conver.push_back(prevMax + nums[i] + conver.back()) ;\\n            }\\n        }\\n        return conver ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920265,
                "title": "o-n-approach",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\nFor storing the answer\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> conver(n);\\n        vector<long long> score(n);\\n        \\n        \\n        \\n        long long prefixMax = nums[0];\\n        conver[0] = nums[0] + prefixMax;\\n        score[0] = conver[0];\\n        long long prefixSum = conver[0];\\n        \\n        for(int i=1;i<n;i++) {\\n            prefixMax = max(static_cast<long long>(nums[i]), prefixMax);  // Use long long here\\n            conver[i] = static_cast<long long>(nums[i]) + prefixMax;      // Use long long here\\n            \\n            \\n            prefixSum += conver[i];\\n            \\n            score[i] = prefixSum;\\n            \\n            \\n        }\\n        \\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> conver(n);\\n        vector<long long> score(n);\\n        \\n        \\n        \\n        long long prefixMax = nums[0];\\n        conver[0] = nums[0] + prefixMax;\\n        score[0] = conver[0];\\n        long long prefixSum = conver[0];\\n        \\n        for(int i=1;i<n;i++) {\\n            prefixMax = max(static_cast<long long>(nums[i]), prefixMax);  // Use long long here\\n            conver[i] = static_cast<long long>(nums[i]) + prefixMax;      // Use long long here\\n            \\n            \\n            prefixSum += conver[i];\\n            \\n            score[i] = prefixSum;\\n            \\n            \\n        }\\n        \\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849823,
                "title": "simple-code-with-simple-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe simply iterate over array keeping track of maximum value and also storing the total sum\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nif the array is is less than or eqaul maxi then simply add the maxi to that element and store it ,if not add the same maxi twice and push\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        int maxi=nums[0];\\n        long long tot=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<=maxi){\\n                tot+=nums[i]+maxi;\\n                ans.push_back(tot);\\n            }\\n            else{\\n                 maxi=nums[i];\\n                 tot+=2*maxi;\\n                 ans.push_back(tot);\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        int maxi=nums[0];\\n        long long tot=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<=maxi){\\n                tot+=nums[i]+maxi;\\n                ans.push_back(tot);\\n            }\\n            else{\\n                 maxi=nums[i];\\n                 tot+=2*maxi;\\n                 ans.push_back(tot);\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849219,
                "title": "beats-99-80-of-users-with-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n         int n=nums.size();\\n        vector<long long>ans(n);\\n        ans[0]=2*nums[0];\\n       long long maxi=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>maxi)\\n            maxi=nums[i];\\n            ans[i]=ans[i-1]+nums[i]+maxi;\\n        }\\n        return ans;;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n         int n=nums.size();\\n        vector<long long>ans(n);\\n        ans[0]=2*nums[0];\\n       long long maxi=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>maxi)\\n            maxi=nums[i];\\n            ans[i]=ans[i-1]+nums[i]+maxi;\\n        }\\n        return ans;;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590130,
                "title": "simple-solution-o-n-time-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr= new long[nums.length];\\n        long max=nums[0];\\n        long sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            max=max<=nums[i]?nums[i]:max;\\n            sum=sum+nums[i]+max;\\n            arr[i]=sum;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr= new long[nums.length];\\n        long max=nums[0];\\n        long sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            max=max<=nums[i]?nums[i]:max;\\n            sum=sum+nums[i]+max;\\n            arr[i]=sum;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519543,
                "title": "easy-solution",
                "content": "# Intuition \\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply traverse the array\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nkeep track of max and sum as you go ahead\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nIf you find it helpful then please upvote (thanks)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n       int n = nums.size();\\n       vector<long long> score;\\n       long long max = INT_MIN;\\n       long long sum = 0;\\n       for(int i=0;i<n;i++){\\n           if(nums[i]>max)max = nums[i];\\n           sum += max+nums[i];\\n           score.push_back(sum);\\n       }\\n       return score; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n       int n = nums.size();\\n       vector<long long> score;\\n       long long max = INT_MIN;\\n       long long sum = 0;\\n       for(int i=0;i<n;i++){\\n           if(nums[i]>max)max = nums[i];\\n           sum += max+nums[i];\\n           score.push_back(sum);\\n       }\\n       return score; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444609,
                "title": "java-fastest-runtime-easy-and-elegant-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n     long a = 0;\\n        long max = nums[0];\\n        long[] k = new long[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            if (max < nums[i]) {\\n                max = nums[i];\\n            }\\n            k[i] = a + nums[i] + max;\\n            a = k[i];\\n        }\\n        return k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n     long a = 0;\\n        long max = nums[0];\\n        long[] k = new long[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            if (max < nums[i]) {\\n                max = nums[i];\\n            }\\n            k[i] = a + nums[i] + max;\\n            a = k[i];\\n        }\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425978,
                "title": "max-val-in-prefix-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        //we will do some precomputation to find the max in the range\\n        vector<int>prefix(nums.size(),-1);\\n        prefix[0] = nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            int ele = max(prefix[i-1],nums[i]);\\n            prefix[i] = ele;\\n        }\\n        //we are going to make the ans vector\\n        vector<long long>ans;\\n\\n        //now making ans for the every index\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            long long ele = nums[i];\\n            long long tillmax = prefix[i];\\n\\n            if(ans.size() == 0)\\n            {\\n                long long result = (0LL + (1LL*ele) + (1LL*tillmax));\\n                ans.push_back(result);\\n            }\\n            else if(ans.size() > 0)\\n            {\\n                long long result = (0LL + (1LL*ele) + (1LL*tillmax)) + (0LL + ans.back());\\n                ans.push_back(result);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        //we will do some precomputation to find the max in the range\\n        vector<int>prefix(nums.size(),-1);\\n        prefix[0] = nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            int ele = max(prefix[i-1],nums[i]);\\n            prefix[i] = ele;\\n        }\\n        //we are going to make the ans vector\\n        vector<long long>ans;\\n\\n        //now making ans for the every index\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            long long ele = nums[i];\\n            long long tillmax = prefix[i];\\n\\n            if(ans.size() == 0)\\n            {\\n                long long result = (0LL + (1LL*ele) + (1LL*tillmax));\\n                ans.push_back(result);\\n            }\\n            else if(ans.size() > 0)\\n            {\\n                long long result = (0LL + (1LL*ele) + (1LL*tillmax)) + (0LL + ans.back());\\n                ans.push_back(result);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424772,
                "title": "easy-c-solution-prefix-array",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n= nums.size();\\n        vector<long long> conver,score(n,0);\\n        int maxi= INT_MIN;\\n        for (int i=0; i<n; i++){\\n            maxi= max(maxi,nums[i]);\\n            conver.push_back((long long)(nums[i])+maxi);\\n            \\n        }\\n        score[0]= conver[0];\\n        for (int i=1; i<n; i++){\\n            score[i]= score[i-1]+conver[i];\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Counting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n= nums.size();\\n        vector<long long> conver,score(n,0);\\n        int maxi= INT_MIN;\\n        for (int i=0; i<n; i++){\\n            maxi= max(maxi,nums[i]);\\n            conver.push_back((long long)(nums[i])+maxi);\\n            \\n        }\\n        score[0]= conver[0];\\n        for (int i=1; i<n; i++){\\n            score[i]= score[i-1]+conver[i];\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424575,
                "title": "do-exactly-what-the-question-has-asked",
                "content": "# Solution:\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length;\\n        long[] c = new long[n];\\n        int max = 0;\\n        // fill the conversion array\\n        for (int i = 0; i < n; i++) {\\n            max = Math.max(nums[i], max);\\n            c[i] = nums[i] + max;\\n        }\\n        // define the scores in the same array (prefix sum)\\n        for (int i = 1; i < n; i++) {\\n            c[i] += c[i - 1];\\n        }\\n        return c;\\n    }\\n}\\n```\\n---\\n## Single loop:\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length;\\n        long[] c = new long[n];\\n        int max = 0;\\n        for (int i = 0; i < n; i++) {\\n            max = Math.max(nums[i], max);\\n            c[i] = nums[i] + max;\\n            if (i > 0) {\\n                c[i] += c[i - 1];\\n            }\\n        }        \\n        return c;\\n    }\\n}\\n```\\n---\\n### Time complexity: $$O(n)$$\\n### Space complexity: $$O(n)$$",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length;\\n        long[] c = new long[n];\\n        int max = 0;\\n        // fill the conversion array\\n        for (int i = 0; i < n; i++) {\\n            max = Math.max(nums[i], max);\\n            c[i] = nums[i] + max;\\n        }\\n        // define the scores in the same array (prefix sum)\\n        for (int i = 1; i < n; i++) {\\n            c[i] += c[i - 1];\\n        }\\n        return c;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length;\\n        long[] c = new long[n];\\n        int max = 0;\\n        for (int i = 0; i < n; i++) {\\n            max = Math.max(nums[i], max);\\n            c[i] = nums[i] + max;\\n            if (i > 0) {\\n                c[i] += c[i - 1];\\n            }\\n        }        \\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424010,
                "title": "c-easy-solution-o-n",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe main catch here is if you are using *max_element() for finding out the max element then the code will give TLE, as *max_element() function takes $$O(n)$$ and the overall complexity turns out to be O(n<sup>2</sup>).\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        long long max1 = nums[0];\\n        ans.push_back(2*nums[0]);\\n        long long sum1 = 2*nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]>=max1){\\n                max1 = nums[i];\\n                sum1 = sum1+(2*nums[i]);\\n                ans.push_back(sum1);\\n            }else{\\n                sum1 = sum1+(nums[i]+max1);\\n                ans.push_back(sum1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote_cat.jpeg](https://assets.leetcode.com/users/images/f87692e8-d2b3-42f0-89a2-44e236bc72d7_1681659029.549422.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        long long max1 = nums[0];\\n        ans.push_back(2*nums[0]);\\n        long long sum1 = 2*nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]>=max1){\\n                max1 = nums[i];\\n                sum1 = sum1+(2*nums[i]);\\n                ans.push_back(sum1);\\n            }else{\\n                sum1 = sum1+(nums[i]+max1);\\n                ans.push_back(sum1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423148,
                "title": "c-easy-4-lines-only-o-n-faster-96",
                "content": "```c++\\nvector<long long> findPrefixScore(vector<int>& nums) {\\n    vector<long long> res;\\n    long long max_so_far = 0, prev = 0;\\n    for (auto num: nums) {\\n        max_so_far = max(max_so_far, 1LL * num);\\n        res.push_back(0LL + num + max_so_far + prev);\\n        prev = res.back();\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```c++\\nvector<long long> findPrefixScore(vector<int>& nums) {\\n    vector<long long> res;\\n    long long max_so_far = 0, prev = 0;\\n    for (auto num: nums) {\\n        max_so_far = max(max_so_far, 1LL * num);\\n        res.push_back(0LL + num + max_so_far + prev);\\n        prev = res.back();\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3422816,
                "title": "c-very-very-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        ans.push_back(nums[0]+nums[0]);\\n        int maxi=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            maxi=max(maxi,nums[i]);\\n            ans.push_back(nums[i]+maxi);\\n        }\\n        \\n        for(int i=1;i<ans.size();i++){\\n            ans[i]=ans[i-1]+ans[i]; \\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        ans.push_back(nums[0]+nums[0]);\\n        int maxi=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            maxi=max(maxi,nums[i]);\\n            ans.push_back(nums[i]+maxi);\\n        }\\n        \\n        for(int i=1;i<ans.size();i++){\\n            ans[i]=ans[i-1]+ans[i]; \\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422758,
                "title": "easy-to-undersatnd-cpp-solution",
                "content": "![UPvote.jpg](https://assets.leetcode.com/users/images/f5aa6015-14a7-4eb6-b0d6-1c39cb83a85c_1681631343.6630116.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> res;\\n        long long sum = 0;\\n        int n = nums.size();\\n        int max_elem = nums[0];\\n        for(int i=0;i<n;i++){\\n            if(nums[i] > max_elem) max_elem = nums[i];\\n            sum += max_elem + nums[i];\\n            res.push_back(sum);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> res;\\n        long long sum = 0;\\n        int n = nums.size();\\n        int max_elem = nums[0];\\n        for(int i=0;i<n;i++){\\n            if(nums[i] > max_elem) max_elem = nums[i];\\n            sum += max_elem + nums[i];\\n            res.push_back(sum);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422289,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        long[] ans=new long[n];\\n        long max=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<n;i++){\\n            max=Math.max(max>nums[i]?max:nums[i],max);\\n            ans[i]=nums[i]+max;\\n        }\\n        \\n        long sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=ans[i];\\n            ans[i]=sum;\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n//         int n=nums.length;\\n//         long conver[]=new long[n];\\n        \\n//         for(int i=0;i<nums.length;i++){\\n//             conver[i] = nums[i];\\n//             long max=0;\\n//             for(int j=0;j<=i;j++){\\n//                 if(nums[j]>max){\\n//                     max=nums[j];\\n//                 }\\n                \\n//             }\\n//             conver[i]=conver[i]+max;\\n//         }\\n        \\n//         for(int i=1;i<n;i++){\\n//             conver[i]=conver[i]+conver[i-1];\\n//         }\\n//         return conver;\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        long[] ans=new long[n];\\n        long max=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<n;i++){\\n            max=Math.max(max>nums[i]?max:nums[i],max);\\n            ans[i]=nums[i]+max;\\n        }\\n        \\n        long sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=ans[i];\\n            ans[i]=sum;\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n//         int n=nums.length;\\n//         long conver[]=new long[n];\\n        \\n//         for(int i=0;i<nums.length;i++){\\n//             conver[i] = nums[i];\\n//             long max=0;\\n//             for(int j=0;j<=i;j++){\\n//                 if(nums[j]>max){\\n//                     max=nums[j];\\n//                 }\\n                \\n//             }\\n//             conver[i]=conver[i]+max;\\n//         }\\n        \\n//         for(int i=1;i<n;i++){\\n//             conver[i]=conver[i]+conver[i-1];\\n//         }\\n//         return conver;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422073,
                "title": "c-brute-force-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int maxi=nums[0];\\n        vector<long long int>ans(nums.size(), 0);\\n        for(int i=0; i<nums.size(); i++){\\n            maxi=max(maxi, nums[i]);\\n            ans[i]=nums[i];\\n            ans[i]+=maxi;\\n        }\\n        for(int i=1; i<nums.size(); i++){\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int maxi=nums[0];\\n        vector<long long int>ans(nums.size(), 0);\\n        for(int i=0; i<nums.size(); i++){\\n            maxi=max(maxi, nums[i]);\\n            ans[i]=nums[i];\\n            ans[i]+=maxi;\\n        }\\n        for(int i=1; i<nums.size(); i++){\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422068,
                "title": "c-brute-force",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int maxi=nums[0];\\n        vector<long long int>ans(nums.size(), 0);\\n        for(int i=0; i<nums.size(); i++){\\n            maxi=max(maxi, nums[i]);\\n            ans[i]=nums[i];\\n            ans[i]+=maxi;\\n        }\\n        for(int i=1; i<nums.size(); i++){\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int maxi=nums[0];\\n        vector<long long int>ans(nums.size(), 0);\\n        for(int i=0; i<nums.size(); i++){\\n            maxi=max(maxi, nums[i]);\\n            ans[i]=nums[i];\\n            ans[i]+=maxi;\\n        }\\n        for(int i=1; i<nums.size(); i++){\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422067,
                "title": "c-brute-force",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int maxi=nums[0];\\n        vector<long long int>ans(nums.size(), 0);\\n        for(int i=0; i<nums.size(); i++){\\n            maxi=max(maxi, nums[i]);\\n            ans[i]=nums[i];\\n            ans[i]+=maxi;\\n        }\\n        for(int i=1; i<nums.size(); i++){\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int maxi=nums[0];\\n        vector<long long int>ans(nums.size(), 0);\\n        for(int i=0; i<nums.size(); i++){\\n            maxi=max(maxi, nums[i]);\\n            ans[i]=nums[i];\\n            ans[i]+=maxi;\\n        }\\n        for(int i=1; i<nums.size(); i++){\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421994,
                "title": "optimized-java-solution-easy-structured-with-comments-and-approach",
                "content": "# Approach\\nThe key to solving the problem is literally by writing the arrays on a paper and figuring out where to add what. The given formula is `conver[i] = arr[i] + max(arr[0..i]) `.\\n\\nNow, with this we can understand that conversion array will contain sum of element at i and maximum element till i. Hence, we need to keep track of maximum element till i and check for it first when we iterate. \\n\\nNext, we do not want to return the conversion array!  We are asked to return array of sums from 0 to i of conversion array. Hence, we\\'ll keep track of sum and store that in the array to return it.\\n\\nIn the given solution, conversion array is not stored as it will just take extra space. But for understanding purposes, you can get to conversion array first and then iterate another loop to get sum/ans array.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` java\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        // array of sums till i\\n        long ans[]=new long[nums.length];\\n        long sum=0;\\n        int max=nums[0];\\n        for (int i=0;i<nums.length;i++){\\n            // updating max\\n            if(nums[i] > max)\\n                max = nums[i];\\n\\n            // conversion array value = nums[i]+max\\n            // ans array = sum of all till i\\n            sum = sum + nums[i] + max;\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        // array of sums till i\\n        long ans[]=new long[nums.length];\\n        long sum=0;\\n        int max=nums[0];\\n        for (int i=0;i<nums.length;i++){\\n            // updating max\\n            if(nums[i] > max)\\n                max = nums[i];\\n\\n            // conversion array value = nums[i]+max\\n            // ans array = sum of all till i\\n            sum = sum + nums[i] + max;\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420828,
                "title": "python-greedy-6-lines-100-beats",
                "content": "```python\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        s, m, a = 0, 0, []\\n\\n        for n in nums:\\n            m = max(m, n)\\n            s += n + m\\n            a.append(s)\\n\\n        return a\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        s, m, a = 0, 0, []\\n\\n        for n in nums:\\n            m = max(m, n)\\n            s += n + m\\n            a.append(s)\\n\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420591,
                "title": "explained-with-code-c-easy-to-understand-and-implement",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe need a maxium from the 0th index to current index so we can just get it using\\n`max_i = max(max_i,nums[i])`\\nit will the the latest maximum number\\n`ans[1] = nums[1] + max_i + ans[0]`(which is a prefix sum until now)\\n\\n# Complexity\\n## - Time complexity: O(n)\\n\\n## - Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        int max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        ans[0] = nums[0] + nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            ans[i] = nums[i] + max_i + ans[i-1];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        int max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        ans[0] = nums[0] + nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            ans[i] = nums[i] + max_i + ans[i-1];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420382,
                "title": "c-well-explained-8-line-code-prefix-sum-o-n-time",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n***O(N)***\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n***O(1)***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        for(auto it : nums) ans.push_back(it);\\n        long long maxi = 0;\\n        for(int i=0; i<ans.size(); i++) {\\n            maxi = max(maxi, ans[i]);\\n            ans[i] += maxi;\\n        }\\n        for(int i=1; i<ans.size(); i++) ans[i] += ans[i-1];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        for(auto it : nums) ans.push_back(it);\\n        long long maxi = 0;\\n        for(int i=0; i<ans.size(); i++) {\\n            maxi = max(maxi, ans[i]);\\n            ans[i] += maxi;\\n        }\\n        for(int i=1; i<ans.size(); i++) ans[i] += ans[i-1];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420243,
                "title": "c-solution",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>ans;\\n        int max = 0;\\n        for(int i=0;i<nums.size();i++){\\nif(nums[i] > max) {\\n    max = nums[i];\\n}\\n            ans.push_back(max+nums[i]);\\n}\\n    long sum = ans[0];\\n        for(int i = 1; i < nums.size(); i++) {\\nsum += ans[i];\\n            ans[i] = sum;\\n            \\n}\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>ans;\\n        int max = 0;\\n        for(int i=0;i<nums.size();i++){\\nif(nums[i] > max) {\\n    max = nums[i];\\n}\\n            ans.push_back(max+nums[i]);\\n}\\n    long sum = ans[0];\\n        for(int i = 1; i < nums.size(); i++) {\\nsum += ans[i];\\n            ans[i] = sum;\\n            \\n}\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420238,
                "title": "java-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr = new long[nums.length];\\n        long max = 0;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            max = Math.max(max, nums[i]);\\n            \\n            arr[i] = nums[i] + max;\\n        }\\n        \\n        long sum = arr[0];\\n        for(int i = 1; i < nums.length; i++) {\\n            sum += arr[i];\\n            arr[i] = sum;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr = new long[nums.length];\\n        long max = 0;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            max = Math.max(max, nums[i]);\\n            \\n            arr[i] = nums[i] + max;\\n        }\\n        \\n        long sum = arr[0];\\n        for(int i = 1; i < nums.length; i++) {\\n            sum += arr[i];\\n            arr[i] = sum;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420211,
                "title": "easy-c",
                "content": "# Intuition\\nIf you see pattern here then it is like \\nfor example [2,3,7,5,10]\\nanswer is \\nans[0] = 2 + max(2) + 0\\nans[1] = 3 + max(2,3) + ans[0];\\nans[2] = 7 + max(2,3,7) + ans[1];\\nans[3] = 5 + max(2,3,7,5) + ans[2];\\nans[4] = 10 + max(2,3,7,5,10) + ans[3];\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans(nums.size(),0);\\n        \\n        long long sum = nums[0];\\n        long long maxi = nums[0];\\n        \\n        ans[0] = sum+maxi;\\n        \\n        for(int i = 1; i < nums.size(); i++)\\n        {\\n            maxi = max((long long) nums[i],maxi);\\n            ans[i] = maxi + (long long)nums[i] + ans[i-1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans(nums.size(),0);\\n        \\n        long long sum = nums[0];\\n        long long maxi = nums[0];\\n        \\n        ans[0] = sum+maxi;\\n        \\n        for(int i = 1; i < nums.size(); i++)\\n        {\\n            maxi = max((long long) nums[i],maxi);\\n            ans[i] = maxi + (long long)nums[i] + ans[i-1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420190,
                "title": "c-simple-iteration",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe use a loop to iterate over the elements of the array and update the maximum element seen so far. Then, calculate the prefix score for the current element by adding it to the maximum element seen so far. Finally, store the prefix score for each element in a vector and returns the vector as the result. \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<long long>ans(n);\\n        int max_till=0;\\n        for(int i=0;i<n;++i){\\n            max_till=max(arr[i],max_till);\\n            long long curr=arr[i]+max_till;\\n            if(i==0){\\n                ans[i]=curr;\\n            }\\n            else ans[i]=ans[i-1]+curr;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<long long>ans(n);\\n        int max_till=0;\\n        for(int i=0;i<n;++i){\\n            max_till=max(arr[i],max_till);\\n            long long curr=arr[i]+max_till;\\n            if(i==0){\\n                ans[i]=curr;\\n            }\\n            else ans[i]=ans[i-1]+curr;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420156,
                "title": "c-short-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        \\n        int n = size(nums);\\n        \\n        vector<long long> prefix;\\n        \\n        long long mx = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            mx = max(mx,0LL+nums[i]);\\n            if(prefix.empty())prefix.push_back(nums[i]+mx);\\n            else prefix.push_back(0ll+prefix.back()+nums[i]+mx);\\n        }\\n        \\n        return prefix;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        \\n        int n = size(nums);\\n        \\n        vector<long long> prefix;\\n        \\n        long long mx = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            mx = max(mx,0LL+nums[i]);\\n            if(prefix.empty())prefix.push_back(nums[i]+mx);\\n            else prefix.push_back(0ll+prefix.back()+nums[i]+mx);\\n        }\\n        \\n        return prefix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420152,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        acc_max=accumulate(nums,max)\\n        return list(accumulate(map(sum,zip(nums,acc_max))))\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        acc_max=accumulate(nums,max)\\n        return list(accumulate(map(sum,zip(nums,acc_max))))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420115,
                "title": "java-prefix-sum-easiest-o-n-self-explanatory",
                "content": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length, max = -1;\\n        long[] conv = new long[n];\\n        \\n        for(int i=0;i<n;i++){\\n          max = Math.max(max, nums[i]);\\n          conv[i] = nums[i] + max;\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            conv[i] = conv[i-1] + conv[i];\\n        }\\n        \\n        return conv;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length, max = -1;\\n        long[] conv = new long[n];\\n        \\n        for(int i=0;i<n;i++){\\n          max = Math.max(max, nums[i]);\\n          conv[i] = nums[i] + max;\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            conv[i] = conv[i-1] + conv[i];\\n        }\\n        \\n        return conv;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420089,
                "title": "c-2-lines-easy-solution-o-n",
                "content": "# Approach\\nThe prefix score of an element at index i is the sum of the maximum element from index 0 to i and the element at index i itself. This prefix score is calculated for all elements in the input vector and returned in the output vector.\\n\\n# Complexity\\n- Time complexity:\\nThe function iterates through the input vector once, so the time complexity is O(n), where n is the size of the input vector.\\n\\n- Space complexity:\\nThe function creates a new vector to store the prefix scores, so the space complexity is also O(n), where n is the size of the input vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> conver;\\n        int maks=nums[0];\\n        long long hence=0;\\n        for(int i=0; i<nums.size(); i++){\\n            maks = max(maks,nums[i]);\\n            hence+=maks+nums[i];\\n            conver.push_back(hence);\\n        }\\n       \\n        return conver;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> conver;\\n        int maks=nums[0];\\n        long long hence=0;\\n        for(int i=0; i<nums.size(); i++){\\n            maks = max(maks,nums[i]);\\n            hence+=maks+nums[i];\\n            conver.push_back(hence);\\n        }\\n       \\n        return conver;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420067,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findPrefixScore = function(nums) {\\n    const ans = [];\\n    let max = 0, sum = 0;\\n    for (const n of nums) {\\n        max = Math.max(max, n);\\n        sum += n + max;\\n        ans.push(sum);\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findPrefixScore = function(nums) {\\n    const ans = [];\\n    let max = 0, sum = 0;\\n    for (const n of nums) {\\n        max = Math.max(max, n);\\n        sum += n + max;\\n        ans.push(sum);\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3420037,
                "title": "easy-java-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] res = new long[nums.length];\\n        long sum = 0;\\n        long max = 0;\\n        for(int i = 0; i<nums.length; i++){\\n            max = Math.max(max, nums[i]);\\n            sum += nums[i] + max;\\n            res[i] = sum;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] res = new long[nums.length];\\n        long sum = 0;\\n        long max = 0;\\n        for(int i = 0; i<nums.length; i++){\\n            max = Math.max(max, nums[i]);\\n            sum += nums[i] + max;\\n            res[i] = sum;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420028,
                "title": "1-loop-solution-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int t = 0, n = nums.size(); \\n        vector<long long> ans(n, 0);\\n        \\n        for(int i=0; i<n; i++){\\n            t = max(t, nums[i]); \\n            ans[i] = nums[i] + t; \\n            if(i>0) ans[i] += ans[i-1];\\n        }\\n        \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int t = 0, n = nums.size(); \\n        vector<long long> ans(n, 0);\\n        \\n        for(int i=0; i<n; i++){\\n            t = max(t, nums[i]); \\n            ans[i] = nums[i] + t; \\n            if(i>0) ans[i] += ans[i-1];\\n        }\\n        \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420027,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution{\\n    typedef long long ll;\\npublic:\\n    vector<ll> findPrefixScore(const vector<int>&v){\\n        ll n=v.size();\\n        vector<ll>ans(n), pref(n); // Convers\\n        pref[0]=ans[0]=2*v[0];\\n        for(ll i=1, mx=v[0]; i<n; ++i){\\n            mx=max(mx, ll(v[i])); // max so far\\n            pref[i]=v[i]+mx;\\n            ans[i]=ans[i-1]+pref[i]; // sum of Convers, i.e., the cur score\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution{\\n    typedef long long ll;\\npublic:\\n    vector<ll> findPrefixScore(const vector<int>&v){\\n        ll n=v.size();\\n        vector<ll>ans(n), pref(n); // Convers\\n        pref[0]=ans[0]=2*v[0];\\n        for(ll i=1, mx=v[0]; i<n; ++i){\\n            mx=max(mx, ll(v[i])); // max so far\\n            pref[i]=v[i]+mx;\\n            ans[i]=ans[i-1]+pref[i]; // sum of Convers, i.e., the cur score\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419998,
                "title": "c-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        long long x = nums[0];\\n        for(int i=0;i<nums.size();i++){\\n            if(x<nums[i]) x = nums[i];\\n            nums[i] += x;\\n        }\\n        vector<long long> ans(nums.size());\\n        ans[0] = nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            ans[i] += (nums[i]+ans[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        long long x = nums[0];\\n        for(int i=0;i<nums.size();i++){\\n            if(x<nums[i]) x = nums[i];\\n            nums[i] += x;\\n        }\\n        vector<long long> ans(nums.size());\\n        ans[0] = nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            ans[i] += (nums[i]+ans[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419983,
                "title": "easy-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr = new long[nums.length];\\n        long max = nums[0];\\n       \\n        for(int i =0 ;i < nums.length;i++){\\n            if(nums[i] > max){\\n                max = nums[i];\\n            }\\n             System.out.println(max);\\n            long sum = max + nums[i];\\n            arr[i] = sum;\\n        }\\n        for(int i =1 ;i<arr.length;i++){\\n            arr[i] = arr[i] + arr[i-1];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr = new long[nums.length];\\n        long max = nums[0];\\n       \\n        for(int i =0 ;i < nums.length;i++){\\n            if(nums[i] > max){\\n                max = nums[i];\\n            }\\n             System.out.println(max);\\n            long sum = max + nums[i];\\n            arr[i] = sum;\\n        }\\n        for(int i =1 ;i<arr.length;i++){\\n            arr[i] = arr[i] + arr[i-1];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101062,
                "title": "simple-and-easy-to-understand-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long arr[] = new long[nums.length];\\n        long max = Integer.MIN_VALUE;\\n        long sum = 0;\\n        for(int i=0; i<nums.length; i++) {\\n            max = Math.max(max, nums[i]);\\n            sum = sum + max + nums[i];\\n            arr[i] = sum;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long arr[] = new long[nums.length];\\n        long max = Integer.MIN_VALUE;\\n        long sum = 0;\\n        for(int i=0; i<nums.length; i++) {\\n            max = Math.max(max, nums[i]);\\n            sum = sum + max + nums[i];\\n            arr[i] = sum;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088059,
                "title": "python3-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        maximum = nums[0]\\n        res = [2 * nums[0]]\\n        for i in range(1, len(nums)):\\n            maximum = max(maximum, nums[i])\\n            res.append(res[i - 1] + nums[i] + maximum)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        maximum = nums[0]\\n        res = [2 * nums[0]]\\n        for i in range(1, len(nums)):\\n            maximum = max(maximum, nums[i])\\n            res.append(res[i - 1] + nums[i] + maximum)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081077,
                "title": "easy-to-understand-c-o-n-beats-94-59",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> v;\\n        int m = 0;\\n        long long sum = 0;\\n        for(int i = 0; i<nums.size(); ++i){\\n            m = max(m, nums[i]);\\n            nums[i] = nums[i] + m;\\n            sum += nums[i];\\n            v.push_back(sum);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> v;\\n        int m = 0;\\n        long long sum = 0;\\n        for(int i = 0; i<nums.size(); ++i){\\n            m = max(m, nums[i]);\\n            nums[i] = nums[i] + m;\\n            sum += nums[i];\\n            v.push_back(sum);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072916,
                "title": "java-solution-100-faster-o-n",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int[] conver = new int[nums.length];\\n        int max = 0;\\n\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] > max)\\n                max = nums[i];\\n\\n            conver[i] = nums[i]+max;\\n        }\\n\\n        long[] ans = new long[nums.length];\\n\\n        ans[0] = conver[0];\\n\\n        for(int i = 1; i < nums.length; i++)\\n            ans[i] = ans[i-1]+conver[i];\\n\\n        return ans;   \\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int[] conver = new int[nums.length];\\n        int max = 0;\\n\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] > max)\\n                max = nums[i];\\n\\n            conver[i] = nums[i]+max;\\n        }\\n\\n        long[] ans = new long[nums.length];\\n\\n        ans[0] = conver[0];\\n\\n        for(int i = 1; i < nums.length; i++)\\n            ans[i] = ans[i-1]+conver[i];\\n\\n        return ans;   \\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069449,
                "title": "very-easy-using-vector",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n       int n=nums.size();\\n       int maxi=-1;\\n       vector<long long>ans;\\n       long long sum=0;\\n       map<int,int>mp;\\n       for(int i=0;i<n;i++){\\n           maxi=max(maxi,nums[i]);\\n           mp[i]=maxi;\\n           sum+=(nums[i]+mp[i]);\\n           ans.push_back(sum);\\n       }\\n       return ans;\\n      \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n       int n=nums.size();\\n       int maxi=-1;\\n       vector<long long>ans;\\n       long long sum=0;\\n       map<int,int>mp;\\n       for(int i=0;i<n;i++){\\n           maxi=max(maxi,nums[i]);\\n           mp[i]=maxi;\\n           sum+=(nums[i]+mp[i]);\\n           ans.push_back(sum);\\n       }\\n       return ans;\\n      \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069443,
                "title": "very-easy-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n       int n=nums.size();\\n       int maxi=-1;\\n       vector<long long>ans;\\n       long long sum=0;\\n       map<int,int>mp;\\n       for(int i=0;i<n;i++){\\n           maxi=max(maxi,nums[i]);\\n           mp[i]=maxi;\\n           sum+=(nums[i]+mp[i]);\\n           ans.push_back(sum);\\n       }\\n       return ans;\\n      \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n       int n=nums.size();\\n       int maxi=-1;\\n       vector<long long>ans;\\n       long long sum=0;\\n       map<int,int>mp;\\n       for(int i=0;i<n;i++){\\n           maxi=max(maxi,nums[i]);\\n           mp[i]=maxi;\\n           sum+=(nums[i]+mp[i]);\\n           ans.push_back(sum);\\n       }\\n       return ans;\\n      \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066305,
                "title": "c-really-easy-and-clean-solution",
                "content": "\\'\\'\\'\\n\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int N=nums.size();\\n        vector<long long> res(N);\\n        vector<long long> conv(N);\\n        long long score=0, maxVal=0;\\n        for (int i=0; i<nums.size(); i++) {\\n            maxVal = max(maxVal, (long long)nums[i]);\\n            conv[i] = nums[i] + maxVal;\\n            score += conv[i];\\n            res[i] = score;\\n        }\\n        \\n        return res;\\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int N=nums.size();\\n        vector<long long> res(N);\\n        vector<long long> conv(N);\\n        long long score=0, maxVal=0;\\n        for (int i=0; i<nums.size(); i++) {\\n            maxVal = max(maxVal, (long long)nums[i]);\\n            conv[i] = nums[i] + maxVal;\\n            score += conv[i];\\n            res[i] = score;\\n        }\\n        \\n        return res;\\n    }\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 4063799,
                "title": "python-elegant-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse the `accumulate(nums, max)` to keep track of the running maximum, \\n`map(add, nums, accumulate(nums, max))` to add the running maxima to the elements of the input list, and finally `accumulate` all that to get the desired result.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ - we bascially do what amounts to a single iteration over the source list\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ - it\\'s all iterators inside, no temporary lists are ever allocated.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        return accumulate(map(add, nums, accumulate(nums, max)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        return accumulate(map(add, nums, accumulate(nums, max)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051688,
                "title": "simple-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int max=INT_MIN;\\n        vector<long long> ans;\\n        long long score =0;\\n        int idx=0;\\n\\n        while(idx<nums.size())\\n        {\\n            if (max <nums[idx])\\n            {\\n                max = nums[idx];\\n            }\\n            score = score + nums[idx] + max;\\n            ans.push_back(score);\\n            idx++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int max=INT_MIN;\\n        vector<long long> ans;\\n        long long score =0;\\n        int idx=0;\\n\\n        while(idx<nums.size())\\n        {\\n            if (max <nums[idx])\\n            {\\n                max = nums[idx];\\n            }\\n            score = score + nums[idx] + max;\\n            ans.push_back(score);\\n            idx++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043158,
                "title": "beats-99-68-runtime-most-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        vector<long long>conver;\\n        int ma=INT_MIN;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ma=max(ma,nums[i]);\\n            conver.push_back(nums[i]+ma);\\n        }\\n        vector<long long>ans;\\n        long long res=0;\\n        for(int i=0;i<conver.size();i++)\\n        {\\n            res+=conver[i];\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        vector<long long>conver;\\n        int ma=INT_MIN;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ma=max(ma,nums[i]);\\n            conver.push_back(nums[i]+ma);\\n        }\\n        vector<long long>ans;\\n        long long res=0;\\n        for(int i=0;i<conver.size();i++)\\n        {\\n            res+=conver[i];\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040810,
                "title": "prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int ax=1;\\n        long long p=0;\\n        vector<long long>ans;\\n        for(int i=0;i<size(nums);i++){\\n            ax=max(ax,nums[i]);\\n            p+=ax+nums[i];\\n            ans.push_back(p);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int ax=1;\\n        long long p=0;\\n        vector<long long>ans;\\n        for(int i=0;i<size(nums);i++){\\n            ax=max(ax,nums[i]);\\n            p+=ax+nums[i];\\n            ans.push_back(p);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038388,
                "title": "easy-o-n-java-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] prefix = new long[nums.length];\\n        long[] res = new long[nums.length];\\n        int prev = nums[0];\\n        res[0] = prev + nums[0];\\n        for (int i = 1; i < prefix.length; i++) {\\n            prev = Math.max(prev, nums[i]);\\n            long curr = prev + nums[i];\\n            res[i] = curr + res[i - 1];\\n        }\\n        return res;\\n    }\\n}\\n/**\\n2, 2 -> 4\\n\\n2 3 -> 4 6 -> 10\\n\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] prefix = new long[nums.length];\\n        long[] res = new long[nums.length];\\n        int prev = nums[0];\\n        res[0] = prev + nums[0];\\n        for (int i = 1; i < prefix.length; i++) {\\n            prev = Math.max(prev, nums[i]);\\n            long curr = prev + nums[i];\\n            res[i] = curr + res[i - 1];\\n        }\\n        return res;\\n    }\\n}\\n/**\\n2, 2 -> 4\\n\\n2 3 -> 4 6 -> 10\\n\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037276,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  List<int> findPrefixScore(List<int> nums) {\\n      final List<int> res = [0];\\n      var prevMax = 0;\\n      for (int i = 0; i < nums.length; i++) {\\n          prevMax = max(prevMax, nums[i]);\\n          final totalAtIndex = prevMax + nums[i];\\n          final total = totalAtIndex + res.last;\\n          res.add(total);\\n      }\\n\\n      return res.sublist(1);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  List<int> findPrefixScore(List<int> nums) {\\n      final List<int> res = [0];\\n      var prevMax = 0;\\n      for (int i = 0; i < nums.length; i++) {\\n          prevMax = max(prevMax, nums[i]);\\n          final totalAtIndex = prevMax + nums[i];\\n          final total = totalAtIndex + res.last;\\n          res.add(total);\\n      }\\n\\n      return res.sublist(1);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035243,
                "title": "step-by-step-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] ans = new long[nums.length];\\n\\n        //This maxArray will store the max value till ith position\\n        int [] maxArray = new int[nums.length];\\n        int[] conversion =  new int[nums.length];\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0 ; i<nums.length;i++){\\n            max = Math.max(max,nums[i]);\\n            maxArray[i] = max;\\n        }\\n        for(int i = 0 ; i<nums.length;i++){\\n            conversion[i] = nums[i] + maxArray[i];\\n            System.out.println(conversion[i]);\\n        }\\n        ans[0] = conversion[0];\\n        for(int i = 1; i<nums.length;i++){\\n            ans[i] = (long)(conversion[i] + ans[i-1]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] ans = new long[nums.length];\\n\\n        //This maxArray will store the max value till ith position\\n        int [] maxArray = new int[nums.length];\\n        int[] conversion =  new int[nums.length];\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0 ; i<nums.length;i++){\\n            max = Math.max(max,nums[i]);\\n            maxArray[i] = max;\\n        }\\n        for(int i = 0 ; i<nums.length;i++){\\n            conversion[i] = nums[i] + maxArray[i];\\n            System.out.println(conversion[i]);\\n        }\\n        ans[0] = conversion[0];\\n        for(int i = 1; i<nums.length;i++){\\n            ans[i] = (long)(conversion[i] + ans[i-1]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020332,
                "title": "easy-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] r = new long[nums.length];\\n        int max = nums[0];\\n        for (int i = 0; i < nums.length; i ++) {\\n            if (max < nums[i]) {\\n                max = nums[i];\\n            }\\n            int conv = nums[i] + max;\\n            if (i == 0) {\\n                r[i] = conv;\\n            }\\n            else {\\n                r[i] = conv + r[i - 1];\\n            }\\n        }\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] r = new long[nums.length];\\n        int max = nums[0];\\n        for (int i = 0; i < nums.length; i ++) {\\n            if (max < nums[i]) {\\n                max = nums[i];\\n            }\\n            int conv = nums[i] + max;\\n            if (i == 0) {\\n                r[i] = conv;\\n            }\\n            else {\\n                r[i] = conv + r[i - 1];\\n            }\\n        }\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017769,
                "title": "easiest-solution-in-single-traversal-95-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        long long sum=0;\\n        int maxi=0;\\n        for(auto i:nums){\\n            maxi=max(maxi,i);\\n            sum=sum+i+maxi;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        long long sum=0;\\n        int maxi=0;\\n        for(auto i:nums){\\n            maxi=max(maxi,i);\\n            sum=sum+i+maxi;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016660,
                "title": "short-code-easiest-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>&n){\\n        vector<long long>ans;\\n        long long mx=0 , sum=0;\\n        for(int i=0; i<n.size(); i++){\\n            if(n[i]>mx){\\n                mx=n[i];\\n            }\\n            sum+=n[i]+mx;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>&n){\\n        vector<long long>ans;\\n        long long mx=0 , sum=0;\\n        for(int i=0; i<n.size(); i++){\\n            if(n[i]>mx){\\n                mx=n[i];\\n            }\\n            sum+=n[i]+mx;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999361,
                "title": "java-straightforward",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int  maxd =  nums[0] ;\\n        long res[] = new long[nums.length];\\n        res[0] = maxd*2 ;\\n        for(int i = 1; i< nums.length ; i++){\\n            \\n            maxd = Math.max(nums[i] , maxd);\\n            res[i] = maxd + nums[i] + res[i-1]; \\n\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int  maxd =  nums[0] ;\\n        long res[] = new long[nums.length];\\n        res[0] = maxd*2 ;\\n        for(int i = 1; i< nums.length ; i++){\\n            \\n            maxd = Math.max(nums[i] , maxd);\\n            res[i] = maxd + nums[i] + res[i-1]; \\n\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996249,
                "title": "c-easy-and-understandable",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long >ans;\\n        vector<int>v;\\n        int mx=nums[0];\\n        v.push_back(mx+nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            mx=max(nums[i],mx);\\n            v.push_back(nums[i]+mx);\\n        }\\n        long long  k=0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            ans.push_back(1LL*(k+v[i]));\\n            k=ans[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long >ans;\\n        vector<int>v;\\n        int mx=nums[0];\\n        v.push_back(mx+nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            mx=max(nums[i],mx);\\n            v.push_back(nums[i]+mx);\\n        }\\n        long long  k=0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            ans.push_back(1LL*(k+v[i]));\\n            k=ans[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994065,
                "title": "very-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length;\\n        long[] arr = new long[n];\\n        long prefix =0,max=0;\\n\\n        for(int i=0;i<n;i++){\\n           max =  Math.max(max,nums[i]);\\n           arr[i] = nums[i] + max + prefix;\\n           prefix = arr[i];\\n     }\\n       return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length;\\n        long[] arr = new long[n];\\n        long prefix =0,max=0;\\n\\n        for(int i=0;i<n;i++){\\n           max =  Math.max(max,nums[i]);\\n           arr[i] = nums[i] + max + prefix;\\n           prefix = arr[i];\\n     }\\n       return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992531,
                "title": "how-can-this-question-be-of-medium-level-difficulty-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nvector<long long> findPrefixScore(vector<int>& nums) \\n{\\n        vector<long long> ans;\\n        long long curr=0;\\n        int mx=-100;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mx=max(mx,nums[i]); // max number till current index\\n            curr+= (mx+nums[i]); // addition of currnumber with max number till curr index and storing the sum\\n            ans.push_back(curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<long long> findPrefixScore(vector<int>& nums) \\n{\\n        vector<long long> ans;\\n        long long curr=0;\\n        int mx=-100;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mx=max(mx,nums[i]); // max number till current index\\n            curr+= (mx+nums[i]); // addition of currnumber with max number till curr index and storing the sum\\n            ans.push_back(curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989319,
                "title": "find-the-score-of-all-prefixes-of-an-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr = new long[nums.length];\\n        int max = nums[0];\\n        arr[0] = nums[0]+max;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            max = Math.max(max,nums[i]);\\n            arr[i] = nums[i]+arr[i-1]+max;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr = new long[nums.length];\\n        int max = nums[0];\\n        arr[0] = nums[0]+max;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            max = Math.max(max,nums[i]);\\n            arr[i] = nums[i]+arr[i-1]+max;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988324,
                "title": "python-simple-python-solution-prefix-sum-98-faster",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 409 ms, faster than 98.17% of Python3 online submissions for Find the Score of All Prefixes of an Array.\\n# Memory Usage: 38.9 MB, less than 81.41% of Python3 online submissions for Find the Score of All Prefixes of an Array.\\n![image](https://assets.leetcode.com/users/images/b2a7499e-0801-4f5b-943e-b4e4fa283cc2_1693569893.2199633.png)\\n\\n\\n\\tclass Solution:\\n\\t\\tdef findPrefixScore(self, nums: List[int]) -> List[int]:\\n\\n\\t\\t\\tresult = []\\n\\n\\t\\t\\tcurrent_max = nums[0]\\n\\n\\t\\t\\tresult.append(nums[0] * 2)\\n\\n\\t\\t\\tfor num in nums[1:]:\\n\\n\\t\\t\\t\\tcurrent_max = max(current_max , num)\\n\\n\\t\\t\\t\\tresult.append(result[-1] + num + current_max)\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n\\tTime Complexity : O(n)\\n\\tSpace Complexity : O(n)\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 409 ms, faster than 98.17% of Python3 online submissions for Find the Score of All Prefixes of an Array.\\n# Memory Usage: 38.9 MB, less than 81.41% of Python3 online submissions for Find the Score of All Prefixes of an Array.\\n![image](https://assets.leetcode.com/users/images/b2a7499e-0801-4f5b-943e-b4e4fa283cc2_1693569893.2199633.png)\\n\\n\\n\\tclass Solution:\\n\\t\\tdef findPrefixScore(self, nums: List[int]) -> List[int]:\\n\\n\\t\\t\\tresult = []\\n\\n\\t\\t\\tcurrent_max = nums[0]\\n\\n\\t\\t\\tresult.append(nums[0] * 2)\\n\\n\\t\\t\\tfor num in nums[1:]:\\n\\n\\t\\t\\t\\tcurrent_max = max(current_max , num)\\n\\n\\t\\t\\t\\tresult.append(result[-1] + num + current_max)\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n\\tTime Complexity : O(n)\\n\\tSpace Complexity : O(n)\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3986671,
                "title": "very-easy-approach-using-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n\\n        vector<long long> output;\\n\\n        long long sum = 0;\\n        long int temp;\\n        output.push_back(nums[0]*2);\\n        sum = nums[0]*2;\\n        long int maxele = nums[0];\\n        for(int i = 1;i<nums.size();i++){\\n\\n            // if(nums[i-1] > nums[i]){\\n            //     temp = nums[i-1]+nums[i];\\n            // }else{\\n            //     temp = nums[i]*2;\\n            // }\\n\\n            if(maxele <= nums[i]){\\n                maxele = nums[i];\\n            }\\n            temp=maxele + nums[i];\\n\\n            sum+=temp;\\n\\n            output.push_back(sum);\\n\\n            \\n        }\\n        return output;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n\\n        vector<long long> output;\\n\\n        long long sum = 0;\\n        long int temp;\\n        output.push_back(nums[0]*2);\\n        sum = nums[0]*2;\\n        long int maxele = nums[0];\\n        for(int i = 1;i<nums.size();i++){\\n\\n            // if(nums[i-1] > nums[i]){\\n            //     temp = nums[i-1]+nums[i];\\n            // }else{\\n            //     temp = nums[i]*2;\\n            // }\\n\\n            if(maxele <= nums[i]){\\n                maxele = nums[i];\\n            }\\n            temp=maxele + nums[i];\\n\\n            sum+=temp;\\n\\n            output.push_back(sum);\\n\\n            \\n        }\\n        return output;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980151,
                "title": "prefixsum-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPrefixSum Java Easy Solution\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPrefixSum Java Easy Solution\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] prefixSum = new long[nums.length];\\n\\n        prefixSum[0] = nums[0] + nums[0];\\n        int max = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i] > max)\\n                max = nums[i];\\n            prefixSum[i] = prefixSum[i-1] + nums[i] + max;\\n        }\\n\\n        return prefixSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] prefixSum = new long[nums.length];\\n\\n        prefixSum[0] = nums[0] + nums[0];\\n        int max = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i] > max)\\n                max = nums[i];\\n            prefixSum[i] = prefixSum[i-1] + nums[i] + max;\\n        }\\n\\n        return prefixSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975237,
                "title": "beats-98-23-o-n-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) -> since we need to return vector.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n       vector<long long> pre(nums.size());\\n       int maxi=nums[0];\\n       pre[0]=maxi+nums[0];\\n       for(int i=1; i<nums.size(); i++) {\\n           maxi=max(maxi, nums[i]);\\n           pre[i]=nums[i]+pre[i-1]+maxi;\\n       }\\n       return pre;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n       vector<long long> pre(nums.size());\\n       int maxi=nums[0];\\n       pre[0]=maxi+nums[0];\\n       for(int i=1; i<nums.size(); i++) {\\n           maxi=max(maxi, nums[i]);\\n           pre[i]=nums[i]+pre[i-1]+maxi;\\n       }\\n       return pre;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966494,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long> ans(n,0);\\n        int maxi=0;\\n        long long sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            maxi=max(maxi,nums[i]);\\n            long long val=maxi+nums[i];\\n            sum=sum+val;;\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long> ans(n,0);\\n        int maxi=0;\\n        long long sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            maxi=max(maxi,nums[i]);\\n            long long val=maxi+nums[i];\\n            sum=sum+val;;\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963370,
                "title": "swift-0-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func findPrefixScore(_ nums: [Int]) -> [Int] {\\n    var maxVal = 0\\n    var result = [Int]()\\n    \\n    for num in nums {\\n        maxVal = max(maxVal, num)\\n        result.append(num + maxVal)\\n    }\\n    var arr = [Int]()\\n    var cur = 0\\n    for i in result {\\n        cur += i\\n        arr.append(cur)\\n    }\\n    return arr\\n}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findPrefixScore(_ nums: [Int]) -> [Int] {\\n    var maxVal = 0\\n    var result = [Int]()\\n    \\n    for num in nums {\\n        maxVal = max(maxVal, num)\\n        result.append(num + maxVal)\\n    }\\n    var arr = [Int]()\\n    var cur = 0\\n    for i in result {\\n        cur += i\\n        arr.append(cur)\\n    }\\n    return arr\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962597,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        long ans[]=new long[n];\\n        int min=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(min<=nums[i])\\n            {\\n                min=nums[i];\\n            }\\n            ans[i]+=min+nums[i];\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        long ans[]=new long[n];\\n        int min=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(min<=nums[i])\\n            {\\n                min=nums[i];\\n            }\\n            ans[i]+=min+nums[i];\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957803,
                "title": "easy-and-well-explained",
                "content": "\\n\\n# Approach\\nmaintain a maxi variable to store the maximum till the current element.\\nInitialise a pre variable to store the score of previous elements.\\nUpdate the pre variable every time .\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int maxi=-1;\\n        long long pre=0;\\n        long long curr;\\n        vector<long long>ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            maxi=max(maxi,nums[i]);\\n\\n             curr=maxi+nums[i];\\n\\n            ans.push_back(curr+pre);\\n            pre=curr+pre;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int maxi=-1;\\n        long long pre=0;\\n        long long curr;\\n        vector<long long>ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            maxi=max(maxi,nums[i]);\\n\\n             curr=maxi+nums[i];\\n\\n            ans.push_back(curr+pre);\\n            pre=curr+pre;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951346,
                "title": "c-prefix-sum-simple-code",
                "content": "\\n\\n# Code\\n```\\n// #define int long long\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& v) {\\n        long long max = v[0];\\n        vector<long long> ans;\\n        ans.push_back(v[0]*2);\\n        for(int i = 1; i<v.size(); i++){\\n            if(v[i]>max) max=v[i];\\n            long long x = v[i] + max;\\n            ans.push_back(ans[i-1]+x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// #define int long long\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& v) {\\n        long long max = v[0];\\n        vector<long long> ans;\\n        ans.push_back(v[0]*2);\\n        for(int i = 1; i<v.size(); i++){\\n            if(v[i]>max) max=v[i];\\n            long long x = v[i] + max;\\n            ans.push_back(ans[i-1]+x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944076,
                "title": "elegant-solution-java-beats-70",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        \\n        int max= Integer.MIN_VALUE;\\n        long [] conArr = new long[nums.length];\\n        long [] conArrAns = new long[nums.length];\\n\\n        for(int i=0;i<nums.length;i++)\\n        {   \\n            int j=0;\\n            if(nums[i]>max)\\n            max=nums[i];\\n            conArr[i] = nums[i]+max;     \\n        }\\n        long sum=0;\\n        for(int i=0;i<conArr.length;i++)\\n        {\\n            sum =sum +conArr[i];\\n            conArrAns[i]=sum;\\n        }\\n        return conArrAns;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        \\n        int max= Integer.MIN_VALUE;\\n        long [] conArr = new long[nums.length];\\n        long [] conArrAns = new long[nums.length];\\n\\n        for(int i=0;i<nums.length;i++)\\n        {   \\n            int j=0;\\n            if(nums[i]>max)\\n            max=nums[i];\\n            conArr[i] = nums[i]+max;     \\n        }\\n        long sum=0;\\n        for(int i=0;i<conArr.length;i++)\\n        {\\n            sum =sum +conArr[i];\\n            conArrAns[i]=sum;\\n        }\\n        return conArrAns;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943782,
                "title": "soooooooooooooo-much-easyyyyyyyyyyyyy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        ans=[]\\n        maxi=nums[0]\\n        count=0\\n        for i in nums:\\n            if i>=maxi:\\n                count = count +(i+i)\\n                maxi=i\\n            else:\\n                count=count+(i+maxi)\\n            ans.append(count)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        ans=[]\\n        maxi=nums[0]\\n        count=0\\n        for i in nums:\\n            if i>=maxi:\\n                count = count +(i+i)\\n                maxi=i\\n            else:\\n                count=count+(i+maxi)\\n            ans.append(count)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931863,
                "title": "elixir-solution-use-enum-reduce",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 285ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 85MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndefmodule Solution do\\n  @spec find_prefix_score(nums :: [integer]) :: [integer]\\n  def find_prefix_score(nums) do\\n    Enum.reduce(nums, {0, [0]}, fn num, {t_max, ans} ->\\n      t_max = max(t_max, num)\\n      {t_max, [num + t_max + (ans |> hd) | ans]}\\n    end) |> elem(1) |> Enum.reverse() |> tl\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec find_prefix_score(nums :: [integer]) :: [integer]\\n  def find_prefix_score(nums) do\\n    Enum.reduce(nums, {0, [0]}, fn num, {t_max, ans} ->\\n      t_max = max(t_max, num)\\n      {t_max, [num + t_max + (ans |> hd) | ans]}\\n    end) |> elem(1) |> Enum.reverse() |> tl\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3926316,
                "title": "python-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        maxx=nums[0]\\n        nums[0]=nums[0]*2\\n        \\n        sum=nums[0]\\n        for i in range(1,len(nums)):\\n            if nums[i]>maxx:\\n                maxx=nums[i]\\n            nums[i]+=maxx\\n            sum+=nums[i]\\n            nums[i]=sum\\n            \\n        return nums\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        maxx=nums[0]\\n        nums[0]=nums[0]*2\\n        \\n        sum=nums[0]\\n        for i in range(1,len(nums)):\\n            if nums[i]>maxx:\\n                maxx=nums[i]\\n            nums[i]+=maxx\\n            sum+=nums[i]\\n            nums[i]=sum\\n            \\n        return nums\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926266,
                "title": "c-code-beats-100-time-complexity",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public long[] FindPrefixScore(int[] nums) {\\n        int max = 0;\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (max < nums[i])\\n                {\\n                    max = nums[i];\\n                }\\n\\n                nums[i] += max;\\n            }\\n\\n            long[] answer = new long[nums.Length];\\n            answer[0] = nums[0];\\n\\n            for (int i = 1; i < nums.Length; i++)\\n            {\\n                answer[i] = answer[i - 1] + nums[i];\\n            }\\n            return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long[] FindPrefixScore(int[] nums) {\\n        int max = 0;\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (max < nums[i])\\n                {\\n                    max = nums[i];\\n                }\\n\\n                nums[i] += max;\\n            }\\n\\n            long[] answer = new long[nums.Length];\\n            answer[0] = nums[0];\\n\\n            for (int i = 1; i < nums.Length; i++)\\n            {\\n                answer[i] = answer[i - 1] + nums[i];\\n            }\\n            return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913564,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        res=[]\\n        maxx=-1\\n        cnt=0\\n        for i in range(len(nums)):\\n            if maxx<nums[i]:\\n                maxx=nums[i]\\n            cnt+=nums[i]+maxx\\n            res.append(cnt)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        res=[]\\n        maxx=-1\\n        cnt=0\\n        for i in range(len(nums)):\\n            if maxx<nums[i]:\\n                maxx=nums[i]\\n            cnt+=nums[i]+maxx\\n            res.append(cnt)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910941,
                "title": "python-solution-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findPrefixScore(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        a = []\\n        sum = 0\\n        max = nums[0]\\n        for i in range(0,len(nums)):\\n            if nums[i]>max:\\n                max = nums[i]\\n            sum = sum + max + nums[i]\\n            a.append(sum)\\n        return a\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findPrefixScore(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        a = []\\n        sum = 0\\n        max = nums[0]\\n        for i in range(0,len(nums)):\\n            if nums[i]>max:\\n                max = nums[i]\\n            sum = sum + max + nums[i]\\n            a.append(sum)\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904134,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] result=new long[nums.length];\\n        int max=nums[0];\\n        for(int j=0;j<nums.length;j++)\\n        {\\n            max=Math.max(max,nums[j]);\\n            nums[j]=max+nums[j];\\n        }\\n\\n        long sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum+=nums[i];\\n            result[i]=sum;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] result=new long[nums.length];\\n        int max=nums[0];\\n        for(int j=0;j<nums.length;j++)\\n        {\\n            max=Math.max(max,nums[j]);\\n            nums[j]=max+nums[j];\\n        }\\n\\n        long sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum+=nums[i];\\n            result[i]=sum;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903415,
                "title": "straight-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n\\n        current_max = nums[0]\\n        conver = [0]*len(nums)\\n        conver[0] = 2*current_max\\n\\n        for i in range(1, len(nums)):\\n            current_max = max(current_max, nums[i])\\n            conver[i] = conver[i-1] + nums[i] + current_max\\n        return conver\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n\\n        current_max = nums[0]\\n        conver = [0]*len(nums)\\n        conver[0] = 2*current_max\\n\\n        for i in range(1, len(nums)):\\n            current_max = max(current_max, nums[i])\\n            conver[i] = conver[i-1] + nums[i] + current_max\\n        return conver\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902615,
                "title": "java-straight-forward-easy-to-understand-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        \\n        int n = nums.length;\\n        long[] scores = new long[n];\\n\\n        long score = 0;\\n\\n        long maxVal = nums[0];\\n\\n        int index = 0;\\n\\n        for(int val : nums){\\n            maxVal = Math.max(maxVal, val);\\n            score += val + maxVal;\\n            scores[index++] = score;\\n        }\\n        return scores;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        \\n        int n = nums.length;\\n        long[] scores = new long[n];\\n\\n        long score = 0;\\n\\n        long maxVal = nums[0];\\n\\n        int index = 0;\\n\\n        for(int val : nums){\\n            maxVal = Math.max(maxVal, val);\\n            score += val + maxVal;\\n            scores[index++] = score;\\n        }\\n        return scores;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901008,
                "title": "java-easy-prefix-sum-100-beats",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long conver[]=new long[nums.length];\\n        long arr[]=new long[nums.length];\\n        int max=-1;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n           max=Math.max(max,nums[i]);\\n           conver[i]=nums[i]+max;\\n        }\\n\\n        arr[0]=conver[0];\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            arr[i]=arr[i-1]+conver[i];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long conver[]=new long[nums.length];\\n        long arr[]=new long[nums.length];\\n        int max=-1;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n           max=Math.max(max,nums[i]);\\n           conver[i]=nums[i]+max;\\n        }\\n\\n        arr[0]=conver[0];\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            arr[i]=arr[i-1]+conver[i];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892092,
                "title": "java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n##### Use for loop to go through the nums array.\\n##### Keep a variable max to keep track of the maximum element till i\\n##### Add max to the current nums[i] now you got the conversion array value\\n##### After finding the value we have to add to final_temp which gives score at index i of our solution array.\\n\\n# Complexity\\n## - Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n##### O(n) where n is length of nums array.\\n\\n## - Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n##### O(n) as we are storing the result in an array res of length n.\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        long res[]=new long[n];\\n        long max=0;\\n        long final_temp=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(max<nums[i])\\n                max=nums[i];\\n            long temp=nums[i]+max;\\n            final_temp+=temp;\\n            res[i]=final_temp;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        long res[]=new long[n];\\n        long max=0;\\n        long final_temp=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(max<nums[i])\\n                max=nums[i];\\n            long temp=nums[i]+max;\\n            final_temp+=temp;\\n            res[i]=final_temp;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887877,
                "title": "golang-o-n-o-n-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc findPrefixScore(nums []int) []int64 {\\n\\tprevMax := nums[0]\\n\\tans := make([]int64, len(nums))\\n\\tans[0]=int64(nums[0]*2)\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tprevMax = max(nums[i], prevMax)\\n\\t\\tans[i] = int64(nums[i] + prevMax)+ans[i-1]\\n\\t}\\n\\treturn ans\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findPrefixScore(nums []int) []int64 {\\n\\tprevMax := nums[0]\\n\\tans := make([]int64, len(nums))\\n\\tans[0]=int64(nums[0]*2)\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tprevMax = max(nums[i], prevMax)\\n\\t\\tans[i] = int64(nums[i] + prevMax)+ans[i-1]\\n\\t}\\n\\treturn ans\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3878745,
                "title": "efficient-solution-beat-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        lenNum=len(nums)\\n        ans=[]\\n        sum=0\\n        maxnum=-9999\\n        for i in range(lenNum):\\n            if maxnum < nums[i]:\\n                maxnum=nums[i]\\n            sum +=maxnum+nums[i]\\n            ans.append(sum)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        lenNum=len(nums)\\n        ans=[]\\n        sum=0\\n        maxnum=-9999\\n        for i in range(lenNum):\\n            if maxnum < nums[i]:\\n                maxnum=nums[i]\\n            sum +=maxnum+nums[i]\\n            ans.append(sum)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874890,
                "title": "c-time-o-n-space-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Keep track of max and previous score when iterating\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public long[] FindPrefixScore(int[] nums) {\\n        int maxValue = 0;\\n        long prevScore = 0;\\n        long[] ret = new long[nums.Length];\\n\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if (nums[i] > maxValue)\\n                maxValue = nums[i];\\n\\n            ret[i] = prevScore + nums[i] + maxValue;\\n\\n            prevScore = ret[i];\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long[] FindPrefixScore(int[] nums) {\\n        int maxValue = 0;\\n        long prevScore = 0;\\n        long[] ret = new long[nums.Length];\\n\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if (nums[i] > maxValue)\\n                maxValue = nums[i];\\n\\n            ret[i] = prevScore + nums[i] + maxValue;\\n\\n            prevScore = ret[i];\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862678,
                "title": "c-o-n-time-space-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst find prefix max of all elements in array\\nThen find arr[i]+prefixMax[i] its conversion array\\nNow find prefix sum of conversion array\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>maxPrefix(nums.size());\\n        //Step:1 finding prefix max of array\\n        maxPrefix[0]=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            maxPrefix[i]=max((long long)nums[i],maxPrefix[i-1]);\\n        }\\n        //ZStep-2 converting maxPrefix array to conversion array\\n        for(int i=0;i<nums.size();i++){\\n            maxPrefix[i]=maxPrefix[i]+nums[i];\\n        }\\n        //Step:3 now calculating prefix sum of conversion array\\n        for(int i=1;i<nums.size();i++){\\n            maxPrefix[i]=maxPrefix[i]+maxPrefix[i-1];\\n        }\\n        return maxPrefix;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>maxPrefix(nums.size());\\n        //Step:1 finding prefix max of array\\n        maxPrefix[0]=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            maxPrefix[i]=max((long long)nums[i],maxPrefix[i-1]);\\n        }\\n        //ZStep-2 converting maxPrefix array to conversion array\\n        for(int i=0;i<nums.size();i++){\\n            maxPrefix[i]=maxPrefix[i]+nums[i];\\n        }\\n        //Step:3 now calculating prefix sum of conversion array\\n        for(int i=1;i<nums.size();i++){\\n            maxPrefix[i]=maxPrefix[i]+maxPrefix[i-1];\\n        }\\n        return maxPrefix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859012,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nimplementation\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>ans;\\n        long long temp=0;\\n        int mx=0;\\n        for(auto i:nums){\\n            mx=max(mx,i);\\n            ans.push_back(temp+mx+i);\\n            temp+=mx+i;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>ans;\\n        long long temp=0;\\n        int mx=0;\\n        for(auto i:nums){\\n            mx=max(mx,i);\\n            ans.push_back(temp+mx+i);\\n            temp+=mx+i;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852180,
                "title": "c-shortest-o-n-space-time",
                "content": "# Approach\\n\\nSince vector elements are always default-initialized but we wouldn\\'t care about its default values here, let\\'s put it at least to some use and pass as \"default value\" the one that should be in the first element, i.e. `largest \\xD7 2`. This would allow us to 1) skip first cycle 2) get rid of `i` boundary check in the cycle.\\n\\nOther than that, the code is straigtforward: we go through `nums` vector and compute each element according to the task description.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```C++\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(const vector<int>& nums) {\\n        int largest = nums[0];\\n        vector<long long> answer(nums.size(), largest * 2);\\n        for (size_t i = 1; i < nums.size(); ++i) {\\n            largest = max(largest, nums[i]);\\n            answer[i] = largest + nums[i] +  answer[i-1];\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(const vector<int>& nums) {\\n        int largest = nums[0];\\n        vector<long long> answer(nums.size(), largest * 2);\\n        for (size_t i = 1; i < nums.size(); ++i) {\\n            largest = max(largest, nums[i]);\\n            answer[i] = largest + nums[i] +  answer[i-1];\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841137,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        long long maxi=nums[0];\\n        vector<long long>ans(n);\\n        ans[0]=maxi+nums[0];\\n        for (int i=1;i<n;i++)\\n        {\\n           if (nums[i]>maxi) maxi=nums[i];\\n            ans[i]=1LL*nums[i]+maxi+ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        long long maxi=nums[0];\\n        vector<long long>ans(n);\\n        ans[0]=maxi+nums[0];\\n        for (int i=1;i<n;i++)\\n        {\\n           if (nums[i]>maxi) maxi=nums[i];\\n            ans[i]=1LL*nums[i]+maxi+ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838349,
                "title": "javascript-you-got-it-mate",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findPrefixScore = function(nums) {\\n    let conv = []\\n    let max = 0\\n    let sum = 0\\n    for(let i=0;i<nums.length;i++){\\n        max = Math.max(max,nums[i])\\n        conv[i] = max + nums[i]\\n        sum += conv[i]\\n        nums[i] = sum\\n    }\\n\\n    return nums\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findPrefixScore = function(nums) {\\n    let conv = []\\n    let max = 0\\n    let sum = 0\\n    for(let i=0;i<nums.length;i++){\\n        max = Math.max(max,nums[i])\\n        conv[i] = max + nums[i]\\n        sum += conv[i]\\n        nums[i] = sum\\n    }\\n\\n    return nums\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3834572,
                "title": "linear-python",
                "content": "# Intuition\\nSince the formula for converting each element only relies on the maximum among prior elements, and the formula for score only relies on summing prior sub-arrays, we can probably do this in linear time with a single pass while keeping track of maximum and score.\\n\\n# Approach\\nLoop through the array calculating conversion value and score along the way.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ ; we only traverse the array once\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ ; we allocate one extra array to hold the answer which is the same length as the input\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        m = -1\\n        score = 0\\n        scores = [None] * len(nums)\\n        for idx, i in enumerate(nums):\\n            if i > m:\\n                m = i\\n            score += (i + m)\\n            scores[idx] = score\\n        return scores\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        m = -1\\n        score = 0\\n        scores = [None] * len(nums)\\n        for idx, i in enumerate(nums):\\n            if i > m:\\n                m = i\\n            score += (i + m)\\n            scores[idx] = score\\n        return scores\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832694,
                "title": "c-beats-100-users-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> ans(n, 0);\\n        int maxi = nums[0];\\n        for(int i=0;i<n;i++){\\n            maxi = max(maxi, nums[i]);\\n            ans[i] = nums[i]+maxi;\\n        }\\n        vector<long long> res(n, 0);\\n        long long sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=ans[i];\\n            res[i] = sum;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> ans(n, 0);\\n        int maxi = nums[0];\\n        for(int i=0;i<n;i++){\\n            maxi = max(maxi, nums[i]);\\n            ans[i] = nums[i]+maxi;\\n        }\\n        vector<long long> res(n, 0);\\n        long long sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=ans[i];\\n            res[i] = sum;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823424,
                "title": "javascript-100-runtime",
                "content": "```javascript\\nconst findPrefixScore = (nums) => {\\n  let prefix = 0;\\n  let max = 0;\\n  return nums.map((num) => {\\n    max = Math.max(max, num);\\n    prefix += num + max;\\n    return prefix;\\n  });\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst findPrefixScore = (nums) => {\\n  let prefix = 0;\\n  let max = 0;\\n  return nums.map((num) => {\\n    max = Math.max(max, num);\\n    prefix += num + max;\\n    return prefix;\\n  });\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3803091,
                "title": "python3-3-lines-o-n-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse the accumulate() and map() functions to create intermediary lists efficiently.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        a = list(itertools.accumulate(nums, max))\\n        a = list(map(add, nums, a))\\n        return list(itertools.accumulate(a))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        a = list(itertools.accumulate(nums, max))\\n        a = list(map(add, nums, a))\\n        return list(itertools.accumulate(a))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799998,
                "title": "python3-one-pass-beats-99-52",
                "content": "\\tclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        mx=nums[0]\\n        cumsum=0\\n        ls=[]\\n        for i in nums:\\n            if i>mx:\\n                mx=i\\n            conver=i+mx\\n            cumsum+=conver\\n            ls.append(cumsum)\\n        \\n        return ls\\n![image](https://assets.leetcode.com/users/images/158e8585-19fb-4f54-bd3c-6af9944dc537_1690014678.3895664.png)\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        mx=nums[0]\\n        cumsum=0\\n        ls=[]\\n        for i in nums:\\n            if i>mx:\\n                mx=i\\n            conver=i+mx\\n            cumsum+=conver\\n            ls.append(cumsum)\\n        \\n        return ls\\n![image](https://assets.leetcode.com/users/images/158e8585-19fb-4f54-bd3c-6af9944dc537_1690014678.3895664.png)\\n",
                "codeTag": "Java"
            },
            {
                "id": 3779535,
                "title": "simple-solution-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- cv is vector storing the max element upto i th element\\n- mx is vector storing the sum , the convert array \\n ( mx[i] = nums[i] + max(nums[0....i]) ) upto i th element\\n- the loop iterates over nums and with each itertion cv stores the max element upto i\\n- mx stores the sum of num arrays with max element making the conversion array making the resultant array\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![leet.jpeg](https://assets.leetcode.com/users/images/efc6a9a0-bdef-4071-80c9-79274758646e_1689612916.0885437.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<int> cv(nums.size(),0);  //stores max element\\n        vector<long long> mx(nums.size(),0);    //stores sum upto i th element making the convert array\\n        cv[0]=nums[0];\\n        mx[0]=nums[0]+cv[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            cv[i]=max(nums[i],cv[i-1]);\\n            mx[i]=nums[i]+cv[i]+mx[i-1];\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<int> cv(nums.size(),0);  //stores max element\\n        vector<long long> mx(nums.size(),0);    //stores sum upto i th element making the convert array\\n        cv[0]=nums[0];\\n        mx[0]=nums[0]+cv[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            cv[i]=max(nums[i],cv[i-1]);\\n            mx[i]=nums[i]+cv[i]+mx[i-1];\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760113,
                "title": "o-n-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple Observation. `ans` store cummulative sum of elements of `conver` of whole `nums`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRather than calculating `conver` for whole `nums`, As we want to store cummulative sum as we iterate through `conver` in `ans`.\\n`conver[i] = nums[i] + maxi`, so rather than storing `conver`,\\ntake a variable `sum` we stores cummulative sum of elements of `conver` on each iteration, and store the value in the corresponding `ans[i]`.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> ans(n);\\n        int maxi = -1e9;\\n        long long sum = 0;\\n        for(int i=0;i<n;i++){\\n            maxi = max(maxi, nums[i]);\\n            sum += nums[i] + maxi;\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> ans(n);\\n        int maxi = -1e9;\\n        long long sum = 0;\\n        for(int i=0;i<n;i++){\\n            maxi = max(maxi, nums[i]);\\n            sum += nums[i] + maxi;\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743854,
                "title": "c-easy-to-understand-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        vector<int> store;\\n        int a=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>a)\\n                a=nums[i];\\n            int push=a+nums[i];\\n            store.push_back(push);\\n        }\\n        long long sum=0;\\n        for(int i=0;i<store.size();i++){\\n            sum+=(long long)store[i];\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        vector<int> store;\\n        int a=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>a)\\n                a=nums[i];\\n            int push=a+nums[i];\\n            store.push_back(push);\\n        }\\n        long long sum=0;\\n        for(int i=0;i<store.size();i++){\\n            sum+=(long long)store[i];\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741585,
                "title": "typescript-solution-beats-speed-100-memory-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nfunction findPrefixScore(nums: number[]): number[] {\\n    \\n    const n: number = nums.length;\\n    let result: number[] = [...Array(n+1)].fill(0);\\n    let maxResult: number = 0;\\n    for(let i=0; i<nums.length; i++) {\\n       maxResult = Math.max(nums[i], maxResult);\\n       result[i+1] = result[i] + maxResult + nums[i];\\n    }\\n    result = result.slice(1);\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction findPrefixScore(nums: number[]): number[] {\\n    \\n    const n: number = nums.length;\\n    let result: number[] = [...Array(n+1)].fill(0);\\n    let maxResult: number = 0;\\n    for(let i=0; i<nums.length; i++) {\\n       maxResult = Math.max(nums[i], maxResult);\\n       result[i+1] = result[i] + maxResult + nums[i];\\n    }\\n    result = result.slice(1);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3717471,
                "title": "optimal-solution-o-n-time",
                "content": "# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        currMax = 0\\n        ans = []\\n\\n        for n in nums:\\n            currMax = max(currMax, n)\\n            if not ans:\\n                ans.append(currMax + n)\\n            else:\\n                ans.append(currMax + n + ans[-1])\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        currMax = 0\\n        ans = []\\n\\n        for n in nums:\\n            currMax = max(currMax, n)\\n            if not ans:\\n                ans.append(currMax + n)\\n            else:\\n                ans.append(currMax + n + ans[-1])\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708003,
                "title": "easily-understandable-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long> v(n);\\n        long long sum=0;\\n        v[0]=2*nums[0];\\n        int m=nums[0];\\n        sum+=v[0];\\n        for(int i=1;i<n;i++){\\n            m=max(m,nums[i]);\\n            long long p=nums[i]+m;\\n            sum+=p;\\n            v[i]=sum;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long> v(n);\\n        long long sum=0;\\n        v[0]=2*nums[0];\\n        int m=nums[0];\\n        sum+=v[0];\\n        for(int i=1;i<n;i++){\\n            m=max(m,nums[i]);\\n            long long p=nums[i]+m;\\n            sum+=p;\\n            v[i]=sum;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701913,
                "title": "python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPrefix sum\\n\\n# Approach\\nCreate an empty array ( or an array having an filler value). Create a  ```max_till_now``` variable to store the max value of the the array at that instant while traversing the loop. Add the value of max_till-now to the the iterator and append the value to the ```ans``` array.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        ans = [0]\\n        max_till_now = nums[0]\\n\\n        # ans = []\\n        for num in nums:\\n            max_till_now = max(max_till_now, num)\\n            n = num + max_till_now\\n            ans.append(ans[-1] + n )\\n\\n            # print(ans)  \\n        return ans[1:]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```max_till_now```\n```ans```\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        ans = [0]\\n        max_till_now = nums[0]\\n\\n        # ans = []\\n        for num in nums:\\n            max_till_now = max(max_till_now, num)\\n            n = num + max_till_now\\n            ans.append(ans[-1] + n )\\n\\n            # print(ans)  \\n        return ans[1:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698236,
                "title": "python-prefix-sum",
                "content": "```\\nclass Solution:\\n    def findPrefixScore(self, nums):\\n        maxPrefix = [nums[0]]\\n        for i in range(1, len(nums)):\\n            maxPrefix.append(max(maxPrefix[-1], nums[i]))\\n        ans = [maxPrefix[0] + nums[0]]\\n        for i in range(1, len(maxPrefix)):\\n            ans.append(ans[-1] + maxPrefix[i] + nums[i])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums):\\n        maxPrefix = [nums[0]]\\n        for i in range(1, len(nums)):\\n            maxPrefix.append(max(maxPrefix[-1], nums[i]))\\n        ans = [maxPrefix[0] + nums[0]]\\n        for i in range(1, len(maxPrefix)):\\n            ans.append(ans[-1] + maxPrefix[i] + nums[i])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697048,
                "title": "prefix-sum-one-pass-simple-java-solution-o-n-time-complexity-and-o-n-space-complexity",
                "content": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n    long ans[]=new long[nums.length];\\n    long max=Long.MIN_VALUE;\\n    for(int i=0;i<nums.length;i++)\\n    {\\n        max=Math.max(max,nums[i]);\\n        ans[i]=nums[i]+max;\\n        if(i!=0)\\n            ans[i]+=ans[i-1];\\n    }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n    long ans[]=new long[nums.length];\\n    long max=Long.MIN_VALUE;\\n    for(int i=0;i<nums.length;i++)\\n    {\\n        max=Math.max(max,nums[i]);\\n        ans[i]=nums[i]+max;\\n        if(i!=0)\\n            ans[i]+=ans[i-1];\\n    }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696796,
                "title": "c-clean-code-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<int> v=nums;\\n        vector<long long int> a;\\n        int m=v[0];\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m=max(m,v[i]);\\n            v[i]=m;\\n        }\\n        for(int i=0;i<v.size();i++)\\n        a.push_back(v[i]+nums[i]);\\n        long long int c=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            c+=a[i];\\n            a[i]=c;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<int> v=nums;\\n        vector<long long int> a;\\n        int m=v[0];\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m=max(m,v[i]);\\n            v[i]=m;\\n        }\\n        for(int i=0;i<v.size();i++)\\n        a.push_back(v[i]+nums[i]);\\n        long long int c=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            c+=a[i];\\n            a[i]=c;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688982,
                "title": "easy-c-solution-beginner-friendly-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        long long int res=0, mx = 0;\\n        vector<long long int> ans;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            mx = max(mx, (long long)nums[i]);\\n            res += mx + (long long)nums[i];\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        long long int res=0, mx = 0;\\n        vector<long long int> ans;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            mx = max(mx, (long long)nums[i]);\\n            res += mx + (long long)nums[i];\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688538,
                "title": "explaination-in-hindi-and-easy-to-understand-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n        // is problem me hamko current element aur 0 to i range tk k maximum value find krna hai.\\n// aur current element aur largest value(0-i range) k sum find krna hai \\n// aur us sum ko ek  new array me dalna hai.\\n// uske bad prefix sum find krna hai \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```\\n\\n\\n\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n       // long data type use karege kyoki return type long diya hua hai \\n        int n  = nums.length;\\n        long prefix1[] = new long[n];\\n        long prefix2[] = new long[n];\\n        int largest = Integer.MIN_VALUE;\\n        for(int i =0; i<n ;i++)\\n        {\\n    // largest number find kr rhe hai yha pr 0 to i range tk \\n            if(nums[i]>largest)\\n            {\\n                largest = nums[i];\\n            }\\n // new prefix Array me ham current element aur largest element k sum dalege \\n            prefix1[i] = nums[i]+largest;\\n        }\\n        long  m = prefix1.length;\\n   // simple yha pr jaise PREFIX SUM find krte hai wo find krna hai \\n        prefix2[0] = prefix1[0];\\n        for(int i=1;i<m;i++)\\n        {\\n            prefix2[i] = prefix2[i-1]+prefix1[i];\\n        }\\n // last me ham prefix2 array ko  return kr dege\\n        return prefix2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\n\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n       // long data type use karege kyoki return type long diya hua hai \\n        int n  = nums.length;\\n        long prefix1[] = new long[n];\\n        long prefix2[] = new long[n];\\n        int largest = Integer.MIN_VALUE;\\n        for(int i =0; i<n ;i++)\\n        {\\n    // largest number find kr rhe hai yha pr 0 to i range tk \\n            if(nums[i]>largest)\\n            {\\n                largest = nums[i];\\n            }\\n // new prefix Array me ham current element aur largest element k sum dalege \\n            prefix1[i] = nums[i]+largest;\\n        }\\n        long  m = prefix1.length;\\n   // simple yha pr jaise PREFIX SUM find krte hai wo find krna hai \\n        prefix2[0] = prefix1[0];\\n        for(int i=1;i<m;i++)\\n        {\\n            prefix2[i] = prefix2[i-1]+prefix1[i];\\n        }\\n // last me ham prefix2 array ko  return kr dege\\n        return prefix2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683940,
                "title": "using-stack-and-logic-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStore max value in a variable rather than to find max value for each iteration\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntraverse nums and find converse use stack to find score\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n\\n        stack=[0]\\n\\n        m=nums[0]\\n\\n        for i in range(0,len(nums)):\\n            if nums[i]>m:\\n                m=nums[i]\\n                g=nums[i]+m+stack[-1]\\n                stack.append(g)\\n            else:\\n                g=nums[i]+m+stack[-1]\\n                stack.append(g)\\n        \\n        stack.remove(stack[0])\\n        return stack\\n        \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n\\n        stack=[0]\\n\\n        m=nums[0]\\n\\n        for i in range(0,len(nums)):\\n            if nums[i]>m:\\n                m=nums[i]\\n                g=nums[i]+m+stack[-1]\\n                stack.append(g)\\n            else:\\n                g=nums[i]+m+stack[-1]\\n                stack.append(g)\\n        \\n        stack.remove(stack[0])\\n        return stack\\n        \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671148,
                "title": "python3-solution-with-using-prefix-sum",
                "content": "# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        conver = [0] * len(nums)\\n\\n        cur_max = 0\\n        for idx in range(len(nums)):\\n            cur_max = max(cur_max, nums[idx])\\n            conver[idx] = cur_max + nums[idx]\\n\\n        for idx in range(1, len(conver)):\\n            conver[idx] += conver[idx - 1]\\n        \\n        return conver\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        conver = [0] * len(nums)\\n\\n        cur_max = 0\\n        for idx in range(len(nums)):\\n            cur_max = max(cur_max, nums[idx])\\n            conver[idx] = cur_max + nums[idx]\\n\\n        for idx in range(1, len(conver)):\\n            conver[idx] += conver[idx - 1]\\n        \\n        return conver\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669194,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        ans=[]\\n        mx=0\\n        for num in nums:\\n            mx=max(num,mx)\\n            if len(ans)>0:\\n                ans.append(mx+num+ans[-1])\\n            else:\\n                ans.append(mx+num)\\n\\n        return ans\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        ans=[]\\n        mx=0\\n        for num in nums:\\n            mx=max(num,mx)\\n            if len(ans)>0:\\n                ans.append(mx+num+ans[-1])\\n            else:\\n                ans.append(mx+num)\\n\\n        return ans\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667211,
                "title": "one-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        m = -1\\n        for i in range(len(nums)):\\n            m=max(m,nums[i])\\n            nums[i] += m\\n            if i >0:\\n                nums[i]+=nums[i-1]\\n        return nums\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        m = -1\\n        for i in range(len(nums)):\\n            m=max(m,nums[i])\\n            nums[i] += m\\n            if i >0:\\n                nums[i]+=nums[i-1]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665090,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int m = 0;\\n        int[] max = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            max[i] = Math.max(m, nums[i]);\\n            m = max[i];\\n        }\\n\\n        long n = 0;\\n        long[] result = new long[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            result[i] = nums[i] + max[i] + n;\\n            n = result[i];\\n        }\\n        return result;   \\n    }\\n}\\n```\\nIf you made it this far please upvote.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int m = 0;\\n        int[] max = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            max[i] = Math.max(m, nums[i]);\\n            m = max[i];\\n        }\\n\\n        long n = 0;\\n        long[] result = new long[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            result[i] = nums[i] + max[i] + n;\\n            n = result[i];\\n        }\\n        return result;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664357,
                "title": "easy-java-solution",
                "content": "# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] score = new long[nums.length];\\n        int max  = Integer.MIN_VALUE;\\n        long conver = 0; long i_score =0;\\n        for(int i =0;i <nums.length;i++)\\n        {\\n            max = Math.max(max,nums[i]);\\n            conver = nums[i]+max;\\n            i_score += conver;\\n            score[i] = i_score;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] score = new long[nums.length];\\n        int max  = Integer.MIN_VALUE;\\n        long conver = 0; long i_score =0;\\n        for(int i =0;i <nums.length;i++)\\n        {\\n            max = Math.max(max,nums[i]);\\n            conver = nums[i]+max;\\n            i_score += conver;\\n            score[i] = i_score;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659176,
                "title": "c-solution-o-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> arr;\\n        int max = nums[0];\\n        long long sum = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>max){\\n                max = nums[i];\\n            }\\n            sum = sum + max + nums[i];\\n            arr.push_back(sum);\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> arr;\\n        int max = nums[0];\\n        long long sum = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>max){\\n                max = nums[i];\\n            }\\n            sum = sum + max + nums[i];\\n            arr.push_back(sum);\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659174,
                "title": "java-solution-o-n-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr = new long[nums.length];\\n        int max = nums[0];\\n        long sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>max){\\n                max = nums[i];\\n            }\\n            sum = sum + max + nums[i];\\n            arr[i] = sum;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr = new long[nums.length];\\n        int max = nums[0];\\n        long sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>max){\\n                max = nums[i];\\n            }\\n            sum = sum + max + nums[i];\\n            arr[i] = sum;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657727,
                "title": "easy-solution-straight-forward-approach",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n $$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n $$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>res(nums.size());\\n    \\n        int maxi=nums[0],x;\\n        for(int i=0;i<nums.size();i++){\\n              if(nums[i]>maxi){\\n                  maxi=nums[i];\\n              }\\n              x=nums[i]+maxi;\\n              if(i==0){\\n                res[i]=x;\\n              }else{\\n                 res[i]=res[i-1]+x;\\n              }\\n        }\\n       return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>res(nums.size());\\n    \\n        int maxi=nums[0],x;\\n        for(int i=0;i<nums.size();i++){\\n              if(nums[i]>maxi){\\n                  maxi=nums[i];\\n              }\\n              x=nums[i]+maxi;\\n              if(i==0){\\n                res[i]=x;\\n              }else{\\n                 res[i]=res[i-1]+x;\\n              }\\n        }\\n       return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652788,
                "title": "2-ms-runtime-beats-100-simple-observation-java",
                "content": "# Intuition\\nNotice from example 1 the differences between each array of the answer. The first difference is 6 which is the sum of the current max, 3, and the current element 3. Notice the third difference 12, which is the sum of the current max, 7, and the current element 5. \\n\\n# Approach\\nIf we calculate these differences and add them to the previous element, we can get the next element in our output array. Gang!\\n# Complexity\\nThe time complexity is O(N) - we traverse the array just once. \\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long max = nums[0];\\n        long[] out = new long[nums.length];\\n        out[0] = nums[0] + max;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] > max) {\\n                max = nums[i];\\n            }\\n            out[i] = nums[i] + out[i-1] + max;\\n        }\\n        return out;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long max = nums[0];\\n        long[] out = new long[nums.length];\\n        out[0] = nums[0] + max;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] > max) {\\n                max = nums[i];\\n            }\\n            out[i] = nums[i] + out[i-1] + max;\\n        }\\n        return out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652005,
                "title": "java-solution",
                "content": "# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(n)\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        int[] t=new int[n];\\n        int max=Integer.MIN_VALUE;\\n        long[] res=new long[n];\\n        for(int i=0;i<n;i++){\\n            max=Math.max(max,nums[i]);\\n            t[i]=max;\\n        }\\n        long sum=0;\\n        for(int i=0;i<n;i++){\\n            res[i]=nums[i]+t[i]+sum;\\n            sum=res[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        int[] t=new int[n];\\n        int max=Integer.MIN_VALUE;\\n        long[] res=new long[n];\\n        for(int i=0;i<n;i++){\\n            max=Math.max(max,nums[i]);\\n            t[i]=max;\\n        }\\n        long sum=0;\\n        for(int i=0;i<n;i++){\\n            res[i]=nums[i]+t[i]+sum;\\n            sum=res[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642587,
                "title": "98-11-easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nauto _ = []()\\n{\\n    std::cin.tie(0)->sync_with_stdio(0);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>a;\\n        a.push_back(nums[0]);\\n        for(int i = 1 ; i<nums.size();i++){\\n            if(nums[i]>a[a.size()-1]){\\n                a.push_back(nums[i]);\\n            }\\n            else{\\n                a.push_back(a[a.size()-1]);\\n            }\\n        }\\n        for(int i = 0 ; i<nums.size();i++){\\n            a[i] = a[i] + nums[i];\\n        }\\n        for(int i = 1 ; i<a.size() ; i++){\\n            a[i] = a[i-1] + a[i];\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nauto _ = []()\\n{\\n    std::cin.tie(0)->sync_with_stdio(0);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>a;\\n        a.push_back(nums[0]);\\n        for(int i = 1 ; i<nums.size();i++){\\n            if(nums[i]>a[a.size()-1]){\\n                a.push_back(nums[i]);\\n            }\\n            else{\\n                a.push_back(a[a.size()-1]);\\n            }\\n        }\\n        for(int i = 0 ; i<nums.size();i++){\\n            a[i] = a[i] + nums[i];\\n        }\\n        for(int i = 1 ; i<a.size() ; i++){\\n            a[i] = a[i-1] + a[i];\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3637272,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKeep record of sum of convertion array till each element\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore max and sum of convertion array for each element and add converted array element for that index \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        l=[]\\n        s=0\\n        m=0\\n        for i in range(len(nums)):\\n            m=max(m,nums[i])\\n            s=s+nums[i]+m\\n            l.append(s)\\n        return l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        l=[]\\n        s=0\\n        m=0\\n        for i in range(len(nums)):\\n            m=max(m,nums[i])\\n            s=s+nums[i]+m\\n            l.append(s)\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618344,
                "title": "beginner-freindly-approach-c",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long>mx(n);\\n        mx[0] = nums[0];\\n        int mxe = nums[0];\\n        for(int i=1; i<n; i++){\\n            mxe = max(mxe, nums[i]);\\n            mx[i]=mxe;\\n\\n        }\\n\\n        for(int i=0; i<n; i++){\\n            mx[i] = mx[i]+nums[i];\\n        }\\n        for(int i=1; i<n; i++){\\n            mx[i] = mx[i]+mx[i-1];\\n        }\\n        return mx;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long>mx(n);\\n        mx[0] = nums[0];\\n        int mxe = nums[0];\\n        for(int i=1; i<n; i++){\\n            mxe = max(mxe, nums[i]);\\n            mx[i]=mxe;\\n\\n        }\\n\\n        for(int i=0; i<n; i++){\\n            mx[i] = mx[i]+nums[i];\\n        }\\n        for(int i=1; i<n; i++){\\n            mx[i] = mx[i]+mx[i-1];\\n        }\\n        return mx;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586372,
                "title": "beat-100-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int max = 0;\\n        long[] result = new long[nums.length];\\n        for(int i = 0;i<nums.length;i++){\\n            if(nums[i]>max){\\n                max = nums[i];\\n            }\\n            if(i == 0){\\n                result[i] = nums[i] + max;\\n            }\\n            else{\\n            result[i] = result[i-1]+nums[i] + max;\\n        \\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int max = 0;\\n        long[] result = new long[nums.length];\\n        for(int i = 0;i<nums.length;i++){\\n            if(nums[i]>max){\\n                max = nums[i];\\n            }\\n            if(i == 0){\\n                result[i] = nums[i] + max;\\n            }\\n            else{\\n            result[i] = result[i-1]+nums[i] + max;\\n        \\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582084,
                "title": "java-easy-solution",
                "content": "# Intuition\\nMaximum is fixed and direct implementation of given formula\\n\\n# Approach\\nDynamic programming\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] conver = new long[nums.length];\\n        conver[0] = nums[0]*2;\\n        int maxi = nums[0];\\n        for(int i = 1;nums.length>i;i++){\\n            maxi = Math.max(maxi,nums[i]);\\n            conver[i] = maxi+nums[i]+conver[i-1];\\n        }\\n        return conver;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] conver = new long[nums.length];\\n        conver[0] = nums[0]*2;\\n        int maxi = nums[0];\\n        for(int i = 1;nums.length>i;i++){\\n            maxi = Math.max(maxi,nums[i]);\\n            conver[i] = maxi+nums[i]+conver[i-1];\\n        }\\n        return conver;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581187,
                "title": "java-simple-solution-o-n-100-faster",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public long[] findPrefixScore(int[] nums) {\\n        long max = 0;\\n        long sum = 0;\\n        long[] ans = new long[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > max) {\\n                max = nums[i];\\n            }\\n            sum += nums[i] + max;\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n\\n    public long[] findPrefixScore(int[] nums) {\\n        long max = 0;\\n        long sum = 0;\\n        long[] ans = new long[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > max) {\\n                max = nums[i];\\n            }\\n            sum += nums[i] + max;\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571029,
                "title": "simple-solution-in-a-single-loop-prefix-sum",
                "content": "# Intuition\\n<a href=\"https://ibb.co/mDwk4pt\"><img src=\"https://i.ibb.co/BzxbBkj/null-1.png\" alt=\"null-1\" border=\"0\"></a><br />\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int len = nums.size();\\n        vector<long long int> prefix(len,0);\\n        int mx(0);\\n\\n        for(int i  = 0; i < len; i++){\\n            mx = max(mx,nums[i]);\\n\\n            prefix[i] = (nums[i] + mx);\\n\\n            if(i > 0){\\n                prefix[i] += prefix[i - 1];\\n            }\\n        }\\n\\n        return prefix;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int len = nums.size();\\n        vector<long long int> prefix(len,0);\\n        int mx(0);\\n\\n        for(int i  = 0; i < len; i++){\\n            mx = max(mx,nums[i]);\\n\\n            prefix[i] = (nums[i] + mx);\\n\\n            if(i > 0){\\n                prefix[i] += prefix[i - 1];\\n            }\\n        }\\n\\n        return prefix;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567821,
                "title": "simple-java-solution-using-array-and-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO( N )<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO( N )<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        \\n        int n=nums.length;\\n        long[] ans=new long[n]; //for final ans\\n        long[] max=new long[n]; //for calculating sum of element and max\\n                                // before it\\n\\n        max[0]=2*nums[0];\\n        long temp=nums[0];\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>temp){\\n                max[i]=2*nums[i];\\n                temp=nums[i]; //Here we have calculted the max value before\\n                             //it and sum of that element.\\n            }\\n            else max[i]=temp+nums[i];\\n        }\\n        \\n        ans[0]=max[0];\\n\\n        for(int i=1;i<n;i++){\\n            ans[i]=ans[i-1]+max[i]; //we calculated the prefix sum using\\n                                    // max array.\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        \\n        int n=nums.length;\\n        long[] ans=new long[n]; //for final ans\\n        long[] max=new long[n]; //for calculating sum of element and max\\n                                // before it\\n\\n        max[0]=2*nums[0];\\n        long temp=nums[0];\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>temp){\\n                max[i]=2*nums[i];\\n                temp=nums[i]; //Here we have calculted the max value before\\n                             //it and sum of that element.\\n            }\\n            else max[i]=temp+nums[i];\\n        }\\n        \\n        ans[0]=max[0];\\n\\n        for(int i=1;i<n;i++){\\n            ans[i]=ans[i-1]+max[i]; //we calculated the prefix sum using\\n                                    // max array.\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567125,
                "title": "using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> \\nfirst calculating the prefix sum then calculating the score. for calculating prefix sum used priority queue.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\nO(n), where n is size of nums.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>pref,ans; \\n        priority_queue<long long>pq;  \\n       // pq.push(nums[0]);\\n        for(int i=0;i<nums.size();i++) \\n        { \\n             pq.push(nums[i]);\\n           pref.push_back(nums[i]+pq.top()); \\n          \\n        } \\n        ans.push_back(pref[0]); \\n        for(int i=1;i<pref.size();i++) \\n        {\\n            ans.push_back(ans[i-1]+pref[i]);\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>pref,ans; \\n        priority_queue<long long>pq;  \\n       // pq.push(nums[0]);\\n        for(int i=0;i<nums.size();i++) \\n        { \\n             pq.push(nums[i]);\\n           pref.push_back(nums[i]+pq.top()); \\n          \\n        } \\n        ans.push_back(pref[0]); \\n        for(int i=1;i<pref.size();i++) \\n        {\\n            ans.push_back(ans[i-1]+pref[i]);\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566507,
                "title": "c-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvector<long long> Get_converted(vector<int> &nums)\\n{\\n    vector<long long> ans = {};\\n    long long maximum = nums[0];\\n    for(int i = 0; i<nums.size(); i++)\\n    {\\n        maximum = max((long long)nums[i], maximum);\\n        int x = nums[i] + maximum;\\n        ans.push_back(x);\\n    }\\n    return ans;\\n}\\nvoid Get_added(vector<long long> &ans)\\n{\\n    long long sum = 0;\\n    for(int i = 0; i<ans.size(); i++)\\n    {\\n        sum = sum + ans[i];\\n        ans[i] = sum;\\n    }\\n}\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        // Cancel as answer differs after sorting -> sort(nums.begin(), nums.end());\\n        // We got the conversion array\\n        vector<long long> ans = Get_converted(nums);\\n        Get_added(ans);\\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvector<long long> Get_converted(vector<int> &nums)\\n{\\n    vector<long long> ans = {};\\n    long long maximum = nums[0];\\n    for(int i = 0; i<nums.size(); i++)\\n    {\\n        maximum = max((long long)nums[i], maximum);\\n        int x = nums[i] + maximum;\\n        ans.push_back(x);\\n    }\\n    return ans;\\n}\\nvoid Get_added(vector<long long> &ans)\\n{\\n    long long sum = 0;\\n    for(int i = 0; i<ans.size(); i++)\\n    {\\n        sum = sum + ans[i];\\n        ans[i] = sum;\\n    }\\n}\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        // Cancel as answer differs after sorting -> sort(nums.begin(), nums.end());\\n        // We got the conversion array\\n        vector<long long> ans = Get_converted(nums);\\n        Get_added(ans);\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1864501,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1880976,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1868316,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1864344,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1974599,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1938215,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1876746,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1865483,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1864439,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1864351,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1864501,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1880976,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1868316,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1864344,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1974599,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1938215,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1876746,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1865483,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1864439,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1864351,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            }
        ]
    }
]