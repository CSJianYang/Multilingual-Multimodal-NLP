[
    {
        "title": "Longest Common Prefix",
        "question_content": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".\n&nbsp;\nExample 1:\n\nInput: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"\n\nExample 2:\n\nInput: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.\n\n&nbsp;\nConstraints:\n\n\t1 <= strs.length <= 200\n\t0 <= strs[i].length <= 200\n\tstrs[i] consists of only lowercase English letters.",
        "solutions": [
            {
                "id": 3174307,
                "title": "well-explained-code-using-strings-in-java",
                "content": "\\n# Approach\\nThis code is used to find the longest common prefix of an array of strings, which is defined as the longest string that is a prefix of all the strings in the array. By sorting the array and then comparing the first and last elements, the code is able to find the common prefix that would be shared by all strings in the array.\\n\\n1. Sort the elements of an array of strings called \"strs\" in lexicographic (alphabetical) order using the Arrays.sort(strs) method.\\n2. Assign the first element of the sorted array (the lexicographically smallest string) to a string variable s1.\\n3. Assign the last element of the sorted array (the lexicographically largest string) to a string variable s2.\\n4. Initialize an integer variable idx to 0.\\n5. Start a while loop that continues while idx is less than the length of s1 and s2.\\n6. Within the while loop, check if the character at the current index in s1 is equal to the character at the same index in s2. If the characters are equal, increment the value of idx by 1.\\n7. If the characters are not equal, exit the while loop.\\n8. Return the substring of s1 that starts from the first character and ends at the idxth character (exclusive).\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n1. Sorting the array of strings takes O(Nlog(N)) time. This is because most of the common sorting algorithms like quicksort, mergesort, and heapsort have an average time complexity of O(Nlog(N)).\\n2. Iterating over the characters of the first and last strings takes O(M) time. This is because the code compares the characters of the two strings until it finds the first mismatch.\\n\\nTherefore, the total time complexity is O(Nlog(N) + M).\\n\\n\\n\\n\\n- Space complexity:\\nThe space used by the two string variables s1 and s2 is proportional to the length of the longest string in the array. Therefore, the space complexity is O(1) as it does not depend on the size of the input array.\\n\\n# Reason for Sorting \\n\\nThe reason why we sort the input array of strings and compare the first and last strings is that the longest common prefix of all the strings must be a prefix of the first string and a prefix of the last string in the sorted array. This is because strings are ordered based on their alphabetical order (Lexicographical order).\\nFor example, consider the input array of strings {\"flower\", \"flow\", \"flight\"}. After sorting the array, we get {\"flight\", \"flow\", \"flower\"}. The longest common prefix of all the strings is \"fl\", which is located at the beginning of the first string \"flight\" and the second string \"flow\". Therefore, by comparing the first and last strings of the sorted array, we can easily find the longest common prefix.\\n\\n# Code\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        Arrays.sort(strs);\\n        String s1 = strs[0];\\n        String s2 = strs[strs.length-1];\\n        int idx = 0;\\n        while(idx < s1.length() && idx < s2.length()){\\n            if(s1.charAt(idx) == s2.charAt(idx)){\\n                idx++;\\n            } else {\\n                break;\\n            }\\n        }\\n        return s1.substring(0, idx);\\n    }\\n}\\n```\\n![upvote.jpeg](https://assets.leetcode.com/users/images/078cc82b-d80b-4aef-ae08-ce75ef6c698d_1676176908.0916324.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        Arrays.sort(strs);\\n        String s1 = strs[0];\\n        String s2 = strs[strs.length-1];\\n        int idx = 0;\\n        while(idx < s1.length() && idx < s2.length()){\\n            if(s1.charAt(idx) == s2.charAt(idx)){\\n                idx++;\\n            } else {\\n                break;\\n            }\\n        }\\n        return s1.substring(0, idx);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273176,
                "title": "python3-c-java-19-ms-beats-99-91",
                "content": "# Please UPVOTE\\uD83D\\uDE0A\\n![image.png](https://assets.leetcode.com/users/images/f54185ef-bb76-4c6e-807b-66e506e7fab0_1678294130.6935549.png)\\n\\nThis code implements the longestCommonPrefix function that takes a list of strings v as input and returns the longest common prefix of all the strings. Here is an explanation of how the code works:\\n\\n1. Initialize an empty string ans to store the common prefix.\\n2. Sort the input list v lexicographically. This step is necessary because the common prefix should be common to all the strings, so we need to find the common prefix of the first and last string in the sorted list.\\n3. Iterate through the characters of the first and last string in the sorted list, stopping at the length of the shorter string.\\n4. If the current character of the first string is not equal to the current character of the last string, return the common prefix found so far.\\n5. Otherwise, append the current character to the ans string.\\n6. Return the ans string containing the longest common prefix.\\n\\nNote that the code assumes that the input list v is non-empty, and that all the strings in v have at least one character. If either of these assumptions is not true, the code may fail.\\n# Python3\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, v: List[str]) -> str:\\n        ans=\"\"\\n        v=sorted(v)\\n        first=v[0]\\n        last=v[-1]\\n        for i in range(min(len(first),len(last))):\\n            if(first[i]!=last[i]):\\n                return ans\\n            ans+=first[i]\\n        return ans \\n\\n```\\n# C++\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& v) {\\n        string ans=\"\";\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n        string first=v[0],last=v[n-1];\\n        for(int i=0;i<min(first.size(),last.size());i++){\\n            if(first[i]!=last[i]){\\n                return ans;\\n            }\\n            ans+=first[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Java \\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] v) {\\n        StringBuilder ans = new StringBuilder();\\n        Arrays.sort(v);\\n        String first = v[0];\\n        String last = v[v.length-1];\\n        for (int i=0; i<Math.min(first.length(), last.length()); i++) {\\n            if (first.charAt(i) != last.charAt(i)) {\\n                return ans.toString();\\n            }\\n            ans.append(first.charAt(i));\\n        }\\n        return ans.toString();\\n    }\\n}\\n```\\n![image.png](https://assets.leetcode.com/users/images/a6c83c54-1d1a-4f26-8273-b687d119dd5b_1679889261.1494205.png)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, v: List[str]) -> str:\\n        ans=\"\"\\n        v=sorted(v)\\n        first=v[0]\\n        last=v[-1]\\n        for i in range(min(len(first),len(last))):\\n            if(first[i]!=last[i]):\\n                return ans\\n            ans+=first[i]\\n        return ans \\n\\n```\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& v) {\\n        string ans=\"\";\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n        string first=v[0],last=v[n-1];\\n        for(int i=0;i<min(first.size(),last.size());i++){\\n            if(first[i]!=last[i]){\\n                return ans;\\n            }\\n            ans+=first[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] v) {\\n        StringBuilder ans = new StringBuilder();\\n        Arrays.sort(v);\\n        String first = v[0];\\n        String last = v[v.length-1];\\n        for (int i=0; i<Math.min(first.length(), last.length()); i++) {\\n            if (first.charAt(i) != last.charAt(i)) {\\n                return ans.toString();\\n            }\\n            ans.append(first.charAt(i));\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6918,
                "title": "short-python-solution",
                "content": "```\\n def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        if not strs:\\n            return \"\"\\n        shortest = min(strs,key=len)\\n        for i, ch in enumerate(shortest):\\n            for other in strs:\\n                if other[i] != ch:\\n                    return shortest[:i]\\n        return shortest \\n```",
                "solutionTags": [],
                "code": "```\\n def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        if not strs:\\n            return \"\"\\n        shortest = min(strs,key=len)\\n        for i, ch in enumerate(shortest):\\n            for other in strs:\\n                if other[i] != ch:\\n                    return shortest[:i]\\n        return shortest \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 721752,
                "title": "java-100-just-compare-two-strings",
                "content": "```class Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if (strs == null || strs.length == 0)\\n            return \"\";\\n        \\n        Arrays.sort(strs);\\n        String first = strs[0];\\n        String last = strs[strs.length - 1];\\n        int c = 0;\\n        while(c < first.length())\\n        {\\n            if (first.charAt(c) == last.charAt(c))\\n                c++;\\n            else\\n                break;\\n        }\\n        return c == 0 ? \"\" : first.substring(0, c);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if (strs == null || strs.length == 0)\\n            return \"\";\\n        \\n        Arrays.sort(strs);\\n        String first = strs[0];\\n        String last = strs[strs.length - 1];\\n        int c = 0;\\n        while(c < first.length())\\n        {\\n            if (first.charAt(c) == last.charAt(c))\\n                c++;\\n            else\\n                break;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1405155,
                "title": "java-detailed-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String prefix = strs[0];\\n        for(int index=1;index<strs.length;index++){\\n            while(strs[index].indexOf(prefix) != 0){\\n                prefix=prefix.substring(0,prefix.length()-1);\\n            }\\n        }\\n        return prefix;\\n    }\\n}\\n\\n/*\\nPLEASE UPVOTE IF IT HELPS YOU! THANK YOU!\\nRecommend to dry run along with the example.\\n\\nWorking:\\n1)Take the first(index=0) string in the array as prefix.\\n2)Iterate from second(index=1) string till the end.\\n3)Use the indexOf() function to check if the prefix is there in the strs[i] or not.\\nIf the prefix is there the function returns 0 else -1.\\n4)Use the substring function to chop the last letter from prefix each time the function return -1.\\n\\neg:\\nstrs=[\"flower\", \"flow\", \"flight\"]\\nprefix=flower\\nindex=1\\n    while(strs[index].indexOf(prefix) != 0) means while(\"flow\".indexOf(\"flower\")!=0)\\n    Since flower as a whole is not in flow, it return -1 and  prefix=prefix.substring(0,prefix.length()-1) reduces prefix to \"flowe\"\\n    Again while(strs[index].indexOf(prefix) != 0) means while(\"flow\".indexOf(\"flowe\")!=0)\\n    Since flowe as a whole is not in flow, it return -1 and  prefix=prefix.substring(0,prefix.length()-1) reduces prefix to \"flow\"\\n    Again while(strs[index].indexOf(prefix) != 0) means while(\"flow\".indexOf(\"flow\")!=0)\\n    Since flow as a whole is in flow, it returns 0 so now prefix=flow\\nindex=2\\n    while(strs[index].indexOf(prefix) != 0) means while(\"flight\".indexOf(\"flow\")!=0)\\n    Since flow as a whole is not in flight, it return -1 and  prefix=prefix.substring(0,prefix.length()-1) reduces prefix to \"flo\"\\n    Again while(strs[index].indexOf(prefix) != 0) means while(\"flight\".indexOf(\"flo\")!=0)\\n    Since flo as a whole is not in flight, it return -1 and  prefix=prefix.substring(0,prefix.length()-1) reduces prefix to \"fl\"\\n    Again while(strs[index].indexOf(prefix) != 0) means while(\"flight\".indexOf(\"fl\")!=0)\\n    Since fl as a whole is in flight, it returns 0 so now prefix=fl\\nindex=3, for loop terminates and we return prefix which is equal to fl\\n*/\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String prefix = strs[0];\\n        for(int index=1;index<strs.length;index++){\\n            while(strs[index].indexOf(prefix) != 0){\\n                prefix=prefix.substring(0,prefix.length()-1);\\n            }\\n        }\\n        return prefix;\\n    }\\n}\\n\\n/*\\nPLEASE UPVOTE IF IT HELPS YOU! THANK YOU!\\nRecommend to dry run along with the example.\\n\\nWorking:\\n1)Take the first(index=0) string in the array as prefix.\\n2)Iterate from second(index=1) string till the end.\\n3)Use the indexOf() function to check if the prefix is there in the strs[i] or not.\\nIf the prefix is there the function returns 0 else -1.\\n4)Use the substring function to chop the last letter from prefix each time the function return -1.\\n\\neg:\\nstrs=[\"flower\", \"flow\", \"flight\"]\\nprefix=flower\\nindex=1\\n    while(strs[index].indexOf(prefix) != 0) means while(\"flow\".indexOf(\"flower\")!=0)\\n    Since flower as a whole is not in flow, it return -1 and  prefix=prefix.substring(0,prefix.length()-1) reduces prefix to \"flowe\"\\n    Again while(strs[index].indexOf(prefix) != 0) means while(\"flow\".indexOf(\"flowe\")!=0)\\n    Since flowe as a whole is not in flow, it return -1 and  prefix=prefix.substring(0,prefix.length()-1) reduces prefix to \"flow\"\\n    Again while(strs[index].indexOf(prefix) != 0) means while(\"flow\".indexOf(\"flow\")!=0)\\n    Since flow as a whole is in flow, it returns 0 so now prefix=flow\\nindex=2\\n    while(strs[index].indexOf(prefix) != 0) means while(\"flight\".indexOf(\"flow\")!=0)\\n    Since flow as a whole is not in flight, it return -1 and  prefix=prefix.substring(0,prefix.length()-1) reduces prefix to \"flo\"\\n    Again while(strs[index].indexOf(prefix) != 0) means while(\"flight\".indexOf(\"flo\")!=0)\\n    Since flo as a whole is not in flight, it return -1 and  prefix=prefix.substring(0,prefix.length()-1) reduces prefix to \"fl\"\\n    Again while(strs[index].indexOf(prefix) != 0) means while(\"flight\".indexOf(\"fl\")!=0)\\n    Since fl as a whole is in flight, it returns 0 so now prefix=fl\\nindex=3, for loop terminates and we return prefix which is equal to fl\\n*/\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 391089,
                "title": "c-easy-to-understand-solution-using-sort",
                "content": "The code below is very much self explanatory. \\n1. We first sort the array of strings.\\n2. Then, we choose the first and last string in the array. `[They are supposed to be the most different among all the pairs of strings in the sorted array]`\\n3. We just compare how many common characters match from index  `i = 0`  of these two strings.\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) {\\n        int n = str.size();\\n        if(n==0) return \"\";\\n        \\n        string ans  = \"\";\\n        sort(begin(str), end(str));\\n        string a = str[0];\\n        string b = str[n-1];\\n        \\n        for(int i=0; i<a.size(); i++){\\n            if(a[i]==b[i]){\\n                ans = ans + a[i];\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) {\\n        int n = str.size();\\n        if(n==0) return \"\";\\n        \\n        string ans  = \"\";\\n        sort(begin(str), end(str));\\n        string a = str[0];\\n        string b = str[n-1];\\n        \\n        for(int i=0; i<a.size(); i++){\\n            if(a[i]==b[i]){\\n                ans = ans + a[i];\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6910,
                "title": "java-code-with-13-lines",
                "content": "\\n    public String longestCommonPrefix(String[] strs) {\\n        if(strs == null || strs.length == 0)    return \"\";\\n        String pre = strs[0];\\n        int i = 1;\\n        while(i < strs.length){\\n            while(strs[i].indexOf(pre) != 0)\\n                pre = pre.substring(0,pre.length()-1);\\n            i++;\\n        }\\n        return pre;\\n    }",
                "solutionTags": [],
                "code": "\\n    public String longestCommonPrefix(String[] strs) {\\n        if(strs == null || strs.length == 0)    return \"\";\\n        String pre = strs[0];\\n        int i = 1;\\n        while(i < strs.length){\\n            while(strs[i].indexOf(pre) != 0)\\n                pre = pre.substring(0,pre.length()-1);\\n            i++;\\n        }\\n        return pre;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 172553,
                "title": "beat-100-python-submission-short-and-clean",
                "content": "**using enumerater**\n```\nclass Solution:\n    def longestCommonPrefix(self, m):\n        if not m: return ''\n\t\t\t\t#since list of string will be sorted and retrieved min max by alphebetic order\n        s1 = min(m)\n        s2 = max(m)\n\n        for i, c in enumerate(s1):\n            if c != s2[i]:\n                return s1[:i] #stop until hit the split index\n        return s1\n```",
                "solutionTags": [],
                "code": "```\nclass Solution:\n    def longestCommonPrefix(self, m):\n        if not m: return ''\n\t\t\t\t#since list of string will be sorted and retrieved min max by alphebetic order\n        s1 = min(m)\n        s2 = max(m)\n\n        for i, c in enumerate(s1):\n            if c != s2[i]:\n                return s1[:i] #stop until hit the split index\n        return s1\n```",
                "codeTag": "Java"
            },
            {
                "id": 2669032,
                "title": "c-very-easy-explained",
                "content": "The longest common prefix is common to all the strings. So, we can fix one string and check the common prefix of this string with other strings. The minimum such length is found and the answer is the substring of the fixed string starting from 0 to the length of the above such minimum.\\nHere, I have fixed 0th string and checked other strings with this. \\n**Full Code:**\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& s) {\\n        int ans = s[0].length(), n = s.size();\\n        for(int i=1; i<n; i++){\\n            int j = 0;\\n            while(j<s[i].length() && s[i][j]==s[0][j])j++;\\n            ans = min(ans, j);\\n        }\\n        return s[0].substr(0, ans);\\n    }\\n};\\n```\\n**Incase you found the post useful, please give it an upvote.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& s) {\\n        int ans = s[0].length(), n = s.size();\\n        for(int i=1; i<n; i++){\\n            int j = 0;\\n            while(j<s[i].length() && s[i][j]==s[0][j])j++;\\n            ans = min(ans, j);\\n        }\\n        return s[0].substr(0, ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184623,
                "title": "simplest-c-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end());\\n        int a=strs.size();\\n        string n=strs[0],m=strs[a-1],ans=\"\";\\n        for(int i=0;i<n.size();i++){\\n            if(n[i]==m[i]){ans+=n[i];}\\n            else break;\\n        }\\n        return ans;\\n        \\n    }\\n};\\nDo UPVOTE if you like\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end());\\n        int a=strs.size();\\n        string n=strs[0],m=strs[a-1],ans=\"\";\\n        for(int i=0;i<n.size();i++){\\n            if(n[i]==m[i]){ans+=n[i];}\\n            else break;\\n        }\\n        return ans;\\n        \\n    }\\n};\\nDo UPVOTE if you like\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354496,
                "title": "python3-list-zip-str",
                "content": "*  list(zip(*strs))\\nstrs = [\"flower\",\"flow\",\"flight\"]\\n```\\nstrs = [\"flower\",\"flow\",\"flight\"]\\nl = list(zip(*strs))\\n>>> l = [(\\'f\\', \\'f\\', \\'f\\'), (\\'l\\', \\'l\\', \\'l\\'), (\\'o\\', \\'o\\', \\'i\\'), (\\'w\\', \\'w\\', \\'g\\')]\\n```\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        l = list(zip(*strs))\\n        prefix = \"\"\\n        for i in l:\\n            if len(set(i))==1:\\n                prefix += i[0]\\n            else:\\n                break\\n        return prefix\\n```\\n* traditional scan vertically\\n```\\n i      0  1  2  3  4  5\\n 0      f  l  o  w  e  r\\n 1\\t    f  l  o  w\\n 2\\t    f  l  i  g  h  t\\n\\t\\t\\nWe choose the first string in the list as a reference. in this case is str[0] = \"flower\"\\nthe outside for-loop go through each character of the str[0] or \"flower\". f->l->o->w->e->r\\nthe inside for-loop, go through the words, in this case is flow, flight.\\n\\n\\nstrs[j][i] means the the i\\'s character of the j words in the strs.\\n\\nthere are 3 cases when we proceed the scan:\\n\\ncase 1: strs[j][i] = c, strs[1][2] = \\'o\\' and strs[0][2] = \\'o\\';  keep going;\\ncase 2: strs[j][i] != c, strs[2][2] = \\'i\\' and strs[0][2] = \\'o\\';  break the rule, we can return strs[j][:i]. when comes to slicing a string, [:i] won\\'t include the index i;\\ncase 3: i = len(strs[j]) which means current word at strs[j] doesn\\'t have character at index i, since it\\'s 0 based index. the lenght equals i, the index ends at i - 1; break the rule, we can return.\\n\\n \\n```\\n\\n\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if strs == None or len(strs) == 0: return \"\"\\n        for i in range(len(strs[0])): \\n            c = strs[0][i]// \\n            for j in range(1,len(strs)):\\n                if i == len(strs[j]) or strs[j][i] != c:\\n                    return strs[0][:i]\\n        return strs[0] if strs else \"\"\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nstrs = [\"flower\",\"flow\",\"flight\"]\\nl = list(zip(*strs))\\n>>> l = [(\\'f\\', \\'f\\', \\'f\\'), (\\'l\\', \\'l\\', \\'l\\'), (\\'o\\', \\'o\\', \\'i\\'), (\\'w\\', \\'w\\', \\'g\\')]\\n```\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        l = list(zip(*strs))\\n        prefix = \"\"\\n        for i in l:\\n            if len(set(i))==1:\\n                prefix += i[0]\\n            else:\\n                break\\n        return prefix\\n```\n```\\n i      0  1  2  3  4  5\\n 0      f  l  o  w  e  r\\n 1\\t    f  l  o  w\\n 2\\t    f  l  i  g  h  t\\n\\t\\t\\nWe choose the first string in the list as a reference. in this case is str[0] = \"flower\"\\nthe outside for-loop go through each character of the str[0] or \"flower\". f->l->o->w->e->r\\nthe inside for-loop, go through the words, in this case is flow, flight.\\n\\n\\nstrs[j][i] means the the i\\'s character of the j words in the strs.\\n\\nthere are 3 cases when we proceed the scan:\\n\\ncase 1: strs[j][i] = c, strs[1][2] = \\'o\\' and strs[0][2] = \\'o\\';  keep going;\\ncase 2: strs[j][i] != c, strs[2][2] = \\'i\\' and strs[0][2] = \\'o\\';  break the rule, we can return strs[j][:i]. when comes to slicing a string, [:i] won\\'t include the index i;\\ncase 3: i = len(strs[j]) which means current word at strs[j] doesn\\'t have character at index i, since it\\'s 0 based index. the lenght equals i, the index ends at i - 1; break the rule, we can return.\\n\\n \\n```\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if strs == None or len(strs) == 0: return \"\"\\n        for i in range(len(strs[0])): \\n            c = strs[0][i]// \\n            for j in range(1,len(strs)):\\n                if i == len(strs[j]) or strs[j][i] != c:\\n                    return strs[0][:i]\\n        return strs[0] if strs else \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6924,
                "title": "sorted-the-array-java-solution-2-ms",
                "content": "Sort the array first, and then you can simply compare the first and last elements in the sorted array.\\n\\n\\n        public String longestCommonPrefix(String[] strs) {\\n            StringBuilder result = new StringBuilder();\\n            \\n            if (strs!= null && strs.length > 0){\\n            \\n                Arrays.sort(strs);\\n                \\n                char [] a = strs[0].toCharArray();\\n                char [] b = strs[strs.length-1].toCharArray();\\n                \\n                for (int i = 0; i < a.length; i ++){\\n                    if (b.length > i && b[i] == a[i]){\\n                        result.append(b[i]);\\n                    }\\n                    else {\\n                        return result.toString();\\n                    }\\n                }\\n            return result.toString();\\n        }",
                "solutionTags": [],
                "code": "Sort the array first, and then you can simply compare the first and last elements in the sorted array.\\n\\n\\n        public String longestCommonPrefix(String[] strs) {\\n            StringBuilder result = new StringBuilder();\\n            \\n            if (strs!= null && strs.length > 0){\\n            \\n                Arrays.sort(strs);\\n                \\n                char [] a = strs[0].toCharArray();\\n                char [] b = strs[strs.length-1].toCharArray();\\n                \\n                for (int i = 0; i < a.length; i ++){\\n                    if (b.length > i && b[i] == a[i]){\\n                        result.append(b[i]);\\n                    }\\n                    else {\\n                        return result.toString();\\n                    }\\n                }\\n            return result.toString();\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 6911,
                "title": "simple-python-solution",
                "content": "Might be a bit slow, but here's my relatively elegant Python solution:\\n\\n    class Solution:\\n        # @return a string\\n        def longestCommonPrefix(self, strs):\\n            if not strs:\\n                return \"\"\\n                \\n            for i, letter_group in enumerate(zip(*strs)):\\n                if len(set(letter_group)) > 1:\\n                    return strs[0][:i]\\n            else:\\n                return min(strs)",
                "solutionTags": [],
                "code": "Might be a bit slow, but here's my relatively elegant Python solution:\\n\\n    class Solution:\\n        # @return a string\\n        def longestCommonPrefix(self, strs):\\n            if not strs:\\n                return \"\"\\n                \\n            for i, letter_group in enumerate(zip(*strs)):\\n                if len(set(letter_group)) > 1:\\n                    return strs[0][:i]\\n            else:\\n                return min(strs)",
                "codeTag": "Java"
            },
            {
                "id": 2748936,
                "title": "simple-java-solution",
                "content": "```\\n    public String longestCommonPrefix(String[] strs) {\\n        if(strs.length==0) return \"\";\\n        String prefix=strs[0];\\n        for(int i=1;i<strs.length;i++){\\n            while(strs[i].indexOf(prefix)!=0){\\n                prefix=prefix.substring(0,prefix.length()-1);\\n            }\\n            \\n        }\\n        return prefix;\\n        \\n        \\n    }\\n//Please upvote",
                "solutionTags": [],
                "code": "```\\n    public String longestCommonPrefix(String[] strs) {\\n        if(strs.length==0) return \"\";\\n        String prefix=strs[0];\\n        for(int i=1;i<strs.length;i++){\\n            while(strs[i].indexOf(prefix)!=0){\\n                prefix=prefix.substring(0,prefix.length()-1);\\n            }\\n            \\n        }\\n        return prefix;\\n        \\n        \\n    }\\n//Please upvote",
                "codeTag": "Unknown"
            },
            {
                "id": 1351149,
                "title": "python-startswith",
                "content": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        \\n        pre = strs[0]\\n        \\n        for i in strs:\\n            while not i.startswith(pre):\\n                pre = pre[:-1]\\n        \\n        return pre     \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        \\n        pre = strs[0]\\n        \\n        for i in strs:\\n            while not i.startswith(pre):\\n                pre = pre[:-1]\\n        \\n        return pre     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 6983,
                "title": "js-higher-order-function-solution-with-concise-and-easy-to-understand-code",
                "content": "reduce is just for this: take a list of strings and reduce them to one string\\n\\n    var longestCommonPrefix = function(strs) {\\n        'use strict';\\n        if (strs === undefined || strs.length === 0) { return ''; }\\n        \\n        return strs.reduce((prev, next) => {\\n            let i = 0;\\n            while (prev[i] && next[i] && prev[i] === next[i]) i++;\\n            return prev.slice(0, i);\\n        });\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "reduce is just for this: take a list of strings and reduce them to one string\\n\\n    var longestCommonPrefix = function(strs) {\\n        'use strict';\\n        if (strs === undefined || strs.length === 0) { return ''; }\\n        \\n        return strs.reduce((prev, next) => {\\n            let i = 0;\\n            while (prev[i] && next[i] && prev[i] === next[i]) i++;\\n            return prev.slice(0, i);\\n        });\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3031312,
                "title": "longest-common-prefix-in-python",
                "content": "# Intuition\\nCompare each letter of each word to check if they match, and add them to an empty string until you hit a character that doesn\\'t match. Return the string obtained so far.\\n\\n# Approach\\nInitialize an empty string. Zip the list, so you get the first characters of each word together in a tuple, the second letters in another tuple, and so on. Convert each such tuple into a set, and check if the length of the set is 1 - to understand if the elements were same (as sets store only 1 instance of a repeated element). If the length of the set is 1, add the first element of the tuple (any element is fine, as all elements are same but we take the first element just to be cautious) to the empty string. If the length of a set is not 1, return the string as is. Finally, return the string obtained thus far.\\n\\n# Complexity\\n- Time complexity:\\n\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        res = \"\"\\n        for a in zip(*strs):\\n            if len(set(a)) == 1: \\n                res += a[0]\\n            else: \\n                return res\\n        return res\\n                        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        res = \"\"\\n        for a in zip(*strs):\\n            if len(set(a)) == 1: \\n                res += a[0]\\n            else: \\n                return res\\n        return res\\n                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1393325,
                "title": "c-solution-100-faster-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs){\\n        int n =strs.size();\\n        string ans; \\n        sort(strs.begin(), strs.end());\\n        string a = strs[0];\\n        string b = strs[n-1];\\n        for(int i =0; i< a.size(); i++){\\n            if(a[i] == b[i]){\\n                ans += a[i];\\n            }else break;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs){\\n        int n =strs.size();\\n        string ans; \\n        sort(strs.begin(), strs.end());\\n        string a = strs[0];\\n        string b = strs[n-1];\\n        for(int i =0; i< a.size(); i++){\\n            if(a[i] == b[i]){\\n                ans += a[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 526694,
                "title": "javascript-simple-solution-using-every-with-explanation",
                "content": "# Approach\\n- First find the shortest string in the array; the length of this string is the maximum length of our prefix \\n\\t- this is because a prefix can\\'t be longer than the word it inhabits\\n- Next we iterate from `index 0` to `maxPrefixLength - 1`\\n- We use this index to check the corresponding character of each string together and compare them\\n- This is easily done using `Array.every`\\n- If all characters at `index i` match, then we add it to our `prefix` result string\\n- As soon as we hit one mismatch, that\\'s the end of the common prefix and we break out of our loop\\n- return prefix at the end, which may be empty\\n\\n# Solution\\n```\\nvar longestCommonPrefix = function(strs) {\\n  if (!strs.length) return \\'\\';\\n  let prefix = \\'\\';\\n  let maxPrefixLength = Math.min(...strs.map(str => str.length));\\n  for (let i = 0; i < maxPrefixLength; i++) {\\n    let char = strs[0][i];\\n    if (strs.every(str => str[i] === char)) {\\n      prefix += char;\\n    } else {\\n      break;\\n    }\\n  };  \\n  return prefix;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestCommonPrefix = function(strs) {\\n  if (!strs.length) return \\'\\';\\n  let prefix = \\'\\';\\n  let maxPrefixLength = Math.min(...strs.map(str => str.length));\\n  for (let i = 0; i < maxPrefixLength; i++) {\\n    let char = strs[0][i];\\n    if (strs.every(str => str[i] === char)) {\\n      prefix += char;\\n    } else {\\n      break;\\n    }\\n  };  \\n  return prefix;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1136361,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranty of any kind. You are free to use the content freely and as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    func longestCommonPrefix(_ strs: [String]) -> String {\\n        \\n        if strs.isEmpty { return \"\" }\\n        var common = strs[0]\\n        \\n        for ch in strs {\\n            while !ch.hasPrefix(common) {\\n                common = String(common.dropLast())\\n            }\\n        }\\n        return common\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.004 (0.006) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.longestCommonPrefix([\"flower\",\"flow\",\"flight\"])\\n        XCTAssertEqual(value, \"fl\")\\n    }\\n    func test1() {\\n        let value = solution.longestCommonPrefix([\"dog\",\"racecar\",\"car\"])\\n        XCTAssertEqual(value, \"\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func longestCommonPrefix(_ strs: [String]) -> String {\\n        \\n        if strs.isEmpty { return \"\" }\\n        var common = strs[0]\\n        \\n        for ch in strs {\\n            while !ch.hasPrefix(common) {\\n                common = String(common.dropLast())\\n            }\\n        }\\n        return common\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.longestCommonPrefix([\"flower\",\"flow\",\"flight\"])\\n        XCTAssertEqual(value, \"fl\")\\n    }\\n    func test1() {\\n        let value = solution.longestCommonPrefix([\"dog\",\"racecar\",\"car\"])\\n        XCTAssertEqual(value, \"\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484683,
                "title": "python-3-beats-97-six-lines",
                "content": "```\\nclass Solution:\\n    def longestCommonPrefix(self, S: List[str]) -> str:\\n        if not S: return \\'\\'\\n        m, M, i = min(S), max(S), 0\\n        for i in range(min(len(m),len(M))):\\n            if m[i] != M[i]: break\\n        else: i += 1\\n        return m[:i]\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, S: List[str]) -> str:\\n        if not S: return \\'\\'\\n        m, M, i = min(S), max(S), 0\\n        for i in range(min(len(m),len(M))):\\n            if m[i] != M[i]: break\\n        else: i += 1\\n        return m[:i]\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "codeTag": "Java"
            },
            {
                "id": 6940,
                "title": "java-we-love-clear-code",
                "content": "    public String longestCommonPrefix(String[] strs) {\\n        if (strs == null) return null;\\n        if (strs.length == 0) return \"\";\\n        \\n        Arrays.sort(strs);\\n        char[] first = strs[0].toCharArray();\\n        char[] last  = strs[strs.length - 1].toCharArray();\\n         \\n        int i = 0, len = Math.min(first.length, last.length);\\n        while (i < len && first[i] == last[i]) i++;\\n        return strs[0].substring(0, i);\\n    }",
                "solutionTags": [],
                "code": "    public String longestCommonPrefix(String[] strs) {\\n        if (strs == null) return null;\\n        if (strs.length == 0) return \"\";\\n        \\n        Arrays.sort(strs);\\n        char[] first = strs[0].toCharArray();\\n        char[] last  = strs[strs.length - 1].toCharArray();\\n         \\n        int i = 0, len = Math.min(first.length, last.length);\\n        while (i < len && first[i] == last[i]) i++;\\n        return strs[0].substring(0, i);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1309953,
                "title": "5-lines-js-solution-beats-99-62-of-js-solutions",
                "content": "The thing is with js we can sort strings and when we sort an array of different strings they will be sorted alphabetically, which means all we left to do is find the common part between the first and the last values in the sorted array. As simple as this:\\n```\\nvar longestCommonPrefix = function(strs) {\\n  strs.sort();\\n  for (let i = 0; i < strs[0].length; i++) {\\n    if (strs[0][i] !== strs[strs.length - 1][i]) return strs[0].substr(0, i);\\n  }\\n  return strs[0];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nvar longestCommonPrefix = function(strs) {\\n  strs.sort();\\n  for (let i = 0; i < strs[0].length; i++) {\\n    if (strs[0][i] !== strs[strs.length - 1][i]) return strs[0].substr(0, i);\\n  }\\n  return strs[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6926,
                "title": "accepted-c-6-lines-4ms",
                "content": "    class Solution {\\n    public:\\n        string longestCommonPrefix(vector<string>& strs) {\\n            string prefix = \"\";\\n            for(int idx=0; strs.size()>0; prefix+=strs[0][idx], idx++)\\n                for(int i=0; i<strs.size(); i++)\\n                    if(idx >= strs[i].size() ||(i > 0 && strs[i][idx] != strs[i-1][idx]))\\n                        return prefix;\\n            return prefix;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string longestCommonPrefix(vector<string>& strs) {\\n            string prefix = \"\";\\n            for(int idx=0; strs.size()>0; prefix+=strs[0][idx], idx++)\\n                for(int i=0; i<strs.size(); i++)\\n                    if(idx >= strs[i].size() ||(i > 0 && strs[i][idx] != strs[i-1][idx]))\\n                        return prefix;\\n            return prefix;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 120133,
                "title": "simple-javascript-solution",
                "content": "```js\\nfunction longestCommonPrefix(strs) {\\n  if (!strs.length) return \\'\\';\\n  \\n  for (let i = 0; i < strs[0].length; i++) {\\n    for (let str of strs) {\\n      if (str[i] !== strs[0][i]) {\\n        return str.slice(0, i);\\n      }\\n    }\\n  }\\n  \\n  return strs[0];\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction longestCommonPrefix(strs) {\\n  if (!strs.length) return \\'\\';\\n  \\n  for (let i = 0; i < strs[0].length; i++) {\\n    for (let str of strs) {\\n      if (str[i] !== strs[0][i]) {\\n        return str.slice(0, i);\\n      }\\n    }\\n  }\\n  \\n  return strs[0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2765214,
                "title": "python-prefix",
                "content": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        shortest = min(strs,key=len)\\n        for i, ch in enumerate(shortest):\\n            for other in strs:\\n                if other[i] != ch:\\n                    return shortest[:i]\\n        return shortest \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        shortest = min(strs,key=len)\\n        for i, ch in enumerate(shortest):\\n            for other in strs:\\n                if other[i] != ch:\\n                    return shortest[:i]\\n        return shortest \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683825,
                "title": "js-two-approaches-with-explanation-easy-to-understand",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/10/longest-common-prefix.html\\nIt is very useful, and I just wanted to share it with you.\\n\\n\\n\\n```\\nvar longestCommonPrefix = function (strs) {\\n    // Return early on empty input\\n    if (!strs.length) return \\'\\';\\n\\n    // Loop through the letters of the first word\\n    for (let i = 0; i <= strs[0].length; i++) {\\n        // Check if this character is present in the same position of every string\\n        if (!strs.every((string) => string[i] === strs[0][i])) {\\n            // If not, return the string up to and including the previous character\\n            return strs[0].slice(0, i);\\n        }\\n    }\\n\\n    return strs[0];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestCommonPrefix = function (strs) {\\n    // Return early on empty input\\n    if (!strs.length) return \\'\\';\\n\\n    // Loop through the letters of the first word\\n    for (let i = 0; i <= strs[0].length; i++) {\\n        // Check if this character is present in the same position of every string\\n        if (!strs.every((string) => string[i] === strs[0][i])) {\\n            // If not, return the string up to and including the previous character\\n            return strs[0].slice(0, i);\\n        }\\n    }\\n\\n    return strs[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 7139,
                "title": "my-1ms-java-solution",
                "content": "I have read many solutions but I just add couple of lines. I think finding the shortest string first can make the solution more effective.\\n\\n    public class Solution {\\n        public String longestCommonPrefix(String[] strs) {\\n            if (strs.length < 1 || strs == null) {\\n                return \"\";\\n            }\\n            if (strs.length == 1) {\\n                return strs[0];\\n            }\\n            //find the shortest String\\n            int shortest = 0;\\n            int len = strs[0].length();\\n            for (int i = 1; i < strs.length; i++) {\\n                int curLen = strs[i].length();\\n                if (curLen < len) {\\n                    len = curLen;\\n                    shortest = i;\\n                }\\n            }\\n            //find the longest common prefix\\n            String sub = strs[shortest];\\n            for (int i = 0; i < strs.length; i++) {\\n                while (strs[i].indexOf(sub) != 0) {\\n                    sub = sub.substring(0, sub.length()-1);\\n                }\\n            } \\n            return sub;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String longestCommonPrefix(String[] strs) {\\n            if (strs.length < 1 || strs == null) {\\n                return \"\";\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1621297,
                "title": "python-runtime-94-46-and-memory-81-95",
                "content": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n\\n        str1, str2 = min(strs), max(strs)\\n        i = 0\\n        while i < len(str1):\\n            if str1[i] != str2[i]:\\n                str1 = str1[:i]\\n            i +=1\\n\\n        return str1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n\\n        str1, str2 = min(strs), max(strs)\\n        i = 0\\n        while i < len(str1):\\n            if str1[i] != str2[i]:\\n                str1 = str1[:i]\\n            i +=1\\n\\n        return str1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339122,
                "title": "simple-c-soluton",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        string ans;\\n        for(int i=0;i<strs[0].size();i++)\\n        {\\n            for(int j=1;j<strs.size();j++)\\n            {\\n                if(strs[0][i] != strs[j][i])\\n                {\\n                    return ans;\\n                }\\n            }\\n            ans += strs[0][i];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Like the solution?\\nPlease upvote \\u30C4**\\n\\nIf you can\\'t understand any step/point, feel free to comment.\\nHappy to help.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        string ans;\\n        for(int i=0;i<strs[0].size();i++)\\n        {\\n            for(int j=1;j<strs.size();j++)\\n            {\\n                if(strs[0][i] != strs[j][i])\\n                {\\n                    return ans;\\n                }\\n            }\\n            ans += strs[0][i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7138,
                "title": "5-line-python-with-zip-and-len-set",
                "content": "Just for fun :)\\n\\n    class Solution(object):\\n        def longestCommonPrefix(self, strs):\\n            \"\"\"\\n            :type strs: List[str]; rtype: str\\n            \"\"\"\\n            sz, ret = zip(*strs), \"\"\\n            # looping corrected based on @StefanPochmann's comment below\\n            for c in sz:\\n                if len(set(c)) > 1: break\\n                ret += c[0]\\n            return ret",
                "solutionTags": [
                    "Python"
                ],
                "code": "Just for fun :)\\n\\n    class Solution(object):\\n        def longestCommonPrefix(self, strs):\\n            \"\"\"\\n            :type strs: List[str]; rtype: str\\n            \"\"\"\\n            sz, ret = zip(*strs), \"\"\\n            # looping corrected based on @StefanPochmann's comment below\\n            for c in sz:\\n                if len(set(c)) > 1: break\\n                ret += c[0]\\n            return ret",
                "codeTag": "Java"
            },
            {
                "id": 6946,
                "title": "fast-and-simple-java-code-231ms",
                "content": "    public class Solution {\\n        public String longestCommonPrefix(List<String> strs) {\\n            if(strs.size()==0) return \"\";\\n            StringBuilder lcp=new StringBuilder();\\n            for(int i=0;i<strs.get(0).length();i++){\\n                char c=strs.get(0).charAt(i);\\n                for(String s:strs){\\n                    if(s.length()<i+1||c!=s.charAt(i)) return lcp.toString();\\n                }\\n                lcp.append(c);\\n            }\\n            return lcp.toString();\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public String longestCommonPrefix(List<String> strs) {\\n            if(strs.size()==0) return \"\";\\n            StringBuilder lcp=new StringBuilder();\\n            for(int i=0;i<strs.get(0).length();i++){\\n                char c=strs.get(0).charAt(i);\\n                for(String s:strs){\\n                    if(s.length()<i+1||c!=s.charAt(i)) return lcp.toString();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3512602,
                "title": "c-java-python-javascript-fully-explained",
                "content": "# Intuition:\\nThe idea behind this solution is to start with the first string in the vector `strs` and consider it as the initial common prefix. Then, iterate through the remaining strings and continuously update the common prefix by removing characters from the end until the common prefix is found in the current string at the beginning. If the common prefix becomes empty at any point, it means there is no common prefix among the strings, so we return an empty string.\\n\\n# Approach:\\n1. Check if the vector `strs` is empty. If it is, there are no strings to compare, so we return an empty string.\\n2. Initialize a string variable `ans` with the first string in `strs`. This will be our initial common prefix.\\n3. Iterate through the remaining strings starting from the second string.\\n4. Inside the loop, use a while loop to check if the current string does not start with the current `ans`.\\n5. If the current string does not start with `ans`, remove the last character from `ans` by using the `substr` function and updating it to `ans.substr(0, ans.length() - 1)`.\\n6. Check if `ans` becomes empty after removing the character. If it does, it means there is no common prefix among the strings, so we return an empty string.\\n7. Repeat steps 4-6 until the current string starts with `ans`.\\n8. After the loop ends, the value of `ans` will be the longest common prefix among all the strings. Return `ans`.\\n\\n# Complexity:\\n- Time complexity: O(n), where n is the total number of characters in all the strings combined. This is because we iterate through each character of the strings to find the common prefix.\\n- Space complexity: O(1) because we are using a constant amount of space to store the common prefix (`ans`) and the loop variables.\\n\\n---\\n# C++\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if(strs.size()==0){\\n            return \"\";\\n        }\\n        string ans=strs[0];\\n        for(int i=1;i<strs.size();i++){\\n            while(strs[i].find(ans) != 0 ){\\n                cout<< ans.substr(0,ans.length() -1)<<endl;\\n                ans  = ans.substr(0,ans.length() -1);\\n                if(ans.empty()){\\n                    return \"\";\\n                }\\n            }   \\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n# JAVA\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if (strs.length == 0) {\\n            return \"\";\\n        }\\n        String ans = strs[0];\\n        for (int i = 1; i < strs.length; i++) {\\n            while (strs[i].indexOf(ans) != 0) {\\n                ans = ans.substring(0, ans.length() - 1);\\n                if (ans.isEmpty()) {\\n                    return \"\";\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n---\\n\\n# Python\\n```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        if len(strs) == 0:\\n            return \\'\\'\\n        ans = strs[0]\\n        for i in range(1, len(strs)):\\n            while ans != strs[i][:len(ans)]:\\n                ans = ans[:-1]\\n                if ans == \\'\\':\\n                    return \\'\\'\\n        return ans\\n\\n```\\n\\n---\\n# JavaScript\\n```\\nvar longestCommonPrefix = function(strs) {\\n    if (strs.length === 0) {\\n        return \\'\\';\\n    }\\n    let ans = strs[0];\\n    for (let i = 1; i < strs.length; i++) {\\n        while (strs[i].indexOf(ans) !== 0) {\\n            ans = ans.substring(0, ans.length - 1);\\n            if (ans === \\'\\') {\\n                return \\'\\';\\n            }\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if(strs.size()==0){\\n            return \"\";\\n        }\\n        string ans=strs[0];\\n        for(int i=1;i<strs.size();i++){\\n            while(strs[i].find(ans) != 0 ){\\n                cout<< ans.substr(0,ans.length() -1)<<endl;\\n                ans  = ans.substr(0,ans.length() -1);\\n                if(ans.empty()){\\n                    return \"\";\\n                }\\n            }   \\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if (strs.length == 0) {\\n            return \"\";\\n        }\\n        String ans = strs[0];\\n        for (int i = 1; i < strs.length; i++) {\\n            while (strs[i].indexOf(ans) != 0) {\\n                ans = ans.substring(0, ans.length() - 1);\\n                if (ans.isEmpty()) {\\n                    return \"\";\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        if len(strs) == 0:\\n            return \\'\\'\\n        ans = strs[0]\\n        for i in range(1, len(strs)):\\n            while ans != strs[i][:len(ans)]:\\n                ans = ans[:-1]\\n                if ans == \\'\\':\\n                    return \\'\\'\\n        return ans\\n\\n```\n```\\nvar longestCommonPrefix = function(strs) {\\n    if (strs.length === 0) {\\n        return \\'\\';\\n    }\\n    let ans = strs[0];\\n    for (let i = 1; i < strs.length; i++) {\\n        while (strs[i].indexOf(ans) !== 0) {\\n            ans = ans.substring(0, ans.length - 1);\\n            if (ans === \\'\\') {\\n                return \\'\\';\\n            }\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1869031,
                "title": "c-0ms",
                "content": "\\tchar *longestCommonPrefix(char **strs, int strsSize)\\n\\t{\\n\\t\\tfor(int c=0;; ++c)\\n\\t\\t{\\n\\t\\t\\tif(strs[0][c] == \\'\\\\0\\') // the longest common prefix is the first string\\n\\t\\t\\t\\treturn strs[0];\\n\\t\\t\\tfor(int s=1; s<strsSize; ++s)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(strs[s][c] != strs[0][c]) // compare all strings character to the first one\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstrs[0][c] = \\'\\\\0\\'; // replace the current character with \\'\\\\0\\'\\n\\t\\t\\t\\t\\treturn strs[0];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tchar *longestCommonPrefix(char **strs, int strsSize)\\n\\t{\\n\\t\\tfor(int c=0;; ++c)\\n\\t\\t{\\n\\t\\t\\tif(strs[0][c] == \\'\\\\0\\') // the longest common prefix is the first string\\n\\t\\t\\t\\treturn strs[0];\\n\\t\\t\\tfor(int s=1; s<strsSize; ++s)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(strs[s][c] != strs[0][c]) // compare all strings character to the first one\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstrs[0][c] = \\'\\\\0\\'; // replace the current character with \\'\\\\0\\'\\n\\t\\t\\t\\t\\treturn strs[0];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 221978,
                "title": "javascript",
                "content": "```\\nvar longestCommonPrefix = function(strs) {\\n  if (strs.length === 0) return \\'\\';\\n  let r = \\'\\';\\n  for (let i = 0; i < strs[0].length; i++) {\\n    for (let j = 1; j < strs.length; j++) {\\n      if (strs[0][i] !== strs[j][i]) return r;\\n    }\\n    r += strs[0][i];\\n  }\\n  return r;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar longestCommonPrefix = function(strs) {\\n  if (strs.length === 0) return \\'\\';\\n  let r = \\'\\';\\n  for (let i = 0; i < strs[0].length; i++) {\\n    for (let j = 1; j < strs.length; j++) {\\n      if (strs[0][i] !== strs[j][i]) return r;\\n    }\\n    r += strs[0][i];\\n  }\\n  return r;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2869179,
                "title": "python-99-faster-easy-solution",
                "content": "# Code\\u2705\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str: #// strs = [\"flower\",\"flow\",\"flight\"]\\n        short = min(strs, key=len) #// short = \"flow\"\\n        for item in strs: #// When item = \"flight\"\\n            while len(short) > 0:\\n                if item.startswith(short): #// during loop 1 condition fails, during loop 2 condition fails, during loop 3 \"flight\" startswith fl is True\\n                    break\\n                else:\\n                    short = short[:-1] #// during loop 1 short = flo, during loop 2 short = fl\\n        return short\\n```\\n![leet.png](https://assets.leetcode.com/users/images/957926b9-2e91-4aca-bda2-0c413ba34ea2_1669969069.6613681.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str: #// strs = [\"flower\",\"flow\",\"flight\"]\\n        short = min(strs, key=len) #// short = \"flow\"\\n        for item in strs: #// When item = \"flight\"\\n            while len(short) > 0:\\n                if item.startswith(short): #// during loop 1 condition fails, during loop 2 condition fails, during loop 3 \"flight\" startswith fl is True\\n                    break\\n                else:\\n                    short = short[:-1] #// during loop 1 short = flo, during loop 2 short = fl\\n        return short\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763488,
                "title": "rust-0ms-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Rust online submissions for Longest Common Prefix.\\nMemory Usage: 2.2 MB, less than 60.00% of Rust online submissions for Longest Common Prefix.\\n```\\nimpl Solution {\\n    pub fn longest_common_prefix(strs: Vec<String>) -> String { \\n        match strs.is_empty() {\\n            true => \"\".to_string(),\\n            _ => {\\n                strs.iter().skip(1).fold(strs[0].clone(), |acc, x| {\\n                     acc\\n                        .chars()\\n                        .zip(x.chars())\\n                        .take_while(|(x,y)| x == y)\\n                        .map(|(x, _)| x)\\n                        .collect()\\n                })\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn longest_common_prefix(strs: Vec<String>) -> String { \\n        match strs.is_empty() {\\n            true => \"\".to_string(),\\n            _ => {\\n                strs.iter().skip(1).fold(strs[0].clone(), |acc, x| {\\n                     acc\\n                        .chars()\\n                        .zip(x.chars())\\n                        .take_while(|(x,y)| x == y)\\n                        .map(|(x, _)| x)\\n                        .collect()\\n                })\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 801411,
                "title": "javascript-clean-solution",
                "content": "```javascript\\nvar longestCommonPrefix = function(strs) {\\n    if(!strs.length) return \\'\\';\\n    \\n    for(let i = 0; i < strs[0].length; i++) {\\n        for(let s of strs) {\\n            if(s[i] !== strs[0][i]) return s.slice(0, i);\\n        }\\n    }\\n    return strs[0];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar longestCommonPrefix = function(strs) {\\n    if(!strs.length) return \\'\\';\\n    \\n    for(let i = 0; i < strs[0].length; i++) {\\n        for(let s of strs) {\\n            if(s[i] !== strs[0][i]) return s.slice(0, i);\\n        }\\n    }\\n    return strs[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 798212,
                "title": "fastest-python-solution-longest-common-prefix",
                "content": "\\n```\\nstr=[\"flower\",\"flow\",\"flight\"]\\n\\nafter zip(*strs)\\n\\n[(\\'f\\', \\'f\\', \\'f\\'), (\\'l\\', \\'l\\', \\'l\\'), (\\'o\\', \\'o\\', \\'i\\'), (\\'w\\', \\'w\\', \\'g\\')]\\n\\ntaken first set\\n\\nlen(set( \"f\",\"f\",\"f\"))=1\\n\\nand taken 3\\nlen(set(\"o\",\"o\",\"i\"))=2\\n\\n```\\n\\n```\\n\\nprefix=[]\\n        num = len(strs)\\n        for x in zip(*strs):\\n            if len(set(x)) == 1:\\n                prefix.append(x[0])\\n            else:\\n                break\\n        return \"\".join(prefix) \\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nstr=[\"flower\",\"flow\",\"flight\"]\\n\\nafter zip(*strs)\\n\\n[(\\'f\\', \\'f\\', \\'f\\'), (\\'l\\', \\'l\\', \\'l\\'), (\\'o\\', \\'o\\', \\'i\\'), (\\'w\\', \\'w\\', \\'g\\')]\\n\\ntaken first set\\n\\nlen(set( \"f\",\"f\",\"f\"))=1\\n\\nand taken 3\\nlen(set(\"o\",\"o\",\"i\"))=2\\n\\n```\n```\\n\\nprefix=[]\\n        num = len(strs)\\n        for x in zip(*strs):\\n            if len(set(x)) == 1:\\n                prefix.append(x[0])\\n            else:\\n                break\\n        return \"\".join(prefix) \\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 323909,
                "title": "python-simple-solution-implementing-vertical-scanning",
                "content": "```python\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        result = []\\n\\t\\t# Create one iterator per string using zip, it will stop at the shortest string\\n\\t\\t# s is a tuple of characters at current position for each string\\n\\t\\t# create a set to test unicity\\n        for s in zip(*strs):\\n            if len(set(s)) != 1:\\n                break\\n            result.append(s[0])\\n        return \"\".join(result)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        result = []\\n\\t\\t# Create one iterator per string using zip, it will stop at the shortest string\\n\\t\\t# s is a tuple of characters at current position for each string\\n\\t\\t# create a set to test unicity\\n        for s in zip(*strs):\\n            if len(set(s)) != 1:\\n                break\\n            result.append(s[0])\\n        return \"\".join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244957,
                "title": "idiomatic-and-elegant-rust-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn longest_common_prefix(input: Vec<String>) -> String {\\n        input.into_iter().reduce(|acc,cur|{\\n            acc.chars()\\n               .zip(cur.chars())\\n               .take_while(|(a,c)| a== c)\\n               .map(|(c,_)|c)\\n               .collect()\\n        }).unwrap()\\n    }\\n}\\n```\\n\\n# Intuition\\nThe longest common prefix (LCP) between `input[i+1]` and `input[i+2]` will always be as short or shorter than between `input[i]` and `input[i+1]`.\\nThis means this problem (taking as example input `[\"flight\",\"flow\",\"flip\"]`) can be solved like: `LCP(\"flat\",LCP(\"flip\",LCP(\"flow\", \"flight\")))`. \\nThe recursive call of an operation on the previous result of that operation is a classic example of [Iterator::reduce](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.reduce)\\n\\n# Approach\\n1. Apply reduce on the input\\n2. `acc` starts out as the first string in input.\\n3. `cur` starts out as the second string, and will become each string as we iterate through the input\\n4. zip `acc` and `cur`. This will create an iterator over tuples representing pairs of `acc[i]`, `cur[i]`. It will clip the longest one to the size of the shortest.\\n5. take as many chars as possible while they are equal in each zipped string\\n6. forget about one element of the tuple, in order to have an iterator over `char`\\n7. `collect` it into a `String` and return it from the closure. This will be `acc` argument in the next iteration\\n8. after the iteration, the final `acc` value will be returned. `unwrap` is necessary because `reduce` returns an `Option`\\n# Complexity\\n- Time complexity:\\n**O(n*s)**, where s is the shortest LCP so far.\\n- Space complexity:\\n**O(1)**\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn longest_common_prefix(input: Vec<String>) -> String {\\n        input.into_iter().reduce(|acc,cur|{\\n            acc.chars()\\n               .zip(cur.chars())\\n               .take_while(|(a,c)| a== c)\\n               .map(|(c,_)|c)\\n               .collect()\\n        }).unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1517792,
                "title": "simple-go-solution",
                "content": "```\\nfunc longestCommonPrefix(strs []string) string {\\n    p := strs[0]\\n    for _, s := range strs {\\n        i := 0\\n        for ; i < len(s) && i < len(p) && p[i] == s[i]; i++ {}\\n        p = p[:i]\\n    }\\n    return p\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc longestCommonPrefix(strs []string) string {\\n    p := strs[0]\\n    for _, s := range strs {\\n        i := 0\\n        for ; i < len(s) && i < len(p) && p[i] == s[i]; i++ {}\\n        p = p[:i]\\n    }\\n    return p\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3160852,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n\\n\\n# Approach\\nSimple solution using startsWith JavaScript method\\n\\n# Complexity\\n- Time complexity: 60ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 41.8MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(arr) {\\n    let i = 1;\\n    let prf = arr[0];\\n    while(i < arr.length){\\n        if(!arr[i].startsWith(prf)){\\n            prf = prf.slice(0, -1)\\n        }else{\\n            i++\\n        }\\n    }\\n    return prf\\n\\n\\n};\\n\\n// \"\"\\n//\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(arr) {\\n    let i = 1;\\n    let prf = arr[0];\\n    while(i < arr.length){\\n        if(!arr[i].startsWith(prf)){\\n            prf = prf.slice(0, -1)\\n        }else{\\n            i++\\n        }\\n    }\\n    return prf\\n\\n\\n};\\n\\n// \"\"\\n//\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1422342,
                "title": "python-easy-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef longestCommonPrefix(self, lst: List[str]) -> str:\\n\\t\\t\\tans = \"\"\\n\\t\\t\\tfor i in zip(*lst):\\n\\t\\t\\t\\tp = \"\".join(i)\\n\\t\\t\\t\\tif len(set(p)) != 1:\\n\\t\\t\\t\\t\\treturn (ans)\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tans += p[0]\\n\\n\\t\\t\\treturn (ans)\\n\\t\\t\\t\\n# if you like the solution, Please upvote!!\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef longestCommonPrefix(self, lst: List[str]) -> str:\\n\\t\\t\\tans = \"\"\\n\\t\\t\\tfor i in zip(*lst):\\n\\t\\t\\t\\tp = \"\".join(i)\\n\\t\\t\\t\\tif len(set(p)) != 1:\\n\\t\\t\\t\\t\\treturn (ans)\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tans += p[0]\\n\\n\\t\\t\\treturn (ans)\\n\\t\\t\\t\\n# if you like the solution, Please upvote!!\\n",
                "codeTag": "Java"
            },
            {
                "id": 1336046,
                "title": "python-horizontal-scanning",
                "content": "I got this question in an interview recently. I solved it using the most voted Python approach. [Link](https://leetcode.com/problems/longest-common-prefix/discuss/6918/Short-Python-Solution)\\nHowever, the interviewer told me that this solution isn\\'t the most optimized because it checks each character once if the two words aren\\'t the same. I told him I can whip a Trie solution, and he said that is an overkill. Finally, I came up with this solution which is scanning it horizontally. Hope it can help someone else out there. \\n\\n```\\nclass Solution: \\n\\tdef longestCommonPrefix(self, words: List[str]) -> str: \\n\\t\\tprefix = words[0]\\n\\t\\tfor word in words[1:]: \\n\\t\\t\\t# keep looping and current word sliced to len of prefix == prefix\\n\\t\\t\\twhile word[:len(prefix)] != prefix: \\n\\t\\t\\t\\tprefix = prefix[:-1]\\n\\t\\t\\t\\t# Covers edge case: if two words don\\'t have any similar characters\\n\\t\\t\\t\\tif not prefix: \\n\\t\\t\\t\\t\\treturn \"\"\\n\\t\\treturn prefix",
                "solutionTags": [
                    "Python"
                ],
                "code": "I got this question in an interview recently. I solved it using the most voted Python approach. [Link](https://leetcode.com/problems/longest-common-prefix/discuss/6918/Short-Python-Solution)\\nHowever, the interviewer told me that this solution isn\\'t the most optimized because it checks each character once if the two words aren\\'t the same. I told him I can whip a Trie solution, and he said that is an overkill. Finally, I came up with this solution which is scanning it horizontally. Hope it can help someone else out there. \\n\\n```\\nclass Solution: \\n\\tdef longestCommonPrefix(self, words: List[str]) -> str: \\n\\t\\tprefix = words[0]\\n\\t\\tfor word in words[1:]: \\n\\t\\t\\t# keep looping and current word sliced to len of prefix == prefix\\n\\t\\t\\twhile word[:len(prefix)] != prefix: \\n\\t\\t\\t\\tprefix = prefix[:-1]\\n\\t\\t\\t\\t# Covers edge case: if two words don\\'t have any similar characters\\n\\t\\t\\t\\tif not prefix: \\n\\t\\t\\t\\t\\treturn \"\"\\n\\t\\treturn prefix",
                "codeTag": "Java"
            },
            {
                "id": 3168831,
                "title": "python-80-simple-find-max-and-min-words",
                "content": "# Approach\\nImagine that all the words are ordered. Similar words will be next to each other (because of the lexicographic order). Then we need to compare the prefixes of the first and last word. So we need the maximum and minimum word.\\n\\nSee comments in the code.\\n\\n\\uD83D\\uDC49 [Explanation with an example in the comments](https://leetcode.com/problems/longest-common-prefix/solutions/3168831/python-80-simple-find-max-and-min-words/comments/1804509)\\n\\n**\\u2764\\uFE0F Please upvote if you liked this approach**\\n\\n# Complexity\\n- Time complexity: $$O(max(n, min(len(minWord), len(maxWord))))$$\\n\\nFinding max and min word: $$O(n)$$\\nLoop with i < N: $$O(min(len(minWord), len(maxWord)))$$\\nThus, we have to take the max from them.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        # this will be an answer\\n        pref = \\'\\'        \\n        # find min and max words among strs\\n        minWord = min(strs)\\n        maxWord = max(strs)\\n\\n        # for iteration\\n        i = 0\\n        N = min(len(minWord), len(maxWord))\\n        \\n        while i < N:\\n            # if chars are equal\\n            if minWord[i] == maxWord[i]:\\n                # add this char to the answer\\n                pref += minWord[i]\\n            else:\\n                # if not, break\\n                break\\n            i += 1\\n\\n        return pref\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        # this will be an answer\\n        pref = \\'\\'        \\n        # find min and max words among strs\\n        minWord = min(strs)\\n        maxWord = max(strs)\\n\\n        # for iteration\\n        i = 0\\n        N = min(len(minWord), len(maxWord))\\n        \\n        while i < N:\\n            # if chars are equal\\n            if minWord[i] == maxWord[i]:\\n                # add this char to the answer\\n                pref += minWord[i]\\n            else:\\n                # if not, break\\n                break\\n            i += 1\\n\\n        return pref\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 204779,
                "title": "python-trie-clean-implementation",
                "content": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.end = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def add_word(self, word):\\n        cur = self.root\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n        cur.end = True\\n    \\n    def longest_prefix(self):\\n        res = []\\n        cur = self.root\\n        while cur:\\n            # return when reaches the end of word or when there are more than 1 branches\\n            if cur.end or len(cur.children) > 1:\\n                return \\'\\'.join(res)\\n            c = list(cur.children)[0]\\n            res.append(c)\\n            cur = cur.children[c]\\n        return \\'\\'.join(res)\\n        \\nclass Solution:\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        if not strs:\\n            return \\'\\'\\n        T = Trie()\\n        for s in strs:\\n            T.add_word(s)\\n        return T.longest_prefix()\\n```\\n\\nTime complexity:\\n- building Trie: O(N\\\\*len(s)) where N = len(strs) and s is the longest word in strs\\n- finding longest prefix: O(M) where M is the length of LCP (which is in the range of 0 and the length of shortest string)",
                "solutionTags": [],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.end = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def add_word(self, word):\\n        cur = self.root\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n        cur.end = True\\n    \\n    def longest_prefix(self):\\n        res = []\\n        cur = self.root\\n        while cur:\\n            # return when reaches the end of word or when there are more than 1 branches\\n            if cur.end or len(cur.children) > 1:\\n                return \\'\\'.join(res)\\n            c = list(cur.children)[0]\\n            res.append(c)\\n            cur = cur.children[c]\\n        return \\'\\'.join(res)\\n        \\nclass Solution:\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        if not strs:\\n            return \\'\\'\\n        T = Trie()\\n        for s in strs:\\n            T.add_word(s)\\n        return T.longest_prefix()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087422,
                "title": "python-brilliant-approach-taught-by-my-bf-xd",
                "content": "# Intuition\\n**EDIT** - Earlier I used sorting, which took O(M * NLOGN) complexity.Instead we can use min() and max() , which takes O(N*M) time.complexity. (N is no.of elements in the array and M is size of the string)\\n\\nIf you sort the given array (lexicographically), the **first** and **last** word will be the least similar (i.e, they vary the most)\\n- It is enough if you find the common prefix between the **first** and **last** word ( need not consider other words in the array )\\n\\n**Example:** arr = [\"aad\",\"aaf\", \"aaaa\", \"af\"]\\n1) Sorted arr is [\"aaaa\", \"aad\", \"aaf\", \"af\"]\\n2) *first* = \"aaaa\", *last* = \"af\"\\n3) Common prefix of *first* and *last* is ans = \"a\"\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) **Sort** the given array\\n2) Take the **first** and **last** word of the array\\n3) Find the common **prefix** of the first and last word\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*M) - since use min() and max() in python, where N is no.of elements in the array and M is size of the string\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) -  no extra space is used\\n\\n# Code\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        first, last = min(strs), max(strs)\\n        prefix = \\'\\'\\n        for ind in range(min(len(first), len(last))):\\n            if first[ind] != last[ind]:\\n                break\\n            prefix += first[ind]\\n\\n        return prefix\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        first, last = min(strs), max(strs)\\n        prefix = \\'\\'\\n        for ind in range(min(len(first), len(last))):\\n            if first[ind] != last[ind]:\\n                break\\n            prefix += first[ind]\\n\\n        return prefix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981733,
                "title": "concise-and-easy-solutions-with-trivial-linq",
                "content": "1. Get the shortest word\\n2. Make sure that each of its characters can be found in every other word in the same place.\\n  a. If not, return what you have checked so far.\\n  b. If yes, go on.\\n\\nShort solution:\\n```csharp\\npublic class Solution\\n{\\n    public string LongestCommonPrefix(string[] ss)\\n    {\\n        string shortest = ss.OrderBy(s => s.Length).First();\\n\\n        for (int i = 0; i < shortest.Length; i++)\\n        {\\n            if (ss.Select(s => s[i]).Distinct().Count() > 1) return shortest[..i];\\n        }\\n\\n        return shortest;\\n    }\\n}\\n```\\n\\nAnother one, with `StringBuilder`:\\n```csharp\\npublic class Solution\\n{\\n    public string LongestCommonPrefix(string[] ss)\\n    {\\n        int i = 0;\\n        StringBuilder sb = new();\\n        string shortest = ss.OrderBy(s => s.Length).First();\\n\\n        foreach (char c in shortest)\\n        {\\n            if (ss.Any(s => s[i] != c)) break;\\n            sb.Append(c);\\n            i++;\\n        }\\n\\n        return sb.ToString();\\n    }\\n}\\n```\\n\\nWe can get rid of the explicit declaration of `i` by using LINQ/tuples:\\n```csharp\\npublic class Solution\\n{\\n    public string LongestCommonPrefix(string[] ss)\\n    {\\n        StringBuilder sb = new();\\n        string shortest = ss.OrderBy(s => s.Length).First();\\n\\n        foreach (var (c, i) in shortest.Select((c, i) => (c, i)))\\n        {\\n            if (ss.Any(s => s[i] != c)) break;\\n            sb.Append(c);\\n        }\\n\\n        return sb.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public string LongestCommonPrefix(string[] ss)\\n    {\\n        string shortest = ss.OrderBy(s => s.Length).First();\\n\\n        for (int i = 0; i < shortest.Length; i++)\\n        {\\n            if (ss.Select(s => s[i]).Distinct().Count() > 1) return shortest[..i];\\n        }\\n\\n        return shortest;\\n    }\\n}\\n```\n```csharp\\npublic class Solution\\n{\\n    public string LongestCommonPrefix(string[] ss)\\n    {\\n        int i = 0;\\n        StringBuilder sb = new();\\n        string shortest = ss.OrderBy(s => s.Length).First();\\n\\n        foreach (char c in shortest)\\n        {\\n            if (ss.Any(s => s[i] != c)) break;\\n            sb.Append(c);\\n            i++;\\n        }\\n\\n        return sb.ToString();\\n    }\\n}\\n```\n```csharp\\npublic class Solution\\n{\\n    public string LongestCommonPrefix(string[] ss)\\n    {\\n        StringBuilder sb = new();\\n        string shortest = ss.OrderBy(s => s.Length).First();\\n\\n        foreach (var (c, i) in shortest.Select((c, i) => (c, i)))\\n        {\\n            if (ss.Any(s => s[i] != c)) break;\\n            sb.Append(c);\\n        }\\n\\n        return sb.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 292303,
                "title": "c-straightforward",
                "content": "```\\npublic class Solution {\\n    public string LongestCommonPrefix(string[] strs) {\\n        if (strs.Length == 0 || Array.IndexOf(strs, \"\") != -1)\\n            return \"\";\\n        string res = strs[0];\\n        int i = res.Length;\\n        foreach (string word in strs) {\\n            int j = 0;\\n            foreach (char c in word) {\\n                if (j >= i || res[j] != c)\\n                    break;\\n                j += 1;\\n            }\\n            i = Math.Min(i, j);\\n        }\\n        return res.Substring(0, i);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string LongestCommonPrefix(string[] strs) {\\n        if (strs.Length == 0 || Array.IndexOf(strs, \"\") != -1)\\n            return \"\";\\n        string res = strs[0];\\n        int i = res.Length;\\n        foreach (string word in strs) {\\n            int j = 0;\\n            foreach (char c in word) {\\n                if (j >= i || res[j] != c)\\n                    break;\\n                j += 1;\\n            }\\n            i = Math.Min(i, j);\\n        }\\n        return res.Substring(0, i);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291991,
                "title": "using-simple-str-sort-method-5-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfind the min length str and or write in the sorting \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst we use str.sort method becuse its sorting by alphabetical order\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nsort method Time Colplexity \\nO(nlog(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1);\\n\\n# Code\\n```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n    // sort the array because its rearrange alphabetical order\\n   strs.sort();\\n\\n\\n  for (let i = 0; i < strs[0].length; i++) {\\n    if (strs[0][i] !== strs[strs.length - 1][i]){\\nreturn strs[0].substr(0, i);\\n    } \\n  }\\n\\n  return strs[0];  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n    // sort the array because its rearrange alphabetical order\\n   strs.sort();\\n\\n\\n  for (let i = 0; i < strs[0].length; i++) {\\n    if (strs[0][i] !== strs[strs.length - 1][i]){\\nreturn strs[0].substr(0, i);\\n    } \\n  }\\n\\n  return strs[0];  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2516139,
                "title": "simple-python-solution-with-zip-and-set",
                "content": "`zip(*strs)` Iterate over all words in parallel, producing tuples with an letter from each one.  It will stop iteration on the shortest word. \\n\\n```\\n>>> list(zip(*[\"flower\",\"flow\",\"flight\"]))\\n[\\n(\\'f\\', \\'f\\', \\'f\\'),\\n(\\'l\\', \\'l\\', \\'l\\'),\\n(\\'o\\', \\'o\\', \\'i\\'), \\n(\\'w\\', \\'w\\', \\'g\\')\\n]\\n```\\n\\n\\n```python\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        match = 0\\n        \\n        for vals in zip(*strs):\\n            if len(set(vals)) == 1:\\n                match += 1\\n            else:\\n                break\\n        \\n        return strs[0][:match]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n>>> list(zip(*[\"flower\",\"flow\",\"flight\"]))\\n[\\n(\\'f\\', \\'f\\', \\'f\\'),\\n(\\'l\\', \\'l\\', \\'l\\'),\\n(\\'o\\', \\'o\\', \\'i\\'), \\n(\\'w\\', \\'w\\', \\'g\\')\\n]\\n```\n```python\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        match = 0\\n        \\n        for vals in zip(*strs):\\n            if len(set(vals)) == 1:\\n                match += 1\\n            else:\\n                break\\n        \\n        return strs[0][:match]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 587345,
                "title": "c-easy-solution-4ms",
                "content": "```\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string ans=\"\";\\n        int n=strs.size();\\n        if(n==0)\\n            return ans;\\n        int l=strs[0].length();\\n        for(string s:strs)\\n            if(l>s.length())\\n                l=s.length();\\n        int index=0;\\n        for(char c:strs[0])\\n        {\\n            for(int i=1;i<n;i++)\\n            {\\n                if(strs[i][index]!=c||index>l)\\n                    return ans;\\n            }\\n            ans+=c;\\n            index++;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string ans=\"\";\\n        int n=strs.size();\\n        if(n==0)\\n            return ans;\\n        int l=strs[0].length();\\n        for(string s:strs)\\n            if(l>s.length())\\n                l=s.length();\\n        int index=0;\\n        for(char c:strs[0])\\n        {\\n            for(int i=1;i<n;i++)\\n            {\\n                if(strs[i][index]!=c||index>l)\\n                    return ans;\\n            }\\n            ans+=c;\\n            index++;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 561757,
                "title": "c-memory-and-runtime-efficient-2-solutions-1-greedy-1-trie-implementation",
                "content": "**Greedy**\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if(strs.size() == 0) return \"\";\\n        if(strs.size() == 1) return strs[0];\\n        \\n        int small = INT_MAX;\\n        bool flag = true;\\n        string retStr;\\n        \\n        for(auto str : strs) if(str.length() < small) small = str.length();\\n        \\n        while(small != 0){\\n            flag = true;\\n            for(int i = 0; i < strs.size() - 1; i++){\\n                if(strs[i].substr(0, small) != strs[i + 1].substr(0, small)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                return strs[0].substr(0, small);\\n            }\\n            small--;\\n        }\\n        \\n        return retStr; \\n    }\\n};\\n```\\n\\n**Trie Implementation**\\n```\\nclass TrieNode{\\npublic:\\n    unordered_map<char, TrieNode*> children;\\n    char val;\\n    bool isWord = false;\\n    \\n    TrieNode(){}\\n    \\n    TrieNode(char v){\\n        this->val = v;\\n    }\\n};\\n\\nclass Trie {\\nprivate:\\n    TrieNode* root;\\n    \\npublic:\\n    /** Initialize your data structure here. */\\n    Trie() {\\n        root = new TrieNode();\\n    }\\n    \\n    /* Get TrieNode. */\\n    TrieNode* getTrieNode(){\\n        return root;\\n    }\\n    \\n    /** Inserts a word into the trie. */\\n    void insert(string word) {\\n        TrieNode* temp = root;\\n        \\n        for(auto ch : word){\\n            if(temp->children.find(ch) == temp->children.end()){\\n                temp->children[ch] = new TrieNode(ch);\\n            }     \\n            temp = temp->children[ch];\\n        }\\n        \\n        temp->isWord = true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        // insert all keys into trie\\n        Trie* pTrie = new Trie();\\n        \\n        for (string str : strs) { pTrie->insert(str); }\\n\\n        // Traverse the trie and find Longest Common Prefix\\n        string lcp(\"\");\\n        TrieNode* curr = pTrie->getTrieNode();\\n\\n        // Do till we find a leaf node or node has more than 1 children\\n        while (curr && !curr->isWord && (curr->children.size() == 1))\\n        {\\n            auto it = curr->children.begin();\\n            lcp += it->first;\\n            curr = it->second;\\n        }\\n\\n        return lcp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if(strs.size() == 0) return \"\";\\n        if(strs.size() == 1) return strs[0];\\n        \\n        int small = INT_MAX;\\n        bool flag = true;\\n        string retStr;\\n        \\n        for(auto str : strs) if(str.length() < small) small = str.length();\\n        \\n        while(small != 0){\\n            flag = true;\\n            for(int i = 0; i < strs.size() - 1; i++){\\n                if(strs[i].substr(0, small) != strs[i + 1].substr(0, small)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                return strs[0].substr(0, small);\\n            }\\n            small--;\\n        }\\n        \\n        return retStr; \\n    }\\n};\\n```\n```\\nclass TrieNode{\\npublic:\\n    unordered_map<char, TrieNode*> children;\\n    char val;\\n    bool isWord = false;\\n    \\n    TrieNode(){}\\n    \\n    TrieNode(char v){\\n        this->val = v;\\n    }\\n};\\n\\nclass Trie {\\nprivate:\\n    TrieNode* root;\\n    \\npublic:\\n    /** Initialize your data structure here. */\\n    Trie() {\\n        root = new TrieNode();\\n    }\\n    \\n    /* Get TrieNode. */\\n    TrieNode* getTrieNode(){\\n        return root;\\n    }\\n    \\n    /** Inserts a word into the trie. */\\n    void insert(string word) {\\n        TrieNode* temp = root;\\n        \\n        for(auto ch : word){\\n            if(temp->children.find(ch) == temp->children.end()){\\n                temp->children[ch] = new TrieNode(ch);\\n            }     \\n            temp = temp->children[ch];\\n        }\\n        \\n        temp->isWord = true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        // insert all keys into trie\\n        Trie* pTrie = new Trie();\\n        \\n        for (string str : strs) { pTrie->insert(str); }\\n\\n        // Traverse the trie and find Longest Common Prefix\\n        string lcp(\"\");\\n        TrieNode* curr = pTrie->getTrieNode();\\n\\n        // Do till we find a leaf node or node has more than 1 children\\n        while (curr && !curr->isWord && (curr->children.size() == 1))\\n        {\\n            auto it = curr->children.begin();\\n            lcp += it->first;\\n            curr = it->second;\\n        }\\n\\n        return lcp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 397075,
                "title": "java-o-n-log-n",
                "content": "// 1) sort the array. this way if you have [\"hall\", \"hallow\", \"hat\"]\\n// it would sort it so that hat is first and hallow is last\\n// 2) Compare only first and last element. Because the longest posssible prefix will\\n// be at the end and the shorest possible prefix will be in the begining\\n// 3) convert first and last element to char array\\n// 4) loop through first elemnt comparing each value to last element value\\n// 5)Make sure that when looping you do not go-out-of-bounds for the last element\\n// 6) if it is equal then append it to a string builder\\n// if it is not equal immediately return the result\\n\\n```\\nimport  java.util.*;\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if (strs == null || strs.length == 0) {\\n            return \"\";\\n        }\\n        // 1) string builder\\n        StringBuilder result = new StringBuilder();\\n        \\n        // Sort array\\n        Arrays.sort(strs);\\n        \\n        // split first and last to char\\n        char[] first = strs[0].toCharArray();\\n        char[] last = strs[strs.length - 1 ].toCharArray();\\n        \\n        // loop through\\n        for (int i = 0; i < first.length && i < last.length; i++) {\\n            if (first[i] == last[i]) {\\n                result.append(first[i]);                \\n            }\\n            else\\n                return result.toString();\\n        }\\n        return result.toString();\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport  java.util.*;\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if (strs == null || strs.length == 0) {\\n            return \"\";\\n        }\\n        // 1) string builder\\n        StringBuilder result = new StringBuilder();\\n        \\n        // Sort array\\n        Arrays.sort(strs);\\n        \\n        // split first and last to char\\n        char[] first = strs[0].toCharArray();\\n        char[] last = strs[strs.length - 1 ].toCharArray();\\n        \\n        // loop through\\n        for (int i = 0; i < first.length && i < last.length; i++) {\\n            if (first[i] == last[i]) {\\n                result.append(first[i]);                \\n            }\\n            else\\n                return result.toString();\\n        }\\n        return result.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 833959,
                "title": "javascript-solution-14",
                "content": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nlet longestCommonPrefix = function(strs) {\\n        if(!strs.length) {\\n            return \\'\\';\\n        }\\n        for(let i = 0; i < strs[0].length; i++) {\\n            for(let s of strs) {\\n                if(s[i] !== strs[0][i]) {\\n                    return s.slice(0, i);\\n                }\\n            }\\n        }\\n        return strs[0];\\n    };\\n```\\n**Runtime: 80 ms, faster than 75.49% of JavaScript online submissions for Longest Common Prefix.**\\n\\n**Memory Usage: 39.2 MB, less than 10.70% of JavaScript online submissions for Longest Common Prefix.**\\n\\n**Feedback Appreciated**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nlet longestCommonPrefix = function(strs) {\\n        if(!strs.length) {\\n            return \\'\\';\\n        }\\n        for(let i = 0; i < strs[0].length; i++) {\\n            for(let s of strs) {\\n                if(s[i] !== strs[0][i]) {\\n                    return s.slice(0, i);\\n                }\\n            }\\n        }\\n        return strs[0];\\n    };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3405496,
                "title": "python-code-explained-with-approach-and-time-complexity",
                "content": "Intuition:\\nThe problem requires finding the longest common prefix among a list of strings. The approach is to assume that the prefix is the shortest string in the list and then compare it with all the other strings. The length of the prefix is then reduced by one character at a time until a match is found or the prefix becomes empty.\\n\\nApproach:\\n\\nIf the input list is empty, return an empty string.\\nAssume that the prefix is the shortest string in the list.\\nIterate over all the other strings in the list and compare them with the prefix.\\nIf a match is found, continue to the next string in the list.\\nIf a match is not found, reduce the length of the prefix by one character at a time until a match is found or the prefix becomes empty.\\nIf the prefix becomes empty, return an empty string.\\nIf all strings match the prefix, return the prefix.\\n\\nTime complexity:\\nThe time complexity of the given implementation is O(nm), where n is the number of strings in the input list and m is the length of the shortest string. This is because the algorithm iterates over all the strings in the list once, and for each string, it may reduce the length of the prefix by up to m characters. The min() function used to find the shortest string in the list has a time complexity of O(nm), where n is the number of strings in the list and m is the length of the longest string.\\n\\nSpace complexity:\\nThe space complexity of the given implementation is O(1), as it uses only constant extra space to store the prefix variable and the loop variables.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        \\n        prefix = min(strs, key=len)\\n        for s in strs:\\n            while not s.startswith(prefix):\\n                prefix = prefix[:-1]\\n                \\n        return prefix\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        \\n        prefix = min(strs, key=len)\\n        for s in strs:\\n            while not s.startswith(prefix):\\n                prefix = prefix[:-1]\\n                \\n        return prefix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1923947,
                "title": "typescript-solution",
                "content": "```typescript\\nfunction longestCommonPrefix(strs: string[]): string {\\n  let prefix = strs[0];\\n\\n  for (let i = 1; i < strs.length; i++) {\\n    while (!strs[i].startsWith(prefix)) {\\n      prefix = prefix.slice(0, -1);\\n    }\\n\\n    if (prefix === \\'\\') {\\n      return prefix;\\n    }\\n  }\\n  \\n  return prefix;\\n};\\n```\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```typescript\\nfunction longestCommonPrefix(strs: string[]): string {\\n  let prefix = strs[0];\\n\\n  for (let i = 1; i < strs.length; i++) {\\n    while (!strs[i].startsWith(prefix)) {\\n      prefix = prefix.slice(0, -1);\\n    }\\n\\n    if (prefix === \\'\\') {\\n      return prefix;\\n    }\\n  }\\n  \\n  return prefix;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1214400,
                "title": "kotlin",
                "content": "```\\nfun longestCommonPrefix(ar: Array<String>) = StringBuilder().apply {\\n    ar.minBy { it.length }?.forEachIndexed { i, c -> if (ar.all { it[i] == c }) append(c) else return toString() }\\n}.toString()\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun longestCommonPrefix(ar: Array<String>) = StringBuilder().apply {\\n    ar.minBy { it.length }?.forEachIndexed { i, c -> if (ar.all { it[i] == c }) append(c) else return toString() }\\n}.toString()\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2188782,
                "title": "keep-it-simple-and-go",
                "content": "```\\nfunc longestCommonPrefix(strs []string) string {\\n    for i := 0 ;; i++  {\\n        for _, str := range strs {\\n            if i == len(str) || str[i] != strs[0][i] {\\n                return strs[0][:i]\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc longestCommonPrefix(strs []string) string {\\n    for i := 0 ;; i++  {\\n        for _, str := range strs {\\n            if i == len(str) || str[i] != strs[0][i] {\\n                return strs[0][:i]\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 7282,
                "title": "here-is-my-solution-in-c-0-ms",
                "content": "    #include<stdio.h>\\n    #include<string.h>\\n    char* longestCommonPrefix(char** strs, int strsSize) \\n    {\\n        int i=0; int j=0;int index;int tempindex=0;\\n        if(strsSize<1)\\n        return \"\";\\n        index=strlen(strs[0]);\\n        char *a;\\n        a= malloc(sizeof(char)*(index+1));\\n        strcpy(a,strs[0]);\\n        for(i=1;i<strsSize;i++)\\n        {   tempindex=0;\\n            for(j=0;j<index;j++)\\n            { \\n                if(a[j]==strs[i][j])\\n                tempindex++;\\n                else\\n                {a[j]='\\\\0';\\n                 break;\\n                }\\n            } \\n              if (tempindex==0)return (\"\");\\n              if(tempindex<index)index=tempindex;\\n            \\n        }\\n        return a;\\n        \\n    }",
                "solutionTags": [],
                "code": "    #include<stdio.h>\\n    #include<string.h>\\n    char* longestCommonPrefix(char** strs, int strsSize) \\n    {\\n        int i=0; int j=0;int index;int tempindex=0;\\n        if(strsSize<1)\\n        return \"\";\\n        index=strlen(strs[0]);\\n        char *a;\\n        a= malloc(sizeof(char)*(index+1));\\n        strcpy(a,strs[0]);\\n        for(i=1;i<strsSize;i++)\\n        {   tempindex=0;\\n            for(j=0;j<index;j++)\\n            { \\n                if(a[j]==strs[i][j])\\n                tempindex++;\\n                else\\n                {a[j]='\\\\0';\\n                 break;\\n                }\\n            } \\n              if (tempindex==0)return (\"\");\\n              if(tempindex<index)index=tempindex;\\n            \\n        }\\n        return a;\\n        \\n    }",
                "codeTag": "C++"
            },
            {
                "id": 2744518,
                "title": "python3-solution",
                "content": "Simple & fast.\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs) == 0: return \"\"\\n        \\n        longPref = strs[0]\\n        \\n        for string in strs:\\n            for index in range(0, len(longPref)):\\n                if (index >= len(string) or longPref[index] != string[index]):\\n                    longPref = longPref[0:index]\\n                    break\\n                \\n        return longPref\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs) == 0: return \"\"\\n        \\n        longPref = strs[0]\\n        \\n        for string in strs:\\n            for index in range(0, len(longPref)):\\n                if (index >= len(string) or longPref[index] != string[index]):\\n                    longPref = longPref[0:index]\\n                    break\\n                \\n        return longPref\\n```",
                "codeTag": "Java"
            },
            {
                "id": 537447,
                "title": "swift-faster-than-93-78-of-swift-online-submissions",
                "content": "```\\nclass Solution {\\n    func longestCommonPrefix(_ strs: [String]) -> String {\\n        if strs.isEmpty { return \"\" }\\n        if strs.count == 1 { return strs[0] }\\n\\n        let strs = strs.sorted()\\n        var output = \"\"\\n        for (char1, char2) in zip(strs.first!, strs.last!) {\\n            if char1 == char2 {\\n                output += String(char1)\\n            } else {\\n                break\\n            }\\n        }\\n        return output\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func longestCommonPrefix(_ strs: [String]) -> String {\\n        if strs.isEmpty { return \"\" }\\n        if strs.count == 1 { return strs[0] }\\n\\n        let strs = strs.sorted()\\n        var output = \"\"\\n        for (char1, char2) in zip(strs.first!, strs.last!) {\\n            if char1 == char2 {\\n                output += String(char1)\\n            } else {\\n                break\\n            }\\n        }\\n        return output\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6944,
                "title": "python-recursive-boring-solution-linear-time-and-constant-space-with-simple-explanation",
                "content": "````\\n# asymptotic O(n*m) (n=number of words, m=number of letters) time, and O(1) space complexity\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        if not strs:\\n            return ''\\n        first_word = strs[0]\\n        for i in range(len(first_word)):\\n            for j in range(1,len(strs)):\\n                if i >= len(strs[j]): # first_word larger than current_word\\n                    return first_word[:i]\\n                if strs[j][i] != first_word[i]: # letters don't equal\\n                    return first_word[:i]\\n\\n        return first_word # made it to the end of the first word so this the common prefix\\n````\\nExplanation: No sorting (which adds additional O(nlogn) complexity) needed. The letters of the first word in the `strs` list will be used to compare against the letters of all of the other strings in the list. There are two main comparison cases while iterating over the letters of the first word: 1) The current index of the first word is larger then current index of the word being compared against. 2) The current first word letter does not match the letter in the word being compared against. In both cases, just return the substring of the first word up until this index. If you make it though the entire first word, then the entire first word is the common prefix.",
                "solutionTags": [
                    "Python"
                ],
                "code": "````\\n# asymptotic O(n*m) (n=number of words, m=number of letters) time, and O(1) space complexity\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        if not strs:\\n            return ''\\n        first_word = strs[0]\\n        for i in range(len(first_word)):\\n            for j in range(1,len(strs)):\\n                if i >= len(strs[j]): # first_word larger than current_word\\n                    return first_word[:i]\\n                if strs[j][i] != first_word[i]: # letters don't equal\\n                    return first_word[:i]\\n\\n        return first_word # made it to the end of the first word so this the common prefix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049209,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple Brute Force Solution\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n\\n    // Return early on empty input\\n    if (!strs.length) return \\'\\';\\n\\n    // Loop through the letters of the first string\\n    for (let i = 0; i <= strs[0].length; i++) {\\n        // Loop through the other strings\\n        for (let j = 1; j < strs.length; j++) {\\n            // Check if this character is also present in the same position of each string\\n            if (strs[0][i] !== strs[j][i]) {\\n                // If not, return the string up to and including the previous character\\n                return strs[0].slice(0, i);\\n            }\\n        }\\n    }\\n\\n    return strs[0];\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n\\n    // Return early on empty input\\n    if (!strs.length) return \\'\\';\\n\\n    // Loop through the letters of the first string\\n    for (let i = 0; i <= strs[0].length; i++) {\\n        // Loop through the other strings\\n        for (let j = 1; j < strs.length; j++) {\\n            // Check if this character is also present in the same position of each string\\n            if (strs[0][i] !== strs[j][i]) {\\n                // If not, return the string up to and including the previous character\\n                return strs[0].slice(0, i);\\n            }\\n        }\\n    }\\n\\n    return strs[0];\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2768776,
                "title": "c-prefix",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int n = strs.size();\\n        \\n        // Sort the vector\\n        sort(strs.begin(), strs.end());\\n        string ans = \"\"; // for storing answer\\n        \\n        string a = strs[0]; // after sorting first element\\n        string b = strs[n-1]; // after sorting last element\\n        \\n        // We can compare for first and last , since they are sorted\\n        // i < a.length() ==> common prefix we can select least word\\n        for(int i = 0; i < a.length(); i++){\\n            if(a[i] == b[i]){\\n                // If same add in answer\\n                ans += a[i];\\n            }else{\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int n = strs.size();\\n        \\n        // Sort the vector\\n        sort(strs.begin(), strs.end());\\n        string ans = \"\"; // for storing answer\\n        \\n        string a = strs[0]; // after sorting first element\\n        string b = strs[n-1]; // after sorting last element\\n        \\n        // We can compare for first and last , since they are sorted\\n        // i < a.length() ==> common prefix we can select least word\\n        for(int i = 0; i < a.length(); i++){\\n            if(a[i] == b[i]){\\n                // If same add in answer\\n                ans += a[i];\\n            }else{\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 281741,
                "title": "c-100ms-faster-than-96",
                "content": "Could certainly be improved but I didn\\'t see any other C# solutions posted so I wanted to include something\\n\\n\\n```\\npublic class Solution {\\n    public string LongestCommonPrefix(string[] strs) {\\n        if(strs.Length == 1)\\n            return strs[0];\\n        \\n        var prefixString = \"\";\\n        \\n        if (strs == null || strs.Length == 0)\\n            return prefixString;\\n        \\n        // Go through all the letters of the first word\\n        for(int i = 0; i < strs[0].Length; i++){\\n            \\n            // Go through each of the remaining words\\n            foreach(string str in strs){\\n                // If i is higher then the length of the word\\n                // there is no longer a prefix to match\\n                if(i > str.Length - 1)\\n                    return prefixString;\\n                \\n                // If the i-th letter of the string doesn\\'t match the i-th \\n                // letter of the first word we\\'ve reached the end of the\\n                // common prefix\\n                if(strs[0][i] != str[i])\\n                    return prefixString;            \\n            }\\n            \\n            // If we make it through the inner foreach all of the \\n            prefixString += strs[0][i];\\n        }\\n        \\n        \\n        return prefixString;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string LongestCommonPrefix(string[] strs) {\\n        if(strs.Length == 1)\\n            return strs[0];\\n        \\n        var prefixString = \"\";\\n        \\n        if (strs == null || strs.Length == 0)\\n            return prefixString;\\n        \\n        // Go through all the letters of the first word\\n        for(int i = 0; i < strs[0].Length; i++){\\n            \\n            // Go through each of the remaining words\\n            foreach(string str in strs){\\n                // If i is higher then the length of the word\\n                // there is no longer a prefix to match\\n                if(i > str.Length - 1)\\n                    return prefixString;\\n                \\n                // If the i-th letter of the string doesn\\'t match the i-th \\n                // letter of the first word we\\'ve reached the end of the\\n                // common prefix\\n                if(strs[0][i] != str[i])\\n                    return prefixString;            \\n            }\\n            \\n            // If we make it through the inner foreach all of the \\n            prefixString += strs[0][i];\\n        }\\n        \\n        \\n        return prefixString;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7224,
                "title": "share-my-java-solution",
                "content": "Scan all the strings with the same pace, once we reach the end of a string or find a mismatch we return the result.\\n\\n    public String longestCommonPrefix(String[] strs) {\\n      if (strs == null || strs.length == 0) {\\n        return \"\";\\n      }\\n      \\n      for (int i = 0; i < strs[0].length(); i++) {\\n        for (int j = 1; j < strs.length; j++) {\\n          if (i >= strs[j].length() || strs[j].charAt(i) != strs[0].charAt(i)) {\\n            return strs[0].substring(0, i);\\n          }\\n        }\\n      }\\n      \\n      return strs[0];\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Scan all the strings with the same pace, once we reach the end of a string or find a mismatch we return the result.\\n\\n    public String longestCommonPrefix(String[] strs) {\\n      if (strs == null || strs.length == 0) {\\n        return \"\";\\n      }\\n      \\n      for (int i = 0; i < strs[0].length(); i++) {\\n        for (int j = 1; j < strs.length; j++) {\\n          if (i >= strs[j].length() || strs[j].charAt(i) != strs[0].charAt(i)) {\\n            return strs[0].substring(0, i);\\n          }\\n        }\\n      }\\n      \\n      return strs[0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2703310,
                "title": "comparision-of-characters-of-two-strings-java",
                "content": "1. If the ```strs``` array does not contain any element then return ```null``` string OR if it contains only one element then return that string.\\n2. Make a character array ```arr``` of the first element of ```strs``` array. This is done in order to compare the characters with the remaining elements of the ```strs``` array.\\n3. Make a variable ```i``` and assign it a value 0, another variable ```ans``` and assign it the value of Integer.MAX_VALUE\\n3. Place a pointer ```j``` on the 1st position of ```strs``` array and traverse it till the length of the array. Inside this loop, make a pointer ```k``` and traverse it till the **minimum** of the length of **j**th element of ```strs``` array and the length of ```arr``` array. (Minimum length is taken in order to avoid the IndexOutofBoundException)\\n4. Inside this second loop, check if the characters of that **j**th element matches with the **k**th character of ```arr``` array. Increment the value of ```i``` if this condition satisfies. Else break the loop if at any iteration the character doesn\\'t matches.\\n5. If ```i``` is less than ```ans``` then update the value of ```ans = i```. This is done because so as to minimize the length of the common valid prefix.\\n6. Update the value of ```i``` to 0 for the next iteration. This is how here the first loop ends.\\n7. Make an empty string ```res```. Initialize a for loop from 0 to ```ans``` and concatenate the subsequent characters of the ```arr``` array so as to make the final **longest common prefix**.\\n8. Finally, return ```res```.\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        char[] arr = strs[0].toCharArray();\\n        if(strs.length == 0){\\n            return \"\";\\n        }\\n        if(strs.length == 1){\\n            return strs[0];\\n        }\\n        int i = 0,ans = Integer.MAX_VALUE;\\n        for (int j = 1;j < strs.length;j++){\\n            for (int k = 0;k < Math.min(strs[j].length(),arr.length);k++){\\n                if(strs[j].charAt(k) == arr[k]){\\n                    i++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            if(i < ans){\\n                ans = i;\\n            }\\n            i = 0;\\n        }\\n        String res = \"\";\\n        for (int j = 0;j < ans;j++){\\n            res += arr[j];\\n        }\\n        return res;\\n    }\\n}\\n```\\n**If you got this, please upvote :)**",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```strs```\n```null```\n```arr```\n```strs```\n```strs```\n```i```\n```ans```\n```j```\n```strs```\n```k```\n```strs```\n```arr```\n```arr```\n```i```\n```i```\n```ans```\n```ans = i```\n```i```\n```res```\n```ans```\n```arr```\n```res```\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        char[] arr = strs[0].toCharArray();\\n        if(strs.length == 0){\\n            return \"\";\\n        }\\n        if(strs.length == 1){\\n            return strs[0];\\n        }\\n        int i = 0,ans = Integer.MAX_VALUE;\\n        for (int j = 1;j < strs.length;j++){\\n            for (int k = 0;k < Math.min(strs[j].length(),arr.length);k++){\\n                if(strs[j].charAt(k) == arr[k]){\\n                    i++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            if(i < ans){\\n                ans = i;\\n            }\\n            i = 0;\\n        }\\n        String res = \"\";\\n        for (int j = 0;j < ans;j++){\\n            res += arr[j];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695808,
                "title": "python-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought was to sort the array according to the length of the strings and then use the shortest string as the base prefix.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAfter sorting and getting the base prefix we simply check if the base prefix is the longest common prefix if that is not the case we check if excluding the last letter of base prefix gives us the longest common prefix, we do this until we run out of letters in base prefix and in this case we return empty string.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(mn)\\nm = min(array, key lambda x:len(x))\\nn = len(array)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        strs.sort(key = lambda x:len(x))\\n        prefix = strs[0]\\n        for i in range(len(strs[0]),0,-1):\\n            if all([prefix[:i] == strs[j][:i] for j in range(1,len(strs))]):\\n                return(prefix[:i])\\n        return \"\"\\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        strs.sort(key = lambda x:len(x))\\n        prefix = strs[0]\\n        for i in range(len(strs[0]),0,-1):\\n            if all([prefix[:i] == strs[j][:i] for j in range(1,len(strs))]):\\n                return(prefix[:i])\\n        return \"\"\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587164,
                "title": "c-2-solutions-simple-and-clean",
                "content": "**Time complexity - O(n*m)\\nSpace complexity - O(1)**\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string ans;\\n        \\n        for(int i=0;i<strs[0].size();i++) {\\n            for(int j=1;j<strs.size();j++) {\\n                if(strs[0][i] != strs[j][i]) {\\n                    return ans;\\n                }\\n            }\\n            ans += strs[0][i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Optimized solution.**\\n**Time complexity - O(n logn)\\nSpace complexity - O(1)**\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string ans;\\n        \\n        sort(strs.begin(),strs.end());\\n        for(int i=0;i<strs[0].size();i++) {\\n            if(strs[0][i] != strs[strs.size()-1][i]) {\\n                return ans;\\n            }\\n            ans += strs[0][i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Like the solution?\\nPlease upvote \\u30C4**\\n\\nIf you can\\'t understand any step/point, feel free to comment.\\nHappy to help",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string ans;\\n        \\n        for(int i=0;i<strs[0].size();i++) {\\n            for(int j=1;j<strs.size();j++) {\\n                if(strs[0][i] != strs[j][i]) {\\n                    return ans;\\n                }\\n            }\\n            ans += strs[0][i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string ans;\\n        \\n        sort(strs.begin(),strs.end());\\n        for(int i=0;i<strs[0].size();i++) {\\n            if(strs[0][i] != strs[strs.size()-1][i]) {\\n                return ans;\\n            }\\n            ans += strs[0][i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158660,
                "title": "c-java-python3-javascript-solution-explanation",
                "content": "Which have included C#, Java, Python3,JavaScript solutions\\n(JavaScript version have been updated on 2022/06/16 )\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-14-longest-common-prefix-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-14-longest-common-prefix-solution-and-explanation-en/)\\u2B50\\n\\n\\u2B07JavaScript Submission Detail (2022/06/16) \\u2B07\\n![image](https://assets.leetcode.com/users/images/60e91036-09f2-431f-b730-22bcf63a4c8f_1655382611.7401285.png)\\n\\n\\n\\n#### Example : Java Code \\u27A1 Runtime : 1ms\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        for (int i = 0; i < strs[0].length(); i++) \\n        {\\n            char tmpChar = strs[0].charAt(i); \\n            for (int j = 0; j < strs.length; j++) \\n            {\\n                if (strs[j].length() == i || strs[j].charAt(i) != tmpChar) \\n                {\\n                    return strs[0].substring(0, i);\\n                }\\n            }\\n        }\\n        return strs[0]; \\n    }\\n}\\n```\\n**You can find a faster Java solution in the link.**\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to leave your comment.\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        for (int i = 0; i < strs[0].length(); i++) \\n        {\\n            char tmpChar = strs[0].charAt(i); \\n            for (int j = 0; j < strs.length; j++) \\n            {\\n                if (strs[j].length() == i || strs[j].charAt(i) != tmpChar) \\n                {\\n                    return strs[0].substring(0, i);\\n                }\\n            }\\n        }\\n        return strs[0]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152670,
                "title": "c-easiest-solution-detailed-explanation-short-simple-code",
                "content": "```\\nstring longestCommonPrefix(vector<string>& strs) {\\n       \\n        int n=strs.size();\\n        sort(strs.begin(),strs.end());\\n        string ans;\\n//Since we need to find the longest common prefix, we just need to compare the 0th and the last string in strs after sorting and see which characters are common. Since it\\'s sorted, 0th & last strings\\' common characters will be the ans.\\n        string s1=strs[0];\\n        string s2=strs[n-1];\\n        \\n        for(int i=0; i<s1.size(); i++)\\n        {\\n            if(s1[i]==s2[i])\\n                ans=ans+s1[i];\\n            else\\n                break;\\n        }\\n        return ans;\\n    }\\n```\\n*If this was helpful, don\\'t forget to upvote!*",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nstring longestCommonPrefix(vector<string>& strs) {\\n       \\n        int n=strs.size();\\n        sort(strs.begin(),strs.end());\\n        string ans;\\n//Since we need to find the longest common prefix, we just need to compare the 0th and the last string in strs after sorting and see which characters are common. Since it\\'s sorted, 0th & last strings\\' common characters will be the ans.\\n        string s1=strs[0];\\n        string s2=strs[n-1];\\n        \\n        for(int i=0; i<s1.size(); i++)\\n        {\\n            if(s1[i]==s2[i])\\n                ans=ans+s1[i];\\n            else\\n                break;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1545132,
                "title": "java-tc-o-n-minlen-sc-o-1-constant-space-vertical-scanning-solution",
                "content": "**Constant Space Solution - Using String.substring to save on auxillary space**\\n```\\n/**\\n * Vertical Scanning or Column Scanning. Here character at the same index is\\n * compared. If the character at the same index in all input strings is same,\\n * add it to the prefix. Else, return the found prefix.\\n *\\n * Using substring instead of string builder to save on space.\\n *\\n * Time Complexity: O(N * minLen)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Number of strings in strs. minLen = Length of the smallest string.\\n */\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if (strs == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int numStrs = strs.length;\\n        if (numStrs == 0 || \"\".equals(strs[0]) || \"\".equals(strs[numStrs - 1])) {\\n            return \"\";\\n        }\\n\\n        String firstStr = strs[0];\\n        if (numStrs == 1) {\\n            return firstStr;\\n        }\\n\\n        int prefixLen = 0;\\n\\n\\t\\t// No need to find the minLen as this nested loop will exit when we reach the\\n        // end of minLen string.\\n        while (prefixLen < firstStr.length()) {\\n            char c = firstStr.charAt(prefixLen);\\n            for (int i = 1; i < numStrs; i++) {\\n                if (strs[i].length() <= prefixLen || strs[i].charAt(prefixLen) != c) {\\n                    return firstStr.substring(0, prefixLen);\\n                }\\n            }\\n            prefixLen++;\\n        }\\n\\n        return firstStr.substring(0, prefixLen);\\n    }\\n}\\n```\\n\\n---\\n**This solution will take O(minLen) space. Using StringBuilder to keep track of the result**\\n```java\\n/**\\n * Vertical Scanning or Column Scanning. Here character at the same index is\\n * compared. If the character at the same index in all input strings is same,\\n * add it to the prefix. Else, return the found prefix.\\n *\\n * In this solution using StringBuilder to keep track of the result\\n *\\n * Time Complexity: O(N * minLen + N)\\n *\\n * Space Complexity: O(minLen)\\n *\\n * N = Number of strings in strs. minLen = Length of smallest string in strs.\\n */\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if (strs == null || strs.length == 0) {\\n            return \"\";\\n        }\\n        if (strs.length == 1) {\\n            return strs[0];\\n        }\\n\\n        int minLen = Integer.MAX_VALUE;\\n        for (String s : strs) {\\n            minLen = Math.min(minLen, s.length());\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < minLen; i++) {\\n            char c1 = strs[0].charAt(i);\\n            for (int j = 1; j < strs.length; j++) {\\n                if (c1 != strs[j].charAt(i)) {\\n                    return sb.toString();\\n                }\\n            }\\n            sb.append(c1);\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n/**\\n * Vertical Scanning or Column Scanning. Here character at the same index is\\n * compared. If the character at the same index in all input strings is same,\\n * add it to the prefix. Else, return the found prefix.\\n *\\n * Using substring instead of string builder to save on space.\\n *\\n * Time Complexity: O(N * minLen)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Number of strings in strs. minLen = Length of the smallest string.\\n */\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if (strs == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int numStrs = strs.length;\\n        if (numStrs == 0 || \"\".equals(strs[0]) || \"\".equals(strs[numStrs - 1])) {\\n            return \"\";\\n        }\\n\\n        String firstStr = strs[0];\\n        if (numStrs == 1) {\\n            return firstStr;\\n        }\\n\\n        int prefixLen = 0;\\n\\n\\t\\t// No need to find the minLen as this nested loop will exit when we reach the\\n        // end of minLen string.\\n        while (prefixLen < firstStr.length()) {\\n            char c = firstStr.charAt(prefixLen);\\n            for (int i = 1; i < numStrs; i++) {\\n                if (strs[i].length() <= prefixLen || strs[i].charAt(prefixLen) != c) {\\n                    return firstStr.substring(0, prefixLen);\\n                }\\n            }\\n            prefixLen++;\\n        }\\n\\n        return firstStr.substring(0, prefixLen);\\n    }\\n}\\n```\n```java\\n/**\\n * Vertical Scanning or Column Scanning. Here character at the same index is\\n * compared. If the character at the same index in all input strings is same,\\n * add it to the prefix. Else, return the found prefix.\\n *\\n * In this solution using StringBuilder to keep track of the result\\n *\\n * Time Complexity: O(N * minLen + N)\\n *\\n * Space Complexity: O(minLen)\\n *\\n * N = Number of strings in strs. minLen = Length of smallest string in strs.\\n */\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if (strs == null || strs.length == 0) {\\n            return \"\";\\n        }\\n        if (strs.length == 1) {\\n            return strs[0];\\n        }\\n\\n        int minLen = Integer.MAX_VALUE;\\n        for (String s : strs) {\\n            minLen = Math.min(minLen, s.length());\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < minLen; i++) {\\n            char c1 = strs[0].charAt(i);\\n            for (int j = 1; j < strs.length; j++) {\\n                if (c1 != strs[j].charAt(i)) {\\n                    return sb.toString();\\n                }\\n            }\\n            sb.append(c1);\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 527474,
                "title": "c-solution",
                "content": "```c\\nchar * longestCommonPrefix(char ** strs, int strsSize){\\n    if (strsSize == 0) return \"\";\\n    if (strsSize == 1) return strs[0];\\n\\n    int len = 0, min = strlen(strs[0]);\\n    for (int i = 1; i < strsSize; ++i) {\\n        min = strlen(strs[i]) < min ? strlen(strs[i]) : min;\\n    }\\n\\n    for (int c = 0; c < min; ++c) {\\n        for (int s = 0; s < strsSize - 1; ++s) {\\n            if (strs[s][c] == strs[s+1][c]) {\\n                if (s == strsSize - 2) {\\n                    ++len;\\n                }\\n            } else {\\n                goto br;\\n            }\\n        }\\n    }\\n    br:\\n\\n    if (len > 0) {\\n        char* ret = malloc(len * sizeof(int));\\n        strs[0][len] = \\'\\\\0\\';\\n        strcpy(ret, strs[0]);\\n        return ret;\\n    }\\n\\n    return \"\";\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c\\nchar * longestCommonPrefix(char ** strs, int strsSize){\\n    if (strsSize == 0) return \"\";\\n    if (strsSize == 1) return strs[0];\\n\\n    int len = 0, min = strlen(strs[0]);\\n    for (int i = 1; i < strsSize; ++i) {\\n        min = strlen(strs[i]) < min ? strlen(strs[i]) : min;\\n    }\\n\\n    for (int c = 0; c < min; ++c) {\\n        for (int s = 0; s < strsSize - 1; ++s) {\\n            if (strs[s][c] == strs[s+1][c]) {\\n                if (s == strsSize - 2) {\\n                    ++len;\\n                }\\n            } else {\\n                goto br;\\n            }\\n        }\\n    }\\n    br:\\n\\n    if (len > 0) {\\n        char* ret = malloc(len * sizeof(int));\\n        strs[0][len] = \\'\\\\0\\';\\n        strcpy(ret, strs[0]);\\n        return ret;\\n    }\\n\\n    return \"\";\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 293568,
                "title": "python-easy-solution-runtime-95-faster",
                "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        lcp = \"\"\\n        for s in zip(*strs):\\n            if (s[0],) * len(s) == s:\\n                lcp += s[0]\\n            else:\\n                break\\n        return lcp\\n```",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        lcp = \"\"\\n        for s in zip(*strs):\\n            if (s[0],) * len(s) == s:\\n                lcp += s[0]\\n            else:\\n                break\\n        return lcp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 160011,
                "title": "simple-and-clear-solution-in-c-java-python",
                "content": "Sort the string array first, then we only need to find out the longest common prefix between the first and last word.\\n#### C++\\n```\\n# include<algorithm>\\n\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int n = strs.size();\\n        if(n == 0) {\\n            return \"\";\\n        }\\n        string res = \"\";\\n        sort(strs.begin(), strs.end());// sort the array\\n        string first = strs[0]; // first word\\n        string last = strs[n-1];// last word\\n        int limit = min(first.length(), last.length());\\n        for(int i = 0; i < limit; i++) {// find out the longest common prefix between first and last word\\n            if(first[i] == last[i]) {\\n                res += first[i];\\n            }    \\n            else {\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n#### Java\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int n = strs.length;\\n        if(n == 0) {\\n            return \"\";\\n        }\\n        StringBuffer sb = new StringBuffer();\\n        Arrays.sort(strs);// sort string array\\n        String first = strs[0];\\n        String last = strs[n-1];\\n        int limit = Math.min(first.length(), last.length());\\n        for(int i = 0; i < limit; i++) {// find out the longest common prefix between first and last word\\n            if(first.charAt(i) == last.charAt(i)) {\\n                sb.append(first.charAt(i));\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n#### Python\\n```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        n = len(strs)\\n        if n == 0:\\n            return \"\"\\n        \\n        res = \"\"\\n        strs.sort() # sort the string array\\n        first = strs[0]\\n        last = strs[-1]\\n        limit = min(len(first), len(last)) \\n        for i in range(limit): # find out the longest common prefix between first and last word\\n            if first[i] == last[i]:\\n                res += first[i]\\n            else:\\n                break\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n# include<algorithm>\\n\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int n = strs.size();\\n        if(n == 0) {\\n            return \"\";\\n        }\\n        string res = \"\";\\n        sort(strs.begin(), strs.end());// sort the array\\n        string first = strs[0]; // first word\\n        string last = strs[n-1];// last word\\n        int limit = min(first.length(), last.length());\\n        for(int i = 0; i < limit; i++) {// find out the longest common prefix between first and last word\\n            if(first[i] == last[i]) {\\n                res += first[i];\\n            }    \\n            else {\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int n = strs.length;\\n        if(n == 0) {\\n            return \"\";\\n        }\\n        StringBuffer sb = new StringBuffer();\\n        Arrays.sort(strs);// sort string array\\n        String first = strs[0];\\n        String last = strs[n-1];\\n        int limit = Math.min(first.length(), last.length());\\n        for(int i = 0; i < limit; i++) {// find out the longest common prefix between first and last word\\n            if(first.charAt(i) == last.charAt(i)) {\\n                sb.append(first.charAt(i));\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        n = len(strs)\\n        if n == 0:\\n            return \"\"\\n        \\n        res = \"\"\\n        strs.sort() # sort the string array\\n        first = strs[0]\\n        last = strs[-1]\\n        limit = min(len(first), len(last)) \\n        for i in range(limit): # find out the longest common prefix between first and last word\\n            if first[i] == last[i]:\\n                res += first[i]\\n            else:\\n                break\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 129542,
                "title": "swift-16-ms",
                "content": "```\\nfunc longestCommonPrefix(_ strs: [String]) -> String {\\n    \\n   if strs.count == 0 { return \"\" }\\n    \\n    let shortestWord = strs.min{$0.count < $1.count}!\\n    var longestPrefix = shortestWord\\n    \\n        for str in strs {\\n            \\n            while !str.hasPrefix(longestPrefix), longestPrefix.count > 0 {\\n                longestPrefix.removeLast()\\n            }\\n            \\n            if longestPrefix.count == 0 { return longestPrefix }\\n        }\\n    \\n    return longestPrefix\\n}\\n```\\nThere is no need, actually, to use shortestWord. It just stayed there from one of my previous submission. But when I noticed that and removed it:\\n\\n```\\n    var longestPrefix = strs.min{$0.count < $1.count}!\\n```\\n\\nthen time went up to the 22 ms :)",
                "solutionTags": [],
                "code": "```\\nfunc longestCommonPrefix(_ strs: [String]) -> String {\\n    \\n   if strs.count == 0 { return \"\" }\\n    \\n    let shortestWord = strs.min{$0.count < $1.count}!\\n    var longestPrefix = shortestWord\\n    \\n        for str in strs {\\n            \\n            while !str.hasPrefix(longestPrefix), longestPrefix.count > 0 {\\n                longestPrefix.removeLast()\\n            }\\n            \\n            if longestPrefix.count == 0 { return longestPrefix }\\n        }\\n    \\n    return longestPrefix\\n}\\n```\n```\\n    var longestPrefix = strs.min{$0.count < $1.count}!\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6950,
                "title": "clean-7-lines-c",
                "content": "**Solution 1**\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if(strs.empty()) return \"\";\\n        string res = strs[0];\\n        for(auto s: strs) res = match(res, s);\\n        return res;\\n    }\\n    \\n    string match(const string& pre, const string& s){\\n        int i = 0, len = min(pre.size(), s.size());\\n        for(; i < len; i++) if(s[i] != pre[i]) break;\\n        return pre.substr(0, i);\\n    }\\n};\\n```\\n***\\n**Solution 2**\\n\\nUsing sort and only compare the first string with the last string.\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if(strs.empty()) return \"\";\\n        sort(strs.begin(), strs.end());\\n        string a = strs[0], b = strs.back();\\n        int i = 0;\\n        for(; i < min(a.size(), b.size()); i++) if(a[i] != b[i]) break;\\n        return a.substr(0, i);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if(strs.empty()) return \"\";\\n        string res = strs[0];\\n        for(auto s: strs) res = match(res, s);\\n        return res;\\n    }\\n    \\n    string match(const string& pre, const string& s){\\n        int i = 0, len = min(pre.size(), s.size());\\n        for(; i < len; i++) if(s[i] != pre[i]) break;\\n        return pre.substr(0, i);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if(strs.empty()) return \"\";\\n        sort(strs.begin(), strs.end());\\n        string a = strs[0], b = strs.back();\\n        int i = 0;\\n        for(; i < min(a.size(), b.size()); i++) if(a[i] != b[i]) break;\\n        return a.substr(0, i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7258,
                "title": "3-diffrent-c-solutions-each-one-costs-8ms",
                "content": "First one: check from strs[0][0] to strs[i][0]. If matches, check strs[0][1] to strs[i][1].\\n\\nCode:\\n\\n    class Solution {\\n    public:\\n        string longestCommonPrefix(vector<string>& strs) {\\n            if(strs.size()==0)\\n            return \"\";\\n            string ans=\"\";\\n            int max=INT_MAX;\\n            for(auto& s:strs)\\n            {\\n                max=(max>s.length())?s.length():max;\\n            }\\n            for(int i=0;i<max;i++)\\n            {\\n                bool flag=true;\\n                char x=strs[0][i];\\n                for(auto& s:strs)\\n                {\\n                    if(s[i]!=x)\\n                    {\\n                        flag=false;\\n                        break;\\n                    }\\n                }\\n                if(flag==false)\\n                return ans;\\n                ans+=x;\\n            }\\n            return ans;\\n        }\\n    };\\n\\nSecond one: assume the prefix is strs[0]. Compair with strs[i], and cut the letters which don't match.\\n\\nCode:\\n\\n    class Solution {\\n    public:\\n        string longestCommonPrefix(vector<string>& strs) {\\n            if(strs.size()==0)\\n            return \"\";\\n            string ans=strs[0];\\n            int max=INT_MAX;\\n            for(auto& s:strs)\\n            {\\n                if(s.length()==0)\\n                return \"\";\\n                int i=0;\\n                for(i=0;i<ans.length()&&i<s.length();i++)\\n                {\\n                    if(s[i]!=ans[i])\\n                    break;\\n                }\\n                ans=ans.substr(0,i);\\n            }\\n    \\n            return ans;\\n        }\\n    };\\n\\nThird one:  use a Trie data structure to save the strs. Search the trie, and stops when a TrieNode has more than one son.\\n\\nCode:\\n\\n    class TrieNode{\\n    public:\\n    \\tbool val;\\n    \\tTrieNode* next[52];\\n    \\tint sons;\\n    \\tTrieNode() :val(false), sons(0)\\n    \\t{\\n    \\t\\tfor (int i = 0; i < 52; i++)\\n    \\t\\t\\tnext[i] = nullptr;\\n    \\t}\\n    };\\n    class Trie{\\n    private:\\n    \\tTrieNode* putst(string& s, TrieNode * node, int loc, TrieNode *father)\\n    \\t{\\n    \\t\\tif (s.length() == 0)\\n    \\t\\t{\\n    \\t\\t\\tnode->val = true;\\n    \\t\\t\\tnode->sons++;\\n    \\t\\t\\treturn node;\\n    \\t\\t}\\n    \\t\\tif (node == nullptr)\\n    \\t\\t{\\n    \\t\\t\\tnode = new TrieNode();\\n    \\t\\t\\tif (father != nullptr)\\n    \\t\\t\\t\\tfather->sons++;\\n    \\t\\t}\\n    \\t\\tif (loc == s.length())\\n    \\t\\t{\\n    \\t\\t\\tnode->val = true;\\n    \\t\\t\\treturn node;\\n    \\t\\t}\\n    \\t\\tif (s[loc] >= 'a')\\n    \\t\\t\\tnode->next[s[loc] - 'a'] = putst(s, node->next[s[loc] - 'a'], loc + 1, node);\\n    \\t\\telse\\n    \\t\\t\\tnode->next[s[loc] - 'A' + 26] = putst(s, node->next[s[loc] - 'A' + 26], loc + 1, node);\\n    \\t\\treturn node;\\n    \\t}\\n    public:\\n    \\tTrieNode *root;\\n    \\tvoid insert(string & str){ putst(str, root, 0, nullptr); }\\n    \\tTrie(){ root = new TrieNode(); }\\n    };\\n    class Solution {\\n    private:\\n    \\tstring findPre(TrieNode * node)\\n    \\t{\\n    \\t\\tif (node == nullptr || (node != nullptr&&node->sons > 1))\\n    \\t\\t\\treturn string(\"\");\\n    \\t\\tint i = 0;\\n    \\t\\tfor (i = 0; i < 52; i++)\\n    \\t\\t{\\n    \\t\\t\\tif (node->next[i] != nullptr)\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t}\\n    \\t\\tif (i == 52)\\n    \\t\\t\\treturn string(\"\");\\n    \\t\\tchar temp1 = ((i>25) ? ('A' + i) : ('a' + i));\\n    \\t\\tstring temp;\\n    \\t\\ttemp.insert(temp.begin(), temp1);\\n    \\t\\tif (node->val)\\n    \\t\\t{\\n    \\t\\t\\treturn string(\"\");\\n    \\t\\t}\\n    \\t\\telse\\n    \\t\\t{\\n    \\t\\t\\treturn temp + findPre(node->next[i]);\\n    \\t\\t}\\n    \\t}\\n    public:\\n    \\tstring longestCommonPrefix(vector<string>& strs) {\\n    \\t\\tTrie a;\\n    \\t\\tfor (auto& str : strs)\\n    \\t\\t\\ta.insert(str);\\n    \\t\\treturn findPre(a.root);\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string longestCommonPrefix(vector<string>& strs) {\\n            if(strs.size()==0)\\n            return \"\";\\n            string ans=\"\";\\n            int max=INT_MAX;\\n            for(auto& s:strs)\\n            {\\n                max=(max>s.length())?s.length():max;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3152934,
                "title": "beats-100-c-easy-solution",
                "content": "# Intuition\\n# Approach\\n1.short the string \\n   sort(str.begin(), str.end())\\n   it will short in alphabetically order\\n   such that no need to compair string in between start and last      string so\\n   \\n2.compair first string alphabet with last string alphabet\\n3.store in another string if alphabet gets equall;\\n\\n \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) {\\n     string ans=\"\"; //to store result \\n     sort(str.begin(), str.end()); \\n      string firstStr=str[0];\\n      string lastStr=str[str.size()-1]; \\n        for(int i=0; i<firstStr.size(); i++)\\n        {\\n           if(firstStr[i]==lastStr[i])//compair first string alphabet with last string alphabet\\n           {\\n             ans=ans+firstStr[i];\\n           }\\n            else \\n             break;\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) {\\n     string ans=\"\"; //to store result \\n     sort(str.begin(), str.end()); \\n      string firstStr=str[0];\\n      string lastStr=str[str.size()-1]; \\n        for(int i=0; i<firstStr.size(); i++)\\n        {\\n           if(firstStr[i]==lastStr[i])//compair first string alphabet with last string alphabet\\n           {\\n             ans=ans+firstStr[i];\\n           }\\n            else \\n             break;\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928400,
                "title": "easiest-faang-method-ever",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis question uses the beauty of sort() in strings. \\n```\\nWhen Strings are sorted, the possibility of characters to be least\\ncommon is between 1st and last member of the sorted strings.\\n```\\nVery simple beginner friendly question. Yet the idea of sorting stings is what makes it tricky \\uD83D\\uDCA1\\n\\n# Complexity\\n- Time complexity: O(n logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) {\\n        string res=\"\";\\n        sort(str.begin(),str.end());\\n        string a=str[0];\\n        string b=str[str.size()-1];\\n        for(int i=0;i<str[0].size();i++){\\n            if(a[i]==b[i])\\n                res+=a[i];\\n            else\\n                break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C",
                    "String"
                ],
                "code": "```\\nWhen Strings are sorted, the possibility of characters to be least\\ncommon is between 1st and last member of the sorted strings.\\n```\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) {\\n        string res=\"\";\\n        sort(str.begin(),str.end());\\n        string a=str[0];\\n        string b=str[str.size()-1];\\n        for(int i=0;i<str[0].size();i++){\\n            if(a[i]==b[i])\\n                res+=a[i];\\n            else\\n                break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2175545,
                "title": "python-solution-beats-95-34-brute-force",
                "content": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        strs.sort()\\n        lim = min(strs,key=len)\\n        res = \"\"\\n        for i in range(len(lim)):\\n            if strs[0][i] != strs[len(strs)-1][i]:\\n                break\\n            res += strs[0][i]\\n        return res\\n```\\n**.\\n.\\n.\\n.\\n.\\n.\\nPlease Upvote if you find this post useful...**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        strs.sort()\\n        lim = min(strs,key=len)\\n        res = \"\"\\n        for i in range(len(lim)):\\n            if strs[0][i] != strs[len(strs)-1][i]:\\n                break\\n            res += strs[0][i]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031242,
                "title": "javascript-simple-solution-faster-than-87",
                "content": "```\\nvar longestCommonPrefix = function (strs) {\\n \\n  let lcp = \\'\\';\\n  if (!strs || !strs.length) return lcp;\\n  \\n  // sorting array alphabetically \\n  strs.sort()\\n  \\n  for (let i = 0; i < strs[0].length; ++i) {\\n    if (strs[0][i] !== strs[strs.length - 1][i]) {    // comparing only first and last item\\n      break;\\n    } else {\\n      lcp += strs[0][i];\\n    }\\n  }\\n  return lcp;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestCommonPrefix = function (strs) {\\n \\n  let lcp = \\'\\';\\n  if (!strs || !strs.length) return lcp;\\n  \\n  // sorting array alphabetically \\n  strs.sort()\\n  \\n  for (let i = 0; i < strs[0].length; ++i) {\\n    if (strs[0][i] !== strs[strs.length - 1][i]) {    // comparing only first and last item\\n      break;\\n    } else {\\n      lcp += strs[0][i];\\n    }\\n  }\\n  return lcp;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 783976,
                "title": "python-simple-solution-beats-100-runtime-12ms",
                "content": "The longest common prefix can be optimally found if we have the alphabetically smallest & largest strings. After that we just need compare them & return the longest common prefix. There is no need of sorting the array as the time complexity would be O(nlogn) for that.\\n\\n**min(an array of strings)** - returns the alphabetically smallest string\\nUse **max()** in a similar way.\\n\\n```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        if len(strs) == 0: \\n\\t\\t\\treturn \"\"\\n        s1, s2 = min(strs), max(strs)\\n        i = 0\\n        while i < len(s1) and i < len(s2) and s1[i] == s2[i]: \\n\\t\\t\\ti += 1\\n        return s1[:i]\\n```\\n\\n**Modular Version** - 16ms\\nThe lcp helper compares two strings & returns the longest common prefix. It can be included within the original function itself, I wrote it this way because in my first solution I was using Brute Force to compare all the pairs of strings. Don\\'t judge me :) \\nThis way I could reuse my pre-written piece of code without having to change anything when optimizing the Brute Force.\\n```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        if len(strs) == 0:\\n            return \"\"\\n        return self.lcp_helper(min(strs), max(strs))\\n\\n    def lcp_helper(self, s1, s2):\\n        i = 0\\n        while i<len(s1) and i<len(s2) and s1[i]==s2[i]:\\n            i += 1\\n        return s1[:i]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        if len(strs) == 0: \\n\\t\\t\\treturn \"\"\\n        s1, s2 = min(strs), max(strs)\\n        i = 0\\n        while i < len(s1) and i < len(s2) and s1[i] == s2[i]: \\n\\t\\t\\ti += 1\\n        return s1[:i]\\n```\n```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        if len(strs) == 0:\\n            return \"\"\\n        return self.lcp_helper(min(strs), max(strs))\\n\\n    def lcp_helper(self, s1, s2):\\n        i = 0\\n        while i<len(s1) and i<len(s2) and s1[i]==s2[i]:\\n            i += 1\\n        return s1[:i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 777900,
                "title": "python-3-faster-than-85-less-than-95-memory-with-explanation",
                "content": "Ok, this was a tricky one. I am surprised it\\'s ranked easy. I made my algorithm, ran into an issue, peeked at discussions as I was convinced there should be a trick/easy way of doing it, realized no, went back and completed my solution. \\n\\nIt\\'s not the most elegant, sorry for the nested loops and if\\'s but let me know if you want further explanation.\\n\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        # compares first letter of all words, then moves to next letter\\n        s = \"\"\\n        if len(strs)==0: #edge case, no elements in list\\n            return s\\n        elif len(strs)==1: #edge case, single element in list\\n            return strs[0]\\n\\n        #word length of shortest word to prevent index out of range\\n        for a in range(len(min(strs))): \\n            #loops through each word in list, starting with second word\\n            for b in range(1, len(strs)): \\n                #compares nth character of first word to other words\\n                if strs[0][a]==strs[b][a]: \\n                    #only adds to pattern if nth character same up to the last word\\n                    if b==len(strs)-1: \\n                        s += strs[0][a]\\n                else: #exits when characters don\\'t match\\n                    return s\\n        return s\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        # compares first letter of all words, then moves to next letter\\n        s = \"\"\\n        if len(strs)==0: #edge case, no elements in list\\n            return s\\n        elif len(strs)==1: #edge case, single element in list\\n            return strs[0]\\n\\n        #word length of shortest word to prevent index out of range\\n        for a in range(len(min(strs))): \\n            #loops through each word in list, starting with second word\\n            for b in range(1, len(strs)): \\n                #compares nth character of first word to other words\\n                if strs[0][a]==strs[b][a]: \\n                    #only adds to pattern if nth character same up to the last word\\n                    if b==len(strs)-1: \\n                        s += strs[0][a]\\n                else: #exits when characters don\\'t match\\n                    return s\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7030,
                "title": "c-6-lines-o-n-len-of-prefix-most-optimal-i-can-think-of",
                "content": "I'm sure there is a more clever way, but this seems like the most optimal I can think of\\n* start at index 0\\n* check each string if they have the same char at the index\\n* if all have the same char increment the index\\n* terminate if any mismatch is found or any string has exceeded it's length\\n* also, avoids any string functions, adding strings, sub string, etc (except in my return)\\n\\nThis seems like it will terminate the quickest, as soon as any string runs out or any character is not a match.  It will do no unnecessary compares.\\n```\\n    public string LongestCommonPrefix(string[] strs) \\n    {\\n        int min = 0;\\n        while (strs.Length > 0)\\n        {\\n            foreach (string s in strs)\\n            {\\n                if (s.Length == min || s[min] != strs[0][min]) return strs[0].Substring(0, min);\\n            }\\n            min++;\\n        }\\n        return \"\";\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public string LongestCommonPrefix(string[] strs) \\n    {\\n        int min = 0;\\n        while (strs.Length > 0)\\n        {\\n            foreach (string s in strs)\\n            {\\n                if (s.Length == min || s[min] != strs[0][min]) return strs[0].Substring(0, min);\\n            }\\n            min++;\\n        }\\n        return \"\";\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2687169,
                "title": "javascript-solution",
                "content": "```\\nvar longestCommonPrefix = function(strs) {\\n    let cur = strs[0]\\n    let temp = \"\"\\n    for(let i = 1; i < strs.length; i++){\\n        for(let j = 0; j < cur.length; j++){\\n            if(cur[j] == strs[i][j]){\\n                temp += cur[j]\\n            } else {\\n                break\\n            }\\n        }\\n        cur = temp\\n        temp = \"\"\\n    }\\n    return cur\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestCommonPrefix = function(strs) {\\n    let cur = strs[0]\\n    let temp = \"\"\\n    for(let i = 1; i < strs.length; i++){\\n        for(let j = 0; j < cur.length; j++){\\n            if(cur[j] == strs[i][j]){\\n                temp += cur[j]\\n            } else {\\n                break\\n            }\\n        }\\n        cur = temp\\n        temp = \"\"\\n    }\\n    return cur\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2297953,
                "title": "python-91-45-fasters-python-simplest-solution-with-explanation-beg-to-adv-string-o-n",
                "content": "```python\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        res = \"\" #Taking a empty string for saving the result \\n        for i in zip(*strs): # check out the bottom of this artical for its explanation.\\n            a = \"\".join(i) # joining the result of zip, check out the example\\n            if len(set(a)) != 1: # this will checkout, if the elements of the all the provided string on a same level (i.e a[i][i]) are identical or not.  If its identical then will always be equal to one.\\n                return res\\n            else:\\n                res += a[0] # if we are having identical element in the string will add it to our resulting string.\\n\\n        return res\\n```\\n```python\\nzip(*strs)\\nThis will club each element of the string on the same together \\nIt will club the element till the len of shortest string available in the list.\\nExample:-\\nYour input\\n[\"flower\",\"flow\",\"flight\"]\\nstdout\\n(\\'f\\', \\'f\\', \\'f\\')\\n(\\'l\\', \\'l\\', \\'l\\')\\n(\\'o\\', \\'o\\', \\'i\\')\\n(\\'w\\', \\'w\\', \\'g\\')\\nHere, in the we were having \\'flow\\' as a shortest string and the zip clubed till its length. \\n```\\n\\n***Found helpful, Do upvote !!***\\n![image](https://assets.leetcode.com/users/images/dd2ce5b2-49e1-49be-8855-101c82825214_1658127524.888506.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```python\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        res = \"\" #Taking a empty string for saving the result \\n        for i in zip(*strs): # check out the bottom of this artical for its explanation.\\n            a = \"\".join(i) # joining the result of zip, check out the example\\n            if len(set(a)) != 1: # this will checkout, if the elements of the all the provided string on a same level (i.e a[i][i]) are identical or not.  If its identical then will always be equal to one.\\n                return res\\n            else:\\n                res += a[0] # if we are having identical element in the string will add it to our resulting string.\\n\\n        return res\\n```\n```python\\nzip(*strs)\\nThis will club each element of the string on the same together \\nIt will club the element till the len of shortest string available in the list.\\nExample:-\\nYour input\\n[\"flower\",\"flow\",\"flight\"]\\nstdout\\n(\\'f\\', \\'f\\', \\'f\\')\\n(\\'l\\', \\'l\\', \\'l\\')\\n(\\'o\\', \\'o\\', \\'i\\')\\n(\\'w\\', \\'w\\', \\'g\\')\\nHere, in the we were having \\'flow\\' as a shortest string and the zip clubed till its length. \\n```",
                "codeTag": "Java"
            },
            {
                "id": 934491,
                "title": "python-trie-solution",
                "content": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.endOfWord = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, word):\\n        root = self.root\\n        for ch in word:\\n            if ch not in root.children:\\n                root.children[ch] = TrieNode()\\n            root = root.children[ch]\\n        root.endOfWord = True\\n        \\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if not strs:\\n            return \\'\\'\\n        \\n        trie = Trie()\\n        \\n        for word in strs:\\n            trie.insert(word)\\n            \\n        root = trie.root\\n        res = \\'\\'\\n        while root:\\n            if len(root.children) > 1 or root.endOfWord:\\n                return res\\n            \\n            key = list(root.children)[0]\\n            res += key\\n            \\n            root = root.children[key]\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.endOfWord = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, word):\\n        root = self.root\\n        for ch in word:\\n            if ch not in root.children:\\n                root.children[ch] = TrieNode()\\n            root = root.children[ch]\\n        root.endOfWord = True\\n        \\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if not strs:\\n            return \\'\\'\\n        \\n        trie = Trie()\\n        \\n        for word in strs:\\n            trie.insert(word)\\n            \\n        root = trie.root\\n        res = \\'\\'\\n        while root:\\n            if len(root.children) > 1 or root.endOfWord:\\n                return res\\n            \\n            key = list(root.children)[0]\\n            res += key\\n            \\n            root = root.children[key]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7177,
                "title": "6-line-c-lightening-fast",
                "content": "    string longestCommonPrefix(vector<string>& strs) {\\n            if (strs.size()==0) return \"\";\\n            for (int i=0; i<strs[0].length(); i++)\\n                for (int j=0; j<strs.size(); j++)\\n                    if ( !(i<strs[j].length() && strs[0][i]==strs[j][i]) )\\n                        return strs[0].substr(0, i);\\n            return strs[0];\\n        }",
                "solutionTags": [],
                "code": "    string longestCommonPrefix(vector<string>& strs) {\\n            if (strs.size()==0) return \"\";\\n            for (int i=0; i<strs[0].length(); i++)\\n                for (int j=0; j<strs.size(); j++)\\n                    if ( !(i<strs[j].length() && strs[0][i]==strs[j][i]) )\\n                        return strs[0].substr(0, i);\\n            return strs[0];\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3914585,
                "title": "c-beginner-friendly-beats-100-of-c-users",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen you sort an array, it is enough to check for the common characters of the the first & last string of the sorted vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) \\n    {\\n        sort(str.begin(), str.end()); //sorting the array\\n        string ans=\"\"; //creating a new empty string to store the common prefixes\\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\\n        {\\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\\n                break;\\n            ans+=str[0][i]; // concatinate if the characters are matching\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) \\n    {\\n        sort(str.begin(), str.end()); //sorting the array\\n        string ans=\"\"; //creating a new empty string to store the common prefixes\\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\\n        {\\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\\n                break;\\n            ans+=str[0][i]; // concatinate if the characters are matching\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2745752,
                "title": "python-short-simple",
                "content": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        shortest = min(strs,key=len)\\n        for i, ch in enumerate(shortest):\\n            for other in strs:\\n                if other[i] != ch:\\n                    return shortest[:i]\\n        return shortest \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        shortest = min(strs,key=len)\\n        for i, ch in enumerate(shortest):\\n            for other in strs:\\n                if other[i] != ch:\\n                    return shortest[:i]\\n        return shortest \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330097,
                "title": "c-java-python3-javascript-solution-explanation",
                "content": "**Which have included C#, Java, Python3,JavaScript solutions**\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-14-longest-common-prefix-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-14-longest-common-prefix-solution-and-explanation-en/)\\u2B50**\\n\\n\\n#### Example : Java Code \\u27A1 Runtime : 1ms\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        for (int i = 0; i < strs[0].length(); i++) \\n        {\\n            char tmpChar = strs[0].charAt(i); \\n            for (int j = 0; j < strs.length; j++) \\n            {\\n                if (strs[j].length() == i || strs[j].charAt(i) != tmpChar) \\n                {\\n                    return strs[0].substring(0, i);\\n                }\\n            }\\n        }\\n        return strs[0]; \\n    }\\n}\\n```\\n**You can find a faster Java solution in the link.**\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to leave your comment.\\n\\n**\\uD83E\\uDDE1See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        for (int i = 0; i < strs[0].length(); i++) \\n        {\\n            char tmpChar = strs[0].charAt(i); \\n            for (int j = 0; j < strs.length; j++) \\n            {\\n                if (strs[j].length() == i || strs[j].charAt(i) != tmpChar) \\n                {\\n                    return strs[0].substring(0, i);\\n                }\\n            }\\n        }\\n        return strs[0]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982614,
                "title": "kotlin-o-s-4-lines",
                "content": "```\\nclass Solution {\\n    fun longestCommonPrefix(strs: Array<String>): String {\\n        val w = strs[0]\\n        w.forEachIndexed { i, c ->\\n            if (strs.any { it.length == i || it[i] != c } ) return w.substring(0, i)\\n        }\\n        return w\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun longestCommonPrefix(strs: Array<String>): String {\\n        val w = strs[0]\\n        w.forEachIndexed { i, c ->\\n            if (strs.any { it.length == i || it[i] != c } ) return w.substring(0, i)\\n        }\\n        return w\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888715,
                "title": "100-fastest-typescript-solution",
                "content": "```\\nfunction longestCommonPrefix(strings: string[]): string {\\n  if (strings.length === 0) { return \"\" }\\n  if (strings.length === 1) { return strings[0] }\\n  let possiblePrefix = \"\"\\n  \\n  while (strings.every((str) => str.startsWith(possiblePrefix))) {\\n    const newPossiblePrefix = strings[0].substr(0, possiblePrefix.length + 1)\\n\\n    if (newPossiblePrefix.length > possiblePrefix.length) {\\n      possiblePrefix = newPossiblePrefix\\n    } else if (newPossiblePrefix.length === possiblePrefix.length) {\\n      return possiblePrefix\\n    } else { break }\\n  }\\n\\n  return possiblePrefix.slice(0, -1)\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction longestCommonPrefix(strings: string[]): string {\\n  if (strings.length === 0) { return \"\" }\\n  if (strings.length === 1) { return strings[0] }\\n  let possiblePrefix = \"\"\\n  \\n  while (strings.every((str) => str.startsWith(possiblePrefix))) {\\n    const newPossiblePrefix = strings[0].substr(0, possiblePrefix.length + 1)\\n\\n    if (newPossiblePrefix.length > possiblePrefix.length) {\\n      possiblePrefix = newPossiblePrefix\\n    } else if (newPossiblePrefix.length === possiblePrefix.length) {\\n      return possiblePrefix\\n    } else { break }\\n  }\\n\\n  return possiblePrefix.slice(0, -1)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1678669,
                "title": "easy-and-optimized-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) {\\n        int n = str.size();\\n        string ans  = \"\";\\n        sort(begin(str), end(str));\\n        string a = str[0];\\n        string b = str[n-1];\\n        for(int i=0; i<a.size(); i++){\\n            if(a[i]==b[i]) ans = ans + a[i];\\n            else break;\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) {\\n        int n = str.size();\\n        string ans  = \"\";\\n        sort(begin(str), end(str));\\n        string a = str[0];\\n        string b = str[n-1];\\n        for(int i=0; i<a.size(); i++){\\n            if(a[i]==b[i]) ans = ans + a[i];\\n            else break;\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1174581,
                "title": "0ms-faster-than-100-longest-common-prefix-java-soln",
                "content": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if(strs.length == 0) return \"\";\\n        String prefix = strs[0];\\n        for(int i=1; i< strs.length; i++ ) {\\n            while(strs[i].indexOf(prefix) != 0) {\\n                prefix = prefix.substring(0, prefix.length()-1);\\n            }\\n        }\\n        \\n        return prefix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if(strs.length == 0) return \"\";\\n        String prefix = strs[0];\\n        for(int i=1; i< strs.length; i++ ) {\\n            while(strs[i].indexOf(prefix) != 0) {\\n                prefix = prefix.substring(0, prefix.length()-1);\\n            }\\n        }\\n        \\n        return prefix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 702828,
                "title": "easy-js-solution",
                "content": "```\\nvar longestCommonPrefix = function(arr) {\\n    if (!arr.length) return \"\";\\n    let prefix = \"\";\\n    for (let i = 0; i < arr[0].length; i++) {\\n        for (let j = 0; j < arr.length-1; j++) {\\n            if (arr[j][i] !== arr[j+1][i]) return prefix;\\n        }\\n        prefix += arr[0][i];\\n    }\\n    return prefix;\\n    // Time Complexity: O(M*N), M = length of shortest word, N = length of given array\\n    // Space Complexity: O(1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestCommonPrefix = function(arr) {\\n    if (!arr.length) return \"\";\\n    let prefix = \"\";\\n    for (let i = 0; i < arr[0].length; i++) {\\n        for (let j = 0; j < arr.length-1; j++) {\\n            if (arr[j][i] !== arr[j+1][i]) return prefix;\\n        }\\n        prefix += arr[0][i];\\n    }\\n    return prefix;\\n    // Time Complexity: O(M*N), M = length of shortest word, N = length of given array\\n    // Space Complexity: O(1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 7004,
                "title": "my-2ms-java-solution-may-help-u",
                "content": "    public class Solution {\\n        public String longestCommonPrefix(String[] strs) {\\n            int len = strs.length;\\n    \\t\\tif (len == 0)\\n    \\t\\t\\treturn \"\";\\n    \\t\\tint minlen = 0x7fffffff;\\n    \\t\\tfor (int i = 0; i < len; ++i) \\n    \\t\\t\\tminlen = Math.min(minlen, strs[i].length());\\n    \\t\\tfor (int j = 0; j < minlen; ++j) \\n    \\t\\t\\tfor (int i = 1; i < len; ++i) \\n    \\t\\t\\t\\tif (strs[0].charAt(j) != strs[i].charAt(j)) \\n    \\t\\t\\t\\t\\treturn strs[0].substring(0, j);\\n    \\t\\treturn strs[0].substring(0, minlen);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String longestCommonPrefix(String[] strs) {\\n            int len = strs.length;\\n    \\t\\tif (len == 0)\\n    \\t\\t\\treturn \"\";\\n    \\t\\tint minlen = 0x7fffffff;\\n    \\t\\tfor (int i = 0; i < len; ++i) \\n    \\t\\t\\tminlen = Math.min(minlen, strs[i].length());\\n    \\t\\tfor (int j = 0; j < minlen; ++j) \\n    \\t\\t\\tfor (int i = 1; i < len; ++i) \\n    \\t\\t\\t\\tif (strs[0].charAt(j) != strs[i].charAt(j)) \\n    \\t\\t\\t\\t\\treturn strs[0].substring(0, j);\\n    \\t\\treturn strs[0].substring(0, minlen);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 7240,
                "title": "short-accepted-cpp-solution",
                "content": "     string longestCommonPrefix(vector<string> &strs) {\\n            string prefix = \"\";\\n            if(strs.empty()) return prefix;\\n            for(int j = 0; j < strs[0].length(); ++j)\\n            {\\n                for(int i = 1; i < strs.size(); ++i){\\n                    if(j >= strs[i].size() || strs[i][j] != strs[0][j])\\n                       return prefix;\\n                }\\n                prefix += strs[0][j];\\n            }\\n            return prefix;\\n        }",
                "solutionTags": [
                    "C++"
                ],
                "code": "     string longestCommonPrefix(vector<string> &strs) {\\n            string prefix = \"\";\\n            if(strs.empty()) return prefix;\\n            for(int j = 0; j < strs[0].length(); ++j)\\n            {\\n                for(int i = 1; i < strs.size(); ++i){\\n                    if(j >= strs[i].size() || strs[i][j] != strs[0][j])\\n                       return prefix;\\n                }\\n                prefix += strs[0][j];\\n            }\\n            return prefix;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3946986,
                "title": "java-runtime-1-ms-beats-82-61",
                "content": "# Intuition\\nMy initial thoughts on solving this problem involve finding the longest common prefix among a given array of strings. I plan to sort the array first to bring the strings with the common prefix closer to each other. Then, I will compare the first and last strings in the sorted array to find the common prefix.\\n\\n# Approach\\nI will sort the array of strings to ensure that the strings with the longest common prefix are close to each other. After sorting, I will take the first and last strings and compare their characters one by one until I encounter a mismatch. I will keep track of the count of matching characters to determine the length of the common prefix.\\n\\n# Complexity\\n- Time complexity: O(n * m)\\nHere, \\'n\\' is the number of strings in the array and \\'m\\' is the average length of the strings. Sorting the array takes O(n * log n) time, and then comparing the characters in the common prefix takes O(m) time. Thus, the overall time complexity is O(n * log n + m), which can be approximated as O(n * m).\\n\\n- Space complexity: O(1)\\n  The algorithm uses a constant amount of extra space for variables.\\n\\n# Code\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        int count  = 0;\\n\\n        Arrays.sort(strs);\\n\\n        String start = strs[0];\\n\\n        String end  = strs[strs.length-1];\\n\\n        int i = 0 ;\\n        while (i<start.length() && i<end.length()){\\n\\n            if(start.charAt(i) == end.charAt(i)){\\n\\n                count++;\\n                i++;\\n            }\\n            else {\\n                break;\\n            }\\n\\n\\n        }\\n\\n        return start.substring(0,count);\\n        \\n\\n    }\\n}\\n```\\n![c0504eaf-5fb8-4a1d-a769-833262d1b86e_1674433591.3836212.webp](https://assets.leetcode.com/users/images/8a3b41d1-f0ca-472f-a9f7-8346b34a824e_1693297402.2918687.webp)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        int count  = 0;\\n\\n        Arrays.sort(strs);\\n\\n        String start = strs[0];\\n\\n        String end  = strs[strs.length-1];\\n\\n        int i = 0 ;\\n        while (i<start.length() && i<end.length()){\\n\\n            if(start.charAt(i) == end.charAt(i)){\\n\\n                count++;\\n                i++;\\n            }\\n            else {\\n                break;\\n            }\\n\\n\\n        }\\n\\n        return start.substring(0,count);\\n        \\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451292,
                "title": "best-solution-by-java-in-runtime-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n         if (strs.length == 0){\\n                return \"\";\\n            }\\n\\n            String prefix = strs[0];\\n            int length = prefix.length();\\n\\n        for (int i = 1; i < strs.length; i++) {\\n            while (strs[i].indexOf(prefix) != 0){\\n                prefix = prefix.substring(0 , --length);\\n                if (length == 0){\\n                    return \"\";\\n                }\\n            }\\n            \\n        }\\n\\n        return prefix;\\n    }\\n}\\n```\\n\\n![b0e5afaa-48ec-4dcc-bd96-e39aa7a524f8_1681948924.2890832.png](https://assets.leetcode.com/users/images/7e978d3c-4abb-4d64-bb09-e5dfbf33b86d_1682356180.961795.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n         if (strs.length == 0){\\n                return \"\";\\n            }\\n\\n            String prefix = strs[0];\\n            int length = prefix.length();\\n\\n        for (int i = 1; i < strs.length; i++) {\\n            while (strs[i].indexOf(prefix) != 0){\\n                prefix = prefix.substring(0 , --length);\\n                if (length == 0){\\n                    return \"\";\\n                }\\n            }\\n            \\n        }\\n\\n        return prefix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684788,
                "title": "java-solution-simple-with-explanation-69-faster-then-other-9-line-code",
                "content": "![image](https://assets.leetcode.com/users/images/aafcadf5-cd6a-4bb6-ac77-7b3e89ffd06e_1665384459.5574121.png)\\n\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String r=\"\";\\n        int n=strs.length;\\n        Arrays.sort(strs);//Sorted first\\n        String s=strs[0];//smallest no of char\\n        String h=strs[n-1];//highest no of char\\n        for(int i =0;i<s.length();i++)//taken smallest length so that run time will be less\\n        {\\n            if(s.charAt(i)!=h.charAt(i)) break;\\n            r=r+s.charAt(i);  \\n        }\\n        return r;  \\n    }\\n}\\n\\n//Time complexity would be O(n)\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String r=\"\";\\n        int n=strs.length;\\n        Arrays.sort(strs);//Sorted first\\n        String s=strs[0];//smallest no of char\\n        String h=strs[n-1];//highest no of char\\n        for(int i =0;i<s.length();i++)//taken smallest length so that run time will be less\\n        {\\n            if(s.charAt(i)!=h.charAt(i)) break;\\n            r=r+s.charAt(i);  \\n        }\\n        return r;  \\n    }\\n}\\n\\n//Time complexity would be O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266870,
                "title": "c-using-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int n=strs.size();\\n        string ans=\"\";\\n        sort(strs.begin(),strs.end());\\n        \\n        string a=strs[0];\\n        string b=strs[n-1];\\n        \\n        for(int i=0;i<a.size();i++)\\n        {\\n            if(a[i]==b[i])\\n            {\\n                ans+=a[i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nUpvote if you find it useful. \\uD83D\\uDE4C",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int n=strs.size();\\n        string ans=\"\";\\n        sort(strs.begin(),strs.end());\\n        \\n        string a=strs[0];\\n        string b=strs[n-1];\\n        \\n        for(int i=0;i<a.size();i++)\\n        {\\n            if(a[i]==b[i])\\n            {\\n                ans+=a[i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2264602,
                "title": "python-faster-98",
                "content": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        \\n        ans = \\'\\'\\n        for i,val in enumerate(zip(*strs)):\\n            if len(set(val)) == 1:\\n                ans+= val[0]\\n            else:\\n                break\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        \\n        ans = \\'\\'\\n        for i,val in enumerate(zip(*strs)):\\n            if len(set(val)) == 1:\\n                ans+= val[0]\\n            else:\\n                break\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726743,
                "title": "c-solution-with-easy-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Here we find the smallest string and store in `str` & it\\u2019s size to `mn`\\n- We use 2 loops to access all the strings, if any point character of every element in a index doesn\\'t match then we\\u2019ll return string till that index.\\n- **Time complexity:** O(n^2).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int n = strs.size();\\n        int mn = INT_MAX, count = 0;\\n        string str;\\n        \\n        for(int i=0; i<n; i++){\\n            if(mn > strs[i].size()){\\n                mn = strs[i].size();\\n                str = strs[i];\\n            }\\n        }\\n        \\n        for(int i=0; i<mn; i++){\\n            for(int j=0; j<n; j++){\\n                if(strs[j][i] != str[i])\\n                    return str.substr(0, count);\\n            }\\n            count++;\\n        }\\n        return str.substr(0,count);        \\n    }\\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int n = strs.size();\\n        int mn = INT_MAX, count = 0;\\n        string str;\\n        \\n        for(int i=0; i<n; i++){\\n            if(mn > strs[i].size()){\\n                mn = strs[i].size();\\n                str = strs[i];\\n            }\\n        }\\n        \\n        for(int i=0; i<mn; i++){\\n            for(int j=0; j<n; j++){\\n                if(strs[j][i] != str[i])\\n                    return str.substr(0, count);\\n            }\\n            count++;\\n        }\\n        return str.substr(0,count);        \\n    }\\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 404383,
                "title": "python3-short-expressive-and-fast-solution-faster-than-99-73",
                "content": "```python\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n      prefix = \\'\\'\\n      for cmbn in zip(*strs):\\n        if len(set(cmbn)) > 1:\\n          break\\n        prefix += cmbn[0]\\n      return prefix\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n      prefix = \\'\\'\\n      for cmbn in zip(*strs):\\n        if len(set(cmbn)) > 1:\\n          break\\n        prefix += cmbn[0]\\n      return prefix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 389414,
                "title": "easy-c-solution-4ms",
                "content": "Runtime: 4 ms, faster than 94.85% of C++ online submissions for Longest Common Prefix.\\nMemory Usage: 8.8 MB, less than 87.10% of C++ online submissions for Longest Common Prefix.\\n\\n```\\nstring longestCommonPrefix(vector<string>& strs) {\\n        \\n        if(strs.empty()) return \"\";\\n        \\n        for(int i=0; ; i++)\\n        {\\n            for(auto& s : strs)\\n            {\\n                if(i >= s.size() || s[i] != strs[0][i])\\n                    return strs[0].substr(0,i);\\n            }\\n        }\\n        \\n        return \"\";\\n    }",
                "solutionTags": [],
                "code": "Runtime: 4 ms, faster than 94.85% of C++ online submissions for Longest Common Prefix.\\nMemory Usage: 8.8 MB, less than 87.10% of C++ online submissions for Longest Common Prefix.\\n\\n```\\nstring longestCommonPrefix(vector<string>& strs) {\\n        \\n        if(strs.empty()) return \"\";\\n        \\n        for(int i=0; ; i++)\\n        {\\n            for(auto& s : strs)\\n            {\\n                if(i >= s.size() || s[i] != strs[0][i])\\n                    return strs[0].substr(0,i);\\n            }\\n        }\\n        \\n        return \"\";\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 164655,
                "title": "javascript-solution",
                "content": "```\\nvar longestCommonPrefix = function(strs) {\\n    if(!strs[0]) return \"\";\\n    let res = \"\";\\n    let cur = \"\";\\n    let i = 0;\\n    while(i < strs[0].length){\\n        cur = strs[0].substring(0, i + 1);\\n        let flag = strs.every(x => {\\n            return x.startsWith(cur);\\n        })\\n        if(flag === true){\\n            res = cur;\\n        }\\n        else break;\\n        i ++;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar longestCommonPrefix = function(strs) {\\n    if(!strs[0]) return \"\";\\n    let res = \"\";\\n    let cur = \"\";\\n    let i = 0;\\n    while(i < strs[0].length){\\n        cur = strs[0].substring(0, i + 1);\\n        let flag = strs.every(x => {\\n            return x.startsWith(cur);\\n        })\\n        if(flag === true){\\n            res = cur;\\n        }\\n        else break;\\n        i ++;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6934,
                "title": "simple-python-sol-32-ms",
                "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        result = \"\"       \\n        for n in zip(*strs):\\n            if len(set(n)) == 1:\\n                result += n[0]\\n            else:\\n                return result\\n        return result  \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        result = \"\"       \\n        for n in zip(*strs):\\n            if len(set(n)) == 1:\\n                result += n[0]\\n            else:\\n                return result\\n        return result  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825300,
                "title": "most-easy-javascript-solution-beat-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n    if(!strs.length) return \\'\\'\\n    let longerstCommonPrefix = \\'\\'\\n    for(let i=0; i< strs[0].length; i++) {\\n        let char = strs[0][i]\\n        if(!char) return \\'\\'\\n        if(strs.every(str => str[i] === char)) {\\n            longerstCommonPrefix+=char\\n        } else break\\n    }\\n    return longerstCommonPrefix\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n    if(!strs.length) return \\'\\'\\n    let longerstCommonPrefix = \\'\\'\\n    for(let i=0; i< strs[0].length; i++) {\\n        let char = strs[0][i]\\n        if(!char) return \\'\\'\\n        if(strs.every(str => str[i] === char)) {\\n            longerstCommonPrefix+=char\\n        } else break\\n    }\\n    return longerstCommonPrefix\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3386001,
                "title": "java-solution",
                "content": "# Complexity\\n- Time complexity: O(S * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if (strs == null || strs.length == 0) {\\n            return \"\";\\n        }\\n\\n        String prefix = strs[0];\\n\\n        for (int i = 1; i < strs.length; i++) {\\n            while (!strs[i].startsWith(prefix)) {\\n                prefix = prefix.substring(0, prefix.length() - 1);\\n                if (prefix.isEmpty()) {\\n                    return \"\";\\n                }\\n            }\\n        }\\n\\n        return prefix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if (strs == null || strs.length == 0) {\\n            return \"\";\\n        }\\n\\n        String prefix = strs[0];\\n\\n        for (int i = 1; i < strs.length; i++) {\\n            while (!strs[i].startsWith(prefix)) {\\n                prefix = prefix.substring(0, prefix.length() - 1);\\n                if (prefix.isEmpty()) {\\n                    return \"\";\\n                }\\n            }\\n        }\\n\\n        return prefix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359811,
                "title": "simple-go-solution",
                "content": "# Code\\n```\\nfunc longestCommonPrefix(s []string) string {\\n\\tpref := s[0]\\n\\tfor i := 1; i < len(s); i++ {\\n\\t\\tfor !strings.HasPrefix(s[i], pref) {\\n\\t\\t\\tpref = pref[:len(pref)-1]\\n\\t\\t}\\n\\t\\tfmt.Println(s[i])\\n\\t}\\n\\treturn pref\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc longestCommonPrefix(s []string) string {\\n\\tpref := s[0]\\n\\tfor i := 1; i < len(s); i++ {\\n\\t\\tfor !strings.HasPrefix(s[i], pref) {\\n\\t\\t\\tpref = pref[:len(pref)-1]\\n\\t\\t}\\n\\t\\tfmt.Println(s[i])\\n\\t}\\n\\treturn pref\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2269966,
                "title": "java-better-than-100",
                "content": "An upvote would be appreciated, Thank you!\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if(strs.length == 0)\\n        {\\n            return \"\";\\n        }\\n        String prefix=strs[0];\\n        for(int i=1;i<strs.length;i++)\\n        {\\n            while(strs[i].indexOf(prefix)!=0)\\n            {\\n                prefix=prefix.substring(0,prefix.length()-1);\\n            }\\n        }\\n        return prefix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if(strs.length == 0)\\n        {\\n            return \"\";\\n        }\\n        String prefix=strs[0];\\n        for(int i=1;i<strs.length;i++)\\n        {\\n            while(strs[i].indexOf(prefix)!=0)\\n            {\\n                prefix=prefix.substring(0,prefix.length()-1);\\n            }\\n        }\\n        return prefix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141240,
                "title": "c-java-python3-solution-explanation",
                "content": "Here\\'s my blog written on 2022/06/12\\nWhich have include C#, Java, Python3 (JavaScript version will be updated in few days)\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-14-longest-common-prefix-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-14-longest-common-prefix-solution-and-explanation-en/)\\u2B50\\n\\n#### Example : Java Code \\u27A1 Runtime : 1ms\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        for (int i = 0; i < strs[0].length(); i++) \\n        {\\n            char tmpChar = strs[0].charAt(i); \\n            for (int j = 0; j < strs.length; j++) \\n            {\\n                if (strs[j].length() == i || strs[j].charAt(i) != tmpChar) \\n                {\\n                    return strs[0].substring(0, i);\\n                }\\n            }\\n        }\\n        return strs[0]; \\n    }\\n}\\n```\\n**You can find a faster solution in the link.**\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to leave your comment.\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        for (int i = 0; i < strs[0].length(); i++) \\n        {\\n            char tmpChar = strs[0].charAt(i); \\n            for (int j = 0; j < strs.length; j++) \\n            {\\n                if (strs[j].length() == i || strs[j].charAt(i) != tmpChar) \\n                {\\n                    return strs[0].substring(0, i);\\n                }\\n            }\\n        }\\n        return strs[0]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899592,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func longestCommonPrefix(_ strs: [String]) -> String {\\n        guard strs.count > 0 else { return \"\" }\\n        let chars_array = strs.map({ Array($0) })\\n        var string = \"\"\\n        var i = 0\\n        \\n        while true {\\n            var c: Character? = nil\\n            for chars in chars_array {\\n                if i >= chars.count {\\n                    return string\\n                } else {\\n                    if c == nil {\\n                        c = chars[i]\\n                    } else if chars[i] != c! { return string }\\n                }  \\n            }\\n            string += String(c!)\\n            i += 1\\n        }\\n        \\n        return string\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func longestCommonPrefix(_ strs: [String]) -> String {\\n        guard strs.count > 0 else { return \"\" }\\n        let chars_array = strs.map({ Array($0) })\\n        var string = \"\"\\n        var i = 0\\n        \\n        while true {\\n            var c: Character? = nil\\n            for chars in chars_array {\\n                if i >= chars.count {\\n                    return string\\n                } else {\\n                    if c == nil {\\n                        c = chars[i]\\n                    } else if chars[i] != c! { return string }\\n                }  \\n            }\\n            string += String(c!)\\n            i += 1\\n        }\\n        \\n        return string\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1751555,
                "title": "js-easy-clean-solution",
                "content": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n    let firstStr = strs[0];\\n    for (let i = 0; i < firstStr.length; i++) {\\n        for (let s of strs) {\\n            if (s[i] !== firstStr[i]) return s.slice(0, i);\\n        }\\n    }\\n    return strs[0];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n    let firstStr = strs[0];\\n    for (let i = 0; i < firstStr.length; i++) {\\n        for (let s of strs) {\\n            if (s[i] !== firstStr[i]) return s.slice(0, i);\\n        }\\n    }\\n    return strs[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 773126,
                "title": "python-sol-by-column-wise-slicing-w-comment",
                "content": "Python sol by column-wise slicing\\n\\n---\\n\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n\\t\\t\\n\\t\\t# generate column-wise slicing\\n        column_slices, common_prefix = zip(*strs), \\'\\'\\n        \\n        for current_column in column_slices:\\n            \\n            if len(set(current_column)) == 1:\\n\\t\\t\\t\\t# current column-wise slice\\'s character is the same\\n\\t\\t\\t\\t# update common prefix\\n                common_prefix += current_column[0]\\n            \\n            else:\\n\\t\\t\\t\\t# current column-wise slice\\'s character is different\\n                break\\n                \\n        return common_prefix\\n```\\n\\n---\\n\\n**Demo of zip(...)**, auto-align on length:\\n\\n![image](https://assets.leetcode.com/users/images/214b59f5-7200-435b-a974-1555668c69d5_1596559716.3218155.png)\\n\\n\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about zip( ... )](https://docs.python.org/3.3/library/functions.html#zip)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n\\t\\t\\n\\t\\t# generate column-wise slicing\\n        column_slices, common_prefix = zip(*strs), \\'\\'\\n        \\n        for current_column in column_slices:\\n            \\n            if len(set(current_column)) == 1:\\n\\t\\t\\t\\t# current column-wise slice\\'s character is the same\\n\\t\\t\\t\\t# update common prefix\\n                common_prefix += current_column[0]\\n            \\n            else:\\n\\t\\t\\t\\t# current column-wise slice\\'s character is different\\n                break\\n                \\n        return common_prefix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 291314,
                "title": "ruby-solution",
                "content": "Take a base string (the first element in the array). Go through the the base string, and through each iteration check if the letter at index `i` exists in all the other words in the array. If it does, append it to the string `s`. If you reach a case where the letter at index `i` does not exist in some word in the array, break. \\n```\\ndef longest_common_prefix(strs)\\n    return \"\" if strs.empty? \\n    s = \"\"\\n    base = strs[0]\\n    for i in 0..base.length-1\\n        if strs.all?{|x| x[i] == base[i]}\\n            s += base[i]\\n        else\\n            break\\n        end\\n    end\\n    s\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef longest_common_prefix(strs)\\n    return \"\" if strs.empty? \\n    s = \"\"\\n    base = strs[0]\\n    for i in 0..base.length-1\\n        if strs.all?{|x| x[i] == base[i]}\\n            s += base[i]\\n        else\\n            break\\n        end\\n    end\\n    s\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 229160,
                "title": "python-7-lines-20ms-solution",
                "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        s = \\'\\'\\n        for i in zip(*strs):\\n            if len(set(i)) != 1:\\n                return s\\n            else:\\n                s += i[0]\\n        return s\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        s = \\'\\'\\n        for i in zip(*strs):\\n            if len(set(i)) != 1:\\n                return s\\n            else:\\n                s += i[0]\\n        return s\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 7066,
                "title": "my-simple-and-clean-c-code-solution",
                "content": "```   \\n string longestCommonPrefix(vector<string>& strs) {\\n        if(strs.empty()) return \"\";\\n        string res = strs[0];\\n        for(int i=0; i<strs.size();i++)\\n            for(int j=0; j<res.size();j++)\\n                if(strs[i][j]!=res[j]) {res.resize(j); break;}\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```   \\n string longestCommonPrefix(vector<string>& strs) {\\n        if(strs.empty()) return \"\";\\n        string res = strs[0];\\n        for(int i=0; i<strs.size();i++)\\n            for(int j=0; j<res.size();j++)\\n                if(strs[i][j]!=res[j]) {res.resize(j); break;}\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6968,
                "title": "simple-python-solution-using-min",
                "content": "    class Solution(object):\\n        def longestCommonPrefix(self, strs):\\n            if not strs: return ''\\n            first = min(strs)\\n            for i in range(len(first)):\\n                for s in strs:\\n                    if s[i] != first[i]:\\n                        return first[:i] if i > 0 else ''\\n            return first",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def longestCommonPrefix(self, strs):\\n            if not strs: return ''\\n            first = min(strs)\\n            for i in range(len(first)):\\n                for s in strs:\\n                    if s[i] != first[i]:\\n                        return first[:i] if i > 0 else ''\\n            return first",
                "codeTag": "Java"
            },
            {
                "id": 4062081,
                "title": "video-step-by-step-visualization-of-vertical-scanning-strategy",
                "content": "https://youtube.com/watch?v=SiNDN2M4dtQ\\n\\nThis solution is the <b>vertical scanning</b> approach that is discussed in the official solution, slightly modified for Python.  The idea is to scan the the first character of every word, then the second character, etc. until a mismatch is found.  At that point, we return a slice of the string which is the longest common prefix.\\n\\nThis is superior to horizontal scanning because even if a very short word is included in the array, the algorithm won\\'t do any extra work scanning the longer words and will still end when the end of the shortest word is reached.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        if len(strs) == 0:\\n            return \"\"\\n\\n        base = strs[0]\\n        for i in range(len(base)):\\n            for word in strs[1:]:\\n                if i == len(word) or word[i] != base[i]:\\n                    return base[0:i]\\n\\n        return base\\n  \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        if len(strs) == 0:\\n            return \"\"\\n\\n        base = strs[0]\\n        for i in range(len(base)):\\n            for word in strs[1:]:\\n                if i == len(word) or word[i] != base[i]:\\n                    return base[0:i]\\n\\n        return base\\n  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010931,
                "title": "5-liner-easy-approach-with-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Firstly I was very confused about the problem because I have ignored the word \"prefix\". Prefix means the starting letters of the word. \\n- So if the starting letter of any word in the array will not be matched then we will simply return empty string and if first word will be matched in the every array of strings using every method then we will look for the second word ans so on..\\n\\n# Code\\n```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function (strs) {\\n    let output = \"\";\\n    for (let i = 0; i < strs[0].length; i++) {\\n        if(strs.every(str => str[i] === strs[0][i])) output += strs[0][i];\\n        else break;\\n    }\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function (strs) {\\n    let output = \"\";\\n    for (let i = 0; i < strs[0].length; i++) {\\n        if(strs.every(str => str[i] === strs[0][i])) output += strs[0][i];\\n        else break;\\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3302948,
                "title": "c-solution-easy-to-understand-100-fast",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n       string ans=\"\";\\n        vector<int>len;     //To store the length of every string present in the vector;\\n        int row=strs.size();  //size of row;\\n        for(int i=0;i<rows;i++)\\n        {\\n             len.emplace_back(strs[i].length()); \\n        }\\n        sort(len.begin(),len.end());  //Sort the len vector to find the minimum size;\\n        int col=len[0];   //Store the minimum size in column ;\\n        bool flag=true;\\n        for(int i=0;i<col;i++)\\n        { //column wise traversal\\n            for(int j=1;j<row;j++)\\n            {\\n                //Check every element in the column if it is equal to its next element or not\\n            \\n                if(strs[j-1][i]!=strs[j][i]){  \\n                    //If elements are not equal then make flag = false and break the loop   \\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            if(flag==true) \\n             count++; //This will store the numbers of column which are equal\\n        }\\n\\n         ans=strs[0].substr(0,count); //take the substring(of size equal to count) from any string present in strs vector;\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n       string ans=\"\";\\n        vector<int>len;     //To store the length of every string present in the vector;\\n        int row=strs.size();  //size of row;\\n        for(int i=0;i<rows;i++)\\n        {\\n             len.emplace_back(strs[i].length()); \\n        }\\n        sort(len.begin(),len.end());  //Sort the len vector to find the minimum size;\\n        int col=len[0];   //Store the minimum size in column ;\\n        bool flag=true;\\n        for(int i=0;i<col;i++)\\n        { //column wise traversal\\n            for(int j=1;j<row;j++)\\n            {\\n                //Check every element in the column if it is equal to its next element or not\\n            \\n                if(strs[j-1][i]!=strs[j][i]){  \\n                    //If elements are not equal then make flag = false and break the loop   \\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            if(flag==true) \\n             count++; //This will store the numbers of column which are equal\\n        }\\n\\n         ans=strs[0].substr(0,count); //take the substring(of size equal to count) from any string present in strs vector;\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459950,
                "title": "python-85-fast-88-less-space-easy-to-understand",
                "content": "Upvote if it helped. Thanks\\n\\n![image](https://assets.leetcode.com/users/images/f1fd820f-92fe-4d2c-8adf-bb3757ca241f_1661100206.6040626.png)\\n\\n\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        prefix = \"\"\\n\\t\\t\\n\\t\\t#here zip function creates tuples of all the characters of the string index wise. \\n\\t\\t# s= ((\\'f\\',\\'f\\',\\'f\\'), (\\'l\\', \\'l\\', \\'l\\') ........)\\n\\t\\t\\n        s = zip(*strs)\\n        for i in s:\\n            if len(set(i)) ==1 :\\n                prefix += i[0]\\n            else:\\n                break\\n        return prefix\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        prefix = \"\"\\n\\t\\t\\n\\t\\t#here zip function creates tuples of all the characters of the string index wise. \\n\\t\\t# s= ((\\'f\\',\\'f\\',\\'f\\'), (\\'l\\', \\'l\\', \\'l\\') ........)\\n\\t\\t\\n        s = zip(*strs)\\n        for i in s:\\n            if len(set(i)) ==1 :\\n                prefix += i[0]\\n            else:\\n                break\\n        return prefix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2344186,
                "title": "most-optimal-solution-in-java",
                "content": "Easy code for all to understand.\\n\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if(strs.length == 0){\\n            return \"\";\\n        }\\n        String prefix = strs[0];\\n        for(String s : strs){\\n            int len = Math.min(prefix.length(), s.length());\\n            for(int i = len; i >= 0; i--){\\n                if(prefix.indexOf(s.substring(0, i)) == 0){\\n                    prefix = s.substring(0, i);\\n                    break;\\n                }\\n            }\\n        }\\n        return prefix;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if(strs.length == 0){\\n            return \"\";\\n        }\\n        String prefix = strs[0];\\n        for(String s : strs){\\n            int len = Math.min(prefix.length(), s.length());\\n            for(int i = len; i >= 0; i--){\\n                if(prefix.indexOf(s.substring(0, i)) == 0){\\n                    prefix = s.substring(0, i);\\n                    break;\\n                }\\n            }\\n        }\\n        return prefix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2244027,
                "title": "c-java-python3-javascript-solution-easy-code",
                "content": "**Which have included C#, Java, Python3,JavaScript solutions**\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-14-longest-common-prefix-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-14-longest-common-prefix-solution-and-explanation-en/)\\u2B50**\\n\\n\\n#### Example : Java Code \\u27A1 Runtime : 1ms\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        for (int i = 0; i < strs[0].length(); i++) \\n        {\\n            char tmpChar = strs[0].charAt(i); \\n            for (int j = 0; j < strs.length; j++) \\n            {\\n                if (strs[j].length() == i || strs[j].charAt(i) != tmpChar) \\n                {\\n                    return strs[0].substring(0, i);\\n                }\\n            }\\n        }\\n        return strs[0]; \\n    }\\n}\\n```\\n**You can find a faster Java solution in the link.**\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to leave your comment.\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        for (int i = 0; i < strs[0].length(); i++) \\n        {\\n            char tmpChar = strs[0].charAt(i); \\n            for (int j = 0; j < strs.length; j++) \\n            {\\n                if (strs[j].length() == i || strs[j].charAt(i) != tmpChar) \\n                {\\n                    return strs[0].substring(0, i);\\n                }\\n            }\\n        }\\n        return strs[0]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2241147,
                "title": "c-easy-simple-o-n-min-and-max-element",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n                \\n        string min=*min_element(strs.begin(),strs.end());  //smallest string\\n        string mx=*max_element(strs.begin(),strs.end()); //largest one\\n        \\n        int i=0;\\n        int j=0;\\n        \\n        while(i<min.size() and min[i]==mx[j]) {   //loop until characters are matching\\n            i++;\\n            j++;\\n        }\\n        return mx.substr(0,i);    //return substring till any index i or j answer will be same\\n    }\\n};\\n\\nif(helpful)\\n\\tupVote();",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n                \\n        string min=*min_element(strs.begin(),strs.end());  //smallest string\\n        string mx=*max_element(strs.begin(),strs.end()); //largest one\\n        \\n        int i=0;\\n        int j=0;\\n        \\n        while(i<min.size() and min[i]==mx[j]) {   //loop until characters are matching\\n            i++;\\n            j++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2204347,
                "title": "simple-javascript-solution-97-36-fast-with-95-67-less-memory-usage",
                "content": "![image](https://assets.leetcode.com/users/images/d638b758-4379-497b-a8a5-3b3843d0dcfe_1656320626.4312003.png)\\n\\n```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n  if(strs.length === 1) return strs[0];\\n  \\n  strs.sort();\\n\\n  const strLastIndex = strs.length - 1;\\n  if(strs[0] === strs[strLastIndex]) return strs[0];\\n  \\n  let prefix = \"\";\\n  for(let i=0; i < strs[0].length; i++) {\\n    if(strs[0][i] === strs[strLastIndex][i]) {\\n      prefix += strs[0][i];\\n    } else {\\n      return prefix;\\n    }\\n  }\\n  \\n  return prefix;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n  if(strs.length === 1) return strs[0];\\n  \\n  strs.sort();\\n\\n  const strLastIndex = strs.length - 1;\\n  if(strs[0] === strs[strLastIndex]) return strs[0];\\n  \\n  let prefix = \"\";\\n  for(let i=0; i < strs[0].length; i++) {\\n    if(strs[0][i] === strs[strLastIndex][i]) {\\n      prefix += strs[0][i];\\n    } else {\\n      return prefix;\\n    }\\n  }\\n  \\n  return prefix;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2019053,
                "title": "python-simplest-solution-in-o-nlog-n",
                "content": "Time: Avg case: O(nlog(n)) ; Worst case: O(mnlog(n)) [when all strings are of same size]; n: length of array; m: length of smallest string [Do correct me if I am wrong.]\\nSpace: O(1) on average; O(m) in worst case when all strings are same.; m: length of smallest string\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        strs.sort()\\n        pre = []\\n        \\n        for a,b in zip(strs[0], strs[-1]):\\n            if a == b:\\n                pre.append(a)\\n            else:\\n                break\\n        \\n        return \"\".join(pre)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        strs.sort()\\n        pre = []\\n        \\n        for a,b in zip(strs[0], strs[-1]):\\n            if a == b:\\n                pre.append(a)\\n            else:\\n                break\\n        \\n        return \"\".join(pre)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995677,
                "title": "c-100-faster-solution-explained",
                "content": "# C++ 100% Faster Solution Explained\\nWrite a function to find the longest common prefix string amongst an array of strings.\\nIf there is no common prefix, return an empty string \"\".\\n## Ex:\\n\\n\\tInput: strs = [\"flower\",\"flow\",\"flight\"]\\n\\tOutput: \"fl\"\\n\\n## Solution Logic:\\nThe coding for this solution is easy using the <b><a href=\"https://www.cplusplus.com/doc/tutorial/control/\">For Loop</a></b> to handle iteration. When we focus on the logic behind this problem, we must remember to account for all possible versions of the intput and how to deal with it:\\n### Iterating through everything - For Loops\\n<li>The <b>given vector has an undefined amount of elements</b>, and we must compare them all - therefore we cannot hardcode x number of comparisions between x number of strings\\n<li>We <b>only need to iterate to the end of one word</b> because <b>all words</b> must be equal - so if one word reaches the end, it cannot possibly be the same as the rest beyond its length\\n<li>Make sure the for-loops incase everything. <b>We must first iterate over the length of a string, then over the size of the vector</b> for desired results. Otherwise, if we swap the loops, the program will stop comparing the characters of the strings at the position equal to the length of the vector. EG: if we receive 3 strings of 10 letters each, the program will only compare the first 3 letters of each string rather than the entire string.\\n<br></br>\\n\\n### How to Tell When We Found the Largest Prefix - If Statement\\n<li>We reach a <b>position where the character</b> at that position in every given string <b>is not the same</b>\\n<li>We <b>reach the end of any string</b> - as anything beyond it does not exist to be the same as other strings\\n<br></br>\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring longestCommonPrefix(vector<string>& strs) {\\n\\t\\t\\t//pos keeps track of the end of the common prefix, starts at 0 since its a prefix\\n\\t\\t\\tfor(int pos = 0; pos < strs[0].length(); ++pos) //iterates over the length of the first word\\n\\t\\t\\t\\tfor(int i = 1; i < strs.size(); ++i) //for all of the strings in the vector\\n\\t\\t\\t\\t\\t//compare each char of the first string to the char at the same pos in each following string\\n\\t\\t\\t\\t\\t//if we reach the end of any string or a pos where the chars do not match, we have the largest prefix\\n\\t\\t\\t\\t\\tif(pos == strs[i].length() || strs[i][pos] != strs[0][pos])\\n\\t\\t\\t\\t\\t\\treturn strs[0].substr(0, pos);\\n\\t\\t\\treturn strs[0];\\n\\t\\t}\\n\\t};\\n\\t\\nIf there\\'s anyway to explain this better please let my pea brain know thanks. If this helped and you have a moment, <b>please upvote so my professor knows I did my homework</b>. Thanks.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring longestCommonPrefix(vector<string>& strs) {\\n\\t\\t\\t//pos keeps track of the end of the common prefix, starts at 0 since its a prefix\\n\\t\\t\\tfor(int pos = 0; pos < strs[0].length(); ++pos) //iterates over the length of the first word\\n\\t\\t\\t\\tfor(int i = 1; i < strs.size(); ++i) //for all of the strings in the vector\\n\\t\\t\\t\\t\\t//compare each char of the first string to the char at the same pos in each following string\\n\\t\\t\\t\\t\\t//if we reach the end of any string or a pos where the chars do not match, we have the largest prefix\\n\\t\\t\\t\\t\\tif(pos == strs[i].length() || strs[i][pos] != strs[0][pos])\\n\\t\\t\\t\\t\\t\\treturn strs[0].substr(0, pos);\\n\\t\\t\\treturn strs[0];\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1663118,
                "title": "javascript-simple-solution-using-every-function",
                "content": "```\\nvar longestCommonPrefix = function(strs) {\\n    let prefix = \\'\\';\\n    \\n    for (let i = 0; i <= strs[0].length; i++) {\\n        const nextPrefix = strs[0].slice(0, i);\\n        \\n        if (strs.every(str => str.slice(0, i) === nextPrefix)) {\\n            prefix = nextPrefix;\\n        } else {\\n            break;\\n        }\\n    }\\n    \\n    return prefix;\\n};\\n```\\n\\nThe idea is to slice strings char by char, and using the `.every()` function to compare if each inputed strings have the same slices.\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestCommonPrefix = function(strs) {\\n    let prefix = \\'\\';\\n    \\n    for (let i = 0; i <= strs[0].length; i++) {\\n        const nextPrefix = strs[0].slice(0, i);\\n        \\n        if (strs.every(str => str.slice(0, i) === nextPrefix)) {\\n            prefix = nextPrefix;\\n        } else {\\n            break;\\n        }\\n    }\\n    \\n    return prefix;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1585205,
                "title": "c-short-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string prefix = \"\";\\n        for(int i=0;i<strs[0].size();++i){\\n            for(int j=1;j<strs.size();++j){\\n                if(strs[j][i]!=strs[0][i]) return prefix;\\n            }\\n              prefix+=strs[0][i];\\n        }\\n        return prefix;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string prefix = \"\";\\n        for(int i=0;i<strs[0].size();++i){\\n            for(int j=1;j<strs.size();++j){\\n                if(strs[j][i]!=strs[0][i]) return prefix;\\n            }\\n              prefix+=strs[0][i];\\n        }\\n        return prefix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1410235,
                "title": "javascript-simple-solution",
                "content": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n    let prefix = \\'\\';\\n    if (strs.length === 1) return strs[0];\\n    for (let i = 0; i < strs[0].length; i++) {\\n        let currentChar = strs[0][i];\\n        if (currentChar && strs.every((s) => s[i] == currentChar)) {\\n            prefix += currentChar;\\n        } else {\\n            return prefix;\\n        }\\n    }\\n    \\n    return prefix;\\n};\\n```\\n\\nStats:\\nRuntime: 72 ms, faster than 90.42% of JavaScript online submissions for Longest Common Prefix.\\nMemory Usage: 40.4 MB, less than 41.53% of JavaScript online submissions for Longest Common Prefix.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n    let prefix = \\'\\';\\n    if (strs.length === 1) return strs[0];\\n    for (let i = 0; i < strs[0].length; i++) {\\n        let currentChar = strs[0][i];\\n        if (currentChar && strs.every((s) => s[i] == currentChar)) {\\n            prefix += currentChar;\\n        } else {\\n            return prefix;\\n        }\\n    }\\n    \\n    return prefix;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 936274,
                "title": "c-detailed-explanation-for-longest-common-prefix",
                "content": "```class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.size() == 0) {\\n            return \"\";\\n        }\\n        \\n        // First let\\'s assume that the entire first string\\n        // is the common prefix.\\n        //\\n        std::string prefix = strs[0];\\n        \\n        // Now we iterate through the list of strings, and \\n        // for each string, we see how much of it matches with\\n        // our prefix. The size of the prefix keeps decreasing.\\n        //\\n        for(int i = 1; i < strs.size(); ++i) {\\n            // As long as you don\\'t find the prefix, keep decreasing\\n            // it\\'s size.\\n            //\\n            while(strs[i].find(prefix) != 0) {\\n                prefix = prefix.substr(0, prefix.length() - 1);\\n            }\\n            if(prefix.length() == 0) return \"\";\\n        }\\n        \\n        return prefix;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.size() == 0) {\\n            return \"\";\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 795155,
                "title": "simple-o-nlogn-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int n=strs.size();\\n        string ans=\"\";\\n        if(n==0)\\n            return ans;\\n        vector<string> k=strs;\\n        sort(k.begin(),k.end());\\n        string one=k[0],two=k[n-1];\\n        int i=0,j=0;\\n        int x=one.length();\\n        int y=two.length();\\n        for(;i<x and j<y;i++,j++)\\n        {\\n            if(one[i]!=two[j])\\n                break;\\n            ans+=one[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int n=strs.size();\\n        string ans=\"\";\\n        if(n==0)\\n            return ans;\\n        vector<string> k=strs;\\n        sort(k.begin(),k.end());\\n        string one=k[0],two=k[n-1];\\n        int i=0,j=0;\\n        int x=one.length();\\n        int y=two.length();\\n        for(;i<x and j<y;i++,j++)\\n        {\\n            if(one[i]!=two[j])\\n                break;\\n            ans+=one[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 565521,
                "title": "java-trie",
                "content": "This question is the best example to use a Trie. If you are familiar with Trie, then great. All you need is the \"insert\" function and a \"traversal\" function. Else follow the link mentioned below to understand.\\n\\nRefer to Trie : [ https://leetcode.com/problems/implement-trie-prefix-tree/solution/ ] \\n\\n```\\nclass Node {\\n    // Here : used a TreeMap because there is a need to maintain the insertion order\\n    TreeMap<Character, Node> children;\\n    boolean endOfWord;\\n    \\n    Node() {\\n        children = new TreeMap<>();\\n        endOfWord = false;\\n    }\\n}\\n\\nclass Solution {\\n    Node root;\\n    \\n\\t// insert the characters in trie\\n    public void insert(String word) {\\n        Node curr = this.root;\\n        for(int i=0;i<word.length();i++) {\\n            char ch = word.charAt(i);\\n            if( curr.children.get(ch) == null ) {\\n                curr.children.put(ch, new Node());\\n            }\\n            curr = curr.children.get(ch);\\n        }\\n        curr.endOfWord = true;\\n    }\\n    \\n\\t// Function : find the longest common prefix\\n    public String lcp() {\\n        \\n        StringBuilder result = new StringBuilder();\\n        Node curr = this.root;\\n        while(curr!=null && !curr.endOfWord && curr.children.size()==1) {\\n            \\n            // iterate the map and keep on appending the Character with the answer\\n\\t\\t\\t// much simpler iterator below \\n            Iterator<Map.Entry<Character, Node>> treemapItertor = curr.children.entrySet().iterator();\\n            \\n\\t\\t\\tif(treemapItertor.hasNext()) {\\n                Map.Entry<Character, Node> entry = treemapItertor.next();\\n\\t\\t\\t\\tresult.append(entry.getKey());\\n\\t\\t\\t\\tcurr = entry.getValue();\\n            }\\n        }\\n\\n\\t\\t/*  This can also be done like below : \\n\\t\\t\\t\\twhile(curr!=null && !curr.isEndOfWord && curr.children.size() == 1) {\\n\\t\\t\\t\\t\\tfor(Character key : curr.children.keySet()) {\\n\\t\\t\\t\\t\\t\\t result.append(key);\\n\\t\\t\\t\\t\\t\\tcurr = curr.children.get(key);\\n\\t\\t\\t\\t\\t\\tbreak;  // break out this for loop as we want only the single character\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t*/\\n        return result.toString();\\n    }\\n    public String longestCommonPrefix(String[] strs) {\\n        Solution trieObj = new Solution();\\n        trieObj.root = new Node();\\n        \\n        if(strs==null || strs.length==0) {\\n            return new String(\"\");\\n        }\\n\\t\\t// insert the words in Trie\\n        for(String s : strs) {\\n            trieObj.insert(s);\\n        }\\n\\t\\t// find the LCP !\\n        return trieObj.lcp();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Node {\\n    // Here : used a TreeMap because there is a need to maintain the insertion order\\n    TreeMap<Character, Node> children;\\n    boolean endOfWord;\\n    \\n    Node() {\\n        children = new TreeMap<>();\\n        endOfWord = false;\\n    }\\n}\\n\\nclass Solution {\\n    Node root;\\n    \\n\\t// insert the characters in trie\\n    public void insert(String word) {\\n        Node curr = this.root;\\n        for(int i=0;i<word.length();i++) {\\n            char ch = word.charAt(i);\\n            if( curr.children.get(ch) == null ) {\\n                curr.children.put(ch, new Node());\\n            }\\n            curr = curr.children.get(ch);\\n        }\\n        curr.endOfWord = true;\\n    }\\n    \\n\\t// Function : find the longest common prefix\\n    public String lcp() {\\n        \\n        StringBuilder result = new StringBuilder();\\n        Node curr = this.root;\\n        while(curr!=null && !curr.endOfWord && curr.children.size()==1) {\\n            \\n            // iterate the map and keep on appending the Character with the answer\\n\\t\\t\\t// much simpler iterator below \\n            Iterator<Map.Entry<Character, Node>> treemapItertor = curr.children.entrySet().iterator();\\n            \\n\\t\\t\\tif(treemapItertor.hasNext()) {\\n                Map.Entry<Character, Node> entry = treemapItertor.next();\\n\\t\\t\\t\\tresult.append(entry.getKey());\\n\\t\\t\\t\\tcurr = entry.getValue();\\n            }\\n        }\\n\\n\\t\\t/*  This can also be done like below : \\n\\t\\t\\t\\twhile(curr!=null && !curr.isEndOfWord && curr.children.size() == 1) {\\n\\t\\t\\t\\t\\tfor(Character key : curr.children.keySet()) {\\n\\t\\t\\t\\t\\t\\t result.append(key);\\n\\t\\t\\t\\t\\t\\tcurr = curr.children.get(key);\\n\\t\\t\\t\\t\\t\\tbreak;  // break out this for loop as we want only the single character\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t*/\\n        return result.toString();\\n    }\\n    public String longestCommonPrefix(String[] strs) {\\n        Solution trieObj = new Solution();\\n        trieObj.root = new Node();\\n        \\n        if(strs==null || strs.length==0) {\\n            return new String(\"\");\\n        }\\n\\t\\t// insert the words in Trie\\n        for(String s : strs) {\\n            trieObj.insert(s);\\n        }\\n\\t\\t// find the LCP !\\n        return trieObj.lcp();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 331851,
                "title": "python-trie",
                "content": "```python\\nclass TrieNode(object):\\n    \"\"\"Trie Node with a maximum of 26 links (a-z)\"\"\"\\n    ALPHABET = 26\\n\\n    def __init__(self):\\n        self._links = {}\\n        self.is_end = False\\n        self.link_size = 0\\n\\n    def contains_key(self, char):\\n        \"\"\"Check if charater has a child link in node\"\"\"\\n        return char in self._links\\n\\n    def get(self, char):\\n        \"\"\"Get child link for character\"\"\"\\n        return self._links[char]\\n\\n    def put(self, char, node):\\n        \"\"\"Set child link for character\"\"\"\\n        self._links[char] = node\\n        self.link_size += 1\\n        \\nclass Trie(object):\\n    \"\"\"Trie for strings of lower case letter a-z\"\"\"\\n    def __init__(self):\\n        self._root = TrieNode()\\n\\n    def insert(self, word):\\n        \"\"\"Insert word into the Trie\"\"\"\\n        node = self._root\\n        for char in word:\\n            if not node.contains_key(char):\\n                node.put(char, TrieNode())\\n            node = node.get(char)\\n        node.is_end = True\\n\\n    def _search_prefix(self, word):\\n        \"\"\"Search whole key or prefix in the Trie\\n           and return the node where the search ends\"\"\"\\n        node = self._root\\n        for char in word:\\n            if not node.contains_key(char):\\n                return None\\n            node = node.get(char)\\n        return node\\n\\n    def search(self, word):\\n        \"\"\"Search if a word is in the Trie\"\"\"\\n        node = self._search_prefix(word)\\n        return node is not None and node.is_end\\n\\n    def startswith(self, prefix):\\n        \"\"\"Search if prefix exist in Trie\"\"\"\\n        node = self._search_prefix(prefix)\\n        return node is not None\\n    \\n    def search_longest_prefix(self, word):\\n        \"\"\"Search longest prefix in Trie\"\"\"\\n        node = self._root\\n        prefix = \"\"\\n        for char in word:\\n            if (not node.contains_key(char) \\n                or node.link_size != 1\\n                or node.is_end):\\n                return prefix\\n            \\n            prefix += char\\n            node = node.get(char)\\n        \\n        return prefix\\n        \\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if not strs:\\n            return \"\"\\n        \\n        if len(strs) == 1:\\n            return strs[0]\\n        \\n        trie = Trie()\\n        for s in islice(strs, 1, None):\\n            trie.insert(s)\\n        \\n        return trie.search_longest_prefix(strs[0])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass TrieNode(object):\\n    \"\"\"Trie Node with a maximum of 26 links (a-z)\"\"\"\\n    ALPHABET = 26\\n\\n    def __init__(self):\\n        self._links = {}\\n        self.is_end = False\\n        self.link_size = 0\\n\\n    def contains_key(self, char):\\n        \"\"\"Check if charater has a child link in node\"\"\"\\n        return char in self._links\\n\\n    def get(self, char):\\n        \"\"\"Get child link for character\"\"\"\\n        return self._links[char]\\n\\n    def put(self, char, node):\\n        \"\"\"Set child link for character\"\"\"\\n        self._links[char] = node\\n        self.link_size += 1\\n        \\nclass Trie(object):\\n    \"\"\"Trie for strings of lower case letter a-z\"\"\"\\n    def __init__(self):\\n        self._root = TrieNode()\\n\\n    def insert(self, word):\\n        \"\"\"Insert word into the Trie\"\"\"\\n        node = self._root\\n        for char in word:\\n            if not node.contains_key(char):\\n                node.put(char, TrieNode())\\n            node = node.get(char)\\n        node.is_end = True\\n\\n    def _search_prefix(self, word):\\n        \"\"\"Search whole key or prefix in the Trie\\n           and return the node where the search ends\"\"\"\\n        node = self._root\\n        for char in word:\\n            if not node.contains_key(char):\\n                return None\\n            node = node.get(char)\\n        return node\\n\\n    def search(self, word):\\n        \"\"\"Search if a word is in the Trie\"\"\"\\n        node = self._search_prefix(word)\\n        return node is not None and node.is_end\\n\\n    def startswith(self, prefix):\\n        \"\"\"Search if prefix exist in Trie\"\"\"\\n        node = self._search_prefix(prefix)\\n        return node is not None\\n    \\n    def search_longest_prefix(self, word):\\n        \"\"\"Search longest prefix in Trie\"\"\"\\n        node = self._root\\n        prefix = \"\"\\n        for char in word:\\n            if (not node.contains_key(char) \\n                or node.link_size != 1\\n                or node.is_end):\\n                return prefix\\n            \\n            prefix += char\\n            node = node.get(char)\\n        \\n        return prefix\\n        \\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if not strs:\\n            return \"\"\\n        \\n        if len(strs) == 1:\\n            return strs[0]\\n        \\n        trie = Trie()\\n        for s in islice(strs, 1, None):\\n            trie.insert(s)\\n        \\n        return trie.search_longest_prefix(strs[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7108,
                "title": "java-solution-using-trie",
                "content": "Trie is a great solution for problems about prefix or string processing. And because of my intuition, I implementing a Trie for this question. May be its slow for this question, but I think it would definitely has advantage when the data set is very large. \\nAnyway, it an interesting method to use and practice. In case any one would want to see it, here is my code. \\n\\n```\\npublic class Solution {\\n    /**\\n     * Use a Trie to store all the strings. And this data structure is naturelly suited to find common prefix since it uses common prefix to store and search the strings. \\n     * All we have to do is print out the TrieNodes with only 1 child, indicating they are the common prefix of all the strings. \\n    **/\\n    \\n    public String longestCommonPrefix(String[] strs) {\\n        Trie trie = new Trie();\\n        for (String str : strs) {\\n            trie.insert(str);\\n        }\\n        TrieNode current = trie.root;\\n        String result = \"\";\\n        while (current.isEnd != true) {\\n            int count = 0;\\n            int index = 0;\\n            for (int i = 0; i < 26; i++) {\\n                if (current.childs[i] != null) {\\n                    count += 1;\\n                    index = i;\\n                }\\n            }\\n            if (count != 1) return result;  //Once we find a node whose childs number is not 1, say, either 0 or more than 1, common prefix have been found\\n            current = current.childs[index];\\n            result += String.valueOf(current.value);\\n        }\\n        return result;\\n        \\n    }\\n    \\n    class TrieNode {\\n        static final int numAlpha = 26;\\n        char value;\\n        int count;\\n        TrieNode[] childs;\\n        boolean isEnd;\\n        public TrieNode(char c) {\\n            value = c;\\n            count = 0;\\n            childs = new TrieNode[numAlpha];\\n            isEnd = false;\\n        }\\n    }\\n    \\n    class Trie {\\n        TrieNode root;\\n        public Trie() {\\n            root = new TrieNode(' ');\\n        }\\n        \\n        public void insert(String word) {\\n            if (this.search(word) == true) return;\\n            \\n            TrieNode current = root;\\n            for (int i = 0; i < word.length(); i++) {\\n                char c = word.charAt(i);\\n                if (c >= 'A' && c <= 'Z') {\\n                    c = (char)(c + 'a' - 'A');\\n                }\\n                if (current.childs[c - 'a'] != null) {\\n                    current = current.childs[c - 'a'];\\n                }\\n                else {\\n                    current.childs[c - 'a'] = new TrieNode(c);\\n                    current = current.childs[c - 'a'];\\n                }\\n                current.count++;\\n            }\\n            current.isEnd = true;\\n        }\\n        \\n        public boolean search(String word) {\\n            TrieNode current = root;\\n            \\n            for (int i = 0; i < word.length(); i++) {\\n                char c = word.charAt(i);\\n                int index = 0;\\n                if (c >= 'A' && c <= 'Z') {\\n                    index = c - 'A';\\n                }\\n                else {\\n                    index = c - 'a';\\n                }\\n                if (current.childs[index] == null) {\\n                    return false;\\n                }\\n                else {\\n                    current = current.childs[index];\\n                }\\n            }\\n            if (current.isEnd == true) {\\n                return true;\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    /**\\n     * Use a Trie to store all the strings. And this data structure is naturelly suited to find common prefix since it uses common prefix to store and search the strings. \\n     * All we have to do is print out the TrieNodes with only 1 child, indicating they are the common prefix of all the strings. \\n    **/\\n    \\n    public String longestCommonPrefix(String[] strs) {\\n        Trie trie = new Trie();\\n        for (String str : strs) {\\n            trie.insert(str);\\n        }\\n        TrieNode current = trie.root;\\n        String result = \"\";\\n        while (current.isEnd != true) {\\n            int count = 0;\\n            int index = 0;\\n            for (int i = 0; i < 26; i++) {\\n                if (current.childs[i] != null) {\\n                    count += 1;\\n                    index = i;\\n                }\\n            }\\n            if (count != 1) return result;  //Once we find a node whose childs number is not 1, say, either 0 or more than 1, common prefix have been found\\n            current = current.childs[index];\\n            result += String.valueOf(current.value);\\n        }\\n        return result;\\n        \\n    }\\n    \\n    class TrieNode {\\n        static final int numAlpha = 26;\\n        char value;\\n        int count;\\n        TrieNode[] childs;\\n        boolean isEnd;\\n        public TrieNode(char c) {\\n            value = c;\\n            count = 0;\\n            childs = new TrieNode[numAlpha];\\n            isEnd = false;\\n        }\\n    }\\n    \\n    class Trie {\\n        TrieNode root;\\n        public Trie() {\\n            root = new TrieNode(' ');\\n        }\\n        \\n        public void insert(String word) {\\n            if (this.search(word) == true) return;\\n            \\n            TrieNode current = root;\\n            for (int i = 0; i < word.length(); i++) {\\n                char c = word.charAt(i);\\n                if (c >= 'A' && c <= 'Z') {\\n                    c = (char)(c + 'a' - 'A');\\n                }\\n                if (current.childs[c - 'a'] != null) {\\n                    current = current.childs[c - 'a'];\\n                }\\n                else {\\n                    current.childs[c - 'a'] = new TrieNode(c);\\n                    current = current.childs[c - 'a'];\\n                }\\n                current.count++;\\n            }\\n            current.isEnd = true;\\n        }\\n        \\n        public boolean search(String word) {\\n            TrieNode current = root;\\n            \\n            for (int i = 0; i < word.length(); i++) {\\n                char c = word.charAt(i);\\n                int index = 0;\\n                if (c >= 'A' && c <= 'Z') {\\n                    index = c - 'A';\\n                }\\n                else {\\n                    index = c - 'a';\\n                }\\n                if (current.childs[index] == null) {\\n                    return false;\\n                }\\n                else {\\n                    current = current.childs[index];\\n                }\\n            }\\n            if (current.isEnd == true) {\\n                return true;\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566649,
                "title": "longest-common-prefix-optimized-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty())\\n            return \"\";\\n        \\n        string prefix = strs[0];\\n        \\n        for (int i = 1; i < strs.size(); i++) {\\n            while (strs[i].find(prefix) != 0) {\\n                prefix = prefix.substr(0, prefix.length() - 1);\\n                \\n                if (prefix.empty())\\n                    return \"\";\\n            }\\n        }\\n        \\n        return prefix;\\n    }\\n};\\n```\\n\\nExplanation:\\n\\n1. We define a longestCommonPrefix function that takes a vector of strings strs as input and returns the longest common prefix string.\\n2. If the input vector strs is empty, we immediately return an empty string.\\n3. We initialize the prefix string with the first string in the vector strs.\\n4. We iterate through the remaining strings in the vector, starting from the second string (index 1).\\n5. In each iteration, we check if the prefix is a prefix of the current string strs[i] using the find function. If it is not a prefix, we remove the last character from the prefix by using substr with the starting index 0 and length prefix.length() - 1.\\n6. We continue this process until the prefix becomes a prefix of the current string or until it becomes an empty string. If the prefix becomes empty, it means there is no common prefix among the strings, so we return an empty string.\\n7. Finally, we return the resulting prefix string, which represents the longest common prefix among all the strings in the vector strs.\\n\\nThe time complexity of this solution is O(N * M), where N is the number of strings in the vector strs and M is the length of the shortest string in the vector.\\n\\n**PLEASE UPVOTE :)**\\n\\n",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty())\\n            return \"\";\\n        \\n        string prefix = strs[0];\\n        \\n        for (int i = 1; i < strs.size(); i++) {\\n            while (strs[i].find(prefix) != 0) {\\n                prefix = prefix.substr(0, prefix.length() - 1);\\n                \\n                if (prefix.empty())\\n                    return \"\";\\n            }\\n        }\\n        \\n        return prefix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504703,
                "title": "java-solution-easy-to-understand",
                "content": "# Approach\\nThe given code implements the `longestCommonPrefix` method, which takes an array of strings `strs` as input and returns the longest common prefix among the strings. Here is an explanation of the approach used in the code:\\n\\n1. Initialize a variable `ans` with the first string in the array `strs`. This is done assuming that the first string is the initial common prefix.\\n\\n2. Initialize an empty string `sub` to store the temporary common prefix between `ans` and the current string being checked.\\n\\n3. Iterate through the remaining strings in the `strs` array starting from the second string.\\n\\n4. For each string, iterate through its characters and compare them with the characters at the corresponding positions in `ans`. The inner loop runs until either the end of the current string or the end of `ans`, whichever is shorter.\\n\\n5. If the characters at the current position in both `ans` and the current string are the same, append that character to the `sub` string.\\n\\n6. If the characters at the current position are not the same, break out of the inner loop because it means that the common prefix ends at this point.\\n\\n7. Update `ans` to be equal to `sub`, which contains the common prefix found so far.\\n\\n8. Reset `sub` to an empty string for the next iteration.\\n\\n9. After all the strings have been processed, the value of `ans` will be the longest common prefix among all the strings.\\n\\n10. Finally, return the `ans` string as the result.\\n\\nNote: The code assumes that the input `strs` array is not empty and contains at least one string.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the given code is O(N * M), where N is the length of the input array strs and M is the length of the shortest string in strs\\n\\n- Space complexity:\\nThe space complexity of the code is O(M), where M is the length of the shortest string in strs.\\n\\n# Code\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {     \\n        String ans = strs[0];\\n        String sub = \"\";\\n        \\n        for (int i = 1; i < strs.length; i++) {\\n            \\n            for (int j = 0; j < Math.min(ans.length(), strs[i].length()); j++) {\\n\\n                if (ans.charAt(j) == strs[i].charAt(j)) {\\n                    sub += ans.charAt(j);\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            ans = sub;\\n            sub = \"\";\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {     \\n        String ans = strs[0];\\n        String sub = \"\";\\n        \\n        for (int i = 1; i < strs.length; i++) {\\n            \\n            for (int j = 0; j < Math.min(ans.length(), strs[i].length()); j++) {\\n\\n                if (ans.charAt(j) == strs[i].charAt(j)) {\\n                    sub += ans.charAt(j);\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            ans = sub;\\n            sub = \"\";\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316480,
                "title": "powerful-logic-with-sort-approach-and-prefix-tree-python",
                "content": "# 1.  Sort approach:\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        ans=\"\"\\n        n=len(strs)\\n        strs.sort()\\n        for i in range(len(strs[0])):\\n            if strs[0][i]==strs[n-1][i]:\\n                ans+=strs[0][i]\\n            else:\\n                break\\n        return ans\\n```\\n\\n# Prefix Tree Approach\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if not strs:\\n            return \"\"\\n        short=min(strs,key=len)\\n        for i,v in enumerate(short):\\n            for w in strs:\\n                if w[i]!=short[i]:\\n                    return short[:i]\\n        return short \\n        \\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        ans=\"\"\\n        n=len(strs)\\n        strs.sort()\\n        for i in range(len(strs[0])):\\n            if strs[0][i]==strs[n-1][i]:\\n                ans+=strs[0][i]\\n            else:\\n                break\\n        return ans\\n```\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if not strs:\\n            return \"\"\\n        short=min(strs,key=len)\\n        for i,v in enumerate(short):\\n            for w in strs:\\n                if w[i]!=short[i]:\\n                    return short[:i]\\n        return short \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194229,
                "title": "easy-approach-without-sorting-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncomparing the characters of the smallest string in the given string array!!\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        StringBuffer ans=new StringBuffer();\\n        if(strs.length==1)\\n        {\\n            return strs[0];\\n        }\\n        // FINDING THE SMALLEST STRING\\n        int min=strs[0].length();\\n  \\n        int index=0;\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            if(strs[i].length()<min)\\n            {\\n                min=strs[i].length();\\n                index=i;\\n            }\\n        }\\n        // COMPARING THE CHARACTERS OF ALL OTHER STRING WITH THE        SMALLEST STRING AND...\\n        String check=strs[index];\\n        <!-- System.out.println(check); -->\\n        for(int i=0;i<check.length();i++)\\n        {\\n            char ch=check.charAt(i);\\n            for(int j=0;j<strs.length;j++)\\n            {\\n                if(strs[j].charAt(i)!=ch)\\n                {\\n                    return ans+\"\";\\n                }\\n                \\n            }\\n            ans.append(ch);\\n        }\\n        return ans+\"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        StringBuffer ans=new StringBuffer();\\n        if(strs.length==1)\\n        {\\n            return strs[0];\\n        }\\n        // FINDING THE SMALLEST STRING\\n        int min=strs[0].length();\\n  \\n        int index=0;\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            if(strs[i].length()<min)\\n            {\\n                min=strs[i].length();\\n                index=i;\\n            }\\n        }\\n        // COMPARING THE CHARACTERS OF ALL OTHER STRING WITH THE        SMALLEST STRING AND...\\n        String check=strs[index];\\n        <!-- System.out.println(check); -->\\n        for(int i=0;i<check.length();i++)\\n        {\\n            char ch=check.charAt(i);\\n            for(int j=0;j<strs.length;j++)\\n            {\\n                if(strs[j].charAt(i)!=ch)\\n                {\\n                    return ans+\"\";\\n                }\\n                \\n            }\\n            ans.append(ch);\\n        }\\n        return ans+\"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773589,
                "title": "efficient-python-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Start from the first index of strs[0]\\n- Loop through strs (array)\\n- If not same: return prefix\\n- else: add prefix\\n\\n# Complexity\\n- Time complexity: $$O(n*n[0].length)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ *(Not counting result)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        prefix = \\'\\'\\n\\n        for p in range(len(strs[0])):\\n            for m in range(1, len(strs)):\\n                if p > len(strs[m])-1 or strs[m][p] != strs[0][p]:\\n                    return prefix\\n            prefix += strs[0][p]\\n        return prefix\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        prefix = \\'\\'\\n\\n        for p in range(len(strs[0])):\\n            for m in range(1, len(strs)):\\n                if p > len(strs[m])-1 or strs[m][p] != strs[0][p]:\\n                    return prefix\\n            prefix += strs[0][p]\\n        return prefix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2553219,
                "title": "simplest-java-solution-ever-for-the-problem-with-explanation",
                "content": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        //if we see the string in arrays carefully we can say that if \\n        //arreange them in lexicogrphy order and check for the first and last \\n        //string for same prefix we will get the ans\\n        //no need to travels and check all the strings\\n                \\n        Arrays.sort(strs);//sorting the strs array\\n        String start = strs[0];//taking first string in sorted array\\n        String end = strs[strs.length-1];//taking last string in sorted array\\n        String s = \"\";//creating an empty string\\n        for(int i=0; i<start.length(); i++){\\n            if(start.charAt(i)==end.charAt(i)){//checking the elemet in first & last string\\n                s += start.charAt(i);//if same add in string s\\n            }\\n            else{\\n                break;//if letters are not same break the loop \\n            }\\n        }\\n        return s;\\n    }\\n}\\n```\\nIf u like the solution plz upvote",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        //if we see the string in arrays carefully we can say that if \\n        //arreange them in lexicogrphy order and check for the first and last \\n        //string for same prefix we will get the ans\\n        //no need to travels and check all the strings\\n                \\n        Arrays.sort(strs);//sorting the strs array\\n        String start = strs[0];//taking first string in sorted array\\n        String end = strs[strs.length-1];//taking last string in sorted array\\n        String s = \"\";//creating an empty string\\n        for(int i=0; i<start.length(); i++){\\n            if(start.charAt(i)==end.charAt(i)){//checking the elemet in first & last string\\n                s += start.charAt(i);//if same add in string s\\n            }\\n            else{\\n                break;//if letters are not same break the loop \\n            }\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430629,
                "title": "c-linq-solution",
                "content": "```\\npublic class Solution {\\n    public string LongestCommonPrefix(string[] strs)\\n    {\\n        if (!strs.Any())\\n            return string.Empty;\\n\\n        var shortestWord = strs.MinBy(a => a.Length);\\n        for (var i = shortestWord.Length; i > 0; i--)\\n        {\\n            if (strs.All(a => a.StartsWith(shortestWord[..i])))\\n                return shortestWord[..i];\\n        }\\n\\n        return string.Empty;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string LongestCommonPrefix(string[] strs)\\n    {\\n        if (!strs.Any())\\n            return string.Empty;\\n\\n        var shortestWord = strs.MinBy(a => a.Length);\\n        for (var i = shortestWord.Length; i > 0; i--)\\n        {\\n            if (strs.All(a => a.StartsWith(shortestWord[..i])))\\n                return shortestWord[..i];\\n        }\\n\\n        return string.Empty;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2193815,
                "title": "python-3-liner-clean-code-zip-function",
                "content": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        res=\"\"\\n        for i in list(zip(*strs)):\\n            if len(set(i))==1: res+=i[0]\\n            else: break\\n        return res\\n\\n```\\n***Pls upvote the solution if you find it helpful***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        res=\"\"\\n        for i in list(zip(*strs)):\\n            if len(set(i))==1: res+=i[0]\\n            else: break\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2163267,
                "title": "python-beats-99-11-with-full-working-explanation",
                "content": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:  # Time: O(n*n) and Space: O(1)\\n        res=\\'\\'\\n        for i in range(len(strs[0])):           # we take the first string from the list of strings as the base case\\n            for s in strs:                        # taking one string at a time and checking each of the strings\\' character at the same index i\\n                if i==len(s) or s[i]!=strs[0][i]:   # when anyone of the string reaches its end and at index i strings does not match\\n                    return res                      # we cannot go ahead now as per the LCP rules, and we need to return the longest common prefix\\n            res+=strs[0][i]                       # when all the conditions in if fails for every string at index i, that means that character at i is LCP\\n        return res                              # when for loop exit, means the whole base case was the LCP\\n```\\nFor example,\\nstrs = [\"flower\",\"flow\",\"flight\"]\\n{index, s} = {0, flower}, {1, flow}, {2, flight}\\nlen(flower) = 6, len(flow) = 4,  and len(flight) = 6\\nfor i = len(strs[0]) = len(flower) = 6 i.e. 0,1,2,3,4,5\\n1. i=0: \\n* for s=flower --> if 0==6 or s[0]!=strs[0][0] = False \\n* for s=flow   --> if 0==4 or s[0]!=strs[0][0] = False \\n* for s=flight --> if 0==6 or s[0]!=strs[0][0] = False\\n* res = res + strs[0][0] = \\'\\' + \\'f\\' = f \\n2. i=1:\\n* for s=flower --> if 1==6 or s[1]!=strs[0][1] = False \\n* for s=flow   --> if 1==4 or s[1]!=strs[0][1] = False \\n* for s=flight --> if 1==6 or s[1]!=strs[0][1] = False\\n* res = res + strs[0][0] = f + l = fl \\n3. i=2:\\n* for s=flower --> if 2==6 or s[2]!=strs[0][2] = False \\n* for s=flow   --> if 2==4 or s[2]!=strs[0][2] = False \\n* for s=flight --> if 2==6 or s[2]!=strs[0][2] = False\\n* res = res + strs[0][0] = fl + o  = flo \\n4. i=3:\\n* for s=flower --> if 3==6 or s[3]!=strs[0][3] = False \\n* for s=flow   --> if 3==4 or s[3]!=strs[0][3] = False \\n* for s=flight --> if 3==6 or s[3]!=strs[0][3] = False\\n* res = res + strs[0][0] = flow + w = flow \\n5. i=4:\\n* for s=flower --> if 4==6 or s[4]!=strs[0][4] = False \\n* for s=flow   --> if 4==4 or s[4]!=strs[0][4] = True and index out of bounds -->  Return result flow as the longest common prefix",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:  # Time: O(n*n) and Space: O(1)\\n        res=\\'\\'\\n        for i in range(len(strs[0])):           # we take the first string from the list of strings as the base case\\n            for s in strs:                        # taking one string at a time and checking each of the strings\\' character at the same index i\\n                if i==len(s) or s[i]!=strs[0][i]:   # when anyone of the string reaches its end and at index i strings does not match\\n                    return res                      # we cannot go ahead now as per the LCP rules, and we need to return the longest common prefix\\n            res+=strs[0][i]                       # when all the conditions in if fails for every string at index i, that means that character at i is LCP\\n        return res                              # when for loop exit, means the whole base case was the LCP\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564635,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1720944,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1565735,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1575665,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1565289,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1789281,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1573676,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1566468,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1684693,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1566066,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1564635,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1720944,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1565735,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1575665,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1565289,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1789281,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1573676,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1566468,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1684693,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1566066,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1635874,
                "content": [
                    {
                        "username": "BrajBliss",
                        "content": "This is a medium level question man."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the vertical scanning strategy:\n\nhttps://youtube.com/watch?v=SiNDN2M4dtQ"
                    },
                    {
                        "username": "jerryy147",
                        "content": "my 100th problem :D"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "congrats :D"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i wrote the slowest solution to this problem "
                    },
                    {
                        "username": "iaashu98",
                        "content": "wow, congrats. Please share link, I want to write slowe solution than you."
                    },
                    {
                        "username": "dmytrochyrva",
                        "content": "Hello, I am a bit confused,  I have set of inputs:\\n[\"reflower\",\"flow\",\"flight\"]\\n\\nand it is clear that the longest prefix here is \"fl\"\\nbut test case fails for some reason and says that:\\n\\nExpected: \"\"\\n\\nHas anyone had this issue?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its prefix.. meaning the beginning of each string. \"fl\" is not the beginning of \"reflower\" "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "[@bmagana5](/bmagana5)  The question wasn\\'t worded clearly at all. It asked for the most common prefix amongst an array of strings, not the most common prefix of ALL STRINGS within an array (which is apparently what it actually wanted)"
                    },
                    {
                        "username": "ArbreD",
                        "content": "[@bmagana5](/bmagana5) Thank you so much. Otherwise, I would take a couple of time fighting with it =))"
                    },
                    {
                        "username": "bmagana5",
                        "content": "it's gotta be the longest possible prefix that matches for all of the strings in the list. The substring 'fl' works for both 'flow' and 'flight', but not in 'reflower', as 'reflower' begins with the characters 're', so it stands that the longest prefix that all of the strings in the list share is \"\", or the empty string."
                    },
                    {
                        "username": "wwdj1924",
                        "content": "\"flower\" is not a prefix."
                    },
                    {
                        "username": "alpycelf",
                        "content": "Dear god...\nTurns out I didn't read the question carefully. (It wasn't written clearly though)\nI made it so it finds the longest common prefix inside the array.\nBUT\n\nInput:    [\"reflower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExpected: \"\"\n\nApparently it asks me to find the common prefix shared by ALL of the elements."
                    },
                    {
                        "username": "user7067M",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  It says **prefix** not **contains**. \"fl\" is not a prefix in \"reflower\" but is a prefix in \"flow\" and \"flight\"."
                    },
                    {
                        "username": "Jeetpal",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  For example, the index 0, ie \"reflower\", doesn\\'t have \"fl\" prefix, hence, it contradicts all elements having prefix of \"fl\""
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "I still didn\\'t understand, all elements shares \"fl\"? "
                    },
                    {
                        "username": "ejqgpt",
                        "content": "It says that time complexity of the first provided solution by leetcode itself is O(S) where S is the sum of lengths of all strings. However in the 5th line, **indexOf** method of String is called. So, **indexOf** method must finish execution in O(1) for complexity to be O(S) finally. Does it work in O(1) ?"
                    },
                    {
                        "username": "rajatkumargla19",
                        "content": "no....indexOf() works in O(n) for array\nbut leetcode official solution has O(S) time complexity...observe again"
                    },
                    {
                        "username": "esauceda2725",
                        "content": "The `[\"\",\"\"]` test case is wild. The constraints clearly say that the elements in `strs` will only consist of English letters. NOT SYMBOLS OR PUNCTUATIONS."
                    },
                    {
                        "username": "kanteshkm",
                        "content": "is problem statement is confusing?. i was thinking we need to find max common prefix in any order like {\"spoiler\", \"flower\", \"flow\", \"flight\"}, still output should be \"fl\""
                    },
                    {
                        "username": "LeetCodeMoAb",
                        "content": "I believe when they say common, it means in every single word.  The best way to word this would have been \"find the longest common sequence in all words that begins at index 0\".  Still not a perfect question, but still better than saying \"prefix\". "
                    }
                ]
            },
            {
                "id": 1876481,
                "content": [
                    {
                        "username": "BrajBliss",
                        "content": "This is a medium level question man."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the vertical scanning strategy:\n\nhttps://youtube.com/watch?v=SiNDN2M4dtQ"
                    },
                    {
                        "username": "jerryy147",
                        "content": "my 100th problem :D"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "congrats :D"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i wrote the slowest solution to this problem "
                    },
                    {
                        "username": "iaashu98",
                        "content": "wow, congrats. Please share link, I want to write slowe solution than you."
                    },
                    {
                        "username": "dmytrochyrva",
                        "content": "Hello, I am a bit confused,  I have set of inputs:\\n[\"reflower\",\"flow\",\"flight\"]\\n\\nand it is clear that the longest prefix here is \"fl\"\\nbut test case fails for some reason and says that:\\n\\nExpected: \"\"\\n\\nHas anyone had this issue?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its prefix.. meaning the beginning of each string. \"fl\" is not the beginning of \"reflower\" "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "[@bmagana5](/bmagana5)  The question wasn\\'t worded clearly at all. It asked for the most common prefix amongst an array of strings, not the most common prefix of ALL STRINGS within an array (which is apparently what it actually wanted)"
                    },
                    {
                        "username": "ArbreD",
                        "content": "[@bmagana5](/bmagana5) Thank you so much. Otherwise, I would take a couple of time fighting with it =))"
                    },
                    {
                        "username": "bmagana5",
                        "content": "it's gotta be the longest possible prefix that matches for all of the strings in the list. The substring 'fl' works for both 'flow' and 'flight', but not in 'reflower', as 'reflower' begins with the characters 're', so it stands that the longest prefix that all of the strings in the list share is \"\", or the empty string."
                    },
                    {
                        "username": "wwdj1924",
                        "content": "\"flower\" is not a prefix."
                    },
                    {
                        "username": "alpycelf",
                        "content": "Dear god...\nTurns out I didn't read the question carefully. (It wasn't written clearly though)\nI made it so it finds the longest common prefix inside the array.\nBUT\n\nInput:    [\"reflower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExpected: \"\"\n\nApparently it asks me to find the common prefix shared by ALL of the elements."
                    },
                    {
                        "username": "user7067M",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  It says **prefix** not **contains**. \"fl\" is not a prefix in \"reflower\" but is a prefix in \"flow\" and \"flight\"."
                    },
                    {
                        "username": "Jeetpal",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  For example, the index 0, ie \"reflower\", doesn\\'t have \"fl\" prefix, hence, it contradicts all elements having prefix of \"fl\""
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "I still didn\\'t understand, all elements shares \"fl\"? "
                    },
                    {
                        "username": "ejqgpt",
                        "content": "It says that time complexity of the first provided solution by leetcode itself is O(S) where S is the sum of lengths of all strings. However in the 5th line, **indexOf** method of String is called. So, **indexOf** method must finish execution in O(1) for complexity to be O(S) finally. Does it work in O(1) ?"
                    },
                    {
                        "username": "rajatkumargla19",
                        "content": "no....indexOf() works in O(n) for array\nbut leetcode official solution has O(S) time complexity...observe again"
                    },
                    {
                        "username": "esauceda2725",
                        "content": "The `[\"\",\"\"]` test case is wild. The constraints clearly say that the elements in `strs` will only consist of English letters. NOT SYMBOLS OR PUNCTUATIONS."
                    },
                    {
                        "username": "kanteshkm",
                        "content": "is problem statement is confusing?. i was thinking we need to find max common prefix in any order like {\"spoiler\", \"flower\", \"flow\", \"flight\"}, still output should be \"fl\""
                    },
                    {
                        "username": "LeetCodeMoAb",
                        "content": "I believe when they say common, it means in every single word.  The best way to word this would have been \"find the longest common sequence in all words that begins at index 0\".  Still not a perfect question, but still better than saying \"prefix\". "
                    }
                ]
            },
            {
                "id": 1881670,
                "content": [
                    {
                        "username": "BrajBliss",
                        "content": "This is a medium level question man."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the vertical scanning strategy:\n\nhttps://youtube.com/watch?v=SiNDN2M4dtQ"
                    },
                    {
                        "username": "jerryy147",
                        "content": "my 100th problem :D"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "congrats :D"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i wrote the slowest solution to this problem "
                    },
                    {
                        "username": "iaashu98",
                        "content": "wow, congrats. Please share link, I want to write slowe solution than you."
                    },
                    {
                        "username": "dmytrochyrva",
                        "content": "Hello, I am a bit confused,  I have set of inputs:\\n[\"reflower\",\"flow\",\"flight\"]\\n\\nand it is clear that the longest prefix here is \"fl\"\\nbut test case fails for some reason and says that:\\n\\nExpected: \"\"\\n\\nHas anyone had this issue?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its prefix.. meaning the beginning of each string. \"fl\" is not the beginning of \"reflower\" "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "[@bmagana5](/bmagana5)  The question wasn\\'t worded clearly at all. It asked for the most common prefix amongst an array of strings, not the most common prefix of ALL STRINGS within an array (which is apparently what it actually wanted)"
                    },
                    {
                        "username": "ArbreD",
                        "content": "[@bmagana5](/bmagana5) Thank you so much. Otherwise, I would take a couple of time fighting with it =))"
                    },
                    {
                        "username": "bmagana5",
                        "content": "it's gotta be the longest possible prefix that matches for all of the strings in the list. The substring 'fl' works for both 'flow' and 'flight', but not in 'reflower', as 'reflower' begins with the characters 're', so it stands that the longest prefix that all of the strings in the list share is \"\", or the empty string."
                    },
                    {
                        "username": "wwdj1924",
                        "content": "\"flower\" is not a prefix."
                    },
                    {
                        "username": "alpycelf",
                        "content": "Dear god...\nTurns out I didn't read the question carefully. (It wasn't written clearly though)\nI made it so it finds the longest common prefix inside the array.\nBUT\n\nInput:    [\"reflower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExpected: \"\"\n\nApparently it asks me to find the common prefix shared by ALL of the elements."
                    },
                    {
                        "username": "user7067M",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  It says **prefix** not **contains**. \"fl\" is not a prefix in \"reflower\" but is a prefix in \"flow\" and \"flight\"."
                    },
                    {
                        "username": "Jeetpal",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  For example, the index 0, ie \"reflower\", doesn\\'t have \"fl\" prefix, hence, it contradicts all elements having prefix of \"fl\""
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "I still didn\\'t understand, all elements shares \"fl\"? "
                    },
                    {
                        "username": "ejqgpt",
                        "content": "It says that time complexity of the first provided solution by leetcode itself is O(S) where S is the sum of lengths of all strings. However in the 5th line, **indexOf** method of String is called. So, **indexOf** method must finish execution in O(1) for complexity to be O(S) finally. Does it work in O(1) ?"
                    },
                    {
                        "username": "rajatkumargla19",
                        "content": "no....indexOf() works in O(n) for array\nbut leetcode official solution has O(S) time complexity...observe again"
                    },
                    {
                        "username": "esauceda2725",
                        "content": "The `[\"\",\"\"]` test case is wild. The constraints clearly say that the elements in `strs` will only consist of English letters. NOT SYMBOLS OR PUNCTUATIONS."
                    },
                    {
                        "username": "kanteshkm",
                        "content": "is problem statement is confusing?. i was thinking we need to find max common prefix in any order like {\"spoiler\", \"flower\", \"flow\", \"flight\"}, still output should be \"fl\""
                    },
                    {
                        "username": "LeetCodeMoAb",
                        "content": "I believe when they say common, it means in every single word.  The best way to word this would have been \"find the longest common sequence in all words that begins at index 0\".  Still not a perfect question, but still better than saying \"prefix\". "
                    }
                ]
            },
            {
                "id": 1864054,
                "content": [
                    {
                        "username": "BrajBliss",
                        "content": "This is a medium level question man."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the vertical scanning strategy:\n\nhttps://youtube.com/watch?v=SiNDN2M4dtQ"
                    },
                    {
                        "username": "jerryy147",
                        "content": "my 100th problem :D"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "congrats :D"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i wrote the slowest solution to this problem "
                    },
                    {
                        "username": "iaashu98",
                        "content": "wow, congrats. Please share link, I want to write slowe solution than you."
                    },
                    {
                        "username": "dmytrochyrva",
                        "content": "Hello, I am a bit confused,  I have set of inputs:\\n[\"reflower\",\"flow\",\"flight\"]\\n\\nand it is clear that the longest prefix here is \"fl\"\\nbut test case fails for some reason and says that:\\n\\nExpected: \"\"\\n\\nHas anyone had this issue?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its prefix.. meaning the beginning of each string. \"fl\" is not the beginning of \"reflower\" "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "[@bmagana5](/bmagana5)  The question wasn\\'t worded clearly at all. It asked for the most common prefix amongst an array of strings, not the most common prefix of ALL STRINGS within an array (which is apparently what it actually wanted)"
                    },
                    {
                        "username": "ArbreD",
                        "content": "[@bmagana5](/bmagana5) Thank you so much. Otherwise, I would take a couple of time fighting with it =))"
                    },
                    {
                        "username": "bmagana5",
                        "content": "it's gotta be the longest possible prefix that matches for all of the strings in the list. The substring 'fl' works for both 'flow' and 'flight', but not in 'reflower', as 'reflower' begins with the characters 're', so it stands that the longest prefix that all of the strings in the list share is \"\", or the empty string."
                    },
                    {
                        "username": "wwdj1924",
                        "content": "\"flower\" is not a prefix."
                    },
                    {
                        "username": "alpycelf",
                        "content": "Dear god...\nTurns out I didn't read the question carefully. (It wasn't written clearly though)\nI made it so it finds the longest common prefix inside the array.\nBUT\n\nInput:    [\"reflower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExpected: \"\"\n\nApparently it asks me to find the common prefix shared by ALL of the elements."
                    },
                    {
                        "username": "user7067M",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  It says **prefix** not **contains**. \"fl\" is not a prefix in \"reflower\" but is a prefix in \"flow\" and \"flight\"."
                    },
                    {
                        "username": "Jeetpal",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  For example, the index 0, ie \"reflower\", doesn\\'t have \"fl\" prefix, hence, it contradicts all elements having prefix of \"fl\""
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "I still didn\\'t understand, all elements shares \"fl\"? "
                    },
                    {
                        "username": "ejqgpt",
                        "content": "It says that time complexity of the first provided solution by leetcode itself is O(S) where S is the sum of lengths of all strings. However in the 5th line, **indexOf** method of String is called. So, **indexOf** method must finish execution in O(1) for complexity to be O(S) finally. Does it work in O(1) ?"
                    },
                    {
                        "username": "rajatkumargla19",
                        "content": "no....indexOf() works in O(n) for array\nbut leetcode official solution has O(S) time complexity...observe again"
                    },
                    {
                        "username": "esauceda2725",
                        "content": "The `[\"\",\"\"]` test case is wild. The constraints clearly say that the elements in `strs` will only consist of English letters. NOT SYMBOLS OR PUNCTUATIONS."
                    },
                    {
                        "username": "kanteshkm",
                        "content": "is problem statement is confusing?. i was thinking we need to find max common prefix in any order like {\"spoiler\", \"flower\", \"flow\", \"flight\"}, still output should be \"fl\""
                    },
                    {
                        "username": "LeetCodeMoAb",
                        "content": "I believe when they say common, it means in every single word.  The best way to word this would have been \"find the longest common sequence in all words that begins at index 0\".  Still not a perfect question, but still better than saying \"prefix\". "
                    }
                ]
            },
            {
                "id": 1729118,
                "content": [
                    {
                        "username": "BrajBliss",
                        "content": "This is a medium level question man."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the vertical scanning strategy:\n\nhttps://youtube.com/watch?v=SiNDN2M4dtQ"
                    },
                    {
                        "username": "jerryy147",
                        "content": "my 100th problem :D"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "congrats :D"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i wrote the slowest solution to this problem "
                    },
                    {
                        "username": "iaashu98",
                        "content": "wow, congrats. Please share link, I want to write slowe solution than you."
                    },
                    {
                        "username": "dmytrochyrva",
                        "content": "Hello, I am a bit confused,  I have set of inputs:\\n[\"reflower\",\"flow\",\"flight\"]\\n\\nand it is clear that the longest prefix here is \"fl\"\\nbut test case fails for some reason and says that:\\n\\nExpected: \"\"\\n\\nHas anyone had this issue?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its prefix.. meaning the beginning of each string. \"fl\" is not the beginning of \"reflower\" "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "[@bmagana5](/bmagana5)  The question wasn\\'t worded clearly at all. It asked for the most common prefix amongst an array of strings, not the most common prefix of ALL STRINGS within an array (which is apparently what it actually wanted)"
                    },
                    {
                        "username": "ArbreD",
                        "content": "[@bmagana5](/bmagana5) Thank you so much. Otherwise, I would take a couple of time fighting with it =))"
                    },
                    {
                        "username": "bmagana5",
                        "content": "it's gotta be the longest possible prefix that matches for all of the strings in the list. The substring 'fl' works for both 'flow' and 'flight', but not in 'reflower', as 'reflower' begins with the characters 're', so it stands that the longest prefix that all of the strings in the list share is \"\", or the empty string."
                    },
                    {
                        "username": "wwdj1924",
                        "content": "\"flower\" is not a prefix."
                    },
                    {
                        "username": "alpycelf",
                        "content": "Dear god...\nTurns out I didn't read the question carefully. (It wasn't written clearly though)\nI made it so it finds the longest common prefix inside the array.\nBUT\n\nInput:    [\"reflower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExpected: \"\"\n\nApparently it asks me to find the common prefix shared by ALL of the elements."
                    },
                    {
                        "username": "user7067M",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  It says **prefix** not **contains**. \"fl\" is not a prefix in \"reflower\" but is a prefix in \"flow\" and \"flight\"."
                    },
                    {
                        "username": "Jeetpal",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  For example, the index 0, ie \"reflower\", doesn\\'t have \"fl\" prefix, hence, it contradicts all elements having prefix of \"fl\""
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "I still didn\\'t understand, all elements shares \"fl\"? "
                    },
                    {
                        "username": "ejqgpt",
                        "content": "It says that time complexity of the first provided solution by leetcode itself is O(S) where S is the sum of lengths of all strings. However in the 5th line, **indexOf** method of String is called. So, **indexOf** method must finish execution in O(1) for complexity to be O(S) finally. Does it work in O(1) ?"
                    },
                    {
                        "username": "rajatkumargla19",
                        "content": "no....indexOf() works in O(n) for array\nbut leetcode official solution has O(S) time complexity...observe again"
                    },
                    {
                        "username": "esauceda2725",
                        "content": "The `[\"\",\"\"]` test case is wild. The constraints clearly say that the elements in `strs` will only consist of English letters. NOT SYMBOLS OR PUNCTUATIONS."
                    },
                    {
                        "username": "kanteshkm",
                        "content": "is problem statement is confusing?. i was thinking we need to find max common prefix in any order like {\"spoiler\", \"flower\", \"flow\", \"flight\"}, still output should be \"fl\""
                    },
                    {
                        "username": "LeetCodeMoAb",
                        "content": "I believe when they say common, it means in every single word.  The best way to word this would have been \"find the longest common sequence in all words that begins at index 0\".  Still not a perfect question, but still better than saying \"prefix\". "
                    }
                ]
            },
            {
                "id": 1736231,
                "content": [
                    {
                        "username": "BrajBliss",
                        "content": "This is a medium level question man."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the vertical scanning strategy:\n\nhttps://youtube.com/watch?v=SiNDN2M4dtQ"
                    },
                    {
                        "username": "jerryy147",
                        "content": "my 100th problem :D"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "congrats :D"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i wrote the slowest solution to this problem "
                    },
                    {
                        "username": "iaashu98",
                        "content": "wow, congrats. Please share link, I want to write slowe solution than you."
                    },
                    {
                        "username": "dmytrochyrva",
                        "content": "Hello, I am a bit confused,  I have set of inputs:\\n[\"reflower\",\"flow\",\"flight\"]\\n\\nand it is clear that the longest prefix here is \"fl\"\\nbut test case fails for some reason and says that:\\n\\nExpected: \"\"\\n\\nHas anyone had this issue?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its prefix.. meaning the beginning of each string. \"fl\" is not the beginning of \"reflower\" "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "[@bmagana5](/bmagana5)  The question wasn\\'t worded clearly at all. It asked for the most common prefix amongst an array of strings, not the most common prefix of ALL STRINGS within an array (which is apparently what it actually wanted)"
                    },
                    {
                        "username": "ArbreD",
                        "content": "[@bmagana5](/bmagana5) Thank you so much. Otherwise, I would take a couple of time fighting with it =))"
                    },
                    {
                        "username": "bmagana5",
                        "content": "it's gotta be the longest possible prefix that matches for all of the strings in the list. The substring 'fl' works for both 'flow' and 'flight', but not in 'reflower', as 'reflower' begins with the characters 're', so it stands that the longest prefix that all of the strings in the list share is \"\", or the empty string."
                    },
                    {
                        "username": "wwdj1924",
                        "content": "\"flower\" is not a prefix."
                    },
                    {
                        "username": "alpycelf",
                        "content": "Dear god...\nTurns out I didn't read the question carefully. (It wasn't written clearly though)\nI made it so it finds the longest common prefix inside the array.\nBUT\n\nInput:    [\"reflower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExpected: \"\"\n\nApparently it asks me to find the common prefix shared by ALL of the elements."
                    },
                    {
                        "username": "user7067M",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  It says **prefix** not **contains**. \"fl\" is not a prefix in \"reflower\" but is a prefix in \"flow\" and \"flight\"."
                    },
                    {
                        "username": "Jeetpal",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  For example, the index 0, ie \"reflower\", doesn\\'t have \"fl\" prefix, hence, it contradicts all elements having prefix of \"fl\""
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "I still didn\\'t understand, all elements shares \"fl\"? "
                    },
                    {
                        "username": "ejqgpt",
                        "content": "It says that time complexity of the first provided solution by leetcode itself is O(S) where S is the sum of lengths of all strings. However in the 5th line, **indexOf** method of String is called. So, **indexOf** method must finish execution in O(1) for complexity to be O(S) finally. Does it work in O(1) ?"
                    },
                    {
                        "username": "rajatkumargla19",
                        "content": "no....indexOf() works in O(n) for array\nbut leetcode official solution has O(S) time complexity...observe again"
                    },
                    {
                        "username": "esauceda2725",
                        "content": "The `[\"\",\"\"]` test case is wild. The constraints clearly say that the elements in `strs` will only consist of English letters. NOT SYMBOLS OR PUNCTUATIONS."
                    },
                    {
                        "username": "kanteshkm",
                        "content": "is problem statement is confusing?. i was thinking we need to find max common prefix in any order like {\"spoiler\", \"flower\", \"flow\", \"flight\"}, still output should be \"fl\""
                    },
                    {
                        "username": "LeetCodeMoAb",
                        "content": "I believe when they say common, it means in every single word.  The best way to word this would have been \"find the longest common sequence in all words that begins at index 0\".  Still not a perfect question, but still better than saying \"prefix\". "
                    }
                ]
            },
            {
                "id": 1718796,
                "content": [
                    {
                        "username": "BrajBliss",
                        "content": "This is a medium level question man."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the vertical scanning strategy:\n\nhttps://youtube.com/watch?v=SiNDN2M4dtQ"
                    },
                    {
                        "username": "jerryy147",
                        "content": "my 100th problem :D"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "congrats :D"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i wrote the slowest solution to this problem "
                    },
                    {
                        "username": "iaashu98",
                        "content": "wow, congrats. Please share link, I want to write slowe solution than you."
                    },
                    {
                        "username": "dmytrochyrva",
                        "content": "Hello, I am a bit confused,  I have set of inputs:\\n[\"reflower\",\"flow\",\"flight\"]\\n\\nand it is clear that the longest prefix here is \"fl\"\\nbut test case fails for some reason and says that:\\n\\nExpected: \"\"\\n\\nHas anyone had this issue?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its prefix.. meaning the beginning of each string. \"fl\" is not the beginning of \"reflower\" "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "[@bmagana5](/bmagana5)  The question wasn\\'t worded clearly at all. It asked for the most common prefix amongst an array of strings, not the most common prefix of ALL STRINGS within an array (which is apparently what it actually wanted)"
                    },
                    {
                        "username": "ArbreD",
                        "content": "[@bmagana5](/bmagana5) Thank you so much. Otherwise, I would take a couple of time fighting with it =))"
                    },
                    {
                        "username": "bmagana5",
                        "content": "it's gotta be the longest possible prefix that matches for all of the strings in the list. The substring 'fl' works for both 'flow' and 'flight', but not in 'reflower', as 'reflower' begins with the characters 're', so it stands that the longest prefix that all of the strings in the list share is \"\", or the empty string."
                    },
                    {
                        "username": "wwdj1924",
                        "content": "\"flower\" is not a prefix."
                    },
                    {
                        "username": "alpycelf",
                        "content": "Dear god...\nTurns out I didn't read the question carefully. (It wasn't written clearly though)\nI made it so it finds the longest common prefix inside the array.\nBUT\n\nInput:    [\"reflower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExpected: \"\"\n\nApparently it asks me to find the common prefix shared by ALL of the elements."
                    },
                    {
                        "username": "user7067M",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  It says **prefix** not **contains**. \"fl\" is not a prefix in \"reflower\" but is a prefix in \"flow\" and \"flight\"."
                    },
                    {
                        "username": "Jeetpal",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  For example, the index 0, ie \"reflower\", doesn\\'t have \"fl\" prefix, hence, it contradicts all elements having prefix of \"fl\""
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "I still didn\\'t understand, all elements shares \"fl\"? "
                    },
                    {
                        "username": "ejqgpt",
                        "content": "It says that time complexity of the first provided solution by leetcode itself is O(S) where S is the sum of lengths of all strings. However in the 5th line, **indexOf** method of String is called. So, **indexOf** method must finish execution in O(1) for complexity to be O(S) finally. Does it work in O(1) ?"
                    },
                    {
                        "username": "rajatkumargla19",
                        "content": "no....indexOf() works in O(n) for array\nbut leetcode official solution has O(S) time complexity...observe again"
                    },
                    {
                        "username": "esauceda2725",
                        "content": "The `[\"\",\"\"]` test case is wild. The constraints clearly say that the elements in `strs` will only consist of English letters. NOT SYMBOLS OR PUNCTUATIONS."
                    },
                    {
                        "username": "kanteshkm",
                        "content": "is problem statement is confusing?. i was thinking we need to find max common prefix in any order like {\"spoiler\", \"flower\", \"flow\", \"flight\"}, still output should be \"fl\""
                    },
                    {
                        "username": "LeetCodeMoAb",
                        "content": "I believe when they say common, it means in every single word.  The best way to word this would have been \"find the longest common sequence in all words that begins at index 0\".  Still not a perfect question, but still better than saying \"prefix\". "
                    }
                ]
            },
            {
                "id": 1568113,
                "content": [
                    {
                        "username": "BrajBliss",
                        "content": "This is a medium level question man."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the vertical scanning strategy:\n\nhttps://youtube.com/watch?v=SiNDN2M4dtQ"
                    },
                    {
                        "username": "jerryy147",
                        "content": "my 100th problem :D"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "congrats :D"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i wrote the slowest solution to this problem "
                    },
                    {
                        "username": "iaashu98",
                        "content": "wow, congrats. Please share link, I want to write slowe solution than you."
                    },
                    {
                        "username": "dmytrochyrva",
                        "content": "Hello, I am a bit confused,  I have set of inputs:\\n[\"reflower\",\"flow\",\"flight\"]\\n\\nand it is clear that the longest prefix here is \"fl\"\\nbut test case fails for some reason and says that:\\n\\nExpected: \"\"\\n\\nHas anyone had this issue?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its prefix.. meaning the beginning of each string. \"fl\" is not the beginning of \"reflower\" "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "[@bmagana5](/bmagana5)  The question wasn\\'t worded clearly at all. It asked for the most common prefix amongst an array of strings, not the most common prefix of ALL STRINGS within an array (which is apparently what it actually wanted)"
                    },
                    {
                        "username": "ArbreD",
                        "content": "[@bmagana5](/bmagana5) Thank you so much. Otherwise, I would take a couple of time fighting with it =))"
                    },
                    {
                        "username": "bmagana5",
                        "content": "it's gotta be the longest possible prefix that matches for all of the strings in the list. The substring 'fl' works for both 'flow' and 'flight', but not in 'reflower', as 'reflower' begins with the characters 're', so it stands that the longest prefix that all of the strings in the list share is \"\", or the empty string."
                    },
                    {
                        "username": "wwdj1924",
                        "content": "\"flower\" is not a prefix."
                    },
                    {
                        "username": "alpycelf",
                        "content": "Dear god...\nTurns out I didn't read the question carefully. (It wasn't written clearly though)\nI made it so it finds the longest common prefix inside the array.\nBUT\n\nInput:    [\"reflower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExpected: \"\"\n\nApparently it asks me to find the common prefix shared by ALL of the elements."
                    },
                    {
                        "username": "user7067M",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  It says **prefix** not **contains**. \"fl\" is not a prefix in \"reflower\" but is a prefix in \"flow\" and \"flight\"."
                    },
                    {
                        "username": "Jeetpal",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  For example, the index 0, ie \"reflower\", doesn\\'t have \"fl\" prefix, hence, it contradicts all elements having prefix of \"fl\""
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "I still didn\\'t understand, all elements shares \"fl\"? "
                    },
                    {
                        "username": "ejqgpt",
                        "content": "It says that time complexity of the first provided solution by leetcode itself is O(S) where S is the sum of lengths of all strings. However in the 5th line, **indexOf** method of String is called. So, **indexOf** method must finish execution in O(1) for complexity to be O(S) finally. Does it work in O(1) ?"
                    },
                    {
                        "username": "rajatkumargla19",
                        "content": "no....indexOf() works in O(n) for array\nbut leetcode official solution has O(S) time complexity...observe again"
                    },
                    {
                        "username": "esauceda2725",
                        "content": "The `[\"\",\"\"]` test case is wild. The constraints clearly say that the elements in `strs` will only consist of English letters. NOT SYMBOLS OR PUNCTUATIONS."
                    },
                    {
                        "username": "kanteshkm",
                        "content": "is problem statement is confusing?. i was thinking we need to find max common prefix in any order like {\"spoiler\", \"flower\", \"flow\", \"flight\"}, still output should be \"fl\""
                    },
                    {
                        "username": "LeetCodeMoAb",
                        "content": "I believe when they say common, it means in every single word.  The best way to word this would have been \"find the longest common sequence in all words that begins at index 0\".  Still not a perfect question, but still better than saying \"prefix\". "
                    }
                ]
            },
            {
                "id": 1853244,
                "content": [
                    {
                        "username": "BrajBliss",
                        "content": "This is a medium level question man."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the vertical scanning strategy:\n\nhttps://youtube.com/watch?v=SiNDN2M4dtQ"
                    },
                    {
                        "username": "jerryy147",
                        "content": "my 100th problem :D"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "congrats :D"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i wrote the slowest solution to this problem "
                    },
                    {
                        "username": "iaashu98",
                        "content": "wow, congrats. Please share link, I want to write slowe solution than you."
                    },
                    {
                        "username": "dmytrochyrva",
                        "content": "Hello, I am a bit confused,  I have set of inputs:\\n[\"reflower\",\"flow\",\"flight\"]\\n\\nand it is clear that the longest prefix here is \"fl\"\\nbut test case fails for some reason and says that:\\n\\nExpected: \"\"\\n\\nHas anyone had this issue?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its prefix.. meaning the beginning of each string. \"fl\" is not the beginning of \"reflower\" "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "[@bmagana5](/bmagana5)  The question wasn\\'t worded clearly at all. It asked for the most common prefix amongst an array of strings, not the most common prefix of ALL STRINGS within an array (which is apparently what it actually wanted)"
                    },
                    {
                        "username": "ArbreD",
                        "content": "[@bmagana5](/bmagana5) Thank you so much. Otherwise, I would take a couple of time fighting with it =))"
                    },
                    {
                        "username": "bmagana5",
                        "content": "it's gotta be the longest possible prefix that matches for all of the strings in the list. The substring 'fl' works for both 'flow' and 'flight', but not in 'reflower', as 'reflower' begins with the characters 're', so it stands that the longest prefix that all of the strings in the list share is \"\", or the empty string."
                    },
                    {
                        "username": "wwdj1924",
                        "content": "\"flower\" is not a prefix."
                    },
                    {
                        "username": "alpycelf",
                        "content": "Dear god...\nTurns out I didn't read the question carefully. (It wasn't written clearly though)\nI made it so it finds the longest common prefix inside the array.\nBUT\n\nInput:    [\"reflower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExpected: \"\"\n\nApparently it asks me to find the common prefix shared by ALL of the elements."
                    },
                    {
                        "username": "user7067M",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  It says **prefix** not **contains**. \"fl\" is not a prefix in \"reflower\" but is a prefix in \"flow\" and \"flight\"."
                    },
                    {
                        "username": "Jeetpal",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  For example, the index 0, ie \"reflower\", doesn\\'t have \"fl\" prefix, hence, it contradicts all elements having prefix of \"fl\""
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "I still didn\\'t understand, all elements shares \"fl\"? "
                    },
                    {
                        "username": "ejqgpt",
                        "content": "It says that time complexity of the first provided solution by leetcode itself is O(S) where S is the sum of lengths of all strings. However in the 5th line, **indexOf** method of String is called. So, **indexOf** method must finish execution in O(1) for complexity to be O(S) finally. Does it work in O(1) ?"
                    },
                    {
                        "username": "rajatkumargla19",
                        "content": "no....indexOf() works in O(n) for array\nbut leetcode official solution has O(S) time complexity...observe again"
                    },
                    {
                        "username": "esauceda2725",
                        "content": "The `[\"\",\"\"]` test case is wild. The constraints clearly say that the elements in `strs` will only consist of English letters. NOT SYMBOLS OR PUNCTUATIONS."
                    },
                    {
                        "username": "kanteshkm",
                        "content": "is problem statement is confusing?. i was thinking we need to find max common prefix in any order like {\"spoiler\", \"flower\", \"flow\", \"flight\"}, still output should be \"fl\""
                    },
                    {
                        "username": "LeetCodeMoAb",
                        "content": "I believe when they say common, it means in every single word.  The best way to word this would have been \"find the longest common sequence in all words that begins at index 0\".  Still not a perfect question, but still better than saying \"prefix\". "
                    }
                ]
            },
            {
                "id": 1699911,
                "content": [
                    {
                        "username": "BrajBliss",
                        "content": "This is a medium level question man."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the vertical scanning strategy:\n\nhttps://youtube.com/watch?v=SiNDN2M4dtQ"
                    },
                    {
                        "username": "jerryy147",
                        "content": "my 100th problem :D"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "congrats :D"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i wrote the slowest solution to this problem "
                    },
                    {
                        "username": "iaashu98",
                        "content": "wow, congrats. Please share link, I want to write slowe solution than you."
                    },
                    {
                        "username": "dmytrochyrva",
                        "content": "Hello, I am a bit confused,  I have set of inputs:\\n[\"reflower\",\"flow\",\"flight\"]\\n\\nand it is clear that the longest prefix here is \"fl\"\\nbut test case fails for some reason and says that:\\n\\nExpected: \"\"\\n\\nHas anyone had this issue?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its prefix.. meaning the beginning of each string. \"fl\" is not the beginning of \"reflower\" "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "[@bmagana5](/bmagana5)  The question wasn\\'t worded clearly at all. It asked for the most common prefix amongst an array of strings, not the most common prefix of ALL STRINGS within an array (which is apparently what it actually wanted)"
                    },
                    {
                        "username": "ArbreD",
                        "content": "[@bmagana5](/bmagana5) Thank you so much. Otherwise, I would take a couple of time fighting with it =))"
                    },
                    {
                        "username": "bmagana5",
                        "content": "it's gotta be the longest possible prefix that matches for all of the strings in the list. The substring 'fl' works for both 'flow' and 'flight', but not in 'reflower', as 'reflower' begins with the characters 're', so it stands that the longest prefix that all of the strings in the list share is \"\", or the empty string."
                    },
                    {
                        "username": "wwdj1924",
                        "content": "\"flower\" is not a prefix."
                    },
                    {
                        "username": "alpycelf",
                        "content": "Dear god...\nTurns out I didn't read the question carefully. (It wasn't written clearly though)\nI made it so it finds the longest common prefix inside the array.\nBUT\n\nInput:    [\"reflower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExpected: \"\"\n\nApparently it asks me to find the common prefix shared by ALL of the elements."
                    },
                    {
                        "username": "user7067M",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  It says **prefix** not **contains**. \"fl\" is not a prefix in \"reflower\" but is a prefix in \"flow\" and \"flight\"."
                    },
                    {
                        "username": "Jeetpal",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  For example, the index 0, ie \"reflower\", doesn\\'t have \"fl\" prefix, hence, it contradicts all elements having prefix of \"fl\""
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "I still didn\\'t understand, all elements shares \"fl\"? "
                    },
                    {
                        "username": "ejqgpt",
                        "content": "It says that time complexity of the first provided solution by leetcode itself is O(S) where S is the sum of lengths of all strings. However in the 5th line, **indexOf** method of String is called. So, **indexOf** method must finish execution in O(1) for complexity to be O(S) finally. Does it work in O(1) ?"
                    },
                    {
                        "username": "rajatkumargla19",
                        "content": "no....indexOf() works in O(n) for array\nbut leetcode official solution has O(S) time complexity...observe again"
                    },
                    {
                        "username": "esauceda2725",
                        "content": "The `[\"\",\"\"]` test case is wild. The constraints clearly say that the elements in `strs` will only consist of English letters. NOT SYMBOLS OR PUNCTUATIONS."
                    },
                    {
                        "username": "kanteshkm",
                        "content": "is problem statement is confusing?. i was thinking we need to find max common prefix in any order like {\"spoiler\", \"flower\", \"flow\", \"flight\"}, still output should be \"fl\""
                    },
                    {
                        "username": "LeetCodeMoAb",
                        "content": "I believe when they say common, it means in every single word.  The best way to word this would have been \"find the longest common sequence in all words that begins at index 0\".  Still not a perfect question, but still better than saying \"prefix\". "
                    }
                ]
            },
            {
                "id": 1695930,
                "content": [
                    {
                        "username": "FakharElyes",
                        "content": "I think there s a problem with the test case [\"flower\",\"fkow\"]\\n\\nOutput\\n\"ow\"\\nExpected\\n\"f\"\\n\\nany 1 can shed some light?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Look up what prefix is"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "the prefix is the beginning of a word"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "> In the worst case we have n equal strings of length m.\\n> Time complexity is O(S), where S = m \\xB7 n. \\n> [because] T(n) = 2 \\xB7 T(n/2) + O(m). \\n \\nIn my understanding, this means there\\'s log\\u2082(n) calls that are O(m) each, meaning complexity should be O(m \\xB7 log(n)), right?"
                    },
                    {
                        "username": "MangoMat",
                        "content": "lol, I get an error because my output is \"\" but expected output is \"\"? whats the difference??\\n "
                    },
                    {
                        "username": "kartikis26",
                        "content": "This is a good question, one of the condition says \n\"strs[i] consists of only lowercase English letters.\"\n\nbut they have test case to check [\"\"] as input, \nhow can empty string be considered as english letter, this shouldn't be the corner case as per the question description"
                    },
                    {
                        "username": "CT-7567",
                        "content": "LoL while replying to you I could\\'t comment with empty string :)"
                    },
                    {
                        "username": "emma_x",
                        "content": "Have anyone had the same issue? How to solve this test case? Python3. \\nInput\\nstrs =[\"\",\"\"]\\nOutput\\nnull\\nExpected\\n\"\""
                    },
                    {
                        "username": "chypso",
                        "content": "Just change your default answer from None to \"\" "
                    },
                    {
                        "username": "user7734BK",
                        "content": "Hi, send the code so I can try to figure out"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Yea I just got the same error; did you ever find out??"
                    },
                    {
                        "username": "lukarazmadze2001",
                        "content": "So if I get correctly if first letter of the word is not the same as other ones we can already say that output is empty string so for example if words are just and adjustment the answer will be \"\" but if words are list = [answer, abu dhabi, and]  the answer will be a "
                    },
                    {
                        "username": "kevinlhit",
                        "content": "why input [\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...] is expect \"aa\"\\uFF1Fso weird"
                    },
                    {
                        "username": "anurag14200314",
                        "content": "==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000150 at pc 0x000000345a71 bp 0x7ffd66beb470 sp 0x7ffd66beb468\\n\\n\\nwhy this?"
                    },
                    {
                        "username": "anshul_paigwar",
                        "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int i = 0, smallest_len = strs[0].size();\\n        for(auto str: strs){\\n            if(str.size()<smallest_len) smallest_len = str.size();\\n        }\\n        string common_str = \"\";\\n        for(int i=0; i<smallest_len; i++){\\n            bool common = true;\\n            char c = strs[0][i];\\n            for(auto word:strs){\\n                if(word[i]!=c){\\n                    common = false;\\n                    break;\\n                }\\n            }\\n            if(common) common_str.append(1, c);\\n            else break;\\n        }\\n        return common_str;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ | JavaScript | Swift solution :\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-longest-common-prefix-string-c-java-python-solution/"
                    }
                ]
            },
            {
                "id": 1569693,
                "content": [
                    {
                        "username": "FakharElyes",
                        "content": "I think there s a problem with the test case [\"flower\",\"fkow\"]\\n\\nOutput\\n\"ow\"\\nExpected\\n\"f\"\\n\\nany 1 can shed some light?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Look up what prefix is"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "the prefix is the beginning of a word"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "> In the worst case we have n equal strings of length m.\\n> Time complexity is O(S), where S = m \\xB7 n. \\n> [because] T(n) = 2 \\xB7 T(n/2) + O(m). \\n \\nIn my understanding, this means there\\'s log\\u2082(n) calls that are O(m) each, meaning complexity should be O(m \\xB7 log(n)), right?"
                    },
                    {
                        "username": "MangoMat",
                        "content": "lol, I get an error because my output is \"\" but expected output is \"\"? whats the difference??\\n "
                    },
                    {
                        "username": "kartikis26",
                        "content": "This is a good question, one of the condition says \n\"strs[i] consists of only lowercase English letters.\"\n\nbut they have test case to check [\"\"] as input, \nhow can empty string be considered as english letter, this shouldn't be the corner case as per the question description"
                    },
                    {
                        "username": "CT-7567",
                        "content": "LoL while replying to you I could\\'t comment with empty string :)"
                    },
                    {
                        "username": "emma_x",
                        "content": "Have anyone had the same issue? How to solve this test case? Python3. \\nInput\\nstrs =[\"\",\"\"]\\nOutput\\nnull\\nExpected\\n\"\""
                    },
                    {
                        "username": "chypso",
                        "content": "Just change your default answer from None to \"\" "
                    },
                    {
                        "username": "user7734BK",
                        "content": "Hi, send the code so I can try to figure out"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Yea I just got the same error; did you ever find out??"
                    },
                    {
                        "username": "lukarazmadze2001",
                        "content": "So if I get correctly if first letter of the word is not the same as other ones we can already say that output is empty string so for example if words are just and adjustment the answer will be \"\" but if words are list = [answer, abu dhabi, and]  the answer will be a "
                    },
                    {
                        "username": "kevinlhit",
                        "content": "why input [\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...] is expect \"aa\"\\uFF1Fso weird"
                    },
                    {
                        "username": "anurag14200314",
                        "content": "==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000150 at pc 0x000000345a71 bp 0x7ffd66beb470 sp 0x7ffd66beb468\\n\\n\\nwhy this?"
                    },
                    {
                        "username": "anshul_paigwar",
                        "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int i = 0, smallest_len = strs[0].size();\\n        for(auto str: strs){\\n            if(str.size()<smallest_len) smallest_len = str.size();\\n        }\\n        string common_str = \"\";\\n        for(int i=0; i<smallest_len; i++){\\n            bool common = true;\\n            char c = strs[0][i];\\n            for(auto word:strs){\\n                if(word[i]!=c){\\n                    common = false;\\n                    break;\\n                }\\n            }\\n            if(common) common_str.append(1, c);\\n            else break;\\n        }\\n        return common_str;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ | JavaScript | Swift solution :\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-longest-common-prefix-string-c-java-python-solution/"
                    }
                ]
            },
            {
                "id": 1860445,
                "content": [
                    {
                        "username": "FakharElyes",
                        "content": "I think there s a problem with the test case [\"flower\",\"fkow\"]\\n\\nOutput\\n\"ow\"\\nExpected\\n\"f\"\\n\\nany 1 can shed some light?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Look up what prefix is"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "the prefix is the beginning of a word"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "> In the worst case we have n equal strings of length m.\\n> Time complexity is O(S), where S = m \\xB7 n. \\n> [because] T(n) = 2 \\xB7 T(n/2) + O(m). \\n \\nIn my understanding, this means there\\'s log\\u2082(n) calls that are O(m) each, meaning complexity should be O(m \\xB7 log(n)), right?"
                    },
                    {
                        "username": "MangoMat",
                        "content": "lol, I get an error because my output is \"\" but expected output is \"\"? whats the difference??\\n "
                    },
                    {
                        "username": "kartikis26",
                        "content": "This is a good question, one of the condition says \n\"strs[i] consists of only lowercase English letters.\"\n\nbut they have test case to check [\"\"] as input, \nhow can empty string be considered as english letter, this shouldn't be the corner case as per the question description"
                    },
                    {
                        "username": "CT-7567",
                        "content": "LoL while replying to you I could\\'t comment with empty string :)"
                    },
                    {
                        "username": "emma_x",
                        "content": "Have anyone had the same issue? How to solve this test case? Python3. \\nInput\\nstrs =[\"\",\"\"]\\nOutput\\nnull\\nExpected\\n\"\""
                    },
                    {
                        "username": "chypso",
                        "content": "Just change your default answer from None to \"\" "
                    },
                    {
                        "username": "user7734BK",
                        "content": "Hi, send the code so I can try to figure out"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Yea I just got the same error; did you ever find out??"
                    },
                    {
                        "username": "lukarazmadze2001",
                        "content": "So if I get correctly if first letter of the word is not the same as other ones we can already say that output is empty string so for example if words are just and adjustment the answer will be \"\" but if words are list = [answer, abu dhabi, and]  the answer will be a "
                    },
                    {
                        "username": "kevinlhit",
                        "content": "why input [\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...] is expect \"aa\"\\uFF1Fso weird"
                    },
                    {
                        "username": "anurag14200314",
                        "content": "==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000150 at pc 0x000000345a71 bp 0x7ffd66beb470 sp 0x7ffd66beb468\\n\\n\\nwhy this?"
                    },
                    {
                        "username": "anshul_paigwar",
                        "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int i = 0, smallest_len = strs[0].size();\\n        for(auto str: strs){\\n            if(str.size()<smallest_len) smallest_len = str.size();\\n        }\\n        string common_str = \"\";\\n        for(int i=0; i<smallest_len; i++){\\n            bool common = true;\\n            char c = strs[0][i];\\n            for(auto word:strs){\\n                if(word[i]!=c){\\n                    common = false;\\n                    break;\\n                }\\n            }\\n            if(common) common_str.append(1, c);\\n            else break;\\n        }\\n        return common_str;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ | JavaScript | Swift solution :\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-longest-common-prefix-string-c-java-python-solution/"
                    }
                ]
            },
            {
                "id": 1811602,
                "content": [
                    {
                        "username": "FakharElyes",
                        "content": "I think there s a problem with the test case [\"flower\",\"fkow\"]\\n\\nOutput\\n\"ow\"\\nExpected\\n\"f\"\\n\\nany 1 can shed some light?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Look up what prefix is"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "the prefix is the beginning of a word"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "> In the worst case we have n equal strings of length m.\\n> Time complexity is O(S), where S = m \\xB7 n. \\n> [because] T(n) = 2 \\xB7 T(n/2) + O(m). \\n \\nIn my understanding, this means there\\'s log\\u2082(n) calls that are O(m) each, meaning complexity should be O(m \\xB7 log(n)), right?"
                    },
                    {
                        "username": "MangoMat",
                        "content": "lol, I get an error because my output is \"\" but expected output is \"\"? whats the difference??\\n "
                    },
                    {
                        "username": "kartikis26",
                        "content": "This is a good question, one of the condition says \n\"strs[i] consists of only lowercase English letters.\"\n\nbut they have test case to check [\"\"] as input, \nhow can empty string be considered as english letter, this shouldn't be the corner case as per the question description"
                    },
                    {
                        "username": "CT-7567",
                        "content": "LoL while replying to you I could\\'t comment with empty string :)"
                    },
                    {
                        "username": "emma_x",
                        "content": "Have anyone had the same issue? How to solve this test case? Python3. \\nInput\\nstrs =[\"\",\"\"]\\nOutput\\nnull\\nExpected\\n\"\""
                    },
                    {
                        "username": "chypso",
                        "content": "Just change your default answer from None to \"\" "
                    },
                    {
                        "username": "user7734BK",
                        "content": "Hi, send the code so I can try to figure out"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Yea I just got the same error; did you ever find out??"
                    },
                    {
                        "username": "lukarazmadze2001",
                        "content": "So if I get correctly if first letter of the word is not the same as other ones we can already say that output is empty string so for example if words are just and adjustment the answer will be \"\" but if words are list = [answer, abu dhabi, and]  the answer will be a "
                    },
                    {
                        "username": "kevinlhit",
                        "content": "why input [\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...] is expect \"aa\"\\uFF1Fso weird"
                    },
                    {
                        "username": "anurag14200314",
                        "content": "==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000150 at pc 0x000000345a71 bp 0x7ffd66beb470 sp 0x7ffd66beb468\\n\\n\\nwhy this?"
                    },
                    {
                        "username": "anshul_paigwar",
                        "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int i = 0, smallest_len = strs[0].size();\\n        for(auto str: strs){\\n            if(str.size()<smallest_len) smallest_len = str.size();\\n        }\\n        string common_str = \"\";\\n        for(int i=0; i<smallest_len; i++){\\n            bool common = true;\\n            char c = strs[0][i];\\n            for(auto word:strs){\\n                if(word[i]!=c){\\n                    common = false;\\n                    break;\\n                }\\n            }\\n            if(common) common_str.append(1, c);\\n            else break;\\n        }\\n        return common_str;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ | JavaScript | Swift solution :\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-longest-common-prefix-string-c-java-python-solution/"
                    }
                ]
            },
            {
                "id": 1765584,
                "content": [
                    {
                        "username": "FakharElyes",
                        "content": "I think there s a problem with the test case [\"flower\",\"fkow\"]\\n\\nOutput\\n\"ow\"\\nExpected\\n\"f\"\\n\\nany 1 can shed some light?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Look up what prefix is"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "the prefix is the beginning of a word"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "> In the worst case we have n equal strings of length m.\\n> Time complexity is O(S), where S = m \\xB7 n. \\n> [because] T(n) = 2 \\xB7 T(n/2) + O(m). \\n \\nIn my understanding, this means there\\'s log\\u2082(n) calls that are O(m) each, meaning complexity should be O(m \\xB7 log(n)), right?"
                    },
                    {
                        "username": "MangoMat",
                        "content": "lol, I get an error because my output is \"\" but expected output is \"\"? whats the difference??\\n "
                    },
                    {
                        "username": "kartikis26",
                        "content": "This is a good question, one of the condition says \n\"strs[i] consists of only lowercase English letters.\"\n\nbut they have test case to check [\"\"] as input, \nhow can empty string be considered as english letter, this shouldn't be the corner case as per the question description"
                    },
                    {
                        "username": "CT-7567",
                        "content": "LoL while replying to you I could\\'t comment with empty string :)"
                    },
                    {
                        "username": "emma_x",
                        "content": "Have anyone had the same issue? How to solve this test case? Python3. \\nInput\\nstrs =[\"\",\"\"]\\nOutput\\nnull\\nExpected\\n\"\""
                    },
                    {
                        "username": "chypso",
                        "content": "Just change your default answer from None to \"\" "
                    },
                    {
                        "username": "user7734BK",
                        "content": "Hi, send the code so I can try to figure out"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Yea I just got the same error; did you ever find out??"
                    },
                    {
                        "username": "lukarazmadze2001",
                        "content": "So if I get correctly if first letter of the word is not the same as other ones we can already say that output is empty string so for example if words are just and adjustment the answer will be \"\" but if words are list = [answer, abu dhabi, and]  the answer will be a "
                    },
                    {
                        "username": "kevinlhit",
                        "content": "why input [\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...] is expect \"aa\"\\uFF1Fso weird"
                    },
                    {
                        "username": "anurag14200314",
                        "content": "==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000150 at pc 0x000000345a71 bp 0x7ffd66beb470 sp 0x7ffd66beb468\\n\\n\\nwhy this?"
                    },
                    {
                        "username": "anshul_paigwar",
                        "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int i = 0, smallest_len = strs[0].size();\\n        for(auto str: strs){\\n            if(str.size()<smallest_len) smallest_len = str.size();\\n        }\\n        string common_str = \"\";\\n        for(int i=0; i<smallest_len; i++){\\n            bool common = true;\\n            char c = strs[0][i];\\n            for(auto word:strs){\\n                if(word[i]!=c){\\n                    common = false;\\n                    break;\\n                }\\n            }\\n            if(common) common_str.append(1, c);\\n            else break;\\n        }\\n        return common_str;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ | JavaScript | Swift solution :\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-longest-common-prefix-string-c-java-python-solution/"
                    }
                ]
            },
            {
                "id": 2007536,
                "content": [
                    {
                        "username": "FakharElyes",
                        "content": "I think there s a problem with the test case [\"flower\",\"fkow\"]\\n\\nOutput\\n\"ow\"\\nExpected\\n\"f\"\\n\\nany 1 can shed some light?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Look up what prefix is"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "the prefix is the beginning of a word"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "> In the worst case we have n equal strings of length m.\\n> Time complexity is O(S), where S = m \\xB7 n. \\n> [because] T(n) = 2 \\xB7 T(n/2) + O(m). \\n \\nIn my understanding, this means there\\'s log\\u2082(n) calls that are O(m) each, meaning complexity should be O(m \\xB7 log(n)), right?"
                    },
                    {
                        "username": "MangoMat",
                        "content": "lol, I get an error because my output is \"\" but expected output is \"\"? whats the difference??\\n "
                    },
                    {
                        "username": "kartikis26",
                        "content": "This is a good question, one of the condition says \n\"strs[i] consists of only lowercase English letters.\"\n\nbut they have test case to check [\"\"] as input, \nhow can empty string be considered as english letter, this shouldn't be the corner case as per the question description"
                    },
                    {
                        "username": "CT-7567",
                        "content": "LoL while replying to you I could\\'t comment with empty string :)"
                    },
                    {
                        "username": "emma_x",
                        "content": "Have anyone had the same issue? How to solve this test case? Python3. \\nInput\\nstrs =[\"\",\"\"]\\nOutput\\nnull\\nExpected\\n\"\""
                    },
                    {
                        "username": "chypso",
                        "content": "Just change your default answer from None to \"\" "
                    },
                    {
                        "username": "user7734BK",
                        "content": "Hi, send the code so I can try to figure out"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Yea I just got the same error; did you ever find out??"
                    },
                    {
                        "username": "lukarazmadze2001",
                        "content": "So if I get correctly if first letter of the word is not the same as other ones we can already say that output is empty string so for example if words are just and adjustment the answer will be \"\" but if words are list = [answer, abu dhabi, and]  the answer will be a "
                    },
                    {
                        "username": "kevinlhit",
                        "content": "why input [\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...] is expect \"aa\"\\uFF1Fso weird"
                    },
                    {
                        "username": "anurag14200314",
                        "content": "==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000150 at pc 0x000000345a71 bp 0x7ffd66beb470 sp 0x7ffd66beb468\\n\\n\\nwhy this?"
                    },
                    {
                        "username": "anshul_paigwar",
                        "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int i = 0, smallest_len = strs[0].size();\\n        for(auto str: strs){\\n            if(str.size()<smallest_len) smallest_len = str.size();\\n        }\\n        string common_str = \"\";\\n        for(int i=0; i<smallest_len; i++){\\n            bool common = true;\\n            char c = strs[0][i];\\n            for(auto word:strs){\\n                if(word[i]!=c){\\n                    common = false;\\n                    break;\\n                }\\n            }\\n            if(common) common_str.append(1, c);\\n            else break;\\n        }\\n        return common_str;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ | JavaScript | Swift solution :\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-longest-common-prefix-string-c-java-python-solution/"
                    }
                ]
            },
            {
                "id": 1996844,
                "content": [
                    {
                        "username": "FakharElyes",
                        "content": "I think there s a problem with the test case [\"flower\",\"fkow\"]\\n\\nOutput\\n\"ow\"\\nExpected\\n\"f\"\\n\\nany 1 can shed some light?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Look up what prefix is"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "the prefix is the beginning of a word"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "> In the worst case we have n equal strings of length m.\\n> Time complexity is O(S), where S = m \\xB7 n. \\n> [because] T(n) = 2 \\xB7 T(n/2) + O(m). \\n \\nIn my understanding, this means there\\'s log\\u2082(n) calls that are O(m) each, meaning complexity should be O(m \\xB7 log(n)), right?"
                    },
                    {
                        "username": "MangoMat",
                        "content": "lol, I get an error because my output is \"\" but expected output is \"\"? whats the difference??\\n "
                    },
                    {
                        "username": "kartikis26",
                        "content": "This is a good question, one of the condition says \n\"strs[i] consists of only lowercase English letters.\"\n\nbut they have test case to check [\"\"] as input, \nhow can empty string be considered as english letter, this shouldn't be the corner case as per the question description"
                    },
                    {
                        "username": "CT-7567",
                        "content": "LoL while replying to you I could\\'t comment with empty string :)"
                    },
                    {
                        "username": "emma_x",
                        "content": "Have anyone had the same issue? How to solve this test case? Python3. \\nInput\\nstrs =[\"\",\"\"]\\nOutput\\nnull\\nExpected\\n\"\""
                    },
                    {
                        "username": "chypso",
                        "content": "Just change your default answer from None to \"\" "
                    },
                    {
                        "username": "user7734BK",
                        "content": "Hi, send the code so I can try to figure out"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Yea I just got the same error; did you ever find out??"
                    },
                    {
                        "username": "lukarazmadze2001",
                        "content": "So if I get correctly if first letter of the word is not the same as other ones we can already say that output is empty string so for example if words are just and adjustment the answer will be \"\" but if words are list = [answer, abu dhabi, and]  the answer will be a "
                    },
                    {
                        "username": "kevinlhit",
                        "content": "why input [\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...] is expect \"aa\"\\uFF1Fso weird"
                    },
                    {
                        "username": "anurag14200314",
                        "content": "==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000150 at pc 0x000000345a71 bp 0x7ffd66beb470 sp 0x7ffd66beb468\\n\\n\\nwhy this?"
                    },
                    {
                        "username": "anshul_paigwar",
                        "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int i = 0, smallest_len = strs[0].size();\\n        for(auto str: strs){\\n            if(str.size()<smallest_len) smallest_len = str.size();\\n        }\\n        string common_str = \"\";\\n        for(int i=0; i<smallest_len; i++){\\n            bool common = true;\\n            char c = strs[0][i];\\n            for(auto word:strs){\\n                if(word[i]!=c){\\n                    common = false;\\n                    break;\\n                }\\n            }\\n            if(common) common_str.append(1, c);\\n            else break;\\n        }\\n        return common_str;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ | JavaScript | Swift solution :\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-longest-common-prefix-string-c-java-python-solution/"
                    }
                ]
            },
            {
                "id": 1693397,
                "content": [
                    {
                        "username": "FakharElyes",
                        "content": "I think there s a problem with the test case [\"flower\",\"fkow\"]\\n\\nOutput\\n\"ow\"\\nExpected\\n\"f\"\\n\\nany 1 can shed some light?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Look up what prefix is"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "the prefix is the beginning of a word"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "> In the worst case we have n equal strings of length m.\\n> Time complexity is O(S), where S = m \\xB7 n. \\n> [because] T(n) = 2 \\xB7 T(n/2) + O(m). \\n \\nIn my understanding, this means there\\'s log\\u2082(n) calls that are O(m) each, meaning complexity should be O(m \\xB7 log(n)), right?"
                    },
                    {
                        "username": "MangoMat",
                        "content": "lol, I get an error because my output is \"\" but expected output is \"\"? whats the difference??\\n "
                    },
                    {
                        "username": "kartikis26",
                        "content": "This is a good question, one of the condition says \n\"strs[i] consists of only lowercase English letters.\"\n\nbut they have test case to check [\"\"] as input, \nhow can empty string be considered as english letter, this shouldn't be the corner case as per the question description"
                    },
                    {
                        "username": "CT-7567",
                        "content": "LoL while replying to you I could\\'t comment with empty string :)"
                    },
                    {
                        "username": "emma_x",
                        "content": "Have anyone had the same issue? How to solve this test case? Python3. \\nInput\\nstrs =[\"\",\"\"]\\nOutput\\nnull\\nExpected\\n\"\""
                    },
                    {
                        "username": "chypso",
                        "content": "Just change your default answer from None to \"\" "
                    },
                    {
                        "username": "user7734BK",
                        "content": "Hi, send the code so I can try to figure out"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Yea I just got the same error; did you ever find out??"
                    },
                    {
                        "username": "lukarazmadze2001",
                        "content": "So if I get correctly if first letter of the word is not the same as other ones we can already say that output is empty string so for example if words are just and adjustment the answer will be \"\" but if words are list = [answer, abu dhabi, and]  the answer will be a "
                    },
                    {
                        "username": "kevinlhit",
                        "content": "why input [\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...] is expect \"aa\"\\uFF1Fso weird"
                    },
                    {
                        "username": "anurag14200314",
                        "content": "==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000150 at pc 0x000000345a71 bp 0x7ffd66beb470 sp 0x7ffd66beb468\\n\\n\\nwhy this?"
                    },
                    {
                        "username": "anshul_paigwar",
                        "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int i = 0, smallest_len = strs[0].size();\\n        for(auto str: strs){\\n            if(str.size()<smallest_len) smallest_len = str.size();\\n        }\\n        string common_str = \"\";\\n        for(int i=0; i<smallest_len; i++){\\n            bool common = true;\\n            char c = strs[0][i];\\n            for(auto word:strs){\\n                if(word[i]!=c){\\n                    common = false;\\n                    break;\\n                }\\n            }\\n            if(common) common_str.append(1, c);\\n            else break;\\n        }\\n        return common_str;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ | JavaScript | Swift solution :\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-longest-common-prefix-string-c-java-python-solution/"
                    }
                ]
            },
            {
                "id": 1625417,
                "content": [
                    {
                        "username": "FakharElyes",
                        "content": "I think there s a problem with the test case [\"flower\",\"fkow\"]\\n\\nOutput\\n\"ow\"\\nExpected\\n\"f\"\\n\\nany 1 can shed some light?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Look up what prefix is"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "the prefix is the beginning of a word"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "> In the worst case we have n equal strings of length m.\\n> Time complexity is O(S), where S = m \\xB7 n. \\n> [because] T(n) = 2 \\xB7 T(n/2) + O(m). \\n \\nIn my understanding, this means there\\'s log\\u2082(n) calls that are O(m) each, meaning complexity should be O(m \\xB7 log(n)), right?"
                    },
                    {
                        "username": "MangoMat",
                        "content": "lol, I get an error because my output is \"\" but expected output is \"\"? whats the difference??\\n "
                    },
                    {
                        "username": "kartikis26",
                        "content": "This is a good question, one of the condition says \n\"strs[i] consists of only lowercase English letters.\"\n\nbut they have test case to check [\"\"] as input, \nhow can empty string be considered as english letter, this shouldn't be the corner case as per the question description"
                    },
                    {
                        "username": "CT-7567",
                        "content": "LoL while replying to you I could\\'t comment with empty string :)"
                    },
                    {
                        "username": "emma_x",
                        "content": "Have anyone had the same issue? How to solve this test case? Python3. \\nInput\\nstrs =[\"\",\"\"]\\nOutput\\nnull\\nExpected\\n\"\""
                    },
                    {
                        "username": "chypso",
                        "content": "Just change your default answer from None to \"\" "
                    },
                    {
                        "username": "user7734BK",
                        "content": "Hi, send the code so I can try to figure out"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Yea I just got the same error; did you ever find out??"
                    },
                    {
                        "username": "lukarazmadze2001",
                        "content": "So if I get correctly if first letter of the word is not the same as other ones we can already say that output is empty string so for example if words are just and adjustment the answer will be \"\" but if words are list = [answer, abu dhabi, and]  the answer will be a "
                    },
                    {
                        "username": "kevinlhit",
                        "content": "why input [\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...] is expect \"aa\"\\uFF1Fso weird"
                    },
                    {
                        "username": "anurag14200314",
                        "content": "==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000150 at pc 0x000000345a71 bp 0x7ffd66beb470 sp 0x7ffd66beb468\\n\\n\\nwhy this?"
                    },
                    {
                        "username": "anshul_paigwar",
                        "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int i = 0, smallest_len = strs[0].size();\\n        for(auto str: strs){\\n            if(str.size()<smallest_len) smallest_len = str.size();\\n        }\\n        string common_str = \"\";\\n        for(int i=0; i<smallest_len; i++){\\n            bool common = true;\\n            char c = strs[0][i];\\n            for(auto word:strs){\\n                if(word[i]!=c){\\n                    common = false;\\n                    break;\\n                }\\n            }\\n            if(common) common_str.append(1, c);\\n            else break;\\n        }\\n        return common_str;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ | JavaScript | Swift solution :\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-longest-common-prefix-string-c-java-python-solution/"
                    }
                ]
            },
            {
                "id": 1576657,
                "content": [
                    {
                        "username": "FakharElyes",
                        "content": "I think there s a problem with the test case [\"flower\",\"fkow\"]\\n\\nOutput\\n\"ow\"\\nExpected\\n\"f\"\\n\\nany 1 can shed some light?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Look up what prefix is"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "the prefix is the beginning of a word"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "> In the worst case we have n equal strings of length m.\\n> Time complexity is O(S), where S = m \\xB7 n. \\n> [because] T(n) = 2 \\xB7 T(n/2) + O(m). \\n \\nIn my understanding, this means there\\'s log\\u2082(n) calls that are O(m) each, meaning complexity should be O(m \\xB7 log(n)), right?"
                    },
                    {
                        "username": "MangoMat",
                        "content": "lol, I get an error because my output is \"\" but expected output is \"\"? whats the difference??\\n "
                    },
                    {
                        "username": "kartikis26",
                        "content": "This is a good question, one of the condition says \n\"strs[i] consists of only lowercase English letters.\"\n\nbut they have test case to check [\"\"] as input, \nhow can empty string be considered as english letter, this shouldn't be the corner case as per the question description"
                    },
                    {
                        "username": "CT-7567",
                        "content": "LoL while replying to you I could\\'t comment with empty string :)"
                    },
                    {
                        "username": "emma_x",
                        "content": "Have anyone had the same issue? How to solve this test case? Python3. \\nInput\\nstrs =[\"\",\"\"]\\nOutput\\nnull\\nExpected\\n\"\""
                    },
                    {
                        "username": "chypso",
                        "content": "Just change your default answer from None to \"\" "
                    },
                    {
                        "username": "user7734BK",
                        "content": "Hi, send the code so I can try to figure out"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Yea I just got the same error; did you ever find out??"
                    },
                    {
                        "username": "lukarazmadze2001",
                        "content": "So if I get correctly if first letter of the word is not the same as other ones we can already say that output is empty string so for example if words are just and adjustment the answer will be \"\" but if words are list = [answer, abu dhabi, and]  the answer will be a "
                    },
                    {
                        "username": "kevinlhit",
                        "content": "why input [\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...] is expect \"aa\"\\uFF1Fso weird"
                    },
                    {
                        "username": "anurag14200314",
                        "content": "==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000150 at pc 0x000000345a71 bp 0x7ffd66beb470 sp 0x7ffd66beb468\\n\\n\\nwhy this?"
                    },
                    {
                        "username": "anshul_paigwar",
                        "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int i = 0, smallest_len = strs[0].size();\\n        for(auto str: strs){\\n            if(str.size()<smallest_len) smallest_len = str.size();\\n        }\\n        string common_str = \"\";\\n        for(int i=0; i<smallest_len; i++){\\n            bool common = true;\\n            char c = strs[0][i];\\n            for(auto word:strs){\\n                if(word[i]!=c){\\n                    common = false;\\n                    break;\\n                }\\n            }\\n            if(common) common_str.append(1, c);\\n            else break;\\n        }\\n        return common_str;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ | JavaScript | Swift solution :\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-longest-common-prefix-string-c-java-python-solution/"
                    }
                ]
            },
            {
                "id": 1573975,
                "content": [
                    {
                        "username": "styopa",
                        "content": "I think that [] shouldn\\'t be a test case. Mathematically speaking, there is no defined longest prefix. They suggest that the answer is \"\", but \"randomword\" is also a common prefix because every string that is in the list has it as a prefix. It\\'s kinda like taking the intersection of all sets inside the empty set in set theory."
                    },
                    {
                        "username": "zhangxi1994",
                        "content": "I don't understand the time complexity in editorial solution#3(Divide and conquer). My answer to this approach is somehow O(mn)..."
                    },
                    {
                        "username": "pushen",
                        "content": "It seems that we need to go through every letter in the first string to compare the substring with the rest of string s in the array. So it will take O(n^2).\\nIs there a way of O(nlgn) or O(n)?"
                    },
                    {
                        "username": "john_112",
                        "content": "Good Solution in C++, Java. Python:\\nhttps://www.techiedelight.com/find-longest-common-prefix-lcp-strings/\\nhttps://www.techiedelight.com/longest-common-prefix-given-set-strings-using-trie/"
                    },
                    {
                        "username": "firerex",
                        "content": "Please be more clear when you asking a problem. \\n\\nFor this problem, I was thinking to find out the longest common prefix, NOT FOR ALL string. \\n\\nFor my understanding if the arry like this [\"abc\", \"abcd\", \"aef\"], the result should be \"abc\". But your actually asking to get \"a\". \\n"
                    },
                    {
                        "username": "nilesh_agarwal",
                        "content": "when its written common it indicates you need to compare with all the strings"
                    },
                    {
                        "username": "rajender7",
                        "content": "I know a Trie can be used to solve this problem. But is that an overkill?"
                    },
                    {
                        "username": "raniakhemiri",
                        "content": "test case : strs =\\n[\"flower\",\"fkow\"]\\nisn\\'t the longest common prefix here \"ow\"\\n\\nit says : Expected\\n\"f\" \\n\\nI\\'m confused? "
                    },
                    {
                        "username": "ARA34",
                        "content": "Not sure I completely understand this question. Using testcase and running code on ide [\"dog\", \"flower\", \"flight\"]:\\nI get - \"dog\"\\nExpected - \"\"\\n\\nBut the code passes through the tests and shows I get \"\" for this testcase on leetcode???"
                    },
                    {
                        "username": "AfatDog",
                        "content": "help  :0\\n im struggling im new\\n"
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'ve passed all the test cases.... JUST THE LAST FIVE OF THEM ARE DRIVING ME INSANE"
                    }
                ]
            },
            {
                "id": 1571040,
                "content": [
                    {
                        "username": "styopa",
                        "content": "I think that [] shouldn\\'t be a test case. Mathematically speaking, there is no defined longest prefix. They suggest that the answer is \"\", but \"randomword\" is also a common prefix because every string that is in the list has it as a prefix. It\\'s kinda like taking the intersection of all sets inside the empty set in set theory."
                    },
                    {
                        "username": "zhangxi1994",
                        "content": "I don't understand the time complexity in editorial solution#3(Divide and conquer). My answer to this approach is somehow O(mn)..."
                    },
                    {
                        "username": "pushen",
                        "content": "It seems that we need to go through every letter in the first string to compare the substring with the rest of string s in the array. So it will take O(n^2).\\nIs there a way of O(nlgn) or O(n)?"
                    },
                    {
                        "username": "john_112",
                        "content": "Good Solution in C++, Java. Python:\\nhttps://www.techiedelight.com/find-longest-common-prefix-lcp-strings/\\nhttps://www.techiedelight.com/longest-common-prefix-given-set-strings-using-trie/"
                    },
                    {
                        "username": "firerex",
                        "content": "Please be more clear when you asking a problem. \\n\\nFor this problem, I was thinking to find out the longest common prefix, NOT FOR ALL string. \\n\\nFor my understanding if the arry like this [\"abc\", \"abcd\", \"aef\"], the result should be \"abc\". But your actually asking to get \"a\". \\n"
                    },
                    {
                        "username": "nilesh_agarwal",
                        "content": "when its written common it indicates you need to compare with all the strings"
                    },
                    {
                        "username": "rajender7",
                        "content": "I know a Trie can be used to solve this problem. But is that an overkill?"
                    },
                    {
                        "username": "raniakhemiri",
                        "content": "test case : strs =\\n[\"flower\",\"fkow\"]\\nisn\\'t the longest common prefix here \"ow\"\\n\\nit says : Expected\\n\"f\" \\n\\nI\\'m confused? "
                    },
                    {
                        "username": "ARA34",
                        "content": "Not sure I completely understand this question. Using testcase and running code on ide [\"dog\", \"flower\", \"flight\"]:\\nI get - \"dog\"\\nExpected - \"\"\\n\\nBut the code passes through the tests and shows I get \"\" for this testcase on leetcode???"
                    },
                    {
                        "username": "AfatDog",
                        "content": "help  :0\\n im struggling im new\\n"
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'ve passed all the test cases.... JUST THE LAST FIVE OF THEM ARE DRIVING ME INSANE"
                    }
                ]
            },
            {
                "id": 1571041,
                "content": [
                    {
                        "username": "styopa",
                        "content": "I think that [] shouldn\\'t be a test case. Mathematically speaking, there is no defined longest prefix. They suggest that the answer is \"\", but \"randomword\" is also a common prefix because every string that is in the list has it as a prefix. It\\'s kinda like taking the intersection of all sets inside the empty set in set theory."
                    },
                    {
                        "username": "zhangxi1994",
                        "content": "I don't understand the time complexity in editorial solution#3(Divide and conquer). My answer to this approach is somehow O(mn)..."
                    },
                    {
                        "username": "pushen",
                        "content": "It seems that we need to go through every letter in the first string to compare the substring with the rest of string s in the array. So it will take O(n^2).\\nIs there a way of O(nlgn) or O(n)?"
                    },
                    {
                        "username": "john_112",
                        "content": "Good Solution in C++, Java. Python:\\nhttps://www.techiedelight.com/find-longest-common-prefix-lcp-strings/\\nhttps://www.techiedelight.com/longest-common-prefix-given-set-strings-using-trie/"
                    },
                    {
                        "username": "firerex",
                        "content": "Please be more clear when you asking a problem. \\n\\nFor this problem, I was thinking to find out the longest common prefix, NOT FOR ALL string. \\n\\nFor my understanding if the arry like this [\"abc\", \"abcd\", \"aef\"], the result should be \"abc\". But your actually asking to get \"a\". \\n"
                    },
                    {
                        "username": "nilesh_agarwal",
                        "content": "when its written common it indicates you need to compare with all the strings"
                    },
                    {
                        "username": "rajender7",
                        "content": "I know a Trie can be used to solve this problem. But is that an overkill?"
                    },
                    {
                        "username": "raniakhemiri",
                        "content": "test case : strs =\\n[\"flower\",\"fkow\"]\\nisn\\'t the longest common prefix here \"ow\"\\n\\nit says : Expected\\n\"f\" \\n\\nI\\'m confused? "
                    },
                    {
                        "username": "ARA34",
                        "content": "Not sure I completely understand this question. Using testcase and running code on ide [\"dog\", \"flower\", \"flight\"]:\\nI get - \"dog\"\\nExpected - \"\"\\n\\nBut the code passes through the tests and shows I get \"\" for this testcase on leetcode???"
                    },
                    {
                        "username": "AfatDog",
                        "content": "help  :0\\n im struggling im new\\n"
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'ve passed all the test cases.... JUST THE LAST FIVE OF THEM ARE DRIVING ME INSANE"
                    }
                ]
            },
            {
                "id": 1569953,
                "content": [
                    {
                        "username": "styopa",
                        "content": "I think that [] shouldn\\'t be a test case. Mathematically speaking, there is no defined longest prefix. They suggest that the answer is \"\", but \"randomword\" is also a common prefix because every string that is in the list has it as a prefix. It\\'s kinda like taking the intersection of all sets inside the empty set in set theory."
                    },
                    {
                        "username": "zhangxi1994",
                        "content": "I don't understand the time complexity in editorial solution#3(Divide and conquer). My answer to this approach is somehow O(mn)..."
                    },
                    {
                        "username": "pushen",
                        "content": "It seems that we need to go through every letter in the first string to compare the substring with the rest of string s in the array. So it will take O(n^2).\\nIs there a way of O(nlgn) or O(n)?"
                    },
                    {
                        "username": "john_112",
                        "content": "Good Solution in C++, Java. Python:\\nhttps://www.techiedelight.com/find-longest-common-prefix-lcp-strings/\\nhttps://www.techiedelight.com/longest-common-prefix-given-set-strings-using-trie/"
                    },
                    {
                        "username": "firerex",
                        "content": "Please be more clear when you asking a problem. \\n\\nFor this problem, I was thinking to find out the longest common prefix, NOT FOR ALL string. \\n\\nFor my understanding if the arry like this [\"abc\", \"abcd\", \"aef\"], the result should be \"abc\". But your actually asking to get \"a\". \\n"
                    },
                    {
                        "username": "nilesh_agarwal",
                        "content": "when its written common it indicates you need to compare with all the strings"
                    },
                    {
                        "username": "rajender7",
                        "content": "I know a Trie can be used to solve this problem. But is that an overkill?"
                    },
                    {
                        "username": "raniakhemiri",
                        "content": "test case : strs =\\n[\"flower\",\"fkow\"]\\nisn\\'t the longest common prefix here \"ow\"\\n\\nit says : Expected\\n\"f\" \\n\\nI\\'m confused? "
                    },
                    {
                        "username": "ARA34",
                        "content": "Not sure I completely understand this question. Using testcase and running code on ide [\"dog\", \"flower\", \"flight\"]:\\nI get - \"dog\"\\nExpected - \"\"\\n\\nBut the code passes through the tests and shows I get \"\" for this testcase on leetcode???"
                    },
                    {
                        "username": "AfatDog",
                        "content": "help  :0\\n im struggling im new\\n"
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'ve passed all the test cases.... JUST THE LAST FIVE OF THEM ARE DRIVING ME INSANE"
                    }
                ]
            },
            {
                "id": 1569195,
                "content": [
                    {
                        "username": "styopa",
                        "content": "I think that [] shouldn\\'t be a test case. Mathematically speaking, there is no defined longest prefix. They suggest that the answer is \"\", but \"randomword\" is also a common prefix because every string that is in the list has it as a prefix. It\\'s kinda like taking the intersection of all sets inside the empty set in set theory."
                    },
                    {
                        "username": "zhangxi1994",
                        "content": "I don't understand the time complexity in editorial solution#3(Divide and conquer). My answer to this approach is somehow O(mn)..."
                    },
                    {
                        "username": "pushen",
                        "content": "It seems that we need to go through every letter in the first string to compare the substring with the rest of string s in the array. So it will take O(n^2).\\nIs there a way of O(nlgn) or O(n)?"
                    },
                    {
                        "username": "john_112",
                        "content": "Good Solution in C++, Java. Python:\\nhttps://www.techiedelight.com/find-longest-common-prefix-lcp-strings/\\nhttps://www.techiedelight.com/longest-common-prefix-given-set-strings-using-trie/"
                    },
                    {
                        "username": "firerex",
                        "content": "Please be more clear when you asking a problem. \\n\\nFor this problem, I was thinking to find out the longest common prefix, NOT FOR ALL string. \\n\\nFor my understanding if the arry like this [\"abc\", \"abcd\", \"aef\"], the result should be \"abc\". But your actually asking to get \"a\". \\n"
                    },
                    {
                        "username": "nilesh_agarwal",
                        "content": "when its written common it indicates you need to compare with all the strings"
                    },
                    {
                        "username": "rajender7",
                        "content": "I know a Trie can be used to solve this problem. But is that an overkill?"
                    },
                    {
                        "username": "raniakhemiri",
                        "content": "test case : strs =\\n[\"flower\",\"fkow\"]\\nisn\\'t the longest common prefix here \"ow\"\\n\\nit says : Expected\\n\"f\" \\n\\nI\\'m confused? "
                    },
                    {
                        "username": "ARA34",
                        "content": "Not sure I completely understand this question. Using testcase and running code on ide [\"dog\", \"flower\", \"flight\"]:\\nI get - \"dog\"\\nExpected - \"\"\\n\\nBut the code passes through the tests and shows I get \"\" for this testcase on leetcode???"
                    },
                    {
                        "username": "AfatDog",
                        "content": "help  :0\\n im struggling im new\\n"
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'ve passed all the test cases.... JUST THE LAST FIVE OF THEM ARE DRIVING ME INSANE"
                    }
                ]
            },
            {
                "id": 2075698,
                "content": [
                    {
                        "username": "styopa",
                        "content": "I think that [] shouldn\\'t be a test case. Mathematically speaking, there is no defined longest prefix. They suggest that the answer is \"\", but \"randomword\" is also a common prefix because every string that is in the list has it as a prefix. It\\'s kinda like taking the intersection of all sets inside the empty set in set theory."
                    },
                    {
                        "username": "zhangxi1994",
                        "content": "I don't understand the time complexity in editorial solution#3(Divide and conquer). My answer to this approach is somehow O(mn)..."
                    },
                    {
                        "username": "pushen",
                        "content": "It seems that we need to go through every letter in the first string to compare the substring with the rest of string s in the array. So it will take O(n^2).\\nIs there a way of O(nlgn) or O(n)?"
                    },
                    {
                        "username": "john_112",
                        "content": "Good Solution in C++, Java. Python:\\nhttps://www.techiedelight.com/find-longest-common-prefix-lcp-strings/\\nhttps://www.techiedelight.com/longest-common-prefix-given-set-strings-using-trie/"
                    },
                    {
                        "username": "firerex",
                        "content": "Please be more clear when you asking a problem. \\n\\nFor this problem, I was thinking to find out the longest common prefix, NOT FOR ALL string. \\n\\nFor my understanding if the arry like this [\"abc\", \"abcd\", \"aef\"], the result should be \"abc\". But your actually asking to get \"a\". \\n"
                    },
                    {
                        "username": "nilesh_agarwal",
                        "content": "when its written common it indicates you need to compare with all the strings"
                    },
                    {
                        "username": "rajender7",
                        "content": "I know a Trie can be used to solve this problem. But is that an overkill?"
                    },
                    {
                        "username": "raniakhemiri",
                        "content": "test case : strs =\\n[\"flower\",\"fkow\"]\\nisn\\'t the longest common prefix here \"ow\"\\n\\nit says : Expected\\n\"f\" \\n\\nI\\'m confused? "
                    },
                    {
                        "username": "ARA34",
                        "content": "Not sure I completely understand this question. Using testcase and running code on ide [\"dog\", \"flower\", \"flight\"]:\\nI get - \"dog\"\\nExpected - \"\"\\n\\nBut the code passes through the tests and shows I get \"\" for this testcase on leetcode???"
                    },
                    {
                        "username": "AfatDog",
                        "content": "help  :0\\n im struggling im new\\n"
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'ve passed all the test cases.... JUST THE LAST FIVE OF THEM ARE DRIVING ME INSANE"
                    }
                ]
            },
            {
                "id": 2074749,
                "content": [
                    {
                        "username": "styopa",
                        "content": "I think that [] shouldn\\'t be a test case. Mathematically speaking, there is no defined longest prefix. They suggest that the answer is \"\", but \"randomword\" is also a common prefix because every string that is in the list has it as a prefix. It\\'s kinda like taking the intersection of all sets inside the empty set in set theory."
                    },
                    {
                        "username": "zhangxi1994",
                        "content": "I don't understand the time complexity in editorial solution#3(Divide and conquer). My answer to this approach is somehow O(mn)..."
                    },
                    {
                        "username": "pushen",
                        "content": "It seems that we need to go through every letter in the first string to compare the substring with the rest of string s in the array. So it will take O(n^2).\\nIs there a way of O(nlgn) or O(n)?"
                    },
                    {
                        "username": "john_112",
                        "content": "Good Solution in C++, Java. Python:\\nhttps://www.techiedelight.com/find-longest-common-prefix-lcp-strings/\\nhttps://www.techiedelight.com/longest-common-prefix-given-set-strings-using-trie/"
                    },
                    {
                        "username": "firerex",
                        "content": "Please be more clear when you asking a problem. \\n\\nFor this problem, I was thinking to find out the longest common prefix, NOT FOR ALL string. \\n\\nFor my understanding if the arry like this [\"abc\", \"abcd\", \"aef\"], the result should be \"abc\". But your actually asking to get \"a\". \\n"
                    },
                    {
                        "username": "nilesh_agarwal",
                        "content": "when its written common it indicates you need to compare with all the strings"
                    },
                    {
                        "username": "rajender7",
                        "content": "I know a Trie can be used to solve this problem. But is that an overkill?"
                    },
                    {
                        "username": "raniakhemiri",
                        "content": "test case : strs =\\n[\"flower\",\"fkow\"]\\nisn\\'t the longest common prefix here \"ow\"\\n\\nit says : Expected\\n\"f\" \\n\\nI\\'m confused? "
                    },
                    {
                        "username": "ARA34",
                        "content": "Not sure I completely understand this question. Using testcase and running code on ide [\"dog\", \"flower\", \"flight\"]:\\nI get - \"dog\"\\nExpected - \"\"\\n\\nBut the code passes through the tests and shows I get \"\" for this testcase on leetcode???"
                    },
                    {
                        "username": "AfatDog",
                        "content": "help  :0\\n im struggling im new\\n"
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'ve passed all the test cases.... JUST THE LAST FIVE OF THEM ARE DRIVING ME INSANE"
                    }
                ]
            },
            {
                "id": 2073826,
                "content": [
                    {
                        "username": "styopa",
                        "content": "I think that [] shouldn\\'t be a test case. Mathematically speaking, there is no defined longest prefix. They suggest that the answer is \"\", but \"randomword\" is also a common prefix because every string that is in the list has it as a prefix. It\\'s kinda like taking the intersection of all sets inside the empty set in set theory."
                    },
                    {
                        "username": "zhangxi1994",
                        "content": "I don't understand the time complexity in editorial solution#3(Divide and conquer). My answer to this approach is somehow O(mn)..."
                    },
                    {
                        "username": "pushen",
                        "content": "It seems that we need to go through every letter in the first string to compare the substring with the rest of string s in the array. So it will take O(n^2).\\nIs there a way of O(nlgn) or O(n)?"
                    },
                    {
                        "username": "john_112",
                        "content": "Good Solution in C++, Java. Python:\\nhttps://www.techiedelight.com/find-longest-common-prefix-lcp-strings/\\nhttps://www.techiedelight.com/longest-common-prefix-given-set-strings-using-trie/"
                    },
                    {
                        "username": "firerex",
                        "content": "Please be more clear when you asking a problem. \\n\\nFor this problem, I was thinking to find out the longest common prefix, NOT FOR ALL string. \\n\\nFor my understanding if the arry like this [\"abc\", \"abcd\", \"aef\"], the result should be \"abc\". But your actually asking to get \"a\". \\n"
                    },
                    {
                        "username": "nilesh_agarwal",
                        "content": "when its written common it indicates you need to compare with all the strings"
                    },
                    {
                        "username": "rajender7",
                        "content": "I know a Trie can be used to solve this problem. But is that an overkill?"
                    },
                    {
                        "username": "raniakhemiri",
                        "content": "test case : strs =\\n[\"flower\",\"fkow\"]\\nisn\\'t the longest common prefix here \"ow\"\\n\\nit says : Expected\\n\"f\" \\n\\nI\\'m confused? "
                    },
                    {
                        "username": "ARA34",
                        "content": "Not sure I completely understand this question. Using testcase and running code on ide [\"dog\", \"flower\", \"flight\"]:\\nI get - \"dog\"\\nExpected - \"\"\\n\\nBut the code passes through the tests and shows I get \"\" for this testcase on leetcode???"
                    },
                    {
                        "username": "AfatDog",
                        "content": "help  :0\\n im struggling im new\\n"
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'ve passed all the test cases.... JUST THE LAST FIVE OF THEM ARE DRIVING ME INSANE"
                    }
                ]
            },
            {
                "id": 2068399,
                "content": [
                    {
                        "username": "styopa",
                        "content": "I think that [] shouldn\\'t be a test case. Mathematically speaking, there is no defined longest prefix. They suggest that the answer is \"\", but \"randomword\" is also a common prefix because every string that is in the list has it as a prefix. It\\'s kinda like taking the intersection of all sets inside the empty set in set theory."
                    },
                    {
                        "username": "zhangxi1994",
                        "content": "I don't understand the time complexity in editorial solution#3(Divide and conquer). My answer to this approach is somehow O(mn)..."
                    },
                    {
                        "username": "pushen",
                        "content": "It seems that we need to go through every letter in the first string to compare the substring with the rest of string s in the array. So it will take O(n^2).\\nIs there a way of O(nlgn) or O(n)?"
                    },
                    {
                        "username": "john_112",
                        "content": "Good Solution in C++, Java. Python:\\nhttps://www.techiedelight.com/find-longest-common-prefix-lcp-strings/\\nhttps://www.techiedelight.com/longest-common-prefix-given-set-strings-using-trie/"
                    },
                    {
                        "username": "firerex",
                        "content": "Please be more clear when you asking a problem. \\n\\nFor this problem, I was thinking to find out the longest common prefix, NOT FOR ALL string. \\n\\nFor my understanding if the arry like this [\"abc\", \"abcd\", \"aef\"], the result should be \"abc\". But your actually asking to get \"a\". \\n"
                    },
                    {
                        "username": "nilesh_agarwal",
                        "content": "when its written common it indicates you need to compare with all the strings"
                    },
                    {
                        "username": "rajender7",
                        "content": "I know a Trie can be used to solve this problem. But is that an overkill?"
                    },
                    {
                        "username": "raniakhemiri",
                        "content": "test case : strs =\\n[\"flower\",\"fkow\"]\\nisn\\'t the longest common prefix here \"ow\"\\n\\nit says : Expected\\n\"f\" \\n\\nI\\'m confused? "
                    },
                    {
                        "username": "ARA34",
                        "content": "Not sure I completely understand this question. Using testcase and running code on ide [\"dog\", \"flower\", \"flight\"]:\\nI get - \"dog\"\\nExpected - \"\"\\n\\nBut the code passes through the tests and shows I get \"\" for this testcase on leetcode???"
                    },
                    {
                        "username": "AfatDog",
                        "content": "help  :0\\n im struggling im new\\n"
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'ve passed all the test cases.... JUST THE LAST FIVE OF THEM ARE DRIVING ME INSANE"
                    }
                ]
            },
            {
                "id": 2064571,
                "content": [
                    {
                        "username": "styopa",
                        "content": "I think that [] shouldn\\'t be a test case. Mathematically speaking, there is no defined longest prefix. They suggest that the answer is \"\", but \"randomword\" is also a common prefix because every string that is in the list has it as a prefix. It\\'s kinda like taking the intersection of all sets inside the empty set in set theory."
                    },
                    {
                        "username": "zhangxi1994",
                        "content": "I don't understand the time complexity in editorial solution#3(Divide and conquer). My answer to this approach is somehow O(mn)..."
                    },
                    {
                        "username": "pushen",
                        "content": "It seems that we need to go through every letter in the first string to compare the substring with the rest of string s in the array. So it will take O(n^2).\\nIs there a way of O(nlgn) or O(n)?"
                    },
                    {
                        "username": "john_112",
                        "content": "Good Solution in C++, Java. Python:\\nhttps://www.techiedelight.com/find-longest-common-prefix-lcp-strings/\\nhttps://www.techiedelight.com/longest-common-prefix-given-set-strings-using-trie/"
                    },
                    {
                        "username": "firerex",
                        "content": "Please be more clear when you asking a problem. \\n\\nFor this problem, I was thinking to find out the longest common prefix, NOT FOR ALL string. \\n\\nFor my understanding if the arry like this [\"abc\", \"abcd\", \"aef\"], the result should be \"abc\". But your actually asking to get \"a\". \\n"
                    },
                    {
                        "username": "nilesh_agarwal",
                        "content": "when its written common it indicates you need to compare with all the strings"
                    },
                    {
                        "username": "rajender7",
                        "content": "I know a Trie can be used to solve this problem. But is that an overkill?"
                    },
                    {
                        "username": "raniakhemiri",
                        "content": "test case : strs =\\n[\"flower\",\"fkow\"]\\nisn\\'t the longest common prefix here \"ow\"\\n\\nit says : Expected\\n\"f\" \\n\\nI\\'m confused? "
                    },
                    {
                        "username": "ARA34",
                        "content": "Not sure I completely understand this question. Using testcase and running code on ide [\"dog\", \"flower\", \"flight\"]:\\nI get - \"dog\"\\nExpected - \"\"\\n\\nBut the code passes through the tests and shows I get \"\" for this testcase on leetcode???"
                    },
                    {
                        "username": "AfatDog",
                        "content": "help  :0\\n im struggling im new\\n"
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'ve passed all the test cases.... JUST THE LAST FIVE OF THEM ARE DRIVING ME INSANE"
                    }
                ]
            },
            {
                "id": 2063625,
                "content": [
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty()) {\\n            return \"\";\\n        }\\n        \\n        string s3;\\n        \\n        for (int j = 0; j < strs[0].size(); j++) {\\n            char current_char = strs[0][j];\\n            \\n            for (int i = 1; i < strs.size(); i++) {\\n                if (j >= strs[i].size() || strs[i][j] != current_char) {\\n                    return s3;\\n                }\\n            }\\n            \\n            s3.push_back(current_char);\\n        }\\n        \\n        return s3;\\n    }\\n};\\n"
                    },
                    {
                        "username": "grisoliaemilio0",
                        "content": "The problem is not correctly worded. The prefix should exists in ALL the strings in the array, which can be empty (in this case, \"\" should be returned)"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This was easy but really annoying....\\ni solved it under 10 min though.. ;D"
                    },
                    {
                        "username": "rammuthukumar18",
                        "content": "for this solution it won\\'t give the correct output for the testcase [\"flower\",\"flower\",\"flower\",\"flower\"] it prints \"\" but the correct output is \"flower\" why is that?\\n\\nPassed : 95/124\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String ans=\"\";\\n        int cnt=0;\\n        if(strs.length==1) {\\n            ans=ans+strs[0];\\n            return ans;\\n        }\\n        for(int i=0;i<strs[0].length();i++){\\n            if(checker((strs[0].charAt(i)),strs,i))\\n                cnt++;\\n            else {\\n                ans=ans+strs[0].substring(0,cnt);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n    public boolean checker(char ch,String[] strs,int j){\\n        for(int i=1;i<strs.length;i++){\\n            if(strs[i].length()>j) {\\n                if(ch!=strs[i].charAt(j)) \\n                    return false;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "seventy_two",
                        "content": "The code below is showing the exact output in my IDE but it\\'s not getting done in here Why? \\n\\n\\nchar *longestCommonPrefix(char **strs, int strsSize)\\n{\\n    char *return_string;\\n    int length = 0;\\n    int flag = 0;\\n    for (int i = 0; i < strlen(strs[0]); i++)\\n    {\\n        for (int j = 1; j < strsSize; j++)\\n        {\\n            if (strs[0][i] != strs[j][i])\\n            {\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if (flag)\\n            break;\\n        else\\n        {\\n            length++;\\n        }\\n    }\\n    return_string = (char *)malloc(sizeof(char) * length);\\n    strncpy(return_string, strs[0], length);\\n    return_string[length] = \\'\\\\0\\';\\n    return return_string;\\n}\\n//"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Has anyone tried using a Trie? Is that overcomplicating this problem?"
                    },
                    {
                        "username": "anmol1301",
                        "content": "strs[i].size() returns size_t not int\\nyou can\\'t compare int with size_t unless you typecase it to int"
                    },
                    {
                        "username": "Razin87",
                        "content": "For testcase 16, my output was \\'flo\\' and the expected output was \\'flower\\'. The sample for the testcase was strs = [\"flower\",\"flower\",\"flower\",\"flower\"]. Am I not supposed to find the prefix but the whole word in case they\\'re the same word?"
                    },
                    {
                        "username": "HariharPal",
                        "content": "my solution is working on vscode where string [\"flower\",\"flower\",\"flower\",\"flower\"] is passed but when i put this code in leetcode it give output \"\"\\nhere is my crap code\\nclass Program14Try {\\n    public static String longestCommonPrefix(String[] strs) {\\n        String last = strs[strs.length - 1];\\n        String sample = \"\";\\n        String Initial = strs[0];\\n        for (int i = 0; i < strs.length; i++) {\\n            String ithStr = strs[i];\\n            for (int j = 0; j < ithStr.length(); j++) {\\n\\n                if (Initial.length() > 0 && strs[0] != strs[strs.length - 1]) {\\n                    if (Initial.charAt(j) != ithStr.charAt(j)) {\\n                        String Prefix = Initial.substring(0, j);\\n                        return Prefix;\\n                    } else if (strs.length == 1) {\\n                        return Initial;\\n                    } else if (Initial.charAt(j) == ithStr.charAt(j) && strs.length == 2) {\\n                        sample = sample + ithStr.charAt(j);\\n                        return sample;\\n                    }\\n                } else {\\n                    return strs[0];\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    public static void main(String[] args) {\\n        String[] strs = { \"ab\", \"a\" };\\n        System.out.println(longestCommonPrefix(strs));\\n    }\\n}"
                    },
                    {
                        "username": "tribit",
                        "content": "Definition of \"common\" should be stated here. I worked with assumption that \"common\" is prefix found in 2 or more items, when it clearly should be, `prefix found in all items`."
                    }
                ]
            },
            {
                "id": 2063560,
                "content": [
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty()) {\\n            return \"\";\\n        }\\n        \\n        string s3;\\n        \\n        for (int j = 0; j < strs[0].size(); j++) {\\n            char current_char = strs[0][j];\\n            \\n            for (int i = 1; i < strs.size(); i++) {\\n                if (j >= strs[i].size() || strs[i][j] != current_char) {\\n                    return s3;\\n                }\\n            }\\n            \\n            s3.push_back(current_char);\\n        }\\n        \\n        return s3;\\n    }\\n};\\n"
                    },
                    {
                        "username": "grisoliaemilio0",
                        "content": "The problem is not correctly worded. The prefix should exists in ALL the strings in the array, which can be empty (in this case, \"\" should be returned)"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This was easy but really annoying....\\ni solved it under 10 min though.. ;D"
                    },
                    {
                        "username": "rammuthukumar18",
                        "content": "for this solution it won\\'t give the correct output for the testcase [\"flower\",\"flower\",\"flower\",\"flower\"] it prints \"\" but the correct output is \"flower\" why is that?\\n\\nPassed : 95/124\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String ans=\"\";\\n        int cnt=0;\\n        if(strs.length==1) {\\n            ans=ans+strs[0];\\n            return ans;\\n        }\\n        for(int i=0;i<strs[0].length();i++){\\n            if(checker((strs[0].charAt(i)),strs,i))\\n                cnt++;\\n            else {\\n                ans=ans+strs[0].substring(0,cnt);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n    public boolean checker(char ch,String[] strs,int j){\\n        for(int i=1;i<strs.length;i++){\\n            if(strs[i].length()>j) {\\n                if(ch!=strs[i].charAt(j)) \\n                    return false;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "seventy_two",
                        "content": "The code below is showing the exact output in my IDE but it\\'s not getting done in here Why? \\n\\n\\nchar *longestCommonPrefix(char **strs, int strsSize)\\n{\\n    char *return_string;\\n    int length = 0;\\n    int flag = 0;\\n    for (int i = 0; i < strlen(strs[0]); i++)\\n    {\\n        for (int j = 1; j < strsSize; j++)\\n        {\\n            if (strs[0][i] != strs[j][i])\\n            {\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if (flag)\\n            break;\\n        else\\n        {\\n            length++;\\n        }\\n    }\\n    return_string = (char *)malloc(sizeof(char) * length);\\n    strncpy(return_string, strs[0], length);\\n    return_string[length] = \\'\\\\0\\';\\n    return return_string;\\n}\\n//"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Has anyone tried using a Trie? Is that overcomplicating this problem?"
                    },
                    {
                        "username": "anmol1301",
                        "content": "strs[i].size() returns size_t not int\\nyou can\\'t compare int with size_t unless you typecase it to int"
                    },
                    {
                        "username": "Razin87",
                        "content": "For testcase 16, my output was \\'flo\\' and the expected output was \\'flower\\'. The sample for the testcase was strs = [\"flower\",\"flower\",\"flower\",\"flower\"]. Am I not supposed to find the prefix but the whole word in case they\\'re the same word?"
                    },
                    {
                        "username": "HariharPal",
                        "content": "my solution is working on vscode where string [\"flower\",\"flower\",\"flower\",\"flower\"] is passed but when i put this code in leetcode it give output \"\"\\nhere is my crap code\\nclass Program14Try {\\n    public static String longestCommonPrefix(String[] strs) {\\n        String last = strs[strs.length - 1];\\n        String sample = \"\";\\n        String Initial = strs[0];\\n        for (int i = 0; i < strs.length; i++) {\\n            String ithStr = strs[i];\\n            for (int j = 0; j < ithStr.length(); j++) {\\n\\n                if (Initial.length() > 0 && strs[0] != strs[strs.length - 1]) {\\n                    if (Initial.charAt(j) != ithStr.charAt(j)) {\\n                        String Prefix = Initial.substring(0, j);\\n                        return Prefix;\\n                    } else if (strs.length == 1) {\\n                        return Initial;\\n                    } else if (Initial.charAt(j) == ithStr.charAt(j) && strs.length == 2) {\\n                        sample = sample + ithStr.charAt(j);\\n                        return sample;\\n                    }\\n                } else {\\n                    return strs[0];\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    public static void main(String[] args) {\\n        String[] strs = { \"ab\", \"a\" };\\n        System.out.println(longestCommonPrefix(strs));\\n    }\\n}"
                    },
                    {
                        "username": "tribit",
                        "content": "Definition of \"common\" should be stated here. I worked with assumption that \"common\" is prefix found in 2 or more items, when it clearly should be, `prefix found in all items`."
                    }
                ]
            },
            {
                "id": 2060562,
                "content": [
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty()) {\\n            return \"\";\\n        }\\n        \\n        string s3;\\n        \\n        for (int j = 0; j < strs[0].size(); j++) {\\n            char current_char = strs[0][j];\\n            \\n            for (int i = 1; i < strs.size(); i++) {\\n                if (j >= strs[i].size() || strs[i][j] != current_char) {\\n                    return s3;\\n                }\\n            }\\n            \\n            s3.push_back(current_char);\\n        }\\n        \\n        return s3;\\n    }\\n};\\n"
                    },
                    {
                        "username": "grisoliaemilio0",
                        "content": "The problem is not correctly worded. The prefix should exists in ALL the strings in the array, which can be empty (in this case, \"\" should be returned)"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This was easy but really annoying....\\ni solved it under 10 min though.. ;D"
                    },
                    {
                        "username": "rammuthukumar18",
                        "content": "for this solution it won\\'t give the correct output for the testcase [\"flower\",\"flower\",\"flower\",\"flower\"] it prints \"\" but the correct output is \"flower\" why is that?\\n\\nPassed : 95/124\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String ans=\"\";\\n        int cnt=0;\\n        if(strs.length==1) {\\n            ans=ans+strs[0];\\n            return ans;\\n        }\\n        for(int i=0;i<strs[0].length();i++){\\n            if(checker((strs[0].charAt(i)),strs,i))\\n                cnt++;\\n            else {\\n                ans=ans+strs[0].substring(0,cnt);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n    public boolean checker(char ch,String[] strs,int j){\\n        for(int i=1;i<strs.length;i++){\\n            if(strs[i].length()>j) {\\n                if(ch!=strs[i].charAt(j)) \\n                    return false;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "seventy_two",
                        "content": "The code below is showing the exact output in my IDE but it\\'s not getting done in here Why? \\n\\n\\nchar *longestCommonPrefix(char **strs, int strsSize)\\n{\\n    char *return_string;\\n    int length = 0;\\n    int flag = 0;\\n    for (int i = 0; i < strlen(strs[0]); i++)\\n    {\\n        for (int j = 1; j < strsSize; j++)\\n        {\\n            if (strs[0][i] != strs[j][i])\\n            {\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if (flag)\\n            break;\\n        else\\n        {\\n            length++;\\n        }\\n    }\\n    return_string = (char *)malloc(sizeof(char) * length);\\n    strncpy(return_string, strs[0], length);\\n    return_string[length] = \\'\\\\0\\';\\n    return return_string;\\n}\\n//"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Has anyone tried using a Trie? Is that overcomplicating this problem?"
                    },
                    {
                        "username": "anmol1301",
                        "content": "strs[i].size() returns size_t not int\\nyou can\\'t compare int with size_t unless you typecase it to int"
                    },
                    {
                        "username": "Razin87",
                        "content": "For testcase 16, my output was \\'flo\\' and the expected output was \\'flower\\'. The sample for the testcase was strs = [\"flower\",\"flower\",\"flower\",\"flower\"]. Am I not supposed to find the prefix but the whole word in case they\\'re the same word?"
                    },
                    {
                        "username": "HariharPal",
                        "content": "my solution is working on vscode where string [\"flower\",\"flower\",\"flower\",\"flower\"] is passed but when i put this code in leetcode it give output \"\"\\nhere is my crap code\\nclass Program14Try {\\n    public static String longestCommonPrefix(String[] strs) {\\n        String last = strs[strs.length - 1];\\n        String sample = \"\";\\n        String Initial = strs[0];\\n        for (int i = 0; i < strs.length; i++) {\\n            String ithStr = strs[i];\\n            for (int j = 0; j < ithStr.length(); j++) {\\n\\n                if (Initial.length() > 0 && strs[0] != strs[strs.length - 1]) {\\n                    if (Initial.charAt(j) != ithStr.charAt(j)) {\\n                        String Prefix = Initial.substring(0, j);\\n                        return Prefix;\\n                    } else if (strs.length == 1) {\\n                        return Initial;\\n                    } else if (Initial.charAt(j) == ithStr.charAt(j) && strs.length == 2) {\\n                        sample = sample + ithStr.charAt(j);\\n                        return sample;\\n                    }\\n                } else {\\n                    return strs[0];\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    public static void main(String[] args) {\\n        String[] strs = { \"ab\", \"a\" };\\n        System.out.println(longestCommonPrefix(strs));\\n    }\\n}"
                    },
                    {
                        "username": "tribit",
                        "content": "Definition of \"common\" should be stated here. I worked with assumption that \"common\" is prefix found in 2 or more items, when it clearly should be, `prefix found in all items`."
                    }
                ]
            },
            {
                "id": 2050193,
                "content": [
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty()) {\\n            return \"\";\\n        }\\n        \\n        string s3;\\n        \\n        for (int j = 0; j < strs[0].size(); j++) {\\n            char current_char = strs[0][j];\\n            \\n            for (int i = 1; i < strs.size(); i++) {\\n                if (j >= strs[i].size() || strs[i][j] != current_char) {\\n                    return s3;\\n                }\\n            }\\n            \\n            s3.push_back(current_char);\\n        }\\n        \\n        return s3;\\n    }\\n};\\n"
                    },
                    {
                        "username": "grisoliaemilio0",
                        "content": "The problem is not correctly worded. The prefix should exists in ALL the strings in the array, which can be empty (in this case, \"\" should be returned)"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This was easy but really annoying....\\ni solved it under 10 min though.. ;D"
                    },
                    {
                        "username": "rammuthukumar18",
                        "content": "for this solution it won\\'t give the correct output for the testcase [\"flower\",\"flower\",\"flower\",\"flower\"] it prints \"\" but the correct output is \"flower\" why is that?\\n\\nPassed : 95/124\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String ans=\"\";\\n        int cnt=0;\\n        if(strs.length==1) {\\n            ans=ans+strs[0];\\n            return ans;\\n        }\\n        for(int i=0;i<strs[0].length();i++){\\n            if(checker((strs[0].charAt(i)),strs,i))\\n                cnt++;\\n            else {\\n                ans=ans+strs[0].substring(0,cnt);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n    public boolean checker(char ch,String[] strs,int j){\\n        for(int i=1;i<strs.length;i++){\\n            if(strs[i].length()>j) {\\n                if(ch!=strs[i].charAt(j)) \\n                    return false;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "seventy_two",
                        "content": "The code below is showing the exact output in my IDE but it\\'s not getting done in here Why? \\n\\n\\nchar *longestCommonPrefix(char **strs, int strsSize)\\n{\\n    char *return_string;\\n    int length = 0;\\n    int flag = 0;\\n    for (int i = 0; i < strlen(strs[0]); i++)\\n    {\\n        for (int j = 1; j < strsSize; j++)\\n        {\\n            if (strs[0][i] != strs[j][i])\\n            {\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if (flag)\\n            break;\\n        else\\n        {\\n            length++;\\n        }\\n    }\\n    return_string = (char *)malloc(sizeof(char) * length);\\n    strncpy(return_string, strs[0], length);\\n    return_string[length] = \\'\\\\0\\';\\n    return return_string;\\n}\\n//"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Has anyone tried using a Trie? Is that overcomplicating this problem?"
                    },
                    {
                        "username": "anmol1301",
                        "content": "strs[i].size() returns size_t not int\\nyou can\\'t compare int with size_t unless you typecase it to int"
                    },
                    {
                        "username": "Razin87",
                        "content": "For testcase 16, my output was \\'flo\\' and the expected output was \\'flower\\'. The sample for the testcase was strs = [\"flower\",\"flower\",\"flower\",\"flower\"]. Am I not supposed to find the prefix but the whole word in case they\\'re the same word?"
                    },
                    {
                        "username": "HariharPal",
                        "content": "my solution is working on vscode where string [\"flower\",\"flower\",\"flower\",\"flower\"] is passed but when i put this code in leetcode it give output \"\"\\nhere is my crap code\\nclass Program14Try {\\n    public static String longestCommonPrefix(String[] strs) {\\n        String last = strs[strs.length - 1];\\n        String sample = \"\";\\n        String Initial = strs[0];\\n        for (int i = 0; i < strs.length; i++) {\\n            String ithStr = strs[i];\\n            for (int j = 0; j < ithStr.length(); j++) {\\n\\n                if (Initial.length() > 0 && strs[0] != strs[strs.length - 1]) {\\n                    if (Initial.charAt(j) != ithStr.charAt(j)) {\\n                        String Prefix = Initial.substring(0, j);\\n                        return Prefix;\\n                    } else if (strs.length == 1) {\\n                        return Initial;\\n                    } else if (Initial.charAt(j) == ithStr.charAt(j) && strs.length == 2) {\\n                        sample = sample + ithStr.charAt(j);\\n                        return sample;\\n                    }\\n                } else {\\n                    return strs[0];\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    public static void main(String[] args) {\\n        String[] strs = { \"ab\", \"a\" };\\n        System.out.println(longestCommonPrefix(strs));\\n    }\\n}"
                    },
                    {
                        "username": "tribit",
                        "content": "Definition of \"common\" should be stated here. I worked with assumption that \"common\" is prefix found in 2 or more items, when it clearly should be, `prefix found in all items`."
                    }
                ]
            },
            {
                "id": 2049154,
                "content": [
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty()) {\\n            return \"\";\\n        }\\n        \\n        string s3;\\n        \\n        for (int j = 0; j < strs[0].size(); j++) {\\n            char current_char = strs[0][j];\\n            \\n            for (int i = 1; i < strs.size(); i++) {\\n                if (j >= strs[i].size() || strs[i][j] != current_char) {\\n                    return s3;\\n                }\\n            }\\n            \\n            s3.push_back(current_char);\\n        }\\n        \\n        return s3;\\n    }\\n};\\n"
                    },
                    {
                        "username": "grisoliaemilio0",
                        "content": "The problem is not correctly worded. The prefix should exists in ALL the strings in the array, which can be empty (in this case, \"\" should be returned)"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This was easy but really annoying....\\ni solved it under 10 min though.. ;D"
                    },
                    {
                        "username": "rammuthukumar18",
                        "content": "for this solution it won\\'t give the correct output for the testcase [\"flower\",\"flower\",\"flower\",\"flower\"] it prints \"\" but the correct output is \"flower\" why is that?\\n\\nPassed : 95/124\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String ans=\"\";\\n        int cnt=0;\\n        if(strs.length==1) {\\n            ans=ans+strs[0];\\n            return ans;\\n        }\\n        for(int i=0;i<strs[0].length();i++){\\n            if(checker((strs[0].charAt(i)),strs,i))\\n                cnt++;\\n            else {\\n                ans=ans+strs[0].substring(0,cnt);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n    public boolean checker(char ch,String[] strs,int j){\\n        for(int i=1;i<strs.length;i++){\\n            if(strs[i].length()>j) {\\n                if(ch!=strs[i].charAt(j)) \\n                    return false;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "seventy_two",
                        "content": "The code below is showing the exact output in my IDE but it\\'s not getting done in here Why? \\n\\n\\nchar *longestCommonPrefix(char **strs, int strsSize)\\n{\\n    char *return_string;\\n    int length = 0;\\n    int flag = 0;\\n    for (int i = 0; i < strlen(strs[0]); i++)\\n    {\\n        for (int j = 1; j < strsSize; j++)\\n        {\\n            if (strs[0][i] != strs[j][i])\\n            {\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if (flag)\\n            break;\\n        else\\n        {\\n            length++;\\n        }\\n    }\\n    return_string = (char *)malloc(sizeof(char) * length);\\n    strncpy(return_string, strs[0], length);\\n    return_string[length] = \\'\\\\0\\';\\n    return return_string;\\n}\\n//"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Has anyone tried using a Trie? Is that overcomplicating this problem?"
                    },
                    {
                        "username": "anmol1301",
                        "content": "strs[i].size() returns size_t not int\\nyou can\\'t compare int with size_t unless you typecase it to int"
                    },
                    {
                        "username": "Razin87",
                        "content": "For testcase 16, my output was \\'flo\\' and the expected output was \\'flower\\'. The sample for the testcase was strs = [\"flower\",\"flower\",\"flower\",\"flower\"]. Am I not supposed to find the prefix but the whole word in case they\\'re the same word?"
                    },
                    {
                        "username": "HariharPal",
                        "content": "my solution is working on vscode where string [\"flower\",\"flower\",\"flower\",\"flower\"] is passed but when i put this code in leetcode it give output \"\"\\nhere is my crap code\\nclass Program14Try {\\n    public static String longestCommonPrefix(String[] strs) {\\n        String last = strs[strs.length - 1];\\n        String sample = \"\";\\n        String Initial = strs[0];\\n        for (int i = 0; i < strs.length; i++) {\\n            String ithStr = strs[i];\\n            for (int j = 0; j < ithStr.length(); j++) {\\n\\n                if (Initial.length() > 0 && strs[0] != strs[strs.length - 1]) {\\n                    if (Initial.charAt(j) != ithStr.charAt(j)) {\\n                        String Prefix = Initial.substring(0, j);\\n                        return Prefix;\\n                    } else if (strs.length == 1) {\\n                        return Initial;\\n                    } else if (Initial.charAt(j) == ithStr.charAt(j) && strs.length == 2) {\\n                        sample = sample + ithStr.charAt(j);\\n                        return sample;\\n                    }\\n                } else {\\n                    return strs[0];\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    public static void main(String[] args) {\\n        String[] strs = { \"ab\", \"a\" };\\n        System.out.println(longestCommonPrefix(strs));\\n    }\\n}"
                    },
                    {
                        "username": "tribit",
                        "content": "Definition of \"common\" should be stated here. I worked with assumption that \"common\" is prefix found in 2 or more items, when it clearly should be, `prefix found in all items`."
                    }
                ]
            },
            {
                "id": 2048123,
                "content": [
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty()) {\\n            return \"\";\\n        }\\n        \\n        string s3;\\n        \\n        for (int j = 0; j < strs[0].size(); j++) {\\n            char current_char = strs[0][j];\\n            \\n            for (int i = 1; i < strs.size(); i++) {\\n                if (j >= strs[i].size() || strs[i][j] != current_char) {\\n                    return s3;\\n                }\\n            }\\n            \\n            s3.push_back(current_char);\\n        }\\n        \\n        return s3;\\n    }\\n};\\n"
                    },
                    {
                        "username": "grisoliaemilio0",
                        "content": "The problem is not correctly worded. The prefix should exists in ALL the strings in the array, which can be empty (in this case, \"\" should be returned)"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This was easy but really annoying....\\ni solved it under 10 min though.. ;D"
                    },
                    {
                        "username": "rammuthukumar18",
                        "content": "for this solution it won\\'t give the correct output for the testcase [\"flower\",\"flower\",\"flower\",\"flower\"] it prints \"\" but the correct output is \"flower\" why is that?\\n\\nPassed : 95/124\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String ans=\"\";\\n        int cnt=0;\\n        if(strs.length==1) {\\n            ans=ans+strs[0];\\n            return ans;\\n        }\\n        for(int i=0;i<strs[0].length();i++){\\n            if(checker((strs[0].charAt(i)),strs,i))\\n                cnt++;\\n            else {\\n                ans=ans+strs[0].substring(0,cnt);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n    public boolean checker(char ch,String[] strs,int j){\\n        for(int i=1;i<strs.length;i++){\\n            if(strs[i].length()>j) {\\n                if(ch!=strs[i].charAt(j)) \\n                    return false;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "seventy_two",
                        "content": "The code below is showing the exact output in my IDE but it\\'s not getting done in here Why? \\n\\n\\nchar *longestCommonPrefix(char **strs, int strsSize)\\n{\\n    char *return_string;\\n    int length = 0;\\n    int flag = 0;\\n    for (int i = 0; i < strlen(strs[0]); i++)\\n    {\\n        for (int j = 1; j < strsSize; j++)\\n        {\\n            if (strs[0][i] != strs[j][i])\\n            {\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if (flag)\\n            break;\\n        else\\n        {\\n            length++;\\n        }\\n    }\\n    return_string = (char *)malloc(sizeof(char) * length);\\n    strncpy(return_string, strs[0], length);\\n    return_string[length] = \\'\\\\0\\';\\n    return return_string;\\n}\\n//"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Has anyone tried using a Trie? Is that overcomplicating this problem?"
                    },
                    {
                        "username": "anmol1301",
                        "content": "strs[i].size() returns size_t not int\\nyou can\\'t compare int with size_t unless you typecase it to int"
                    },
                    {
                        "username": "Razin87",
                        "content": "For testcase 16, my output was \\'flo\\' and the expected output was \\'flower\\'. The sample for the testcase was strs = [\"flower\",\"flower\",\"flower\",\"flower\"]. Am I not supposed to find the prefix but the whole word in case they\\'re the same word?"
                    },
                    {
                        "username": "HariharPal",
                        "content": "my solution is working on vscode where string [\"flower\",\"flower\",\"flower\",\"flower\"] is passed but when i put this code in leetcode it give output \"\"\\nhere is my crap code\\nclass Program14Try {\\n    public static String longestCommonPrefix(String[] strs) {\\n        String last = strs[strs.length - 1];\\n        String sample = \"\";\\n        String Initial = strs[0];\\n        for (int i = 0; i < strs.length; i++) {\\n            String ithStr = strs[i];\\n            for (int j = 0; j < ithStr.length(); j++) {\\n\\n                if (Initial.length() > 0 && strs[0] != strs[strs.length - 1]) {\\n                    if (Initial.charAt(j) != ithStr.charAt(j)) {\\n                        String Prefix = Initial.substring(0, j);\\n                        return Prefix;\\n                    } else if (strs.length == 1) {\\n                        return Initial;\\n                    } else if (Initial.charAt(j) == ithStr.charAt(j) && strs.length == 2) {\\n                        sample = sample + ithStr.charAt(j);\\n                        return sample;\\n                    }\\n                } else {\\n                    return strs[0];\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    public static void main(String[] args) {\\n        String[] strs = { \"ab\", \"a\" };\\n        System.out.println(longestCommonPrefix(strs));\\n    }\\n}"
                    },
                    {
                        "username": "tribit",
                        "content": "Definition of \"common\" should be stated here. I worked with assumption that \"common\" is prefix found in 2 or more items, when it clearly should be, `prefix found in all items`."
                    }
                ]
            },
            {
                "id": 2035198,
                "content": [
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty()) {\\n            return \"\";\\n        }\\n        \\n        string s3;\\n        \\n        for (int j = 0; j < strs[0].size(); j++) {\\n            char current_char = strs[0][j];\\n            \\n            for (int i = 1; i < strs.size(); i++) {\\n                if (j >= strs[i].size() || strs[i][j] != current_char) {\\n                    return s3;\\n                }\\n            }\\n            \\n            s3.push_back(current_char);\\n        }\\n        \\n        return s3;\\n    }\\n};\\n"
                    },
                    {
                        "username": "grisoliaemilio0",
                        "content": "The problem is not correctly worded. The prefix should exists in ALL the strings in the array, which can be empty (in this case, \"\" should be returned)"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This was easy but really annoying....\\ni solved it under 10 min though.. ;D"
                    },
                    {
                        "username": "rammuthukumar18",
                        "content": "for this solution it won\\'t give the correct output for the testcase [\"flower\",\"flower\",\"flower\",\"flower\"] it prints \"\" but the correct output is \"flower\" why is that?\\n\\nPassed : 95/124\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String ans=\"\";\\n        int cnt=0;\\n        if(strs.length==1) {\\n            ans=ans+strs[0];\\n            return ans;\\n        }\\n        for(int i=0;i<strs[0].length();i++){\\n            if(checker((strs[0].charAt(i)),strs,i))\\n                cnt++;\\n            else {\\n                ans=ans+strs[0].substring(0,cnt);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n    public boolean checker(char ch,String[] strs,int j){\\n        for(int i=1;i<strs.length;i++){\\n            if(strs[i].length()>j) {\\n                if(ch!=strs[i].charAt(j)) \\n                    return false;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "seventy_two",
                        "content": "The code below is showing the exact output in my IDE but it\\'s not getting done in here Why? \\n\\n\\nchar *longestCommonPrefix(char **strs, int strsSize)\\n{\\n    char *return_string;\\n    int length = 0;\\n    int flag = 0;\\n    for (int i = 0; i < strlen(strs[0]); i++)\\n    {\\n        for (int j = 1; j < strsSize; j++)\\n        {\\n            if (strs[0][i] != strs[j][i])\\n            {\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if (flag)\\n            break;\\n        else\\n        {\\n            length++;\\n        }\\n    }\\n    return_string = (char *)malloc(sizeof(char) * length);\\n    strncpy(return_string, strs[0], length);\\n    return_string[length] = \\'\\\\0\\';\\n    return return_string;\\n}\\n//"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Has anyone tried using a Trie? Is that overcomplicating this problem?"
                    },
                    {
                        "username": "anmol1301",
                        "content": "strs[i].size() returns size_t not int\\nyou can\\'t compare int with size_t unless you typecase it to int"
                    },
                    {
                        "username": "Razin87",
                        "content": "For testcase 16, my output was \\'flo\\' and the expected output was \\'flower\\'. The sample for the testcase was strs = [\"flower\",\"flower\",\"flower\",\"flower\"]. Am I not supposed to find the prefix but the whole word in case they\\'re the same word?"
                    },
                    {
                        "username": "HariharPal",
                        "content": "my solution is working on vscode where string [\"flower\",\"flower\",\"flower\",\"flower\"] is passed but when i put this code in leetcode it give output \"\"\\nhere is my crap code\\nclass Program14Try {\\n    public static String longestCommonPrefix(String[] strs) {\\n        String last = strs[strs.length - 1];\\n        String sample = \"\";\\n        String Initial = strs[0];\\n        for (int i = 0; i < strs.length; i++) {\\n            String ithStr = strs[i];\\n            for (int j = 0; j < ithStr.length(); j++) {\\n\\n                if (Initial.length() > 0 && strs[0] != strs[strs.length - 1]) {\\n                    if (Initial.charAt(j) != ithStr.charAt(j)) {\\n                        String Prefix = Initial.substring(0, j);\\n                        return Prefix;\\n                    } else if (strs.length == 1) {\\n                        return Initial;\\n                    } else if (Initial.charAt(j) == ithStr.charAt(j) && strs.length == 2) {\\n                        sample = sample + ithStr.charAt(j);\\n                        return sample;\\n                    }\\n                } else {\\n                    return strs[0];\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    public static void main(String[] args) {\\n        String[] strs = { \"ab\", \"a\" };\\n        System.out.println(longestCommonPrefix(strs));\\n    }\\n}"
                    },
                    {
                        "username": "tribit",
                        "content": "Definition of \"common\" should be stated here. I worked with assumption that \"common\" is prefix found in 2 or more items, when it clearly should be, `prefix found in all items`."
                    }
                ]
            },
            {
                "id": 2034579,
                "content": [
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty()) {\\n            return \"\";\\n        }\\n        \\n        string s3;\\n        \\n        for (int j = 0; j < strs[0].size(); j++) {\\n            char current_char = strs[0][j];\\n            \\n            for (int i = 1; i < strs.size(); i++) {\\n                if (j >= strs[i].size() || strs[i][j] != current_char) {\\n                    return s3;\\n                }\\n            }\\n            \\n            s3.push_back(current_char);\\n        }\\n        \\n        return s3;\\n    }\\n};\\n"
                    },
                    {
                        "username": "grisoliaemilio0",
                        "content": "The problem is not correctly worded. The prefix should exists in ALL the strings in the array, which can be empty (in this case, \"\" should be returned)"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This was easy but really annoying....\\ni solved it under 10 min though.. ;D"
                    },
                    {
                        "username": "rammuthukumar18",
                        "content": "for this solution it won\\'t give the correct output for the testcase [\"flower\",\"flower\",\"flower\",\"flower\"] it prints \"\" but the correct output is \"flower\" why is that?\\n\\nPassed : 95/124\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String ans=\"\";\\n        int cnt=0;\\n        if(strs.length==1) {\\n            ans=ans+strs[0];\\n            return ans;\\n        }\\n        for(int i=0;i<strs[0].length();i++){\\n            if(checker((strs[0].charAt(i)),strs,i))\\n                cnt++;\\n            else {\\n                ans=ans+strs[0].substring(0,cnt);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n    public boolean checker(char ch,String[] strs,int j){\\n        for(int i=1;i<strs.length;i++){\\n            if(strs[i].length()>j) {\\n                if(ch!=strs[i].charAt(j)) \\n                    return false;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "seventy_two",
                        "content": "The code below is showing the exact output in my IDE but it\\'s not getting done in here Why? \\n\\n\\nchar *longestCommonPrefix(char **strs, int strsSize)\\n{\\n    char *return_string;\\n    int length = 0;\\n    int flag = 0;\\n    for (int i = 0; i < strlen(strs[0]); i++)\\n    {\\n        for (int j = 1; j < strsSize; j++)\\n        {\\n            if (strs[0][i] != strs[j][i])\\n            {\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if (flag)\\n            break;\\n        else\\n        {\\n            length++;\\n        }\\n    }\\n    return_string = (char *)malloc(sizeof(char) * length);\\n    strncpy(return_string, strs[0], length);\\n    return_string[length] = \\'\\\\0\\';\\n    return return_string;\\n}\\n//"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Has anyone tried using a Trie? Is that overcomplicating this problem?"
                    },
                    {
                        "username": "anmol1301",
                        "content": "strs[i].size() returns size_t not int\\nyou can\\'t compare int with size_t unless you typecase it to int"
                    },
                    {
                        "username": "Razin87",
                        "content": "For testcase 16, my output was \\'flo\\' and the expected output was \\'flower\\'. The sample for the testcase was strs = [\"flower\",\"flower\",\"flower\",\"flower\"]. Am I not supposed to find the prefix but the whole word in case they\\'re the same word?"
                    },
                    {
                        "username": "HariharPal",
                        "content": "my solution is working on vscode where string [\"flower\",\"flower\",\"flower\",\"flower\"] is passed but when i put this code in leetcode it give output \"\"\\nhere is my crap code\\nclass Program14Try {\\n    public static String longestCommonPrefix(String[] strs) {\\n        String last = strs[strs.length - 1];\\n        String sample = \"\";\\n        String Initial = strs[0];\\n        for (int i = 0; i < strs.length; i++) {\\n            String ithStr = strs[i];\\n            for (int j = 0; j < ithStr.length(); j++) {\\n\\n                if (Initial.length() > 0 && strs[0] != strs[strs.length - 1]) {\\n                    if (Initial.charAt(j) != ithStr.charAt(j)) {\\n                        String Prefix = Initial.substring(0, j);\\n                        return Prefix;\\n                    } else if (strs.length == 1) {\\n                        return Initial;\\n                    } else if (Initial.charAt(j) == ithStr.charAt(j) && strs.length == 2) {\\n                        sample = sample + ithStr.charAt(j);\\n                        return sample;\\n                    }\\n                } else {\\n                    return strs[0];\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    public static void main(String[] args) {\\n        String[] strs = { \"ab\", \"a\" };\\n        System.out.println(longestCommonPrefix(strs));\\n    }\\n}"
                    },
                    {
                        "username": "tribit",
                        "content": "Definition of \"common\" should be stated here. I worked with assumption that \"common\" is prefix found in 2 or more items, when it clearly should be, `prefix found in all items`."
                    }
                ]
            },
            {
                "id": 2019638,
                "content": [
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty()) {\\n            return \"\";\\n        }\\n        \\n        string s3;\\n        \\n        for (int j = 0; j < strs[0].size(); j++) {\\n            char current_char = strs[0][j];\\n            \\n            for (int i = 1; i < strs.size(); i++) {\\n                if (j >= strs[i].size() || strs[i][j] != current_char) {\\n                    return s3;\\n                }\\n            }\\n            \\n            s3.push_back(current_char);\\n        }\\n        \\n        return s3;\\n    }\\n};\\n"
                    },
                    {
                        "username": "grisoliaemilio0",
                        "content": "The problem is not correctly worded. The prefix should exists in ALL the strings in the array, which can be empty (in this case, \"\" should be returned)"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This was easy but really annoying....\\ni solved it under 10 min though.. ;D"
                    },
                    {
                        "username": "rammuthukumar18",
                        "content": "for this solution it won\\'t give the correct output for the testcase [\"flower\",\"flower\",\"flower\",\"flower\"] it prints \"\" but the correct output is \"flower\" why is that?\\n\\nPassed : 95/124\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String ans=\"\";\\n        int cnt=0;\\n        if(strs.length==1) {\\n            ans=ans+strs[0];\\n            return ans;\\n        }\\n        for(int i=0;i<strs[0].length();i++){\\n            if(checker((strs[0].charAt(i)),strs,i))\\n                cnt++;\\n            else {\\n                ans=ans+strs[0].substring(0,cnt);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n    public boolean checker(char ch,String[] strs,int j){\\n        for(int i=1;i<strs.length;i++){\\n            if(strs[i].length()>j) {\\n                if(ch!=strs[i].charAt(j)) \\n                    return false;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "seventy_two",
                        "content": "The code below is showing the exact output in my IDE but it\\'s not getting done in here Why? \\n\\n\\nchar *longestCommonPrefix(char **strs, int strsSize)\\n{\\n    char *return_string;\\n    int length = 0;\\n    int flag = 0;\\n    for (int i = 0; i < strlen(strs[0]); i++)\\n    {\\n        for (int j = 1; j < strsSize; j++)\\n        {\\n            if (strs[0][i] != strs[j][i])\\n            {\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if (flag)\\n            break;\\n        else\\n        {\\n            length++;\\n        }\\n    }\\n    return_string = (char *)malloc(sizeof(char) * length);\\n    strncpy(return_string, strs[0], length);\\n    return_string[length] = \\'\\\\0\\';\\n    return return_string;\\n}\\n//"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Has anyone tried using a Trie? Is that overcomplicating this problem?"
                    },
                    {
                        "username": "anmol1301",
                        "content": "strs[i].size() returns size_t not int\\nyou can\\'t compare int with size_t unless you typecase it to int"
                    },
                    {
                        "username": "Razin87",
                        "content": "For testcase 16, my output was \\'flo\\' and the expected output was \\'flower\\'. The sample for the testcase was strs = [\"flower\",\"flower\",\"flower\",\"flower\"]. Am I not supposed to find the prefix but the whole word in case they\\'re the same word?"
                    },
                    {
                        "username": "HariharPal",
                        "content": "my solution is working on vscode where string [\"flower\",\"flower\",\"flower\",\"flower\"] is passed but when i put this code in leetcode it give output \"\"\\nhere is my crap code\\nclass Program14Try {\\n    public static String longestCommonPrefix(String[] strs) {\\n        String last = strs[strs.length - 1];\\n        String sample = \"\";\\n        String Initial = strs[0];\\n        for (int i = 0; i < strs.length; i++) {\\n            String ithStr = strs[i];\\n            for (int j = 0; j < ithStr.length(); j++) {\\n\\n                if (Initial.length() > 0 && strs[0] != strs[strs.length - 1]) {\\n                    if (Initial.charAt(j) != ithStr.charAt(j)) {\\n                        String Prefix = Initial.substring(0, j);\\n                        return Prefix;\\n                    } else if (strs.length == 1) {\\n                        return Initial;\\n                    } else if (Initial.charAt(j) == ithStr.charAt(j) && strs.length == 2) {\\n                        sample = sample + ithStr.charAt(j);\\n                        return sample;\\n                    }\\n                } else {\\n                    return strs[0];\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    public static void main(String[] args) {\\n        String[] strs = { \"ab\", \"a\" };\\n        System.out.println(longestCommonPrefix(strs));\\n    }\\n}"
                    },
                    {
                        "username": "tribit",
                        "content": "Definition of \"common\" should be stated here. I worked with assumption that \"common\" is prefix found in 2 or more items, when it clearly should be, `prefix found in all items`."
                    }
                ]
            },
            {
                "id": 2017693,
                "content": [
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty()) {\\n            return \"\";\\n        }\\n        \\n        string s3;\\n        \\n        for (int j = 0; j < strs[0].size(); j++) {\\n            char current_char = strs[0][j];\\n            \\n            for (int i = 1; i < strs.size(); i++) {\\n                if (j >= strs[i].size() || strs[i][j] != current_char) {\\n                    return s3;\\n                }\\n            }\\n            \\n            s3.push_back(current_char);\\n        }\\n        \\n        return s3;\\n    }\\n};\\n"
                    },
                    {
                        "username": "grisoliaemilio0",
                        "content": "The problem is not correctly worded. The prefix should exists in ALL the strings in the array, which can be empty (in this case, \"\" should be returned)"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This was easy but really annoying....\\ni solved it under 10 min though.. ;D"
                    },
                    {
                        "username": "rammuthukumar18",
                        "content": "for this solution it won\\'t give the correct output for the testcase [\"flower\",\"flower\",\"flower\",\"flower\"] it prints \"\" but the correct output is \"flower\" why is that?\\n\\nPassed : 95/124\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String ans=\"\";\\n        int cnt=0;\\n        if(strs.length==1) {\\n            ans=ans+strs[0];\\n            return ans;\\n        }\\n        for(int i=0;i<strs[0].length();i++){\\n            if(checker((strs[0].charAt(i)),strs,i))\\n                cnt++;\\n            else {\\n                ans=ans+strs[0].substring(0,cnt);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n    public boolean checker(char ch,String[] strs,int j){\\n        for(int i=1;i<strs.length;i++){\\n            if(strs[i].length()>j) {\\n                if(ch!=strs[i].charAt(j)) \\n                    return false;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "seventy_two",
                        "content": "The code below is showing the exact output in my IDE but it\\'s not getting done in here Why? \\n\\n\\nchar *longestCommonPrefix(char **strs, int strsSize)\\n{\\n    char *return_string;\\n    int length = 0;\\n    int flag = 0;\\n    for (int i = 0; i < strlen(strs[0]); i++)\\n    {\\n        for (int j = 1; j < strsSize; j++)\\n        {\\n            if (strs[0][i] != strs[j][i])\\n            {\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if (flag)\\n            break;\\n        else\\n        {\\n            length++;\\n        }\\n    }\\n    return_string = (char *)malloc(sizeof(char) * length);\\n    strncpy(return_string, strs[0], length);\\n    return_string[length] = \\'\\\\0\\';\\n    return return_string;\\n}\\n//"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Has anyone tried using a Trie? Is that overcomplicating this problem?"
                    },
                    {
                        "username": "anmol1301",
                        "content": "strs[i].size() returns size_t not int\\nyou can\\'t compare int with size_t unless you typecase it to int"
                    },
                    {
                        "username": "Razin87",
                        "content": "For testcase 16, my output was \\'flo\\' and the expected output was \\'flower\\'. The sample for the testcase was strs = [\"flower\",\"flower\",\"flower\",\"flower\"]. Am I not supposed to find the prefix but the whole word in case they\\'re the same word?"
                    },
                    {
                        "username": "HariharPal",
                        "content": "my solution is working on vscode where string [\"flower\",\"flower\",\"flower\",\"flower\"] is passed but when i put this code in leetcode it give output \"\"\\nhere is my crap code\\nclass Program14Try {\\n    public static String longestCommonPrefix(String[] strs) {\\n        String last = strs[strs.length - 1];\\n        String sample = \"\";\\n        String Initial = strs[0];\\n        for (int i = 0; i < strs.length; i++) {\\n            String ithStr = strs[i];\\n            for (int j = 0; j < ithStr.length(); j++) {\\n\\n                if (Initial.length() > 0 && strs[0] != strs[strs.length - 1]) {\\n                    if (Initial.charAt(j) != ithStr.charAt(j)) {\\n                        String Prefix = Initial.substring(0, j);\\n                        return Prefix;\\n                    } else if (strs.length == 1) {\\n                        return Initial;\\n                    } else if (Initial.charAt(j) == ithStr.charAt(j) && strs.length == 2) {\\n                        sample = sample + ithStr.charAt(j);\\n                        return sample;\\n                    }\\n                } else {\\n                    return strs[0];\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    public static void main(String[] args) {\\n        String[] strs = { \"ab\", \"a\" };\\n        System.out.println(longestCommonPrefix(strs));\\n    }\\n}"
                    },
                    {
                        "username": "tribit",
                        "content": "Definition of \"common\" should be stated here. I worked with assumption that \"common\" is prefix found in 2 or more items, when it clearly should be, `prefix found in all items`."
                    }
                ]
            },
            {
                "id": 2007273,
                "content": [
                    {
                        "username": "viveknagesh21",
                        "content": "Still giving wrong answer (submission not accepted), These are my testcase run results\n[\"flower\",\"flow\",\"flight\"]\n\"fl\"\n\"fl\"\n\n[\"dog\",\"racecar\",\"car\"]\n\"\"\n\"\"\nmy code is running with time complexity O(n^2), "
                    },
                    {
                        "username": "erenyeager1",
                        "content": " i solved the this ex and checked it in visualize compiler and codeblocks , it works fine with no errors or warnings , but here it shows me theres a problem soo whatts the deal?? if anyone could find out the problem i would be glad !!\nchar * longestCommonPrefix(char ** strs, int strsSize){\n\n\nint i,len=0,j=0,len2=0;\nfor(i=0;strs[0][i]!='\\0';i++) /// i start by finding the len of first str\n    len++;\n\nchar *prefix=malloc((len+1)*(sizeof(char))); //the max size of prefix could by the len of any str in the array\n\nfor(i=0;i<len;i++)\nprefix[i]=strs[0][i]; /// i assume that first str is prefix \n\nprefix[len]='\\0';\n\nfor(i=1;i<strsSize;i++)\n    {\n        for( j=0;j<len;j++)\n\n            {\n                if(prefix[j]!=strs[i][j]) // run a lop in each str if i find a charter thats not common i replace the prefix with \\0; \n                {\n                    prefix[j]='\\0';\n                }\n            }\n            \n    }\n\nreturn prefix;\n}\n\n\nits ready to run , please try it in codeblocks or where ever and tell me what you think!!!"
                    },
                    {
                        "username": "hasan7",
                        "content": "For Input,  [\"c\",\"acc\",\"ccc\"]\\nmy answer is  \"c\" but it is expecting it to be \"\" \\nbut when the input in [\"c\"] , it is expecting \"c\" \\nThis is contradicting with each other and seems wrong??\\n"
                    },
                    {
                        "username": "coronelpoj",
                        "content": "Gonna highlight some of the parts of the problem to help you there buddy\\nWrite a function to find the longest COMMON PREFIX string AMONGST an array of strings.\\n\\nThis means for the [\"c\",\"acc\",\"ccc\"] input the answer is \"\" because \"acc\" did not have a common prefix among the remaining inputs.\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Is this a good enough solution to crack fang on this problem: \\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n        if len(strs)==2:\\n            ans =\"\"\\n            for i in range(0,min(len(strs[0]),len(strs[1]))):\\n                if strs[0][i]!=strs[1][i]:\\n                    return ans\\n                else:\\n                    ans+=strs[0][i]\\n            return ans\\n        ans = list(strs[0])\\n        for i in range(1,len(strs)):\\n            if len(ans)==0:\\n                break\\n            nex = \"\"\\n            for j in range(0,min(len(strs[i]),len(ans))):\\n                if ans[j]!=strs[i][j]:\\n                    break\\n                else:\\n                    nex+=ans[j]\\n            ans = list(nex)\\n        s = \"\"\\n        for i in ans:\\n            s+=i\\n        return s"
                    },
                    {
                        "username": "qwertypushkar123",
                        "content": "class Solution {\\npublic:\\n    // bool cmp(string a,string b){\\n    //     if(a.size()!=b.size()) return a.size()<b.size();\\n    //     else{\\n    //         return a<b;\\n    //     }\\n    // }\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end(),[&](string a,string b){\\n            if(a.size()!=b.size()) return a.size()<b.size();\\n        else{\\n            return a<b;\\n        }\\n        });\\n        string ans=strs[0];\\n        for(auto val:strs){\\n            for(int i=0;i<min(ans.size(),val.size());i++){\\n                if(ans[i]!=val[i]){\\n                    ans.erase(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis solution got accepted but cmp function (marked in comments) was throwing error so i used lambda function. can any one tell the mistake "
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Understand the problem statement properly. PREFIX means that something that comes before any word.SUFFIX is something that comes in last. Use of string functions make the question easier."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "if there is prefix then there is TRIE"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "why he is showing me this error \\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "Jyotiprakashchanda",
                        "content": "class Solution {\\n       public String common(String s1,String s2){\\n           //compare bitween two string\\n           StringBuilder b = new StringBuilder();\\n           //find min length betwiin two string it easy to compare\\n           int min=Math.min(s1.length(), s2.length());\\n           for(int i=0;i<min;i++){\\n               if(s1.charAt(i)==s2.charAt(i)){\\n                   b.append(s1.charAt(i));\\n               }else{\\n                   break;\\n               }\\n           }\\n           return b.toString();\\n       }\\n    public String longestCommonPrefix(String[] strs) {\\n     String prefix=strs[0];\\n     for(int i=0;i<strs.length;i++){\\n         prefix= common(prefix,strs[i]);// compare 1st index string with other string one by one\\n     }\\n     return prefix;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "pjain043",
                        "content": "The problem statment means, that starting from the first character in each string. what is the longest common substring/prefix.\\nHence [\"reflower\",\"flow\",\"flight\"] gives \"\"."
                    }
                ]
            },
            {
                "id": 2005432,
                "content": [
                    {
                        "username": "viveknagesh21",
                        "content": "Still giving wrong answer (submission not accepted), These are my testcase run results\n[\"flower\",\"flow\",\"flight\"]\n\"fl\"\n\"fl\"\n\n[\"dog\",\"racecar\",\"car\"]\n\"\"\n\"\"\nmy code is running with time complexity O(n^2), "
                    },
                    {
                        "username": "erenyeager1",
                        "content": " i solved the this ex and checked it in visualize compiler and codeblocks , it works fine with no errors or warnings , but here it shows me theres a problem soo whatts the deal?? if anyone could find out the problem i would be glad !!\nchar * longestCommonPrefix(char ** strs, int strsSize){\n\n\nint i,len=0,j=0,len2=0;\nfor(i=0;strs[0][i]!='\\0';i++) /// i start by finding the len of first str\n    len++;\n\nchar *prefix=malloc((len+1)*(sizeof(char))); //the max size of prefix could by the len of any str in the array\n\nfor(i=0;i<len;i++)\nprefix[i]=strs[0][i]; /// i assume that first str is prefix \n\nprefix[len]='\\0';\n\nfor(i=1;i<strsSize;i++)\n    {\n        for( j=0;j<len;j++)\n\n            {\n                if(prefix[j]!=strs[i][j]) // run a lop in each str if i find a charter thats not common i replace the prefix with \\0; \n                {\n                    prefix[j]='\\0';\n                }\n            }\n            \n    }\n\nreturn prefix;\n}\n\n\nits ready to run , please try it in codeblocks or where ever and tell me what you think!!!"
                    },
                    {
                        "username": "hasan7",
                        "content": "For Input,  [\"c\",\"acc\",\"ccc\"]\\nmy answer is  \"c\" but it is expecting it to be \"\" \\nbut when the input in [\"c\"] , it is expecting \"c\" \\nThis is contradicting with each other and seems wrong??\\n"
                    },
                    {
                        "username": "coronelpoj",
                        "content": "Gonna highlight some of the parts of the problem to help you there buddy\\nWrite a function to find the longest COMMON PREFIX string AMONGST an array of strings.\\n\\nThis means for the [\"c\",\"acc\",\"ccc\"] input the answer is \"\" because \"acc\" did not have a common prefix among the remaining inputs.\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Is this a good enough solution to crack fang on this problem: \\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n        if len(strs)==2:\\n            ans =\"\"\\n            for i in range(0,min(len(strs[0]),len(strs[1]))):\\n                if strs[0][i]!=strs[1][i]:\\n                    return ans\\n                else:\\n                    ans+=strs[0][i]\\n            return ans\\n        ans = list(strs[0])\\n        for i in range(1,len(strs)):\\n            if len(ans)==0:\\n                break\\n            nex = \"\"\\n            for j in range(0,min(len(strs[i]),len(ans))):\\n                if ans[j]!=strs[i][j]:\\n                    break\\n                else:\\n                    nex+=ans[j]\\n            ans = list(nex)\\n        s = \"\"\\n        for i in ans:\\n            s+=i\\n        return s"
                    },
                    {
                        "username": "qwertypushkar123",
                        "content": "class Solution {\\npublic:\\n    // bool cmp(string a,string b){\\n    //     if(a.size()!=b.size()) return a.size()<b.size();\\n    //     else{\\n    //         return a<b;\\n    //     }\\n    // }\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end(),[&](string a,string b){\\n            if(a.size()!=b.size()) return a.size()<b.size();\\n        else{\\n            return a<b;\\n        }\\n        });\\n        string ans=strs[0];\\n        for(auto val:strs){\\n            for(int i=0;i<min(ans.size(),val.size());i++){\\n                if(ans[i]!=val[i]){\\n                    ans.erase(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis solution got accepted but cmp function (marked in comments) was throwing error so i used lambda function. can any one tell the mistake "
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Understand the problem statement properly. PREFIX means that something that comes before any word.SUFFIX is something that comes in last. Use of string functions make the question easier."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "if there is prefix then there is TRIE"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "why he is showing me this error \\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "Jyotiprakashchanda",
                        "content": "class Solution {\\n       public String common(String s1,String s2){\\n           //compare bitween two string\\n           StringBuilder b = new StringBuilder();\\n           //find min length betwiin two string it easy to compare\\n           int min=Math.min(s1.length(), s2.length());\\n           for(int i=0;i<min;i++){\\n               if(s1.charAt(i)==s2.charAt(i)){\\n                   b.append(s1.charAt(i));\\n               }else{\\n                   break;\\n               }\\n           }\\n           return b.toString();\\n       }\\n    public String longestCommonPrefix(String[] strs) {\\n     String prefix=strs[0];\\n     for(int i=0;i<strs.length;i++){\\n         prefix= common(prefix,strs[i]);// compare 1st index string with other string one by one\\n     }\\n     return prefix;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "pjain043",
                        "content": "The problem statment means, that starting from the first character in each string. what is the longest common substring/prefix.\\nHence [\"reflower\",\"flow\",\"flight\"] gives \"\"."
                    }
                ]
            },
            {
                "id": 2000031,
                "content": [
                    {
                        "username": "viveknagesh21",
                        "content": "Still giving wrong answer (submission not accepted), These are my testcase run results\n[\"flower\",\"flow\",\"flight\"]\n\"fl\"\n\"fl\"\n\n[\"dog\",\"racecar\",\"car\"]\n\"\"\n\"\"\nmy code is running with time complexity O(n^2), "
                    },
                    {
                        "username": "erenyeager1",
                        "content": " i solved the this ex and checked it in visualize compiler and codeblocks , it works fine with no errors or warnings , but here it shows me theres a problem soo whatts the deal?? if anyone could find out the problem i would be glad !!\nchar * longestCommonPrefix(char ** strs, int strsSize){\n\n\nint i,len=0,j=0,len2=0;\nfor(i=0;strs[0][i]!='\\0';i++) /// i start by finding the len of first str\n    len++;\n\nchar *prefix=malloc((len+1)*(sizeof(char))); //the max size of prefix could by the len of any str in the array\n\nfor(i=0;i<len;i++)\nprefix[i]=strs[0][i]; /// i assume that first str is prefix \n\nprefix[len]='\\0';\n\nfor(i=1;i<strsSize;i++)\n    {\n        for( j=0;j<len;j++)\n\n            {\n                if(prefix[j]!=strs[i][j]) // run a lop in each str if i find a charter thats not common i replace the prefix with \\0; \n                {\n                    prefix[j]='\\0';\n                }\n            }\n            \n    }\n\nreturn prefix;\n}\n\n\nits ready to run , please try it in codeblocks or where ever and tell me what you think!!!"
                    },
                    {
                        "username": "hasan7",
                        "content": "For Input,  [\"c\",\"acc\",\"ccc\"]\\nmy answer is  \"c\" but it is expecting it to be \"\" \\nbut when the input in [\"c\"] , it is expecting \"c\" \\nThis is contradicting with each other and seems wrong??\\n"
                    },
                    {
                        "username": "coronelpoj",
                        "content": "Gonna highlight some of the parts of the problem to help you there buddy\\nWrite a function to find the longest COMMON PREFIX string AMONGST an array of strings.\\n\\nThis means for the [\"c\",\"acc\",\"ccc\"] input the answer is \"\" because \"acc\" did not have a common prefix among the remaining inputs.\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Is this a good enough solution to crack fang on this problem: \\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n        if len(strs)==2:\\n            ans =\"\"\\n            for i in range(0,min(len(strs[0]),len(strs[1]))):\\n                if strs[0][i]!=strs[1][i]:\\n                    return ans\\n                else:\\n                    ans+=strs[0][i]\\n            return ans\\n        ans = list(strs[0])\\n        for i in range(1,len(strs)):\\n            if len(ans)==0:\\n                break\\n            nex = \"\"\\n            for j in range(0,min(len(strs[i]),len(ans))):\\n                if ans[j]!=strs[i][j]:\\n                    break\\n                else:\\n                    nex+=ans[j]\\n            ans = list(nex)\\n        s = \"\"\\n        for i in ans:\\n            s+=i\\n        return s"
                    },
                    {
                        "username": "qwertypushkar123",
                        "content": "class Solution {\\npublic:\\n    // bool cmp(string a,string b){\\n    //     if(a.size()!=b.size()) return a.size()<b.size();\\n    //     else{\\n    //         return a<b;\\n    //     }\\n    // }\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end(),[&](string a,string b){\\n            if(a.size()!=b.size()) return a.size()<b.size();\\n        else{\\n            return a<b;\\n        }\\n        });\\n        string ans=strs[0];\\n        for(auto val:strs){\\n            for(int i=0;i<min(ans.size(),val.size());i++){\\n                if(ans[i]!=val[i]){\\n                    ans.erase(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis solution got accepted but cmp function (marked in comments) was throwing error so i used lambda function. can any one tell the mistake "
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Understand the problem statement properly. PREFIX means that something that comes before any word.SUFFIX is something that comes in last. Use of string functions make the question easier."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "if there is prefix then there is TRIE"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "why he is showing me this error \\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "Jyotiprakashchanda",
                        "content": "class Solution {\\n       public String common(String s1,String s2){\\n           //compare bitween two string\\n           StringBuilder b = new StringBuilder();\\n           //find min length betwiin two string it easy to compare\\n           int min=Math.min(s1.length(), s2.length());\\n           for(int i=0;i<min;i++){\\n               if(s1.charAt(i)==s2.charAt(i)){\\n                   b.append(s1.charAt(i));\\n               }else{\\n                   break;\\n               }\\n           }\\n           return b.toString();\\n       }\\n    public String longestCommonPrefix(String[] strs) {\\n     String prefix=strs[0];\\n     for(int i=0;i<strs.length;i++){\\n         prefix= common(prefix,strs[i]);// compare 1st index string with other string one by one\\n     }\\n     return prefix;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "pjain043",
                        "content": "The problem statment means, that starting from the first character in each string. what is the longest common substring/prefix.\\nHence [\"reflower\",\"flow\",\"flight\"] gives \"\"."
                    }
                ]
            },
            {
                "id": 1999258,
                "content": [
                    {
                        "username": "viveknagesh21",
                        "content": "Still giving wrong answer (submission not accepted), These are my testcase run results\n[\"flower\",\"flow\",\"flight\"]\n\"fl\"\n\"fl\"\n\n[\"dog\",\"racecar\",\"car\"]\n\"\"\n\"\"\nmy code is running with time complexity O(n^2), "
                    },
                    {
                        "username": "erenyeager1",
                        "content": " i solved the this ex and checked it in visualize compiler and codeblocks , it works fine with no errors or warnings , but here it shows me theres a problem soo whatts the deal?? if anyone could find out the problem i would be glad !!\nchar * longestCommonPrefix(char ** strs, int strsSize){\n\n\nint i,len=0,j=0,len2=0;\nfor(i=0;strs[0][i]!='\\0';i++) /// i start by finding the len of first str\n    len++;\n\nchar *prefix=malloc((len+1)*(sizeof(char))); //the max size of prefix could by the len of any str in the array\n\nfor(i=0;i<len;i++)\nprefix[i]=strs[0][i]; /// i assume that first str is prefix \n\nprefix[len]='\\0';\n\nfor(i=1;i<strsSize;i++)\n    {\n        for( j=0;j<len;j++)\n\n            {\n                if(prefix[j]!=strs[i][j]) // run a lop in each str if i find a charter thats not common i replace the prefix with \\0; \n                {\n                    prefix[j]='\\0';\n                }\n            }\n            \n    }\n\nreturn prefix;\n}\n\n\nits ready to run , please try it in codeblocks or where ever and tell me what you think!!!"
                    },
                    {
                        "username": "hasan7",
                        "content": "For Input,  [\"c\",\"acc\",\"ccc\"]\\nmy answer is  \"c\" but it is expecting it to be \"\" \\nbut when the input in [\"c\"] , it is expecting \"c\" \\nThis is contradicting with each other and seems wrong??\\n"
                    },
                    {
                        "username": "coronelpoj",
                        "content": "Gonna highlight some of the parts of the problem to help you there buddy\\nWrite a function to find the longest COMMON PREFIX string AMONGST an array of strings.\\n\\nThis means for the [\"c\",\"acc\",\"ccc\"] input the answer is \"\" because \"acc\" did not have a common prefix among the remaining inputs.\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Is this a good enough solution to crack fang on this problem: \\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n        if len(strs)==2:\\n            ans =\"\"\\n            for i in range(0,min(len(strs[0]),len(strs[1]))):\\n                if strs[0][i]!=strs[1][i]:\\n                    return ans\\n                else:\\n                    ans+=strs[0][i]\\n            return ans\\n        ans = list(strs[0])\\n        for i in range(1,len(strs)):\\n            if len(ans)==0:\\n                break\\n            nex = \"\"\\n            for j in range(0,min(len(strs[i]),len(ans))):\\n                if ans[j]!=strs[i][j]:\\n                    break\\n                else:\\n                    nex+=ans[j]\\n            ans = list(nex)\\n        s = \"\"\\n        for i in ans:\\n            s+=i\\n        return s"
                    },
                    {
                        "username": "qwertypushkar123",
                        "content": "class Solution {\\npublic:\\n    // bool cmp(string a,string b){\\n    //     if(a.size()!=b.size()) return a.size()<b.size();\\n    //     else{\\n    //         return a<b;\\n    //     }\\n    // }\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end(),[&](string a,string b){\\n            if(a.size()!=b.size()) return a.size()<b.size();\\n        else{\\n            return a<b;\\n        }\\n        });\\n        string ans=strs[0];\\n        for(auto val:strs){\\n            for(int i=0;i<min(ans.size(),val.size());i++){\\n                if(ans[i]!=val[i]){\\n                    ans.erase(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis solution got accepted but cmp function (marked in comments) was throwing error so i used lambda function. can any one tell the mistake "
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Understand the problem statement properly. PREFIX means that something that comes before any word.SUFFIX is something that comes in last. Use of string functions make the question easier."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "if there is prefix then there is TRIE"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "why he is showing me this error \\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "Jyotiprakashchanda",
                        "content": "class Solution {\\n       public String common(String s1,String s2){\\n           //compare bitween two string\\n           StringBuilder b = new StringBuilder();\\n           //find min length betwiin two string it easy to compare\\n           int min=Math.min(s1.length(), s2.length());\\n           for(int i=0;i<min;i++){\\n               if(s1.charAt(i)==s2.charAt(i)){\\n                   b.append(s1.charAt(i));\\n               }else{\\n                   break;\\n               }\\n           }\\n           return b.toString();\\n       }\\n    public String longestCommonPrefix(String[] strs) {\\n     String prefix=strs[0];\\n     for(int i=0;i<strs.length;i++){\\n         prefix= common(prefix,strs[i]);// compare 1st index string with other string one by one\\n     }\\n     return prefix;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "pjain043",
                        "content": "The problem statment means, that starting from the first character in each string. what is the longest common substring/prefix.\\nHence [\"reflower\",\"flow\",\"flight\"] gives \"\"."
                    }
                ]
            },
            {
                "id": 1996744,
                "content": [
                    {
                        "username": "viveknagesh21",
                        "content": "Still giving wrong answer (submission not accepted), These are my testcase run results\n[\"flower\",\"flow\",\"flight\"]\n\"fl\"\n\"fl\"\n\n[\"dog\",\"racecar\",\"car\"]\n\"\"\n\"\"\nmy code is running with time complexity O(n^2), "
                    },
                    {
                        "username": "erenyeager1",
                        "content": " i solved the this ex and checked it in visualize compiler and codeblocks , it works fine with no errors or warnings , but here it shows me theres a problem soo whatts the deal?? if anyone could find out the problem i would be glad !!\nchar * longestCommonPrefix(char ** strs, int strsSize){\n\n\nint i,len=0,j=0,len2=0;\nfor(i=0;strs[0][i]!='\\0';i++) /// i start by finding the len of first str\n    len++;\n\nchar *prefix=malloc((len+1)*(sizeof(char))); //the max size of prefix could by the len of any str in the array\n\nfor(i=0;i<len;i++)\nprefix[i]=strs[0][i]; /// i assume that first str is prefix \n\nprefix[len]='\\0';\n\nfor(i=1;i<strsSize;i++)\n    {\n        for( j=0;j<len;j++)\n\n            {\n                if(prefix[j]!=strs[i][j]) // run a lop in each str if i find a charter thats not common i replace the prefix with \\0; \n                {\n                    prefix[j]='\\0';\n                }\n            }\n            \n    }\n\nreturn prefix;\n}\n\n\nits ready to run , please try it in codeblocks or where ever and tell me what you think!!!"
                    },
                    {
                        "username": "hasan7",
                        "content": "For Input,  [\"c\",\"acc\",\"ccc\"]\\nmy answer is  \"c\" but it is expecting it to be \"\" \\nbut when the input in [\"c\"] , it is expecting \"c\" \\nThis is contradicting with each other and seems wrong??\\n"
                    },
                    {
                        "username": "coronelpoj",
                        "content": "Gonna highlight some of the parts of the problem to help you there buddy\\nWrite a function to find the longest COMMON PREFIX string AMONGST an array of strings.\\n\\nThis means for the [\"c\",\"acc\",\"ccc\"] input the answer is \"\" because \"acc\" did not have a common prefix among the remaining inputs.\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Is this a good enough solution to crack fang on this problem: \\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n        if len(strs)==2:\\n            ans =\"\"\\n            for i in range(0,min(len(strs[0]),len(strs[1]))):\\n                if strs[0][i]!=strs[1][i]:\\n                    return ans\\n                else:\\n                    ans+=strs[0][i]\\n            return ans\\n        ans = list(strs[0])\\n        for i in range(1,len(strs)):\\n            if len(ans)==0:\\n                break\\n            nex = \"\"\\n            for j in range(0,min(len(strs[i]),len(ans))):\\n                if ans[j]!=strs[i][j]:\\n                    break\\n                else:\\n                    nex+=ans[j]\\n            ans = list(nex)\\n        s = \"\"\\n        for i in ans:\\n            s+=i\\n        return s"
                    },
                    {
                        "username": "qwertypushkar123",
                        "content": "class Solution {\\npublic:\\n    // bool cmp(string a,string b){\\n    //     if(a.size()!=b.size()) return a.size()<b.size();\\n    //     else{\\n    //         return a<b;\\n    //     }\\n    // }\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end(),[&](string a,string b){\\n            if(a.size()!=b.size()) return a.size()<b.size();\\n        else{\\n            return a<b;\\n        }\\n        });\\n        string ans=strs[0];\\n        for(auto val:strs){\\n            for(int i=0;i<min(ans.size(),val.size());i++){\\n                if(ans[i]!=val[i]){\\n                    ans.erase(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis solution got accepted but cmp function (marked in comments) was throwing error so i used lambda function. can any one tell the mistake "
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Understand the problem statement properly. PREFIX means that something that comes before any word.SUFFIX is something that comes in last. Use of string functions make the question easier."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "if there is prefix then there is TRIE"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "why he is showing me this error \\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "Jyotiprakashchanda",
                        "content": "class Solution {\\n       public String common(String s1,String s2){\\n           //compare bitween two string\\n           StringBuilder b = new StringBuilder();\\n           //find min length betwiin two string it easy to compare\\n           int min=Math.min(s1.length(), s2.length());\\n           for(int i=0;i<min;i++){\\n               if(s1.charAt(i)==s2.charAt(i)){\\n                   b.append(s1.charAt(i));\\n               }else{\\n                   break;\\n               }\\n           }\\n           return b.toString();\\n       }\\n    public String longestCommonPrefix(String[] strs) {\\n     String prefix=strs[0];\\n     for(int i=0;i<strs.length;i++){\\n         prefix= common(prefix,strs[i]);// compare 1st index string with other string one by one\\n     }\\n     return prefix;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "pjain043",
                        "content": "The problem statment means, that starting from the first character in each string. what is the longest common substring/prefix.\\nHence [\"reflower\",\"flow\",\"flight\"] gives \"\"."
                    }
                ]
            },
            {
                "id": 1990648,
                "content": [
                    {
                        "username": "viveknagesh21",
                        "content": "Still giving wrong answer (submission not accepted), These are my testcase run results\n[\"flower\",\"flow\",\"flight\"]\n\"fl\"\n\"fl\"\n\n[\"dog\",\"racecar\",\"car\"]\n\"\"\n\"\"\nmy code is running with time complexity O(n^2), "
                    },
                    {
                        "username": "erenyeager1",
                        "content": " i solved the this ex and checked it in visualize compiler and codeblocks , it works fine with no errors or warnings , but here it shows me theres a problem soo whatts the deal?? if anyone could find out the problem i would be glad !!\nchar * longestCommonPrefix(char ** strs, int strsSize){\n\n\nint i,len=0,j=0,len2=0;\nfor(i=0;strs[0][i]!='\\0';i++) /// i start by finding the len of first str\n    len++;\n\nchar *prefix=malloc((len+1)*(sizeof(char))); //the max size of prefix could by the len of any str in the array\n\nfor(i=0;i<len;i++)\nprefix[i]=strs[0][i]; /// i assume that first str is prefix \n\nprefix[len]='\\0';\n\nfor(i=1;i<strsSize;i++)\n    {\n        for( j=0;j<len;j++)\n\n            {\n                if(prefix[j]!=strs[i][j]) // run a lop in each str if i find a charter thats not common i replace the prefix with \\0; \n                {\n                    prefix[j]='\\0';\n                }\n            }\n            \n    }\n\nreturn prefix;\n}\n\n\nits ready to run , please try it in codeblocks or where ever and tell me what you think!!!"
                    },
                    {
                        "username": "hasan7",
                        "content": "For Input,  [\"c\",\"acc\",\"ccc\"]\\nmy answer is  \"c\" but it is expecting it to be \"\" \\nbut when the input in [\"c\"] , it is expecting \"c\" \\nThis is contradicting with each other and seems wrong??\\n"
                    },
                    {
                        "username": "coronelpoj",
                        "content": "Gonna highlight some of the parts of the problem to help you there buddy\\nWrite a function to find the longest COMMON PREFIX string AMONGST an array of strings.\\n\\nThis means for the [\"c\",\"acc\",\"ccc\"] input the answer is \"\" because \"acc\" did not have a common prefix among the remaining inputs.\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Is this a good enough solution to crack fang on this problem: \\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n        if len(strs)==2:\\n            ans =\"\"\\n            for i in range(0,min(len(strs[0]),len(strs[1]))):\\n                if strs[0][i]!=strs[1][i]:\\n                    return ans\\n                else:\\n                    ans+=strs[0][i]\\n            return ans\\n        ans = list(strs[0])\\n        for i in range(1,len(strs)):\\n            if len(ans)==0:\\n                break\\n            nex = \"\"\\n            for j in range(0,min(len(strs[i]),len(ans))):\\n                if ans[j]!=strs[i][j]:\\n                    break\\n                else:\\n                    nex+=ans[j]\\n            ans = list(nex)\\n        s = \"\"\\n        for i in ans:\\n            s+=i\\n        return s"
                    },
                    {
                        "username": "qwertypushkar123",
                        "content": "class Solution {\\npublic:\\n    // bool cmp(string a,string b){\\n    //     if(a.size()!=b.size()) return a.size()<b.size();\\n    //     else{\\n    //         return a<b;\\n    //     }\\n    // }\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end(),[&](string a,string b){\\n            if(a.size()!=b.size()) return a.size()<b.size();\\n        else{\\n            return a<b;\\n        }\\n        });\\n        string ans=strs[0];\\n        for(auto val:strs){\\n            for(int i=0;i<min(ans.size(),val.size());i++){\\n                if(ans[i]!=val[i]){\\n                    ans.erase(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis solution got accepted but cmp function (marked in comments) was throwing error so i used lambda function. can any one tell the mistake "
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Understand the problem statement properly. PREFIX means that something that comes before any word.SUFFIX is something that comes in last. Use of string functions make the question easier."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "if there is prefix then there is TRIE"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "why he is showing me this error \\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "Jyotiprakashchanda",
                        "content": "class Solution {\\n       public String common(String s1,String s2){\\n           //compare bitween two string\\n           StringBuilder b = new StringBuilder();\\n           //find min length betwiin two string it easy to compare\\n           int min=Math.min(s1.length(), s2.length());\\n           for(int i=0;i<min;i++){\\n               if(s1.charAt(i)==s2.charAt(i)){\\n                   b.append(s1.charAt(i));\\n               }else{\\n                   break;\\n               }\\n           }\\n           return b.toString();\\n       }\\n    public String longestCommonPrefix(String[] strs) {\\n     String prefix=strs[0];\\n     for(int i=0;i<strs.length;i++){\\n         prefix= common(prefix,strs[i]);// compare 1st index string with other string one by one\\n     }\\n     return prefix;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "pjain043",
                        "content": "The problem statment means, that starting from the first character in each string. what is the longest common substring/prefix.\\nHence [\"reflower\",\"flow\",\"flight\"] gives \"\"."
                    }
                ]
            },
            {
                "id": 1959953,
                "content": [
                    {
                        "username": "viveknagesh21",
                        "content": "Still giving wrong answer (submission not accepted), These are my testcase run results\n[\"flower\",\"flow\",\"flight\"]\n\"fl\"\n\"fl\"\n\n[\"dog\",\"racecar\",\"car\"]\n\"\"\n\"\"\nmy code is running with time complexity O(n^2), "
                    },
                    {
                        "username": "erenyeager1",
                        "content": " i solved the this ex and checked it in visualize compiler and codeblocks , it works fine with no errors or warnings , but here it shows me theres a problem soo whatts the deal?? if anyone could find out the problem i would be glad !!\nchar * longestCommonPrefix(char ** strs, int strsSize){\n\n\nint i,len=0,j=0,len2=0;\nfor(i=0;strs[0][i]!='\\0';i++) /// i start by finding the len of first str\n    len++;\n\nchar *prefix=malloc((len+1)*(sizeof(char))); //the max size of prefix could by the len of any str in the array\n\nfor(i=0;i<len;i++)\nprefix[i]=strs[0][i]; /// i assume that first str is prefix \n\nprefix[len]='\\0';\n\nfor(i=1;i<strsSize;i++)\n    {\n        for( j=0;j<len;j++)\n\n            {\n                if(prefix[j]!=strs[i][j]) // run a lop in each str if i find a charter thats not common i replace the prefix with \\0; \n                {\n                    prefix[j]='\\0';\n                }\n            }\n            \n    }\n\nreturn prefix;\n}\n\n\nits ready to run , please try it in codeblocks or where ever and tell me what you think!!!"
                    },
                    {
                        "username": "hasan7",
                        "content": "For Input,  [\"c\",\"acc\",\"ccc\"]\\nmy answer is  \"c\" but it is expecting it to be \"\" \\nbut when the input in [\"c\"] , it is expecting \"c\" \\nThis is contradicting with each other and seems wrong??\\n"
                    },
                    {
                        "username": "coronelpoj",
                        "content": "Gonna highlight some of the parts of the problem to help you there buddy\\nWrite a function to find the longest COMMON PREFIX string AMONGST an array of strings.\\n\\nThis means for the [\"c\",\"acc\",\"ccc\"] input the answer is \"\" because \"acc\" did not have a common prefix among the remaining inputs.\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Is this a good enough solution to crack fang on this problem: \\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n        if len(strs)==2:\\n            ans =\"\"\\n            for i in range(0,min(len(strs[0]),len(strs[1]))):\\n                if strs[0][i]!=strs[1][i]:\\n                    return ans\\n                else:\\n                    ans+=strs[0][i]\\n            return ans\\n        ans = list(strs[0])\\n        for i in range(1,len(strs)):\\n            if len(ans)==0:\\n                break\\n            nex = \"\"\\n            for j in range(0,min(len(strs[i]),len(ans))):\\n                if ans[j]!=strs[i][j]:\\n                    break\\n                else:\\n                    nex+=ans[j]\\n            ans = list(nex)\\n        s = \"\"\\n        for i in ans:\\n            s+=i\\n        return s"
                    },
                    {
                        "username": "qwertypushkar123",
                        "content": "class Solution {\\npublic:\\n    // bool cmp(string a,string b){\\n    //     if(a.size()!=b.size()) return a.size()<b.size();\\n    //     else{\\n    //         return a<b;\\n    //     }\\n    // }\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end(),[&](string a,string b){\\n            if(a.size()!=b.size()) return a.size()<b.size();\\n        else{\\n            return a<b;\\n        }\\n        });\\n        string ans=strs[0];\\n        for(auto val:strs){\\n            for(int i=0;i<min(ans.size(),val.size());i++){\\n                if(ans[i]!=val[i]){\\n                    ans.erase(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis solution got accepted but cmp function (marked in comments) was throwing error so i used lambda function. can any one tell the mistake "
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Understand the problem statement properly. PREFIX means that something that comes before any word.SUFFIX is something that comes in last. Use of string functions make the question easier."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "if there is prefix then there is TRIE"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "why he is showing me this error \\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "Jyotiprakashchanda",
                        "content": "class Solution {\\n       public String common(String s1,String s2){\\n           //compare bitween two string\\n           StringBuilder b = new StringBuilder();\\n           //find min length betwiin two string it easy to compare\\n           int min=Math.min(s1.length(), s2.length());\\n           for(int i=0;i<min;i++){\\n               if(s1.charAt(i)==s2.charAt(i)){\\n                   b.append(s1.charAt(i));\\n               }else{\\n                   break;\\n               }\\n           }\\n           return b.toString();\\n       }\\n    public String longestCommonPrefix(String[] strs) {\\n     String prefix=strs[0];\\n     for(int i=0;i<strs.length;i++){\\n         prefix= common(prefix,strs[i]);// compare 1st index string with other string one by one\\n     }\\n     return prefix;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "pjain043",
                        "content": "The problem statment means, that starting from the first character in each string. what is the longest common substring/prefix.\\nHence [\"reflower\",\"flow\",\"flight\"] gives \"\"."
                    }
                ]
            },
            {
                "id": 1944322,
                "content": [
                    {
                        "username": "viveknagesh21",
                        "content": "Still giving wrong answer (submission not accepted), These are my testcase run results\n[\"flower\",\"flow\",\"flight\"]\n\"fl\"\n\"fl\"\n\n[\"dog\",\"racecar\",\"car\"]\n\"\"\n\"\"\nmy code is running with time complexity O(n^2), "
                    },
                    {
                        "username": "erenyeager1",
                        "content": " i solved the this ex and checked it in visualize compiler and codeblocks , it works fine with no errors or warnings , but here it shows me theres a problem soo whatts the deal?? if anyone could find out the problem i would be glad !!\nchar * longestCommonPrefix(char ** strs, int strsSize){\n\n\nint i,len=0,j=0,len2=0;\nfor(i=0;strs[0][i]!='\\0';i++) /// i start by finding the len of first str\n    len++;\n\nchar *prefix=malloc((len+1)*(sizeof(char))); //the max size of prefix could by the len of any str in the array\n\nfor(i=0;i<len;i++)\nprefix[i]=strs[0][i]; /// i assume that first str is prefix \n\nprefix[len]='\\0';\n\nfor(i=1;i<strsSize;i++)\n    {\n        for( j=0;j<len;j++)\n\n            {\n                if(prefix[j]!=strs[i][j]) // run a lop in each str if i find a charter thats not common i replace the prefix with \\0; \n                {\n                    prefix[j]='\\0';\n                }\n            }\n            \n    }\n\nreturn prefix;\n}\n\n\nits ready to run , please try it in codeblocks or where ever and tell me what you think!!!"
                    },
                    {
                        "username": "hasan7",
                        "content": "For Input,  [\"c\",\"acc\",\"ccc\"]\\nmy answer is  \"c\" but it is expecting it to be \"\" \\nbut when the input in [\"c\"] , it is expecting \"c\" \\nThis is contradicting with each other and seems wrong??\\n"
                    },
                    {
                        "username": "coronelpoj",
                        "content": "Gonna highlight some of the parts of the problem to help you there buddy\\nWrite a function to find the longest COMMON PREFIX string AMONGST an array of strings.\\n\\nThis means for the [\"c\",\"acc\",\"ccc\"] input the answer is \"\" because \"acc\" did not have a common prefix among the remaining inputs.\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Is this a good enough solution to crack fang on this problem: \\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n        if len(strs)==2:\\n            ans =\"\"\\n            for i in range(0,min(len(strs[0]),len(strs[1]))):\\n                if strs[0][i]!=strs[1][i]:\\n                    return ans\\n                else:\\n                    ans+=strs[0][i]\\n            return ans\\n        ans = list(strs[0])\\n        for i in range(1,len(strs)):\\n            if len(ans)==0:\\n                break\\n            nex = \"\"\\n            for j in range(0,min(len(strs[i]),len(ans))):\\n                if ans[j]!=strs[i][j]:\\n                    break\\n                else:\\n                    nex+=ans[j]\\n            ans = list(nex)\\n        s = \"\"\\n        for i in ans:\\n            s+=i\\n        return s"
                    },
                    {
                        "username": "qwertypushkar123",
                        "content": "class Solution {\\npublic:\\n    // bool cmp(string a,string b){\\n    //     if(a.size()!=b.size()) return a.size()<b.size();\\n    //     else{\\n    //         return a<b;\\n    //     }\\n    // }\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end(),[&](string a,string b){\\n            if(a.size()!=b.size()) return a.size()<b.size();\\n        else{\\n            return a<b;\\n        }\\n        });\\n        string ans=strs[0];\\n        for(auto val:strs){\\n            for(int i=0;i<min(ans.size(),val.size());i++){\\n                if(ans[i]!=val[i]){\\n                    ans.erase(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis solution got accepted but cmp function (marked in comments) was throwing error so i used lambda function. can any one tell the mistake "
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Understand the problem statement properly. PREFIX means that something that comes before any word.SUFFIX is something that comes in last. Use of string functions make the question easier."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "if there is prefix then there is TRIE"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "why he is showing me this error \\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "Jyotiprakashchanda",
                        "content": "class Solution {\\n       public String common(String s1,String s2){\\n           //compare bitween two string\\n           StringBuilder b = new StringBuilder();\\n           //find min length betwiin two string it easy to compare\\n           int min=Math.min(s1.length(), s2.length());\\n           for(int i=0;i<min;i++){\\n               if(s1.charAt(i)==s2.charAt(i)){\\n                   b.append(s1.charAt(i));\\n               }else{\\n                   break;\\n               }\\n           }\\n           return b.toString();\\n       }\\n    public String longestCommonPrefix(String[] strs) {\\n     String prefix=strs[0];\\n     for(int i=0;i<strs.length;i++){\\n         prefix= common(prefix,strs[i]);// compare 1st index string with other string one by one\\n     }\\n     return prefix;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "pjain043",
                        "content": "The problem statment means, that starting from the first character in each string. what is the longest common substring/prefix.\\nHence [\"reflower\",\"flow\",\"flight\"] gives \"\"."
                    }
                ]
            },
            {
                "id": 1941834,
                "content": [
                    {
                        "username": "viveknagesh21",
                        "content": "Still giving wrong answer (submission not accepted), These are my testcase run results\n[\"flower\",\"flow\",\"flight\"]\n\"fl\"\n\"fl\"\n\n[\"dog\",\"racecar\",\"car\"]\n\"\"\n\"\"\nmy code is running with time complexity O(n^2), "
                    },
                    {
                        "username": "erenyeager1",
                        "content": " i solved the this ex and checked it in visualize compiler and codeblocks , it works fine with no errors or warnings , but here it shows me theres a problem soo whatts the deal?? if anyone could find out the problem i would be glad !!\nchar * longestCommonPrefix(char ** strs, int strsSize){\n\n\nint i,len=0,j=0,len2=0;\nfor(i=0;strs[0][i]!='\\0';i++) /// i start by finding the len of first str\n    len++;\n\nchar *prefix=malloc((len+1)*(sizeof(char))); //the max size of prefix could by the len of any str in the array\n\nfor(i=0;i<len;i++)\nprefix[i]=strs[0][i]; /// i assume that first str is prefix \n\nprefix[len]='\\0';\n\nfor(i=1;i<strsSize;i++)\n    {\n        for( j=0;j<len;j++)\n\n            {\n                if(prefix[j]!=strs[i][j]) // run a lop in each str if i find a charter thats not common i replace the prefix with \\0; \n                {\n                    prefix[j]='\\0';\n                }\n            }\n            \n    }\n\nreturn prefix;\n}\n\n\nits ready to run , please try it in codeblocks or where ever and tell me what you think!!!"
                    },
                    {
                        "username": "hasan7",
                        "content": "For Input,  [\"c\",\"acc\",\"ccc\"]\\nmy answer is  \"c\" but it is expecting it to be \"\" \\nbut when the input in [\"c\"] , it is expecting \"c\" \\nThis is contradicting with each other and seems wrong??\\n"
                    },
                    {
                        "username": "coronelpoj",
                        "content": "Gonna highlight some of the parts of the problem to help you there buddy\\nWrite a function to find the longest COMMON PREFIX string AMONGST an array of strings.\\n\\nThis means for the [\"c\",\"acc\",\"ccc\"] input the answer is \"\" because \"acc\" did not have a common prefix among the remaining inputs.\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Is this a good enough solution to crack fang on this problem: \\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n        if len(strs)==2:\\n            ans =\"\"\\n            for i in range(0,min(len(strs[0]),len(strs[1]))):\\n                if strs[0][i]!=strs[1][i]:\\n                    return ans\\n                else:\\n                    ans+=strs[0][i]\\n            return ans\\n        ans = list(strs[0])\\n        for i in range(1,len(strs)):\\n            if len(ans)==0:\\n                break\\n            nex = \"\"\\n            for j in range(0,min(len(strs[i]),len(ans))):\\n                if ans[j]!=strs[i][j]:\\n                    break\\n                else:\\n                    nex+=ans[j]\\n            ans = list(nex)\\n        s = \"\"\\n        for i in ans:\\n            s+=i\\n        return s"
                    },
                    {
                        "username": "qwertypushkar123",
                        "content": "class Solution {\\npublic:\\n    // bool cmp(string a,string b){\\n    //     if(a.size()!=b.size()) return a.size()<b.size();\\n    //     else{\\n    //         return a<b;\\n    //     }\\n    // }\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end(),[&](string a,string b){\\n            if(a.size()!=b.size()) return a.size()<b.size();\\n        else{\\n            return a<b;\\n        }\\n        });\\n        string ans=strs[0];\\n        for(auto val:strs){\\n            for(int i=0;i<min(ans.size(),val.size());i++){\\n                if(ans[i]!=val[i]){\\n                    ans.erase(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis solution got accepted but cmp function (marked in comments) was throwing error so i used lambda function. can any one tell the mistake "
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Understand the problem statement properly. PREFIX means that something that comes before any word.SUFFIX is something that comes in last. Use of string functions make the question easier."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "if there is prefix then there is TRIE"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "why he is showing me this error \\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "Jyotiprakashchanda",
                        "content": "class Solution {\\n       public String common(String s1,String s2){\\n           //compare bitween two string\\n           StringBuilder b = new StringBuilder();\\n           //find min length betwiin two string it easy to compare\\n           int min=Math.min(s1.length(), s2.length());\\n           for(int i=0;i<min;i++){\\n               if(s1.charAt(i)==s2.charAt(i)){\\n                   b.append(s1.charAt(i));\\n               }else{\\n                   break;\\n               }\\n           }\\n           return b.toString();\\n       }\\n    public String longestCommonPrefix(String[] strs) {\\n     String prefix=strs[0];\\n     for(int i=0;i<strs.length;i++){\\n         prefix= common(prefix,strs[i]);// compare 1st index string with other string one by one\\n     }\\n     return prefix;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "pjain043",
                        "content": "The problem statment means, that starting from the first character in each string. what is the longest common substring/prefix.\\nHence [\"reflower\",\"flow\",\"flight\"] gives \"\"."
                    }
                ]
            },
            {
                "id": 1941758,
                "content": [
                    {
                        "username": "viveknagesh21",
                        "content": "Still giving wrong answer (submission not accepted), These are my testcase run results\n[\"flower\",\"flow\",\"flight\"]\n\"fl\"\n\"fl\"\n\n[\"dog\",\"racecar\",\"car\"]\n\"\"\n\"\"\nmy code is running with time complexity O(n^2), "
                    },
                    {
                        "username": "erenyeager1",
                        "content": " i solved the this ex and checked it in visualize compiler and codeblocks , it works fine with no errors or warnings , but here it shows me theres a problem soo whatts the deal?? if anyone could find out the problem i would be glad !!\nchar * longestCommonPrefix(char ** strs, int strsSize){\n\n\nint i,len=0,j=0,len2=0;\nfor(i=0;strs[0][i]!='\\0';i++) /// i start by finding the len of first str\n    len++;\n\nchar *prefix=malloc((len+1)*(sizeof(char))); //the max size of prefix could by the len of any str in the array\n\nfor(i=0;i<len;i++)\nprefix[i]=strs[0][i]; /// i assume that first str is prefix \n\nprefix[len]='\\0';\n\nfor(i=1;i<strsSize;i++)\n    {\n        for( j=0;j<len;j++)\n\n            {\n                if(prefix[j]!=strs[i][j]) // run a lop in each str if i find a charter thats not common i replace the prefix with \\0; \n                {\n                    prefix[j]='\\0';\n                }\n            }\n            \n    }\n\nreturn prefix;\n}\n\n\nits ready to run , please try it in codeblocks or where ever and tell me what you think!!!"
                    },
                    {
                        "username": "hasan7",
                        "content": "For Input,  [\"c\",\"acc\",\"ccc\"]\\nmy answer is  \"c\" but it is expecting it to be \"\" \\nbut when the input in [\"c\"] , it is expecting \"c\" \\nThis is contradicting with each other and seems wrong??\\n"
                    },
                    {
                        "username": "coronelpoj",
                        "content": "Gonna highlight some of the parts of the problem to help you there buddy\\nWrite a function to find the longest COMMON PREFIX string AMONGST an array of strings.\\n\\nThis means for the [\"c\",\"acc\",\"ccc\"] input the answer is \"\" because \"acc\" did not have a common prefix among the remaining inputs.\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Is this a good enough solution to crack fang on this problem: \\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n        if len(strs)==2:\\n            ans =\"\"\\n            for i in range(0,min(len(strs[0]),len(strs[1]))):\\n                if strs[0][i]!=strs[1][i]:\\n                    return ans\\n                else:\\n                    ans+=strs[0][i]\\n            return ans\\n        ans = list(strs[0])\\n        for i in range(1,len(strs)):\\n            if len(ans)==0:\\n                break\\n            nex = \"\"\\n            for j in range(0,min(len(strs[i]),len(ans))):\\n                if ans[j]!=strs[i][j]:\\n                    break\\n                else:\\n                    nex+=ans[j]\\n            ans = list(nex)\\n        s = \"\"\\n        for i in ans:\\n            s+=i\\n        return s"
                    },
                    {
                        "username": "qwertypushkar123",
                        "content": "class Solution {\\npublic:\\n    // bool cmp(string a,string b){\\n    //     if(a.size()!=b.size()) return a.size()<b.size();\\n    //     else{\\n    //         return a<b;\\n    //     }\\n    // }\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end(),[&](string a,string b){\\n            if(a.size()!=b.size()) return a.size()<b.size();\\n        else{\\n            return a<b;\\n        }\\n        });\\n        string ans=strs[0];\\n        for(auto val:strs){\\n            for(int i=0;i<min(ans.size(),val.size());i++){\\n                if(ans[i]!=val[i]){\\n                    ans.erase(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis solution got accepted but cmp function (marked in comments) was throwing error so i used lambda function. can any one tell the mistake "
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Understand the problem statement properly. PREFIX means that something that comes before any word.SUFFIX is something that comes in last. Use of string functions make the question easier."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "if there is prefix then there is TRIE"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "why he is showing me this error \\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "Jyotiprakashchanda",
                        "content": "class Solution {\\n       public String common(String s1,String s2){\\n           //compare bitween two string\\n           StringBuilder b = new StringBuilder();\\n           //find min length betwiin two string it easy to compare\\n           int min=Math.min(s1.length(), s2.length());\\n           for(int i=0;i<min;i++){\\n               if(s1.charAt(i)==s2.charAt(i)){\\n                   b.append(s1.charAt(i));\\n               }else{\\n                   break;\\n               }\\n           }\\n           return b.toString();\\n       }\\n    public String longestCommonPrefix(String[] strs) {\\n     String prefix=strs[0];\\n     for(int i=0;i<strs.length;i++){\\n         prefix= common(prefix,strs[i]);// compare 1st index string with other string one by one\\n     }\\n     return prefix;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "pjain043",
                        "content": "The problem statment means, that starting from the first character in each string. what is the longest common substring/prefix.\\nHence [\"reflower\",\"flow\",\"flight\"] gives \"\"."
                    }
                ]
            },
            {
                "id": 1938741,
                "content": [
                    {
                        "username": "codez93",
                        "content": "loved this question, too many edge cases to handle.\\nIf your are using trie, little modifications are also needed."
                    },
                    {
                        "username": "PodliyRadja",
                        "content": "Why does my solution work with any test in PyCharm, but here it gives a different answer and because of this it does not count? [\"car\", \"cir\"] in PC gives \"cr\", but here gives \"c\", with the same code."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have done it using simple iteration but  i have a doubt as this question is considered in trie tags. but i am not getting how can i done it using trie."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "sorting might help"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>arr)\\n     {\\n         int N=arr.size();\\n    string ans=\"\";\\n     sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr[N-1].length();i++)\\n    {\\n        if(arr[0][i]==arr[N-1][i])\\n        {\\n            ans=ans+arr[0][i];\\n        }\\n        else\\n        {\\n            break;\\n        }\\n    }\\n    if(ans.length())\\n    return ans;\\n    return \"\";\\n}\\n    \\n};"
                    },
                    {
                        "username": "a098707730135",
                        "content": "I am a beginner in Python, and in this problem, I\\'ve got string index out of range so many times but  the result I ran in my CMD was correct which was: \"fl\". I don\\'t no how can I fix it.\\n\\nmy code is: \\n `res = strs[0]\\n  for s in strs:\\n      if res == s: continue\\n      for char in range(len(s)):\\n          if s[char] == res[char]: \\n              continue\\n          else:\\n              res = res[0:char]\\n              break\\n  return res`\\n\\nI am attempting to compare every character in every word and to keep the same characters, but it shows me that it is out of range in `if s[char] == res[char]:`. \\n\\nWhat\\'s going on? "
                    },
                    {
                        "username": "cubo142",
                        "content": "what determine the \"common\" ?? 5 common prefix word and 1 different word in a same array should return the prefix of the others 5 instead of returning \"\", atleast give a specific and details test case "
                    },
                    {
                        "username": "aadityesh",
                        "content": "sorting the words before comparison simplifies the task of finding the longest common prefix because it brings the potentially common prefix to the beginning of the sorted list."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "I used this first to calculate the minimum:\\nminimum = min(map(lambda x: len(x), strs))\\nthen when i changed to this:\\nminimum = len(strs[0])  \\nfor i in range(1,len(strs)):\\n    if (len(strs[i])< minimum):\\n        minimum = len(strs[i])\\nit\\'s waaaay faster, any reason why ?"
                    },
                    {
                        "username": "singhdushyant2989",
                        "content": "For Javascript people, focus should be on two string function methods :- first one is indexOf() and second one is substring."
                    }
                ]
            },
            {
                "id": 1936395,
                "content": [
                    {
                        "username": "codez93",
                        "content": "loved this question, too many edge cases to handle.\\nIf your are using trie, little modifications are also needed."
                    },
                    {
                        "username": "PodliyRadja",
                        "content": "Why does my solution work with any test in PyCharm, but here it gives a different answer and because of this it does not count? [\"car\", \"cir\"] in PC gives \"cr\", but here gives \"c\", with the same code."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have done it using simple iteration but  i have a doubt as this question is considered in trie tags. but i am not getting how can i done it using trie."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "sorting might help"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>arr)\\n     {\\n         int N=arr.size();\\n    string ans=\"\";\\n     sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr[N-1].length();i++)\\n    {\\n        if(arr[0][i]==arr[N-1][i])\\n        {\\n            ans=ans+arr[0][i];\\n        }\\n        else\\n        {\\n            break;\\n        }\\n    }\\n    if(ans.length())\\n    return ans;\\n    return \"\";\\n}\\n    \\n};"
                    },
                    {
                        "username": "a098707730135",
                        "content": "I am a beginner in Python, and in this problem, I\\'ve got string index out of range so many times but  the result I ran in my CMD was correct which was: \"fl\". I don\\'t no how can I fix it.\\n\\nmy code is: \\n `res = strs[0]\\n  for s in strs:\\n      if res == s: continue\\n      for char in range(len(s)):\\n          if s[char] == res[char]: \\n              continue\\n          else:\\n              res = res[0:char]\\n              break\\n  return res`\\n\\nI am attempting to compare every character in every word and to keep the same characters, but it shows me that it is out of range in `if s[char] == res[char]:`. \\n\\nWhat\\'s going on? "
                    },
                    {
                        "username": "cubo142",
                        "content": "what determine the \"common\" ?? 5 common prefix word and 1 different word in a same array should return the prefix of the others 5 instead of returning \"\", atleast give a specific and details test case "
                    },
                    {
                        "username": "aadityesh",
                        "content": "sorting the words before comparison simplifies the task of finding the longest common prefix because it brings the potentially common prefix to the beginning of the sorted list."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "I used this first to calculate the minimum:\\nminimum = min(map(lambda x: len(x), strs))\\nthen when i changed to this:\\nminimum = len(strs[0])  \\nfor i in range(1,len(strs)):\\n    if (len(strs[i])< minimum):\\n        minimum = len(strs[i])\\nit\\'s waaaay faster, any reason why ?"
                    },
                    {
                        "username": "singhdushyant2989",
                        "content": "For Javascript people, focus should be on two string function methods :- first one is indexOf() and second one is substring."
                    }
                ]
            },
            {
                "id": 1929205,
                "content": [
                    {
                        "username": "codez93",
                        "content": "loved this question, too many edge cases to handle.\\nIf your are using trie, little modifications are also needed."
                    },
                    {
                        "username": "PodliyRadja",
                        "content": "Why does my solution work with any test in PyCharm, but here it gives a different answer and because of this it does not count? [\"car\", \"cir\"] in PC gives \"cr\", but here gives \"c\", with the same code."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have done it using simple iteration but  i have a doubt as this question is considered in trie tags. but i am not getting how can i done it using trie."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "sorting might help"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>arr)\\n     {\\n         int N=arr.size();\\n    string ans=\"\";\\n     sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr[N-1].length();i++)\\n    {\\n        if(arr[0][i]==arr[N-1][i])\\n        {\\n            ans=ans+arr[0][i];\\n        }\\n        else\\n        {\\n            break;\\n        }\\n    }\\n    if(ans.length())\\n    return ans;\\n    return \"\";\\n}\\n    \\n};"
                    },
                    {
                        "username": "a098707730135",
                        "content": "I am a beginner in Python, and in this problem, I\\'ve got string index out of range so many times but  the result I ran in my CMD was correct which was: \"fl\". I don\\'t no how can I fix it.\\n\\nmy code is: \\n `res = strs[0]\\n  for s in strs:\\n      if res == s: continue\\n      for char in range(len(s)):\\n          if s[char] == res[char]: \\n              continue\\n          else:\\n              res = res[0:char]\\n              break\\n  return res`\\n\\nI am attempting to compare every character in every word and to keep the same characters, but it shows me that it is out of range in `if s[char] == res[char]:`. \\n\\nWhat\\'s going on? "
                    },
                    {
                        "username": "cubo142",
                        "content": "what determine the \"common\" ?? 5 common prefix word and 1 different word in a same array should return the prefix of the others 5 instead of returning \"\", atleast give a specific and details test case "
                    },
                    {
                        "username": "aadityesh",
                        "content": "sorting the words before comparison simplifies the task of finding the longest common prefix because it brings the potentially common prefix to the beginning of the sorted list."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "I used this first to calculate the minimum:\\nminimum = min(map(lambda x: len(x), strs))\\nthen when i changed to this:\\nminimum = len(strs[0])  \\nfor i in range(1,len(strs)):\\n    if (len(strs[i])< minimum):\\n        minimum = len(strs[i])\\nit\\'s waaaay faster, any reason why ?"
                    },
                    {
                        "username": "singhdushyant2989",
                        "content": "For Javascript people, focus should be on two string function methods :- first one is indexOf() and second one is substring."
                    }
                ]
            },
            {
                "id": 1928877,
                "content": [
                    {
                        "username": "codez93",
                        "content": "loved this question, too many edge cases to handle.\\nIf your are using trie, little modifications are also needed."
                    },
                    {
                        "username": "PodliyRadja",
                        "content": "Why does my solution work with any test in PyCharm, but here it gives a different answer and because of this it does not count? [\"car\", \"cir\"] in PC gives \"cr\", but here gives \"c\", with the same code."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have done it using simple iteration but  i have a doubt as this question is considered in trie tags. but i am not getting how can i done it using trie."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "sorting might help"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>arr)\\n     {\\n         int N=arr.size();\\n    string ans=\"\";\\n     sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr[N-1].length();i++)\\n    {\\n        if(arr[0][i]==arr[N-1][i])\\n        {\\n            ans=ans+arr[0][i];\\n        }\\n        else\\n        {\\n            break;\\n        }\\n    }\\n    if(ans.length())\\n    return ans;\\n    return \"\";\\n}\\n    \\n};"
                    },
                    {
                        "username": "a098707730135",
                        "content": "I am a beginner in Python, and in this problem, I\\'ve got string index out of range so many times but  the result I ran in my CMD was correct which was: \"fl\". I don\\'t no how can I fix it.\\n\\nmy code is: \\n `res = strs[0]\\n  for s in strs:\\n      if res == s: continue\\n      for char in range(len(s)):\\n          if s[char] == res[char]: \\n              continue\\n          else:\\n              res = res[0:char]\\n              break\\n  return res`\\n\\nI am attempting to compare every character in every word and to keep the same characters, but it shows me that it is out of range in `if s[char] == res[char]:`. \\n\\nWhat\\'s going on? "
                    },
                    {
                        "username": "cubo142",
                        "content": "what determine the \"common\" ?? 5 common prefix word and 1 different word in a same array should return the prefix of the others 5 instead of returning \"\", atleast give a specific and details test case "
                    },
                    {
                        "username": "aadityesh",
                        "content": "sorting the words before comparison simplifies the task of finding the longest common prefix because it brings the potentially common prefix to the beginning of the sorted list."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "I used this first to calculate the minimum:\\nminimum = min(map(lambda x: len(x), strs))\\nthen when i changed to this:\\nminimum = len(strs[0])  \\nfor i in range(1,len(strs)):\\n    if (len(strs[i])< minimum):\\n        minimum = len(strs[i])\\nit\\'s waaaay faster, any reason why ?"
                    },
                    {
                        "username": "singhdushyant2989",
                        "content": "For Javascript people, focus should be on two string function methods :- first one is indexOf() and second one is substring."
                    }
                ]
            },
            {
                "id": 1922509,
                "content": [
                    {
                        "username": "codez93",
                        "content": "loved this question, too many edge cases to handle.\\nIf your are using trie, little modifications are also needed."
                    },
                    {
                        "username": "PodliyRadja",
                        "content": "Why does my solution work with any test in PyCharm, but here it gives a different answer and because of this it does not count? [\"car\", \"cir\"] in PC gives \"cr\", but here gives \"c\", with the same code."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have done it using simple iteration but  i have a doubt as this question is considered in trie tags. but i am not getting how can i done it using trie."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "sorting might help"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>arr)\\n     {\\n         int N=arr.size();\\n    string ans=\"\";\\n     sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr[N-1].length();i++)\\n    {\\n        if(arr[0][i]==arr[N-1][i])\\n        {\\n            ans=ans+arr[0][i];\\n        }\\n        else\\n        {\\n            break;\\n        }\\n    }\\n    if(ans.length())\\n    return ans;\\n    return \"\";\\n}\\n    \\n};"
                    },
                    {
                        "username": "a098707730135",
                        "content": "I am a beginner in Python, and in this problem, I\\'ve got string index out of range so many times but  the result I ran in my CMD was correct which was: \"fl\". I don\\'t no how can I fix it.\\n\\nmy code is: \\n `res = strs[0]\\n  for s in strs:\\n      if res == s: continue\\n      for char in range(len(s)):\\n          if s[char] == res[char]: \\n              continue\\n          else:\\n              res = res[0:char]\\n              break\\n  return res`\\n\\nI am attempting to compare every character in every word and to keep the same characters, but it shows me that it is out of range in `if s[char] == res[char]:`. \\n\\nWhat\\'s going on? "
                    },
                    {
                        "username": "cubo142",
                        "content": "what determine the \"common\" ?? 5 common prefix word and 1 different word in a same array should return the prefix of the others 5 instead of returning \"\", atleast give a specific and details test case "
                    },
                    {
                        "username": "aadityesh",
                        "content": "sorting the words before comparison simplifies the task of finding the longest common prefix because it brings the potentially common prefix to the beginning of the sorted list."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "I used this first to calculate the minimum:\\nminimum = min(map(lambda x: len(x), strs))\\nthen when i changed to this:\\nminimum = len(strs[0])  \\nfor i in range(1,len(strs)):\\n    if (len(strs[i])< minimum):\\n        minimum = len(strs[i])\\nit\\'s waaaay faster, any reason why ?"
                    },
                    {
                        "username": "singhdushyant2989",
                        "content": "For Javascript people, focus should be on two string function methods :- first one is indexOf() and second one is substring."
                    }
                ]
            },
            {
                "id": 1921205,
                "content": [
                    {
                        "username": "codez93",
                        "content": "loved this question, too many edge cases to handle.\\nIf your are using trie, little modifications are also needed."
                    },
                    {
                        "username": "PodliyRadja",
                        "content": "Why does my solution work with any test in PyCharm, but here it gives a different answer and because of this it does not count? [\"car\", \"cir\"] in PC gives \"cr\", but here gives \"c\", with the same code."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have done it using simple iteration but  i have a doubt as this question is considered in trie tags. but i am not getting how can i done it using trie."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "sorting might help"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>arr)\\n     {\\n         int N=arr.size();\\n    string ans=\"\";\\n     sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr[N-1].length();i++)\\n    {\\n        if(arr[0][i]==arr[N-1][i])\\n        {\\n            ans=ans+arr[0][i];\\n        }\\n        else\\n        {\\n            break;\\n        }\\n    }\\n    if(ans.length())\\n    return ans;\\n    return \"\";\\n}\\n    \\n};"
                    },
                    {
                        "username": "a098707730135",
                        "content": "I am a beginner in Python, and in this problem, I\\'ve got string index out of range so many times but  the result I ran in my CMD was correct which was: \"fl\". I don\\'t no how can I fix it.\\n\\nmy code is: \\n `res = strs[0]\\n  for s in strs:\\n      if res == s: continue\\n      for char in range(len(s)):\\n          if s[char] == res[char]: \\n              continue\\n          else:\\n              res = res[0:char]\\n              break\\n  return res`\\n\\nI am attempting to compare every character in every word and to keep the same characters, but it shows me that it is out of range in `if s[char] == res[char]:`. \\n\\nWhat\\'s going on? "
                    },
                    {
                        "username": "cubo142",
                        "content": "what determine the \"common\" ?? 5 common prefix word and 1 different word in a same array should return the prefix of the others 5 instead of returning \"\", atleast give a specific and details test case "
                    },
                    {
                        "username": "aadityesh",
                        "content": "sorting the words before comparison simplifies the task of finding the longest common prefix because it brings the potentially common prefix to the beginning of the sorted list."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "I used this first to calculate the minimum:\\nminimum = min(map(lambda x: len(x), strs))\\nthen when i changed to this:\\nminimum = len(strs[0])  \\nfor i in range(1,len(strs)):\\n    if (len(strs[i])< minimum):\\n        minimum = len(strs[i])\\nit\\'s waaaay faster, any reason why ?"
                    },
                    {
                        "username": "singhdushyant2989",
                        "content": "For Javascript people, focus should be on two string function methods :- first one is indexOf() and second one is substring."
                    }
                ]
            },
            {
                "id": 1919733,
                "content": [
                    {
                        "username": "codez93",
                        "content": "loved this question, too many edge cases to handle.\\nIf your are using trie, little modifications are also needed."
                    },
                    {
                        "username": "PodliyRadja",
                        "content": "Why does my solution work with any test in PyCharm, but here it gives a different answer and because of this it does not count? [\"car\", \"cir\"] in PC gives \"cr\", but here gives \"c\", with the same code."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have done it using simple iteration but  i have a doubt as this question is considered in trie tags. but i am not getting how can i done it using trie."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "sorting might help"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>arr)\\n     {\\n         int N=arr.size();\\n    string ans=\"\";\\n     sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr[N-1].length();i++)\\n    {\\n        if(arr[0][i]==arr[N-1][i])\\n        {\\n            ans=ans+arr[0][i];\\n        }\\n        else\\n        {\\n            break;\\n        }\\n    }\\n    if(ans.length())\\n    return ans;\\n    return \"\";\\n}\\n    \\n};"
                    },
                    {
                        "username": "a098707730135",
                        "content": "I am a beginner in Python, and in this problem, I\\'ve got string index out of range so many times but  the result I ran in my CMD was correct which was: \"fl\". I don\\'t no how can I fix it.\\n\\nmy code is: \\n `res = strs[0]\\n  for s in strs:\\n      if res == s: continue\\n      for char in range(len(s)):\\n          if s[char] == res[char]: \\n              continue\\n          else:\\n              res = res[0:char]\\n              break\\n  return res`\\n\\nI am attempting to compare every character in every word and to keep the same characters, but it shows me that it is out of range in `if s[char] == res[char]:`. \\n\\nWhat\\'s going on? "
                    },
                    {
                        "username": "cubo142",
                        "content": "what determine the \"common\" ?? 5 common prefix word and 1 different word in a same array should return the prefix of the others 5 instead of returning \"\", atleast give a specific and details test case "
                    },
                    {
                        "username": "aadityesh",
                        "content": "sorting the words before comparison simplifies the task of finding the longest common prefix because it brings the potentially common prefix to the beginning of the sorted list."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "I used this first to calculate the minimum:\\nminimum = min(map(lambda x: len(x), strs))\\nthen when i changed to this:\\nminimum = len(strs[0])  \\nfor i in range(1,len(strs)):\\n    if (len(strs[i])< minimum):\\n        minimum = len(strs[i])\\nit\\'s waaaay faster, any reason why ?"
                    },
                    {
                        "username": "singhdushyant2989",
                        "content": "For Javascript people, focus should be on two string function methods :- first one is indexOf() and second one is substring."
                    }
                ]
            },
            {
                "id": 1919247,
                "content": [
                    {
                        "username": "codez93",
                        "content": "loved this question, too many edge cases to handle.\\nIf your are using trie, little modifications are also needed."
                    },
                    {
                        "username": "PodliyRadja",
                        "content": "Why does my solution work with any test in PyCharm, but here it gives a different answer and because of this it does not count? [\"car\", \"cir\"] in PC gives \"cr\", but here gives \"c\", with the same code."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have done it using simple iteration but  i have a doubt as this question is considered in trie tags. but i am not getting how can i done it using trie."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "sorting might help"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>arr)\\n     {\\n         int N=arr.size();\\n    string ans=\"\";\\n     sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr[N-1].length();i++)\\n    {\\n        if(arr[0][i]==arr[N-1][i])\\n        {\\n            ans=ans+arr[0][i];\\n        }\\n        else\\n        {\\n            break;\\n        }\\n    }\\n    if(ans.length())\\n    return ans;\\n    return \"\";\\n}\\n    \\n};"
                    },
                    {
                        "username": "a098707730135",
                        "content": "I am a beginner in Python, and in this problem, I\\'ve got string index out of range so many times but  the result I ran in my CMD was correct which was: \"fl\". I don\\'t no how can I fix it.\\n\\nmy code is: \\n `res = strs[0]\\n  for s in strs:\\n      if res == s: continue\\n      for char in range(len(s)):\\n          if s[char] == res[char]: \\n              continue\\n          else:\\n              res = res[0:char]\\n              break\\n  return res`\\n\\nI am attempting to compare every character in every word and to keep the same characters, but it shows me that it is out of range in `if s[char] == res[char]:`. \\n\\nWhat\\'s going on? "
                    },
                    {
                        "username": "cubo142",
                        "content": "what determine the \"common\" ?? 5 common prefix word and 1 different word in a same array should return the prefix of the others 5 instead of returning \"\", atleast give a specific and details test case "
                    },
                    {
                        "username": "aadityesh",
                        "content": "sorting the words before comparison simplifies the task of finding the longest common prefix because it brings the potentially common prefix to the beginning of the sorted list."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "I used this first to calculate the minimum:\\nminimum = min(map(lambda x: len(x), strs))\\nthen when i changed to this:\\nminimum = len(strs[0])  \\nfor i in range(1,len(strs)):\\n    if (len(strs[i])< minimum):\\n        minimum = len(strs[i])\\nit\\'s waaaay faster, any reason why ?"
                    },
                    {
                        "username": "singhdushyant2989",
                        "content": "For Javascript people, focus should be on two string function methods :- first one is indexOf() and second one is substring."
                    }
                ]
            },
            {
                "id": 1918369,
                "content": [
                    {
                        "username": "codez93",
                        "content": "loved this question, too many edge cases to handle.\\nIf your are using trie, little modifications are also needed."
                    },
                    {
                        "username": "PodliyRadja",
                        "content": "Why does my solution work with any test in PyCharm, but here it gives a different answer and because of this it does not count? [\"car\", \"cir\"] in PC gives \"cr\", but here gives \"c\", with the same code."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have done it using simple iteration but  i have a doubt as this question is considered in trie tags. but i am not getting how can i done it using trie."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "sorting might help"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>arr)\\n     {\\n         int N=arr.size();\\n    string ans=\"\";\\n     sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr[N-1].length();i++)\\n    {\\n        if(arr[0][i]==arr[N-1][i])\\n        {\\n            ans=ans+arr[0][i];\\n        }\\n        else\\n        {\\n            break;\\n        }\\n    }\\n    if(ans.length())\\n    return ans;\\n    return \"\";\\n}\\n    \\n};"
                    },
                    {
                        "username": "a098707730135",
                        "content": "I am a beginner in Python, and in this problem, I\\'ve got string index out of range so many times but  the result I ran in my CMD was correct which was: \"fl\". I don\\'t no how can I fix it.\\n\\nmy code is: \\n `res = strs[0]\\n  for s in strs:\\n      if res == s: continue\\n      for char in range(len(s)):\\n          if s[char] == res[char]: \\n              continue\\n          else:\\n              res = res[0:char]\\n              break\\n  return res`\\n\\nI am attempting to compare every character in every word and to keep the same characters, but it shows me that it is out of range in `if s[char] == res[char]:`. \\n\\nWhat\\'s going on? "
                    },
                    {
                        "username": "cubo142",
                        "content": "what determine the \"common\" ?? 5 common prefix word and 1 different word in a same array should return the prefix of the others 5 instead of returning \"\", atleast give a specific and details test case "
                    },
                    {
                        "username": "aadityesh",
                        "content": "sorting the words before comparison simplifies the task of finding the longest common prefix because it brings the potentially common prefix to the beginning of the sorted list."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "I used this first to calculate the minimum:\\nminimum = min(map(lambda x: len(x), strs))\\nthen when i changed to this:\\nminimum = len(strs[0])  \\nfor i in range(1,len(strs)):\\n    if (len(strs[i])< minimum):\\n        minimum = len(strs[i])\\nit\\'s waaaay faster, any reason why ?"
                    },
                    {
                        "username": "singhdushyant2989",
                        "content": "For Javascript people, focus should be on two string function methods :- first one is indexOf() and second one is substring."
                    }
                ]
            },
            {
                "id": 1918128,
                "content": [
                    {
                        "username": "codez93",
                        "content": "loved this question, too many edge cases to handle.\\nIf your are using trie, little modifications are also needed."
                    },
                    {
                        "username": "PodliyRadja",
                        "content": "Why does my solution work with any test in PyCharm, but here it gives a different answer and because of this it does not count? [\"car\", \"cir\"] in PC gives \"cr\", but here gives \"c\", with the same code."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have done it using simple iteration but  i have a doubt as this question is considered in trie tags. but i am not getting how can i done it using trie."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "sorting might help"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>arr)\\n     {\\n         int N=arr.size();\\n    string ans=\"\";\\n     sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr[N-1].length();i++)\\n    {\\n        if(arr[0][i]==arr[N-1][i])\\n        {\\n            ans=ans+arr[0][i];\\n        }\\n        else\\n        {\\n            break;\\n        }\\n    }\\n    if(ans.length())\\n    return ans;\\n    return \"\";\\n}\\n    \\n};"
                    },
                    {
                        "username": "a098707730135",
                        "content": "I am a beginner in Python, and in this problem, I\\'ve got string index out of range so many times but  the result I ran in my CMD was correct which was: \"fl\". I don\\'t no how can I fix it.\\n\\nmy code is: \\n `res = strs[0]\\n  for s in strs:\\n      if res == s: continue\\n      for char in range(len(s)):\\n          if s[char] == res[char]: \\n              continue\\n          else:\\n              res = res[0:char]\\n              break\\n  return res`\\n\\nI am attempting to compare every character in every word and to keep the same characters, but it shows me that it is out of range in `if s[char] == res[char]:`. \\n\\nWhat\\'s going on? "
                    },
                    {
                        "username": "cubo142",
                        "content": "what determine the \"common\" ?? 5 common prefix word and 1 different word in a same array should return the prefix of the others 5 instead of returning \"\", atleast give a specific and details test case "
                    },
                    {
                        "username": "aadityesh",
                        "content": "sorting the words before comparison simplifies the task of finding the longest common prefix because it brings the potentially common prefix to the beginning of the sorted list."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "I used this first to calculate the minimum:\\nminimum = min(map(lambda x: len(x), strs))\\nthen when i changed to this:\\nminimum = len(strs[0])  \\nfor i in range(1,len(strs)):\\n    if (len(strs[i])< minimum):\\n        minimum = len(strs[i])\\nit\\'s waaaay faster, any reason why ?"
                    },
                    {
                        "username": "singhdushyant2989",
                        "content": "For Javascript people, focus should be on two string function methods :- first one is indexOf() and second one is substring."
                    }
                ]
            },
            {
                "id": 1906633,
                "content": [
                    {
                        "username": "keithdtyler",
                        "content": "Oh, I started attacking this problem all wrong. I was trying to find the longest substring shared by more than one string in the list. So for example the first test would have returned \"flow\" since both \"flow\" and \"flower\" contain that substring.\\nNo, I\\'m supposed to find the common substring that *all* strings in the set have."
                    },
                    {
                        "username": "tadarshtiwari1996",
                        "content": "there is  Use case in this Question \\nuser Case is\\nInput=[\"a\",\"a\",\"b\"]\\nso with this Input Longest Prefix is \"a\"\\nbut in the Expected of this use case Given blank String \" \"\\n\\nWhy it is Expected like that can any one please explain \\n\\n"
                    },
                    {
                        "username": "taolitony",
                        "content": "Help!!!\\n\\nMy code did well for the test cases, but got a Runtime Error when submitted. Can anyone help me understand why the Runtime Error happened? Thanks. See below for the error and the codes:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1513, java.base/java.lang.String.charAt\\n  at line 52, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        String result = \"\";\\n        int preNum = 0;\\n\\n        Arrays.sort(strs);\\n\\n        //check if the strings are legal\\n        for (String word: strs) {\\n            boolean illegal = false;\\n            if (word.length() > 200){\\n                illegal = true;\\n            } else {\\n                for (int i = 0; i < word.length(); i++){\\n                    if (word.charAt(i) >= \\'A\\' && word.charAt(i) <= \\'Z\\'){\\n                        illegal = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (illegal){\\n                return  result;\\n            }\\n        }\\n        \\n        for (int i = 0; i < strs.length; i++) {\\n\\n            boolean flag = true;\\n\\n            for (int j = 1; j < strs.length; j++) {\\n\\n                if (strs[j].charAt(i) != strs[0].charAt(i)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if (flag){\\n                preNum += 1;\\n            }else {\\n                break;\\n            }\\n\\n        }\\n\\n        if (preNum == 0){//line 48\\n            return result;\\n        }else {\\n            for (int i = 0; i < preNum; i++) {\\n                result += strs[0].charAt(i); //line 52\\n            }\\n            return result;//line 54\\n        }\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "Longest common prefix amongst ALL THE STRING ITEMS present in the array. All the string items in the array should have a common prefix."
                    },
                    {
                        "username": "Antodominic_123",
                        "content": "this solution of the Problem is easy to understand And if it //is easy  give one thumps up bro\\n\\n\\nString find = strs[0];\\n\\t\\tboolean data = false;\\n\\t\\tString result = \"\";\\n\\t\\t\\n\\t\\tfor(int i=0; i<find.length();i++)\\n\\t\\t{\\n\\t\\t\\tString process = find.substring(0,(i+1));\\n\\t\\t\\tfor(String st : strs)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(st.startsWith(process))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(data)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult = process;\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\nif(result.length()>0)\\n{\\n\\treturn result;\\n}\\nelse\\n{\\n\\treturn \"\";\\n}"
                    },
                    {
                        "username": "TheStarSlayer",
                        "content": " `char * longestCommonPrefix(char ** strs, int strsSize)\\n  {\\n    int i,j,k = 0;\\n    int *count = malloc(1 * sizeof(int));\\n    int *temp1 = malloc(1 * sizeof(int));\\n    *count = 201;\\n\\n    for (i = 0; i < strsSize; i++)\\n    {\\n        for (j = 0; strs[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            continue;\\n        }\\n        *temp1 = j+1;\\n        if (*temp1 < *count)\\n        {\\n            *count = *temp1;\\n        }\\n    }\\n\\n    int size = *count;\\n    free(count);\\n    free(temp1);\\n\\n    char *str = malloc((size+1)*sizeof(char));\\n    char temp;\\n    if (str == NULL)\\n    {\\n        printf(\"foo\");\\n        return NULL;\\n    }\\n    else\\n    {\\n        for (i = 0, j = 0; i < strsSize; i++)\\n        {\\n            temp = strs[0][j];\\n\\n            if (temp == strs[i][j])                     \\n            {\\n                str[k] = strs[i][j];\\n                if (i == strsSize - 1)\\n                {\\n                    j++;\\n                    k++;\\n                    i = -1;\\n                }\\n                continue;\\n            }\\n            else\\n            {\\n                str[k] = \\'\\\\0\\';\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n}`\\n\\nI was able to solve the testcases but I could not submit it as it throws a heap buffer overflow error. Can someone help me?"
                    },
                    {
                        "username": "rahilsheikh155",
                        "content": "class Solution {\\npublic String longestCommonPrefix(String[] strs) {\\nint size=strs.length;\\nif(size==0)\\n{\\nreturn \"\";\\n}\\nif(size==1)\\n{\\nreturn strs[0];\\n}\\nArrays.sort(strs);\\nint end=Math.min(strs[0].length(),strs[size-1].length());\\nint i=0;\\nwhile(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\ni++;\\nString pre=strs[0].substring(0,i);\\nreturn pre;\\n\\n}\\n}"
                    },
                    {
                        "username": "alexsoyes",
                        "content": "strs =  [\"reflower\",\"flow\",\"flight\"]\\n\\nmy output is \"fl\", but excpeted if \"\"? :O"
                    },
                    {
                        "username": "wowerzero",
                        "content": "The second example is weird: IMHO, [\"flower\",\"flow\",\"dog\"] = \"\" is much better as example"
                    },
                    {
                        "username": "fmv2113",
                        "content": "Hi! When I run this code I get time limit exceeded. Can someone explain why? \\n\\nThought process: if I keep a count of the similarities between the first string and every successive string, then I can take the minimum similarity called min, and make the resulting prefix strs[0].substring(0, min); I guess where I could be being extra is through my use of a binary heap to keep the finding min operation to O(1). Please reply with feedback!\\n\\nimport java.util.*;\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if(strs.length==0){\\n            return null;\\n        }\\n\\n\\n        int leftPointer=0;\\n        int rightPointer=0;\\n        int count=0;\\n        PriorityQueue<Integer> minSim = new PriorityQueue<Integer>();\\n\\n        for(int i=1; i<strs.length; i++){ //start from element at index 1 in string array\\n            count=0;\\n            leftPointer=0;\\n            rightPointer=0;\\n            while(leftPointer<strs[0].length() && rightPointer<strs[i].length()){ \\n                if(strs[0].charAt(leftPointer)==strs[i].charAt(rightPointer)){\\n                    count++;\\n                    leftPointer++;\\n                    rightPointer++;\\n                }\\n            }\\n            \\n            minSim.add(count);\\n\\n        }\\n\\n        /*\\n        the minimum similarity count will tell us up to what index we should return\\n        */\\n        int min=0;\\n        if(minSim.peek()!=0){\\n           min = minSim.peek(); \\n        }\\n        String result = strs[0].substring(0,min);\\n\\n        return result;\\n\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1905998,
                "content": [
                    {
                        "username": "keithdtyler",
                        "content": "Oh, I started attacking this problem all wrong. I was trying to find the longest substring shared by more than one string in the list. So for example the first test would have returned \"flow\" since both \"flow\" and \"flower\" contain that substring.\\nNo, I\\'m supposed to find the common substring that *all* strings in the set have."
                    },
                    {
                        "username": "tadarshtiwari1996",
                        "content": "there is  Use case in this Question \\nuser Case is\\nInput=[\"a\",\"a\",\"b\"]\\nso with this Input Longest Prefix is \"a\"\\nbut in the Expected of this use case Given blank String \" \"\\n\\nWhy it is Expected like that can any one please explain \\n\\n"
                    },
                    {
                        "username": "taolitony",
                        "content": "Help!!!\\n\\nMy code did well for the test cases, but got a Runtime Error when submitted. Can anyone help me understand why the Runtime Error happened? Thanks. See below for the error and the codes:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1513, java.base/java.lang.String.charAt\\n  at line 52, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        String result = \"\";\\n        int preNum = 0;\\n\\n        Arrays.sort(strs);\\n\\n        //check if the strings are legal\\n        for (String word: strs) {\\n            boolean illegal = false;\\n            if (word.length() > 200){\\n                illegal = true;\\n            } else {\\n                for (int i = 0; i < word.length(); i++){\\n                    if (word.charAt(i) >= \\'A\\' && word.charAt(i) <= \\'Z\\'){\\n                        illegal = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (illegal){\\n                return  result;\\n            }\\n        }\\n        \\n        for (int i = 0; i < strs.length; i++) {\\n\\n            boolean flag = true;\\n\\n            for (int j = 1; j < strs.length; j++) {\\n\\n                if (strs[j].charAt(i) != strs[0].charAt(i)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if (flag){\\n                preNum += 1;\\n            }else {\\n                break;\\n            }\\n\\n        }\\n\\n        if (preNum == 0){//line 48\\n            return result;\\n        }else {\\n            for (int i = 0; i < preNum; i++) {\\n                result += strs[0].charAt(i); //line 52\\n            }\\n            return result;//line 54\\n        }\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "Longest common prefix amongst ALL THE STRING ITEMS present in the array. All the string items in the array should have a common prefix."
                    },
                    {
                        "username": "Antodominic_123",
                        "content": "this solution of the Problem is easy to understand And if it //is easy  give one thumps up bro\\n\\n\\nString find = strs[0];\\n\\t\\tboolean data = false;\\n\\t\\tString result = \"\";\\n\\t\\t\\n\\t\\tfor(int i=0; i<find.length();i++)\\n\\t\\t{\\n\\t\\t\\tString process = find.substring(0,(i+1));\\n\\t\\t\\tfor(String st : strs)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(st.startsWith(process))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(data)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult = process;\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\nif(result.length()>0)\\n{\\n\\treturn result;\\n}\\nelse\\n{\\n\\treturn \"\";\\n}"
                    },
                    {
                        "username": "TheStarSlayer",
                        "content": " `char * longestCommonPrefix(char ** strs, int strsSize)\\n  {\\n    int i,j,k = 0;\\n    int *count = malloc(1 * sizeof(int));\\n    int *temp1 = malloc(1 * sizeof(int));\\n    *count = 201;\\n\\n    for (i = 0; i < strsSize; i++)\\n    {\\n        for (j = 0; strs[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            continue;\\n        }\\n        *temp1 = j+1;\\n        if (*temp1 < *count)\\n        {\\n            *count = *temp1;\\n        }\\n    }\\n\\n    int size = *count;\\n    free(count);\\n    free(temp1);\\n\\n    char *str = malloc((size+1)*sizeof(char));\\n    char temp;\\n    if (str == NULL)\\n    {\\n        printf(\"foo\");\\n        return NULL;\\n    }\\n    else\\n    {\\n        for (i = 0, j = 0; i < strsSize; i++)\\n        {\\n            temp = strs[0][j];\\n\\n            if (temp == strs[i][j])                     \\n            {\\n                str[k] = strs[i][j];\\n                if (i == strsSize - 1)\\n                {\\n                    j++;\\n                    k++;\\n                    i = -1;\\n                }\\n                continue;\\n            }\\n            else\\n            {\\n                str[k] = \\'\\\\0\\';\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n}`\\n\\nI was able to solve the testcases but I could not submit it as it throws a heap buffer overflow error. Can someone help me?"
                    },
                    {
                        "username": "rahilsheikh155",
                        "content": "class Solution {\\npublic String longestCommonPrefix(String[] strs) {\\nint size=strs.length;\\nif(size==0)\\n{\\nreturn \"\";\\n}\\nif(size==1)\\n{\\nreturn strs[0];\\n}\\nArrays.sort(strs);\\nint end=Math.min(strs[0].length(),strs[size-1].length());\\nint i=0;\\nwhile(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\ni++;\\nString pre=strs[0].substring(0,i);\\nreturn pre;\\n\\n}\\n}"
                    },
                    {
                        "username": "alexsoyes",
                        "content": "strs =  [\"reflower\",\"flow\",\"flight\"]\\n\\nmy output is \"fl\", but excpeted if \"\"? :O"
                    },
                    {
                        "username": "wowerzero",
                        "content": "The second example is weird: IMHO, [\"flower\",\"flow\",\"dog\"] = \"\" is much better as example"
                    },
                    {
                        "username": "fmv2113",
                        "content": "Hi! When I run this code I get time limit exceeded. Can someone explain why? \\n\\nThought process: if I keep a count of the similarities between the first string and every successive string, then I can take the minimum similarity called min, and make the resulting prefix strs[0].substring(0, min); I guess where I could be being extra is through my use of a binary heap to keep the finding min operation to O(1). Please reply with feedback!\\n\\nimport java.util.*;\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if(strs.length==0){\\n            return null;\\n        }\\n\\n\\n        int leftPointer=0;\\n        int rightPointer=0;\\n        int count=0;\\n        PriorityQueue<Integer> minSim = new PriorityQueue<Integer>();\\n\\n        for(int i=1; i<strs.length; i++){ //start from element at index 1 in string array\\n            count=0;\\n            leftPointer=0;\\n            rightPointer=0;\\n            while(leftPointer<strs[0].length() && rightPointer<strs[i].length()){ \\n                if(strs[0].charAt(leftPointer)==strs[i].charAt(rightPointer)){\\n                    count++;\\n                    leftPointer++;\\n                    rightPointer++;\\n                }\\n            }\\n            \\n            minSim.add(count);\\n\\n        }\\n\\n        /*\\n        the minimum similarity count will tell us up to what index we should return\\n        */\\n        int min=0;\\n        if(minSim.peek()!=0){\\n           min = minSim.peek(); \\n        }\\n        String result = strs[0].substring(0,min);\\n\\n        return result;\\n\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1905748,
                "content": [
                    {
                        "username": "keithdtyler",
                        "content": "Oh, I started attacking this problem all wrong. I was trying to find the longest substring shared by more than one string in the list. So for example the first test would have returned \"flow\" since both \"flow\" and \"flower\" contain that substring.\\nNo, I\\'m supposed to find the common substring that *all* strings in the set have."
                    },
                    {
                        "username": "tadarshtiwari1996",
                        "content": "there is  Use case in this Question \\nuser Case is\\nInput=[\"a\",\"a\",\"b\"]\\nso with this Input Longest Prefix is \"a\"\\nbut in the Expected of this use case Given blank String \" \"\\n\\nWhy it is Expected like that can any one please explain \\n\\n"
                    },
                    {
                        "username": "taolitony",
                        "content": "Help!!!\\n\\nMy code did well for the test cases, but got a Runtime Error when submitted. Can anyone help me understand why the Runtime Error happened? Thanks. See below for the error and the codes:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1513, java.base/java.lang.String.charAt\\n  at line 52, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        String result = \"\";\\n        int preNum = 0;\\n\\n        Arrays.sort(strs);\\n\\n        //check if the strings are legal\\n        for (String word: strs) {\\n            boolean illegal = false;\\n            if (word.length() > 200){\\n                illegal = true;\\n            } else {\\n                for (int i = 0; i < word.length(); i++){\\n                    if (word.charAt(i) >= \\'A\\' && word.charAt(i) <= \\'Z\\'){\\n                        illegal = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (illegal){\\n                return  result;\\n            }\\n        }\\n        \\n        for (int i = 0; i < strs.length; i++) {\\n\\n            boolean flag = true;\\n\\n            for (int j = 1; j < strs.length; j++) {\\n\\n                if (strs[j].charAt(i) != strs[0].charAt(i)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if (flag){\\n                preNum += 1;\\n            }else {\\n                break;\\n            }\\n\\n        }\\n\\n        if (preNum == 0){//line 48\\n            return result;\\n        }else {\\n            for (int i = 0; i < preNum; i++) {\\n                result += strs[0].charAt(i); //line 52\\n            }\\n            return result;//line 54\\n        }\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "Longest common prefix amongst ALL THE STRING ITEMS present in the array. All the string items in the array should have a common prefix."
                    },
                    {
                        "username": "Antodominic_123",
                        "content": "this solution of the Problem is easy to understand And if it //is easy  give one thumps up bro\\n\\n\\nString find = strs[0];\\n\\t\\tboolean data = false;\\n\\t\\tString result = \"\";\\n\\t\\t\\n\\t\\tfor(int i=0; i<find.length();i++)\\n\\t\\t{\\n\\t\\t\\tString process = find.substring(0,(i+1));\\n\\t\\t\\tfor(String st : strs)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(st.startsWith(process))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(data)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult = process;\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\nif(result.length()>0)\\n{\\n\\treturn result;\\n}\\nelse\\n{\\n\\treturn \"\";\\n}"
                    },
                    {
                        "username": "TheStarSlayer",
                        "content": " `char * longestCommonPrefix(char ** strs, int strsSize)\\n  {\\n    int i,j,k = 0;\\n    int *count = malloc(1 * sizeof(int));\\n    int *temp1 = malloc(1 * sizeof(int));\\n    *count = 201;\\n\\n    for (i = 0; i < strsSize; i++)\\n    {\\n        for (j = 0; strs[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            continue;\\n        }\\n        *temp1 = j+1;\\n        if (*temp1 < *count)\\n        {\\n            *count = *temp1;\\n        }\\n    }\\n\\n    int size = *count;\\n    free(count);\\n    free(temp1);\\n\\n    char *str = malloc((size+1)*sizeof(char));\\n    char temp;\\n    if (str == NULL)\\n    {\\n        printf(\"foo\");\\n        return NULL;\\n    }\\n    else\\n    {\\n        for (i = 0, j = 0; i < strsSize; i++)\\n        {\\n            temp = strs[0][j];\\n\\n            if (temp == strs[i][j])                     \\n            {\\n                str[k] = strs[i][j];\\n                if (i == strsSize - 1)\\n                {\\n                    j++;\\n                    k++;\\n                    i = -1;\\n                }\\n                continue;\\n            }\\n            else\\n            {\\n                str[k] = \\'\\\\0\\';\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n}`\\n\\nI was able to solve the testcases but I could not submit it as it throws a heap buffer overflow error. Can someone help me?"
                    },
                    {
                        "username": "rahilsheikh155",
                        "content": "class Solution {\\npublic String longestCommonPrefix(String[] strs) {\\nint size=strs.length;\\nif(size==0)\\n{\\nreturn \"\";\\n}\\nif(size==1)\\n{\\nreturn strs[0];\\n}\\nArrays.sort(strs);\\nint end=Math.min(strs[0].length(),strs[size-1].length());\\nint i=0;\\nwhile(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\ni++;\\nString pre=strs[0].substring(0,i);\\nreturn pre;\\n\\n}\\n}"
                    },
                    {
                        "username": "alexsoyes",
                        "content": "strs =  [\"reflower\",\"flow\",\"flight\"]\\n\\nmy output is \"fl\", but excpeted if \"\"? :O"
                    },
                    {
                        "username": "wowerzero",
                        "content": "The second example is weird: IMHO, [\"flower\",\"flow\",\"dog\"] = \"\" is much better as example"
                    },
                    {
                        "username": "fmv2113",
                        "content": "Hi! When I run this code I get time limit exceeded. Can someone explain why? \\n\\nThought process: if I keep a count of the similarities between the first string and every successive string, then I can take the minimum similarity called min, and make the resulting prefix strs[0].substring(0, min); I guess where I could be being extra is through my use of a binary heap to keep the finding min operation to O(1). Please reply with feedback!\\n\\nimport java.util.*;\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if(strs.length==0){\\n            return null;\\n        }\\n\\n\\n        int leftPointer=0;\\n        int rightPointer=0;\\n        int count=0;\\n        PriorityQueue<Integer> minSim = new PriorityQueue<Integer>();\\n\\n        for(int i=1; i<strs.length; i++){ //start from element at index 1 in string array\\n            count=0;\\n            leftPointer=0;\\n            rightPointer=0;\\n            while(leftPointer<strs[0].length() && rightPointer<strs[i].length()){ \\n                if(strs[0].charAt(leftPointer)==strs[i].charAt(rightPointer)){\\n                    count++;\\n                    leftPointer++;\\n                    rightPointer++;\\n                }\\n            }\\n            \\n            minSim.add(count);\\n\\n        }\\n\\n        /*\\n        the minimum similarity count will tell us up to what index we should return\\n        */\\n        int min=0;\\n        if(minSim.peek()!=0){\\n           min = minSim.peek(); \\n        }\\n        String result = strs[0].substring(0,min);\\n\\n        return result;\\n\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1903337,
                "content": [
                    {
                        "username": "keithdtyler",
                        "content": "Oh, I started attacking this problem all wrong. I was trying to find the longest substring shared by more than one string in the list. So for example the first test would have returned \"flow\" since both \"flow\" and \"flower\" contain that substring.\\nNo, I\\'m supposed to find the common substring that *all* strings in the set have."
                    },
                    {
                        "username": "tadarshtiwari1996",
                        "content": "there is  Use case in this Question \\nuser Case is\\nInput=[\"a\",\"a\",\"b\"]\\nso with this Input Longest Prefix is \"a\"\\nbut in the Expected of this use case Given blank String \" \"\\n\\nWhy it is Expected like that can any one please explain \\n\\n"
                    },
                    {
                        "username": "taolitony",
                        "content": "Help!!!\\n\\nMy code did well for the test cases, but got a Runtime Error when submitted. Can anyone help me understand why the Runtime Error happened? Thanks. See below for the error and the codes:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1513, java.base/java.lang.String.charAt\\n  at line 52, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        String result = \"\";\\n        int preNum = 0;\\n\\n        Arrays.sort(strs);\\n\\n        //check if the strings are legal\\n        for (String word: strs) {\\n            boolean illegal = false;\\n            if (word.length() > 200){\\n                illegal = true;\\n            } else {\\n                for (int i = 0; i < word.length(); i++){\\n                    if (word.charAt(i) >= \\'A\\' && word.charAt(i) <= \\'Z\\'){\\n                        illegal = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (illegal){\\n                return  result;\\n            }\\n        }\\n        \\n        for (int i = 0; i < strs.length; i++) {\\n\\n            boolean flag = true;\\n\\n            for (int j = 1; j < strs.length; j++) {\\n\\n                if (strs[j].charAt(i) != strs[0].charAt(i)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if (flag){\\n                preNum += 1;\\n            }else {\\n                break;\\n            }\\n\\n        }\\n\\n        if (preNum == 0){//line 48\\n            return result;\\n        }else {\\n            for (int i = 0; i < preNum; i++) {\\n                result += strs[0].charAt(i); //line 52\\n            }\\n            return result;//line 54\\n        }\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "Longest common prefix amongst ALL THE STRING ITEMS present in the array. All the string items in the array should have a common prefix."
                    },
                    {
                        "username": "Antodominic_123",
                        "content": "this solution of the Problem is easy to understand And if it //is easy  give one thumps up bro\\n\\n\\nString find = strs[0];\\n\\t\\tboolean data = false;\\n\\t\\tString result = \"\";\\n\\t\\t\\n\\t\\tfor(int i=0; i<find.length();i++)\\n\\t\\t{\\n\\t\\t\\tString process = find.substring(0,(i+1));\\n\\t\\t\\tfor(String st : strs)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(st.startsWith(process))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(data)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult = process;\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\nif(result.length()>0)\\n{\\n\\treturn result;\\n}\\nelse\\n{\\n\\treturn \"\";\\n}"
                    },
                    {
                        "username": "TheStarSlayer",
                        "content": " `char * longestCommonPrefix(char ** strs, int strsSize)\\n  {\\n    int i,j,k = 0;\\n    int *count = malloc(1 * sizeof(int));\\n    int *temp1 = malloc(1 * sizeof(int));\\n    *count = 201;\\n\\n    for (i = 0; i < strsSize; i++)\\n    {\\n        for (j = 0; strs[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            continue;\\n        }\\n        *temp1 = j+1;\\n        if (*temp1 < *count)\\n        {\\n            *count = *temp1;\\n        }\\n    }\\n\\n    int size = *count;\\n    free(count);\\n    free(temp1);\\n\\n    char *str = malloc((size+1)*sizeof(char));\\n    char temp;\\n    if (str == NULL)\\n    {\\n        printf(\"foo\");\\n        return NULL;\\n    }\\n    else\\n    {\\n        for (i = 0, j = 0; i < strsSize; i++)\\n        {\\n            temp = strs[0][j];\\n\\n            if (temp == strs[i][j])                     \\n            {\\n                str[k] = strs[i][j];\\n                if (i == strsSize - 1)\\n                {\\n                    j++;\\n                    k++;\\n                    i = -1;\\n                }\\n                continue;\\n            }\\n            else\\n            {\\n                str[k] = \\'\\\\0\\';\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n}`\\n\\nI was able to solve the testcases but I could not submit it as it throws a heap buffer overflow error. Can someone help me?"
                    },
                    {
                        "username": "rahilsheikh155",
                        "content": "class Solution {\\npublic String longestCommonPrefix(String[] strs) {\\nint size=strs.length;\\nif(size==0)\\n{\\nreturn \"\";\\n}\\nif(size==1)\\n{\\nreturn strs[0];\\n}\\nArrays.sort(strs);\\nint end=Math.min(strs[0].length(),strs[size-1].length());\\nint i=0;\\nwhile(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\ni++;\\nString pre=strs[0].substring(0,i);\\nreturn pre;\\n\\n}\\n}"
                    },
                    {
                        "username": "alexsoyes",
                        "content": "strs =  [\"reflower\",\"flow\",\"flight\"]\\n\\nmy output is \"fl\", but excpeted if \"\"? :O"
                    },
                    {
                        "username": "wowerzero",
                        "content": "The second example is weird: IMHO, [\"flower\",\"flow\",\"dog\"] = \"\" is much better as example"
                    },
                    {
                        "username": "fmv2113",
                        "content": "Hi! When I run this code I get time limit exceeded. Can someone explain why? \\n\\nThought process: if I keep a count of the similarities between the first string and every successive string, then I can take the minimum similarity called min, and make the resulting prefix strs[0].substring(0, min); I guess where I could be being extra is through my use of a binary heap to keep the finding min operation to O(1). Please reply with feedback!\\n\\nimport java.util.*;\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if(strs.length==0){\\n            return null;\\n        }\\n\\n\\n        int leftPointer=0;\\n        int rightPointer=0;\\n        int count=0;\\n        PriorityQueue<Integer> minSim = new PriorityQueue<Integer>();\\n\\n        for(int i=1; i<strs.length; i++){ //start from element at index 1 in string array\\n            count=0;\\n            leftPointer=0;\\n            rightPointer=0;\\n            while(leftPointer<strs[0].length() && rightPointer<strs[i].length()){ \\n                if(strs[0].charAt(leftPointer)==strs[i].charAt(rightPointer)){\\n                    count++;\\n                    leftPointer++;\\n                    rightPointer++;\\n                }\\n            }\\n            \\n            minSim.add(count);\\n\\n        }\\n\\n        /*\\n        the minimum similarity count will tell us up to what index we should return\\n        */\\n        int min=0;\\n        if(minSim.peek()!=0){\\n           min = minSim.peek(); \\n        }\\n        String result = strs[0].substring(0,min);\\n\\n        return result;\\n\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1902847,
                "content": [
                    {
                        "username": "keithdtyler",
                        "content": "Oh, I started attacking this problem all wrong. I was trying to find the longest substring shared by more than one string in the list. So for example the first test would have returned \"flow\" since both \"flow\" and \"flower\" contain that substring.\\nNo, I\\'m supposed to find the common substring that *all* strings in the set have."
                    },
                    {
                        "username": "tadarshtiwari1996",
                        "content": "there is  Use case in this Question \\nuser Case is\\nInput=[\"a\",\"a\",\"b\"]\\nso with this Input Longest Prefix is \"a\"\\nbut in the Expected of this use case Given blank String \" \"\\n\\nWhy it is Expected like that can any one please explain \\n\\n"
                    },
                    {
                        "username": "taolitony",
                        "content": "Help!!!\\n\\nMy code did well for the test cases, but got a Runtime Error when submitted. Can anyone help me understand why the Runtime Error happened? Thanks. See below for the error and the codes:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1513, java.base/java.lang.String.charAt\\n  at line 52, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        String result = \"\";\\n        int preNum = 0;\\n\\n        Arrays.sort(strs);\\n\\n        //check if the strings are legal\\n        for (String word: strs) {\\n            boolean illegal = false;\\n            if (word.length() > 200){\\n                illegal = true;\\n            } else {\\n                for (int i = 0; i < word.length(); i++){\\n                    if (word.charAt(i) >= \\'A\\' && word.charAt(i) <= \\'Z\\'){\\n                        illegal = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (illegal){\\n                return  result;\\n            }\\n        }\\n        \\n        for (int i = 0; i < strs.length; i++) {\\n\\n            boolean flag = true;\\n\\n            for (int j = 1; j < strs.length; j++) {\\n\\n                if (strs[j].charAt(i) != strs[0].charAt(i)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if (flag){\\n                preNum += 1;\\n            }else {\\n                break;\\n            }\\n\\n        }\\n\\n        if (preNum == 0){//line 48\\n            return result;\\n        }else {\\n            for (int i = 0; i < preNum; i++) {\\n                result += strs[0].charAt(i); //line 52\\n            }\\n            return result;//line 54\\n        }\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "Longest common prefix amongst ALL THE STRING ITEMS present in the array. All the string items in the array should have a common prefix."
                    },
                    {
                        "username": "Antodominic_123",
                        "content": "this solution of the Problem is easy to understand And if it //is easy  give one thumps up bro\\n\\n\\nString find = strs[0];\\n\\t\\tboolean data = false;\\n\\t\\tString result = \"\";\\n\\t\\t\\n\\t\\tfor(int i=0; i<find.length();i++)\\n\\t\\t{\\n\\t\\t\\tString process = find.substring(0,(i+1));\\n\\t\\t\\tfor(String st : strs)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(st.startsWith(process))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(data)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult = process;\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\nif(result.length()>0)\\n{\\n\\treturn result;\\n}\\nelse\\n{\\n\\treturn \"\";\\n}"
                    },
                    {
                        "username": "TheStarSlayer",
                        "content": " `char * longestCommonPrefix(char ** strs, int strsSize)\\n  {\\n    int i,j,k = 0;\\n    int *count = malloc(1 * sizeof(int));\\n    int *temp1 = malloc(1 * sizeof(int));\\n    *count = 201;\\n\\n    for (i = 0; i < strsSize; i++)\\n    {\\n        for (j = 0; strs[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            continue;\\n        }\\n        *temp1 = j+1;\\n        if (*temp1 < *count)\\n        {\\n            *count = *temp1;\\n        }\\n    }\\n\\n    int size = *count;\\n    free(count);\\n    free(temp1);\\n\\n    char *str = malloc((size+1)*sizeof(char));\\n    char temp;\\n    if (str == NULL)\\n    {\\n        printf(\"foo\");\\n        return NULL;\\n    }\\n    else\\n    {\\n        for (i = 0, j = 0; i < strsSize; i++)\\n        {\\n            temp = strs[0][j];\\n\\n            if (temp == strs[i][j])                     \\n            {\\n                str[k] = strs[i][j];\\n                if (i == strsSize - 1)\\n                {\\n                    j++;\\n                    k++;\\n                    i = -1;\\n                }\\n                continue;\\n            }\\n            else\\n            {\\n                str[k] = \\'\\\\0\\';\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n}`\\n\\nI was able to solve the testcases but I could not submit it as it throws a heap buffer overflow error. Can someone help me?"
                    },
                    {
                        "username": "rahilsheikh155",
                        "content": "class Solution {\\npublic String longestCommonPrefix(String[] strs) {\\nint size=strs.length;\\nif(size==0)\\n{\\nreturn \"\";\\n}\\nif(size==1)\\n{\\nreturn strs[0];\\n}\\nArrays.sort(strs);\\nint end=Math.min(strs[0].length(),strs[size-1].length());\\nint i=0;\\nwhile(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\ni++;\\nString pre=strs[0].substring(0,i);\\nreturn pre;\\n\\n}\\n}"
                    },
                    {
                        "username": "alexsoyes",
                        "content": "strs =  [\"reflower\",\"flow\",\"flight\"]\\n\\nmy output is \"fl\", but excpeted if \"\"? :O"
                    },
                    {
                        "username": "wowerzero",
                        "content": "The second example is weird: IMHO, [\"flower\",\"flow\",\"dog\"] = \"\" is much better as example"
                    },
                    {
                        "username": "fmv2113",
                        "content": "Hi! When I run this code I get time limit exceeded. Can someone explain why? \\n\\nThought process: if I keep a count of the similarities between the first string and every successive string, then I can take the minimum similarity called min, and make the resulting prefix strs[0].substring(0, min); I guess where I could be being extra is through my use of a binary heap to keep the finding min operation to O(1). Please reply with feedback!\\n\\nimport java.util.*;\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if(strs.length==0){\\n            return null;\\n        }\\n\\n\\n        int leftPointer=0;\\n        int rightPointer=0;\\n        int count=0;\\n        PriorityQueue<Integer> minSim = new PriorityQueue<Integer>();\\n\\n        for(int i=1; i<strs.length; i++){ //start from element at index 1 in string array\\n            count=0;\\n            leftPointer=0;\\n            rightPointer=0;\\n            while(leftPointer<strs[0].length() && rightPointer<strs[i].length()){ \\n                if(strs[0].charAt(leftPointer)==strs[i].charAt(rightPointer)){\\n                    count++;\\n                    leftPointer++;\\n                    rightPointer++;\\n                }\\n            }\\n            \\n            minSim.add(count);\\n\\n        }\\n\\n        /*\\n        the minimum similarity count will tell us up to what index we should return\\n        */\\n        int min=0;\\n        if(minSim.peek()!=0){\\n           min = minSim.peek(); \\n        }\\n        String result = strs[0].substring(0,min);\\n\\n        return result;\\n\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1901078,
                "content": [
                    {
                        "username": "keithdtyler",
                        "content": "Oh, I started attacking this problem all wrong. I was trying to find the longest substring shared by more than one string in the list. So for example the first test would have returned \"flow\" since both \"flow\" and \"flower\" contain that substring.\\nNo, I\\'m supposed to find the common substring that *all* strings in the set have."
                    },
                    {
                        "username": "tadarshtiwari1996",
                        "content": "there is  Use case in this Question \\nuser Case is\\nInput=[\"a\",\"a\",\"b\"]\\nso with this Input Longest Prefix is \"a\"\\nbut in the Expected of this use case Given blank String \" \"\\n\\nWhy it is Expected like that can any one please explain \\n\\n"
                    },
                    {
                        "username": "taolitony",
                        "content": "Help!!!\\n\\nMy code did well for the test cases, but got a Runtime Error when submitted. Can anyone help me understand why the Runtime Error happened? Thanks. See below for the error and the codes:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1513, java.base/java.lang.String.charAt\\n  at line 52, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        String result = \"\";\\n        int preNum = 0;\\n\\n        Arrays.sort(strs);\\n\\n        //check if the strings are legal\\n        for (String word: strs) {\\n            boolean illegal = false;\\n            if (word.length() > 200){\\n                illegal = true;\\n            } else {\\n                for (int i = 0; i < word.length(); i++){\\n                    if (word.charAt(i) >= \\'A\\' && word.charAt(i) <= \\'Z\\'){\\n                        illegal = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (illegal){\\n                return  result;\\n            }\\n        }\\n        \\n        for (int i = 0; i < strs.length; i++) {\\n\\n            boolean flag = true;\\n\\n            for (int j = 1; j < strs.length; j++) {\\n\\n                if (strs[j].charAt(i) != strs[0].charAt(i)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if (flag){\\n                preNum += 1;\\n            }else {\\n                break;\\n            }\\n\\n        }\\n\\n        if (preNum == 0){//line 48\\n            return result;\\n        }else {\\n            for (int i = 0; i < preNum; i++) {\\n                result += strs[0].charAt(i); //line 52\\n            }\\n            return result;//line 54\\n        }\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "Longest common prefix amongst ALL THE STRING ITEMS present in the array. All the string items in the array should have a common prefix."
                    },
                    {
                        "username": "Antodominic_123",
                        "content": "this solution of the Problem is easy to understand And if it //is easy  give one thumps up bro\\n\\n\\nString find = strs[0];\\n\\t\\tboolean data = false;\\n\\t\\tString result = \"\";\\n\\t\\t\\n\\t\\tfor(int i=0; i<find.length();i++)\\n\\t\\t{\\n\\t\\t\\tString process = find.substring(0,(i+1));\\n\\t\\t\\tfor(String st : strs)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(st.startsWith(process))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(data)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult = process;\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\nif(result.length()>0)\\n{\\n\\treturn result;\\n}\\nelse\\n{\\n\\treturn \"\";\\n}"
                    },
                    {
                        "username": "TheStarSlayer",
                        "content": " `char * longestCommonPrefix(char ** strs, int strsSize)\\n  {\\n    int i,j,k = 0;\\n    int *count = malloc(1 * sizeof(int));\\n    int *temp1 = malloc(1 * sizeof(int));\\n    *count = 201;\\n\\n    for (i = 0; i < strsSize; i++)\\n    {\\n        for (j = 0; strs[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            continue;\\n        }\\n        *temp1 = j+1;\\n        if (*temp1 < *count)\\n        {\\n            *count = *temp1;\\n        }\\n    }\\n\\n    int size = *count;\\n    free(count);\\n    free(temp1);\\n\\n    char *str = malloc((size+1)*sizeof(char));\\n    char temp;\\n    if (str == NULL)\\n    {\\n        printf(\"foo\");\\n        return NULL;\\n    }\\n    else\\n    {\\n        for (i = 0, j = 0; i < strsSize; i++)\\n        {\\n            temp = strs[0][j];\\n\\n            if (temp == strs[i][j])                     \\n            {\\n                str[k] = strs[i][j];\\n                if (i == strsSize - 1)\\n                {\\n                    j++;\\n                    k++;\\n                    i = -1;\\n                }\\n                continue;\\n            }\\n            else\\n            {\\n                str[k] = \\'\\\\0\\';\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n}`\\n\\nI was able to solve the testcases but I could not submit it as it throws a heap buffer overflow error. Can someone help me?"
                    },
                    {
                        "username": "rahilsheikh155",
                        "content": "class Solution {\\npublic String longestCommonPrefix(String[] strs) {\\nint size=strs.length;\\nif(size==0)\\n{\\nreturn \"\";\\n}\\nif(size==1)\\n{\\nreturn strs[0];\\n}\\nArrays.sort(strs);\\nint end=Math.min(strs[0].length(),strs[size-1].length());\\nint i=0;\\nwhile(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\ni++;\\nString pre=strs[0].substring(0,i);\\nreturn pre;\\n\\n}\\n}"
                    },
                    {
                        "username": "alexsoyes",
                        "content": "strs =  [\"reflower\",\"flow\",\"flight\"]\\n\\nmy output is \"fl\", but excpeted if \"\"? :O"
                    },
                    {
                        "username": "wowerzero",
                        "content": "The second example is weird: IMHO, [\"flower\",\"flow\",\"dog\"] = \"\" is much better as example"
                    },
                    {
                        "username": "fmv2113",
                        "content": "Hi! When I run this code I get time limit exceeded. Can someone explain why? \\n\\nThought process: if I keep a count of the similarities between the first string and every successive string, then I can take the minimum similarity called min, and make the resulting prefix strs[0].substring(0, min); I guess where I could be being extra is through my use of a binary heap to keep the finding min operation to O(1). Please reply with feedback!\\n\\nimport java.util.*;\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if(strs.length==0){\\n            return null;\\n        }\\n\\n\\n        int leftPointer=0;\\n        int rightPointer=0;\\n        int count=0;\\n        PriorityQueue<Integer> minSim = new PriorityQueue<Integer>();\\n\\n        for(int i=1; i<strs.length; i++){ //start from element at index 1 in string array\\n            count=0;\\n            leftPointer=0;\\n            rightPointer=0;\\n            while(leftPointer<strs[0].length() && rightPointer<strs[i].length()){ \\n                if(strs[0].charAt(leftPointer)==strs[i].charAt(rightPointer)){\\n                    count++;\\n                    leftPointer++;\\n                    rightPointer++;\\n                }\\n            }\\n            \\n            minSim.add(count);\\n\\n        }\\n\\n        /*\\n        the minimum similarity count will tell us up to what index we should return\\n        */\\n        int min=0;\\n        if(minSim.peek()!=0){\\n           min = minSim.peek(); \\n        }\\n        String result = strs[0].substring(0,min);\\n\\n        return result;\\n\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1900758,
                "content": [
                    {
                        "username": "keithdtyler",
                        "content": "Oh, I started attacking this problem all wrong. I was trying to find the longest substring shared by more than one string in the list. So for example the first test would have returned \"flow\" since both \"flow\" and \"flower\" contain that substring.\\nNo, I\\'m supposed to find the common substring that *all* strings in the set have."
                    },
                    {
                        "username": "tadarshtiwari1996",
                        "content": "there is  Use case in this Question \\nuser Case is\\nInput=[\"a\",\"a\",\"b\"]\\nso with this Input Longest Prefix is \"a\"\\nbut in the Expected of this use case Given blank String \" \"\\n\\nWhy it is Expected like that can any one please explain \\n\\n"
                    },
                    {
                        "username": "taolitony",
                        "content": "Help!!!\\n\\nMy code did well for the test cases, but got a Runtime Error when submitted. Can anyone help me understand why the Runtime Error happened? Thanks. See below for the error and the codes:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1513, java.base/java.lang.String.charAt\\n  at line 52, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        String result = \"\";\\n        int preNum = 0;\\n\\n        Arrays.sort(strs);\\n\\n        //check if the strings are legal\\n        for (String word: strs) {\\n            boolean illegal = false;\\n            if (word.length() > 200){\\n                illegal = true;\\n            } else {\\n                for (int i = 0; i < word.length(); i++){\\n                    if (word.charAt(i) >= \\'A\\' && word.charAt(i) <= \\'Z\\'){\\n                        illegal = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (illegal){\\n                return  result;\\n            }\\n        }\\n        \\n        for (int i = 0; i < strs.length; i++) {\\n\\n            boolean flag = true;\\n\\n            for (int j = 1; j < strs.length; j++) {\\n\\n                if (strs[j].charAt(i) != strs[0].charAt(i)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if (flag){\\n                preNum += 1;\\n            }else {\\n                break;\\n            }\\n\\n        }\\n\\n        if (preNum == 0){//line 48\\n            return result;\\n        }else {\\n            for (int i = 0; i < preNum; i++) {\\n                result += strs[0].charAt(i); //line 52\\n            }\\n            return result;//line 54\\n        }\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "Longest common prefix amongst ALL THE STRING ITEMS present in the array. All the string items in the array should have a common prefix."
                    },
                    {
                        "username": "Antodominic_123",
                        "content": "this solution of the Problem is easy to understand And if it //is easy  give one thumps up bro\\n\\n\\nString find = strs[0];\\n\\t\\tboolean data = false;\\n\\t\\tString result = \"\";\\n\\t\\t\\n\\t\\tfor(int i=0; i<find.length();i++)\\n\\t\\t{\\n\\t\\t\\tString process = find.substring(0,(i+1));\\n\\t\\t\\tfor(String st : strs)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(st.startsWith(process))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(data)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult = process;\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\nif(result.length()>0)\\n{\\n\\treturn result;\\n}\\nelse\\n{\\n\\treturn \"\";\\n}"
                    },
                    {
                        "username": "TheStarSlayer",
                        "content": " `char * longestCommonPrefix(char ** strs, int strsSize)\\n  {\\n    int i,j,k = 0;\\n    int *count = malloc(1 * sizeof(int));\\n    int *temp1 = malloc(1 * sizeof(int));\\n    *count = 201;\\n\\n    for (i = 0; i < strsSize; i++)\\n    {\\n        for (j = 0; strs[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            continue;\\n        }\\n        *temp1 = j+1;\\n        if (*temp1 < *count)\\n        {\\n            *count = *temp1;\\n        }\\n    }\\n\\n    int size = *count;\\n    free(count);\\n    free(temp1);\\n\\n    char *str = malloc((size+1)*sizeof(char));\\n    char temp;\\n    if (str == NULL)\\n    {\\n        printf(\"foo\");\\n        return NULL;\\n    }\\n    else\\n    {\\n        for (i = 0, j = 0; i < strsSize; i++)\\n        {\\n            temp = strs[0][j];\\n\\n            if (temp == strs[i][j])                     \\n            {\\n                str[k] = strs[i][j];\\n                if (i == strsSize - 1)\\n                {\\n                    j++;\\n                    k++;\\n                    i = -1;\\n                }\\n                continue;\\n            }\\n            else\\n            {\\n                str[k] = \\'\\\\0\\';\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n}`\\n\\nI was able to solve the testcases but I could not submit it as it throws a heap buffer overflow error. Can someone help me?"
                    },
                    {
                        "username": "rahilsheikh155",
                        "content": "class Solution {\\npublic String longestCommonPrefix(String[] strs) {\\nint size=strs.length;\\nif(size==0)\\n{\\nreturn \"\";\\n}\\nif(size==1)\\n{\\nreturn strs[0];\\n}\\nArrays.sort(strs);\\nint end=Math.min(strs[0].length(),strs[size-1].length());\\nint i=0;\\nwhile(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\ni++;\\nString pre=strs[0].substring(0,i);\\nreturn pre;\\n\\n}\\n}"
                    },
                    {
                        "username": "alexsoyes",
                        "content": "strs =  [\"reflower\",\"flow\",\"flight\"]\\n\\nmy output is \"fl\", but excpeted if \"\"? :O"
                    },
                    {
                        "username": "wowerzero",
                        "content": "The second example is weird: IMHO, [\"flower\",\"flow\",\"dog\"] = \"\" is much better as example"
                    },
                    {
                        "username": "fmv2113",
                        "content": "Hi! When I run this code I get time limit exceeded. Can someone explain why? \\n\\nThought process: if I keep a count of the similarities between the first string and every successive string, then I can take the minimum similarity called min, and make the resulting prefix strs[0].substring(0, min); I guess where I could be being extra is through my use of a binary heap to keep the finding min operation to O(1). Please reply with feedback!\\n\\nimport java.util.*;\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if(strs.length==0){\\n            return null;\\n        }\\n\\n\\n        int leftPointer=0;\\n        int rightPointer=0;\\n        int count=0;\\n        PriorityQueue<Integer> minSim = new PriorityQueue<Integer>();\\n\\n        for(int i=1; i<strs.length; i++){ //start from element at index 1 in string array\\n            count=0;\\n            leftPointer=0;\\n            rightPointer=0;\\n            while(leftPointer<strs[0].length() && rightPointer<strs[i].length()){ \\n                if(strs[0].charAt(leftPointer)==strs[i].charAt(rightPointer)){\\n                    count++;\\n                    leftPointer++;\\n                    rightPointer++;\\n                }\\n            }\\n            \\n            minSim.add(count);\\n\\n        }\\n\\n        /*\\n        the minimum similarity count will tell us up to what index we should return\\n        */\\n        int min=0;\\n        if(minSim.peek()!=0){\\n           min = minSim.peek(); \\n        }\\n        String result = strs[0].substring(0,min);\\n\\n        return result;\\n\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1898401,
                "content": [
                    {
                        "username": "keithdtyler",
                        "content": "Oh, I started attacking this problem all wrong. I was trying to find the longest substring shared by more than one string in the list. So for example the first test would have returned \"flow\" since both \"flow\" and \"flower\" contain that substring.\\nNo, I\\'m supposed to find the common substring that *all* strings in the set have."
                    },
                    {
                        "username": "tadarshtiwari1996",
                        "content": "there is  Use case in this Question \\nuser Case is\\nInput=[\"a\",\"a\",\"b\"]\\nso with this Input Longest Prefix is \"a\"\\nbut in the Expected of this use case Given blank String \" \"\\n\\nWhy it is Expected like that can any one please explain \\n\\n"
                    },
                    {
                        "username": "taolitony",
                        "content": "Help!!!\\n\\nMy code did well for the test cases, but got a Runtime Error when submitted. Can anyone help me understand why the Runtime Error happened? Thanks. See below for the error and the codes:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1513, java.base/java.lang.String.charAt\\n  at line 52, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        String result = \"\";\\n        int preNum = 0;\\n\\n        Arrays.sort(strs);\\n\\n        //check if the strings are legal\\n        for (String word: strs) {\\n            boolean illegal = false;\\n            if (word.length() > 200){\\n                illegal = true;\\n            } else {\\n                for (int i = 0; i < word.length(); i++){\\n                    if (word.charAt(i) >= \\'A\\' && word.charAt(i) <= \\'Z\\'){\\n                        illegal = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (illegal){\\n                return  result;\\n            }\\n        }\\n        \\n        for (int i = 0; i < strs.length; i++) {\\n\\n            boolean flag = true;\\n\\n            for (int j = 1; j < strs.length; j++) {\\n\\n                if (strs[j].charAt(i) != strs[0].charAt(i)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if (flag){\\n                preNum += 1;\\n            }else {\\n                break;\\n            }\\n\\n        }\\n\\n        if (preNum == 0){//line 48\\n            return result;\\n        }else {\\n            for (int i = 0; i < preNum; i++) {\\n                result += strs[0].charAt(i); //line 52\\n            }\\n            return result;//line 54\\n        }\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "Longest common prefix amongst ALL THE STRING ITEMS present in the array. All the string items in the array should have a common prefix."
                    },
                    {
                        "username": "Antodominic_123",
                        "content": "this solution of the Problem is easy to understand And if it //is easy  give one thumps up bro\\n\\n\\nString find = strs[0];\\n\\t\\tboolean data = false;\\n\\t\\tString result = \"\";\\n\\t\\t\\n\\t\\tfor(int i=0; i<find.length();i++)\\n\\t\\t{\\n\\t\\t\\tString process = find.substring(0,(i+1));\\n\\t\\t\\tfor(String st : strs)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(st.startsWith(process))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(data)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult = process;\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\nif(result.length()>0)\\n{\\n\\treturn result;\\n}\\nelse\\n{\\n\\treturn \"\";\\n}"
                    },
                    {
                        "username": "TheStarSlayer",
                        "content": " `char * longestCommonPrefix(char ** strs, int strsSize)\\n  {\\n    int i,j,k = 0;\\n    int *count = malloc(1 * sizeof(int));\\n    int *temp1 = malloc(1 * sizeof(int));\\n    *count = 201;\\n\\n    for (i = 0; i < strsSize; i++)\\n    {\\n        for (j = 0; strs[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            continue;\\n        }\\n        *temp1 = j+1;\\n        if (*temp1 < *count)\\n        {\\n            *count = *temp1;\\n        }\\n    }\\n\\n    int size = *count;\\n    free(count);\\n    free(temp1);\\n\\n    char *str = malloc((size+1)*sizeof(char));\\n    char temp;\\n    if (str == NULL)\\n    {\\n        printf(\"foo\");\\n        return NULL;\\n    }\\n    else\\n    {\\n        for (i = 0, j = 0; i < strsSize; i++)\\n        {\\n            temp = strs[0][j];\\n\\n            if (temp == strs[i][j])                     \\n            {\\n                str[k] = strs[i][j];\\n                if (i == strsSize - 1)\\n                {\\n                    j++;\\n                    k++;\\n                    i = -1;\\n                }\\n                continue;\\n            }\\n            else\\n            {\\n                str[k] = \\'\\\\0\\';\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n}`\\n\\nI was able to solve the testcases but I could not submit it as it throws a heap buffer overflow error. Can someone help me?"
                    },
                    {
                        "username": "rahilsheikh155",
                        "content": "class Solution {\\npublic String longestCommonPrefix(String[] strs) {\\nint size=strs.length;\\nif(size==0)\\n{\\nreturn \"\";\\n}\\nif(size==1)\\n{\\nreturn strs[0];\\n}\\nArrays.sort(strs);\\nint end=Math.min(strs[0].length(),strs[size-1].length());\\nint i=0;\\nwhile(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\ni++;\\nString pre=strs[0].substring(0,i);\\nreturn pre;\\n\\n}\\n}"
                    },
                    {
                        "username": "alexsoyes",
                        "content": "strs =  [\"reflower\",\"flow\",\"flight\"]\\n\\nmy output is \"fl\", but excpeted if \"\"? :O"
                    },
                    {
                        "username": "wowerzero",
                        "content": "The second example is weird: IMHO, [\"flower\",\"flow\",\"dog\"] = \"\" is much better as example"
                    },
                    {
                        "username": "fmv2113",
                        "content": "Hi! When I run this code I get time limit exceeded. Can someone explain why? \\n\\nThought process: if I keep a count of the similarities between the first string and every successive string, then I can take the minimum similarity called min, and make the resulting prefix strs[0].substring(0, min); I guess where I could be being extra is through my use of a binary heap to keep the finding min operation to O(1). Please reply with feedback!\\n\\nimport java.util.*;\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if(strs.length==0){\\n            return null;\\n        }\\n\\n\\n        int leftPointer=0;\\n        int rightPointer=0;\\n        int count=0;\\n        PriorityQueue<Integer> minSim = new PriorityQueue<Integer>();\\n\\n        for(int i=1; i<strs.length; i++){ //start from element at index 1 in string array\\n            count=0;\\n            leftPointer=0;\\n            rightPointer=0;\\n            while(leftPointer<strs[0].length() && rightPointer<strs[i].length()){ \\n                if(strs[0].charAt(leftPointer)==strs[i].charAt(rightPointer)){\\n                    count++;\\n                    leftPointer++;\\n                    rightPointer++;\\n                }\\n            }\\n            \\n            minSim.add(count);\\n\\n        }\\n\\n        /*\\n        the minimum similarity count will tell us up to what index we should return\\n        */\\n        int min=0;\\n        if(minSim.peek()!=0){\\n           min = minSim.peek(); \\n        }\\n        String result = strs[0].substring(0,min);\\n\\n        return result;\\n\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1898235,
                "content": [
                    {
                        "username": "keithdtyler",
                        "content": "Oh, I started attacking this problem all wrong. I was trying to find the longest substring shared by more than one string in the list. So for example the first test would have returned \"flow\" since both \"flow\" and \"flower\" contain that substring.\\nNo, I\\'m supposed to find the common substring that *all* strings in the set have."
                    },
                    {
                        "username": "tadarshtiwari1996",
                        "content": "there is  Use case in this Question \\nuser Case is\\nInput=[\"a\",\"a\",\"b\"]\\nso with this Input Longest Prefix is \"a\"\\nbut in the Expected of this use case Given blank String \" \"\\n\\nWhy it is Expected like that can any one please explain \\n\\n"
                    },
                    {
                        "username": "taolitony",
                        "content": "Help!!!\\n\\nMy code did well for the test cases, but got a Runtime Error when submitted. Can anyone help me understand why the Runtime Error happened? Thanks. See below for the error and the codes:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1513, java.base/java.lang.String.charAt\\n  at line 52, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        String result = \"\";\\n        int preNum = 0;\\n\\n        Arrays.sort(strs);\\n\\n        //check if the strings are legal\\n        for (String word: strs) {\\n            boolean illegal = false;\\n            if (word.length() > 200){\\n                illegal = true;\\n            } else {\\n                for (int i = 0; i < word.length(); i++){\\n                    if (word.charAt(i) >= \\'A\\' && word.charAt(i) <= \\'Z\\'){\\n                        illegal = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (illegal){\\n                return  result;\\n            }\\n        }\\n        \\n        for (int i = 0; i < strs.length; i++) {\\n\\n            boolean flag = true;\\n\\n            for (int j = 1; j < strs.length; j++) {\\n\\n                if (strs[j].charAt(i) != strs[0].charAt(i)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if (flag){\\n                preNum += 1;\\n            }else {\\n                break;\\n            }\\n\\n        }\\n\\n        if (preNum == 0){//line 48\\n            return result;\\n        }else {\\n            for (int i = 0; i < preNum; i++) {\\n                result += strs[0].charAt(i); //line 52\\n            }\\n            return result;//line 54\\n        }\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "Longest common prefix amongst ALL THE STRING ITEMS present in the array. All the string items in the array should have a common prefix."
                    },
                    {
                        "username": "Antodominic_123",
                        "content": "this solution of the Problem is easy to understand And if it //is easy  give one thumps up bro\\n\\n\\nString find = strs[0];\\n\\t\\tboolean data = false;\\n\\t\\tString result = \"\";\\n\\t\\t\\n\\t\\tfor(int i=0; i<find.length();i++)\\n\\t\\t{\\n\\t\\t\\tString process = find.substring(0,(i+1));\\n\\t\\t\\tfor(String st : strs)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(st.startsWith(process))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(data)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult = process;\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\nif(result.length()>0)\\n{\\n\\treturn result;\\n}\\nelse\\n{\\n\\treturn \"\";\\n}"
                    },
                    {
                        "username": "TheStarSlayer",
                        "content": " `char * longestCommonPrefix(char ** strs, int strsSize)\\n  {\\n    int i,j,k = 0;\\n    int *count = malloc(1 * sizeof(int));\\n    int *temp1 = malloc(1 * sizeof(int));\\n    *count = 201;\\n\\n    for (i = 0; i < strsSize; i++)\\n    {\\n        for (j = 0; strs[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            continue;\\n        }\\n        *temp1 = j+1;\\n        if (*temp1 < *count)\\n        {\\n            *count = *temp1;\\n        }\\n    }\\n\\n    int size = *count;\\n    free(count);\\n    free(temp1);\\n\\n    char *str = malloc((size+1)*sizeof(char));\\n    char temp;\\n    if (str == NULL)\\n    {\\n        printf(\"foo\");\\n        return NULL;\\n    }\\n    else\\n    {\\n        for (i = 0, j = 0; i < strsSize; i++)\\n        {\\n            temp = strs[0][j];\\n\\n            if (temp == strs[i][j])                     \\n            {\\n                str[k] = strs[i][j];\\n                if (i == strsSize - 1)\\n                {\\n                    j++;\\n                    k++;\\n                    i = -1;\\n                }\\n                continue;\\n            }\\n            else\\n            {\\n                str[k] = \\'\\\\0\\';\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n}`\\n\\nI was able to solve the testcases but I could not submit it as it throws a heap buffer overflow error. Can someone help me?"
                    },
                    {
                        "username": "rahilsheikh155",
                        "content": "class Solution {\\npublic String longestCommonPrefix(String[] strs) {\\nint size=strs.length;\\nif(size==0)\\n{\\nreturn \"\";\\n}\\nif(size==1)\\n{\\nreturn strs[0];\\n}\\nArrays.sort(strs);\\nint end=Math.min(strs[0].length(),strs[size-1].length());\\nint i=0;\\nwhile(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\ni++;\\nString pre=strs[0].substring(0,i);\\nreturn pre;\\n\\n}\\n}"
                    },
                    {
                        "username": "alexsoyes",
                        "content": "strs =  [\"reflower\",\"flow\",\"flight\"]\\n\\nmy output is \"fl\", but excpeted if \"\"? :O"
                    },
                    {
                        "username": "wowerzero",
                        "content": "The second example is weird: IMHO, [\"flower\",\"flow\",\"dog\"] = \"\" is much better as example"
                    },
                    {
                        "username": "fmv2113",
                        "content": "Hi! When I run this code I get time limit exceeded. Can someone explain why? \\n\\nThought process: if I keep a count of the similarities between the first string and every successive string, then I can take the minimum similarity called min, and make the resulting prefix strs[0].substring(0, min); I guess where I could be being extra is through my use of a binary heap to keep the finding min operation to O(1). Please reply with feedback!\\n\\nimport java.util.*;\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if(strs.length==0){\\n            return null;\\n        }\\n\\n\\n        int leftPointer=0;\\n        int rightPointer=0;\\n        int count=0;\\n        PriorityQueue<Integer> minSim = new PriorityQueue<Integer>();\\n\\n        for(int i=1; i<strs.length; i++){ //start from element at index 1 in string array\\n            count=0;\\n            leftPointer=0;\\n            rightPointer=0;\\n            while(leftPointer<strs[0].length() && rightPointer<strs[i].length()){ \\n                if(strs[0].charAt(leftPointer)==strs[i].charAt(rightPointer)){\\n                    count++;\\n                    leftPointer++;\\n                    rightPointer++;\\n                }\\n            }\\n            \\n            minSim.add(count);\\n\\n        }\\n\\n        /*\\n        the minimum similarity count will tell us up to what index we should return\\n        */\\n        int min=0;\\n        if(minSim.peek()!=0){\\n           min = minSim.peek(); \\n        }\\n        String result = strs[0].substring(0,min);\\n\\n        return result;\\n\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1897386,
                "content": [
                    {
                        "username": "keithdtyler",
                        "content": "Oh, I started attacking this problem all wrong. I was trying to find the longest substring shared by more than one string in the list. So for example the first test would have returned \"flow\" since both \"flow\" and \"flower\" contain that substring.\\nNo, I\\'m supposed to find the common substring that *all* strings in the set have."
                    },
                    {
                        "username": "tadarshtiwari1996",
                        "content": "there is  Use case in this Question \\nuser Case is\\nInput=[\"a\",\"a\",\"b\"]\\nso with this Input Longest Prefix is \"a\"\\nbut in the Expected of this use case Given blank String \" \"\\n\\nWhy it is Expected like that can any one please explain \\n\\n"
                    },
                    {
                        "username": "taolitony",
                        "content": "Help!!!\\n\\nMy code did well for the test cases, but got a Runtime Error when submitted. Can anyone help me understand why the Runtime Error happened? Thanks. See below for the error and the codes:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1513, java.base/java.lang.String.charAt\\n  at line 52, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        String result = \"\";\\n        int preNum = 0;\\n\\n        Arrays.sort(strs);\\n\\n        //check if the strings are legal\\n        for (String word: strs) {\\n            boolean illegal = false;\\n            if (word.length() > 200){\\n                illegal = true;\\n            } else {\\n                for (int i = 0; i < word.length(); i++){\\n                    if (word.charAt(i) >= \\'A\\' && word.charAt(i) <= \\'Z\\'){\\n                        illegal = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (illegal){\\n                return  result;\\n            }\\n        }\\n        \\n        for (int i = 0; i < strs.length; i++) {\\n\\n            boolean flag = true;\\n\\n            for (int j = 1; j < strs.length; j++) {\\n\\n                if (strs[j].charAt(i) != strs[0].charAt(i)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if (flag){\\n                preNum += 1;\\n            }else {\\n                break;\\n            }\\n\\n        }\\n\\n        if (preNum == 0){//line 48\\n            return result;\\n        }else {\\n            for (int i = 0; i < preNum; i++) {\\n                result += strs[0].charAt(i); //line 52\\n            }\\n            return result;//line 54\\n        }\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "Longest common prefix amongst ALL THE STRING ITEMS present in the array. All the string items in the array should have a common prefix."
                    },
                    {
                        "username": "Antodominic_123",
                        "content": "this solution of the Problem is easy to understand And if it //is easy  give one thumps up bro\\n\\n\\nString find = strs[0];\\n\\t\\tboolean data = false;\\n\\t\\tString result = \"\";\\n\\t\\t\\n\\t\\tfor(int i=0; i<find.length();i++)\\n\\t\\t{\\n\\t\\t\\tString process = find.substring(0,(i+1));\\n\\t\\t\\tfor(String st : strs)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(st.startsWith(process))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(data)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult = process;\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\nif(result.length()>0)\\n{\\n\\treturn result;\\n}\\nelse\\n{\\n\\treturn \"\";\\n}"
                    },
                    {
                        "username": "TheStarSlayer",
                        "content": " `char * longestCommonPrefix(char ** strs, int strsSize)\\n  {\\n    int i,j,k = 0;\\n    int *count = malloc(1 * sizeof(int));\\n    int *temp1 = malloc(1 * sizeof(int));\\n    *count = 201;\\n\\n    for (i = 0; i < strsSize; i++)\\n    {\\n        for (j = 0; strs[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            continue;\\n        }\\n        *temp1 = j+1;\\n        if (*temp1 < *count)\\n        {\\n            *count = *temp1;\\n        }\\n    }\\n\\n    int size = *count;\\n    free(count);\\n    free(temp1);\\n\\n    char *str = malloc((size+1)*sizeof(char));\\n    char temp;\\n    if (str == NULL)\\n    {\\n        printf(\"foo\");\\n        return NULL;\\n    }\\n    else\\n    {\\n        for (i = 0, j = 0; i < strsSize; i++)\\n        {\\n            temp = strs[0][j];\\n\\n            if (temp == strs[i][j])                     \\n            {\\n                str[k] = strs[i][j];\\n                if (i == strsSize - 1)\\n                {\\n                    j++;\\n                    k++;\\n                    i = -1;\\n                }\\n                continue;\\n            }\\n            else\\n            {\\n                str[k] = \\'\\\\0\\';\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n}`\\n\\nI was able to solve the testcases but I could not submit it as it throws a heap buffer overflow error. Can someone help me?"
                    },
                    {
                        "username": "rahilsheikh155",
                        "content": "class Solution {\\npublic String longestCommonPrefix(String[] strs) {\\nint size=strs.length;\\nif(size==0)\\n{\\nreturn \"\";\\n}\\nif(size==1)\\n{\\nreturn strs[0];\\n}\\nArrays.sort(strs);\\nint end=Math.min(strs[0].length(),strs[size-1].length());\\nint i=0;\\nwhile(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\ni++;\\nString pre=strs[0].substring(0,i);\\nreturn pre;\\n\\n}\\n}"
                    },
                    {
                        "username": "alexsoyes",
                        "content": "strs =  [\"reflower\",\"flow\",\"flight\"]\\n\\nmy output is \"fl\", but excpeted if \"\"? :O"
                    },
                    {
                        "username": "wowerzero",
                        "content": "The second example is weird: IMHO, [\"flower\",\"flow\",\"dog\"] = \"\" is much better as example"
                    },
                    {
                        "username": "fmv2113",
                        "content": "Hi! When I run this code I get time limit exceeded. Can someone explain why? \\n\\nThought process: if I keep a count of the similarities between the first string and every successive string, then I can take the minimum similarity called min, and make the resulting prefix strs[0].substring(0, min); I guess where I could be being extra is through my use of a binary heap to keep the finding min operation to O(1). Please reply with feedback!\\n\\nimport java.util.*;\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if(strs.length==0){\\n            return null;\\n        }\\n\\n\\n        int leftPointer=0;\\n        int rightPointer=0;\\n        int count=0;\\n        PriorityQueue<Integer> minSim = new PriorityQueue<Integer>();\\n\\n        for(int i=1; i<strs.length; i++){ //start from element at index 1 in string array\\n            count=0;\\n            leftPointer=0;\\n            rightPointer=0;\\n            while(leftPointer<strs[0].length() && rightPointer<strs[i].length()){ \\n                if(strs[0].charAt(leftPointer)==strs[i].charAt(rightPointer)){\\n                    count++;\\n                    leftPointer++;\\n                    rightPointer++;\\n                }\\n            }\\n            \\n            minSim.add(count);\\n\\n        }\\n\\n        /*\\n        the minimum similarity count will tell us up to what index we should return\\n        */\\n        int min=0;\\n        if(minSim.peek()!=0){\\n           min = minSim.peek(); \\n        }\\n        String result = strs[0].substring(0,min);\\n\\n        return result;\\n\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1874278,
                "content": [
                    {
                        "username": "satyam__17",
                        "content": "Can anyone explain this. Why is it telling me that its wrong.\n\nInput = [\"flower\",\"flower\",\"flower\",\"flower\"]\noutput = \"flower\"\nexpected = \"flower\"\n"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "try run strlen on it"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below code worked for me,\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size = strs.length;\\n        if (size == 0)\\n            return \"\";\\n \\n        if (size == 1)\\n            return strs[0];\\n \\n        Arrays.sort(strs);\\n\\n        int end = Math.min(strs[0].length(), strs[size-1].length());\\n        int i = 0;\\n        while (i < end && strs[0].charAt(i) == strs[size-1].charAt(i) )\\n            i++;\\n \\n        String pre = strs[0].substring(0, i);\\n        return pre;\\n    }\\n}"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "test case \nstrs = [\"character\",\"scroll\",\"screen\",\"wave\",\"zoo\"]\nwhy the output is \"\" ?\nShould it be \"scr\" ? (longest and common)"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "[@user1886vS](/user1886vS) thanks! I thought it means the popular one. They should explain more haha"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "\"common\" means in all words, in this case only two elements have the prefix \"scr\""
                    },
                    {
                        "username": "amitkr069",
                        "content": "Line 25: Char 5: error: conflicting types for \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n\\nwhat does this mean??"
                    },
                    {
                        "username": "itechman32",
                        "content": "It\\'s asking to find the longest common prefix amongst an array of strings but it doesn\\'t testcases like = [flight, bling, blink, blight, flew]\\ncorrect me if I\\'m wrong but the longest common prefix should be \"bli\" right? but it expects \"\" as result. "
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        strs.sort()\\n        results = \\'\\'\\n        for i, j in zip(strs[0], strs[-1]):\\n            if i == j:\\n                results += j\\n            else:\\n                break\\n        return results\\n```\\nEasier solution with zip\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "GreyDay",
                        "content": "The test cases show my program giving the proper output but says the test failed??"
                    },
                    {
                        "username": "omaimaouahline",
                        "content": "Not sure about [\"a\",\"aca\",\"accb\",\"b\"] Test Case\\ninput:\\nstrs = [\"a\",\"aca\",\"accb\",\"b\"]\\noutput from my solution: \"\"\\nexpected output: \"a\"\\n\\nWhy \"a\" should be outputted here?"
                    },
                    {
                        "username": "wild_report",
                        "content": "class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        x = []\\n        for i in range(len(strs)):\\n            y = set(strs[i])\\n            x.append(y)\\n        for k in range(1,len(x)):\\n            z = x[0].intersection(x[k])\\n        z_list = list(z)\\n        y = \\'\\'.join(z)\\n        return y\\n        \\ni think that  idea is correct but the algorithm doesn\\'t work while on colab it works.."
                    },
                    {
                        "username": "neel19",
                        "content": "I think my solution is pretty neat and concise, have a look at it. [link](https://leetcode.com/problems/longest-common-prefix/submissions/924041227/)"
                    }
                ]
            },
            {
                "id": 1873238,
                "content": [
                    {
                        "username": "satyam__17",
                        "content": "Can anyone explain this. Why is it telling me that its wrong.\n\nInput = [\"flower\",\"flower\",\"flower\",\"flower\"]\noutput = \"flower\"\nexpected = \"flower\"\n"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "try run strlen on it"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below code worked for me,\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size = strs.length;\\n        if (size == 0)\\n            return \"\";\\n \\n        if (size == 1)\\n            return strs[0];\\n \\n        Arrays.sort(strs);\\n\\n        int end = Math.min(strs[0].length(), strs[size-1].length());\\n        int i = 0;\\n        while (i < end && strs[0].charAt(i) == strs[size-1].charAt(i) )\\n            i++;\\n \\n        String pre = strs[0].substring(0, i);\\n        return pre;\\n    }\\n}"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "test case \nstrs = [\"character\",\"scroll\",\"screen\",\"wave\",\"zoo\"]\nwhy the output is \"\" ?\nShould it be \"scr\" ? (longest and common)"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "[@user1886vS](/user1886vS) thanks! I thought it means the popular one. They should explain more haha"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "\"common\" means in all words, in this case only two elements have the prefix \"scr\""
                    },
                    {
                        "username": "amitkr069",
                        "content": "Line 25: Char 5: error: conflicting types for \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n\\nwhat does this mean??"
                    },
                    {
                        "username": "itechman32",
                        "content": "It\\'s asking to find the longest common prefix amongst an array of strings but it doesn\\'t testcases like = [flight, bling, blink, blight, flew]\\ncorrect me if I\\'m wrong but the longest common prefix should be \"bli\" right? but it expects \"\" as result. "
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        strs.sort()\\n        results = \\'\\'\\n        for i, j in zip(strs[0], strs[-1]):\\n            if i == j:\\n                results += j\\n            else:\\n                break\\n        return results\\n```\\nEasier solution with zip\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "GreyDay",
                        "content": "The test cases show my program giving the proper output but says the test failed??"
                    },
                    {
                        "username": "omaimaouahline",
                        "content": "Not sure about [\"a\",\"aca\",\"accb\",\"b\"] Test Case\\ninput:\\nstrs = [\"a\",\"aca\",\"accb\",\"b\"]\\noutput from my solution: \"\"\\nexpected output: \"a\"\\n\\nWhy \"a\" should be outputted here?"
                    },
                    {
                        "username": "wild_report",
                        "content": "class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        x = []\\n        for i in range(len(strs)):\\n            y = set(strs[i])\\n            x.append(y)\\n        for k in range(1,len(x)):\\n            z = x[0].intersection(x[k])\\n        z_list = list(z)\\n        y = \\'\\'.join(z)\\n        return y\\n        \\ni think that  idea is correct but the algorithm doesn\\'t work while on colab it works.."
                    },
                    {
                        "username": "neel19",
                        "content": "I think my solution is pretty neat and concise, have a look at it. [link](https://leetcode.com/problems/longest-common-prefix/submissions/924041227/)"
                    }
                ]
            },
            {
                "id": 1868675,
                "content": [
                    {
                        "username": "satyam__17",
                        "content": "Can anyone explain this. Why is it telling me that its wrong.\n\nInput = [\"flower\",\"flower\",\"flower\",\"flower\"]\noutput = \"flower\"\nexpected = \"flower\"\n"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "try run strlen on it"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below code worked for me,\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size = strs.length;\\n        if (size == 0)\\n            return \"\";\\n \\n        if (size == 1)\\n            return strs[0];\\n \\n        Arrays.sort(strs);\\n\\n        int end = Math.min(strs[0].length(), strs[size-1].length());\\n        int i = 0;\\n        while (i < end && strs[0].charAt(i) == strs[size-1].charAt(i) )\\n            i++;\\n \\n        String pre = strs[0].substring(0, i);\\n        return pre;\\n    }\\n}"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "test case \nstrs = [\"character\",\"scroll\",\"screen\",\"wave\",\"zoo\"]\nwhy the output is \"\" ?\nShould it be \"scr\" ? (longest and common)"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "[@user1886vS](/user1886vS) thanks! I thought it means the popular one. They should explain more haha"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "\"common\" means in all words, in this case only two elements have the prefix \"scr\""
                    },
                    {
                        "username": "amitkr069",
                        "content": "Line 25: Char 5: error: conflicting types for \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n\\nwhat does this mean??"
                    },
                    {
                        "username": "itechman32",
                        "content": "It\\'s asking to find the longest common prefix amongst an array of strings but it doesn\\'t testcases like = [flight, bling, blink, blight, flew]\\ncorrect me if I\\'m wrong but the longest common prefix should be \"bli\" right? but it expects \"\" as result. "
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        strs.sort()\\n        results = \\'\\'\\n        for i, j in zip(strs[0], strs[-1]):\\n            if i == j:\\n                results += j\\n            else:\\n                break\\n        return results\\n```\\nEasier solution with zip\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "GreyDay",
                        "content": "The test cases show my program giving the proper output but says the test failed??"
                    },
                    {
                        "username": "omaimaouahline",
                        "content": "Not sure about [\"a\",\"aca\",\"accb\",\"b\"] Test Case\\ninput:\\nstrs = [\"a\",\"aca\",\"accb\",\"b\"]\\noutput from my solution: \"\"\\nexpected output: \"a\"\\n\\nWhy \"a\" should be outputted here?"
                    },
                    {
                        "username": "wild_report",
                        "content": "class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        x = []\\n        for i in range(len(strs)):\\n            y = set(strs[i])\\n            x.append(y)\\n        for k in range(1,len(x)):\\n            z = x[0].intersection(x[k])\\n        z_list = list(z)\\n        y = \\'\\'.join(z)\\n        return y\\n        \\ni think that  idea is correct but the algorithm doesn\\'t work while on colab it works.."
                    },
                    {
                        "username": "neel19",
                        "content": "I think my solution is pretty neat and concise, have a look at it. [link](https://leetcode.com/problems/longest-common-prefix/submissions/924041227/)"
                    }
                ]
            },
            {
                "id": 1861679,
                "content": [
                    {
                        "username": "satyam__17",
                        "content": "Can anyone explain this. Why is it telling me that its wrong.\n\nInput = [\"flower\",\"flower\",\"flower\",\"flower\"]\noutput = \"flower\"\nexpected = \"flower\"\n"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "try run strlen on it"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below code worked for me,\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size = strs.length;\\n        if (size == 0)\\n            return \"\";\\n \\n        if (size == 1)\\n            return strs[0];\\n \\n        Arrays.sort(strs);\\n\\n        int end = Math.min(strs[0].length(), strs[size-1].length());\\n        int i = 0;\\n        while (i < end && strs[0].charAt(i) == strs[size-1].charAt(i) )\\n            i++;\\n \\n        String pre = strs[0].substring(0, i);\\n        return pre;\\n    }\\n}"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "test case \nstrs = [\"character\",\"scroll\",\"screen\",\"wave\",\"zoo\"]\nwhy the output is \"\" ?\nShould it be \"scr\" ? (longest and common)"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "[@user1886vS](/user1886vS) thanks! I thought it means the popular one. They should explain more haha"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "\"common\" means in all words, in this case only two elements have the prefix \"scr\""
                    },
                    {
                        "username": "amitkr069",
                        "content": "Line 25: Char 5: error: conflicting types for \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n\\nwhat does this mean??"
                    },
                    {
                        "username": "itechman32",
                        "content": "It\\'s asking to find the longest common prefix amongst an array of strings but it doesn\\'t testcases like = [flight, bling, blink, blight, flew]\\ncorrect me if I\\'m wrong but the longest common prefix should be \"bli\" right? but it expects \"\" as result. "
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        strs.sort()\\n        results = \\'\\'\\n        for i, j in zip(strs[0], strs[-1]):\\n            if i == j:\\n                results += j\\n            else:\\n                break\\n        return results\\n```\\nEasier solution with zip\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "GreyDay",
                        "content": "The test cases show my program giving the proper output but says the test failed??"
                    },
                    {
                        "username": "omaimaouahline",
                        "content": "Not sure about [\"a\",\"aca\",\"accb\",\"b\"] Test Case\\ninput:\\nstrs = [\"a\",\"aca\",\"accb\",\"b\"]\\noutput from my solution: \"\"\\nexpected output: \"a\"\\n\\nWhy \"a\" should be outputted here?"
                    },
                    {
                        "username": "wild_report",
                        "content": "class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        x = []\\n        for i in range(len(strs)):\\n            y = set(strs[i])\\n            x.append(y)\\n        for k in range(1,len(x)):\\n            z = x[0].intersection(x[k])\\n        z_list = list(z)\\n        y = \\'\\'.join(z)\\n        return y\\n        \\ni think that  idea is correct but the algorithm doesn\\'t work while on colab it works.."
                    },
                    {
                        "username": "neel19",
                        "content": "I think my solution is pretty neat and concise, have a look at it. [link](https://leetcode.com/problems/longest-common-prefix/submissions/924041227/)"
                    }
                ]
            },
            {
                "id": 1859803,
                "content": [
                    {
                        "username": "satyam__17",
                        "content": "Can anyone explain this. Why is it telling me that its wrong.\n\nInput = [\"flower\",\"flower\",\"flower\",\"flower\"]\noutput = \"flower\"\nexpected = \"flower\"\n"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "try run strlen on it"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below code worked for me,\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size = strs.length;\\n        if (size == 0)\\n            return \"\";\\n \\n        if (size == 1)\\n            return strs[0];\\n \\n        Arrays.sort(strs);\\n\\n        int end = Math.min(strs[0].length(), strs[size-1].length());\\n        int i = 0;\\n        while (i < end && strs[0].charAt(i) == strs[size-1].charAt(i) )\\n            i++;\\n \\n        String pre = strs[0].substring(0, i);\\n        return pre;\\n    }\\n}"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "test case \nstrs = [\"character\",\"scroll\",\"screen\",\"wave\",\"zoo\"]\nwhy the output is \"\" ?\nShould it be \"scr\" ? (longest and common)"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "[@user1886vS](/user1886vS) thanks! I thought it means the popular one. They should explain more haha"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "\"common\" means in all words, in this case only two elements have the prefix \"scr\""
                    },
                    {
                        "username": "amitkr069",
                        "content": "Line 25: Char 5: error: conflicting types for \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n\\nwhat does this mean??"
                    },
                    {
                        "username": "itechman32",
                        "content": "It\\'s asking to find the longest common prefix amongst an array of strings but it doesn\\'t testcases like = [flight, bling, blink, blight, flew]\\ncorrect me if I\\'m wrong but the longest common prefix should be \"bli\" right? but it expects \"\" as result. "
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        strs.sort()\\n        results = \\'\\'\\n        for i, j in zip(strs[0], strs[-1]):\\n            if i == j:\\n                results += j\\n            else:\\n                break\\n        return results\\n```\\nEasier solution with zip\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "GreyDay",
                        "content": "The test cases show my program giving the proper output but says the test failed??"
                    },
                    {
                        "username": "omaimaouahline",
                        "content": "Not sure about [\"a\",\"aca\",\"accb\",\"b\"] Test Case\\ninput:\\nstrs = [\"a\",\"aca\",\"accb\",\"b\"]\\noutput from my solution: \"\"\\nexpected output: \"a\"\\n\\nWhy \"a\" should be outputted here?"
                    },
                    {
                        "username": "wild_report",
                        "content": "class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        x = []\\n        for i in range(len(strs)):\\n            y = set(strs[i])\\n            x.append(y)\\n        for k in range(1,len(x)):\\n            z = x[0].intersection(x[k])\\n        z_list = list(z)\\n        y = \\'\\'.join(z)\\n        return y\\n        \\ni think that  idea is correct but the algorithm doesn\\'t work while on colab it works.."
                    },
                    {
                        "username": "neel19",
                        "content": "I think my solution is pretty neat and concise, have a look at it. [link](https://leetcode.com/problems/longest-common-prefix/submissions/924041227/)"
                    }
                ]
            },
            {
                "id": 1857632,
                "content": [
                    {
                        "username": "satyam__17",
                        "content": "Can anyone explain this. Why is it telling me that its wrong.\n\nInput = [\"flower\",\"flower\",\"flower\",\"flower\"]\noutput = \"flower\"\nexpected = \"flower\"\n"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "try run strlen on it"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below code worked for me,\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size = strs.length;\\n        if (size == 0)\\n            return \"\";\\n \\n        if (size == 1)\\n            return strs[0];\\n \\n        Arrays.sort(strs);\\n\\n        int end = Math.min(strs[0].length(), strs[size-1].length());\\n        int i = 0;\\n        while (i < end && strs[0].charAt(i) == strs[size-1].charAt(i) )\\n            i++;\\n \\n        String pre = strs[0].substring(0, i);\\n        return pre;\\n    }\\n}"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "test case \nstrs = [\"character\",\"scroll\",\"screen\",\"wave\",\"zoo\"]\nwhy the output is \"\" ?\nShould it be \"scr\" ? (longest and common)"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "[@user1886vS](/user1886vS) thanks! I thought it means the popular one. They should explain more haha"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "\"common\" means in all words, in this case only two elements have the prefix \"scr\""
                    },
                    {
                        "username": "amitkr069",
                        "content": "Line 25: Char 5: error: conflicting types for \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n\\nwhat does this mean??"
                    },
                    {
                        "username": "itechman32",
                        "content": "It\\'s asking to find the longest common prefix amongst an array of strings but it doesn\\'t testcases like = [flight, bling, blink, blight, flew]\\ncorrect me if I\\'m wrong but the longest common prefix should be \"bli\" right? but it expects \"\" as result. "
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        strs.sort()\\n        results = \\'\\'\\n        for i, j in zip(strs[0], strs[-1]):\\n            if i == j:\\n                results += j\\n            else:\\n                break\\n        return results\\n```\\nEasier solution with zip\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "GreyDay",
                        "content": "The test cases show my program giving the proper output but says the test failed??"
                    },
                    {
                        "username": "omaimaouahline",
                        "content": "Not sure about [\"a\",\"aca\",\"accb\",\"b\"] Test Case\\ninput:\\nstrs = [\"a\",\"aca\",\"accb\",\"b\"]\\noutput from my solution: \"\"\\nexpected output: \"a\"\\n\\nWhy \"a\" should be outputted here?"
                    },
                    {
                        "username": "wild_report",
                        "content": "class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        x = []\\n        for i in range(len(strs)):\\n            y = set(strs[i])\\n            x.append(y)\\n        for k in range(1,len(x)):\\n            z = x[0].intersection(x[k])\\n        z_list = list(z)\\n        y = \\'\\'.join(z)\\n        return y\\n        \\ni think that  idea is correct but the algorithm doesn\\'t work while on colab it works.."
                    },
                    {
                        "username": "neel19",
                        "content": "I think my solution is pretty neat and concise, have a look at it. [link](https://leetcode.com/problems/longest-common-prefix/submissions/924041227/)"
                    }
                ]
            },
            {
                "id": 1857009,
                "content": [
                    {
                        "username": "satyam__17",
                        "content": "Can anyone explain this. Why is it telling me that its wrong.\n\nInput = [\"flower\",\"flower\",\"flower\",\"flower\"]\noutput = \"flower\"\nexpected = \"flower\"\n"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "try run strlen on it"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below code worked for me,\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size = strs.length;\\n        if (size == 0)\\n            return \"\";\\n \\n        if (size == 1)\\n            return strs[0];\\n \\n        Arrays.sort(strs);\\n\\n        int end = Math.min(strs[0].length(), strs[size-1].length());\\n        int i = 0;\\n        while (i < end && strs[0].charAt(i) == strs[size-1].charAt(i) )\\n            i++;\\n \\n        String pre = strs[0].substring(0, i);\\n        return pre;\\n    }\\n}"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "test case \nstrs = [\"character\",\"scroll\",\"screen\",\"wave\",\"zoo\"]\nwhy the output is \"\" ?\nShould it be \"scr\" ? (longest and common)"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "[@user1886vS](/user1886vS) thanks! I thought it means the popular one. They should explain more haha"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "\"common\" means in all words, in this case only two elements have the prefix \"scr\""
                    },
                    {
                        "username": "amitkr069",
                        "content": "Line 25: Char 5: error: conflicting types for \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n\\nwhat does this mean??"
                    },
                    {
                        "username": "itechman32",
                        "content": "It\\'s asking to find the longest common prefix amongst an array of strings but it doesn\\'t testcases like = [flight, bling, blink, blight, flew]\\ncorrect me if I\\'m wrong but the longest common prefix should be \"bli\" right? but it expects \"\" as result. "
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        strs.sort()\\n        results = \\'\\'\\n        for i, j in zip(strs[0], strs[-1]):\\n            if i == j:\\n                results += j\\n            else:\\n                break\\n        return results\\n```\\nEasier solution with zip\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "GreyDay",
                        "content": "The test cases show my program giving the proper output but says the test failed??"
                    },
                    {
                        "username": "omaimaouahline",
                        "content": "Not sure about [\"a\",\"aca\",\"accb\",\"b\"] Test Case\\ninput:\\nstrs = [\"a\",\"aca\",\"accb\",\"b\"]\\noutput from my solution: \"\"\\nexpected output: \"a\"\\n\\nWhy \"a\" should be outputted here?"
                    },
                    {
                        "username": "wild_report",
                        "content": "class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        x = []\\n        for i in range(len(strs)):\\n            y = set(strs[i])\\n            x.append(y)\\n        for k in range(1,len(x)):\\n            z = x[0].intersection(x[k])\\n        z_list = list(z)\\n        y = \\'\\'.join(z)\\n        return y\\n        \\ni think that  idea is correct but the algorithm doesn\\'t work while on colab it works.."
                    },
                    {
                        "username": "neel19",
                        "content": "I think my solution is pretty neat and concise, have a look at it. [link](https://leetcode.com/problems/longest-common-prefix/submissions/924041227/)"
                    }
                ]
            },
            {
                "id": 1856732,
                "content": [
                    {
                        "username": "satyam__17",
                        "content": "Can anyone explain this. Why is it telling me that its wrong.\n\nInput = [\"flower\",\"flower\",\"flower\",\"flower\"]\noutput = \"flower\"\nexpected = \"flower\"\n"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "try run strlen on it"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below code worked for me,\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size = strs.length;\\n        if (size == 0)\\n            return \"\";\\n \\n        if (size == 1)\\n            return strs[0];\\n \\n        Arrays.sort(strs);\\n\\n        int end = Math.min(strs[0].length(), strs[size-1].length());\\n        int i = 0;\\n        while (i < end && strs[0].charAt(i) == strs[size-1].charAt(i) )\\n            i++;\\n \\n        String pre = strs[0].substring(0, i);\\n        return pre;\\n    }\\n}"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "test case \nstrs = [\"character\",\"scroll\",\"screen\",\"wave\",\"zoo\"]\nwhy the output is \"\" ?\nShould it be \"scr\" ? (longest and common)"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "[@user1886vS](/user1886vS) thanks! I thought it means the popular one. They should explain more haha"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "\"common\" means in all words, in this case only two elements have the prefix \"scr\""
                    },
                    {
                        "username": "amitkr069",
                        "content": "Line 25: Char 5: error: conflicting types for \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n\\nwhat does this mean??"
                    },
                    {
                        "username": "itechman32",
                        "content": "It\\'s asking to find the longest common prefix amongst an array of strings but it doesn\\'t testcases like = [flight, bling, blink, blight, flew]\\ncorrect me if I\\'m wrong but the longest common prefix should be \"bli\" right? but it expects \"\" as result. "
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        strs.sort()\\n        results = \\'\\'\\n        for i, j in zip(strs[0], strs[-1]):\\n            if i == j:\\n                results += j\\n            else:\\n                break\\n        return results\\n```\\nEasier solution with zip\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "GreyDay",
                        "content": "The test cases show my program giving the proper output but says the test failed??"
                    },
                    {
                        "username": "omaimaouahline",
                        "content": "Not sure about [\"a\",\"aca\",\"accb\",\"b\"] Test Case\\ninput:\\nstrs = [\"a\",\"aca\",\"accb\",\"b\"]\\noutput from my solution: \"\"\\nexpected output: \"a\"\\n\\nWhy \"a\" should be outputted here?"
                    },
                    {
                        "username": "wild_report",
                        "content": "class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        x = []\\n        for i in range(len(strs)):\\n            y = set(strs[i])\\n            x.append(y)\\n        for k in range(1,len(x)):\\n            z = x[0].intersection(x[k])\\n        z_list = list(z)\\n        y = \\'\\'.join(z)\\n        return y\\n        \\ni think that  idea is correct but the algorithm doesn\\'t work while on colab it works.."
                    },
                    {
                        "username": "neel19",
                        "content": "I think my solution is pretty neat and concise, have a look at it. [link](https://leetcode.com/problems/longest-common-prefix/submissions/924041227/)"
                    }
                ]
            },
            {
                "id": 1851865,
                "content": [
                    {
                        "username": "satyam__17",
                        "content": "Can anyone explain this. Why is it telling me that its wrong.\n\nInput = [\"flower\",\"flower\",\"flower\",\"flower\"]\noutput = \"flower\"\nexpected = \"flower\"\n"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "try run strlen on it"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below code worked for me,\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size = strs.length;\\n        if (size == 0)\\n            return \"\";\\n \\n        if (size == 1)\\n            return strs[0];\\n \\n        Arrays.sort(strs);\\n\\n        int end = Math.min(strs[0].length(), strs[size-1].length());\\n        int i = 0;\\n        while (i < end && strs[0].charAt(i) == strs[size-1].charAt(i) )\\n            i++;\\n \\n        String pre = strs[0].substring(0, i);\\n        return pre;\\n    }\\n}"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "test case \nstrs = [\"character\",\"scroll\",\"screen\",\"wave\",\"zoo\"]\nwhy the output is \"\" ?\nShould it be \"scr\" ? (longest and common)"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "[@user1886vS](/user1886vS) thanks! I thought it means the popular one. They should explain more haha"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "\"common\" means in all words, in this case only two elements have the prefix \"scr\""
                    },
                    {
                        "username": "amitkr069",
                        "content": "Line 25: Char 5: error: conflicting types for \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n\\nwhat does this mean??"
                    },
                    {
                        "username": "itechman32",
                        "content": "It\\'s asking to find the longest common prefix amongst an array of strings but it doesn\\'t testcases like = [flight, bling, blink, blight, flew]\\ncorrect me if I\\'m wrong but the longest common prefix should be \"bli\" right? but it expects \"\" as result. "
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        strs.sort()\\n        results = \\'\\'\\n        for i, j in zip(strs[0], strs[-1]):\\n            if i == j:\\n                results += j\\n            else:\\n                break\\n        return results\\n```\\nEasier solution with zip\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "GreyDay",
                        "content": "The test cases show my program giving the proper output but says the test failed??"
                    },
                    {
                        "username": "omaimaouahline",
                        "content": "Not sure about [\"a\",\"aca\",\"accb\",\"b\"] Test Case\\ninput:\\nstrs = [\"a\",\"aca\",\"accb\",\"b\"]\\noutput from my solution: \"\"\\nexpected output: \"a\"\\n\\nWhy \"a\" should be outputted here?"
                    },
                    {
                        "username": "wild_report",
                        "content": "class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        x = []\\n        for i in range(len(strs)):\\n            y = set(strs[i])\\n            x.append(y)\\n        for k in range(1,len(x)):\\n            z = x[0].intersection(x[k])\\n        z_list = list(z)\\n        y = \\'\\'.join(z)\\n        return y\\n        \\ni think that  idea is correct but the algorithm doesn\\'t work while on colab it works.."
                    },
                    {
                        "username": "neel19",
                        "content": "I think my solution is pretty neat and concise, have a look at it. [link](https://leetcode.com/problems/longest-common-prefix/submissions/924041227/)"
                    }
                ]
            },
            {
                "id": 1846936,
                "content": [
                    {
                        "username": "satyam__17",
                        "content": "Can anyone explain this. Why is it telling me that its wrong.\n\nInput = [\"flower\",\"flower\",\"flower\",\"flower\"]\noutput = \"flower\"\nexpected = \"flower\"\n"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "try run strlen on it"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below code worked for me,\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size = strs.length;\\n        if (size == 0)\\n            return \"\";\\n \\n        if (size == 1)\\n            return strs[0];\\n \\n        Arrays.sort(strs);\\n\\n        int end = Math.min(strs[0].length(), strs[size-1].length());\\n        int i = 0;\\n        while (i < end && strs[0].charAt(i) == strs[size-1].charAt(i) )\\n            i++;\\n \\n        String pre = strs[0].substring(0, i);\\n        return pre;\\n    }\\n}"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "test case \nstrs = [\"character\",\"scroll\",\"screen\",\"wave\",\"zoo\"]\nwhy the output is \"\" ?\nShould it be \"scr\" ? (longest and common)"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "[@user1886vS](/user1886vS) thanks! I thought it means the popular one. They should explain more haha"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "\"common\" means in all words, in this case only two elements have the prefix \"scr\""
                    },
                    {
                        "username": "amitkr069",
                        "content": "Line 25: Char 5: error: conflicting types for \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n\\nwhat does this mean??"
                    },
                    {
                        "username": "itechman32",
                        "content": "It\\'s asking to find the longest common prefix amongst an array of strings but it doesn\\'t testcases like = [flight, bling, blink, blight, flew]\\ncorrect me if I\\'m wrong but the longest common prefix should be \"bli\" right? but it expects \"\" as result. "
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        strs.sort()\\n        results = \\'\\'\\n        for i, j in zip(strs[0], strs[-1]):\\n            if i == j:\\n                results += j\\n            else:\\n                break\\n        return results\\n```\\nEasier solution with zip\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "GreyDay",
                        "content": "The test cases show my program giving the proper output but says the test failed??"
                    },
                    {
                        "username": "omaimaouahline",
                        "content": "Not sure about [\"a\",\"aca\",\"accb\",\"b\"] Test Case\\ninput:\\nstrs = [\"a\",\"aca\",\"accb\",\"b\"]\\noutput from my solution: \"\"\\nexpected output: \"a\"\\n\\nWhy \"a\" should be outputted here?"
                    },
                    {
                        "username": "wild_report",
                        "content": "class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        x = []\\n        for i in range(len(strs)):\\n            y = set(strs[i])\\n            x.append(y)\\n        for k in range(1,len(x)):\\n            z = x[0].intersection(x[k])\\n        z_list = list(z)\\n        y = \\'\\'.join(z)\\n        return y\\n        \\ni think that  idea is correct but the algorithm doesn\\'t work while on colab it works.."
                    },
                    {
                        "username": "neel19",
                        "content": "I think my solution is pretty neat and concise, have a look at it. [link](https://leetcode.com/problems/longest-common-prefix/submissions/924041227/)"
                    }
                ]
            },
            {
                "id": 1845152,
                "content": [
                    {
                        "username": "Loomman1",
                        "content": "Should be \"common prefix for EACH string\" - it gets clearer so"
                    },
                    {
                        "username": "user5378Ua",
                        "content": "Testcase 109 \\n[\"reflower\",\"flow\",\"flight\"]\\nOutput\\n\"fl\"\\nExpected\\n\"\"\\n\\nWhy?"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "\"fl\" is not a prefix for \"reflower\". Apparently, what the question is asking for is a common prefix for ALL strings within the list (even though this isn\\'t explicitly stated)"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I was reading through the comments, and it seems like the test case of [\"reflower\",\"flow\",\"flight\"] threw everyone off.\\n\\nThe question is so poorly worded. It asked for the most common prefix amongst an array of strings, and mentioned nothing about the prefix having to be common among **all strings**, which is what it actually wanted. Can\\'t fault someone for coding it wrongly.\\n\\n(Another test case that threw me off was the case of [\\'a\\']. When there\\'s only one item in the list, I don\\'t think you can call it \\'most common\\', but at least this is a bit more open to interpretation)"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized solution with sort crisp code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nknow sorting in 2-d matrix in a deepth way\\n\\nApproach\\nuse 2-d matrix soting property\\n\\nComplexity\\nTime complexity:\\n0(nmlog(nm))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n\\n        string ans=\"\";\\n        sort( strs.begin() , strs.end());\\n        int n = strs.size();\\n        \\n        for( int i=0 ; i<strs[0].length() ; i++)\\n        { \\n        if(strs[0][i]!=strs[n-1][i])\\n        {\\n             return ans;\\n        }\\n        ans.push_back(strs[0][i]);\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "marina_eremina",
                        "content": ">strs[i] consists of only lowercase English letters.\n\n> Testcase: strs = [\"\",\"b\"]\n\nwtf? "
                    },
                    {
                        "username": "lukkyz",
                        "content": "I have a problem with empty string input :\\nInput :\\n[\"\"]\\nOutput\\n\"\"\\nExpected\\n\"\"\\nI have the good output but it don\\'t validate, can you help me ?"
                    },
                    {
                        "username": "sayli1",
                        "content": "How is the Time Complexity for horizontal scanning method = O(N) where N is sum of all characters in all strings ?"
                    },
                    {
                        "username": "03282013ah",
                        "content": "This is hard\\n"
                    },
                    {
                        "username": "dalvsmerk",
                        "content": "Looks like it is expected that each of the string in an array would have common prefix.\n\nI have run these test cases:\n```\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\",\"dog\"] -> \"\"\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\"] -> \"str\"\n```\n"
                    },
                    {
                        "username": "chypso",
                        "content": "Hello. I have question not so much about code but more about logic. \\nif input is \"a\" (ONLY)\\nis correct answer \"a\" or \"\" ?"
                    },
                    {
                        "username": "CT-7567",
                        "content": "\"a\""
                    }
                ]
            },
            {
                "id": 1843167,
                "content": [
                    {
                        "username": "Loomman1",
                        "content": "Should be \"common prefix for EACH string\" - it gets clearer so"
                    },
                    {
                        "username": "user5378Ua",
                        "content": "Testcase 109 \\n[\"reflower\",\"flow\",\"flight\"]\\nOutput\\n\"fl\"\\nExpected\\n\"\"\\n\\nWhy?"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "\"fl\" is not a prefix for \"reflower\". Apparently, what the question is asking for is a common prefix for ALL strings within the list (even though this isn\\'t explicitly stated)"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I was reading through the comments, and it seems like the test case of [\"reflower\",\"flow\",\"flight\"] threw everyone off.\\n\\nThe question is so poorly worded. It asked for the most common prefix amongst an array of strings, and mentioned nothing about the prefix having to be common among **all strings**, which is what it actually wanted. Can\\'t fault someone for coding it wrongly.\\n\\n(Another test case that threw me off was the case of [\\'a\\']. When there\\'s only one item in the list, I don\\'t think you can call it \\'most common\\', but at least this is a bit more open to interpretation)"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized solution with sort crisp code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nknow sorting in 2-d matrix in a deepth way\\n\\nApproach\\nuse 2-d matrix soting property\\n\\nComplexity\\nTime complexity:\\n0(nmlog(nm))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n\\n        string ans=\"\";\\n        sort( strs.begin() , strs.end());\\n        int n = strs.size();\\n        \\n        for( int i=0 ; i<strs[0].length() ; i++)\\n        { \\n        if(strs[0][i]!=strs[n-1][i])\\n        {\\n             return ans;\\n        }\\n        ans.push_back(strs[0][i]);\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "marina_eremina",
                        "content": ">strs[i] consists of only lowercase English letters.\n\n> Testcase: strs = [\"\",\"b\"]\n\nwtf? "
                    },
                    {
                        "username": "lukkyz",
                        "content": "I have a problem with empty string input :\\nInput :\\n[\"\"]\\nOutput\\n\"\"\\nExpected\\n\"\"\\nI have the good output but it don\\'t validate, can you help me ?"
                    },
                    {
                        "username": "sayli1",
                        "content": "How is the Time Complexity for horizontal scanning method = O(N) where N is sum of all characters in all strings ?"
                    },
                    {
                        "username": "03282013ah",
                        "content": "This is hard\\n"
                    },
                    {
                        "username": "dalvsmerk",
                        "content": "Looks like it is expected that each of the string in an array would have common prefix.\n\nI have run these test cases:\n```\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\",\"dog\"] -> \"\"\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\"] -> \"str\"\n```\n"
                    },
                    {
                        "username": "chypso",
                        "content": "Hello. I have question not so much about code but more about logic. \\nif input is \"a\" (ONLY)\\nis correct answer \"a\" or \"\" ?"
                    },
                    {
                        "username": "CT-7567",
                        "content": "\"a\""
                    }
                ]
            },
            {
                "id": 1842345,
                "content": [
                    {
                        "username": "Loomman1",
                        "content": "Should be \"common prefix for EACH string\" - it gets clearer so"
                    },
                    {
                        "username": "user5378Ua",
                        "content": "Testcase 109 \\n[\"reflower\",\"flow\",\"flight\"]\\nOutput\\n\"fl\"\\nExpected\\n\"\"\\n\\nWhy?"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "\"fl\" is not a prefix for \"reflower\". Apparently, what the question is asking for is a common prefix for ALL strings within the list (even though this isn\\'t explicitly stated)"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I was reading through the comments, and it seems like the test case of [\"reflower\",\"flow\",\"flight\"] threw everyone off.\\n\\nThe question is so poorly worded. It asked for the most common prefix amongst an array of strings, and mentioned nothing about the prefix having to be common among **all strings**, which is what it actually wanted. Can\\'t fault someone for coding it wrongly.\\n\\n(Another test case that threw me off was the case of [\\'a\\']. When there\\'s only one item in the list, I don\\'t think you can call it \\'most common\\', but at least this is a bit more open to interpretation)"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized solution with sort crisp code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nknow sorting in 2-d matrix in a deepth way\\n\\nApproach\\nuse 2-d matrix soting property\\n\\nComplexity\\nTime complexity:\\n0(nmlog(nm))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n\\n        string ans=\"\";\\n        sort( strs.begin() , strs.end());\\n        int n = strs.size();\\n        \\n        for( int i=0 ; i<strs[0].length() ; i++)\\n        { \\n        if(strs[0][i]!=strs[n-1][i])\\n        {\\n             return ans;\\n        }\\n        ans.push_back(strs[0][i]);\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "marina_eremina",
                        "content": ">strs[i] consists of only lowercase English letters.\n\n> Testcase: strs = [\"\",\"b\"]\n\nwtf? "
                    },
                    {
                        "username": "lukkyz",
                        "content": "I have a problem with empty string input :\\nInput :\\n[\"\"]\\nOutput\\n\"\"\\nExpected\\n\"\"\\nI have the good output but it don\\'t validate, can you help me ?"
                    },
                    {
                        "username": "sayli1",
                        "content": "How is the Time Complexity for horizontal scanning method = O(N) where N is sum of all characters in all strings ?"
                    },
                    {
                        "username": "03282013ah",
                        "content": "This is hard\\n"
                    },
                    {
                        "username": "dalvsmerk",
                        "content": "Looks like it is expected that each of the string in an array would have common prefix.\n\nI have run these test cases:\n```\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\",\"dog\"] -> \"\"\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\"] -> \"str\"\n```\n"
                    },
                    {
                        "username": "chypso",
                        "content": "Hello. I have question not so much about code but more about logic. \\nif input is \"a\" (ONLY)\\nis correct answer \"a\" or \"\" ?"
                    },
                    {
                        "username": "CT-7567",
                        "content": "\"a\""
                    }
                ]
            },
            {
                "id": 1840829,
                "content": [
                    {
                        "username": "Loomman1",
                        "content": "Should be \"common prefix for EACH string\" - it gets clearer so"
                    },
                    {
                        "username": "user5378Ua",
                        "content": "Testcase 109 \\n[\"reflower\",\"flow\",\"flight\"]\\nOutput\\n\"fl\"\\nExpected\\n\"\"\\n\\nWhy?"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "\"fl\" is not a prefix for \"reflower\". Apparently, what the question is asking for is a common prefix for ALL strings within the list (even though this isn\\'t explicitly stated)"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I was reading through the comments, and it seems like the test case of [\"reflower\",\"flow\",\"flight\"] threw everyone off.\\n\\nThe question is so poorly worded. It asked for the most common prefix amongst an array of strings, and mentioned nothing about the prefix having to be common among **all strings**, which is what it actually wanted. Can\\'t fault someone for coding it wrongly.\\n\\n(Another test case that threw me off was the case of [\\'a\\']. When there\\'s only one item in the list, I don\\'t think you can call it \\'most common\\', but at least this is a bit more open to interpretation)"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized solution with sort crisp code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nknow sorting in 2-d matrix in a deepth way\\n\\nApproach\\nuse 2-d matrix soting property\\n\\nComplexity\\nTime complexity:\\n0(nmlog(nm))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n\\n        string ans=\"\";\\n        sort( strs.begin() , strs.end());\\n        int n = strs.size();\\n        \\n        for( int i=0 ; i<strs[0].length() ; i++)\\n        { \\n        if(strs[0][i]!=strs[n-1][i])\\n        {\\n             return ans;\\n        }\\n        ans.push_back(strs[0][i]);\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "marina_eremina",
                        "content": ">strs[i] consists of only lowercase English letters.\n\n> Testcase: strs = [\"\",\"b\"]\n\nwtf? "
                    },
                    {
                        "username": "lukkyz",
                        "content": "I have a problem with empty string input :\\nInput :\\n[\"\"]\\nOutput\\n\"\"\\nExpected\\n\"\"\\nI have the good output but it don\\'t validate, can you help me ?"
                    },
                    {
                        "username": "sayli1",
                        "content": "How is the Time Complexity for horizontal scanning method = O(N) where N is sum of all characters in all strings ?"
                    },
                    {
                        "username": "03282013ah",
                        "content": "This is hard\\n"
                    },
                    {
                        "username": "dalvsmerk",
                        "content": "Looks like it is expected that each of the string in an array would have common prefix.\n\nI have run these test cases:\n```\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\",\"dog\"] -> \"\"\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\"] -> \"str\"\n```\n"
                    },
                    {
                        "username": "chypso",
                        "content": "Hello. I have question not so much about code but more about logic. \\nif input is \"a\" (ONLY)\\nis correct answer \"a\" or \"\" ?"
                    },
                    {
                        "username": "CT-7567",
                        "content": "\"a\""
                    }
                ]
            },
            {
                "id": 1838850,
                "content": [
                    {
                        "username": "Loomman1",
                        "content": "Should be \"common prefix for EACH string\" - it gets clearer so"
                    },
                    {
                        "username": "user5378Ua",
                        "content": "Testcase 109 \\n[\"reflower\",\"flow\",\"flight\"]\\nOutput\\n\"fl\"\\nExpected\\n\"\"\\n\\nWhy?"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "\"fl\" is not a prefix for \"reflower\". Apparently, what the question is asking for is a common prefix for ALL strings within the list (even though this isn\\'t explicitly stated)"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I was reading through the comments, and it seems like the test case of [\"reflower\",\"flow\",\"flight\"] threw everyone off.\\n\\nThe question is so poorly worded. It asked for the most common prefix amongst an array of strings, and mentioned nothing about the prefix having to be common among **all strings**, which is what it actually wanted. Can\\'t fault someone for coding it wrongly.\\n\\n(Another test case that threw me off was the case of [\\'a\\']. When there\\'s only one item in the list, I don\\'t think you can call it \\'most common\\', but at least this is a bit more open to interpretation)"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized solution with sort crisp code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nknow sorting in 2-d matrix in a deepth way\\n\\nApproach\\nuse 2-d matrix soting property\\n\\nComplexity\\nTime complexity:\\n0(nmlog(nm))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n\\n        string ans=\"\";\\n        sort( strs.begin() , strs.end());\\n        int n = strs.size();\\n        \\n        for( int i=0 ; i<strs[0].length() ; i++)\\n        { \\n        if(strs[0][i]!=strs[n-1][i])\\n        {\\n             return ans;\\n        }\\n        ans.push_back(strs[0][i]);\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "marina_eremina",
                        "content": ">strs[i] consists of only lowercase English letters.\n\n> Testcase: strs = [\"\",\"b\"]\n\nwtf? "
                    },
                    {
                        "username": "lukkyz",
                        "content": "I have a problem with empty string input :\\nInput :\\n[\"\"]\\nOutput\\n\"\"\\nExpected\\n\"\"\\nI have the good output but it don\\'t validate, can you help me ?"
                    },
                    {
                        "username": "sayli1",
                        "content": "How is the Time Complexity for horizontal scanning method = O(N) where N is sum of all characters in all strings ?"
                    },
                    {
                        "username": "03282013ah",
                        "content": "This is hard\\n"
                    },
                    {
                        "username": "dalvsmerk",
                        "content": "Looks like it is expected that each of the string in an array would have common prefix.\n\nI have run these test cases:\n```\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\",\"dog\"] -> \"\"\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\"] -> \"str\"\n```\n"
                    },
                    {
                        "username": "chypso",
                        "content": "Hello. I have question not so much about code but more about logic. \\nif input is \"a\" (ONLY)\\nis correct answer \"a\" or \"\" ?"
                    },
                    {
                        "username": "CT-7567",
                        "content": "\"a\""
                    }
                ]
            },
            {
                "id": 1833617,
                "content": [
                    {
                        "username": "Loomman1",
                        "content": "Should be \"common prefix for EACH string\" - it gets clearer so"
                    },
                    {
                        "username": "user5378Ua",
                        "content": "Testcase 109 \\n[\"reflower\",\"flow\",\"flight\"]\\nOutput\\n\"fl\"\\nExpected\\n\"\"\\n\\nWhy?"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "\"fl\" is not a prefix for \"reflower\". Apparently, what the question is asking for is a common prefix for ALL strings within the list (even though this isn\\'t explicitly stated)"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I was reading through the comments, and it seems like the test case of [\"reflower\",\"flow\",\"flight\"] threw everyone off.\\n\\nThe question is so poorly worded. It asked for the most common prefix amongst an array of strings, and mentioned nothing about the prefix having to be common among **all strings**, which is what it actually wanted. Can\\'t fault someone for coding it wrongly.\\n\\n(Another test case that threw me off was the case of [\\'a\\']. When there\\'s only one item in the list, I don\\'t think you can call it \\'most common\\', but at least this is a bit more open to interpretation)"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized solution with sort crisp code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nknow sorting in 2-d matrix in a deepth way\\n\\nApproach\\nuse 2-d matrix soting property\\n\\nComplexity\\nTime complexity:\\n0(nmlog(nm))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n\\n        string ans=\"\";\\n        sort( strs.begin() , strs.end());\\n        int n = strs.size();\\n        \\n        for( int i=0 ; i<strs[0].length() ; i++)\\n        { \\n        if(strs[0][i]!=strs[n-1][i])\\n        {\\n             return ans;\\n        }\\n        ans.push_back(strs[0][i]);\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "marina_eremina",
                        "content": ">strs[i] consists of only lowercase English letters.\n\n> Testcase: strs = [\"\",\"b\"]\n\nwtf? "
                    },
                    {
                        "username": "lukkyz",
                        "content": "I have a problem with empty string input :\\nInput :\\n[\"\"]\\nOutput\\n\"\"\\nExpected\\n\"\"\\nI have the good output but it don\\'t validate, can you help me ?"
                    },
                    {
                        "username": "sayli1",
                        "content": "How is the Time Complexity for horizontal scanning method = O(N) where N is sum of all characters in all strings ?"
                    },
                    {
                        "username": "03282013ah",
                        "content": "This is hard\\n"
                    },
                    {
                        "username": "dalvsmerk",
                        "content": "Looks like it is expected that each of the string in an array would have common prefix.\n\nI have run these test cases:\n```\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\",\"dog\"] -> \"\"\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\"] -> \"str\"\n```\n"
                    },
                    {
                        "username": "chypso",
                        "content": "Hello. I have question not so much about code but more about logic. \\nif input is \"a\" (ONLY)\\nis correct answer \"a\" or \"\" ?"
                    },
                    {
                        "username": "CT-7567",
                        "content": "\"a\""
                    }
                ]
            },
            {
                "id": 1832789,
                "content": [
                    {
                        "username": "Loomman1",
                        "content": "Should be \"common prefix for EACH string\" - it gets clearer so"
                    },
                    {
                        "username": "user5378Ua",
                        "content": "Testcase 109 \\n[\"reflower\",\"flow\",\"flight\"]\\nOutput\\n\"fl\"\\nExpected\\n\"\"\\n\\nWhy?"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "\"fl\" is not a prefix for \"reflower\". Apparently, what the question is asking for is a common prefix for ALL strings within the list (even though this isn\\'t explicitly stated)"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I was reading through the comments, and it seems like the test case of [\"reflower\",\"flow\",\"flight\"] threw everyone off.\\n\\nThe question is so poorly worded. It asked for the most common prefix amongst an array of strings, and mentioned nothing about the prefix having to be common among **all strings**, which is what it actually wanted. Can\\'t fault someone for coding it wrongly.\\n\\n(Another test case that threw me off was the case of [\\'a\\']. When there\\'s only one item in the list, I don\\'t think you can call it \\'most common\\', but at least this is a bit more open to interpretation)"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized solution with sort crisp code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nknow sorting in 2-d matrix in a deepth way\\n\\nApproach\\nuse 2-d matrix soting property\\n\\nComplexity\\nTime complexity:\\n0(nmlog(nm))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n\\n        string ans=\"\";\\n        sort( strs.begin() , strs.end());\\n        int n = strs.size();\\n        \\n        for( int i=0 ; i<strs[0].length() ; i++)\\n        { \\n        if(strs[0][i]!=strs[n-1][i])\\n        {\\n             return ans;\\n        }\\n        ans.push_back(strs[0][i]);\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "marina_eremina",
                        "content": ">strs[i] consists of only lowercase English letters.\n\n> Testcase: strs = [\"\",\"b\"]\n\nwtf? "
                    },
                    {
                        "username": "lukkyz",
                        "content": "I have a problem with empty string input :\\nInput :\\n[\"\"]\\nOutput\\n\"\"\\nExpected\\n\"\"\\nI have the good output but it don\\'t validate, can you help me ?"
                    },
                    {
                        "username": "sayli1",
                        "content": "How is the Time Complexity for horizontal scanning method = O(N) where N is sum of all characters in all strings ?"
                    },
                    {
                        "username": "03282013ah",
                        "content": "This is hard\\n"
                    },
                    {
                        "username": "dalvsmerk",
                        "content": "Looks like it is expected that each of the string in an array would have common prefix.\n\nI have run these test cases:\n```\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\",\"dog\"] -> \"\"\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\"] -> \"str\"\n```\n"
                    },
                    {
                        "username": "chypso",
                        "content": "Hello. I have question not so much about code but more about logic. \\nif input is \"a\" (ONLY)\\nis correct answer \"a\" or \"\" ?"
                    },
                    {
                        "username": "CT-7567",
                        "content": "\"a\""
                    }
                ]
            },
            {
                "id": 1832339,
                "content": [
                    {
                        "username": "Loomman1",
                        "content": "Should be \"common prefix for EACH string\" - it gets clearer so"
                    },
                    {
                        "username": "user5378Ua",
                        "content": "Testcase 109 \\n[\"reflower\",\"flow\",\"flight\"]\\nOutput\\n\"fl\"\\nExpected\\n\"\"\\n\\nWhy?"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "\"fl\" is not a prefix for \"reflower\". Apparently, what the question is asking for is a common prefix for ALL strings within the list (even though this isn\\'t explicitly stated)"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I was reading through the comments, and it seems like the test case of [\"reflower\",\"flow\",\"flight\"] threw everyone off.\\n\\nThe question is so poorly worded. It asked for the most common prefix amongst an array of strings, and mentioned nothing about the prefix having to be common among **all strings**, which is what it actually wanted. Can\\'t fault someone for coding it wrongly.\\n\\n(Another test case that threw me off was the case of [\\'a\\']. When there\\'s only one item in the list, I don\\'t think you can call it \\'most common\\', but at least this is a bit more open to interpretation)"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized solution with sort crisp code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nknow sorting in 2-d matrix in a deepth way\\n\\nApproach\\nuse 2-d matrix soting property\\n\\nComplexity\\nTime complexity:\\n0(nmlog(nm))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n\\n        string ans=\"\";\\n        sort( strs.begin() , strs.end());\\n        int n = strs.size();\\n        \\n        for( int i=0 ; i<strs[0].length() ; i++)\\n        { \\n        if(strs[0][i]!=strs[n-1][i])\\n        {\\n             return ans;\\n        }\\n        ans.push_back(strs[0][i]);\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "marina_eremina",
                        "content": ">strs[i] consists of only lowercase English letters.\n\n> Testcase: strs = [\"\",\"b\"]\n\nwtf? "
                    },
                    {
                        "username": "lukkyz",
                        "content": "I have a problem with empty string input :\\nInput :\\n[\"\"]\\nOutput\\n\"\"\\nExpected\\n\"\"\\nI have the good output but it don\\'t validate, can you help me ?"
                    },
                    {
                        "username": "sayli1",
                        "content": "How is the Time Complexity for horizontal scanning method = O(N) where N is sum of all characters in all strings ?"
                    },
                    {
                        "username": "03282013ah",
                        "content": "This is hard\\n"
                    },
                    {
                        "username": "dalvsmerk",
                        "content": "Looks like it is expected that each of the string in an array would have common prefix.\n\nI have run these test cases:\n```\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\",\"dog\"] -> \"\"\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\"] -> \"str\"\n```\n"
                    },
                    {
                        "username": "chypso",
                        "content": "Hello. I have question not so much about code but more about logic. \\nif input is \"a\" (ONLY)\\nis correct answer \"a\" or \"\" ?"
                    },
                    {
                        "username": "CT-7567",
                        "content": "\"a\""
                    }
                ]
            },
            {
                "id": 1827431,
                "content": [
                    {
                        "username": "Loomman1",
                        "content": "Should be \"common prefix for EACH string\" - it gets clearer so"
                    },
                    {
                        "username": "user5378Ua",
                        "content": "Testcase 109 \\n[\"reflower\",\"flow\",\"flight\"]\\nOutput\\n\"fl\"\\nExpected\\n\"\"\\n\\nWhy?"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "\"fl\" is not a prefix for \"reflower\". Apparently, what the question is asking for is a common prefix for ALL strings within the list (even though this isn\\'t explicitly stated)"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I was reading through the comments, and it seems like the test case of [\"reflower\",\"flow\",\"flight\"] threw everyone off.\\n\\nThe question is so poorly worded. It asked for the most common prefix amongst an array of strings, and mentioned nothing about the prefix having to be common among **all strings**, which is what it actually wanted. Can\\'t fault someone for coding it wrongly.\\n\\n(Another test case that threw me off was the case of [\\'a\\']. When there\\'s only one item in the list, I don\\'t think you can call it \\'most common\\', but at least this is a bit more open to interpretation)"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized solution with sort crisp code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nknow sorting in 2-d matrix in a deepth way\\n\\nApproach\\nuse 2-d matrix soting property\\n\\nComplexity\\nTime complexity:\\n0(nmlog(nm))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n\\n        string ans=\"\";\\n        sort( strs.begin() , strs.end());\\n        int n = strs.size();\\n        \\n        for( int i=0 ; i<strs[0].length() ; i++)\\n        { \\n        if(strs[0][i]!=strs[n-1][i])\\n        {\\n             return ans;\\n        }\\n        ans.push_back(strs[0][i]);\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "marina_eremina",
                        "content": ">strs[i] consists of only lowercase English letters.\n\n> Testcase: strs = [\"\",\"b\"]\n\nwtf? "
                    },
                    {
                        "username": "lukkyz",
                        "content": "I have a problem with empty string input :\\nInput :\\n[\"\"]\\nOutput\\n\"\"\\nExpected\\n\"\"\\nI have the good output but it don\\'t validate, can you help me ?"
                    },
                    {
                        "username": "sayli1",
                        "content": "How is the Time Complexity for horizontal scanning method = O(N) where N is sum of all characters in all strings ?"
                    },
                    {
                        "username": "03282013ah",
                        "content": "This is hard\\n"
                    },
                    {
                        "username": "dalvsmerk",
                        "content": "Looks like it is expected that each of the string in an array would have common prefix.\n\nI have run these test cases:\n```\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\",\"dog\"] -> \"\"\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\"] -> \"str\"\n```\n"
                    },
                    {
                        "username": "chypso",
                        "content": "Hello. I have question not so much about code but more about logic. \\nif input is \"a\" (ONLY)\\nis correct answer \"a\" or \"\" ?"
                    },
                    {
                        "username": "CT-7567",
                        "content": "\"a\""
                    }
                ]
            },
            {
                "id": 1827297,
                "content": [
                    {
                        "username": "Loomman1",
                        "content": "Should be \"common prefix for EACH string\" - it gets clearer so"
                    },
                    {
                        "username": "user5378Ua",
                        "content": "Testcase 109 \\n[\"reflower\",\"flow\",\"flight\"]\\nOutput\\n\"fl\"\\nExpected\\n\"\"\\n\\nWhy?"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "\"fl\" is not a prefix for \"reflower\". Apparently, what the question is asking for is a common prefix for ALL strings within the list (even though this isn\\'t explicitly stated)"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I was reading through the comments, and it seems like the test case of [\"reflower\",\"flow\",\"flight\"] threw everyone off.\\n\\nThe question is so poorly worded. It asked for the most common prefix amongst an array of strings, and mentioned nothing about the prefix having to be common among **all strings**, which is what it actually wanted. Can\\'t fault someone for coding it wrongly.\\n\\n(Another test case that threw me off was the case of [\\'a\\']. When there\\'s only one item in the list, I don\\'t think you can call it \\'most common\\', but at least this is a bit more open to interpretation)"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized solution with sort crisp code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nknow sorting in 2-d matrix in a deepth way\\n\\nApproach\\nuse 2-d matrix soting property\\n\\nComplexity\\nTime complexity:\\n0(nmlog(nm))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n\\n        string ans=\"\";\\n        sort( strs.begin() , strs.end());\\n        int n = strs.size();\\n        \\n        for( int i=0 ; i<strs[0].length() ; i++)\\n        { \\n        if(strs[0][i]!=strs[n-1][i])\\n        {\\n             return ans;\\n        }\\n        ans.push_back(strs[0][i]);\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "marina_eremina",
                        "content": ">strs[i] consists of only lowercase English letters.\n\n> Testcase: strs = [\"\",\"b\"]\n\nwtf? "
                    },
                    {
                        "username": "lukkyz",
                        "content": "I have a problem with empty string input :\\nInput :\\n[\"\"]\\nOutput\\n\"\"\\nExpected\\n\"\"\\nI have the good output but it don\\'t validate, can you help me ?"
                    },
                    {
                        "username": "sayli1",
                        "content": "How is the Time Complexity for horizontal scanning method = O(N) where N is sum of all characters in all strings ?"
                    },
                    {
                        "username": "03282013ah",
                        "content": "This is hard\\n"
                    },
                    {
                        "username": "dalvsmerk",
                        "content": "Looks like it is expected that each of the string in an array would have common prefix.\n\nI have run these test cases:\n```\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\",\"dog\"] -> \"\"\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\"] -> \"str\"\n```\n"
                    },
                    {
                        "username": "chypso",
                        "content": "Hello. I have question not so much about code but more about logic. \\nif input is \"a\" (ONLY)\\nis correct answer \"a\" or \"\" ?"
                    },
                    {
                        "username": "CT-7567",
                        "content": "\"a\""
                    }
                ]
            },
            {
                "id": 1826740,
                "content": [
                    {
                        "username": "TasneemAyham",
                        "content": "I have a question, please!!\\nI found two ways to solve this. One was to sort the array and use vertical matching(compare characters) between the first string and the last. The other was a normal horizontal matching(taking the string and comparing it to the other strings in the array, returning the longest common string). In a normal situation, horizontal would be faster. But if we are sorting the array, and then using vertical matching between only two words, wouldn\\'t that be faster than horizontal since the latter still compares it to every element in the array? \\nBut the system gives me that the horizontal is still faster. May anyone please explain why? And thank you!!"
                    },
                    {
                        "username": "CT-7567",
                        "content": "compare chars should be more faster instead of strings. think like this:\\nin horizontal you compare string and this process can be used for sorting the array but you are not sorting the array you are just comparing the strings over and over again. I believe this is why."
                    },
                    {
                        "username": "ySIDy",
                        "content": "I ran into a problem, with the same prefixes, my C++ code gives the correct answer, but with an empty symbol at the end, maybe someone knows how to get rid of it ?"
                    },
                    {
                        "username": "swagiuli",
                        "content": "i have the same problem"
                    },
                    {
                        "username": "Gabriel-Barboza-Carvajal",
                        "content": "The testcase [\"\",\"\"] i try it, and the expected output is \"\" and i got the same and it shows up that im wrong! there is a bug there! i got 121 of 124, it will be useful to see all the cases !!"
                    },
                    {
                        "username": "bananacode444",
                        "content": "The description of this problem needs to be written much more explicitly. As of now, it makes it sound as though as long as two or more (not all) elements in the array have a common prefix, then that is a valid output."
                    },
                    {
                        "username": "rugwedk2000",
                        "content": " if(strs.length==0)\\n         return \"\";\\n       String prefix=strs[0];\\n       for(int i=0;i<strs.length;i++){\\n           while(strs[i].indexOf(prefix) !=0){\\n               prefix=prefix.substring(0,prefix.length()-1);\\n               if(prefix.isEmpty())\\n                    return \"\";\\n           }\\n       }\\n       return prefix;"
                    },
                    {
                        "username": "gepcat369",
                        "content": "class Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        MinW = min(strs)\\n        MaxW = max(strs)\\n        left,right = 0 , len(min(strs))\\n        while left < right:\\n            mid = (left+right)//2\\n            if MaxW[mid]==MinW[mid]:\\n                left = mid+1\\n            else: \\n                right = mid-1\\n        if strs[0][left]==strs[1][left]:\\n            return strs[0][:left]\\n        else:\\n            return \"\"\\n\\nWhy this got a runtime problem?"
                    },
                    {
                        "username": "sajeeva616",
                        "content": "Input: S[] = {\\u201Cabcdefgh\\u201D, \\u201Cabcefgh\\u201D}\\nOutput: \\u201Cabc\\u201D\\n\\nis the outpu for the above question is correct or not ? since we can take efgh also as the answer"
                    },
                    {
                        "username": "BachusPL",
                        "content": "This shouldn\\'t be an easy problem. It\\'s so much harder than the rest."
                    },
                    {
                        "username": "G-lion",
                        "content": "when I return \"\" for the empty string, but my output is a gibberish. i don't know how to fix it. please help me. Thank you.  the following is part of my code. \n        if(strs.empty()){\n            return \"\";\n        }"
                    },
                    {
                        "username": "G-lion",
                        "content": "I use \"substr\" instead for return \"\" , and the answer is correct.  I figured it out, thanks."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "It would have been an easy task if the inputs were not that messed up."
                    }
                ]
            },
            {
                "id": 1815685,
                "content": [
                    {
                        "username": "TasneemAyham",
                        "content": "I have a question, please!!\\nI found two ways to solve this. One was to sort the array and use vertical matching(compare characters) between the first string and the last. The other was a normal horizontal matching(taking the string and comparing it to the other strings in the array, returning the longest common string). In a normal situation, horizontal would be faster. But if we are sorting the array, and then using vertical matching between only two words, wouldn\\'t that be faster than horizontal since the latter still compares it to every element in the array? \\nBut the system gives me that the horizontal is still faster. May anyone please explain why? And thank you!!"
                    },
                    {
                        "username": "CT-7567",
                        "content": "compare chars should be more faster instead of strings. think like this:\\nin horizontal you compare string and this process can be used for sorting the array but you are not sorting the array you are just comparing the strings over and over again. I believe this is why."
                    },
                    {
                        "username": "ySIDy",
                        "content": "I ran into a problem, with the same prefixes, my C++ code gives the correct answer, but with an empty symbol at the end, maybe someone knows how to get rid of it ?"
                    },
                    {
                        "username": "swagiuli",
                        "content": "i have the same problem"
                    },
                    {
                        "username": "Gabriel-Barboza-Carvajal",
                        "content": "The testcase [\"\",\"\"] i try it, and the expected output is \"\" and i got the same and it shows up that im wrong! there is a bug there! i got 121 of 124, it will be useful to see all the cases !!"
                    },
                    {
                        "username": "bananacode444",
                        "content": "The description of this problem needs to be written much more explicitly. As of now, it makes it sound as though as long as two or more (not all) elements in the array have a common prefix, then that is a valid output."
                    },
                    {
                        "username": "rugwedk2000",
                        "content": " if(strs.length==0)\\n         return \"\";\\n       String prefix=strs[0];\\n       for(int i=0;i<strs.length;i++){\\n           while(strs[i].indexOf(prefix) !=0){\\n               prefix=prefix.substring(0,prefix.length()-1);\\n               if(prefix.isEmpty())\\n                    return \"\";\\n           }\\n       }\\n       return prefix;"
                    },
                    {
                        "username": "gepcat369",
                        "content": "class Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        MinW = min(strs)\\n        MaxW = max(strs)\\n        left,right = 0 , len(min(strs))\\n        while left < right:\\n            mid = (left+right)//2\\n            if MaxW[mid]==MinW[mid]:\\n                left = mid+1\\n            else: \\n                right = mid-1\\n        if strs[0][left]==strs[1][left]:\\n            return strs[0][:left]\\n        else:\\n            return \"\"\\n\\nWhy this got a runtime problem?"
                    },
                    {
                        "username": "sajeeva616",
                        "content": "Input: S[] = {\\u201Cabcdefgh\\u201D, \\u201Cabcefgh\\u201D}\\nOutput: \\u201Cabc\\u201D\\n\\nis the outpu for the above question is correct or not ? since we can take efgh also as the answer"
                    },
                    {
                        "username": "BachusPL",
                        "content": "This shouldn\\'t be an easy problem. It\\'s so much harder than the rest."
                    },
                    {
                        "username": "G-lion",
                        "content": "when I return \"\" for the empty string, but my output is a gibberish. i don't know how to fix it. please help me. Thank you.  the following is part of my code. \n        if(strs.empty()){\n            return \"\";\n        }"
                    },
                    {
                        "username": "G-lion",
                        "content": "I use \"substr\" instead for return \"\" , and the answer is correct.  I figured it out, thanks."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "It would have been an easy task if the inputs were not that messed up."
                    }
                ]
            },
            {
                "id": 1813606,
                "content": [
                    {
                        "username": "TasneemAyham",
                        "content": "I have a question, please!!\\nI found two ways to solve this. One was to sort the array and use vertical matching(compare characters) between the first string and the last. The other was a normal horizontal matching(taking the string and comparing it to the other strings in the array, returning the longest common string). In a normal situation, horizontal would be faster. But if we are sorting the array, and then using vertical matching between only two words, wouldn\\'t that be faster than horizontal since the latter still compares it to every element in the array? \\nBut the system gives me that the horizontal is still faster. May anyone please explain why? And thank you!!"
                    },
                    {
                        "username": "CT-7567",
                        "content": "compare chars should be more faster instead of strings. think like this:\\nin horizontal you compare string and this process can be used for sorting the array but you are not sorting the array you are just comparing the strings over and over again. I believe this is why."
                    },
                    {
                        "username": "ySIDy",
                        "content": "I ran into a problem, with the same prefixes, my C++ code gives the correct answer, but with an empty symbol at the end, maybe someone knows how to get rid of it ?"
                    },
                    {
                        "username": "swagiuli",
                        "content": "i have the same problem"
                    },
                    {
                        "username": "Gabriel-Barboza-Carvajal",
                        "content": "The testcase [\"\",\"\"] i try it, and the expected output is \"\" and i got the same and it shows up that im wrong! there is a bug there! i got 121 of 124, it will be useful to see all the cases !!"
                    },
                    {
                        "username": "bananacode444",
                        "content": "The description of this problem needs to be written much more explicitly. As of now, it makes it sound as though as long as two or more (not all) elements in the array have a common prefix, then that is a valid output."
                    },
                    {
                        "username": "rugwedk2000",
                        "content": " if(strs.length==0)\\n         return \"\";\\n       String prefix=strs[0];\\n       for(int i=0;i<strs.length;i++){\\n           while(strs[i].indexOf(prefix) !=0){\\n               prefix=prefix.substring(0,prefix.length()-1);\\n               if(prefix.isEmpty())\\n                    return \"\";\\n           }\\n       }\\n       return prefix;"
                    },
                    {
                        "username": "gepcat369",
                        "content": "class Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        MinW = min(strs)\\n        MaxW = max(strs)\\n        left,right = 0 , len(min(strs))\\n        while left < right:\\n            mid = (left+right)//2\\n            if MaxW[mid]==MinW[mid]:\\n                left = mid+1\\n            else: \\n                right = mid-1\\n        if strs[0][left]==strs[1][left]:\\n            return strs[0][:left]\\n        else:\\n            return \"\"\\n\\nWhy this got a runtime problem?"
                    },
                    {
                        "username": "sajeeva616",
                        "content": "Input: S[] = {\\u201Cabcdefgh\\u201D, \\u201Cabcefgh\\u201D}\\nOutput: \\u201Cabc\\u201D\\n\\nis the outpu for the above question is correct or not ? since we can take efgh also as the answer"
                    },
                    {
                        "username": "BachusPL",
                        "content": "This shouldn\\'t be an easy problem. It\\'s so much harder than the rest."
                    },
                    {
                        "username": "G-lion",
                        "content": "when I return \"\" for the empty string, but my output is a gibberish. i don't know how to fix it. please help me. Thank you.  the following is part of my code. \n        if(strs.empty()){\n            return \"\";\n        }"
                    },
                    {
                        "username": "G-lion",
                        "content": "I use \"substr\" instead for return \"\" , and the answer is correct.  I figured it out, thanks."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "It would have been an easy task if the inputs were not that messed up."
                    }
                ]
            },
            {
                "id": 1811316,
                "content": [
                    {
                        "username": "TasneemAyham",
                        "content": "I have a question, please!!\\nI found two ways to solve this. One was to sort the array and use vertical matching(compare characters) between the first string and the last. The other was a normal horizontal matching(taking the string and comparing it to the other strings in the array, returning the longest common string). In a normal situation, horizontal would be faster. But if we are sorting the array, and then using vertical matching between only two words, wouldn\\'t that be faster than horizontal since the latter still compares it to every element in the array? \\nBut the system gives me that the horizontal is still faster. May anyone please explain why? And thank you!!"
                    },
                    {
                        "username": "CT-7567",
                        "content": "compare chars should be more faster instead of strings. think like this:\\nin horizontal you compare string and this process can be used for sorting the array but you are not sorting the array you are just comparing the strings over and over again. I believe this is why."
                    },
                    {
                        "username": "ySIDy",
                        "content": "I ran into a problem, with the same prefixes, my C++ code gives the correct answer, but with an empty symbol at the end, maybe someone knows how to get rid of it ?"
                    },
                    {
                        "username": "swagiuli",
                        "content": "i have the same problem"
                    },
                    {
                        "username": "Gabriel-Barboza-Carvajal",
                        "content": "The testcase [\"\",\"\"] i try it, and the expected output is \"\" and i got the same and it shows up that im wrong! there is a bug there! i got 121 of 124, it will be useful to see all the cases !!"
                    },
                    {
                        "username": "bananacode444",
                        "content": "The description of this problem needs to be written much more explicitly. As of now, it makes it sound as though as long as two or more (not all) elements in the array have a common prefix, then that is a valid output."
                    },
                    {
                        "username": "rugwedk2000",
                        "content": " if(strs.length==0)\\n         return \"\";\\n       String prefix=strs[0];\\n       for(int i=0;i<strs.length;i++){\\n           while(strs[i].indexOf(prefix) !=0){\\n               prefix=prefix.substring(0,prefix.length()-1);\\n               if(prefix.isEmpty())\\n                    return \"\";\\n           }\\n       }\\n       return prefix;"
                    },
                    {
                        "username": "gepcat369",
                        "content": "class Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        MinW = min(strs)\\n        MaxW = max(strs)\\n        left,right = 0 , len(min(strs))\\n        while left < right:\\n            mid = (left+right)//2\\n            if MaxW[mid]==MinW[mid]:\\n                left = mid+1\\n            else: \\n                right = mid-1\\n        if strs[0][left]==strs[1][left]:\\n            return strs[0][:left]\\n        else:\\n            return \"\"\\n\\nWhy this got a runtime problem?"
                    },
                    {
                        "username": "sajeeva616",
                        "content": "Input: S[] = {\\u201Cabcdefgh\\u201D, \\u201Cabcefgh\\u201D}\\nOutput: \\u201Cabc\\u201D\\n\\nis the outpu for the above question is correct or not ? since we can take efgh also as the answer"
                    },
                    {
                        "username": "BachusPL",
                        "content": "This shouldn\\'t be an easy problem. It\\'s so much harder than the rest."
                    },
                    {
                        "username": "G-lion",
                        "content": "when I return \"\" for the empty string, but my output is a gibberish. i don't know how to fix it. please help me. Thank you.  the following is part of my code. \n        if(strs.empty()){\n            return \"\";\n        }"
                    },
                    {
                        "username": "G-lion",
                        "content": "I use \"substr\" instead for return \"\" , and the answer is correct.  I figured it out, thanks."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "It would have been an easy task if the inputs were not that messed up."
                    }
                ]
            },
            {
                "id": 1810914,
                "content": [
                    {
                        "username": "TasneemAyham",
                        "content": "I have a question, please!!\\nI found two ways to solve this. One was to sort the array and use vertical matching(compare characters) between the first string and the last. The other was a normal horizontal matching(taking the string and comparing it to the other strings in the array, returning the longest common string). In a normal situation, horizontal would be faster. But if we are sorting the array, and then using vertical matching between only two words, wouldn\\'t that be faster than horizontal since the latter still compares it to every element in the array? \\nBut the system gives me that the horizontal is still faster. May anyone please explain why? And thank you!!"
                    },
                    {
                        "username": "CT-7567",
                        "content": "compare chars should be more faster instead of strings. think like this:\\nin horizontal you compare string and this process can be used for sorting the array but you are not sorting the array you are just comparing the strings over and over again. I believe this is why."
                    },
                    {
                        "username": "ySIDy",
                        "content": "I ran into a problem, with the same prefixes, my C++ code gives the correct answer, but with an empty symbol at the end, maybe someone knows how to get rid of it ?"
                    },
                    {
                        "username": "swagiuli",
                        "content": "i have the same problem"
                    },
                    {
                        "username": "Gabriel-Barboza-Carvajal",
                        "content": "The testcase [\"\",\"\"] i try it, and the expected output is \"\" and i got the same and it shows up that im wrong! there is a bug there! i got 121 of 124, it will be useful to see all the cases !!"
                    },
                    {
                        "username": "bananacode444",
                        "content": "The description of this problem needs to be written much more explicitly. As of now, it makes it sound as though as long as two or more (not all) elements in the array have a common prefix, then that is a valid output."
                    },
                    {
                        "username": "rugwedk2000",
                        "content": " if(strs.length==0)\\n         return \"\";\\n       String prefix=strs[0];\\n       for(int i=0;i<strs.length;i++){\\n           while(strs[i].indexOf(prefix) !=0){\\n               prefix=prefix.substring(0,prefix.length()-1);\\n               if(prefix.isEmpty())\\n                    return \"\";\\n           }\\n       }\\n       return prefix;"
                    },
                    {
                        "username": "gepcat369",
                        "content": "class Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        MinW = min(strs)\\n        MaxW = max(strs)\\n        left,right = 0 , len(min(strs))\\n        while left < right:\\n            mid = (left+right)//2\\n            if MaxW[mid]==MinW[mid]:\\n                left = mid+1\\n            else: \\n                right = mid-1\\n        if strs[0][left]==strs[1][left]:\\n            return strs[0][:left]\\n        else:\\n            return \"\"\\n\\nWhy this got a runtime problem?"
                    },
                    {
                        "username": "sajeeva616",
                        "content": "Input: S[] = {\\u201Cabcdefgh\\u201D, \\u201Cabcefgh\\u201D}\\nOutput: \\u201Cabc\\u201D\\n\\nis the outpu for the above question is correct or not ? since we can take efgh also as the answer"
                    },
                    {
                        "username": "BachusPL",
                        "content": "This shouldn\\'t be an easy problem. It\\'s so much harder than the rest."
                    },
                    {
                        "username": "G-lion",
                        "content": "when I return \"\" for the empty string, but my output is a gibberish. i don't know how to fix it. please help me. Thank you.  the following is part of my code. \n        if(strs.empty()){\n            return \"\";\n        }"
                    },
                    {
                        "username": "G-lion",
                        "content": "I use \"substr\" instead for return \"\" , and the answer is correct.  I figured it out, thanks."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "It would have been an easy task if the inputs were not that messed up."
                    }
                ]
            },
            {
                "id": 1810374,
                "content": [
                    {
                        "username": "TasneemAyham",
                        "content": "I have a question, please!!\\nI found two ways to solve this. One was to sort the array and use vertical matching(compare characters) between the first string and the last. The other was a normal horizontal matching(taking the string and comparing it to the other strings in the array, returning the longest common string). In a normal situation, horizontal would be faster. But if we are sorting the array, and then using vertical matching between only two words, wouldn\\'t that be faster than horizontal since the latter still compares it to every element in the array? \\nBut the system gives me that the horizontal is still faster. May anyone please explain why? And thank you!!"
                    },
                    {
                        "username": "CT-7567",
                        "content": "compare chars should be more faster instead of strings. think like this:\\nin horizontal you compare string and this process can be used for sorting the array but you are not sorting the array you are just comparing the strings over and over again. I believe this is why."
                    },
                    {
                        "username": "ySIDy",
                        "content": "I ran into a problem, with the same prefixes, my C++ code gives the correct answer, but with an empty symbol at the end, maybe someone knows how to get rid of it ?"
                    },
                    {
                        "username": "swagiuli",
                        "content": "i have the same problem"
                    },
                    {
                        "username": "Gabriel-Barboza-Carvajal",
                        "content": "The testcase [\"\",\"\"] i try it, and the expected output is \"\" and i got the same and it shows up that im wrong! there is a bug there! i got 121 of 124, it will be useful to see all the cases !!"
                    },
                    {
                        "username": "bananacode444",
                        "content": "The description of this problem needs to be written much more explicitly. As of now, it makes it sound as though as long as two or more (not all) elements in the array have a common prefix, then that is a valid output."
                    },
                    {
                        "username": "rugwedk2000",
                        "content": " if(strs.length==0)\\n         return \"\";\\n       String prefix=strs[0];\\n       for(int i=0;i<strs.length;i++){\\n           while(strs[i].indexOf(prefix) !=0){\\n               prefix=prefix.substring(0,prefix.length()-1);\\n               if(prefix.isEmpty())\\n                    return \"\";\\n           }\\n       }\\n       return prefix;"
                    },
                    {
                        "username": "gepcat369",
                        "content": "class Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        MinW = min(strs)\\n        MaxW = max(strs)\\n        left,right = 0 , len(min(strs))\\n        while left < right:\\n            mid = (left+right)//2\\n            if MaxW[mid]==MinW[mid]:\\n                left = mid+1\\n            else: \\n                right = mid-1\\n        if strs[0][left]==strs[1][left]:\\n            return strs[0][:left]\\n        else:\\n            return \"\"\\n\\nWhy this got a runtime problem?"
                    },
                    {
                        "username": "sajeeva616",
                        "content": "Input: S[] = {\\u201Cabcdefgh\\u201D, \\u201Cabcefgh\\u201D}\\nOutput: \\u201Cabc\\u201D\\n\\nis the outpu for the above question is correct or not ? since we can take efgh also as the answer"
                    },
                    {
                        "username": "BachusPL",
                        "content": "This shouldn\\'t be an easy problem. It\\'s so much harder than the rest."
                    },
                    {
                        "username": "G-lion",
                        "content": "when I return \"\" for the empty string, but my output is a gibberish. i don't know how to fix it. please help me. Thank you.  the following is part of my code. \n        if(strs.empty()){\n            return \"\";\n        }"
                    },
                    {
                        "username": "G-lion",
                        "content": "I use \"substr\" instead for return \"\" , and the answer is correct.  I figured it out, thanks."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "It would have been an easy task if the inputs were not that messed up."
                    }
                ]
            },
            {
                "id": 1809618,
                "content": [
                    {
                        "username": "TasneemAyham",
                        "content": "I have a question, please!!\\nI found two ways to solve this. One was to sort the array and use vertical matching(compare characters) between the first string and the last. The other was a normal horizontal matching(taking the string and comparing it to the other strings in the array, returning the longest common string). In a normal situation, horizontal would be faster. But if we are sorting the array, and then using vertical matching between only two words, wouldn\\'t that be faster than horizontal since the latter still compares it to every element in the array? \\nBut the system gives me that the horizontal is still faster. May anyone please explain why? And thank you!!"
                    },
                    {
                        "username": "CT-7567",
                        "content": "compare chars should be more faster instead of strings. think like this:\\nin horizontal you compare string and this process can be used for sorting the array but you are not sorting the array you are just comparing the strings over and over again. I believe this is why."
                    },
                    {
                        "username": "ySIDy",
                        "content": "I ran into a problem, with the same prefixes, my C++ code gives the correct answer, but with an empty symbol at the end, maybe someone knows how to get rid of it ?"
                    },
                    {
                        "username": "swagiuli",
                        "content": "i have the same problem"
                    },
                    {
                        "username": "Gabriel-Barboza-Carvajal",
                        "content": "The testcase [\"\",\"\"] i try it, and the expected output is \"\" and i got the same and it shows up that im wrong! there is a bug there! i got 121 of 124, it will be useful to see all the cases !!"
                    },
                    {
                        "username": "bananacode444",
                        "content": "The description of this problem needs to be written much more explicitly. As of now, it makes it sound as though as long as two or more (not all) elements in the array have a common prefix, then that is a valid output."
                    },
                    {
                        "username": "rugwedk2000",
                        "content": " if(strs.length==0)\\n         return \"\";\\n       String prefix=strs[0];\\n       for(int i=0;i<strs.length;i++){\\n           while(strs[i].indexOf(prefix) !=0){\\n               prefix=prefix.substring(0,prefix.length()-1);\\n               if(prefix.isEmpty())\\n                    return \"\";\\n           }\\n       }\\n       return prefix;"
                    },
                    {
                        "username": "gepcat369",
                        "content": "class Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        MinW = min(strs)\\n        MaxW = max(strs)\\n        left,right = 0 , len(min(strs))\\n        while left < right:\\n            mid = (left+right)//2\\n            if MaxW[mid]==MinW[mid]:\\n                left = mid+1\\n            else: \\n                right = mid-1\\n        if strs[0][left]==strs[1][left]:\\n            return strs[0][:left]\\n        else:\\n            return \"\"\\n\\nWhy this got a runtime problem?"
                    },
                    {
                        "username": "sajeeva616",
                        "content": "Input: S[] = {\\u201Cabcdefgh\\u201D, \\u201Cabcefgh\\u201D}\\nOutput: \\u201Cabc\\u201D\\n\\nis the outpu for the above question is correct or not ? since we can take efgh also as the answer"
                    },
                    {
                        "username": "BachusPL",
                        "content": "This shouldn\\'t be an easy problem. It\\'s so much harder than the rest."
                    },
                    {
                        "username": "G-lion",
                        "content": "when I return \"\" for the empty string, but my output is a gibberish. i don't know how to fix it. please help me. Thank you.  the following is part of my code. \n        if(strs.empty()){\n            return \"\";\n        }"
                    },
                    {
                        "username": "G-lion",
                        "content": "I use \"substr\" instead for return \"\" , and the answer is correct.  I figured it out, thanks."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "It would have been an easy task if the inputs were not that messed up."
                    }
                ]
            },
            {
                "id": 1807257,
                "content": [
                    {
                        "username": "TasneemAyham",
                        "content": "I have a question, please!!\\nI found two ways to solve this. One was to sort the array and use vertical matching(compare characters) between the first string and the last. The other was a normal horizontal matching(taking the string and comparing it to the other strings in the array, returning the longest common string). In a normal situation, horizontal would be faster. But if we are sorting the array, and then using vertical matching between only two words, wouldn\\'t that be faster than horizontal since the latter still compares it to every element in the array? \\nBut the system gives me that the horizontal is still faster. May anyone please explain why? And thank you!!"
                    },
                    {
                        "username": "CT-7567",
                        "content": "compare chars should be more faster instead of strings. think like this:\\nin horizontal you compare string and this process can be used for sorting the array but you are not sorting the array you are just comparing the strings over and over again. I believe this is why."
                    },
                    {
                        "username": "ySIDy",
                        "content": "I ran into a problem, with the same prefixes, my C++ code gives the correct answer, but with an empty symbol at the end, maybe someone knows how to get rid of it ?"
                    },
                    {
                        "username": "swagiuli",
                        "content": "i have the same problem"
                    },
                    {
                        "username": "Gabriel-Barboza-Carvajal",
                        "content": "The testcase [\"\",\"\"] i try it, and the expected output is \"\" and i got the same and it shows up that im wrong! there is a bug there! i got 121 of 124, it will be useful to see all the cases !!"
                    },
                    {
                        "username": "bananacode444",
                        "content": "The description of this problem needs to be written much more explicitly. As of now, it makes it sound as though as long as two or more (not all) elements in the array have a common prefix, then that is a valid output."
                    },
                    {
                        "username": "rugwedk2000",
                        "content": " if(strs.length==0)\\n         return \"\";\\n       String prefix=strs[0];\\n       for(int i=0;i<strs.length;i++){\\n           while(strs[i].indexOf(prefix) !=0){\\n               prefix=prefix.substring(0,prefix.length()-1);\\n               if(prefix.isEmpty())\\n                    return \"\";\\n           }\\n       }\\n       return prefix;"
                    },
                    {
                        "username": "gepcat369",
                        "content": "class Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        MinW = min(strs)\\n        MaxW = max(strs)\\n        left,right = 0 , len(min(strs))\\n        while left < right:\\n            mid = (left+right)//2\\n            if MaxW[mid]==MinW[mid]:\\n                left = mid+1\\n            else: \\n                right = mid-1\\n        if strs[0][left]==strs[1][left]:\\n            return strs[0][:left]\\n        else:\\n            return \"\"\\n\\nWhy this got a runtime problem?"
                    },
                    {
                        "username": "sajeeva616",
                        "content": "Input: S[] = {\\u201Cabcdefgh\\u201D, \\u201Cabcefgh\\u201D}\\nOutput: \\u201Cabc\\u201D\\n\\nis the outpu for the above question is correct or not ? since we can take efgh also as the answer"
                    },
                    {
                        "username": "BachusPL",
                        "content": "This shouldn\\'t be an easy problem. It\\'s so much harder than the rest."
                    },
                    {
                        "username": "G-lion",
                        "content": "when I return \"\" for the empty string, but my output is a gibberish. i don't know how to fix it. please help me. Thank you.  the following is part of my code. \n        if(strs.empty()){\n            return \"\";\n        }"
                    },
                    {
                        "username": "G-lion",
                        "content": "I use \"substr\" instead for return \"\" , and the answer is correct.  I figured it out, thanks."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "It would have been an easy task if the inputs were not that messed up."
                    }
                ]
            },
            {
                "id": 1807228,
                "content": [
                    {
                        "username": "TasneemAyham",
                        "content": "I have a question, please!!\\nI found two ways to solve this. One was to sort the array and use vertical matching(compare characters) between the first string and the last. The other was a normal horizontal matching(taking the string and comparing it to the other strings in the array, returning the longest common string). In a normal situation, horizontal would be faster. But if we are sorting the array, and then using vertical matching between only two words, wouldn\\'t that be faster than horizontal since the latter still compares it to every element in the array? \\nBut the system gives me that the horizontal is still faster. May anyone please explain why? And thank you!!"
                    },
                    {
                        "username": "CT-7567",
                        "content": "compare chars should be more faster instead of strings. think like this:\\nin horizontal you compare string and this process can be used for sorting the array but you are not sorting the array you are just comparing the strings over and over again. I believe this is why."
                    },
                    {
                        "username": "ySIDy",
                        "content": "I ran into a problem, with the same prefixes, my C++ code gives the correct answer, but with an empty symbol at the end, maybe someone knows how to get rid of it ?"
                    },
                    {
                        "username": "swagiuli",
                        "content": "i have the same problem"
                    },
                    {
                        "username": "Gabriel-Barboza-Carvajal",
                        "content": "The testcase [\"\",\"\"] i try it, and the expected output is \"\" and i got the same and it shows up that im wrong! there is a bug there! i got 121 of 124, it will be useful to see all the cases !!"
                    },
                    {
                        "username": "bananacode444",
                        "content": "The description of this problem needs to be written much more explicitly. As of now, it makes it sound as though as long as two or more (not all) elements in the array have a common prefix, then that is a valid output."
                    },
                    {
                        "username": "rugwedk2000",
                        "content": " if(strs.length==0)\\n         return \"\";\\n       String prefix=strs[0];\\n       for(int i=0;i<strs.length;i++){\\n           while(strs[i].indexOf(prefix) !=0){\\n               prefix=prefix.substring(0,prefix.length()-1);\\n               if(prefix.isEmpty())\\n                    return \"\";\\n           }\\n       }\\n       return prefix;"
                    },
                    {
                        "username": "gepcat369",
                        "content": "class Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        MinW = min(strs)\\n        MaxW = max(strs)\\n        left,right = 0 , len(min(strs))\\n        while left < right:\\n            mid = (left+right)//2\\n            if MaxW[mid]==MinW[mid]:\\n                left = mid+1\\n            else: \\n                right = mid-1\\n        if strs[0][left]==strs[1][left]:\\n            return strs[0][:left]\\n        else:\\n            return \"\"\\n\\nWhy this got a runtime problem?"
                    },
                    {
                        "username": "sajeeva616",
                        "content": "Input: S[] = {\\u201Cabcdefgh\\u201D, \\u201Cabcefgh\\u201D}\\nOutput: \\u201Cabc\\u201D\\n\\nis the outpu for the above question is correct or not ? since we can take efgh also as the answer"
                    },
                    {
                        "username": "BachusPL",
                        "content": "This shouldn\\'t be an easy problem. It\\'s so much harder than the rest."
                    },
                    {
                        "username": "G-lion",
                        "content": "when I return \"\" for the empty string, but my output is a gibberish. i don't know how to fix it. please help me. Thank you.  the following is part of my code. \n        if(strs.empty()){\n            return \"\";\n        }"
                    },
                    {
                        "username": "G-lion",
                        "content": "I use \"substr\" instead for return \"\" , and the answer is correct.  I figured it out, thanks."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "It would have been an easy task if the inputs were not that messed up."
                    }
                ]
            },
            {
                "id": 1807146,
                "content": [
                    {
                        "username": "TasneemAyham",
                        "content": "I have a question, please!!\\nI found two ways to solve this. One was to sort the array and use vertical matching(compare characters) between the first string and the last. The other was a normal horizontal matching(taking the string and comparing it to the other strings in the array, returning the longest common string). In a normal situation, horizontal would be faster. But if we are sorting the array, and then using vertical matching between only two words, wouldn\\'t that be faster than horizontal since the latter still compares it to every element in the array? \\nBut the system gives me that the horizontal is still faster. May anyone please explain why? And thank you!!"
                    },
                    {
                        "username": "CT-7567",
                        "content": "compare chars should be more faster instead of strings. think like this:\\nin horizontal you compare string and this process can be used for sorting the array but you are not sorting the array you are just comparing the strings over and over again. I believe this is why."
                    },
                    {
                        "username": "ySIDy",
                        "content": "I ran into a problem, with the same prefixes, my C++ code gives the correct answer, but with an empty symbol at the end, maybe someone knows how to get rid of it ?"
                    },
                    {
                        "username": "swagiuli",
                        "content": "i have the same problem"
                    },
                    {
                        "username": "Gabriel-Barboza-Carvajal",
                        "content": "The testcase [\"\",\"\"] i try it, and the expected output is \"\" and i got the same and it shows up that im wrong! there is a bug there! i got 121 of 124, it will be useful to see all the cases !!"
                    },
                    {
                        "username": "bananacode444",
                        "content": "The description of this problem needs to be written much more explicitly. As of now, it makes it sound as though as long as two or more (not all) elements in the array have a common prefix, then that is a valid output."
                    },
                    {
                        "username": "rugwedk2000",
                        "content": " if(strs.length==0)\\n         return \"\";\\n       String prefix=strs[0];\\n       for(int i=0;i<strs.length;i++){\\n           while(strs[i].indexOf(prefix) !=0){\\n               prefix=prefix.substring(0,prefix.length()-1);\\n               if(prefix.isEmpty())\\n                    return \"\";\\n           }\\n       }\\n       return prefix;"
                    },
                    {
                        "username": "gepcat369",
                        "content": "class Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        MinW = min(strs)\\n        MaxW = max(strs)\\n        left,right = 0 , len(min(strs))\\n        while left < right:\\n            mid = (left+right)//2\\n            if MaxW[mid]==MinW[mid]:\\n                left = mid+1\\n            else: \\n                right = mid-1\\n        if strs[0][left]==strs[1][left]:\\n            return strs[0][:left]\\n        else:\\n            return \"\"\\n\\nWhy this got a runtime problem?"
                    },
                    {
                        "username": "sajeeva616",
                        "content": "Input: S[] = {\\u201Cabcdefgh\\u201D, \\u201Cabcefgh\\u201D}\\nOutput: \\u201Cabc\\u201D\\n\\nis the outpu for the above question is correct or not ? since we can take efgh also as the answer"
                    },
                    {
                        "username": "BachusPL",
                        "content": "This shouldn\\'t be an easy problem. It\\'s so much harder than the rest."
                    },
                    {
                        "username": "G-lion",
                        "content": "when I return \"\" for the empty string, but my output is a gibberish. i don't know how to fix it. please help me. Thank you.  the following is part of my code. \n        if(strs.empty()){\n            return \"\";\n        }"
                    },
                    {
                        "username": "G-lion",
                        "content": "I use \"substr\" instead for return \"\" , and the answer is correct.  I figured it out, thanks."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "It would have been an easy task if the inputs were not that messed up."
                    }
                ]
            },
            {
                "id": 1805457,
                "content": [
                    {
                        "username": "ajaykhot561",
                        "content": "For those who are getting confused between why first and last string is getting compared, here is the approach for them,\\nSo here when we sort string array we get sorted it in this form:\\nflight\\nflow\\nflower\\n\\nSo now it is sorted then we will compare first string with last flight with flower where our string character dont match break there and print the substring till that postion\\nc=2\\nsubstring(0,c);\\nans=fl\\n\\n"
                    },
                    {
                        "username": "achadharma334",
                        "content": "when to use  return and console.log( )  statements ?? I really got confused what to use "
                    },
                    {
                        "username": "ajaykhot561",
                        "content": "Coding in javascript?\\n"
                    },
                    {
                        "username": "zoe850610",
                        "content": "strs = [\"flower\",\"flow\",\"fsight\"]"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Is there any difference between below code in C Programming..??\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) \\n    and \\n    if(strs[0][col] != strs[row][col])\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) - not working\\n    and \\n    if(strs[0][col] != strs[row][col]) - working\\n\\nWhy???\\n    "
                    },
                    {
                        "username": "ayushkaintura567",
                        "content": "What if the inputted list has a single string only? like x=[\\'single\\']"
                    },
                    {
                        "username": "Dennis_8765",
                        "content": "This would be my Code, it works in Eclipse but does not here it tells me that Line 14 (t=strs[j].charAt(i);\\n) has a mistake:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 17, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nDO you know an answer?\\n\\n\\n\\tString in = \"\";\\n\\t\\tchar t=\\' \\';\\n\\t\\tboolean tr=false;\\n\\t\\tchar[] tn = new char[strs.length];\\n        \\t\\tif(strs[0]==\"\") {\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < strs.length; ++i) {\\n\\t\\t\\tfor (int j = 0; j < strs.length; ++j) {\\n                if(strs[j]!=null) {\\n\\t                t=strs[j].charAt(i);\\n\\t                tn[j]=t;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\tfor(int z=1;z<tn.length;++z) {\\n\\t\\t\\t\\tif(tn[z-1]==tn[z]) {\\n\\t\\t\\t\\t\\ttr=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ttr=false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(tr==true) {\\n\\t\\t\\t\\tin+=t;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn in;"
                    },
                    {
                        "username": "AmmarAlkhooly98",
                        "content": "**Tip/Hint:**\n\nI was first trying to solve this using KMP Algo, and adding a random special chars and numbers between each str, worked but has many edge cases, so if you are thinking of the same, there are simpler solutions that can be applied, think of looping vertically throughout the strings... \nGood Luck!\nCheck out my solution post [here](https://leetcode.com/problems/longest-common-prefix/solutions/3172147/looping-vertically-js-easy-optimal-solution-explained/)"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& arr) {\\n        \\n        int N=arr.size();\\n        string ans=\"\";\\n         sort(arr.begin(), arr.end());\\n        for(int i=0;i<arr[N-1].length();i++)\\n        {\\n            if(arr[0][i]==arr[N-1][i])\\n            {\\n                ans=ans+arr[0][i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        if(ans.length())\\n        return ans;\\n        return \"\";\\n    }\\n};"
                    },
                    {
                        "username": "RahulChan",
                        "content": "`String ans=\"\";\\n        String first=\"\";\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<strs.length;i++){\\n            if(strs[i].length()<=min){\\n                min=strs[i].length();\\n                first=strs[i];\\n            }\\n        }\\n        int k=0;\\n        for(int i=0;i<first.length();i++){\\n            int count=0;\\n            char ch=first.charAt(i);\\n            for(int j=0;j<strs.length;j++){\\n                if((ch==strs[j].charAt(k))){\\n                    count++;\\n                }\\n                if(count==0)\\n                    break;\\n            }\\n            k++;\\n            if(count<strs.length){\\n                break;\\n            }\\n            if(count==strs.length)\\n                ans+=ch;\\n        }\\n        return ans;`"
                    },
                    {
                        "username": "sadikhan918",
                        "content": "I threw together a solution really quick without caring for time complexity, and I\\'m getting a runtime error when I shouldn\\'t be?  \\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 14, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI\\'ve tested the specific use case in my own IDE and it returns the proper response. The test case was [\"\", \"\"] and the response was \"\". I don\\'t know why this error is popping up."
                    }
                ]
            },
            {
                "id": 1804033,
                "content": [
                    {
                        "username": "ajaykhot561",
                        "content": "For those who are getting confused between why first and last string is getting compared, here is the approach for them,\\nSo here when we sort string array we get sorted it in this form:\\nflight\\nflow\\nflower\\n\\nSo now it is sorted then we will compare first string with last flight with flower where our string character dont match break there and print the substring till that postion\\nc=2\\nsubstring(0,c);\\nans=fl\\n\\n"
                    },
                    {
                        "username": "achadharma334",
                        "content": "when to use  return and console.log( )  statements ?? I really got confused what to use "
                    },
                    {
                        "username": "ajaykhot561",
                        "content": "Coding in javascript?\\n"
                    },
                    {
                        "username": "zoe850610",
                        "content": "strs = [\"flower\",\"flow\",\"fsight\"]"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Is there any difference between below code in C Programming..??\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) \\n    and \\n    if(strs[0][col] != strs[row][col])\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) - not working\\n    and \\n    if(strs[0][col] != strs[row][col]) - working\\n\\nWhy???\\n    "
                    },
                    {
                        "username": "ayushkaintura567",
                        "content": "What if the inputted list has a single string only? like x=[\\'single\\']"
                    },
                    {
                        "username": "Dennis_8765",
                        "content": "This would be my Code, it works in Eclipse but does not here it tells me that Line 14 (t=strs[j].charAt(i);\\n) has a mistake:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 17, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nDO you know an answer?\\n\\n\\n\\tString in = \"\";\\n\\t\\tchar t=\\' \\';\\n\\t\\tboolean tr=false;\\n\\t\\tchar[] tn = new char[strs.length];\\n        \\t\\tif(strs[0]==\"\") {\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < strs.length; ++i) {\\n\\t\\t\\tfor (int j = 0; j < strs.length; ++j) {\\n                if(strs[j]!=null) {\\n\\t                t=strs[j].charAt(i);\\n\\t                tn[j]=t;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\tfor(int z=1;z<tn.length;++z) {\\n\\t\\t\\t\\tif(tn[z-1]==tn[z]) {\\n\\t\\t\\t\\t\\ttr=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ttr=false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(tr==true) {\\n\\t\\t\\t\\tin+=t;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn in;"
                    },
                    {
                        "username": "AmmarAlkhooly98",
                        "content": "**Tip/Hint:**\n\nI was first trying to solve this using KMP Algo, and adding a random special chars and numbers between each str, worked but has many edge cases, so if you are thinking of the same, there are simpler solutions that can be applied, think of looping vertically throughout the strings... \nGood Luck!\nCheck out my solution post [here](https://leetcode.com/problems/longest-common-prefix/solutions/3172147/looping-vertically-js-easy-optimal-solution-explained/)"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& arr) {\\n        \\n        int N=arr.size();\\n        string ans=\"\";\\n         sort(arr.begin(), arr.end());\\n        for(int i=0;i<arr[N-1].length();i++)\\n        {\\n            if(arr[0][i]==arr[N-1][i])\\n            {\\n                ans=ans+arr[0][i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        if(ans.length())\\n        return ans;\\n        return \"\";\\n    }\\n};"
                    },
                    {
                        "username": "RahulChan",
                        "content": "`String ans=\"\";\\n        String first=\"\";\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<strs.length;i++){\\n            if(strs[i].length()<=min){\\n                min=strs[i].length();\\n                first=strs[i];\\n            }\\n        }\\n        int k=0;\\n        for(int i=0;i<first.length();i++){\\n            int count=0;\\n            char ch=first.charAt(i);\\n            for(int j=0;j<strs.length;j++){\\n                if((ch==strs[j].charAt(k))){\\n                    count++;\\n                }\\n                if(count==0)\\n                    break;\\n            }\\n            k++;\\n            if(count<strs.length){\\n                break;\\n            }\\n            if(count==strs.length)\\n                ans+=ch;\\n        }\\n        return ans;`"
                    },
                    {
                        "username": "sadikhan918",
                        "content": "I threw together a solution really quick without caring for time complexity, and I\\'m getting a runtime error when I shouldn\\'t be?  \\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 14, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI\\'ve tested the specific use case in my own IDE and it returns the proper response. The test case was [\"\", \"\"] and the response was \"\". I don\\'t know why this error is popping up."
                    }
                ]
            },
            {
                "id": 1803861,
                "content": [
                    {
                        "username": "ajaykhot561",
                        "content": "For those who are getting confused between why first and last string is getting compared, here is the approach for them,\\nSo here when we sort string array we get sorted it in this form:\\nflight\\nflow\\nflower\\n\\nSo now it is sorted then we will compare first string with last flight with flower where our string character dont match break there and print the substring till that postion\\nc=2\\nsubstring(0,c);\\nans=fl\\n\\n"
                    },
                    {
                        "username": "achadharma334",
                        "content": "when to use  return and console.log( )  statements ?? I really got confused what to use "
                    },
                    {
                        "username": "ajaykhot561",
                        "content": "Coding in javascript?\\n"
                    },
                    {
                        "username": "zoe850610",
                        "content": "strs = [\"flower\",\"flow\",\"fsight\"]"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Is there any difference between below code in C Programming..??\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) \\n    and \\n    if(strs[0][col] != strs[row][col])\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) - not working\\n    and \\n    if(strs[0][col] != strs[row][col]) - working\\n\\nWhy???\\n    "
                    },
                    {
                        "username": "ayushkaintura567",
                        "content": "What if the inputted list has a single string only? like x=[\\'single\\']"
                    },
                    {
                        "username": "Dennis_8765",
                        "content": "This would be my Code, it works in Eclipse but does not here it tells me that Line 14 (t=strs[j].charAt(i);\\n) has a mistake:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 17, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nDO you know an answer?\\n\\n\\n\\tString in = \"\";\\n\\t\\tchar t=\\' \\';\\n\\t\\tboolean tr=false;\\n\\t\\tchar[] tn = new char[strs.length];\\n        \\t\\tif(strs[0]==\"\") {\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < strs.length; ++i) {\\n\\t\\t\\tfor (int j = 0; j < strs.length; ++j) {\\n                if(strs[j]!=null) {\\n\\t                t=strs[j].charAt(i);\\n\\t                tn[j]=t;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\tfor(int z=1;z<tn.length;++z) {\\n\\t\\t\\t\\tif(tn[z-1]==tn[z]) {\\n\\t\\t\\t\\t\\ttr=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ttr=false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(tr==true) {\\n\\t\\t\\t\\tin+=t;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn in;"
                    },
                    {
                        "username": "AmmarAlkhooly98",
                        "content": "**Tip/Hint:**\n\nI was first trying to solve this using KMP Algo, and adding a random special chars and numbers between each str, worked but has many edge cases, so if you are thinking of the same, there are simpler solutions that can be applied, think of looping vertically throughout the strings... \nGood Luck!\nCheck out my solution post [here](https://leetcode.com/problems/longest-common-prefix/solutions/3172147/looping-vertically-js-easy-optimal-solution-explained/)"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& arr) {\\n        \\n        int N=arr.size();\\n        string ans=\"\";\\n         sort(arr.begin(), arr.end());\\n        for(int i=0;i<arr[N-1].length();i++)\\n        {\\n            if(arr[0][i]==arr[N-1][i])\\n            {\\n                ans=ans+arr[0][i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        if(ans.length())\\n        return ans;\\n        return \"\";\\n    }\\n};"
                    },
                    {
                        "username": "RahulChan",
                        "content": "`String ans=\"\";\\n        String first=\"\";\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<strs.length;i++){\\n            if(strs[i].length()<=min){\\n                min=strs[i].length();\\n                first=strs[i];\\n            }\\n        }\\n        int k=0;\\n        for(int i=0;i<first.length();i++){\\n            int count=0;\\n            char ch=first.charAt(i);\\n            for(int j=0;j<strs.length;j++){\\n                if((ch==strs[j].charAt(k))){\\n                    count++;\\n                }\\n                if(count==0)\\n                    break;\\n            }\\n            k++;\\n            if(count<strs.length){\\n                break;\\n            }\\n            if(count==strs.length)\\n                ans+=ch;\\n        }\\n        return ans;`"
                    },
                    {
                        "username": "sadikhan918",
                        "content": "I threw together a solution really quick without caring for time complexity, and I\\'m getting a runtime error when I shouldn\\'t be?  \\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 14, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI\\'ve tested the specific use case in my own IDE and it returns the proper response. The test case was [\"\", \"\"] and the response was \"\". I don\\'t know why this error is popping up."
                    }
                ]
            },
            {
                "id": 1800636,
                "content": [
                    {
                        "username": "ajaykhot561",
                        "content": "For those who are getting confused between why first and last string is getting compared, here is the approach for them,\\nSo here when we sort string array we get sorted it in this form:\\nflight\\nflow\\nflower\\n\\nSo now it is sorted then we will compare first string with last flight with flower where our string character dont match break there and print the substring till that postion\\nc=2\\nsubstring(0,c);\\nans=fl\\n\\n"
                    },
                    {
                        "username": "achadharma334",
                        "content": "when to use  return and console.log( )  statements ?? I really got confused what to use "
                    },
                    {
                        "username": "ajaykhot561",
                        "content": "Coding in javascript?\\n"
                    },
                    {
                        "username": "zoe850610",
                        "content": "strs = [\"flower\",\"flow\",\"fsight\"]"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Is there any difference between below code in C Programming..??\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) \\n    and \\n    if(strs[0][col] != strs[row][col])\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) - not working\\n    and \\n    if(strs[0][col] != strs[row][col]) - working\\n\\nWhy???\\n    "
                    },
                    {
                        "username": "ayushkaintura567",
                        "content": "What if the inputted list has a single string only? like x=[\\'single\\']"
                    },
                    {
                        "username": "Dennis_8765",
                        "content": "This would be my Code, it works in Eclipse but does not here it tells me that Line 14 (t=strs[j].charAt(i);\\n) has a mistake:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 17, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nDO you know an answer?\\n\\n\\n\\tString in = \"\";\\n\\t\\tchar t=\\' \\';\\n\\t\\tboolean tr=false;\\n\\t\\tchar[] tn = new char[strs.length];\\n        \\t\\tif(strs[0]==\"\") {\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < strs.length; ++i) {\\n\\t\\t\\tfor (int j = 0; j < strs.length; ++j) {\\n                if(strs[j]!=null) {\\n\\t                t=strs[j].charAt(i);\\n\\t                tn[j]=t;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\tfor(int z=1;z<tn.length;++z) {\\n\\t\\t\\t\\tif(tn[z-1]==tn[z]) {\\n\\t\\t\\t\\t\\ttr=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ttr=false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(tr==true) {\\n\\t\\t\\t\\tin+=t;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn in;"
                    },
                    {
                        "username": "AmmarAlkhooly98",
                        "content": "**Tip/Hint:**\n\nI was first trying to solve this using KMP Algo, and adding a random special chars and numbers between each str, worked but has many edge cases, so if you are thinking of the same, there are simpler solutions that can be applied, think of looping vertically throughout the strings... \nGood Luck!\nCheck out my solution post [here](https://leetcode.com/problems/longest-common-prefix/solutions/3172147/looping-vertically-js-easy-optimal-solution-explained/)"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& arr) {\\n        \\n        int N=arr.size();\\n        string ans=\"\";\\n         sort(arr.begin(), arr.end());\\n        for(int i=0;i<arr[N-1].length();i++)\\n        {\\n            if(arr[0][i]==arr[N-1][i])\\n            {\\n                ans=ans+arr[0][i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        if(ans.length())\\n        return ans;\\n        return \"\";\\n    }\\n};"
                    },
                    {
                        "username": "RahulChan",
                        "content": "`String ans=\"\";\\n        String first=\"\";\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<strs.length;i++){\\n            if(strs[i].length()<=min){\\n                min=strs[i].length();\\n                first=strs[i];\\n            }\\n        }\\n        int k=0;\\n        for(int i=0;i<first.length();i++){\\n            int count=0;\\n            char ch=first.charAt(i);\\n            for(int j=0;j<strs.length;j++){\\n                if((ch==strs[j].charAt(k))){\\n                    count++;\\n                }\\n                if(count==0)\\n                    break;\\n            }\\n            k++;\\n            if(count<strs.length){\\n                break;\\n            }\\n            if(count==strs.length)\\n                ans+=ch;\\n        }\\n        return ans;`"
                    },
                    {
                        "username": "sadikhan918",
                        "content": "I threw together a solution really quick without caring for time complexity, and I\\'m getting a runtime error when I shouldn\\'t be?  \\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 14, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI\\'ve tested the specific use case in my own IDE and it returns the proper response. The test case was [\"\", \"\"] and the response was \"\". I don\\'t know why this error is popping up."
                    }
                ]
            },
            {
                "id": 1800532,
                "content": [
                    {
                        "username": "ajaykhot561",
                        "content": "For those who are getting confused between why first and last string is getting compared, here is the approach for them,\\nSo here when we sort string array we get sorted it in this form:\\nflight\\nflow\\nflower\\n\\nSo now it is sorted then we will compare first string with last flight with flower where our string character dont match break there and print the substring till that postion\\nc=2\\nsubstring(0,c);\\nans=fl\\n\\n"
                    },
                    {
                        "username": "achadharma334",
                        "content": "when to use  return and console.log( )  statements ?? I really got confused what to use "
                    },
                    {
                        "username": "ajaykhot561",
                        "content": "Coding in javascript?\\n"
                    },
                    {
                        "username": "zoe850610",
                        "content": "strs = [\"flower\",\"flow\",\"fsight\"]"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Is there any difference between below code in C Programming..??\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) \\n    and \\n    if(strs[0][col] != strs[row][col])\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) - not working\\n    and \\n    if(strs[0][col] != strs[row][col]) - working\\n\\nWhy???\\n    "
                    },
                    {
                        "username": "ayushkaintura567",
                        "content": "What if the inputted list has a single string only? like x=[\\'single\\']"
                    },
                    {
                        "username": "Dennis_8765",
                        "content": "This would be my Code, it works in Eclipse but does not here it tells me that Line 14 (t=strs[j].charAt(i);\\n) has a mistake:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 17, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nDO you know an answer?\\n\\n\\n\\tString in = \"\";\\n\\t\\tchar t=\\' \\';\\n\\t\\tboolean tr=false;\\n\\t\\tchar[] tn = new char[strs.length];\\n        \\t\\tif(strs[0]==\"\") {\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < strs.length; ++i) {\\n\\t\\t\\tfor (int j = 0; j < strs.length; ++j) {\\n                if(strs[j]!=null) {\\n\\t                t=strs[j].charAt(i);\\n\\t                tn[j]=t;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\tfor(int z=1;z<tn.length;++z) {\\n\\t\\t\\t\\tif(tn[z-1]==tn[z]) {\\n\\t\\t\\t\\t\\ttr=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ttr=false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(tr==true) {\\n\\t\\t\\t\\tin+=t;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn in;"
                    },
                    {
                        "username": "AmmarAlkhooly98",
                        "content": "**Tip/Hint:**\n\nI was first trying to solve this using KMP Algo, and adding a random special chars and numbers between each str, worked but has many edge cases, so if you are thinking of the same, there are simpler solutions that can be applied, think of looping vertically throughout the strings... \nGood Luck!\nCheck out my solution post [here](https://leetcode.com/problems/longest-common-prefix/solutions/3172147/looping-vertically-js-easy-optimal-solution-explained/)"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& arr) {\\n        \\n        int N=arr.size();\\n        string ans=\"\";\\n         sort(arr.begin(), arr.end());\\n        for(int i=0;i<arr[N-1].length();i++)\\n        {\\n            if(arr[0][i]==arr[N-1][i])\\n            {\\n                ans=ans+arr[0][i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        if(ans.length())\\n        return ans;\\n        return \"\";\\n    }\\n};"
                    },
                    {
                        "username": "RahulChan",
                        "content": "`String ans=\"\";\\n        String first=\"\";\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<strs.length;i++){\\n            if(strs[i].length()<=min){\\n                min=strs[i].length();\\n                first=strs[i];\\n            }\\n        }\\n        int k=0;\\n        for(int i=0;i<first.length();i++){\\n            int count=0;\\n            char ch=first.charAt(i);\\n            for(int j=0;j<strs.length;j++){\\n                if((ch==strs[j].charAt(k))){\\n                    count++;\\n                }\\n                if(count==0)\\n                    break;\\n            }\\n            k++;\\n            if(count<strs.length){\\n                break;\\n            }\\n            if(count==strs.length)\\n                ans+=ch;\\n        }\\n        return ans;`"
                    },
                    {
                        "username": "sadikhan918",
                        "content": "I threw together a solution really quick without caring for time complexity, and I\\'m getting a runtime error when I shouldn\\'t be?  \\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 14, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI\\'ve tested the specific use case in my own IDE and it returns the proper response. The test case was [\"\", \"\"] and the response was \"\". I don\\'t know why this error is popping up."
                    }
                ]
            },
            {
                "id": 1799998,
                "content": [
                    {
                        "username": "ajaykhot561",
                        "content": "For those who are getting confused between why first and last string is getting compared, here is the approach for them,\\nSo here when we sort string array we get sorted it in this form:\\nflight\\nflow\\nflower\\n\\nSo now it is sorted then we will compare first string with last flight with flower where our string character dont match break there and print the substring till that postion\\nc=2\\nsubstring(0,c);\\nans=fl\\n\\n"
                    },
                    {
                        "username": "achadharma334",
                        "content": "when to use  return and console.log( )  statements ?? I really got confused what to use "
                    },
                    {
                        "username": "ajaykhot561",
                        "content": "Coding in javascript?\\n"
                    },
                    {
                        "username": "zoe850610",
                        "content": "strs = [\"flower\",\"flow\",\"fsight\"]"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Is there any difference between below code in C Programming..??\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) \\n    and \\n    if(strs[0][col] != strs[row][col])\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) - not working\\n    and \\n    if(strs[0][col] != strs[row][col]) - working\\n\\nWhy???\\n    "
                    },
                    {
                        "username": "ayushkaintura567",
                        "content": "What if the inputted list has a single string only? like x=[\\'single\\']"
                    },
                    {
                        "username": "Dennis_8765",
                        "content": "This would be my Code, it works in Eclipse but does not here it tells me that Line 14 (t=strs[j].charAt(i);\\n) has a mistake:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 17, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nDO you know an answer?\\n\\n\\n\\tString in = \"\";\\n\\t\\tchar t=\\' \\';\\n\\t\\tboolean tr=false;\\n\\t\\tchar[] tn = new char[strs.length];\\n        \\t\\tif(strs[0]==\"\") {\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < strs.length; ++i) {\\n\\t\\t\\tfor (int j = 0; j < strs.length; ++j) {\\n                if(strs[j]!=null) {\\n\\t                t=strs[j].charAt(i);\\n\\t                tn[j]=t;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\tfor(int z=1;z<tn.length;++z) {\\n\\t\\t\\t\\tif(tn[z-1]==tn[z]) {\\n\\t\\t\\t\\t\\ttr=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ttr=false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(tr==true) {\\n\\t\\t\\t\\tin+=t;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn in;"
                    },
                    {
                        "username": "AmmarAlkhooly98",
                        "content": "**Tip/Hint:**\n\nI was first trying to solve this using KMP Algo, and adding a random special chars and numbers between each str, worked but has many edge cases, so if you are thinking of the same, there are simpler solutions that can be applied, think of looping vertically throughout the strings... \nGood Luck!\nCheck out my solution post [here](https://leetcode.com/problems/longest-common-prefix/solutions/3172147/looping-vertically-js-easy-optimal-solution-explained/)"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& arr) {\\n        \\n        int N=arr.size();\\n        string ans=\"\";\\n         sort(arr.begin(), arr.end());\\n        for(int i=0;i<arr[N-1].length();i++)\\n        {\\n            if(arr[0][i]==arr[N-1][i])\\n            {\\n                ans=ans+arr[0][i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        if(ans.length())\\n        return ans;\\n        return \"\";\\n    }\\n};"
                    },
                    {
                        "username": "RahulChan",
                        "content": "`String ans=\"\";\\n        String first=\"\";\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<strs.length;i++){\\n            if(strs[i].length()<=min){\\n                min=strs[i].length();\\n                first=strs[i];\\n            }\\n        }\\n        int k=0;\\n        for(int i=0;i<first.length();i++){\\n            int count=0;\\n            char ch=first.charAt(i);\\n            for(int j=0;j<strs.length;j++){\\n                if((ch==strs[j].charAt(k))){\\n                    count++;\\n                }\\n                if(count==0)\\n                    break;\\n            }\\n            k++;\\n            if(count<strs.length){\\n                break;\\n            }\\n            if(count==strs.length)\\n                ans+=ch;\\n        }\\n        return ans;`"
                    },
                    {
                        "username": "sadikhan918",
                        "content": "I threw together a solution really quick without caring for time complexity, and I\\'m getting a runtime error when I shouldn\\'t be?  \\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 14, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI\\'ve tested the specific use case in my own IDE and it returns the proper response. The test case was [\"\", \"\"] and the response was \"\". I don\\'t know why this error is popping up."
                    }
                ]
            },
            {
                "id": 1796736,
                "content": [
                    {
                        "username": "ajaykhot561",
                        "content": "For those who are getting confused between why first and last string is getting compared, here is the approach for them,\\nSo here when we sort string array we get sorted it in this form:\\nflight\\nflow\\nflower\\n\\nSo now it is sorted then we will compare first string with last flight with flower where our string character dont match break there and print the substring till that postion\\nc=2\\nsubstring(0,c);\\nans=fl\\n\\n"
                    },
                    {
                        "username": "achadharma334",
                        "content": "when to use  return and console.log( )  statements ?? I really got confused what to use "
                    },
                    {
                        "username": "ajaykhot561",
                        "content": "Coding in javascript?\\n"
                    },
                    {
                        "username": "zoe850610",
                        "content": "strs = [\"flower\",\"flow\",\"fsight\"]"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Is there any difference between below code in C Programming..??\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) \\n    and \\n    if(strs[0][col] != strs[row][col])\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) - not working\\n    and \\n    if(strs[0][col] != strs[row][col]) - working\\n\\nWhy???\\n    "
                    },
                    {
                        "username": "ayushkaintura567",
                        "content": "What if the inputted list has a single string only? like x=[\\'single\\']"
                    },
                    {
                        "username": "Dennis_8765",
                        "content": "This would be my Code, it works in Eclipse but does not here it tells me that Line 14 (t=strs[j].charAt(i);\\n) has a mistake:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 17, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nDO you know an answer?\\n\\n\\n\\tString in = \"\";\\n\\t\\tchar t=\\' \\';\\n\\t\\tboolean tr=false;\\n\\t\\tchar[] tn = new char[strs.length];\\n        \\t\\tif(strs[0]==\"\") {\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < strs.length; ++i) {\\n\\t\\t\\tfor (int j = 0; j < strs.length; ++j) {\\n                if(strs[j]!=null) {\\n\\t                t=strs[j].charAt(i);\\n\\t                tn[j]=t;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\tfor(int z=1;z<tn.length;++z) {\\n\\t\\t\\t\\tif(tn[z-1]==tn[z]) {\\n\\t\\t\\t\\t\\ttr=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ttr=false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(tr==true) {\\n\\t\\t\\t\\tin+=t;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn in;"
                    },
                    {
                        "username": "AmmarAlkhooly98",
                        "content": "**Tip/Hint:**\n\nI was first trying to solve this using KMP Algo, and adding a random special chars and numbers between each str, worked but has many edge cases, so if you are thinking of the same, there are simpler solutions that can be applied, think of looping vertically throughout the strings... \nGood Luck!\nCheck out my solution post [here](https://leetcode.com/problems/longest-common-prefix/solutions/3172147/looping-vertically-js-easy-optimal-solution-explained/)"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& arr) {\\n        \\n        int N=arr.size();\\n        string ans=\"\";\\n         sort(arr.begin(), arr.end());\\n        for(int i=0;i<arr[N-1].length();i++)\\n        {\\n            if(arr[0][i]==arr[N-1][i])\\n            {\\n                ans=ans+arr[0][i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        if(ans.length())\\n        return ans;\\n        return \"\";\\n    }\\n};"
                    },
                    {
                        "username": "RahulChan",
                        "content": "`String ans=\"\";\\n        String first=\"\";\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<strs.length;i++){\\n            if(strs[i].length()<=min){\\n                min=strs[i].length();\\n                first=strs[i];\\n            }\\n        }\\n        int k=0;\\n        for(int i=0;i<first.length();i++){\\n            int count=0;\\n            char ch=first.charAt(i);\\n            for(int j=0;j<strs.length;j++){\\n                if((ch==strs[j].charAt(k))){\\n                    count++;\\n                }\\n                if(count==0)\\n                    break;\\n            }\\n            k++;\\n            if(count<strs.length){\\n                break;\\n            }\\n            if(count==strs.length)\\n                ans+=ch;\\n        }\\n        return ans;`"
                    },
                    {
                        "username": "sadikhan918",
                        "content": "I threw together a solution really quick without caring for time complexity, and I\\'m getting a runtime error when I shouldn\\'t be?  \\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 14, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI\\'ve tested the specific use case in my own IDE and it returns the proper response. The test case was [\"\", \"\"] and the response was \"\". I don\\'t know why this error is popping up."
                    }
                ]
            },
            {
                "id": 1794688,
                "content": [
                    {
                        "username": "ajaykhot561",
                        "content": "For those who are getting confused between why first and last string is getting compared, here is the approach for them,\\nSo here when we sort string array we get sorted it in this form:\\nflight\\nflow\\nflower\\n\\nSo now it is sorted then we will compare first string with last flight with flower where our string character dont match break there and print the substring till that postion\\nc=2\\nsubstring(0,c);\\nans=fl\\n\\n"
                    },
                    {
                        "username": "achadharma334",
                        "content": "when to use  return and console.log( )  statements ?? I really got confused what to use "
                    },
                    {
                        "username": "ajaykhot561",
                        "content": "Coding in javascript?\\n"
                    },
                    {
                        "username": "zoe850610",
                        "content": "strs = [\"flower\",\"flow\",\"fsight\"]"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Is there any difference between below code in C Programming..??\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) \\n    and \\n    if(strs[0][col] != strs[row][col])\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) - not working\\n    and \\n    if(strs[0][col] != strs[row][col]) - working\\n\\nWhy???\\n    "
                    },
                    {
                        "username": "ayushkaintura567",
                        "content": "What if the inputted list has a single string only? like x=[\\'single\\']"
                    },
                    {
                        "username": "Dennis_8765",
                        "content": "This would be my Code, it works in Eclipse but does not here it tells me that Line 14 (t=strs[j].charAt(i);\\n) has a mistake:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 17, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nDO you know an answer?\\n\\n\\n\\tString in = \"\";\\n\\t\\tchar t=\\' \\';\\n\\t\\tboolean tr=false;\\n\\t\\tchar[] tn = new char[strs.length];\\n        \\t\\tif(strs[0]==\"\") {\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < strs.length; ++i) {\\n\\t\\t\\tfor (int j = 0; j < strs.length; ++j) {\\n                if(strs[j]!=null) {\\n\\t                t=strs[j].charAt(i);\\n\\t                tn[j]=t;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\tfor(int z=1;z<tn.length;++z) {\\n\\t\\t\\t\\tif(tn[z-1]==tn[z]) {\\n\\t\\t\\t\\t\\ttr=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ttr=false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(tr==true) {\\n\\t\\t\\t\\tin+=t;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn in;"
                    },
                    {
                        "username": "AmmarAlkhooly98",
                        "content": "**Tip/Hint:**\n\nI was first trying to solve this using KMP Algo, and adding a random special chars and numbers between each str, worked but has many edge cases, so if you are thinking of the same, there are simpler solutions that can be applied, think of looping vertically throughout the strings... \nGood Luck!\nCheck out my solution post [here](https://leetcode.com/problems/longest-common-prefix/solutions/3172147/looping-vertically-js-easy-optimal-solution-explained/)"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& arr) {\\n        \\n        int N=arr.size();\\n        string ans=\"\";\\n         sort(arr.begin(), arr.end());\\n        for(int i=0;i<arr[N-1].length();i++)\\n        {\\n            if(arr[0][i]==arr[N-1][i])\\n            {\\n                ans=ans+arr[0][i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        if(ans.length())\\n        return ans;\\n        return \"\";\\n    }\\n};"
                    },
                    {
                        "username": "RahulChan",
                        "content": "`String ans=\"\";\\n        String first=\"\";\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<strs.length;i++){\\n            if(strs[i].length()<=min){\\n                min=strs[i].length();\\n                first=strs[i];\\n            }\\n        }\\n        int k=0;\\n        for(int i=0;i<first.length();i++){\\n            int count=0;\\n            char ch=first.charAt(i);\\n            for(int j=0;j<strs.length;j++){\\n                if((ch==strs[j].charAt(k))){\\n                    count++;\\n                }\\n                if(count==0)\\n                    break;\\n            }\\n            k++;\\n            if(count<strs.length){\\n                break;\\n            }\\n            if(count==strs.length)\\n                ans+=ch;\\n        }\\n        return ans;`"
                    },
                    {
                        "username": "sadikhan918",
                        "content": "I threw together a solution really quick without caring for time complexity, and I\\'m getting a runtime error when I shouldn\\'t be?  \\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 14, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI\\'ve tested the specific use case in my own IDE and it returns the proper response. The test case was [\"\", \"\"] and the response was \"\". I don\\'t know why this error is popping up."
                    }
                ]
            },
            {
                "id": 1791785,
                "content": [
                    {
                        "username": "ajaykhot561",
                        "content": "For those who are getting confused between why first and last string is getting compared, here is the approach for them,\\nSo here when we sort string array we get sorted it in this form:\\nflight\\nflow\\nflower\\n\\nSo now it is sorted then we will compare first string with last flight with flower where our string character dont match break there and print the substring till that postion\\nc=2\\nsubstring(0,c);\\nans=fl\\n\\n"
                    },
                    {
                        "username": "achadharma334",
                        "content": "when to use  return and console.log( )  statements ?? I really got confused what to use "
                    },
                    {
                        "username": "ajaykhot561",
                        "content": "Coding in javascript?\\n"
                    },
                    {
                        "username": "zoe850610",
                        "content": "strs = [\"flower\",\"flow\",\"fsight\"]"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Is there any difference between below code in C Programming..??\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) \\n    and \\n    if(strs[0][col] != strs[row][col])\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) - not working\\n    and \\n    if(strs[0][col] != strs[row][col]) - working\\n\\nWhy???\\n    "
                    },
                    {
                        "username": "ayushkaintura567",
                        "content": "What if the inputted list has a single string only? like x=[\\'single\\']"
                    },
                    {
                        "username": "Dennis_8765",
                        "content": "This would be my Code, it works in Eclipse but does not here it tells me that Line 14 (t=strs[j].charAt(i);\\n) has a mistake:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 17, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nDO you know an answer?\\n\\n\\n\\tString in = \"\";\\n\\t\\tchar t=\\' \\';\\n\\t\\tboolean tr=false;\\n\\t\\tchar[] tn = new char[strs.length];\\n        \\t\\tif(strs[0]==\"\") {\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < strs.length; ++i) {\\n\\t\\t\\tfor (int j = 0; j < strs.length; ++j) {\\n                if(strs[j]!=null) {\\n\\t                t=strs[j].charAt(i);\\n\\t                tn[j]=t;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\tfor(int z=1;z<tn.length;++z) {\\n\\t\\t\\t\\tif(tn[z-1]==tn[z]) {\\n\\t\\t\\t\\t\\ttr=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ttr=false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(tr==true) {\\n\\t\\t\\t\\tin+=t;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn in;"
                    },
                    {
                        "username": "AmmarAlkhooly98",
                        "content": "**Tip/Hint:**\n\nI was first trying to solve this using KMP Algo, and adding a random special chars and numbers between each str, worked but has many edge cases, so if you are thinking of the same, there are simpler solutions that can be applied, think of looping vertically throughout the strings... \nGood Luck!\nCheck out my solution post [here](https://leetcode.com/problems/longest-common-prefix/solutions/3172147/looping-vertically-js-easy-optimal-solution-explained/)"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& arr) {\\n        \\n        int N=arr.size();\\n        string ans=\"\";\\n         sort(arr.begin(), arr.end());\\n        for(int i=0;i<arr[N-1].length();i++)\\n        {\\n            if(arr[0][i]==arr[N-1][i])\\n            {\\n                ans=ans+arr[0][i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        if(ans.length())\\n        return ans;\\n        return \"\";\\n    }\\n};"
                    },
                    {
                        "username": "RahulChan",
                        "content": "`String ans=\"\";\\n        String first=\"\";\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<strs.length;i++){\\n            if(strs[i].length()<=min){\\n                min=strs[i].length();\\n                first=strs[i];\\n            }\\n        }\\n        int k=0;\\n        for(int i=0;i<first.length();i++){\\n            int count=0;\\n            char ch=first.charAt(i);\\n            for(int j=0;j<strs.length;j++){\\n                if((ch==strs[j].charAt(k))){\\n                    count++;\\n                }\\n                if(count==0)\\n                    break;\\n            }\\n            k++;\\n            if(count<strs.length){\\n                break;\\n            }\\n            if(count==strs.length)\\n                ans+=ch;\\n        }\\n        return ans;`"
                    },
                    {
                        "username": "sadikhan918",
                        "content": "I threw together a solution really quick without caring for time complexity, and I\\'m getting a runtime error when I shouldn\\'t be?  \\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 14, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI\\'ve tested the specific use case in my own IDE and it returns the proper response. The test case was [\"\", \"\"] and the response was \"\". I don\\'t know why this error is popping up."
                    }
                ]
            },
            {
                "id": 1782812,
                "content": [
                    {
                        "username": "ajaykhot561",
                        "content": "For those who are getting confused between why first and last string is getting compared, here is the approach for them,\\nSo here when we sort string array we get sorted it in this form:\\nflight\\nflow\\nflower\\n\\nSo now it is sorted then we will compare first string with last flight with flower where our string character dont match break there and print the substring till that postion\\nc=2\\nsubstring(0,c);\\nans=fl\\n\\n"
                    },
                    {
                        "username": "achadharma334",
                        "content": "when to use  return and console.log( )  statements ?? I really got confused what to use "
                    },
                    {
                        "username": "ajaykhot561",
                        "content": "Coding in javascript?\\n"
                    },
                    {
                        "username": "zoe850610",
                        "content": "strs = [\"flower\",\"flow\",\"fsight\"]"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Is there any difference between below code in C Programming..??\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) \\n    and \\n    if(strs[0][col] != strs[row][col])\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) - not working\\n    and \\n    if(strs[0][col] != strs[row][col]) - working\\n\\nWhy???\\n    "
                    },
                    {
                        "username": "ayushkaintura567",
                        "content": "What if the inputted list has a single string only? like x=[\\'single\\']"
                    },
                    {
                        "username": "Dennis_8765",
                        "content": "This would be my Code, it works in Eclipse but does not here it tells me that Line 14 (t=strs[j].charAt(i);\\n) has a mistake:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 17, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nDO you know an answer?\\n\\n\\n\\tString in = \"\";\\n\\t\\tchar t=\\' \\';\\n\\t\\tboolean tr=false;\\n\\t\\tchar[] tn = new char[strs.length];\\n        \\t\\tif(strs[0]==\"\") {\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < strs.length; ++i) {\\n\\t\\t\\tfor (int j = 0; j < strs.length; ++j) {\\n                if(strs[j]!=null) {\\n\\t                t=strs[j].charAt(i);\\n\\t                tn[j]=t;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\tfor(int z=1;z<tn.length;++z) {\\n\\t\\t\\t\\tif(tn[z-1]==tn[z]) {\\n\\t\\t\\t\\t\\ttr=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ttr=false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(tr==true) {\\n\\t\\t\\t\\tin+=t;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn in;"
                    },
                    {
                        "username": "AmmarAlkhooly98",
                        "content": "**Tip/Hint:**\n\nI was first trying to solve this using KMP Algo, and adding a random special chars and numbers between each str, worked but has many edge cases, so if you are thinking of the same, there are simpler solutions that can be applied, think of looping vertically throughout the strings... \nGood Luck!\nCheck out my solution post [here](https://leetcode.com/problems/longest-common-prefix/solutions/3172147/looping-vertically-js-easy-optimal-solution-explained/)"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& arr) {\\n        \\n        int N=arr.size();\\n        string ans=\"\";\\n         sort(arr.begin(), arr.end());\\n        for(int i=0;i<arr[N-1].length();i++)\\n        {\\n            if(arr[0][i]==arr[N-1][i])\\n            {\\n                ans=ans+arr[0][i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        if(ans.length())\\n        return ans;\\n        return \"\";\\n    }\\n};"
                    },
                    {
                        "username": "RahulChan",
                        "content": "`String ans=\"\";\\n        String first=\"\";\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<strs.length;i++){\\n            if(strs[i].length()<=min){\\n                min=strs[i].length();\\n                first=strs[i];\\n            }\\n        }\\n        int k=0;\\n        for(int i=0;i<first.length();i++){\\n            int count=0;\\n            char ch=first.charAt(i);\\n            for(int j=0;j<strs.length;j++){\\n                if((ch==strs[j].charAt(k))){\\n                    count++;\\n                }\\n                if(count==0)\\n                    break;\\n            }\\n            k++;\\n            if(count<strs.length){\\n                break;\\n            }\\n            if(count==strs.length)\\n                ans+=ch;\\n        }\\n        return ans;`"
                    },
                    {
                        "username": "sadikhan918",
                        "content": "I threw together a solution really quick without caring for time complexity, and I\\'m getting a runtime error when I shouldn\\'t be?  \\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 14, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI\\'ve tested the specific use case in my own IDE and it returns the proper response. The test case was [\"\", \"\"] and the response was \"\". I don\\'t know why this error is popping up."
                    }
                ]
            },
            {
                "id": 1782389,
                "content": [
                    {
                        "username": "dracont666",
                        "content": "\\nI changed the order of the elements in the list to [\"flower\",\"flight\",\"flow\"]\\n\\nI then used my solution, which in this case returns \"flow\" not \\'fl\\' and the system accepted that decision in Python 3.\\n\\nThis is mistake?"
                    },
                    {
                        "username": "NazarBestCoder",
                        "content": "is it Normal ? \"c\",\"acc\",\"ccc\" -> \"\" , Why not \"c\" ? \\nCan SomeBody Explain me ?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "It cannot be c because the second strong \"acc\" starts with a. \\nPrefix is the First group of letters common to every string"
                    },
                    {
                        "username": "goodguygoddy",
                        "content": "What is the most optimized time complexity for this question? "
                    },
                    {
                        "username": "user7734BK",
                        "content": "it should be O(s), with s the number of total characters"
                    },
                    {
                        "username": "codebrownie",
                        "content": "The main thing here is we have to match characters of the strings consecutively if first character is matched and next doesn\\'t match then we would break the loop, else it would consider the all matching characters.\\nAnd if any length of  any the string is 0 then simply return empty string."
                    },
                    {
                        "username": "Abed_UK",
                        "content": "there is an issue in testcase 120:\\n[\\'flower\\',\\'fkow\\']\\nit is obvious that the ansr is \\'ow\\' but the concole says \\'f\\'?  could anyone help??"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "[@Abed_UK](/Abed_UK) np man. If u get past test case 106 let me know Im stuck on that one it says answer is \\u201C\\u201D and mine returns \\u201C\\u201D but its wrong? Like what? XD"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "[@MichaelG123](/MichaelG123) Thanks bro I thought he was asking for the longest sequence."
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Prefix means the first letter(s) of a word\nFlower, fkow both start with f\n"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Passed 106/124 testcases.\\n\\nfailed on [\"\",\"\"]\\n\\noutput\\n\"\"\\n\\nExpected \\n\"\"\\n\\nAm I missing something here...?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Send the code :)"
                    },
                    {
                        "username": "FaMaSk",
                        "content": "How to fix\\nUnhandled exception. System.IndexOutOfRangeException: Index was outside the bounds of the array.\\nAt Solution.LongestCommonPrefix(String[] strs)\\nAt __Driver__.Main(String[] args)\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Uhm maybe you incremented one of your indexes one way too much. It happened to me too and It was in a very hidden place so It was difficult to figure It out. I suggest you to try changing your indexes (adding -1)in the indicated functions"
                    },
                    {
                        "username": "Amarnath0_o",
                        "content": " `getting the following error\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  basic_string::at: __n (which is 4) >= this->size() (which is 4) pls help\\ncode:\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string lcp =\"\";\\n        for(int i=0;i<strs.size();i++){\\n            for(int k=0;k<i;k++){\\n                int j=0;\\n                \\n                while(strs[k].at(j)!=\\'\\\\0\\'||strs[i].at(j)!=\\'\\\\0\\'){\\n                    if(strs[k].at(j)==strs[i].at(j)){\\n                        lcp+=strs[k].at(j);\\n                        j++;\\n                    }\\n                    else{\\n                        lcp=\"\";\\n                        break;\\n                    }\\n                }\\n                    \\n                \\n            }\\n        }\\n       return lcp; \\n    }\\n};"
                    },
                    {
                        "username": "sahilsandi07",
                        "content": "You can modify the below code :)\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        if len(strs) == 1:\\n            return strs[0]\\n        strs.sort()\\n        first = strs[0]\\n        last = strs[-1]\\n        for i, char in enumerate(first):\\n            if char != last[i]:\\n                return first[:i]\\n        return first"
                    },
                    {
                        "username": "Walzr",
                        "content": "strs = [\"abca\",\"aba\",\"aaab\"]\\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        i=0\\n        prefix = \"\"\\n        size = len(strs)\\n        if size ==0:\\n            return \"\"\\n        if size ==1:\\n            return strs[0]\\n        if strs[i] == \"\" or strs[i+1] ==\"\" or strs[size-1]==\"\":\\n            return \"\" \\n        else:\\n            strs.sort()\\n        if len(set(strs)) == 1:\\n            return strs[0]\\n        while i < len(strs)-1 and strs[i][i] == strs[i+1][i] and strs[size-1][i] == strs[i][i]:\\n            prefix +=strs[i][i]\\n            i+=1\\n        return prefix\\n\\nI dont understand why my output is \"ab\" instead of \"a\". Can someone explain?"
                    }
                ]
            },
            {
                "id": 1780299,
                "content": [
                    {
                        "username": "dracont666",
                        "content": "\\nI changed the order of the elements in the list to [\"flower\",\"flight\",\"flow\"]\\n\\nI then used my solution, which in this case returns \"flow\" not \\'fl\\' and the system accepted that decision in Python 3.\\n\\nThis is mistake?"
                    },
                    {
                        "username": "NazarBestCoder",
                        "content": "is it Normal ? \"c\",\"acc\",\"ccc\" -> \"\" , Why not \"c\" ? \\nCan SomeBody Explain me ?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "It cannot be c because the second strong \"acc\" starts with a. \\nPrefix is the First group of letters common to every string"
                    },
                    {
                        "username": "goodguygoddy",
                        "content": "What is the most optimized time complexity for this question? "
                    },
                    {
                        "username": "user7734BK",
                        "content": "it should be O(s), with s the number of total characters"
                    },
                    {
                        "username": "codebrownie",
                        "content": "The main thing here is we have to match characters of the strings consecutively if first character is matched and next doesn\\'t match then we would break the loop, else it would consider the all matching characters.\\nAnd if any length of  any the string is 0 then simply return empty string."
                    },
                    {
                        "username": "Abed_UK",
                        "content": "there is an issue in testcase 120:\\n[\\'flower\\',\\'fkow\\']\\nit is obvious that the ansr is \\'ow\\' but the concole says \\'f\\'?  could anyone help??"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "[@Abed_UK](/Abed_UK) np man. If u get past test case 106 let me know Im stuck on that one it says answer is \\u201C\\u201D and mine returns \\u201C\\u201D but its wrong? Like what? XD"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "[@MichaelG123](/MichaelG123) Thanks bro I thought he was asking for the longest sequence."
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Prefix means the first letter(s) of a word\nFlower, fkow both start with f\n"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Passed 106/124 testcases.\\n\\nfailed on [\"\",\"\"]\\n\\noutput\\n\"\"\\n\\nExpected \\n\"\"\\n\\nAm I missing something here...?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Send the code :)"
                    },
                    {
                        "username": "FaMaSk",
                        "content": "How to fix\\nUnhandled exception. System.IndexOutOfRangeException: Index was outside the bounds of the array.\\nAt Solution.LongestCommonPrefix(String[] strs)\\nAt __Driver__.Main(String[] args)\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Uhm maybe you incremented one of your indexes one way too much. It happened to me too and It was in a very hidden place so It was difficult to figure It out. I suggest you to try changing your indexes (adding -1)in the indicated functions"
                    },
                    {
                        "username": "Amarnath0_o",
                        "content": " `getting the following error\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  basic_string::at: __n (which is 4) >= this->size() (which is 4) pls help\\ncode:\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string lcp =\"\";\\n        for(int i=0;i<strs.size();i++){\\n            for(int k=0;k<i;k++){\\n                int j=0;\\n                \\n                while(strs[k].at(j)!=\\'\\\\0\\'||strs[i].at(j)!=\\'\\\\0\\'){\\n                    if(strs[k].at(j)==strs[i].at(j)){\\n                        lcp+=strs[k].at(j);\\n                        j++;\\n                    }\\n                    else{\\n                        lcp=\"\";\\n                        break;\\n                    }\\n                }\\n                    \\n                \\n            }\\n        }\\n       return lcp; \\n    }\\n};"
                    },
                    {
                        "username": "sahilsandi07",
                        "content": "You can modify the below code :)\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        if len(strs) == 1:\\n            return strs[0]\\n        strs.sort()\\n        first = strs[0]\\n        last = strs[-1]\\n        for i, char in enumerate(first):\\n            if char != last[i]:\\n                return first[:i]\\n        return first"
                    },
                    {
                        "username": "Walzr",
                        "content": "strs = [\"abca\",\"aba\",\"aaab\"]\\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        i=0\\n        prefix = \"\"\\n        size = len(strs)\\n        if size ==0:\\n            return \"\"\\n        if size ==1:\\n            return strs[0]\\n        if strs[i] == \"\" or strs[i+1] ==\"\" or strs[size-1]==\"\":\\n            return \"\" \\n        else:\\n            strs.sort()\\n        if len(set(strs)) == 1:\\n            return strs[0]\\n        while i < len(strs)-1 and strs[i][i] == strs[i+1][i] and strs[size-1][i] == strs[i][i]:\\n            prefix +=strs[i][i]\\n            i+=1\\n        return prefix\\n\\nI dont understand why my output is \"ab\" instead of \"a\". Can someone explain?"
                    }
                ]
            },
            {
                "id": 1777075,
                "content": [
                    {
                        "username": "dracont666",
                        "content": "\\nI changed the order of the elements in the list to [\"flower\",\"flight\",\"flow\"]\\n\\nI then used my solution, which in this case returns \"flow\" not \\'fl\\' and the system accepted that decision in Python 3.\\n\\nThis is mistake?"
                    },
                    {
                        "username": "NazarBestCoder",
                        "content": "is it Normal ? \"c\",\"acc\",\"ccc\" -> \"\" , Why not \"c\" ? \\nCan SomeBody Explain me ?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "It cannot be c because the second strong \"acc\" starts with a. \\nPrefix is the First group of letters common to every string"
                    },
                    {
                        "username": "goodguygoddy",
                        "content": "What is the most optimized time complexity for this question? "
                    },
                    {
                        "username": "user7734BK",
                        "content": "it should be O(s), with s the number of total characters"
                    },
                    {
                        "username": "codebrownie",
                        "content": "The main thing here is we have to match characters of the strings consecutively if first character is matched and next doesn\\'t match then we would break the loop, else it would consider the all matching characters.\\nAnd if any length of  any the string is 0 then simply return empty string."
                    },
                    {
                        "username": "Abed_UK",
                        "content": "there is an issue in testcase 120:\\n[\\'flower\\',\\'fkow\\']\\nit is obvious that the ansr is \\'ow\\' but the concole says \\'f\\'?  could anyone help??"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "[@Abed_UK](/Abed_UK) np man. If u get past test case 106 let me know Im stuck on that one it says answer is \\u201C\\u201D and mine returns \\u201C\\u201D but its wrong? Like what? XD"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "[@MichaelG123](/MichaelG123) Thanks bro I thought he was asking for the longest sequence."
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Prefix means the first letter(s) of a word\nFlower, fkow both start with f\n"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Passed 106/124 testcases.\\n\\nfailed on [\"\",\"\"]\\n\\noutput\\n\"\"\\n\\nExpected \\n\"\"\\n\\nAm I missing something here...?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Send the code :)"
                    },
                    {
                        "username": "FaMaSk",
                        "content": "How to fix\\nUnhandled exception. System.IndexOutOfRangeException: Index was outside the bounds of the array.\\nAt Solution.LongestCommonPrefix(String[] strs)\\nAt __Driver__.Main(String[] args)\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Uhm maybe you incremented one of your indexes one way too much. It happened to me too and It was in a very hidden place so It was difficult to figure It out. I suggest you to try changing your indexes (adding -1)in the indicated functions"
                    },
                    {
                        "username": "Amarnath0_o",
                        "content": " `getting the following error\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  basic_string::at: __n (which is 4) >= this->size() (which is 4) pls help\\ncode:\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string lcp =\"\";\\n        for(int i=0;i<strs.size();i++){\\n            for(int k=0;k<i;k++){\\n                int j=0;\\n                \\n                while(strs[k].at(j)!=\\'\\\\0\\'||strs[i].at(j)!=\\'\\\\0\\'){\\n                    if(strs[k].at(j)==strs[i].at(j)){\\n                        lcp+=strs[k].at(j);\\n                        j++;\\n                    }\\n                    else{\\n                        lcp=\"\";\\n                        break;\\n                    }\\n                }\\n                    \\n                \\n            }\\n        }\\n       return lcp; \\n    }\\n};"
                    },
                    {
                        "username": "sahilsandi07",
                        "content": "You can modify the below code :)\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        if len(strs) == 1:\\n            return strs[0]\\n        strs.sort()\\n        first = strs[0]\\n        last = strs[-1]\\n        for i, char in enumerate(first):\\n            if char != last[i]:\\n                return first[:i]\\n        return first"
                    },
                    {
                        "username": "Walzr",
                        "content": "strs = [\"abca\",\"aba\",\"aaab\"]\\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        i=0\\n        prefix = \"\"\\n        size = len(strs)\\n        if size ==0:\\n            return \"\"\\n        if size ==1:\\n            return strs[0]\\n        if strs[i] == \"\" or strs[i+1] ==\"\" or strs[size-1]==\"\":\\n            return \"\" \\n        else:\\n            strs.sort()\\n        if len(set(strs)) == 1:\\n            return strs[0]\\n        while i < len(strs)-1 and strs[i][i] == strs[i+1][i] and strs[size-1][i] == strs[i][i]:\\n            prefix +=strs[i][i]\\n            i+=1\\n        return prefix\\n\\nI dont understand why my output is \"ab\" instead of \"a\". Can someone explain?"
                    }
                ]
            },
            {
                "id": 1776625,
                "content": [
                    {
                        "username": "dracont666",
                        "content": "\\nI changed the order of the elements in the list to [\"flower\",\"flight\",\"flow\"]\\n\\nI then used my solution, which in this case returns \"flow\" not \\'fl\\' and the system accepted that decision in Python 3.\\n\\nThis is mistake?"
                    },
                    {
                        "username": "NazarBestCoder",
                        "content": "is it Normal ? \"c\",\"acc\",\"ccc\" -> \"\" , Why not \"c\" ? \\nCan SomeBody Explain me ?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "It cannot be c because the second strong \"acc\" starts with a. \\nPrefix is the First group of letters common to every string"
                    },
                    {
                        "username": "goodguygoddy",
                        "content": "What is the most optimized time complexity for this question? "
                    },
                    {
                        "username": "user7734BK",
                        "content": "it should be O(s), with s the number of total characters"
                    },
                    {
                        "username": "codebrownie",
                        "content": "The main thing here is we have to match characters of the strings consecutively if first character is matched and next doesn\\'t match then we would break the loop, else it would consider the all matching characters.\\nAnd if any length of  any the string is 0 then simply return empty string."
                    },
                    {
                        "username": "Abed_UK",
                        "content": "there is an issue in testcase 120:\\n[\\'flower\\',\\'fkow\\']\\nit is obvious that the ansr is \\'ow\\' but the concole says \\'f\\'?  could anyone help??"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "[@Abed_UK](/Abed_UK) np man. If u get past test case 106 let me know Im stuck on that one it says answer is \\u201C\\u201D and mine returns \\u201C\\u201D but its wrong? Like what? XD"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "[@MichaelG123](/MichaelG123) Thanks bro I thought he was asking for the longest sequence."
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Prefix means the first letter(s) of a word\nFlower, fkow both start with f\n"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Passed 106/124 testcases.\\n\\nfailed on [\"\",\"\"]\\n\\noutput\\n\"\"\\n\\nExpected \\n\"\"\\n\\nAm I missing something here...?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Send the code :)"
                    },
                    {
                        "username": "FaMaSk",
                        "content": "How to fix\\nUnhandled exception. System.IndexOutOfRangeException: Index was outside the bounds of the array.\\nAt Solution.LongestCommonPrefix(String[] strs)\\nAt __Driver__.Main(String[] args)\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Uhm maybe you incremented one of your indexes one way too much. It happened to me too and It was in a very hidden place so It was difficult to figure It out. I suggest you to try changing your indexes (adding -1)in the indicated functions"
                    },
                    {
                        "username": "Amarnath0_o",
                        "content": " `getting the following error\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  basic_string::at: __n (which is 4) >= this->size() (which is 4) pls help\\ncode:\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string lcp =\"\";\\n        for(int i=0;i<strs.size();i++){\\n            for(int k=0;k<i;k++){\\n                int j=0;\\n                \\n                while(strs[k].at(j)!=\\'\\\\0\\'||strs[i].at(j)!=\\'\\\\0\\'){\\n                    if(strs[k].at(j)==strs[i].at(j)){\\n                        lcp+=strs[k].at(j);\\n                        j++;\\n                    }\\n                    else{\\n                        lcp=\"\";\\n                        break;\\n                    }\\n                }\\n                    \\n                \\n            }\\n        }\\n       return lcp; \\n    }\\n};"
                    },
                    {
                        "username": "sahilsandi07",
                        "content": "You can modify the below code :)\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        if len(strs) == 1:\\n            return strs[0]\\n        strs.sort()\\n        first = strs[0]\\n        last = strs[-1]\\n        for i, char in enumerate(first):\\n            if char != last[i]:\\n                return first[:i]\\n        return first"
                    },
                    {
                        "username": "Walzr",
                        "content": "strs = [\"abca\",\"aba\",\"aaab\"]\\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        i=0\\n        prefix = \"\"\\n        size = len(strs)\\n        if size ==0:\\n            return \"\"\\n        if size ==1:\\n            return strs[0]\\n        if strs[i] == \"\" or strs[i+1] ==\"\" or strs[size-1]==\"\":\\n            return \"\" \\n        else:\\n            strs.sort()\\n        if len(set(strs)) == 1:\\n            return strs[0]\\n        while i < len(strs)-1 and strs[i][i] == strs[i+1][i] and strs[size-1][i] == strs[i][i]:\\n            prefix +=strs[i][i]\\n            i+=1\\n        return prefix\\n\\nI dont understand why my output is \"ab\" instead of \"a\". Can someone explain?"
                    }
                ]
            },
            {
                "id": 1772751,
                "content": [
                    {
                        "username": "dracont666",
                        "content": "\\nI changed the order of the elements in the list to [\"flower\",\"flight\",\"flow\"]\\n\\nI then used my solution, which in this case returns \"flow\" not \\'fl\\' and the system accepted that decision in Python 3.\\n\\nThis is mistake?"
                    },
                    {
                        "username": "NazarBestCoder",
                        "content": "is it Normal ? \"c\",\"acc\",\"ccc\" -> \"\" , Why not \"c\" ? \\nCan SomeBody Explain me ?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "It cannot be c because the second strong \"acc\" starts with a. \\nPrefix is the First group of letters common to every string"
                    },
                    {
                        "username": "goodguygoddy",
                        "content": "What is the most optimized time complexity for this question? "
                    },
                    {
                        "username": "user7734BK",
                        "content": "it should be O(s), with s the number of total characters"
                    },
                    {
                        "username": "codebrownie",
                        "content": "The main thing here is we have to match characters of the strings consecutively if first character is matched and next doesn\\'t match then we would break the loop, else it would consider the all matching characters.\\nAnd if any length of  any the string is 0 then simply return empty string."
                    },
                    {
                        "username": "Abed_UK",
                        "content": "there is an issue in testcase 120:\\n[\\'flower\\',\\'fkow\\']\\nit is obvious that the ansr is \\'ow\\' but the concole says \\'f\\'?  could anyone help??"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "[@Abed_UK](/Abed_UK) np man. If u get past test case 106 let me know Im stuck on that one it says answer is \\u201C\\u201D and mine returns \\u201C\\u201D but its wrong? Like what? XD"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "[@MichaelG123](/MichaelG123) Thanks bro I thought he was asking for the longest sequence."
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Prefix means the first letter(s) of a word\nFlower, fkow both start with f\n"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Passed 106/124 testcases.\\n\\nfailed on [\"\",\"\"]\\n\\noutput\\n\"\"\\n\\nExpected \\n\"\"\\n\\nAm I missing something here...?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Send the code :)"
                    },
                    {
                        "username": "FaMaSk",
                        "content": "How to fix\\nUnhandled exception. System.IndexOutOfRangeException: Index was outside the bounds of the array.\\nAt Solution.LongestCommonPrefix(String[] strs)\\nAt __Driver__.Main(String[] args)\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Uhm maybe you incremented one of your indexes one way too much. It happened to me too and It was in a very hidden place so It was difficult to figure It out. I suggest you to try changing your indexes (adding -1)in the indicated functions"
                    },
                    {
                        "username": "Amarnath0_o",
                        "content": " `getting the following error\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  basic_string::at: __n (which is 4) >= this->size() (which is 4) pls help\\ncode:\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string lcp =\"\";\\n        for(int i=0;i<strs.size();i++){\\n            for(int k=0;k<i;k++){\\n                int j=0;\\n                \\n                while(strs[k].at(j)!=\\'\\\\0\\'||strs[i].at(j)!=\\'\\\\0\\'){\\n                    if(strs[k].at(j)==strs[i].at(j)){\\n                        lcp+=strs[k].at(j);\\n                        j++;\\n                    }\\n                    else{\\n                        lcp=\"\";\\n                        break;\\n                    }\\n                }\\n                    \\n                \\n            }\\n        }\\n       return lcp; \\n    }\\n};"
                    },
                    {
                        "username": "sahilsandi07",
                        "content": "You can modify the below code :)\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        if len(strs) == 1:\\n            return strs[0]\\n        strs.sort()\\n        first = strs[0]\\n        last = strs[-1]\\n        for i, char in enumerate(first):\\n            if char != last[i]:\\n                return first[:i]\\n        return first"
                    },
                    {
                        "username": "Walzr",
                        "content": "strs = [\"abca\",\"aba\",\"aaab\"]\\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        i=0\\n        prefix = \"\"\\n        size = len(strs)\\n        if size ==0:\\n            return \"\"\\n        if size ==1:\\n            return strs[0]\\n        if strs[i] == \"\" or strs[i+1] ==\"\" or strs[size-1]==\"\":\\n            return \"\" \\n        else:\\n            strs.sort()\\n        if len(set(strs)) == 1:\\n            return strs[0]\\n        while i < len(strs)-1 and strs[i][i] == strs[i+1][i] and strs[size-1][i] == strs[i][i]:\\n            prefix +=strs[i][i]\\n            i+=1\\n        return prefix\\n\\nI dont understand why my output is \"ab\" instead of \"a\". Can someone explain?"
                    }
                ]
            },
            {
                "id": 1767363,
                "content": [
                    {
                        "username": "dracont666",
                        "content": "\\nI changed the order of the elements in the list to [\"flower\",\"flight\",\"flow\"]\\n\\nI then used my solution, which in this case returns \"flow\" not \\'fl\\' and the system accepted that decision in Python 3.\\n\\nThis is mistake?"
                    },
                    {
                        "username": "NazarBestCoder",
                        "content": "is it Normal ? \"c\",\"acc\",\"ccc\" -> \"\" , Why not \"c\" ? \\nCan SomeBody Explain me ?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "It cannot be c because the second strong \"acc\" starts with a. \\nPrefix is the First group of letters common to every string"
                    },
                    {
                        "username": "goodguygoddy",
                        "content": "What is the most optimized time complexity for this question? "
                    },
                    {
                        "username": "user7734BK",
                        "content": "it should be O(s), with s the number of total characters"
                    },
                    {
                        "username": "codebrownie",
                        "content": "The main thing here is we have to match characters of the strings consecutively if first character is matched and next doesn\\'t match then we would break the loop, else it would consider the all matching characters.\\nAnd if any length of  any the string is 0 then simply return empty string."
                    },
                    {
                        "username": "Abed_UK",
                        "content": "there is an issue in testcase 120:\\n[\\'flower\\',\\'fkow\\']\\nit is obvious that the ansr is \\'ow\\' but the concole says \\'f\\'?  could anyone help??"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "[@Abed_UK](/Abed_UK) np man. If u get past test case 106 let me know Im stuck on that one it says answer is \\u201C\\u201D and mine returns \\u201C\\u201D but its wrong? Like what? XD"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "[@MichaelG123](/MichaelG123) Thanks bro I thought he was asking for the longest sequence."
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Prefix means the first letter(s) of a word\nFlower, fkow both start with f\n"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Passed 106/124 testcases.\\n\\nfailed on [\"\",\"\"]\\n\\noutput\\n\"\"\\n\\nExpected \\n\"\"\\n\\nAm I missing something here...?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Send the code :)"
                    },
                    {
                        "username": "FaMaSk",
                        "content": "How to fix\\nUnhandled exception. System.IndexOutOfRangeException: Index was outside the bounds of the array.\\nAt Solution.LongestCommonPrefix(String[] strs)\\nAt __Driver__.Main(String[] args)\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Uhm maybe you incremented one of your indexes one way too much. It happened to me too and It was in a very hidden place so It was difficult to figure It out. I suggest you to try changing your indexes (adding -1)in the indicated functions"
                    },
                    {
                        "username": "Amarnath0_o",
                        "content": " `getting the following error\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  basic_string::at: __n (which is 4) >= this->size() (which is 4) pls help\\ncode:\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string lcp =\"\";\\n        for(int i=0;i<strs.size();i++){\\n            for(int k=0;k<i;k++){\\n                int j=0;\\n                \\n                while(strs[k].at(j)!=\\'\\\\0\\'||strs[i].at(j)!=\\'\\\\0\\'){\\n                    if(strs[k].at(j)==strs[i].at(j)){\\n                        lcp+=strs[k].at(j);\\n                        j++;\\n                    }\\n                    else{\\n                        lcp=\"\";\\n                        break;\\n                    }\\n                }\\n                    \\n                \\n            }\\n        }\\n       return lcp; \\n    }\\n};"
                    },
                    {
                        "username": "sahilsandi07",
                        "content": "You can modify the below code :)\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        if len(strs) == 1:\\n            return strs[0]\\n        strs.sort()\\n        first = strs[0]\\n        last = strs[-1]\\n        for i, char in enumerate(first):\\n            if char != last[i]:\\n                return first[:i]\\n        return first"
                    },
                    {
                        "username": "Walzr",
                        "content": "strs = [\"abca\",\"aba\",\"aaab\"]\\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        i=0\\n        prefix = \"\"\\n        size = len(strs)\\n        if size ==0:\\n            return \"\"\\n        if size ==1:\\n            return strs[0]\\n        if strs[i] == \"\" or strs[i+1] ==\"\" or strs[size-1]==\"\":\\n            return \"\" \\n        else:\\n            strs.sort()\\n        if len(set(strs)) == 1:\\n            return strs[0]\\n        while i < len(strs)-1 and strs[i][i] == strs[i+1][i] and strs[size-1][i] == strs[i][i]:\\n            prefix +=strs[i][i]\\n            i+=1\\n        return prefix\\n\\nI dont understand why my output is \"ab\" instead of \"a\". Can someone explain?"
                    }
                ]
            },
            {
                "id": 1758845,
                "content": [
                    {
                        "username": "dracont666",
                        "content": "\\nI changed the order of the elements in the list to [\"flower\",\"flight\",\"flow\"]\\n\\nI then used my solution, which in this case returns \"flow\" not \\'fl\\' and the system accepted that decision in Python 3.\\n\\nThis is mistake?"
                    },
                    {
                        "username": "NazarBestCoder",
                        "content": "is it Normal ? \"c\",\"acc\",\"ccc\" -> \"\" , Why not \"c\" ? \\nCan SomeBody Explain me ?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "It cannot be c because the second strong \"acc\" starts with a. \\nPrefix is the First group of letters common to every string"
                    },
                    {
                        "username": "goodguygoddy",
                        "content": "What is the most optimized time complexity for this question? "
                    },
                    {
                        "username": "user7734BK",
                        "content": "it should be O(s), with s the number of total characters"
                    },
                    {
                        "username": "codebrownie",
                        "content": "The main thing here is we have to match characters of the strings consecutively if first character is matched and next doesn\\'t match then we would break the loop, else it would consider the all matching characters.\\nAnd if any length of  any the string is 0 then simply return empty string."
                    },
                    {
                        "username": "Abed_UK",
                        "content": "there is an issue in testcase 120:\\n[\\'flower\\',\\'fkow\\']\\nit is obvious that the ansr is \\'ow\\' but the concole says \\'f\\'?  could anyone help??"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "[@Abed_UK](/Abed_UK) np man. If u get past test case 106 let me know Im stuck on that one it says answer is \\u201C\\u201D and mine returns \\u201C\\u201D but its wrong? Like what? XD"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "[@MichaelG123](/MichaelG123) Thanks bro I thought he was asking for the longest sequence."
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Prefix means the first letter(s) of a word\nFlower, fkow both start with f\n"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Passed 106/124 testcases.\\n\\nfailed on [\"\",\"\"]\\n\\noutput\\n\"\"\\n\\nExpected \\n\"\"\\n\\nAm I missing something here...?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Send the code :)"
                    },
                    {
                        "username": "FaMaSk",
                        "content": "How to fix\\nUnhandled exception. System.IndexOutOfRangeException: Index was outside the bounds of the array.\\nAt Solution.LongestCommonPrefix(String[] strs)\\nAt __Driver__.Main(String[] args)\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Uhm maybe you incremented one of your indexes one way too much. It happened to me too and It was in a very hidden place so It was difficult to figure It out. I suggest you to try changing your indexes (adding -1)in the indicated functions"
                    },
                    {
                        "username": "Amarnath0_o",
                        "content": " `getting the following error\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  basic_string::at: __n (which is 4) >= this->size() (which is 4) pls help\\ncode:\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string lcp =\"\";\\n        for(int i=0;i<strs.size();i++){\\n            for(int k=0;k<i;k++){\\n                int j=0;\\n                \\n                while(strs[k].at(j)!=\\'\\\\0\\'||strs[i].at(j)!=\\'\\\\0\\'){\\n                    if(strs[k].at(j)==strs[i].at(j)){\\n                        lcp+=strs[k].at(j);\\n                        j++;\\n                    }\\n                    else{\\n                        lcp=\"\";\\n                        break;\\n                    }\\n                }\\n                    \\n                \\n            }\\n        }\\n       return lcp; \\n    }\\n};"
                    },
                    {
                        "username": "sahilsandi07",
                        "content": "You can modify the below code :)\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        if len(strs) == 1:\\n            return strs[0]\\n        strs.sort()\\n        first = strs[0]\\n        last = strs[-1]\\n        for i, char in enumerate(first):\\n            if char != last[i]:\\n                return first[:i]\\n        return first"
                    },
                    {
                        "username": "Walzr",
                        "content": "strs = [\"abca\",\"aba\",\"aaab\"]\\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        i=0\\n        prefix = \"\"\\n        size = len(strs)\\n        if size ==0:\\n            return \"\"\\n        if size ==1:\\n            return strs[0]\\n        if strs[i] == \"\" or strs[i+1] ==\"\" or strs[size-1]==\"\":\\n            return \"\" \\n        else:\\n            strs.sort()\\n        if len(set(strs)) == 1:\\n            return strs[0]\\n        while i < len(strs)-1 and strs[i][i] == strs[i+1][i] and strs[size-1][i] == strs[i][i]:\\n            prefix +=strs[i][i]\\n            i+=1\\n        return prefix\\n\\nI dont understand why my output is \"ab\" instead of \"a\". Can someone explain?"
                    }
                ]
            },
            {
                "id": 1755558,
                "content": [
                    {
                        "username": "dracont666",
                        "content": "\\nI changed the order of the elements in the list to [\"flower\",\"flight\",\"flow\"]\\n\\nI then used my solution, which in this case returns \"flow\" not \\'fl\\' and the system accepted that decision in Python 3.\\n\\nThis is mistake?"
                    },
                    {
                        "username": "NazarBestCoder",
                        "content": "is it Normal ? \"c\",\"acc\",\"ccc\" -> \"\" , Why not \"c\" ? \\nCan SomeBody Explain me ?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "It cannot be c because the second strong \"acc\" starts with a. \\nPrefix is the First group of letters common to every string"
                    },
                    {
                        "username": "goodguygoddy",
                        "content": "What is the most optimized time complexity for this question? "
                    },
                    {
                        "username": "user7734BK",
                        "content": "it should be O(s), with s the number of total characters"
                    },
                    {
                        "username": "codebrownie",
                        "content": "The main thing here is we have to match characters of the strings consecutively if first character is matched and next doesn\\'t match then we would break the loop, else it would consider the all matching characters.\\nAnd if any length of  any the string is 0 then simply return empty string."
                    },
                    {
                        "username": "Abed_UK",
                        "content": "there is an issue in testcase 120:\\n[\\'flower\\',\\'fkow\\']\\nit is obvious that the ansr is \\'ow\\' but the concole says \\'f\\'?  could anyone help??"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "[@Abed_UK](/Abed_UK) np man. If u get past test case 106 let me know Im stuck on that one it says answer is \\u201C\\u201D and mine returns \\u201C\\u201D but its wrong? Like what? XD"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "[@MichaelG123](/MichaelG123) Thanks bro I thought he was asking for the longest sequence."
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Prefix means the first letter(s) of a word\nFlower, fkow both start with f\n"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Passed 106/124 testcases.\\n\\nfailed on [\"\",\"\"]\\n\\noutput\\n\"\"\\n\\nExpected \\n\"\"\\n\\nAm I missing something here...?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Send the code :)"
                    },
                    {
                        "username": "FaMaSk",
                        "content": "How to fix\\nUnhandled exception. System.IndexOutOfRangeException: Index was outside the bounds of the array.\\nAt Solution.LongestCommonPrefix(String[] strs)\\nAt __Driver__.Main(String[] args)\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Uhm maybe you incremented one of your indexes one way too much. It happened to me too and It was in a very hidden place so It was difficult to figure It out. I suggest you to try changing your indexes (adding -1)in the indicated functions"
                    },
                    {
                        "username": "Amarnath0_o",
                        "content": " `getting the following error\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  basic_string::at: __n (which is 4) >= this->size() (which is 4) pls help\\ncode:\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string lcp =\"\";\\n        for(int i=0;i<strs.size();i++){\\n            for(int k=0;k<i;k++){\\n                int j=0;\\n                \\n                while(strs[k].at(j)!=\\'\\\\0\\'||strs[i].at(j)!=\\'\\\\0\\'){\\n                    if(strs[k].at(j)==strs[i].at(j)){\\n                        lcp+=strs[k].at(j);\\n                        j++;\\n                    }\\n                    else{\\n                        lcp=\"\";\\n                        break;\\n                    }\\n                }\\n                    \\n                \\n            }\\n        }\\n       return lcp; \\n    }\\n};"
                    },
                    {
                        "username": "sahilsandi07",
                        "content": "You can modify the below code :)\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        if len(strs) == 1:\\n            return strs[0]\\n        strs.sort()\\n        first = strs[0]\\n        last = strs[-1]\\n        for i, char in enumerate(first):\\n            if char != last[i]:\\n                return first[:i]\\n        return first"
                    },
                    {
                        "username": "Walzr",
                        "content": "strs = [\"abca\",\"aba\",\"aaab\"]\\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        i=0\\n        prefix = \"\"\\n        size = len(strs)\\n        if size ==0:\\n            return \"\"\\n        if size ==1:\\n            return strs[0]\\n        if strs[i] == \"\" or strs[i+1] ==\"\" or strs[size-1]==\"\":\\n            return \"\" \\n        else:\\n            strs.sort()\\n        if len(set(strs)) == 1:\\n            return strs[0]\\n        while i < len(strs)-1 and strs[i][i] == strs[i+1][i] and strs[size-1][i] == strs[i][i]:\\n            prefix +=strs[i][i]\\n            i+=1\\n        return prefix\\n\\nI dont understand why my output is \"ab\" instead of \"a\". Can someone explain?"
                    }
                ]
            },
            {
                "id": 1753950,
                "content": [
                    {
                        "username": "dracont666",
                        "content": "\\nI changed the order of the elements in the list to [\"flower\",\"flight\",\"flow\"]\\n\\nI then used my solution, which in this case returns \"flow\" not \\'fl\\' and the system accepted that decision in Python 3.\\n\\nThis is mistake?"
                    },
                    {
                        "username": "NazarBestCoder",
                        "content": "is it Normal ? \"c\",\"acc\",\"ccc\" -> \"\" , Why not \"c\" ? \\nCan SomeBody Explain me ?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "It cannot be c because the second strong \"acc\" starts with a. \\nPrefix is the First group of letters common to every string"
                    },
                    {
                        "username": "goodguygoddy",
                        "content": "What is the most optimized time complexity for this question? "
                    },
                    {
                        "username": "user7734BK",
                        "content": "it should be O(s), with s the number of total characters"
                    },
                    {
                        "username": "codebrownie",
                        "content": "The main thing here is we have to match characters of the strings consecutively if first character is matched and next doesn\\'t match then we would break the loop, else it would consider the all matching characters.\\nAnd if any length of  any the string is 0 then simply return empty string."
                    },
                    {
                        "username": "Abed_UK",
                        "content": "there is an issue in testcase 120:\\n[\\'flower\\',\\'fkow\\']\\nit is obvious that the ansr is \\'ow\\' but the concole says \\'f\\'?  could anyone help??"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "[@Abed_UK](/Abed_UK) np man. If u get past test case 106 let me know Im stuck on that one it says answer is \\u201C\\u201D and mine returns \\u201C\\u201D but its wrong? Like what? XD"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "[@MichaelG123](/MichaelG123) Thanks bro I thought he was asking for the longest sequence."
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Prefix means the first letter(s) of a word\nFlower, fkow both start with f\n"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Passed 106/124 testcases.\\n\\nfailed on [\"\",\"\"]\\n\\noutput\\n\"\"\\n\\nExpected \\n\"\"\\n\\nAm I missing something here...?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Send the code :)"
                    },
                    {
                        "username": "FaMaSk",
                        "content": "How to fix\\nUnhandled exception. System.IndexOutOfRangeException: Index was outside the bounds of the array.\\nAt Solution.LongestCommonPrefix(String[] strs)\\nAt __Driver__.Main(String[] args)\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Uhm maybe you incremented one of your indexes one way too much. It happened to me too and It was in a very hidden place so It was difficult to figure It out. I suggest you to try changing your indexes (adding -1)in the indicated functions"
                    },
                    {
                        "username": "Amarnath0_o",
                        "content": " `getting the following error\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  basic_string::at: __n (which is 4) >= this->size() (which is 4) pls help\\ncode:\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string lcp =\"\";\\n        for(int i=0;i<strs.size();i++){\\n            for(int k=0;k<i;k++){\\n                int j=0;\\n                \\n                while(strs[k].at(j)!=\\'\\\\0\\'||strs[i].at(j)!=\\'\\\\0\\'){\\n                    if(strs[k].at(j)==strs[i].at(j)){\\n                        lcp+=strs[k].at(j);\\n                        j++;\\n                    }\\n                    else{\\n                        lcp=\"\";\\n                        break;\\n                    }\\n                }\\n                    \\n                \\n            }\\n        }\\n       return lcp; \\n    }\\n};"
                    },
                    {
                        "username": "sahilsandi07",
                        "content": "You can modify the below code :)\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        if len(strs) == 1:\\n            return strs[0]\\n        strs.sort()\\n        first = strs[0]\\n        last = strs[-1]\\n        for i, char in enumerate(first):\\n            if char != last[i]:\\n                return first[:i]\\n        return first"
                    },
                    {
                        "username": "Walzr",
                        "content": "strs = [\"abca\",\"aba\",\"aaab\"]\\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        i=0\\n        prefix = \"\"\\n        size = len(strs)\\n        if size ==0:\\n            return \"\"\\n        if size ==1:\\n            return strs[0]\\n        if strs[i] == \"\" or strs[i+1] ==\"\" or strs[size-1]==\"\":\\n            return \"\" \\n        else:\\n            strs.sort()\\n        if len(set(strs)) == 1:\\n            return strs[0]\\n        while i < len(strs)-1 and strs[i][i] == strs[i+1][i] and strs[size-1][i] == strs[i][i]:\\n            prefix +=strs[i][i]\\n            i+=1\\n        return prefix\\n\\nI dont understand why my output is \"ab\" instead of \"a\". Can someone explain?"
                    }
                ]
            },
            {
                "id": 1743578,
                "content": [
                    {
                        "username": "dracont666",
                        "content": "\\nI changed the order of the elements in the list to [\"flower\",\"flight\",\"flow\"]\\n\\nI then used my solution, which in this case returns \"flow\" not \\'fl\\' and the system accepted that decision in Python 3.\\n\\nThis is mistake?"
                    },
                    {
                        "username": "NazarBestCoder",
                        "content": "is it Normal ? \"c\",\"acc\",\"ccc\" -> \"\" , Why not \"c\" ? \\nCan SomeBody Explain me ?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "It cannot be c because the second strong \"acc\" starts with a. \\nPrefix is the First group of letters common to every string"
                    },
                    {
                        "username": "goodguygoddy",
                        "content": "What is the most optimized time complexity for this question? "
                    },
                    {
                        "username": "user7734BK",
                        "content": "it should be O(s), with s the number of total characters"
                    },
                    {
                        "username": "codebrownie",
                        "content": "The main thing here is we have to match characters of the strings consecutively if first character is matched and next doesn\\'t match then we would break the loop, else it would consider the all matching characters.\\nAnd if any length of  any the string is 0 then simply return empty string."
                    },
                    {
                        "username": "Abed_UK",
                        "content": "there is an issue in testcase 120:\\n[\\'flower\\',\\'fkow\\']\\nit is obvious that the ansr is \\'ow\\' but the concole says \\'f\\'?  could anyone help??"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "[@Abed_UK](/Abed_UK) np man. If u get past test case 106 let me know Im stuck on that one it says answer is \\u201C\\u201D and mine returns \\u201C\\u201D but its wrong? Like what? XD"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "[@MichaelG123](/MichaelG123) Thanks bro I thought he was asking for the longest sequence."
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Prefix means the first letter(s) of a word\nFlower, fkow both start with f\n"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Passed 106/124 testcases.\\n\\nfailed on [\"\",\"\"]\\n\\noutput\\n\"\"\\n\\nExpected \\n\"\"\\n\\nAm I missing something here...?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Send the code :)"
                    },
                    {
                        "username": "FaMaSk",
                        "content": "How to fix\\nUnhandled exception. System.IndexOutOfRangeException: Index was outside the bounds of the array.\\nAt Solution.LongestCommonPrefix(String[] strs)\\nAt __Driver__.Main(String[] args)\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Uhm maybe you incremented one of your indexes one way too much. It happened to me too and It was in a very hidden place so It was difficult to figure It out. I suggest you to try changing your indexes (adding -1)in the indicated functions"
                    },
                    {
                        "username": "Amarnath0_o",
                        "content": " `getting the following error\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  basic_string::at: __n (which is 4) >= this->size() (which is 4) pls help\\ncode:\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string lcp =\"\";\\n        for(int i=0;i<strs.size();i++){\\n            for(int k=0;k<i;k++){\\n                int j=0;\\n                \\n                while(strs[k].at(j)!=\\'\\\\0\\'||strs[i].at(j)!=\\'\\\\0\\'){\\n                    if(strs[k].at(j)==strs[i].at(j)){\\n                        lcp+=strs[k].at(j);\\n                        j++;\\n                    }\\n                    else{\\n                        lcp=\"\";\\n                        break;\\n                    }\\n                }\\n                    \\n                \\n            }\\n        }\\n       return lcp; \\n    }\\n};"
                    },
                    {
                        "username": "sahilsandi07",
                        "content": "You can modify the below code :)\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        if len(strs) == 1:\\n            return strs[0]\\n        strs.sort()\\n        first = strs[0]\\n        last = strs[-1]\\n        for i, char in enumerate(first):\\n            if char != last[i]:\\n                return first[:i]\\n        return first"
                    },
                    {
                        "username": "Walzr",
                        "content": "strs = [\"abca\",\"aba\",\"aaab\"]\\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        i=0\\n        prefix = \"\"\\n        size = len(strs)\\n        if size ==0:\\n            return \"\"\\n        if size ==1:\\n            return strs[0]\\n        if strs[i] == \"\" or strs[i+1] ==\"\" or strs[size-1]==\"\":\\n            return \"\" \\n        else:\\n            strs.sort()\\n        if len(set(strs)) == 1:\\n            return strs[0]\\n        while i < len(strs)-1 and strs[i][i] == strs[i+1][i] and strs[size-1][i] == strs[i][i]:\\n            prefix +=strs[i][i]\\n            i+=1\\n        return prefix\\n\\nI dont understand why my output is \"ab\" instead of \"a\". Can someone explain?"
                    }
                ]
            },
            {
                "id": 1742786,
                "content": [
                    {
                        "username": "doradengxf",
                        "content": "![image info](./Pictures/Screenshot/Screenshot(2).png)\\nI got wrong answer for a case and the expected answer does not make sense.\\nstrs = [\"reflower\",\"flow\",\"flight\" ]\\nOutput = \"fl\" \\nExpectd = \"\"\\n\\nIs there anyone who get it?"
                    },
                    {
                        "username": "Morningstar515",
                        "content": "Kind of poorly worded imo. Spent a great deal of time trying to account for the fact that the first words prefix might not contain the longest prefix. Yet the most common solutions I\\'m finding don\\'t account for this case."
                    },
                    {
                        "username": "VijayPatidar9179",
                        "content": "firstly take the length of FirstElement of string array and compare FirstElement to the last element of string array until the length of FirstElement .if char are matching them append to the Stringbuilder and return String.\\n\\n Arrays.sort(strs);\\n       int len=strs[0].length();\\n       StringBuilder sb=new StringBuilder();\\n       for(int i=0; i<len; i++)\\n       {\\n           if(strs[0].charAt(i)==strs[strs.length-1].charAt(i))\\n                sb.append(strs[0].charAt(i));\\n            else\\n                break;\\n       }\\n       String s=sb.toString();\\n       return s;"
                    },
                    {
                        "username": "Subaranjana",
                        "content": "Getting error as AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x5580a623afe2 bp 0x7fff364fa780 sp 0x7fff364fa770...... \\nfor most of the problems i have tried today. Can anyone say the reason behind this and help me to clear this error."
                    },
                    {
                        "username": "user1873di",
                        "content": "This means you are trying to access value from address out of range. For example if your array size is 5(range 0..4) but if you try to access arr[5] you get this type of error. This is also applicable in terms of vector, list, stack, queue etc."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: startWith() method in String API"
                    },
                    {
                        "username": "plak4",
                        "content": "tests case of this problem reward slower algorithms ! "
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     string longestCommonPrefix(vector<string>& strs) \\n    {\\n        string prefix = \"\";\\n        \\n        if(strs.size() == 0 || strs[0].length() == 0 ){\\n            return \"\";\\n        }\\n        int CI = 0;\\n        char currnetChar= strs[0][CI];\\n        char ans;\\n        \\n        while(currnetChar != \\'\\\\0\\')\\n        {\\n            bool isCharacterDifferent = false;\\n            for(int i = 0; i < strs.size() ; i++)\\n            {\\n                ans = strs[i][CI];\\n                \\n                if(ans != currnetChar || ans == \\'\\\\0\\')\\n                {\\n                    isCharacterDifferent = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(isCharacterDifferent){\\n                break;\\n            }\\n            prefix.push_back(currnetChar);\\n            currnetChar = strs[0][++CI];\\n        }\\n        \\n        return prefix;\\n    }\\n};`\\n\\n\\n\\nHere is the Clear solution of such code. If you find any changes in this code so please ping a comment reply. "
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "For those getting confused on test cases like:\n[\"reflower\",\"flow\",\"flight\"] \nwhere expected output is \"\" but your output is \"fl\"\nread the question carefully.\nIt's asking for longest prefix\nnot longest substring, prefix means substring from the start of the string.\nI too was confused for a day not wanting to look at any solution\nbut then while asking in one of the forums this occurred to me."
                    },
                    {
                        "username": "JCH97",
                        "content": "I think that a good solution for this kind of problems could be by using a Trie. Perphas trie is too much for the problem itself, but is a good skills \\nknow when we can use it.\\n\\nRetrieve w: O( len(w) )\\nInsert w: O( (len(w) )\\nGet longest prefix: O( len(longest prefix) )\\n\\nSo, operations over trie are amazing. \\n\\n"
                    },
                    {
                        "username": "eostling",
                        "content": "Definitely enjoyed this one! I would say this is close to a  medium level tbh. Just goes to show never take someone else\\'s word for it"
                    }
                ]
            },
            {
                "id": 1742688,
                "content": [
                    {
                        "username": "doradengxf",
                        "content": "![image info](./Pictures/Screenshot/Screenshot(2).png)\\nI got wrong answer for a case and the expected answer does not make sense.\\nstrs = [\"reflower\",\"flow\",\"flight\" ]\\nOutput = \"fl\" \\nExpectd = \"\"\\n\\nIs there anyone who get it?"
                    },
                    {
                        "username": "Morningstar515",
                        "content": "Kind of poorly worded imo. Spent a great deal of time trying to account for the fact that the first words prefix might not contain the longest prefix. Yet the most common solutions I\\'m finding don\\'t account for this case."
                    },
                    {
                        "username": "VijayPatidar9179",
                        "content": "firstly take the length of FirstElement of string array and compare FirstElement to the last element of string array until the length of FirstElement .if char are matching them append to the Stringbuilder and return String.\\n\\n Arrays.sort(strs);\\n       int len=strs[0].length();\\n       StringBuilder sb=new StringBuilder();\\n       for(int i=0; i<len; i++)\\n       {\\n           if(strs[0].charAt(i)==strs[strs.length-1].charAt(i))\\n                sb.append(strs[0].charAt(i));\\n            else\\n                break;\\n       }\\n       String s=sb.toString();\\n       return s;"
                    },
                    {
                        "username": "Subaranjana",
                        "content": "Getting error as AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x5580a623afe2 bp 0x7fff364fa780 sp 0x7fff364fa770...... \\nfor most of the problems i have tried today. Can anyone say the reason behind this and help me to clear this error."
                    },
                    {
                        "username": "user1873di",
                        "content": "This means you are trying to access value from address out of range. For example if your array size is 5(range 0..4) but if you try to access arr[5] you get this type of error. This is also applicable in terms of vector, list, stack, queue etc."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: startWith() method in String API"
                    },
                    {
                        "username": "plak4",
                        "content": "tests case of this problem reward slower algorithms ! "
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     string longestCommonPrefix(vector<string>& strs) \\n    {\\n        string prefix = \"\";\\n        \\n        if(strs.size() == 0 || strs[0].length() == 0 ){\\n            return \"\";\\n        }\\n        int CI = 0;\\n        char currnetChar= strs[0][CI];\\n        char ans;\\n        \\n        while(currnetChar != \\'\\\\0\\')\\n        {\\n            bool isCharacterDifferent = false;\\n            for(int i = 0; i < strs.size() ; i++)\\n            {\\n                ans = strs[i][CI];\\n                \\n                if(ans != currnetChar || ans == \\'\\\\0\\')\\n                {\\n                    isCharacterDifferent = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(isCharacterDifferent){\\n                break;\\n            }\\n            prefix.push_back(currnetChar);\\n            currnetChar = strs[0][++CI];\\n        }\\n        \\n        return prefix;\\n    }\\n};`\\n\\n\\n\\nHere is the Clear solution of such code. If you find any changes in this code so please ping a comment reply. "
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "For those getting confused on test cases like:\n[\"reflower\",\"flow\",\"flight\"] \nwhere expected output is \"\" but your output is \"fl\"\nread the question carefully.\nIt's asking for longest prefix\nnot longest substring, prefix means substring from the start of the string.\nI too was confused for a day not wanting to look at any solution\nbut then while asking in one of the forums this occurred to me."
                    },
                    {
                        "username": "JCH97",
                        "content": "I think that a good solution for this kind of problems could be by using a Trie. Perphas trie is too much for the problem itself, but is a good skills \\nknow when we can use it.\\n\\nRetrieve w: O( len(w) )\\nInsert w: O( (len(w) )\\nGet longest prefix: O( len(longest prefix) )\\n\\nSo, operations over trie are amazing. \\n\\n"
                    },
                    {
                        "username": "eostling",
                        "content": "Definitely enjoyed this one! I would say this is close to a  medium level tbh. Just goes to show never take someone else\\'s word for it"
                    }
                ]
            },
            {
                "id": 1741875,
                "content": [
                    {
                        "username": "doradengxf",
                        "content": "![image info](./Pictures/Screenshot/Screenshot(2).png)\\nI got wrong answer for a case and the expected answer does not make sense.\\nstrs = [\"reflower\",\"flow\",\"flight\" ]\\nOutput = \"fl\" \\nExpectd = \"\"\\n\\nIs there anyone who get it?"
                    },
                    {
                        "username": "Morningstar515",
                        "content": "Kind of poorly worded imo. Spent a great deal of time trying to account for the fact that the first words prefix might not contain the longest prefix. Yet the most common solutions I\\'m finding don\\'t account for this case."
                    },
                    {
                        "username": "VijayPatidar9179",
                        "content": "firstly take the length of FirstElement of string array and compare FirstElement to the last element of string array until the length of FirstElement .if char are matching them append to the Stringbuilder and return String.\\n\\n Arrays.sort(strs);\\n       int len=strs[0].length();\\n       StringBuilder sb=new StringBuilder();\\n       for(int i=0; i<len; i++)\\n       {\\n           if(strs[0].charAt(i)==strs[strs.length-1].charAt(i))\\n                sb.append(strs[0].charAt(i));\\n            else\\n                break;\\n       }\\n       String s=sb.toString();\\n       return s;"
                    },
                    {
                        "username": "Subaranjana",
                        "content": "Getting error as AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x5580a623afe2 bp 0x7fff364fa780 sp 0x7fff364fa770...... \\nfor most of the problems i have tried today. Can anyone say the reason behind this and help me to clear this error."
                    },
                    {
                        "username": "user1873di",
                        "content": "This means you are trying to access value from address out of range. For example if your array size is 5(range 0..4) but if you try to access arr[5] you get this type of error. This is also applicable in terms of vector, list, stack, queue etc."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: startWith() method in String API"
                    },
                    {
                        "username": "plak4",
                        "content": "tests case of this problem reward slower algorithms ! "
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     string longestCommonPrefix(vector<string>& strs) \\n    {\\n        string prefix = \"\";\\n        \\n        if(strs.size() == 0 || strs[0].length() == 0 ){\\n            return \"\";\\n        }\\n        int CI = 0;\\n        char currnetChar= strs[0][CI];\\n        char ans;\\n        \\n        while(currnetChar != \\'\\\\0\\')\\n        {\\n            bool isCharacterDifferent = false;\\n            for(int i = 0; i < strs.size() ; i++)\\n            {\\n                ans = strs[i][CI];\\n                \\n                if(ans != currnetChar || ans == \\'\\\\0\\')\\n                {\\n                    isCharacterDifferent = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(isCharacterDifferent){\\n                break;\\n            }\\n            prefix.push_back(currnetChar);\\n            currnetChar = strs[0][++CI];\\n        }\\n        \\n        return prefix;\\n    }\\n};`\\n\\n\\n\\nHere is the Clear solution of such code. If you find any changes in this code so please ping a comment reply. "
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "For those getting confused on test cases like:\n[\"reflower\",\"flow\",\"flight\"] \nwhere expected output is \"\" but your output is \"fl\"\nread the question carefully.\nIt's asking for longest prefix\nnot longest substring, prefix means substring from the start of the string.\nI too was confused for a day not wanting to look at any solution\nbut then while asking in one of the forums this occurred to me."
                    },
                    {
                        "username": "JCH97",
                        "content": "I think that a good solution for this kind of problems could be by using a Trie. Perphas trie is too much for the problem itself, but is a good skills \\nknow when we can use it.\\n\\nRetrieve w: O( len(w) )\\nInsert w: O( (len(w) )\\nGet longest prefix: O( len(longest prefix) )\\n\\nSo, operations over trie are amazing. \\n\\n"
                    },
                    {
                        "username": "eostling",
                        "content": "Definitely enjoyed this one! I would say this is close to a  medium level tbh. Just goes to show never take someone else\\'s word for it"
                    }
                ]
            },
            {
                "id": 1739869,
                "content": [
                    {
                        "username": "doradengxf",
                        "content": "![image info](./Pictures/Screenshot/Screenshot(2).png)\\nI got wrong answer for a case and the expected answer does not make sense.\\nstrs = [\"reflower\",\"flow\",\"flight\" ]\\nOutput = \"fl\" \\nExpectd = \"\"\\n\\nIs there anyone who get it?"
                    },
                    {
                        "username": "Morningstar515",
                        "content": "Kind of poorly worded imo. Spent a great deal of time trying to account for the fact that the first words prefix might not contain the longest prefix. Yet the most common solutions I\\'m finding don\\'t account for this case."
                    },
                    {
                        "username": "VijayPatidar9179",
                        "content": "firstly take the length of FirstElement of string array and compare FirstElement to the last element of string array until the length of FirstElement .if char are matching them append to the Stringbuilder and return String.\\n\\n Arrays.sort(strs);\\n       int len=strs[0].length();\\n       StringBuilder sb=new StringBuilder();\\n       for(int i=0; i<len; i++)\\n       {\\n           if(strs[0].charAt(i)==strs[strs.length-1].charAt(i))\\n                sb.append(strs[0].charAt(i));\\n            else\\n                break;\\n       }\\n       String s=sb.toString();\\n       return s;"
                    },
                    {
                        "username": "Subaranjana",
                        "content": "Getting error as AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x5580a623afe2 bp 0x7fff364fa780 sp 0x7fff364fa770...... \\nfor most of the problems i have tried today. Can anyone say the reason behind this and help me to clear this error."
                    },
                    {
                        "username": "user1873di",
                        "content": "This means you are trying to access value from address out of range. For example if your array size is 5(range 0..4) but if you try to access arr[5] you get this type of error. This is also applicable in terms of vector, list, stack, queue etc."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: startWith() method in String API"
                    },
                    {
                        "username": "plak4",
                        "content": "tests case of this problem reward slower algorithms ! "
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     string longestCommonPrefix(vector<string>& strs) \\n    {\\n        string prefix = \"\";\\n        \\n        if(strs.size() == 0 || strs[0].length() == 0 ){\\n            return \"\";\\n        }\\n        int CI = 0;\\n        char currnetChar= strs[0][CI];\\n        char ans;\\n        \\n        while(currnetChar != \\'\\\\0\\')\\n        {\\n            bool isCharacterDifferent = false;\\n            for(int i = 0; i < strs.size() ; i++)\\n            {\\n                ans = strs[i][CI];\\n                \\n                if(ans != currnetChar || ans == \\'\\\\0\\')\\n                {\\n                    isCharacterDifferent = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(isCharacterDifferent){\\n                break;\\n            }\\n            prefix.push_back(currnetChar);\\n            currnetChar = strs[0][++CI];\\n        }\\n        \\n        return prefix;\\n    }\\n};`\\n\\n\\n\\nHere is the Clear solution of such code. If you find any changes in this code so please ping a comment reply. "
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "For those getting confused on test cases like:\n[\"reflower\",\"flow\",\"flight\"] \nwhere expected output is \"\" but your output is \"fl\"\nread the question carefully.\nIt's asking for longest prefix\nnot longest substring, prefix means substring from the start of the string.\nI too was confused for a day not wanting to look at any solution\nbut then while asking in one of the forums this occurred to me."
                    },
                    {
                        "username": "JCH97",
                        "content": "I think that a good solution for this kind of problems could be by using a Trie. Perphas trie is too much for the problem itself, but is a good skills \\nknow when we can use it.\\n\\nRetrieve w: O( len(w) )\\nInsert w: O( (len(w) )\\nGet longest prefix: O( len(longest prefix) )\\n\\nSo, operations over trie are amazing. \\n\\n"
                    },
                    {
                        "username": "eostling",
                        "content": "Definitely enjoyed this one! I would say this is close to a  medium level tbh. Just goes to show never take someone else\\'s word for it"
                    }
                ]
            },
            {
                "id": 1737343,
                "content": [
                    {
                        "username": "doradengxf",
                        "content": "![image info](./Pictures/Screenshot/Screenshot(2).png)\\nI got wrong answer for a case and the expected answer does not make sense.\\nstrs = [\"reflower\",\"flow\",\"flight\" ]\\nOutput = \"fl\" \\nExpectd = \"\"\\n\\nIs there anyone who get it?"
                    },
                    {
                        "username": "Morningstar515",
                        "content": "Kind of poorly worded imo. Spent a great deal of time trying to account for the fact that the first words prefix might not contain the longest prefix. Yet the most common solutions I\\'m finding don\\'t account for this case."
                    },
                    {
                        "username": "VijayPatidar9179",
                        "content": "firstly take the length of FirstElement of string array and compare FirstElement to the last element of string array until the length of FirstElement .if char are matching them append to the Stringbuilder and return String.\\n\\n Arrays.sort(strs);\\n       int len=strs[0].length();\\n       StringBuilder sb=new StringBuilder();\\n       for(int i=0; i<len; i++)\\n       {\\n           if(strs[0].charAt(i)==strs[strs.length-1].charAt(i))\\n                sb.append(strs[0].charAt(i));\\n            else\\n                break;\\n       }\\n       String s=sb.toString();\\n       return s;"
                    },
                    {
                        "username": "Subaranjana",
                        "content": "Getting error as AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x5580a623afe2 bp 0x7fff364fa780 sp 0x7fff364fa770...... \\nfor most of the problems i have tried today. Can anyone say the reason behind this and help me to clear this error."
                    },
                    {
                        "username": "user1873di",
                        "content": "This means you are trying to access value from address out of range. For example if your array size is 5(range 0..4) but if you try to access arr[5] you get this type of error. This is also applicable in terms of vector, list, stack, queue etc."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: startWith() method in String API"
                    },
                    {
                        "username": "plak4",
                        "content": "tests case of this problem reward slower algorithms ! "
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     string longestCommonPrefix(vector<string>& strs) \\n    {\\n        string prefix = \"\";\\n        \\n        if(strs.size() == 0 || strs[0].length() == 0 ){\\n            return \"\";\\n        }\\n        int CI = 0;\\n        char currnetChar= strs[0][CI];\\n        char ans;\\n        \\n        while(currnetChar != \\'\\\\0\\')\\n        {\\n            bool isCharacterDifferent = false;\\n            for(int i = 0; i < strs.size() ; i++)\\n            {\\n                ans = strs[i][CI];\\n                \\n                if(ans != currnetChar || ans == \\'\\\\0\\')\\n                {\\n                    isCharacterDifferent = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(isCharacterDifferent){\\n                break;\\n            }\\n            prefix.push_back(currnetChar);\\n            currnetChar = strs[0][++CI];\\n        }\\n        \\n        return prefix;\\n    }\\n};`\\n\\n\\n\\nHere is the Clear solution of such code. If you find any changes in this code so please ping a comment reply. "
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "For those getting confused on test cases like:\n[\"reflower\",\"flow\",\"flight\"] \nwhere expected output is \"\" but your output is \"fl\"\nread the question carefully.\nIt's asking for longest prefix\nnot longest substring, prefix means substring from the start of the string.\nI too was confused for a day not wanting to look at any solution\nbut then while asking in one of the forums this occurred to me."
                    },
                    {
                        "username": "JCH97",
                        "content": "I think that a good solution for this kind of problems could be by using a Trie. Perphas trie is too much for the problem itself, but is a good skills \\nknow when we can use it.\\n\\nRetrieve w: O( len(w) )\\nInsert w: O( (len(w) )\\nGet longest prefix: O( len(longest prefix) )\\n\\nSo, operations over trie are amazing. \\n\\n"
                    },
                    {
                        "username": "eostling",
                        "content": "Definitely enjoyed this one! I would say this is close to a  medium level tbh. Just goes to show never take someone else\\'s word for it"
                    }
                ]
            },
            {
                "id": 1736735,
                "content": [
                    {
                        "username": "doradengxf",
                        "content": "![image info](./Pictures/Screenshot/Screenshot(2).png)\\nI got wrong answer for a case and the expected answer does not make sense.\\nstrs = [\"reflower\",\"flow\",\"flight\" ]\\nOutput = \"fl\" \\nExpectd = \"\"\\n\\nIs there anyone who get it?"
                    },
                    {
                        "username": "Morningstar515",
                        "content": "Kind of poorly worded imo. Spent a great deal of time trying to account for the fact that the first words prefix might not contain the longest prefix. Yet the most common solutions I\\'m finding don\\'t account for this case."
                    },
                    {
                        "username": "VijayPatidar9179",
                        "content": "firstly take the length of FirstElement of string array and compare FirstElement to the last element of string array until the length of FirstElement .if char are matching them append to the Stringbuilder and return String.\\n\\n Arrays.sort(strs);\\n       int len=strs[0].length();\\n       StringBuilder sb=new StringBuilder();\\n       for(int i=0; i<len; i++)\\n       {\\n           if(strs[0].charAt(i)==strs[strs.length-1].charAt(i))\\n                sb.append(strs[0].charAt(i));\\n            else\\n                break;\\n       }\\n       String s=sb.toString();\\n       return s;"
                    },
                    {
                        "username": "Subaranjana",
                        "content": "Getting error as AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x5580a623afe2 bp 0x7fff364fa780 sp 0x7fff364fa770...... \\nfor most of the problems i have tried today. Can anyone say the reason behind this and help me to clear this error."
                    },
                    {
                        "username": "user1873di",
                        "content": "This means you are trying to access value from address out of range. For example if your array size is 5(range 0..4) but if you try to access arr[5] you get this type of error. This is also applicable in terms of vector, list, stack, queue etc."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: startWith() method in String API"
                    },
                    {
                        "username": "plak4",
                        "content": "tests case of this problem reward slower algorithms ! "
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     string longestCommonPrefix(vector<string>& strs) \\n    {\\n        string prefix = \"\";\\n        \\n        if(strs.size() == 0 || strs[0].length() == 0 ){\\n            return \"\";\\n        }\\n        int CI = 0;\\n        char currnetChar= strs[0][CI];\\n        char ans;\\n        \\n        while(currnetChar != \\'\\\\0\\')\\n        {\\n            bool isCharacterDifferent = false;\\n            for(int i = 0; i < strs.size() ; i++)\\n            {\\n                ans = strs[i][CI];\\n                \\n                if(ans != currnetChar || ans == \\'\\\\0\\')\\n                {\\n                    isCharacterDifferent = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(isCharacterDifferent){\\n                break;\\n            }\\n            prefix.push_back(currnetChar);\\n            currnetChar = strs[0][++CI];\\n        }\\n        \\n        return prefix;\\n    }\\n};`\\n\\n\\n\\nHere is the Clear solution of such code. If you find any changes in this code so please ping a comment reply. "
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "For those getting confused on test cases like:\n[\"reflower\",\"flow\",\"flight\"] \nwhere expected output is \"\" but your output is \"fl\"\nread the question carefully.\nIt's asking for longest prefix\nnot longest substring, prefix means substring from the start of the string.\nI too was confused for a day not wanting to look at any solution\nbut then while asking in one of the forums this occurred to me."
                    },
                    {
                        "username": "JCH97",
                        "content": "I think that a good solution for this kind of problems could be by using a Trie. Perphas trie is too much for the problem itself, but is a good skills \\nknow when we can use it.\\n\\nRetrieve w: O( len(w) )\\nInsert w: O( (len(w) )\\nGet longest prefix: O( len(longest prefix) )\\n\\nSo, operations over trie are amazing. \\n\\n"
                    },
                    {
                        "username": "eostling",
                        "content": "Definitely enjoyed this one! I would say this is close to a  medium level tbh. Just goes to show never take someone else\\'s word for it"
                    }
                ]
            },
            {
                "id": 1733842,
                "content": [
                    {
                        "username": "doradengxf",
                        "content": "![image info](./Pictures/Screenshot/Screenshot(2).png)\\nI got wrong answer for a case and the expected answer does not make sense.\\nstrs = [\"reflower\",\"flow\",\"flight\" ]\\nOutput = \"fl\" \\nExpectd = \"\"\\n\\nIs there anyone who get it?"
                    },
                    {
                        "username": "Morningstar515",
                        "content": "Kind of poorly worded imo. Spent a great deal of time trying to account for the fact that the first words prefix might not contain the longest prefix. Yet the most common solutions I\\'m finding don\\'t account for this case."
                    },
                    {
                        "username": "VijayPatidar9179",
                        "content": "firstly take the length of FirstElement of string array and compare FirstElement to the last element of string array until the length of FirstElement .if char are matching them append to the Stringbuilder and return String.\\n\\n Arrays.sort(strs);\\n       int len=strs[0].length();\\n       StringBuilder sb=new StringBuilder();\\n       for(int i=0; i<len; i++)\\n       {\\n           if(strs[0].charAt(i)==strs[strs.length-1].charAt(i))\\n                sb.append(strs[0].charAt(i));\\n            else\\n                break;\\n       }\\n       String s=sb.toString();\\n       return s;"
                    },
                    {
                        "username": "Subaranjana",
                        "content": "Getting error as AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x5580a623afe2 bp 0x7fff364fa780 sp 0x7fff364fa770...... \\nfor most of the problems i have tried today. Can anyone say the reason behind this and help me to clear this error."
                    },
                    {
                        "username": "user1873di",
                        "content": "This means you are trying to access value from address out of range. For example if your array size is 5(range 0..4) but if you try to access arr[5] you get this type of error. This is also applicable in terms of vector, list, stack, queue etc."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: startWith() method in String API"
                    },
                    {
                        "username": "plak4",
                        "content": "tests case of this problem reward slower algorithms ! "
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     string longestCommonPrefix(vector<string>& strs) \\n    {\\n        string prefix = \"\";\\n        \\n        if(strs.size() == 0 || strs[0].length() == 0 ){\\n            return \"\";\\n        }\\n        int CI = 0;\\n        char currnetChar= strs[0][CI];\\n        char ans;\\n        \\n        while(currnetChar != \\'\\\\0\\')\\n        {\\n            bool isCharacterDifferent = false;\\n            for(int i = 0; i < strs.size() ; i++)\\n            {\\n                ans = strs[i][CI];\\n                \\n                if(ans != currnetChar || ans == \\'\\\\0\\')\\n                {\\n                    isCharacterDifferent = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(isCharacterDifferent){\\n                break;\\n            }\\n            prefix.push_back(currnetChar);\\n            currnetChar = strs[0][++CI];\\n        }\\n        \\n        return prefix;\\n    }\\n};`\\n\\n\\n\\nHere is the Clear solution of such code. If you find any changes in this code so please ping a comment reply. "
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "For those getting confused on test cases like:\n[\"reflower\",\"flow\",\"flight\"] \nwhere expected output is \"\" but your output is \"fl\"\nread the question carefully.\nIt's asking for longest prefix\nnot longest substring, prefix means substring from the start of the string.\nI too was confused for a day not wanting to look at any solution\nbut then while asking in one of the forums this occurred to me."
                    },
                    {
                        "username": "JCH97",
                        "content": "I think that a good solution for this kind of problems could be by using a Trie. Perphas trie is too much for the problem itself, but is a good skills \\nknow when we can use it.\\n\\nRetrieve w: O( len(w) )\\nInsert w: O( (len(w) )\\nGet longest prefix: O( len(longest prefix) )\\n\\nSo, operations over trie are amazing. \\n\\n"
                    },
                    {
                        "username": "eostling",
                        "content": "Definitely enjoyed this one! I would say this is close to a  medium level tbh. Just goes to show never take someone else\\'s word for it"
                    }
                ]
            },
            {
                "id": 1733380,
                "content": [
                    {
                        "username": "doradengxf",
                        "content": "![image info](./Pictures/Screenshot/Screenshot(2).png)\\nI got wrong answer for a case and the expected answer does not make sense.\\nstrs = [\"reflower\",\"flow\",\"flight\" ]\\nOutput = \"fl\" \\nExpectd = \"\"\\n\\nIs there anyone who get it?"
                    },
                    {
                        "username": "Morningstar515",
                        "content": "Kind of poorly worded imo. Spent a great deal of time trying to account for the fact that the first words prefix might not contain the longest prefix. Yet the most common solutions I\\'m finding don\\'t account for this case."
                    },
                    {
                        "username": "VijayPatidar9179",
                        "content": "firstly take the length of FirstElement of string array and compare FirstElement to the last element of string array until the length of FirstElement .if char are matching them append to the Stringbuilder and return String.\\n\\n Arrays.sort(strs);\\n       int len=strs[0].length();\\n       StringBuilder sb=new StringBuilder();\\n       for(int i=0; i<len; i++)\\n       {\\n           if(strs[0].charAt(i)==strs[strs.length-1].charAt(i))\\n                sb.append(strs[0].charAt(i));\\n            else\\n                break;\\n       }\\n       String s=sb.toString();\\n       return s;"
                    },
                    {
                        "username": "Subaranjana",
                        "content": "Getting error as AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x5580a623afe2 bp 0x7fff364fa780 sp 0x7fff364fa770...... \\nfor most of the problems i have tried today. Can anyone say the reason behind this and help me to clear this error."
                    },
                    {
                        "username": "user1873di",
                        "content": "This means you are trying to access value from address out of range. For example if your array size is 5(range 0..4) but if you try to access arr[5] you get this type of error. This is also applicable in terms of vector, list, stack, queue etc."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: startWith() method in String API"
                    },
                    {
                        "username": "plak4",
                        "content": "tests case of this problem reward slower algorithms ! "
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     string longestCommonPrefix(vector<string>& strs) \\n    {\\n        string prefix = \"\";\\n        \\n        if(strs.size() == 0 || strs[0].length() == 0 ){\\n            return \"\";\\n        }\\n        int CI = 0;\\n        char currnetChar= strs[0][CI];\\n        char ans;\\n        \\n        while(currnetChar != \\'\\\\0\\')\\n        {\\n            bool isCharacterDifferent = false;\\n            for(int i = 0; i < strs.size() ; i++)\\n            {\\n                ans = strs[i][CI];\\n                \\n                if(ans != currnetChar || ans == \\'\\\\0\\')\\n                {\\n                    isCharacterDifferent = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(isCharacterDifferent){\\n                break;\\n            }\\n            prefix.push_back(currnetChar);\\n            currnetChar = strs[0][++CI];\\n        }\\n        \\n        return prefix;\\n    }\\n};`\\n\\n\\n\\nHere is the Clear solution of such code. If you find any changes in this code so please ping a comment reply. "
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "For those getting confused on test cases like:\n[\"reflower\",\"flow\",\"flight\"] \nwhere expected output is \"\" but your output is \"fl\"\nread the question carefully.\nIt's asking for longest prefix\nnot longest substring, prefix means substring from the start of the string.\nI too was confused for a day not wanting to look at any solution\nbut then while asking in one of the forums this occurred to me."
                    },
                    {
                        "username": "JCH97",
                        "content": "I think that a good solution for this kind of problems could be by using a Trie. Perphas trie is too much for the problem itself, but is a good skills \\nknow when we can use it.\\n\\nRetrieve w: O( len(w) )\\nInsert w: O( (len(w) )\\nGet longest prefix: O( len(longest prefix) )\\n\\nSo, operations over trie are amazing. \\n\\n"
                    },
                    {
                        "username": "eostling",
                        "content": "Definitely enjoyed this one! I would say this is close to a  medium level tbh. Just goes to show never take someone else\\'s word for it"
                    }
                ]
            },
            {
                "id": 1732191,
                "content": [
                    {
                        "username": "doradengxf",
                        "content": "![image info](./Pictures/Screenshot/Screenshot(2).png)\\nI got wrong answer for a case and the expected answer does not make sense.\\nstrs = [\"reflower\",\"flow\",\"flight\" ]\\nOutput = \"fl\" \\nExpectd = \"\"\\n\\nIs there anyone who get it?"
                    },
                    {
                        "username": "Morningstar515",
                        "content": "Kind of poorly worded imo. Spent a great deal of time trying to account for the fact that the first words prefix might not contain the longest prefix. Yet the most common solutions I\\'m finding don\\'t account for this case."
                    },
                    {
                        "username": "VijayPatidar9179",
                        "content": "firstly take the length of FirstElement of string array and compare FirstElement to the last element of string array until the length of FirstElement .if char are matching them append to the Stringbuilder and return String.\\n\\n Arrays.sort(strs);\\n       int len=strs[0].length();\\n       StringBuilder sb=new StringBuilder();\\n       for(int i=0; i<len; i++)\\n       {\\n           if(strs[0].charAt(i)==strs[strs.length-1].charAt(i))\\n                sb.append(strs[0].charAt(i));\\n            else\\n                break;\\n       }\\n       String s=sb.toString();\\n       return s;"
                    },
                    {
                        "username": "Subaranjana",
                        "content": "Getting error as AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x5580a623afe2 bp 0x7fff364fa780 sp 0x7fff364fa770...... \\nfor most of the problems i have tried today. Can anyone say the reason behind this and help me to clear this error."
                    },
                    {
                        "username": "user1873di",
                        "content": "This means you are trying to access value from address out of range. For example if your array size is 5(range 0..4) but if you try to access arr[5] you get this type of error. This is also applicable in terms of vector, list, stack, queue etc."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: startWith() method in String API"
                    },
                    {
                        "username": "plak4",
                        "content": "tests case of this problem reward slower algorithms ! "
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     string longestCommonPrefix(vector<string>& strs) \\n    {\\n        string prefix = \"\";\\n        \\n        if(strs.size() == 0 || strs[0].length() == 0 ){\\n            return \"\";\\n        }\\n        int CI = 0;\\n        char currnetChar= strs[0][CI];\\n        char ans;\\n        \\n        while(currnetChar != \\'\\\\0\\')\\n        {\\n            bool isCharacterDifferent = false;\\n            for(int i = 0; i < strs.size() ; i++)\\n            {\\n                ans = strs[i][CI];\\n                \\n                if(ans != currnetChar || ans == \\'\\\\0\\')\\n                {\\n                    isCharacterDifferent = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(isCharacterDifferent){\\n                break;\\n            }\\n            prefix.push_back(currnetChar);\\n            currnetChar = strs[0][++CI];\\n        }\\n        \\n        return prefix;\\n    }\\n};`\\n\\n\\n\\nHere is the Clear solution of such code. If you find any changes in this code so please ping a comment reply. "
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "For those getting confused on test cases like:\n[\"reflower\",\"flow\",\"flight\"] \nwhere expected output is \"\" but your output is \"fl\"\nread the question carefully.\nIt's asking for longest prefix\nnot longest substring, prefix means substring from the start of the string.\nI too was confused for a day not wanting to look at any solution\nbut then while asking in one of the forums this occurred to me."
                    },
                    {
                        "username": "JCH97",
                        "content": "I think that a good solution for this kind of problems could be by using a Trie. Perphas trie is too much for the problem itself, but is a good skills \\nknow when we can use it.\\n\\nRetrieve w: O( len(w) )\\nInsert w: O( (len(w) )\\nGet longest prefix: O( len(longest prefix) )\\n\\nSo, operations over trie are amazing. \\n\\n"
                    },
                    {
                        "username": "eostling",
                        "content": "Definitely enjoyed this one! I would say this is close to a  medium level tbh. Just goes to show never take someone else\\'s word for it"
                    }
                ]
            },
            {
                "id": 1731881,
                "content": [
                    {
                        "username": "doradengxf",
                        "content": "![image info](./Pictures/Screenshot/Screenshot(2).png)\\nI got wrong answer for a case and the expected answer does not make sense.\\nstrs = [\"reflower\",\"flow\",\"flight\" ]\\nOutput = \"fl\" \\nExpectd = \"\"\\n\\nIs there anyone who get it?"
                    },
                    {
                        "username": "Morningstar515",
                        "content": "Kind of poorly worded imo. Spent a great deal of time trying to account for the fact that the first words prefix might not contain the longest prefix. Yet the most common solutions I\\'m finding don\\'t account for this case."
                    },
                    {
                        "username": "VijayPatidar9179",
                        "content": "firstly take the length of FirstElement of string array and compare FirstElement to the last element of string array until the length of FirstElement .if char are matching them append to the Stringbuilder and return String.\\n\\n Arrays.sort(strs);\\n       int len=strs[0].length();\\n       StringBuilder sb=new StringBuilder();\\n       for(int i=0; i<len; i++)\\n       {\\n           if(strs[0].charAt(i)==strs[strs.length-1].charAt(i))\\n                sb.append(strs[0].charAt(i));\\n            else\\n                break;\\n       }\\n       String s=sb.toString();\\n       return s;"
                    },
                    {
                        "username": "Subaranjana",
                        "content": "Getting error as AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x5580a623afe2 bp 0x7fff364fa780 sp 0x7fff364fa770...... \\nfor most of the problems i have tried today. Can anyone say the reason behind this and help me to clear this error."
                    },
                    {
                        "username": "user1873di",
                        "content": "This means you are trying to access value from address out of range. For example if your array size is 5(range 0..4) but if you try to access arr[5] you get this type of error. This is also applicable in terms of vector, list, stack, queue etc."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: startWith() method in String API"
                    },
                    {
                        "username": "plak4",
                        "content": "tests case of this problem reward slower algorithms ! "
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     string longestCommonPrefix(vector<string>& strs) \\n    {\\n        string prefix = \"\";\\n        \\n        if(strs.size() == 0 || strs[0].length() == 0 ){\\n            return \"\";\\n        }\\n        int CI = 0;\\n        char currnetChar= strs[0][CI];\\n        char ans;\\n        \\n        while(currnetChar != \\'\\\\0\\')\\n        {\\n            bool isCharacterDifferent = false;\\n            for(int i = 0; i < strs.size() ; i++)\\n            {\\n                ans = strs[i][CI];\\n                \\n                if(ans != currnetChar || ans == \\'\\\\0\\')\\n                {\\n                    isCharacterDifferent = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(isCharacterDifferent){\\n                break;\\n            }\\n            prefix.push_back(currnetChar);\\n            currnetChar = strs[0][++CI];\\n        }\\n        \\n        return prefix;\\n    }\\n};`\\n\\n\\n\\nHere is the Clear solution of such code. If you find any changes in this code so please ping a comment reply. "
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "For those getting confused on test cases like:\n[\"reflower\",\"flow\",\"flight\"] \nwhere expected output is \"\" but your output is \"fl\"\nread the question carefully.\nIt's asking for longest prefix\nnot longest substring, prefix means substring from the start of the string.\nI too was confused for a day not wanting to look at any solution\nbut then while asking in one of the forums this occurred to me."
                    },
                    {
                        "username": "JCH97",
                        "content": "I think that a good solution for this kind of problems could be by using a Trie. Perphas trie is too much for the problem itself, but is a good skills \\nknow when we can use it.\\n\\nRetrieve w: O( len(w) )\\nInsert w: O( (len(w) )\\nGet longest prefix: O( len(longest prefix) )\\n\\nSo, operations over trie are amazing. \\n\\n"
                    },
                    {
                        "username": "eostling",
                        "content": "Definitely enjoyed this one! I would say this is close to a  medium level tbh. Just goes to show never take someone else\\'s word for it"
                    }
                ]
            },
            {
                "id": 1728419,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "My Simple code in java\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size=strs.length;\\n        if(size==0)\\n        {\\n            return \"\";\\n        }\\n        if(size==1)\\n        {\\n            return strs[0];\\n        }\\n        Arrays.sort(strs);\\n        int end=Math.min(strs[0].length(),strs[size-1].length());\\n        int i=0;\\n        while(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\n            i++;\\n            String pre=strs[0].substring(0,i);\\n            return pre;\\n    \\n}\\n}"
                    },
                    {
                        "username": "Raj_MN_Doshi",
                        "content": "tried doing this the code \\na = set(set.intersection(*map(set, strs)))\\n        s=\"\"\\n        \\n        for i in a:\\n            s=s+i\\n        return s\\n\\nso the answer sometimes is coming in reverse randomly can someone explain the reason"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/14_longest_common_prefix.cpp"
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "strs = [\"c\",\"acc\",\"ccc\"]\\n\\nOutput\\n\"c\"\\n\\nExpected\\n\"\"\\n\\nHow? I can clearly see every string on array has \"c\""
                    },
                    {
                        "username": "bmagana5",
                        "content": "A prefix is always at the start of a word. The longest common prefix between \"c\" and \"ccc\" is \"c\", but not for \"acc\", since \"acc\" starts with \"a\". The longest possible prefix between them is \"\"."
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string s=strs[0];\\n        if(s[0]==0)\\n        {\\n            return s;\\n        }\\n        int j=0;\\n        string s1;\\n        for(int i=1;i<strs.size();i++)\\n        {\\n            if(strs[i]==\"\\\\0\")\\n            {\\n                return \"\\\\0\";\\n            }\\n            while(s[j]==strs[i][j])\\n            {\\n                s1=s1+s[j];\\n                j++;\\n            }\\n            s=s1;\\n            s1.clear();\\n            j=0;\\n\\n        }\\n        string f;\\n        int i=0;\\n        return f;\\n\\n    }\\n};\\n\\nmy code if failing when all the string are same plzzz give me solution of it\\n"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        String common=str[0];\\n        for( int i=0;i<str.length;i++)\\n        while(str[i].indexOf(common)!=0){\\n            common=common.substring(0,common.length()-1);\\n    return common;\\n}\\n}"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "Best solution in java\\n  class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        if(str.length==0)\\n        return \"\";\\n        String prefix=str[0];\\n        for(String s:str){\\n            int i=0;\\n           int j=0;\\n            while(i<prefix.length() && j<s.length() && prefix.charAt(i)==s.charAt(j)){\\n            i++;\\n            j++;\\n        }\\n        prefix=s.substring(0,j);\\n    }\\n    return prefix;\\n         \\n    }\\n}"
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Intuition\nCheck each combination\n\n# Approach\n- Track character index\n- The check if the index has reached the length of the current string if yes return result\n- Check if characters don't match if no return result.\n- Else add character to the result string.\n\n# Complexity\n- Time complexity:\n O(n)\n\n- Space complexity:\nO(n)\n\n# Code\n```\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string res;\n        for(int i = 0;i<strs[0].size();i++){\n            for(int j = 0;j<strs.size();j++){\n                if(i==strs[j].length() or strs[j][i]!=strs[0][i])\n                    return res;\n            res+=strs[0][i];\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "egehanyldz7",
                        "content": "flower and fkow is the testcase 120/124 and it should output ow since its the longest common prefix but its expected is \"f\" somehow"
                    }
                ]
            },
            {
                "id": 1726264,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "My Simple code in java\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size=strs.length;\\n        if(size==0)\\n        {\\n            return \"\";\\n        }\\n        if(size==1)\\n        {\\n            return strs[0];\\n        }\\n        Arrays.sort(strs);\\n        int end=Math.min(strs[0].length(),strs[size-1].length());\\n        int i=0;\\n        while(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\n            i++;\\n            String pre=strs[0].substring(0,i);\\n            return pre;\\n    \\n}\\n}"
                    },
                    {
                        "username": "Raj_MN_Doshi",
                        "content": "tried doing this the code \\na = set(set.intersection(*map(set, strs)))\\n        s=\"\"\\n        \\n        for i in a:\\n            s=s+i\\n        return s\\n\\nso the answer sometimes is coming in reverse randomly can someone explain the reason"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/14_longest_common_prefix.cpp"
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "strs = [\"c\",\"acc\",\"ccc\"]\\n\\nOutput\\n\"c\"\\n\\nExpected\\n\"\"\\n\\nHow? I can clearly see every string on array has \"c\""
                    },
                    {
                        "username": "bmagana5",
                        "content": "A prefix is always at the start of a word. The longest common prefix between \"c\" and \"ccc\" is \"c\", but not for \"acc\", since \"acc\" starts with \"a\". The longest possible prefix between them is \"\"."
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string s=strs[0];\\n        if(s[0]==0)\\n        {\\n            return s;\\n        }\\n        int j=0;\\n        string s1;\\n        for(int i=1;i<strs.size();i++)\\n        {\\n            if(strs[i]==\"\\\\0\")\\n            {\\n                return \"\\\\0\";\\n            }\\n            while(s[j]==strs[i][j])\\n            {\\n                s1=s1+s[j];\\n                j++;\\n            }\\n            s=s1;\\n            s1.clear();\\n            j=0;\\n\\n        }\\n        string f;\\n        int i=0;\\n        return f;\\n\\n    }\\n};\\n\\nmy code if failing when all the string are same plzzz give me solution of it\\n"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        String common=str[0];\\n        for( int i=0;i<str.length;i++)\\n        while(str[i].indexOf(common)!=0){\\n            common=common.substring(0,common.length()-1);\\n    return common;\\n}\\n}"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "Best solution in java\\n  class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        if(str.length==0)\\n        return \"\";\\n        String prefix=str[0];\\n        for(String s:str){\\n            int i=0;\\n           int j=0;\\n            while(i<prefix.length() && j<s.length() && prefix.charAt(i)==s.charAt(j)){\\n            i++;\\n            j++;\\n        }\\n        prefix=s.substring(0,j);\\n    }\\n    return prefix;\\n         \\n    }\\n}"
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Intuition\nCheck each combination\n\n# Approach\n- Track character index\n- The check if the index has reached the length of the current string if yes return result\n- Check if characters don't match if no return result.\n- Else add character to the result string.\n\n# Complexity\n- Time complexity:\n O(n)\n\n- Space complexity:\nO(n)\n\n# Code\n```\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string res;\n        for(int i = 0;i<strs[0].size();i++){\n            for(int j = 0;j<strs.size();j++){\n                if(i==strs[j].length() or strs[j][i]!=strs[0][i])\n                    return res;\n            res+=strs[0][i];\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "egehanyldz7",
                        "content": "flower and fkow is the testcase 120/124 and it should output ow since its the longest common prefix but its expected is \"f\" somehow"
                    }
                ]
            },
            {
                "id": 1725500,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "My Simple code in java\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size=strs.length;\\n        if(size==0)\\n        {\\n            return \"\";\\n        }\\n        if(size==1)\\n        {\\n            return strs[0];\\n        }\\n        Arrays.sort(strs);\\n        int end=Math.min(strs[0].length(),strs[size-1].length());\\n        int i=0;\\n        while(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\n            i++;\\n            String pre=strs[0].substring(0,i);\\n            return pre;\\n    \\n}\\n}"
                    },
                    {
                        "username": "Raj_MN_Doshi",
                        "content": "tried doing this the code \\na = set(set.intersection(*map(set, strs)))\\n        s=\"\"\\n        \\n        for i in a:\\n            s=s+i\\n        return s\\n\\nso the answer sometimes is coming in reverse randomly can someone explain the reason"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/14_longest_common_prefix.cpp"
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "strs = [\"c\",\"acc\",\"ccc\"]\\n\\nOutput\\n\"c\"\\n\\nExpected\\n\"\"\\n\\nHow? I can clearly see every string on array has \"c\""
                    },
                    {
                        "username": "bmagana5",
                        "content": "A prefix is always at the start of a word. The longest common prefix between \"c\" and \"ccc\" is \"c\", but not for \"acc\", since \"acc\" starts with \"a\". The longest possible prefix between them is \"\"."
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string s=strs[0];\\n        if(s[0]==0)\\n        {\\n            return s;\\n        }\\n        int j=0;\\n        string s1;\\n        for(int i=1;i<strs.size();i++)\\n        {\\n            if(strs[i]==\"\\\\0\")\\n            {\\n                return \"\\\\0\";\\n            }\\n            while(s[j]==strs[i][j])\\n            {\\n                s1=s1+s[j];\\n                j++;\\n            }\\n            s=s1;\\n            s1.clear();\\n            j=0;\\n\\n        }\\n        string f;\\n        int i=0;\\n        return f;\\n\\n    }\\n};\\n\\nmy code if failing when all the string are same plzzz give me solution of it\\n"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        String common=str[0];\\n        for( int i=0;i<str.length;i++)\\n        while(str[i].indexOf(common)!=0){\\n            common=common.substring(0,common.length()-1);\\n    return common;\\n}\\n}"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "Best solution in java\\n  class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        if(str.length==0)\\n        return \"\";\\n        String prefix=str[0];\\n        for(String s:str){\\n            int i=0;\\n           int j=0;\\n            while(i<prefix.length() && j<s.length() && prefix.charAt(i)==s.charAt(j)){\\n            i++;\\n            j++;\\n        }\\n        prefix=s.substring(0,j);\\n    }\\n    return prefix;\\n         \\n    }\\n}"
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Intuition\nCheck each combination\n\n# Approach\n- Track character index\n- The check if the index has reached the length of the current string if yes return result\n- Check if characters don't match if no return result.\n- Else add character to the result string.\n\n# Complexity\n- Time complexity:\n O(n)\n\n- Space complexity:\nO(n)\n\n# Code\n```\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string res;\n        for(int i = 0;i<strs[0].size();i++){\n            for(int j = 0;j<strs.size();j++){\n                if(i==strs[j].length() or strs[j][i]!=strs[0][i])\n                    return res;\n            res+=strs[0][i];\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "egehanyldz7",
                        "content": "flower and fkow is the testcase 120/124 and it should output ow since its the longest common prefix but its expected is \"f\" somehow"
                    }
                ]
            },
            {
                "id": 1722955,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "My Simple code in java\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size=strs.length;\\n        if(size==0)\\n        {\\n            return \"\";\\n        }\\n        if(size==1)\\n        {\\n            return strs[0];\\n        }\\n        Arrays.sort(strs);\\n        int end=Math.min(strs[0].length(),strs[size-1].length());\\n        int i=0;\\n        while(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\n            i++;\\n            String pre=strs[0].substring(0,i);\\n            return pre;\\n    \\n}\\n}"
                    },
                    {
                        "username": "Raj_MN_Doshi",
                        "content": "tried doing this the code \\na = set(set.intersection(*map(set, strs)))\\n        s=\"\"\\n        \\n        for i in a:\\n            s=s+i\\n        return s\\n\\nso the answer sometimes is coming in reverse randomly can someone explain the reason"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/14_longest_common_prefix.cpp"
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "strs = [\"c\",\"acc\",\"ccc\"]\\n\\nOutput\\n\"c\"\\n\\nExpected\\n\"\"\\n\\nHow? I can clearly see every string on array has \"c\""
                    },
                    {
                        "username": "bmagana5",
                        "content": "A prefix is always at the start of a word. The longest common prefix between \"c\" and \"ccc\" is \"c\", but not for \"acc\", since \"acc\" starts with \"a\". The longest possible prefix between them is \"\"."
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string s=strs[0];\\n        if(s[0]==0)\\n        {\\n            return s;\\n        }\\n        int j=0;\\n        string s1;\\n        for(int i=1;i<strs.size();i++)\\n        {\\n            if(strs[i]==\"\\\\0\")\\n            {\\n                return \"\\\\0\";\\n            }\\n            while(s[j]==strs[i][j])\\n            {\\n                s1=s1+s[j];\\n                j++;\\n            }\\n            s=s1;\\n            s1.clear();\\n            j=0;\\n\\n        }\\n        string f;\\n        int i=0;\\n        return f;\\n\\n    }\\n};\\n\\nmy code if failing when all the string are same plzzz give me solution of it\\n"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        String common=str[0];\\n        for( int i=0;i<str.length;i++)\\n        while(str[i].indexOf(common)!=0){\\n            common=common.substring(0,common.length()-1);\\n    return common;\\n}\\n}"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "Best solution in java\\n  class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        if(str.length==0)\\n        return \"\";\\n        String prefix=str[0];\\n        for(String s:str){\\n            int i=0;\\n           int j=0;\\n            while(i<prefix.length() && j<s.length() && prefix.charAt(i)==s.charAt(j)){\\n            i++;\\n            j++;\\n        }\\n        prefix=s.substring(0,j);\\n    }\\n    return prefix;\\n         \\n    }\\n}"
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Intuition\nCheck each combination\n\n# Approach\n- Track character index\n- The check if the index has reached the length of the current string if yes return result\n- Check if characters don't match if no return result.\n- Else add character to the result string.\n\n# Complexity\n- Time complexity:\n O(n)\n\n- Space complexity:\nO(n)\n\n# Code\n```\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string res;\n        for(int i = 0;i<strs[0].size();i++){\n            for(int j = 0;j<strs.size();j++){\n                if(i==strs[j].length() or strs[j][i]!=strs[0][i])\n                    return res;\n            res+=strs[0][i];\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "egehanyldz7",
                        "content": "flower and fkow is the testcase 120/124 and it should output ow since its the longest common prefix but its expected is \"f\" somehow"
                    }
                ]
            },
            {
                "id": 1722619,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "My Simple code in java\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size=strs.length;\\n        if(size==0)\\n        {\\n            return \"\";\\n        }\\n        if(size==1)\\n        {\\n            return strs[0];\\n        }\\n        Arrays.sort(strs);\\n        int end=Math.min(strs[0].length(),strs[size-1].length());\\n        int i=0;\\n        while(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\n            i++;\\n            String pre=strs[0].substring(0,i);\\n            return pre;\\n    \\n}\\n}"
                    },
                    {
                        "username": "Raj_MN_Doshi",
                        "content": "tried doing this the code \\na = set(set.intersection(*map(set, strs)))\\n        s=\"\"\\n        \\n        for i in a:\\n            s=s+i\\n        return s\\n\\nso the answer sometimes is coming in reverse randomly can someone explain the reason"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/14_longest_common_prefix.cpp"
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "strs = [\"c\",\"acc\",\"ccc\"]\\n\\nOutput\\n\"c\"\\n\\nExpected\\n\"\"\\n\\nHow? I can clearly see every string on array has \"c\""
                    },
                    {
                        "username": "bmagana5",
                        "content": "A prefix is always at the start of a word. The longest common prefix between \"c\" and \"ccc\" is \"c\", but not for \"acc\", since \"acc\" starts with \"a\". The longest possible prefix between them is \"\"."
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string s=strs[0];\\n        if(s[0]==0)\\n        {\\n            return s;\\n        }\\n        int j=0;\\n        string s1;\\n        for(int i=1;i<strs.size();i++)\\n        {\\n            if(strs[i]==\"\\\\0\")\\n            {\\n                return \"\\\\0\";\\n            }\\n            while(s[j]==strs[i][j])\\n            {\\n                s1=s1+s[j];\\n                j++;\\n            }\\n            s=s1;\\n            s1.clear();\\n            j=0;\\n\\n        }\\n        string f;\\n        int i=0;\\n        return f;\\n\\n    }\\n};\\n\\nmy code if failing when all the string are same plzzz give me solution of it\\n"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        String common=str[0];\\n        for( int i=0;i<str.length;i++)\\n        while(str[i].indexOf(common)!=0){\\n            common=common.substring(0,common.length()-1);\\n    return common;\\n}\\n}"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "Best solution in java\\n  class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        if(str.length==0)\\n        return \"\";\\n        String prefix=str[0];\\n        for(String s:str){\\n            int i=0;\\n           int j=0;\\n            while(i<prefix.length() && j<s.length() && prefix.charAt(i)==s.charAt(j)){\\n            i++;\\n            j++;\\n        }\\n        prefix=s.substring(0,j);\\n    }\\n    return prefix;\\n         \\n    }\\n}"
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Intuition\nCheck each combination\n\n# Approach\n- Track character index\n- The check if the index has reached the length of the current string if yes return result\n- Check if characters don't match if no return result.\n- Else add character to the result string.\n\n# Complexity\n- Time complexity:\n O(n)\n\n- Space complexity:\nO(n)\n\n# Code\n```\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string res;\n        for(int i = 0;i<strs[0].size();i++){\n            for(int j = 0;j<strs.size();j++){\n                if(i==strs[j].length() or strs[j][i]!=strs[0][i])\n                    return res;\n            res+=strs[0][i];\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "egehanyldz7",
                        "content": "flower and fkow is the testcase 120/124 and it should output ow since its the longest common prefix but its expected is \"f\" somehow"
                    }
                ]
            },
            {
                "id": 1722148,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "My Simple code in java\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size=strs.length;\\n        if(size==0)\\n        {\\n            return \"\";\\n        }\\n        if(size==1)\\n        {\\n            return strs[0];\\n        }\\n        Arrays.sort(strs);\\n        int end=Math.min(strs[0].length(),strs[size-1].length());\\n        int i=0;\\n        while(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\n            i++;\\n            String pre=strs[0].substring(0,i);\\n            return pre;\\n    \\n}\\n}"
                    },
                    {
                        "username": "Raj_MN_Doshi",
                        "content": "tried doing this the code \\na = set(set.intersection(*map(set, strs)))\\n        s=\"\"\\n        \\n        for i in a:\\n            s=s+i\\n        return s\\n\\nso the answer sometimes is coming in reverse randomly can someone explain the reason"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/14_longest_common_prefix.cpp"
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "strs = [\"c\",\"acc\",\"ccc\"]\\n\\nOutput\\n\"c\"\\n\\nExpected\\n\"\"\\n\\nHow? I can clearly see every string on array has \"c\""
                    },
                    {
                        "username": "bmagana5",
                        "content": "A prefix is always at the start of a word. The longest common prefix between \"c\" and \"ccc\" is \"c\", but not for \"acc\", since \"acc\" starts with \"a\". The longest possible prefix between them is \"\"."
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string s=strs[0];\\n        if(s[0]==0)\\n        {\\n            return s;\\n        }\\n        int j=0;\\n        string s1;\\n        for(int i=1;i<strs.size();i++)\\n        {\\n            if(strs[i]==\"\\\\0\")\\n            {\\n                return \"\\\\0\";\\n            }\\n            while(s[j]==strs[i][j])\\n            {\\n                s1=s1+s[j];\\n                j++;\\n            }\\n            s=s1;\\n            s1.clear();\\n            j=0;\\n\\n        }\\n        string f;\\n        int i=0;\\n        return f;\\n\\n    }\\n};\\n\\nmy code if failing when all the string are same plzzz give me solution of it\\n"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        String common=str[0];\\n        for( int i=0;i<str.length;i++)\\n        while(str[i].indexOf(common)!=0){\\n            common=common.substring(0,common.length()-1);\\n    return common;\\n}\\n}"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "Best solution in java\\n  class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        if(str.length==0)\\n        return \"\";\\n        String prefix=str[0];\\n        for(String s:str){\\n            int i=0;\\n           int j=0;\\n            while(i<prefix.length() && j<s.length() && prefix.charAt(i)==s.charAt(j)){\\n            i++;\\n            j++;\\n        }\\n        prefix=s.substring(0,j);\\n    }\\n    return prefix;\\n         \\n    }\\n}"
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Intuition\nCheck each combination\n\n# Approach\n- Track character index\n- The check if the index has reached the length of the current string if yes return result\n- Check if characters don't match if no return result.\n- Else add character to the result string.\n\n# Complexity\n- Time complexity:\n O(n)\n\n- Space complexity:\nO(n)\n\n# Code\n```\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string res;\n        for(int i = 0;i<strs[0].size();i++){\n            for(int j = 0;j<strs.size();j++){\n                if(i==strs[j].length() or strs[j][i]!=strs[0][i])\n                    return res;\n            res+=strs[0][i];\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "egehanyldz7",
                        "content": "flower and fkow is the testcase 120/124 and it should output ow since its the longest common prefix but its expected is \"f\" somehow"
                    }
                ]
            },
            {
                "id": 1722111,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "My Simple code in java\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size=strs.length;\\n        if(size==0)\\n        {\\n            return \"\";\\n        }\\n        if(size==1)\\n        {\\n            return strs[0];\\n        }\\n        Arrays.sort(strs);\\n        int end=Math.min(strs[0].length(),strs[size-1].length());\\n        int i=0;\\n        while(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\n            i++;\\n            String pre=strs[0].substring(0,i);\\n            return pre;\\n    \\n}\\n}"
                    },
                    {
                        "username": "Raj_MN_Doshi",
                        "content": "tried doing this the code \\na = set(set.intersection(*map(set, strs)))\\n        s=\"\"\\n        \\n        for i in a:\\n            s=s+i\\n        return s\\n\\nso the answer sometimes is coming in reverse randomly can someone explain the reason"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/14_longest_common_prefix.cpp"
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "strs = [\"c\",\"acc\",\"ccc\"]\\n\\nOutput\\n\"c\"\\n\\nExpected\\n\"\"\\n\\nHow? I can clearly see every string on array has \"c\""
                    },
                    {
                        "username": "bmagana5",
                        "content": "A prefix is always at the start of a word. The longest common prefix between \"c\" and \"ccc\" is \"c\", but not for \"acc\", since \"acc\" starts with \"a\". The longest possible prefix between them is \"\"."
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string s=strs[0];\\n        if(s[0]==0)\\n        {\\n            return s;\\n        }\\n        int j=0;\\n        string s1;\\n        for(int i=1;i<strs.size();i++)\\n        {\\n            if(strs[i]==\"\\\\0\")\\n            {\\n                return \"\\\\0\";\\n            }\\n            while(s[j]==strs[i][j])\\n            {\\n                s1=s1+s[j];\\n                j++;\\n            }\\n            s=s1;\\n            s1.clear();\\n            j=0;\\n\\n        }\\n        string f;\\n        int i=0;\\n        return f;\\n\\n    }\\n};\\n\\nmy code if failing when all the string are same plzzz give me solution of it\\n"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        String common=str[0];\\n        for( int i=0;i<str.length;i++)\\n        while(str[i].indexOf(common)!=0){\\n            common=common.substring(0,common.length()-1);\\n    return common;\\n}\\n}"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "Best solution in java\\n  class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        if(str.length==0)\\n        return \"\";\\n        String prefix=str[0];\\n        for(String s:str){\\n            int i=0;\\n           int j=0;\\n            while(i<prefix.length() && j<s.length() && prefix.charAt(i)==s.charAt(j)){\\n            i++;\\n            j++;\\n        }\\n        prefix=s.substring(0,j);\\n    }\\n    return prefix;\\n         \\n    }\\n}"
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Intuition\nCheck each combination\n\n# Approach\n- Track character index\n- The check if the index has reached the length of the current string if yes return result\n- Check if characters don't match if no return result.\n- Else add character to the result string.\n\n# Complexity\n- Time complexity:\n O(n)\n\n- Space complexity:\nO(n)\n\n# Code\n```\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string res;\n        for(int i = 0;i<strs[0].size();i++){\n            for(int j = 0;j<strs.size();j++){\n                if(i==strs[j].length() or strs[j][i]!=strs[0][i])\n                    return res;\n            res+=strs[0][i];\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "egehanyldz7",
                        "content": "flower and fkow is the testcase 120/124 and it should output ow since its the longest common prefix but its expected is \"f\" somehow"
                    }
                ]
            },
            {
                "id": 1721552,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "My Simple code in java\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size=strs.length;\\n        if(size==0)\\n        {\\n            return \"\";\\n        }\\n        if(size==1)\\n        {\\n            return strs[0];\\n        }\\n        Arrays.sort(strs);\\n        int end=Math.min(strs[0].length(),strs[size-1].length());\\n        int i=0;\\n        while(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\n            i++;\\n            String pre=strs[0].substring(0,i);\\n            return pre;\\n    \\n}\\n}"
                    },
                    {
                        "username": "Raj_MN_Doshi",
                        "content": "tried doing this the code \\na = set(set.intersection(*map(set, strs)))\\n        s=\"\"\\n        \\n        for i in a:\\n            s=s+i\\n        return s\\n\\nso the answer sometimes is coming in reverse randomly can someone explain the reason"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/14_longest_common_prefix.cpp"
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "strs = [\"c\",\"acc\",\"ccc\"]\\n\\nOutput\\n\"c\"\\n\\nExpected\\n\"\"\\n\\nHow? I can clearly see every string on array has \"c\""
                    },
                    {
                        "username": "bmagana5",
                        "content": "A prefix is always at the start of a word. The longest common prefix between \"c\" and \"ccc\" is \"c\", but not for \"acc\", since \"acc\" starts with \"a\". The longest possible prefix between them is \"\"."
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string s=strs[0];\\n        if(s[0]==0)\\n        {\\n            return s;\\n        }\\n        int j=0;\\n        string s1;\\n        for(int i=1;i<strs.size();i++)\\n        {\\n            if(strs[i]==\"\\\\0\")\\n            {\\n                return \"\\\\0\";\\n            }\\n            while(s[j]==strs[i][j])\\n            {\\n                s1=s1+s[j];\\n                j++;\\n            }\\n            s=s1;\\n            s1.clear();\\n            j=0;\\n\\n        }\\n        string f;\\n        int i=0;\\n        return f;\\n\\n    }\\n};\\n\\nmy code if failing when all the string are same plzzz give me solution of it\\n"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        String common=str[0];\\n        for( int i=0;i<str.length;i++)\\n        while(str[i].indexOf(common)!=0){\\n            common=common.substring(0,common.length()-1);\\n    return common;\\n}\\n}"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "Best solution in java\\n  class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        if(str.length==0)\\n        return \"\";\\n        String prefix=str[0];\\n        for(String s:str){\\n            int i=0;\\n           int j=0;\\n            while(i<prefix.length() && j<s.length() && prefix.charAt(i)==s.charAt(j)){\\n            i++;\\n            j++;\\n        }\\n        prefix=s.substring(0,j);\\n    }\\n    return prefix;\\n         \\n    }\\n}"
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Intuition\nCheck each combination\n\n# Approach\n- Track character index\n- The check if the index has reached the length of the current string if yes return result\n- Check if characters don't match if no return result.\n- Else add character to the result string.\n\n# Complexity\n- Time complexity:\n O(n)\n\n- Space complexity:\nO(n)\n\n# Code\n```\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string res;\n        for(int i = 0;i<strs[0].size();i++){\n            for(int j = 0;j<strs.size();j++){\n                if(i==strs[j].length() or strs[j][i]!=strs[0][i])\n                    return res;\n            res+=strs[0][i];\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "egehanyldz7",
                        "content": "flower and fkow is the testcase 120/124 and it should output ow since its the longest common prefix but its expected is \"f\" somehow"
                    }
                ]
            },
            {
                "id": 1721458,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "My Simple code in java\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size=strs.length;\\n        if(size==0)\\n        {\\n            return \"\";\\n        }\\n        if(size==1)\\n        {\\n            return strs[0];\\n        }\\n        Arrays.sort(strs);\\n        int end=Math.min(strs[0].length(),strs[size-1].length());\\n        int i=0;\\n        while(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\n            i++;\\n            String pre=strs[0].substring(0,i);\\n            return pre;\\n    \\n}\\n}"
                    },
                    {
                        "username": "Raj_MN_Doshi",
                        "content": "tried doing this the code \\na = set(set.intersection(*map(set, strs)))\\n        s=\"\"\\n        \\n        for i in a:\\n            s=s+i\\n        return s\\n\\nso the answer sometimes is coming in reverse randomly can someone explain the reason"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/14_longest_common_prefix.cpp"
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "strs = [\"c\",\"acc\",\"ccc\"]\\n\\nOutput\\n\"c\"\\n\\nExpected\\n\"\"\\n\\nHow? I can clearly see every string on array has \"c\""
                    },
                    {
                        "username": "bmagana5",
                        "content": "A prefix is always at the start of a word. The longest common prefix between \"c\" and \"ccc\" is \"c\", but not for \"acc\", since \"acc\" starts with \"a\". The longest possible prefix between them is \"\"."
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string s=strs[0];\\n        if(s[0]==0)\\n        {\\n            return s;\\n        }\\n        int j=0;\\n        string s1;\\n        for(int i=1;i<strs.size();i++)\\n        {\\n            if(strs[i]==\"\\\\0\")\\n            {\\n                return \"\\\\0\";\\n            }\\n            while(s[j]==strs[i][j])\\n            {\\n                s1=s1+s[j];\\n                j++;\\n            }\\n            s=s1;\\n            s1.clear();\\n            j=0;\\n\\n        }\\n        string f;\\n        int i=0;\\n        return f;\\n\\n    }\\n};\\n\\nmy code if failing when all the string are same plzzz give me solution of it\\n"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        String common=str[0];\\n        for( int i=0;i<str.length;i++)\\n        while(str[i].indexOf(common)!=0){\\n            common=common.substring(0,common.length()-1);\\n    return common;\\n}\\n}"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "Best solution in java\\n  class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        if(str.length==0)\\n        return \"\";\\n        String prefix=str[0];\\n        for(String s:str){\\n            int i=0;\\n           int j=0;\\n            while(i<prefix.length() && j<s.length() && prefix.charAt(i)==s.charAt(j)){\\n            i++;\\n            j++;\\n        }\\n        prefix=s.substring(0,j);\\n    }\\n    return prefix;\\n         \\n    }\\n}"
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Intuition\nCheck each combination\n\n# Approach\n- Track character index\n- The check if the index has reached the length of the current string if yes return result\n- Check if characters don't match if no return result.\n- Else add character to the result string.\n\n# Complexity\n- Time complexity:\n O(n)\n\n- Space complexity:\nO(n)\n\n# Code\n```\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string res;\n        for(int i = 0;i<strs[0].size();i++){\n            for(int j = 0;j<strs.size();j++){\n                if(i==strs[j].length() or strs[j][i]!=strs[0][i])\n                    return res;\n            res+=strs[0][i];\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "egehanyldz7",
                        "content": "flower and fkow is the testcase 120/124 and it should output ow since its the longest common prefix but its expected is \"f\" somehow"
                    }
                ]
            },
            {
                "id": 1718667,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "My Simple code in java\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size=strs.length;\\n        if(size==0)\\n        {\\n            return \"\";\\n        }\\n        if(size==1)\\n        {\\n            return strs[0];\\n        }\\n        Arrays.sort(strs);\\n        int end=Math.min(strs[0].length(),strs[size-1].length());\\n        int i=0;\\n        while(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\n            i++;\\n            String pre=strs[0].substring(0,i);\\n            return pre;\\n    \\n}\\n}"
                    },
                    {
                        "username": "Raj_MN_Doshi",
                        "content": "tried doing this the code \\na = set(set.intersection(*map(set, strs)))\\n        s=\"\"\\n        \\n        for i in a:\\n            s=s+i\\n        return s\\n\\nso the answer sometimes is coming in reverse randomly can someone explain the reason"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/14_longest_common_prefix.cpp"
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "strs = [\"c\",\"acc\",\"ccc\"]\\n\\nOutput\\n\"c\"\\n\\nExpected\\n\"\"\\n\\nHow? I can clearly see every string on array has \"c\""
                    },
                    {
                        "username": "bmagana5",
                        "content": "A prefix is always at the start of a word. The longest common prefix between \"c\" and \"ccc\" is \"c\", but not for \"acc\", since \"acc\" starts with \"a\". The longest possible prefix between them is \"\"."
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string s=strs[0];\\n        if(s[0]==0)\\n        {\\n            return s;\\n        }\\n        int j=0;\\n        string s1;\\n        for(int i=1;i<strs.size();i++)\\n        {\\n            if(strs[i]==\"\\\\0\")\\n            {\\n                return \"\\\\0\";\\n            }\\n            while(s[j]==strs[i][j])\\n            {\\n                s1=s1+s[j];\\n                j++;\\n            }\\n            s=s1;\\n            s1.clear();\\n            j=0;\\n\\n        }\\n        string f;\\n        int i=0;\\n        return f;\\n\\n    }\\n};\\n\\nmy code if failing when all the string are same plzzz give me solution of it\\n"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        String common=str[0];\\n        for( int i=0;i<str.length;i++)\\n        while(str[i].indexOf(common)!=0){\\n            common=common.substring(0,common.length()-1);\\n    return common;\\n}\\n}"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "Best solution in java\\n  class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        if(str.length==0)\\n        return \"\";\\n        String prefix=str[0];\\n        for(String s:str){\\n            int i=0;\\n           int j=0;\\n            while(i<prefix.length() && j<s.length() && prefix.charAt(i)==s.charAt(j)){\\n            i++;\\n            j++;\\n        }\\n        prefix=s.substring(0,j);\\n    }\\n    return prefix;\\n         \\n    }\\n}"
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Intuition\nCheck each combination\n\n# Approach\n- Track character index\n- The check if the index has reached the length of the current string if yes return result\n- Check if characters don't match if no return result.\n- Else add character to the result string.\n\n# Complexity\n- Time complexity:\n O(n)\n\n- Space complexity:\nO(n)\n\n# Code\n```\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string res;\n        for(int i = 0;i<strs[0].size();i++){\n            for(int j = 0;j<strs.size();j++){\n                if(i==strs[j].length() or strs[j][i]!=strs[0][i])\n                    return res;\n            res+=strs[0][i];\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "egehanyldz7",
                        "content": "flower and fkow is the testcase 120/124 and it should output ow since its the longest common prefix but its expected is \"f\" somehow"
                    }
                ]
            },
            {
                "id": 1718349,
                "content": [
                    {
                        "username": "charanrai",
                        "content": " `string longestCommonPrefix(vector<string>& strs) {\\n        \\n        sort(strs.begin(), strs.end());\\n\\n        string fir_str = strs[0];\\n        string last_str = strs[strs.size() - 1];\\n\\n        int matched = 0;\\n        for (int  i = 0; i < fir_str.size(); i++) {\\n            if (fir_str[i] != last_str[i] ) {\\n                break;\\n            }\\n            ++matched;\\n        } \\n        \\n        if (matched == 0) {\\n            return \"\";\\n        }\\n        return fir_str.substr(0, matched);\\n    }`"
                    },
                    {
                        "username": "jamadade",
                        "content": "Why am I not able to submit this code?\\n\\n\\nvar longestCommonPrefix = function(strs) {\\n\\n    var common = \"\";\\n    var temp = \"\";\\n\\n    for(var i = 0; i < strs.length; i++){\\n        var currInd = 0;\\n        if(i === 0){\\n            common = strs[i];\\n            continue;\\n        }\\n        while(strs[i][currInd] === common[currInd]){\\n            temp = temp + strs[i][currInd];\\n            currInd++;\\n        }\\n        common = temp;\\n        temp=\"\";\\n    }\\n    return common;\\n};\\n\\n\\nRuntime Error\\n `terminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc`"
                    },
                    {
                        "username": "Matthew910818",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int flag = 0;\\n        string ans = \"\";\\n        int len = strs[0].length();\\n        string first = strs[0];\\n        for(int i=0;i<=len;i++)\\n        {\\n            for(auto it=strs.begin();it!=strs.end();it++)\\n            {\\n                string cmp = *it;\\n                if(first[i] != cmp[i])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag == 0)\\n            {\\n                ans+=strs[0][i];\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHow come the output answer and the expected answer are the same but it still shows wrong answer?"
                    },
                    {
                        "username": "Ritam33",
                        "content": "avc"
                    },
                    {
                        "username": "willymather",
                        "content": "Should say longest substring \"car\" is not a prefix of \"racecar\""
                    },
                    {
                        "username": "urchinz",
                        "content": "I originally want to utilize python's short-circuit evaluation method: \n\nif (letter_pos >= len(current_word)) | (current_word[letter_pos] != letter):\n  -- do evaluation\n\nthe test case [\"ab\", \"a\"] keeps giving me errors. I believe it's because when letter_pos = 1, \"a\"[1] is out of index. However, because of python's or operator short-circuit, the first condition should be evaluation TRUE...\n\nAnyone have any thoughts?\n"
                    },
                    {
                        "username": "yashk1",
                        "content": "why are string questions so hard "
                    },
                    {
                        "username": "venkat50",
                        "content": "jkk"
                    },
                    {
                        "username": "kadyr1901",
                        "content": "Hi Guys, I solved this problem on C#.\\nWhen I run my code on visual studio and debug i can see it works fine, however i get different output in leetcode. \\nCan someone help me?"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "Why does the problem have a testcase  [\"\",\"\"] when it clearly says it accepts only lowercase English letters?"
                    }
                ]
            },
            {
                "id": 1716871,
                "content": [
                    {
                        "username": "charanrai",
                        "content": " `string longestCommonPrefix(vector<string>& strs) {\\n        \\n        sort(strs.begin(), strs.end());\\n\\n        string fir_str = strs[0];\\n        string last_str = strs[strs.size() - 1];\\n\\n        int matched = 0;\\n        for (int  i = 0; i < fir_str.size(); i++) {\\n            if (fir_str[i] != last_str[i] ) {\\n                break;\\n            }\\n            ++matched;\\n        } \\n        \\n        if (matched == 0) {\\n            return \"\";\\n        }\\n        return fir_str.substr(0, matched);\\n    }`"
                    },
                    {
                        "username": "jamadade",
                        "content": "Why am I not able to submit this code?\\n\\n\\nvar longestCommonPrefix = function(strs) {\\n\\n    var common = \"\";\\n    var temp = \"\";\\n\\n    for(var i = 0; i < strs.length; i++){\\n        var currInd = 0;\\n        if(i === 0){\\n            common = strs[i];\\n            continue;\\n        }\\n        while(strs[i][currInd] === common[currInd]){\\n            temp = temp + strs[i][currInd];\\n            currInd++;\\n        }\\n        common = temp;\\n        temp=\"\";\\n    }\\n    return common;\\n};\\n\\n\\nRuntime Error\\n `terminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc`"
                    },
                    {
                        "username": "Matthew910818",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int flag = 0;\\n        string ans = \"\";\\n        int len = strs[0].length();\\n        string first = strs[0];\\n        for(int i=0;i<=len;i++)\\n        {\\n            for(auto it=strs.begin();it!=strs.end();it++)\\n            {\\n                string cmp = *it;\\n                if(first[i] != cmp[i])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag == 0)\\n            {\\n                ans+=strs[0][i];\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHow come the output answer and the expected answer are the same but it still shows wrong answer?"
                    },
                    {
                        "username": "Ritam33",
                        "content": "avc"
                    },
                    {
                        "username": "willymather",
                        "content": "Should say longest substring \"car\" is not a prefix of \"racecar\""
                    },
                    {
                        "username": "urchinz",
                        "content": "I originally want to utilize python's short-circuit evaluation method: \n\nif (letter_pos >= len(current_word)) | (current_word[letter_pos] != letter):\n  -- do evaluation\n\nthe test case [\"ab\", \"a\"] keeps giving me errors. I believe it's because when letter_pos = 1, \"a\"[1] is out of index. However, because of python's or operator short-circuit, the first condition should be evaluation TRUE...\n\nAnyone have any thoughts?\n"
                    },
                    {
                        "username": "yashk1",
                        "content": "why are string questions so hard "
                    },
                    {
                        "username": "venkat50",
                        "content": "jkk"
                    },
                    {
                        "username": "kadyr1901",
                        "content": "Hi Guys, I solved this problem on C#.\\nWhen I run my code on visual studio and debug i can see it works fine, however i get different output in leetcode. \\nCan someone help me?"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "Why does the problem have a testcase  [\"\",\"\"] when it clearly says it accepts only lowercase English letters?"
                    }
                ]
            },
            {
                "id": 1714098,
                "content": [
                    {
                        "username": "charanrai",
                        "content": " `string longestCommonPrefix(vector<string>& strs) {\\n        \\n        sort(strs.begin(), strs.end());\\n\\n        string fir_str = strs[0];\\n        string last_str = strs[strs.size() - 1];\\n\\n        int matched = 0;\\n        for (int  i = 0; i < fir_str.size(); i++) {\\n            if (fir_str[i] != last_str[i] ) {\\n                break;\\n            }\\n            ++matched;\\n        } \\n        \\n        if (matched == 0) {\\n            return \"\";\\n        }\\n        return fir_str.substr(0, matched);\\n    }`"
                    },
                    {
                        "username": "jamadade",
                        "content": "Why am I not able to submit this code?\\n\\n\\nvar longestCommonPrefix = function(strs) {\\n\\n    var common = \"\";\\n    var temp = \"\";\\n\\n    for(var i = 0; i < strs.length; i++){\\n        var currInd = 0;\\n        if(i === 0){\\n            common = strs[i];\\n            continue;\\n        }\\n        while(strs[i][currInd] === common[currInd]){\\n            temp = temp + strs[i][currInd];\\n            currInd++;\\n        }\\n        common = temp;\\n        temp=\"\";\\n    }\\n    return common;\\n};\\n\\n\\nRuntime Error\\n `terminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc`"
                    },
                    {
                        "username": "Matthew910818",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int flag = 0;\\n        string ans = \"\";\\n        int len = strs[0].length();\\n        string first = strs[0];\\n        for(int i=0;i<=len;i++)\\n        {\\n            for(auto it=strs.begin();it!=strs.end();it++)\\n            {\\n                string cmp = *it;\\n                if(first[i] != cmp[i])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag == 0)\\n            {\\n                ans+=strs[0][i];\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHow come the output answer and the expected answer are the same but it still shows wrong answer?"
                    },
                    {
                        "username": "Ritam33",
                        "content": "avc"
                    },
                    {
                        "username": "willymather",
                        "content": "Should say longest substring \"car\" is not a prefix of \"racecar\""
                    },
                    {
                        "username": "urchinz",
                        "content": "I originally want to utilize python's short-circuit evaluation method: \n\nif (letter_pos >= len(current_word)) | (current_word[letter_pos] != letter):\n  -- do evaluation\n\nthe test case [\"ab\", \"a\"] keeps giving me errors. I believe it's because when letter_pos = 1, \"a\"[1] is out of index. However, because of python's or operator short-circuit, the first condition should be evaluation TRUE...\n\nAnyone have any thoughts?\n"
                    },
                    {
                        "username": "yashk1",
                        "content": "why are string questions so hard "
                    },
                    {
                        "username": "venkat50",
                        "content": "jkk"
                    },
                    {
                        "username": "kadyr1901",
                        "content": "Hi Guys, I solved this problem on C#.\\nWhen I run my code on visual studio and debug i can see it works fine, however i get different output in leetcode. \\nCan someone help me?"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "Why does the problem have a testcase  [\"\",\"\"] when it clearly says it accepts only lowercase English letters?"
                    }
                ]
            },
            {
                "id": 1713556,
                "content": [
                    {
                        "username": "charanrai",
                        "content": " `string longestCommonPrefix(vector<string>& strs) {\\n        \\n        sort(strs.begin(), strs.end());\\n\\n        string fir_str = strs[0];\\n        string last_str = strs[strs.size() - 1];\\n\\n        int matched = 0;\\n        for (int  i = 0; i < fir_str.size(); i++) {\\n            if (fir_str[i] != last_str[i] ) {\\n                break;\\n            }\\n            ++matched;\\n        } \\n        \\n        if (matched == 0) {\\n            return \"\";\\n        }\\n        return fir_str.substr(0, matched);\\n    }`"
                    },
                    {
                        "username": "jamadade",
                        "content": "Why am I not able to submit this code?\\n\\n\\nvar longestCommonPrefix = function(strs) {\\n\\n    var common = \"\";\\n    var temp = \"\";\\n\\n    for(var i = 0; i < strs.length; i++){\\n        var currInd = 0;\\n        if(i === 0){\\n            common = strs[i];\\n            continue;\\n        }\\n        while(strs[i][currInd] === common[currInd]){\\n            temp = temp + strs[i][currInd];\\n            currInd++;\\n        }\\n        common = temp;\\n        temp=\"\";\\n    }\\n    return common;\\n};\\n\\n\\nRuntime Error\\n `terminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc`"
                    },
                    {
                        "username": "Matthew910818",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int flag = 0;\\n        string ans = \"\";\\n        int len = strs[0].length();\\n        string first = strs[0];\\n        for(int i=0;i<=len;i++)\\n        {\\n            for(auto it=strs.begin();it!=strs.end();it++)\\n            {\\n                string cmp = *it;\\n                if(first[i] != cmp[i])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag == 0)\\n            {\\n                ans+=strs[0][i];\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHow come the output answer and the expected answer are the same but it still shows wrong answer?"
                    },
                    {
                        "username": "Ritam33",
                        "content": "avc"
                    },
                    {
                        "username": "willymather",
                        "content": "Should say longest substring \"car\" is not a prefix of \"racecar\""
                    },
                    {
                        "username": "urchinz",
                        "content": "I originally want to utilize python's short-circuit evaluation method: \n\nif (letter_pos >= len(current_word)) | (current_word[letter_pos] != letter):\n  -- do evaluation\n\nthe test case [\"ab\", \"a\"] keeps giving me errors. I believe it's because when letter_pos = 1, \"a\"[1] is out of index. However, because of python's or operator short-circuit, the first condition should be evaluation TRUE...\n\nAnyone have any thoughts?\n"
                    },
                    {
                        "username": "yashk1",
                        "content": "why are string questions so hard "
                    },
                    {
                        "username": "venkat50",
                        "content": "jkk"
                    },
                    {
                        "username": "kadyr1901",
                        "content": "Hi Guys, I solved this problem on C#.\\nWhen I run my code on visual studio and debug i can see it works fine, however i get different output in leetcode. \\nCan someone help me?"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "Why does the problem have a testcase  [\"\",\"\"] when it clearly says it accepts only lowercase English letters?"
                    }
                ]
            },
            {
                "id": 1709875,
                "content": [
                    {
                        "username": "charanrai",
                        "content": " `string longestCommonPrefix(vector<string>& strs) {\\n        \\n        sort(strs.begin(), strs.end());\\n\\n        string fir_str = strs[0];\\n        string last_str = strs[strs.size() - 1];\\n\\n        int matched = 0;\\n        for (int  i = 0; i < fir_str.size(); i++) {\\n            if (fir_str[i] != last_str[i] ) {\\n                break;\\n            }\\n            ++matched;\\n        } \\n        \\n        if (matched == 0) {\\n            return \"\";\\n        }\\n        return fir_str.substr(0, matched);\\n    }`"
                    },
                    {
                        "username": "jamadade",
                        "content": "Why am I not able to submit this code?\\n\\n\\nvar longestCommonPrefix = function(strs) {\\n\\n    var common = \"\";\\n    var temp = \"\";\\n\\n    for(var i = 0; i < strs.length; i++){\\n        var currInd = 0;\\n        if(i === 0){\\n            common = strs[i];\\n            continue;\\n        }\\n        while(strs[i][currInd] === common[currInd]){\\n            temp = temp + strs[i][currInd];\\n            currInd++;\\n        }\\n        common = temp;\\n        temp=\"\";\\n    }\\n    return common;\\n};\\n\\n\\nRuntime Error\\n `terminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc`"
                    },
                    {
                        "username": "Matthew910818",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int flag = 0;\\n        string ans = \"\";\\n        int len = strs[0].length();\\n        string first = strs[0];\\n        for(int i=0;i<=len;i++)\\n        {\\n            for(auto it=strs.begin();it!=strs.end();it++)\\n            {\\n                string cmp = *it;\\n                if(first[i] != cmp[i])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag == 0)\\n            {\\n                ans+=strs[0][i];\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHow come the output answer and the expected answer are the same but it still shows wrong answer?"
                    },
                    {
                        "username": "Ritam33",
                        "content": "avc"
                    },
                    {
                        "username": "willymather",
                        "content": "Should say longest substring \"car\" is not a prefix of \"racecar\""
                    },
                    {
                        "username": "urchinz",
                        "content": "I originally want to utilize python's short-circuit evaluation method: \n\nif (letter_pos >= len(current_word)) | (current_word[letter_pos] != letter):\n  -- do evaluation\n\nthe test case [\"ab\", \"a\"] keeps giving me errors. I believe it's because when letter_pos = 1, \"a\"[1] is out of index. However, because of python's or operator short-circuit, the first condition should be evaluation TRUE...\n\nAnyone have any thoughts?\n"
                    },
                    {
                        "username": "yashk1",
                        "content": "why are string questions so hard "
                    },
                    {
                        "username": "venkat50",
                        "content": "jkk"
                    },
                    {
                        "username": "kadyr1901",
                        "content": "Hi Guys, I solved this problem on C#.\\nWhen I run my code on visual studio and debug i can see it works fine, however i get different output in leetcode. \\nCan someone help me?"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "Why does the problem have a testcase  [\"\",\"\"] when it clearly says it accepts only lowercase English letters?"
                    }
                ]
            },
            {
                "id": 1707963,
                "content": [
                    {
                        "username": "charanrai",
                        "content": " `string longestCommonPrefix(vector<string>& strs) {\\n        \\n        sort(strs.begin(), strs.end());\\n\\n        string fir_str = strs[0];\\n        string last_str = strs[strs.size() - 1];\\n\\n        int matched = 0;\\n        for (int  i = 0; i < fir_str.size(); i++) {\\n            if (fir_str[i] != last_str[i] ) {\\n                break;\\n            }\\n            ++matched;\\n        } \\n        \\n        if (matched == 0) {\\n            return \"\";\\n        }\\n        return fir_str.substr(0, matched);\\n    }`"
                    },
                    {
                        "username": "jamadade",
                        "content": "Why am I not able to submit this code?\\n\\n\\nvar longestCommonPrefix = function(strs) {\\n\\n    var common = \"\";\\n    var temp = \"\";\\n\\n    for(var i = 0; i < strs.length; i++){\\n        var currInd = 0;\\n        if(i === 0){\\n            common = strs[i];\\n            continue;\\n        }\\n        while(strs[i][currInd] === common[currInd]){\\n            temp = temp + strs[i][currInd];\\n            currInd++;\\n        }\\n        common = temp;\\n        temp=\"\";\\n    }\\n    return common;\\n};\\n\\n\\nRuntime Error\\n `terminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc`"
                    },
                    {
                        "username": "Matthew910818",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int flag = 0;\\n        string ans = \"\";\\n        int len = strs[0].length();\\n        string first = strs[0];\\n        for(int i=0;i<=len;i++)\\n        {\\n            for(auto it=strs.begin();it!=strs.end();it++)\\n            {\\n                string cmp = *it;\\n                if(first[i] != cmp[i])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag == 0)\\n            {\\n                ans+=strs[0][i];\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHow come the output answer and the expected answer are the same but it still shows wrong answer?"
                    },
                    {
                        "username": "Ritam33",
                        "content": "avc"
                    },
                    {
                        "username": "willymather",
                        "content": "Should say longest substring \"car\" is not a prefix of \"racecar\""
                    },
                    {
                        "username": "urchinz",
                        "content": "I originally want to utilize python's short-circuit evaluation method: \n\nif (letter_pos >= len(current_word)) | (current_word[letter_pos] != letter):\n  -- do evaluation\n\nthe test case [\"ab\", \"a\"] keeps giving me errors. I believe it's because when letter_pos = 1, \"a\"[1] is out of index. However, because of python's or operator short-circuit, the first condition should be evaluation TRUE...\n\nAnyone have any thoughts?\n"
                    },
                    {
                        "username": "yashk1",
                        "content": "why are string questions so hard "
                    },
                    {
                        "username": "venkat50",
                        "content": "jkk"
                    },
                    {
                        "username": "kadyr1901",
                        "content": "Hi Guys, I solved this problem on C#.\\nWhen I run my code on visual studio and debug i can see it works fine, however i get different output in leetcode. \\nCan someone help me?"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "Why does the problem have a testcase  [\"\",\"\"] when it clearly says it accepts only lowercase English letters?"
                    }
                ]
            },
            {
                "id": 1707681,
                "content": [
                    {
                        "username": "charanrai",
                        "content": " `string longestCommonPrefix(vector<string>& strs) {\\n        \\n        sort(strs.begin(), strs.end());\\n\\n        string fir_str = strs[0];\\n        string last_str = strs[strs.size() - 1];\\n\\n        int matched = 0;\\n        for (int  i = 0; i < fir_str.size(); i++) {\\n            if (fir_str[i] != last_str[i] ) {\\n                break;\\n            }\\n            ++matched;\\n        } \\n        \\n        if (matched == 0) {\\n            return \"\";\\n        }\\n        return fir_str.substr(0, matched);\\n    }`"
                    },
                    {
                        "username": "jamadade",
                        "content": "Why am I not able to submit this code?\\n\\n\\nvar longestCommonPrefix = function(strs) {\\n\\n    var common = \"\";\\n    var temp = \"\";\\n\\n    for(var i = 0; i < strs.length; i++){\\n        var currInd = 0;\\n        if(i === 0){\\n            common = strs[i];\\n            continue;\\n        }\\n        while(strs[i][currInd] === common[currInd]){\\n            temp = temp + strs[i][currInd];\\n            currInd++;\\n        }\\n        common = temp;\\n        temp=\"\";\\n    }\\n    return common;\\n};\\n\\n\\nRuntime Error\\n `terminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc`"
                    },
                    {
                        "username": "Matthew910818",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int flag = 0;\\n        string ans = \"\";\\n        int len = strs[0].length();\\n        string first = strs[0];\\n        for(int i=0;i<=len;i++)\\n        {\\n            for(auto it=strs.begin();it!=strs.end();it++)\\n            {\\n                string cmp = *it;\\n                if(first[i] != cmp[i])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag == 0)\\n            {\\n                ans+=strs[0][i];\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHow come the output answer and the expected answer are the same but it still shows wrong answer?"
                    },
                    {
                        "username": "Ritam33",
                        "content": "avc"
                    },
                    {
                        "username": "willymather",
                        "content": "Should say longest substring \"car\" is not a prefix of \"racecar\""
                    },
                    {
                        "username": "urchinz",
                        "content": "I originally want to utilize python's short-circuit evaluation method: \n\nif (letter_pos >= len(current_word)) | (current_word[letter_pos] != letter):\n  -- do evaluation\n\nthe test case [\"ab\", \"a\"] keeps giving me errors. I believe it's because when letter_pos = 1, \"a\"[1] is out of index. However, because of python's or operator short-circuit, the first condition should be evaluation TRUE...\n\nAnyone have any thoughts?\n"
                    },
                    {
                        "username": "yashk1",
                        "content": "why are string questions so hard "
                    },
                    {
                        "username": "venkat50",
                        "content": "jkk"
                    },
                    {
                        "username": "kadyr1901",
                        "content": "Hi Guys, I solved this problem on C#.\\nWhen I run my code on visual studio and debug i can see it works fine, however i get different output in leetcode. \\nCan someone help me?"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "Why does the problem have a testcase  [\"\",\"\"] when it clearly says it accepts only lowercase English letters?"
                    }
                ]
            },
            {
                "id": 1707579,
                "content": [
                    {
                        "username": "charanrai",
                        "content": " `string longestCommonPrefix(vector<string>& strs) {\\n        \\n        sort(strs.begin(), strs.end());\\n\\n        string fir_str = strs[0];\\n        string last_str = strs[strs.size() - 1];\\n\\n        int matched = 0;\\n        for (int  i = 0; i < fir_str.size(); i++) {\\n            if (fir_str[i] != last_str[i] ) {\\n                break;\\n            }\\n            ++matched;\\n        } \\n        \\n        if (matched == 0) {\\n            return \"\";\\n        }\\n        return fir_str.substr(0, matched);\\n    }`"
                    },
                    {
                        "username": "jamadade",
                        "content": "Why am I not able to submit this code?\\n\\n\\nvar longestCommonPrefix = function(strs) {\\n\\n    var common = \"\";\\n    var temp = \"\";\\n\\n    for(var i = 0; i < strs.length; i++){\\n        var currInd = 0;\\n        if(i === 0){\\n            common = strs[i];\\n            continue;\\n        }\\n        while(strs[i][currInd] === common[currInd]){\\n            temp = temp + strs[i][currInd];\\n            currInd++;\\n        }\\n        common = temp;\\n        temp=\"\";\\n    }\\n    return common;\\n};\\n\\n\\nRuntime Error\\n `terminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc`"
                    },
                    {
                        "username": "Matthew910818",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int flag = 0;\\n        string ans = \"\";\\n        int len = strs[0].length();\\n        string first = strs[0];\\n        for(int i=0;i<=len;i++)\\n        {\\n            for(auto it=strs.begin();it!=strs.end();it++)\\n            {\\n                string cmp = *it;\\n                if(first[i] != cmp[i])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag == 0)\\n            {\\n                ans+=strs[0][i];\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHow come the output answer and the expected answer are the same but it still shows wrong answer?"
                    },
                    {
                        "username": "Ritam33",
                        "content": "avc"
                    },
                    {
                        "username": "willymather",
                        "content": "Should say longest substring \"car\" is not a prefix of \"racecar\""
                    },
                    {
                        "username": "urchinz",
                        "content": "I originally want to utilize python's short-circuit evaluation method: \n\nif (letter_pos >= len(current_word)) | (current_word[letter_pos] != letter):\n  -- do evaluation\n\nthe test case [\"ab\", \"a\"] keeps giving me errors. I believe it's because when letter_pos = 1, \"a\"[1] is out of index. However, because of python's or operator short-circuit, the first condition should be evaluation TRUE...\n\nAnyone have any thoughts?\n"
                    },
                    {
                        "username": "yashk1",
                        "content": "why are string questions so hard "
                    },
                    {
                        "username": "venkat50",
                        "content": "jkk"
                    },
                    {
                        "username": "kadyr1901",
                        "content": "Hi Guys, I solved this problem on C#.\\nWhen I run my code on visual studio and debug i can see it works fine, however i get different output in leetcode. \\nCan someone help me?"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "Why does the problem have a testcase  [\"\",\"\"] when it clearly says it accepts only lowercase English letters?"
                    }
                ]
            },
            {
                "id": 1707380,
                "content": [
                    {
                        "username": "charanrai",
                        "content": " `string longestCommonPrefix(vector<string>& strs) {\\n        \\n        sort(strs.begin(), strs.end());\\n\\n        string fir_str = strs[0];\\n        string last_str = strs[strs.size() - 1];\\n\\n        int matched = 0;\\n        for (int  i = 0; i < fir_str.size(); i++) {\\n            if (fir_str[i] != last_str[i] ) {\\n                break;\\n            }\\n            ++matched;\\n        } \\n        \\n        if (matched == 0) {\\n            return \"\";\\n        }\\n        return fir_str.substr(0, matched);\\n    }`"
                    },
                    {
                        "username": "jamadade",
                        "content": "Why am I not able to submit this code?\\n\\n\\nvar longestCommonPrefix = function(strs) {\\n\\n    var common = \"\";\\n    var temp = \"\";\\n\\n    for(var i = 0; i < strs.length; i++){\\n        var currInd = 0;\\n        if(i === 0){\\n            common = strs[i];\\n            continue;\\n        }\\n        while(strs[i][currInd] === common[currInd]){\\n            temp = temp + strs[i][currInd];\\n            currInd++;\\n        }\\n        common = temp;\\n        temp=\"\";\\n    }\\n    return common;\\n};\\n\\n\\nRuntime Error\\n `terminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc`"
                    },
                    {
                        "username": "Matthew910818",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int flag = 0;\\n        string ans = \"\";\\n        int len = strs[0].length();\\n        string first = strs[0];\\n        for(int i=0;i<=len;i++)\\n        {\\n            for(auto it=strs.begin();it!=strs.end();it++)\\n            {\\n                string cmp = *it;\\n                if(first[i] != cmp[i])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag == 0)\\n            {\\n                ans+=strs[0][i];\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHow come the output answer and the expected answer are the same but it still shows wrong answer?"
                    },
                    {
                        "username": "Ritam33",
                        "content": "avc"
                    },
                    {
                        "username": "willymather",
                        "content": "Should say longest substring \"car\" is not a prefix of \"racecar\""
                    },
                    {
                        "username": "urchinz",
                        "content": "I originally want to utilize python's short-circuit evaluation method: \n\nif (letter_pos >= len(current_word)) | (current_word[letter_pos] != letter):\n  -- do evaluation\n\nthe test case [\"ab\", \"a\"] keeps giving me errors. I believe it's because when letter_pos = 1, \"a\"[1] is out of index. However, because of python's or operator short-circuit, the first condition should be evaluation TRUE...\n\nAnyone have any thoughts?\n"
                    },
                    {
                        "username": "yashk1",
                        "content": "why are string questions so hard "
                    },
                    {
                        "username": "venkat50",
                        "content": "jkk"
                    },
                    {
                        "username": "kadyr1901",
                        "content": "Hi Guys, I solved this problem on C#.\\nWhen I run my code on visual studio and debug i can see it works fine, however i get different output in leetcode. \\nCan someone help me?"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "Why does the problem have a testcase  [\"\",\"\"] when it clearly says it accepts only lowercase English letters?"
                    }
                ]
            },
            {
                "id": 1704244,
                "content": [
                    {
                        "username": "charanrai",
                        "content": " `string longestCommonPrefix(vector<string>& strs) {\\n        \\n        sort(strs.begin(), strs.end());\\n\\n        string fir_str = strs[0];\\n        string last_str = strs[strs.size() - 1];\\n\\n        int matched = 0;\\n        for (int  i = 0; i < fir_str.size(); i++) {\\n            if (fir_str[i] != last_str[i] ) {\\n                break;\\n            }\\n            ++matched;\\n        } \\n        \\n        if (matched == 0) {\\n            return \"\";\\n        }\\n        return fir_str.substr(0, matched);\\n    }`"
                    },
                    {
                        "username": "jamadade",
                        "content": "Why am I not able to submit this code?\\n\\n\\nvar longestCommonPrefix = function(strs) {\\n\\n    var common = \"\";\\n    var temp = \"\";\\n\\n    for(var i = 0; i < strs.length; i++){\\n        var currInd = 0;\\n        if(i === 0){\\n            common = strs[i];\\n            continue;\\n        }\\n        while(strs[i][currInd] === common[currInd]){\\n            temp = temp + strs[i][currInd];\\n            currInd++;\\n        }\\n        common = temp;\\n        temp=\"\";\\n    }\\n    return common;\\n};\\n\\n\\nRuntime Error\\n `terminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc`"
                    },
                    {
                        "username": "Matthew910818",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int flag = 0;\\n        string ans = \"\";\\n        int len = strs[0].length();\\n        string first = strs[0];\\n        for(int i=0;i<=len;i++)\\n        {\\n            for(auto it=strs.begin();it!=strs.end();it++)\\n            {\\n                string cmp = *it;\\n                if(first[i] != cmp[i])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag == 0)\\n            {\\n                ans+=strs[0][i];\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHow come the output answer and the expected answer are the same but it still shows wrong answer?"
                    },
                    {
                        "username": "Ritam33",
                        "content": "avc"
                    },
                    {
                        "username": "willymather",
                        "content": "Should say longest substring \"car\" is not a prefix of \"racecar\""
                    },
                    {
                        "username": "urchinz",
                        "content": "I originally want to utilize python's short-circuit evaluation method: \n\nif (letter_pos >= len(current_word)) | (current_word[letter_pos] != letter):\n  -- do evaluation\n\nthe test case [\"ab\", \"a\"] keeps giving me errors. I believe it's because when letter_pos = 1, \"a\"[1] is out of index. However, because of python's or operator short-circuit, the first condition should be evaluation TRUE...\n\nAnyone have any thoughts?\n"
                    },
                    {
                        "username": "yashk1",
                        "content": "why are string questions so hard "
                    },
                    {
                        "username": "venkat50",
                        "content": "jkk"
                    },
                    {
                        "username": "kadyr1901",
                        "content": "Hi Guys, I solved this problem on C#.\\nWhen I run my code on visual studio and debug i can see it works fine, however i get different output in leetcode. \\nCan someone help me?"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "Why does the problem have a testcase  [\"\",\"\"] when it clearly says it accepts only lowercase English letters?"
                    }
                ]
            },
            {
                "id": 1702173,
                "content": [
                    {
                        "username": "mirotvoretts",
                        "content": "How can I improve my code? I dont like my SymbolIsContainedInStringsOnPosition, because it asks for 3 arguments. Suggestions?\n`public class Solution\n{\n    public string FindShortestWord(string[] strs)\n    {\n        var shortestWord = strs[0];\n\n        foreach (var word in strs)\n        {\n            if (word.Length < shortestWord.Length)\n                shortestWord = word;\n        }\n\n        return shortestWord;\n    }\n\n    public bool SymbolIsContainedInStringsOnPosition(char symbol, string[] strings, int position)\n    {\n        for (int i = 0; i < strings.Length; i++)\n        {\n            if (strings[i][position] != symbol)\n                return false;\n        }\n\n        return true;\n    }\n\n    public string LongestCommonPrefix(string[] strs)\n    {\n        var shortestWord = FindShortestWord(strs);\n        var answer = \"\";\n\n        for (int i = 0; i < shortestWord.Length; i++)\n        {\n            if (SymbolIsContainedInStringsOnPosition(shortestWord[i], strs, i))\n                answer += shortestWord[i];\n            else\n                break;\n        }\n\n        return answer;\n    }\n}`"
                    },
                    {
                        "username": "micro9997",
                        "content": "The problem statement is confusing!\\n\\nin C, as input\\n\\nchar strs[][7] = {\"flower\", \"flow\", \"flight\"};    ?\\n\\nor\\n\\nchar strs = \"[\\\\\"flower\\\\\",\\\\\"flow\\\\\",\\\\\"flight\\\\\"]\";    ?\\n"
                    },
                    {
                        "username": "dmartel33",
                        "content": "I saw the vertical scan solution immediately, but struggled with the edge cases. :("
                    },
                    {
                        "username": "acams1803",
                        "content": "guys in one of the test cases the list is [\"cir\",\"car\"] and the PREFIX expected is \"cr\" even though it should be \"c\". I believe I have misunderstood the problem. I would appreciate anyone giving an explanation."
                    },
                    {
                        "username": "Shubham_chauhan981",
                        "content": "Please read carefully the output is your output \\'cr\\' (what your program is producing) and the bottom one is expected \\'c\\' (which leetcode expects from your code)."
                    },
                    {
                        "username": "avishekchakraborty05",
                        "content": "please make the question clear. Here in the question it is asked to find the longest common prefix but not mentioned that whether we have to compare with many prefixes or there will be only one prefix sequence.\\nwhenever I am putting multiple prefixes it is showing me wrong output.\\nThank you\\n"
                    },
                    {
                        "username": "reton2008",
                        "content": "I have confusion here, like it says to find the longest prefix so we need to check each and evey character with corresponding array string. than what woud be the output of this test case\n\n`strs = [\"fllfower\",\"fllfow\",\"fllfight\"]`"
                    },
                    {
                        "username": "user8889vy",
                        "content": "check only the prefix that is from the start the output for this would be -> fllf"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html)"
                    },
                    {
                        "username": "pradeep_skywalker",
                        "content": "Hi Guys, \\n\\nWhat is the TC of this solution. I think it\\'s O(N^3). Can you please check?\\n`class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n\\n        d=collections.defaultdict(list)\\n        for i in range(len(strs[0])):\\n            d[strs[0][i]].append(i)\\n        print(d)\\n\\n        ans=\"\"\\n        L=len(strs[0])\\n        l=0\\n        for i in range(1,len(strs)):\\n            ans=\"\"\\n            l=0\\n            for j in range(len(strs[i])):\\n                if j<L:\\n                    if strs[i][j] not in d.keys():\\n                        break\\n                    elif j not in d[strs[i][j]]:\\n                        break\\n                    else:\\n                        ans+=strs[i][j]\\n                        l+=1\\n                        # d[strs[i][j]].remove(j)\\n            L=l\\n            print(ans,L)\\n        return ans`\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "I think it\\'s just N^2"
                    },
                    {
                        "username": "pradeep_selvaraj",
                        "content": "The problem is not clear.\\n\\nBecause for given input [\"reflower\",\"flow\",\"flight\"], its not accepting the answer \"fl\" as longest common prefix ? \\nDid the question mention that either all strings in array have some common prefix or none ?\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "prefix are letters that are added to the begging of the word. So common prefix means the sequence of letters that starts in common. Start, by which means from the beginning. Since the word \\'reflower\\' starts with the letter \\'r\\', those words don\\'t have common prefix.\\nThe question doesn\\'t say that all the elements of an array have common prefix, so we can\\'t suppose that there is neither. \\nWe have to program the function to find whether there is or not, and then, if there is, what is this common prefix."
                    },
                    {
                        "username": "niitk",
                        "content": "my solution is true, but allocation failure, why?"
                    }
                ]
            },
            {
                "id": 1701739,
                "content": [
                    {
                        "username": "mirotvoretts",
                        "content": "How can I improve my code? I dont like my SymbolIsContainedInStringsOnPosition, because it asks for 3 arguments. Suggestions?\n`public class Solution\n{\n    public string FindShortestWord(string[] strs)\n    {\n        var shortestWord = strs[0];\n\n        foreach (var word in strs)\n        {\n            if (word.Length < shortestWord.Length)\n                shortestWord = word;\n        }\n\n        return shortestWord;\n    }\n\n    public bool SymbolIsContainedInStringsOnPosition(char symbol, string[] strings, int position)\n    {\n        for (int i = 0; i < strings.Length; i++)\n        {\n            if (strings[i][position] != symbol)\n                return false;\n        }\n\n        return true;\n    }\n\n    public string LongestCommonPrefix(string[] strs)\n    {\n        var shortestWord = FindShortestWord(strs);\n        var answer = \"\";\n\n        for (int i = 0; i < shortestWord.Length; i++)\n        {\n            if (SymbolIsContainedInStringsOnPosition(shortestWord[i], strs, i))\n                answer += shortestWord[i];\n            else\n                break;\n        }\n\n        return answer;\n    }\n}`"
                    },
                    {
                        "username": "micro9997",
                        "content": "The problem statement is confusing!\\n\\nin C, as input\\n\\nchar strs[][7] = {\"flower\", \"flow\", \"flight\"};    ?\\n\\nor\\n\\nchar strs = \"[\\\\\"flower\\\\\",\\\\\"flow\\\\\",\\\\\"flight\\\\\"]\";    ?\\n"
                    },
                    {
                        "username": "dmartel33",
                        "content": "I saw the vertical scan solution immediately, but struggled with the edge cases. :("
                    },
                    {
                        "username": "acams1803",
                        "content": "guys in one of the test cases the list is [\"cir\",\"car\"] and the PREFIX expected is \"cr\" even though it should be \"c\". I believe I have misunderstood the problem. I would appreciate anyone giving an explanation."
                    },
                    {
                        "username": "Shubham_chauhan981",
                        "content": "Please read carefully the output is your output \\'cr\\' (what your program is producing) and the bottom one is expected \\'c\\' (which leetcode expects from your code)."
                    },
                    {
                        "username": "avishekchakraborty05",
                        "content": "please make the question clear. Here in the question it is asked to find the longest common prefix but not mentioned that whether we have to compare with many prefixes or there will be only one prefix sequence.\\nwhenever I am putting multiple prefixes it is showing me wrong output.\\nThank you\\n"
                    },
                    {
                        "username": "reton2008",
                        "content": "I have confusion here, like it says to find the longest prefix so we need to check each and evey character with corresponding array string. than what woud be the output of this test case\n\n`strs = [\"fllfower\",\"fllfow\",\"fllfight\"]`"
                    },
                    {
                        "username": "user8889vy",
                        "content": "check only the prefix that is from the start the output for this would be -> fllf"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html)"
                    },
                    {
                        "username": "pradeep_skywalker",
                        "content": "Hi Guys, \\n\\nWhat is the TC of this solution. I think it\\'s O(N^3). Can you please check?\\n`class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n\\n        d=collections.defaultdict(list)\\n        for i in range(len(strs[0])):\\n            d[strs[0][i]].append(i)\\n        print(d)\\n\\n        ans=\"\"\\n        L=len(strs[0])\\n        l=0\\n        for i in range(1,len(strs)):\\n            ans=\"\"\\n            l=0\\n            for j in range(len(strs[i])):\\n                if j<L:\\n                    if strs[i][j] not in d.keys():\\n                        break\\n                    elif j not in d[strs[i][j]]:\\n                        break\\n                    else:\\n                        ans+=strs[i][j]\\n                        l+=1\\n                        # d[strs[i][j]].remove(j)\\n            L=l\\n            print(ans,L)\\n        return ans`\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "I think it\\'s just N^2"
                    },
                    {
                        "username": "pradeep_selvaraj",
                        "content": "The problem is not clear.\\n\\nBecause for given input [\"reflower\",\"flow\",\"flight\"], its not accepting the answer \"fl\" as longest common prefix ? \\nDid the question mention that either all strings in array have some common prefix or none ?\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "prefix are letters that are added to the begging of the word. So common prefix means the sequence of letters that starts in common. Start, by which means from the beginning. Since the word \\'reflower\\' starts with the letter \\'r\\', those words don\\'t have common prefix.\\nThe question doesn\\'t say that all the elements of an array have common prefix, so we can\\'t suppose that there is neither. \\nWe have to program the function to find whether there is or not, and then, if there is, what is this common prefix."
                    },
                    {
                        "username": "niitk",
                        "content": "my solution is true, but allocation failure, why?"
                    }
                ]
            },
            {
                "id": 1691108,
                "content": [
                    {
                        "username": "mirotvoretts",
                        "content": "How can I improve my code? I dont like my SymbolIsContainedInStringsOnPosition, because it asks for 3 arguments. Suggestions?\n`public class Solution\n{\n    public string FindShortestWord(string[] strs)\n    {\n        var shortestWord = strs[0];\n\n        foreach (var word in strs)\n        {\n            if (word.Length < shortestWord.Length)\n                shortestWord = word;\n        }\n\n        return shortestWord;\n    }\n\n    public bool SymbolIsContainedInStringsOnPosition(char symbol, string[] strings, int position)\n    {\n        for (int i = 0; i < strings.Length; i++)\n        {\n            if (strings[i][position] != symbol)\n                return false;\n        }\n\n        return true;\n    }\n\n    public string LongestCommonPrefix(string[] strs)\n    {\n        var shortestWord = FindShortestWord(strs);\n        var answer = \"\";\n\n        for (int i = 0; i < shortestWord.Length; i++)\n        {\n            if (SymbolIsContainedInStringsOnPosition(shortestWord[i], strs, i))\n                answer += shortestWord[i];\n            else\n                break;\n        }\n\n        return answer;\n    }\n}`"
                    },
                    {
                        "username": "micro9997",
                        "content": "The problem statement is confusing!\\n\\nin C, as input\\n\\nchar strs[][7] = {\"flower\", \"flow\", \"flight\"};    ?\\n\\nor\\n\\nchar strs = \"[\\\\\"flower\\\\\",\\\\\"flow\\\\\",\\\\\"flight\\\\\"]\";    ?\\n"
                    },
                    {
                        "username": "dmartel33",
                        "content": "I saw the vertical scan solution immediately, but struggled with the edge cases. :("
                    },
                    {
                        "username": "acams1803",
                        "content": "guys in one of the test cases the list is [\"cir\",\"car\"] and the PREFIX expected is \"cr\" even though it should be \"c\". I believe I have misunderstood the problem. I would appreciate anyone giving an explanation."
                    },
                    {
                        "username": "Shubham_chauhan981",
                        "content": "Please read carefully the output is your output \\'cr\\' (what your program is producing) and the bottom one is expected \\'c\\' (which leetcode expects from your code)."
                    },
                    {
                        "username": "avishekchakraborty05",
                        "content": "please make the question clear. Here in the question it is asked to find the longest common prefix but not mentioned that whether we have to compare with many prefixes or there will be only one prefix sequence.\\nwhenever I am putting multiple prefixes it is showing me wrong output.\\nThank you\\n"
                    },
                    {
                        "username": "reton2008",
                        "content": "I have confusion here, like it says to find the longest prefix so we need to check each and evey character with corresponding array string. than what woud be the output of this test case\n\n`strs = [\"fllfower\",\"fllfow\",\"fllfight\"]`"
                    },
                    {
                        "username": "user8889vy",
                        "content": "check only the prefix that is from the start the output for this would be -> fllf"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html)"
                    },
                    {
                        "username": "pradeep_skywalker",
                        "content": "Hi Guys, \\n\\nWhat is the TC of this solution. I think it\\'s O(N^3). Can you please check?\\n`class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n\\n        d=collections.defaultdict(list)\\n        for i in range(len(strs[0])):\\n            d[strs[0][i]].append(i)\\n        print(d)\\n\\n        ans=\"\"\\n        L=len(strs[0])\\n        l=0\\n        for i in range(1,len(strs)):\\n            ans=\"\"\\n            l=0\\n            for j in range(len(strs[i])):\\n                if j<L:\\n                    if strs[i][j] not in d.keys():\\n                        break\\n                    elif j not in d[strs[i][j]]:\\n                        break\\n                    else:\\n                        ans+=strs[i][j]\\n                        l+=1\\n                        # d[strs[i][j]].remove(j)\\n            L=l\\n            print(ans,L)\\n        return ans`\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "I think it\\'s just N^2"
                    },
                    {
                        "username": "pradeep_selvaraj",
                        "content": "The problem is not clear.\\n\\nBecause for given input [\"reflower\",\"flow\",\"flight\"], its not accepting the answer \"fl\" as longest common prefix ? \\nDid the question mention that either all strings in array have some common prefix or none ?\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "prefix are letters that are added to the begging of the word. So common prefix means the sequence of letters that starts in common. Start, by which means from the beginning. Since the word \\'reflower\\' starts with the letter \\'r\\', those words don\\'t have common prefix.\\nThe question doesn\\'t say that all the elements of an array have common prefix, so we can\\'t suppose that there is neither. \\nWe have to program the function to find whether there is or not, and then, if there is, what is this common prefix."
                    },
                    {
                        "username": "niitk",
                        "content": "my solution is true, but allocation failure, why?"
                    }
                ]
            },
            {
                "id": 1690959,
                "content": [
                    {
                        "username": "mirotvoretts",
                        "content": "How can I improve my code? I dont like my SymbolIsContainedInStringsOnPosition, because it asks for 3 arguments. Suggestions?\n`public class Solution\n{\n    public string FindShortestWord(string[] strs)\n    {\n        var shortestWord = strs[0];\n\n        foreach (var word in strs)\n        {\n            if (word.Length < shortestWord.Length)\n                shortestWord = word;\n        }\n\n        return shortestWord;\n    }\n\n    public bool SymbolIsContainedInStringsOnPosition(char symbol, string[] strings, int position)\n    {\n        for (int i = 0; i < strings.Length; i++)\n        {\n            if (strings[i][position] != symbol)\n                return false;\n        }\n\n        return true;\n    }\n\n    public string LongestCommonPrefix(string[] strs)\n    {\n        var shortestWord = FindShortestWord(strs);\n        var answer = \"\";\n\n        for (int i = 0; i < shortestWord.Length; i++)\n        {\n            if (SymbolIsContainedInStringsOnPosition(shortestWord[i], strs, i))\n                answer += shortestWord[i];\n            else\n                break;\n        }\n\n        return answer;\n    }\n}`"
                    },
                    {
                        "username": "micro9997",
                        "content": "The problem statement is confusing!\\n\\nin C, as input\\n\\nchar strs[][7] = {\"flower\", \"flow\", \"flight\"};    ?\\n\\nor\\n\\nchar strs = \"[\\\\\"flower\\\\\",\\\\\"flow\\\\\",\\\\\"flight\\\\\"]\";    ?\\n"
                    },
                    {
                        "username": "dmartel33",
                        "content": "I saw the vertical scan solution immediately, but struggled with the edge cases. :("
                    },
                    {
                        "username": "acams1803",
                        "content": "guys in one of the test cases the list is [\"cir\",\"car\"] and the PREFIX expected is \"cr\" even though it should be \"c\". I believe I have misunderstood the problem. I would appreciate anyone giving an explanation."
                    },
                    {
                        "username": "Shubham_chauhan981",
                        "content": "Please read carefully the output is your output \\'cr\\' (what your program is producing) and the bottom one is expected \\'c\\' (which leetcode expects from your code)."
                    },
                    {
                        "username": "avishekchakraborty05",
                        "content": "please make the question clear. Here in the question it is asked to find the longest common prefix but not mentioned that whether we have to compare with many prefixes or there will be only one prefix sequence.\\nwhenever I am putting multiple prefixes it is showing me wrong output.\\nThank you\\n"
                    },
                    {
                        "username": "reton2008",
                        "content": "I have confusion here, like it says to find the longest prefix so we need to check each and evey character with corresponding array string. than what woud be the output of this test case\n\n`strs = [\"fllfower\",\"fllfow\",\"fllfight\"]`"
                    },
                    {
                        "username": "user8889vy",
                        "content": "check only the prefix that is from the start the output for this would be -> fllf"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html)"
                    },
                    {
                        "username": "pradeep_skywalker",
                        "content": "Hi Guys, \\n\\nWhat is the TC of this solution. I think it\\'s O(N^3). Can you please check?\\n`class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n\\n        d=collections.defaultdict(list)\\n        for i in range(len(strs[0])):\\n            d[strs[0][i]].append(i)\\n        print(d)\\n\\n        ans=\"\"\\n        L=len(strs[0])\\n        l=0\\n        for i in range(1,len(strs)):\\n            ans=\"\"\\n            l=0\\n            for j in range(len(strs[i])):\\n                if j<L:\\n                    if strs[i][j] not in d.keys():\\n                        break\\n                    elif j not in d[strs[i][j]]:\\n                        break\\n                    else:\\n                        ans+=strs[i][j]\\n                        l+=1\\n                        # d[strs[i][j]].remove(j)\\n            L=l\\n            print(ans,L)\\n        return ans`\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "I think it\\'s just N^2"
                    },
                    {
                        "username": "pradeep_selvaraj",
                        "content": "The problem is not clear.\\n\\nBecause for given input [\"reflower\",\"flow\",\"flight\"], its not accepting the answer \"fl\" as longest common prefix ? \\nDid the question mention that either all strings in array have some common prefix or none ?\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "prefix are letters that are added to the begging of the word. So common prefix means the sequence of letters that starts in common. Start, by which means from the beginning. Since the word \\'reflower\\' starts with the letter \\'r\\', those words don\\'t have common prefix.\\nThe question doesn\\'t say that all the elements of an array have common prefix, so we can\\'t suppose that there is neither. \\nWe have to program the function to find whether there is or not, and then, if there is, what is this common prefix."
                    },
                    {
                        "username": "niitk",
                        "content": "my solution is true, but allocation failure, why?"
                    }
                ]
            },
            {
                "id": 1678402,
                "content": [
                    {
                        "username": "mirotvoretts",
                        "content": "How can I improve my code? I dont like my SymbolIsContainedInStringsOnPosition, because it asks for 3 arguments. Suggestions?\n`public class Solution\n{\n    public string FindShortestWord(string[] strs)\n    {\n        var shortestWord = strs[0];\n\n        foreach (var word in strs)\n        {\n            if (word.Length < shortestWord.Length)\n                shortestWord = word;\n        }\n\n        return shortestWord;\n    }\n\n    public bool SymbolIsContainedInStringsOnPosition(char symbol, string[] strings, int position)\n    {\n        for (int i = 0; i < strings.Length; i++)\n        {\n            if (strings[i][position] != symbol)\n                return false;\n        }\n\n        return true;\n    }\n\n    public string LongestCommonPrefix(string[] strs)\n    {\n        var shortestWord = FindShortestWord(strs);\n        var answer = \"\";\n\n        for (int i = 0; i < shortestWord.Length; i++)\n        {\n            if (SymbolIsContainedInStringsOnPosition(shortestWord[i], strs, i))\n                answer += shortestWord[i];\n            else\n                break;\n        }\n\n        return answer;\n    }\n}`"
                    },
                    {
                        "username": "micro9997",
                        "content": "The problem statement is confusing!\\n\\nin C, as input\\n\\nchar strs[][7] = {\"flower\", \"flow\", \"flight\"};    ?\\n\\nor\\n\\nchar strs = \"[\\\\\"flower\\\\\",\\\\\"flow\\\\\",\\\\\"flight\\\\\"]\";    ?\\n"
                    },
                    {
                        "username": "dmartel33",
                        "content": "I saw the vertical scan solution immediately, but struggled with the edge cases. :("
                    },
                    {
                        "username": "acams1803",
                        "content": "guys in one of the test cases the list is [\"cir\",\"car\"] and the PREFIX expected is \"cr\" even though it should be \"c\". I believe I have misunderstood the problem. I would appreciate anyone giving an explanation."
                    },
                    {
                        "username": "Shubham_chauhan981",
                        "content": "Please read carefully the output is your output \\'cr\\' (what your program is producing) and the bottom one is expected \\'c\\' (which leetcode expects from your code)."
                    },
                    {
                        "username": "avishekchakraborty05",
                        "content": "please make the question clear. Here in the question it is asked to find the longest common prefix but not mentioned that whether we have to compare with many prefixes or there will be only one prefix sequence.\\nwhenever I am putting multiple prefixes it is showing me wrong output.\\nThank you\\n"
                    },
                    {
                        "username": "reton2008",
                        "content": "I have confusion here, like it says to find the longest prefix so we need to check each and evey character with corresponding array string. than what woud be the output of this test case\n\n`strs = [\"fllfower\",\"fllfow\",\"fllfight\"]`"
                    },
                    {
                        "username": "user8889vy",
                        "content": "check only the prefix that is from the start the output for this would be -> fllf"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html)"
                    },
                    {
                        "username": "pradeep_skywalker",
                        "content": "Hi Guys, \\n\\nWhat is the TC of this solution. I think it\\'s O(N^3). Can you please check?\\n`class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n\\n        d=collections.defaultdict(list)\\n        for i in range(len(strs[0])):\\n            d[strs[0][i]].append(i)\\n        print(d)\\n\\n        ans=\"\"\\n        L=len(strs[0])\\n        l=0\\n        for i in range(1,len(strs)):\\n            ans=\"\"\\n            l=0\\n            for j in range(len(strs[i])):\\n                if j<L:\\n                    if strs[i][j] not in d.keys():\\n                        break\\n                    elif j not in d[strs[i][j]]:\\n                        break\\n                    else:\\n                        ans+=strs[i][j]\\n                        l+=1\\n                        # d[strs[i][j]].remove(j)\\n            L=l\\n            print(ans,L)\\n        return ans`\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "I think it\\'s just N^2"
                    },
                    {
                        "username": "pradeep_selvaraj",
                        "content": "The problem is not clear.\\n\\nBecause for given input [\"reflower\",\"flow\",\"flight\"], its not accepting the answer \"fl\" as longest common prefix ? \\nDid the question mention that either all strings in array have some common prefix or none ?\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "prefix are letters that are added to the begging of the word. So common prefix means the sequence of letters that starts in common. Start, by which means from the beginning. Since the word \\'reflower\\' starts with the letter \\'r\\', those words don\\'t have common prefix.\\nThe question doesn\\'t say that all the elements of an array have common prefix, so we can\\'t suppose that there is neither. \\nWe have to program the function to find whether there is or not, and then, if there is, what is this common prefix."
                    },
                    {
                        "username": "niitk",
                        "content": "my solution is true, but allocation failure, why?"
                    }
                ]
            },
            {
                "id": 1673977,
                "content": [
                    {
                        "username": "mirotvoretts",
                        "content": "How can I improve my code? I dont like my SymbolIsContainedInStringsOnPosition, because it asks for 3 arguments. Suggestions?\n`public class Solution\n{\n    public string FindShortestWord(string[] strs)\n    {\n        var shortestWord = strs[0];\n\n        foreach (var word in strs)\n        {\n            if (word.Length < shortestWord.Length)\n                shortestWord = word;\n        }\n\n        return shortestWord;\n    }\n\n    public bool SymbolIsContainedInStringsOnPosition(char symbol, string[] strings, int position)\n    {\n        for (int i = 0; i < strings.Length; i++)\n        {\n            if (strings[i][position] != symbol)\n                return false;\n        }\n\n        return true;\n    }\n\n    public string LongestCommonPrefix(string[] strs)\n    {\n        var shortestWord = FindShortestWord(strs);\n        var answer = \"\";\n\n        for (int i = 0; i < shortestWord.Length; i++)\n        {\n            if (SymbolIsContainedInStringsOnPosition(shortestWord[i], strs, i))\n                answer += shortestWord[i];\n            else\n                break;\n        }\n\n        return answer;\n    }\n}`"
                    },
                    {
                        "username": "micro9997",
                        "content": "The problem statement is confusing!\\n\\nin C, as input\\n\\nchar strs[][7] = {\"flower\", \"flow\", \"flight\"};    ?\\n\\nor\\n\\nchar strs = \"[\\\\\"flower\\\\\",\\\\\"flow\\\\\",\\\\\"flight\\\\\"]\";    ?\\n"
                    },
                    {
                        "username": "dmartel33",
                        "content": "I saw the vertical scan solution immediately, but struggled with the edge cases. :("
                    },
                    {
                        "username": "acams1803",
                        "content": "guys in one of the test cases the list is [\"cir\",\"car\"] and the PREFIX expected is \"cr\" even though it should be \"c\". I believe I have misunderstood the problem. I would appreciate anyone giving an explanation."
                    },
                    {
                        "username": "Shubham_chauhan981",
                        "content": "Please read carefully the output is your output \\'cr\\' (what your program is producing) and the bottom one is expected \\'c\\' (which leetcode expects from your code)."
                    },
                    {
                        "username": "avishekchakraborty05",
                        "content": "please make the question clear. Here in the question it is asked to find the longest common prefix but not mentioned that whether we have to compare with many prefixes or there will be only one prefix sequence.\\nwhenever I am putting multiple prefixes it is showing me wrong output.\\nThank you\\n"
                    },
                    {
                        "username": "reton2008",
                        "content": "I have confusion here, like it says to find the longest prefix so we need to check each and evey character with corresponding array string. than what woud be the output of this test case\n\n`strs = [\"fllfower\",\"fllfow\",\"fllfight\"]`"
                    },
                    {
                        "username": "user8889vy",
                        "content": "check only the prefix that is from the start the output for this would be -> fllf"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html)"
                    },
                    {
                        "username": "pradeep_skywalker",
                        "content": "Hi Guys, \\n\\nWhat is the TC of this solution. I think it\\'s O(N^3). Can you please check?\\n`class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n\\n        d=collections.defaultdict(list)\\n        for i in range(len(strs[0])):\\n            d[strs[0][i]].append(i)\\n        print(d)\\n\\n        ans=\"\"\\n        L=len(strs[0])\\n        l=0\\n        for i in range(1,len(strs)):\\n            ans=\"\"\\n            l=0\\n            for j in range(len(strs[i])):\\n                if j<L:\\n                    if strs[i][j] not in d.keys():\\n                        break\\n                    elif j not in d[strs[i][j]]:\\n                        break\\n                    else:\\n                        ans+=strs[i][j]\\n                        l+=1\\n                        # d[strs[i][j]].remove(j)\\n            L=l\\n            print(ans,L)\\n        return ans`\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "I think it\\'s just N^2"
                    },
                    {
                        "username": "pradeep_selvaraj",
                        "content": "The problem is not clear.\\n\\nBecause for given input [\"reflower\",\"flow\",\"flight\"], its not accepting the answer \"fl\" as longest common prefix ? \\nDid the question mention that either all strings in array have some common prefix or none ?\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "prefix are letters that are added to the begging of the word. So common prefix means the sequence of letters that starts in common. Start, by which means from the beginning. Since the word \\'reflower\\' starts with the letter \\'r\\', those words don\\'t have common prefix.\\nThe question doesn\\'t say that all the elements of an array have common prefix, so we can\\'t suppose that there is neither. \\nWe have to program the function to find whether there is or not, and then, if there is, what is this common prefix."
                    },
                    {
                        "username": "niitk",
                        "content": "my solution is true, but allocation failure, why?"
                    }
                ]
            },
            {
                "id": 1671252,
                "content": [
                    {
                        "username": "mirotvoretts",
                        "content": "How can I improve my code? I dont like my SymbolIsContainedInStringsOnPosition, because it asks for 3 arguments. Suggestions?\n`public class Solution\n{\n    public string FindShortestWord(string[] strs)\n    {\n        var shortestWord = strs[0];\n\n        foreach (var word in strs)\n        {\n            if (word.Length < shortestWord.Length)\n                shortestWord = word;\n        }\n\n        return shortestWord;\n    }\n\n    public bool SymbolIsContainedInStringsOnPosition(char symbol, string[] strings, int position)\n    {\n        for (int i = 0; i < strings.Length; i++)\n        {\n            if (strings[i][position] != symbol)\n                return false;\n        }\n\n        return true;\n    }\n\n    public string LongestCommonPrefix(string[] strs)\n    {\n        var shortestWord = FindShortestWord(strs);\n        var answer = \"\";\n\n        for (int i = 0; i < shortestWord.Length; i++)\n        {\n            if (SymbolIsContainedInStringsOnPosition(shortestWord[i], strs, i))\n                answer += shortestWord[i];\n            else\n                break;\n        }\n\n        return answer;\n    }\n}`"
                    },
                    {
                        "username": "micro9997",
                        "content": "The problem statement is confusing!\\n\\nin C, as input\\n\\nchar strs[][7] = {\"flower\", \"flow\", \"flight\"};    ?\\n\\nor\\n\\nchar strs = \"[\\\\\"flower\\\\\",\\\\\"flow\\\\\",\\\\\"flight\\\\\"]\";    ?\\n"
                    },
                    {
                        "username": "dmartel33",
                        "content": "I saw the vertical scan solution immediately, but struggled with the edge cases. :("
                    },
                    {
                        "username": "acams1803",
                        "content": "guys in one of the test cases the list is [\"cir\",\"car\"] and the PREFIX expected is \"cr\" even though it should be \"c\". I believe I have misunderstood the problem. I would appreciate anyone giving an explanation."
                    },
                    {
                        "username": "Shubham_chauhan981",
                        "content": "Please read carefully the output is your output \\'cr\\' (what your program is producing) and the bottom one is expected \\'c\\' (which leetcode expects from your code)."
                    },
                    {
                        "username": "avishekchakraborty05",
                        "content": "please make the question clear. Here in the question it is asked to find the longest common prefix but not mentioned that whether we have to compare with many prefixes or there will be only one prefix sequence.\\nwhenever I am putting multiple prefixes it is showing me wrong output.\\nThank you\\n"
                    },
                    {
                        "username": "reton2008",
                        "content": "I have confusion here, like it says to find the longest prefix so we need to check each and evey character with corresponding array string. than what woud be the output of this test case\n\n`strs = [\"fllfower\",\"fllfow\",\"fllfight\"]`"
                    },
                    {
                        "username": "user8889vy",
                        "content": "check only the prefix that is from the start the output for this would be -> fllf"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html)"
                    },
                    {
                        "username": "pradeep_skywalker",
                        "content": "Hi Guys, \\n\\nWhat is the TC of this solution. I think it\\'s O(N^3). Can you please check?\\n`class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n\\n        d=collections.defaultdict(list)\\n        for i in range(len(strs[0])):\\n            d[strs[0][i]].append(i)\\n        print(d)\\n\\n        ans=\"\"\\n        L=len(strs[0])\\n        l=0\\n        for i in range(1,len(strs)):\\n            ans=\"\"\\n            l=0\\n            for j in range(len(strs[i])):\\n                if j<L:\\n                    if strs[i][j] not in d.keys():\\n                        break\\n                    elif j not in d[strs[i][j]]:\\n                        break\\n                    else:\\n                        ans+=strs[i][j]\\n                        l+=1\\n                        # d[strs[i][j]].remove(j)\\n            L=l\\n            print(ans,L)\\n        return ans`\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "I think it\\'s just N^2"
                    },
                    {
                        "username": "pradeep_selvaraj",
                        "content": "The problem is not clear.\\n\\nBecause for given input [\"reflower\",\"flow\",\"flight\"], its not accepting the answer \"fl\" as longest common prefix ? \\nDid the question mention that either all strings in array have some common prefix or none ?\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "prefix are letters that are added to the begging of the word. So common prefix means the sequence of letters that starts in common. Start, by which means from the beginning. Since the word \\'reflower\\' starts with the letter \\'r\\', those words don\\'t have common prefix.\\nThe question doesn\\'t say that all the elements of an array have common prefix, so we can\\'t suppose that there is neither. \\nWe have to program the function to find whether there is or not, and then, if there is, what is this common prefix."
                    },
                    {
                        "username": "niitk",
                        "content": "my solution is true, but allocation failure, why?"
                    }
                ]
            },
            {
                "id": 1671116,
                "content": [
                    {
                        "username": "mirotvoretts",
                        "content": "How can I improve my code? I dont like my SymbolIsContainedInStringsOnPosition, because it asks for 3 arguments. Suggestions?\n`public class Solution\n{\n    public string FindShortestWord(string[] strs)\n    {\n        var shortestWord = strs[0];\n\n        foreach (var word in strs)\n        {\n            if (word.Length < shortestWord.Length)\n                shortestWord = word;\n        }\n\n        return shortestWord;\n    }\n\n    public bool SymbolIsContainedInStringsOnPosition(char symbol, string[] strings, int position)\n    {\n        for (int i = 0; i < strings.Length; i++)\n        {\n            if (strings[i][position] != symbol)\n                return false;\n        }\n\n        return true;\n    }\n\n    public string LongestCommonPrefix(string[] strs)\n    {\n        var shortestWord = FindShortestWord(strs);\n        var answer = \"\";\n\n        for (int i = 0; i < shortestWord.Length; i++)\n        {\n            if (SymbolIsContainedInStringsOnPosition(shortestWord[i], strs, i))\n                answer += shortestWord[i];\n            else\n                break;\n        }\n\n        return answer;\n    }\n}`"
                    },
                    {
                        "username": "micro9997",
                        "content": "The problem statement is confusing!\\n\\nin C, as input\\n\\nchar strs[][7] = {\"flower\", \"flow\", \"flight\"};    ?\\n\\nor\\n\\nchar strs = \"[\\\\\"flower\\\\\",\\\\\"flow\\\\\",\\\\\"flight\\\\\"]\";    ?\\n"
                    },
                    {
                        "username": "dmartel33",
                        "content": "I saw the vertical scan solution immediately, but struggled with the edge cases. :("
                    },
                    {
                        "username": "acams1803",
                        "content": "guys in one of the test cases the list is [\"cir\",\"car\"] and the PREFIX expected is \"cr\" even though it should be \"c\". I believe I have misunderstood the problem. I would appreciate anyone giving an explanation."
                    },
                    {
                        "username": "Shubham_chauhan981",
                        "content": "Please read carefully the output is your output \\'cr\\' (what your program is producing) and the bottom one is expected \\'c\\' (which leetcode expects from your code)."
                    },
                    {
                        "username": "avishekchakraborty05",
                        "content": "please make the question clear. Here in the question it is asked to find the longest common prefix but not mentioned that whether we have to compare with many prefixes or there will be only one prefix sequence.\\nwhenever I am putting multiple prefixes it is showing me wrong output.\\nThank you\\n"
                    },
                    {
                        "username": "reton2008",
                        "content": "I have confusion here, like it says to find the longest prefix so we need to check each and evey character with corresponding array string. than what woud be the output of this test case\n\n`strs = [\"fllfower\",\"fllfow\",\"fllfight\"]`"
                    },
                    {
                        "username": "user8889vy",
                        "content": "check only the prefix that is from the start the output for this would be -> fllf"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html)"
                    },
                    {
                        "username": "pradeep_skywalker",
                        "content": "Hi Guys, \\n\\nWhat is the TC of this solution. I think it\\'s O(N^3). Can you please check?\\n`class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n\\n        d=collections.defaultdict(list)\\n        for i in range(len(strs[0])):\\n            d[strs[0][i]].append(i)\\n        print(d)\\n\\n        ans=\"\"\\n        L=len(strs[0])\\n        l=0\\n        for i in range(1,len(strs)):\\n            ans=\"\"\\n            l=0\\n            for j in range(len(strs[i])):\\n                if j<L:\\n                    if strs[i][j] not in d.keys():\\n                        break\\n                    elif j not in d[strs[i][j]]:\\n                        break\\n                    else:\\n                        ans+=strs[i][j]\\n                        l+=1\\n                        # d[strs[i][j]].remove(j)\\n            L=l\\n            print(ans,L)\\n        return ans`\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "I think it\\'s just N^2"
                    },
                    {
                        "username": "pradeep_selvaraj",
                        "content": "The problem is not clear.\\n\\nBecause for given input [\"reflower\",\"flow\",\"flight\"], its not accepting the answer \"fl\" as longest common prefix ? \\nDid the question mention that either all strings in array have some common prefix or none ?\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "prefix are letters that are added to the begging of the word. So common prefix means the sequence of letters that starts in common. Start, by which means from the beginning. Since the word \\'reflower\\' starts with the letter \\'r\\', those words don\\'t have common prefix.\\nThe question doesn\\'t say that all the elements of an array have common prefix, so we can\\'t suppose that there is neither. \\nWe have to program the function to find whether there is or not, and then, if there is, what is this common prefix."
                    },
                    {
                        "username": "niitk",
                        "content": "my solution is true, but allocation failure, why?"
                    }
                ]
            },
            {
                "id": 1662522,
                "content": [
                    {
                        "username": "mirotvoretts",
                        "content": "How can I improve my code? I dont like my SymbolIsContainedInStringsOnPosition, because it asks for 3 arguments. Suggestions?\n`public class Solution\n{\n    public string FindShortestWord(string[] strs)\n    {\n        var shortestWord = strs[0];\n\n        foreach (var word in strs)\n        {\n            if (word.Length < shortestWord.Length)\n                shortestWord = word;\n        }\n\n        return shortestWord;\n    }\n\n    public bool SymbolIsContainedInStringsOnPosition(char symbol, string[] strings, int position)\n    {\n        for (int i = 0; i < strings.Length; i++)\n        {\n            if (strings[i][position] != symbol)\n                return false;\n        }\n\n        return true;\n    }\n\n    public string LongestCommonPrefix(string[] strs)\n    {\n        var shortestWord = FindShortestWord(strs);\n        var answer = \"\";\n\n        for (int i = 0; i < shortestWord.Length; i++)\n        {\n            if (SymbolIsContainedInStringsOnPosition(shortestWord[i], strs, i))\n                answer += shortestWord[i];\n            else\n                break;\n        }\n\n        return answer;\n    }\n}`"
                    },
                    {
                        "username": "micro9997",
                        "content": "The problem statement is confusing!\\n\\nin C, as input\\n\\nchar strs[][7] = {\"flower\", \"flow\", \"flight\"};    ?\\n\\nor\\n\\nchar strs = \"[\\\\\"flower\\\\\",\\\\\"flow\\\\\",\\\\\"flight\\\\\"]\";    ?\\n"
                    },
                    {
                        "username": "dmartel33",
                        "content": "I saw the vertical scan solution immediately, but struggled with the edge cases. :("
                    },
                    {
                        "username": "acams1803",
                        "content": "guys in one of the test cases the list is [\"cir\",\"car\"] and the PREFIX expected is \"cr\" even though it should be \"c\". I believe I have misunderstood the problem. I would appreciate anyone giving an explanation."
                    },
                    {
                        "username": "Shubham_chauhan981",
                        "content": "Please read carefully the output is your output \\'cr\\' (what your program is producing) and the bottom one is expected \\'c\\' (which leetcode expects from your code)."
                    },
                    {
                        "username": "avishekchakraborty05",
                        "content": "please make the question clear. Here in the question it is asked to find the longest common prefix but not mentioned that whether we have to compare with many prefixes or there will be only one prefix sequence.\\nwhenever I am putting multiple prefixes it is showing me wrong output.\\nThank you\\n"
                    },
                    {
                        "username": "reton2008",
                        "content": "I have confusion here, like it says to find the longest prefix so we need to check each and evey character with corresponding array string. than what woud be the output of this test case\n\n`strs = [\"fllfower\",\"fllfow\",\"fllfight\"]`"
                    },
                    {
                        "username": "user8889vy",
                        "content": "check only the prefix that is from the start the output for this would be -> fllf"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html)"
                    },
                    {
                        "username": "pradeep_skywalker",
                        "content": "Hi Guys, \\n\\nWhat is the TC of this solution. I think it\\'s O(N^3). Can you please check?\\n`class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n\\n        d=collections.defaultdict(list)\\n        for i in range(len(strs[0])):\\n            d[strs[0][i]].append(i)\\n        print(d)\\n\\n        ans=\"\"\\n        L=len(strs[0])\\n        l=0\\n        for i in range(1,len(strs)):\\n            ans=\"\"\\n            l=0\\n            for j in range(len(strs[i])):\\n                if j<L:\\n                    if strs[i][j] not in d.keys():\\n                        break\\n                    elif j not in d[strs[i][j]]:\\n                        break\\n                    else:\\n                        ans+=strs[i][j]\\n                        l+=1\\n                        # d[strs[i][j]].remove(j)\\n            L=l\\n            print(ans,L)\\n        return ans`\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "I think it\\'s just N^2"
                    },
                    {
                        "username": "pradeep_selvaraj",
                        "content": "The problem is not clear.\\n\\nBecause for given input [\"reflower\",\"flow\",\"flight\"], its not accepting the answer \"fl\" as longest common prefix ? \\nDid the question mention that either all strings in array have some common prefix or none ?\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "prefix are letters that are added to the begging of the word. So common prefix means the sequence of letters that starts in common. Start, by which means from the beginning. Since the word \\'reflower\\' starts with the letter \\'r\\', those words don\\'t have common prefix.\\nThe question doesn\\'t say that all the elements of an array have common prefix, so we can\\'t suppose that there is neither. \\nWe have to program the function to find whether there is or not, and then, if there is, what is this common prefix."
                    },
                    {
                        "username": "niitk",
                        "content": "my solution is true, but allocation failure, why?"
                    }
                ]
            },
            {
                "id": 1657496,
                "content": [
                    {
                        "username": "mirotvoretts",
                        "content": "How can I improve my code? I dont like my SymbolIsContainedInStringsOnPosition, because it asks for 3 arguments. Suggestions?\n`public class Solution\n{\n    public string FindShortestWord(string[] strs)\n    {\n        var shortestWord = strs[0];\n\n        foreach (var word in strs)\n        {\n            if (word.Length < shortestWord.Length)\n                shortestWord = word;\n        }\n\n        return shortestWord;\n    }\n\n    public bool SymbolIsContainedInStringsOnPosition(char symbol, string[] strings, int position)\n    {\n        for (int i = 0; i < strings.Length; i++)\n        {\n            if (strings[i][position] != symbol)\n                return false;\n        }\n\n        return true;\n    }\n\n    public string LongestCommonPrefix(string[] strs)\n    {\n        var shortestWord = FindShortestWord(strs);\n        var answer = \"\";\n\n        for (int i = 0; i < shortestWord.Length; i++)\n        {\n            if (SymbolIsContainedInStringsOnPosition(shortestWord[i], strs, i))\n                answer += shortestWord[i];\n            else\n                break;\n        }\n\n        return answer;\n    }\n}`"
                    },
                    {
                        "username": "micro9997",
                        "content": "The problem statement is confusing!\\n\\nin C, as input\\n\\nchar strs[][7] = {\"flower\", \"flow\", \"flight\"};    ?\\n\\nor\\n\\nchar strs = \"[\\\\\"flower\\\\\",\\\\\"flow\\\\\",\\\\\"flight\\\\\"]\";    ?\\n"
                    },
                    {
                        "username": "dmartel33",
                        "content": "I saw the vertical scan solution immediately, but struggled with the edge cases. :("
                    },
                    {
                        "username": "acams1803",
                        "content": "guys in one of the test cases the list is [\"cir\",\"car\"] and the PREFIX expected is \"cr\" even though it should be \"c\". I believe I have misunderstood the problem. I would appreciate anyone giving an explanation."
                    },
                    {
                        "username": "Shubham_chauhan981",
                        "content": "Please read carefully the output is your output \\'cr\\' (what your program is producing) and the bottom one is expected \\'c\\' (which leetcode expects from your code)."
                    },
                    {
                        "username": "avishekchakraborty05",
                        "content": "please make the question clear. Here in the question it is asked to find the longest common prefix but not mentioned that whether we have to compare with many prefixes or there will be only one prefix sequence.\\nwhenever I am putting multiple prefixes it is showing me wrong output.\\nThank you\\n"
                    },
                    {
                        "username": "reton2008",
                        "content": "I have confusion here, like it says to find the longest prefix so we need to check each and evey character with corresponding array string. than what woud be the output of this test case\n\n`strs = [\"fllfower\",\"fllfow\",\"fllfight\"]`"
                    },
                    {
                        "username": "user8889vy",
                        "content": "check only the prefix that is from the start the output for this would be -> fllf"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html)"
                    },
                    {
                        "username": "pradeep_skywalker",
                        "content": "Hi Guys, \\n\\nWhat is the TC of this solution. I think it\\'s O(N^3). Can you please check?\\n`class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n\\n        d=collections.defaultdict(list)\\n        for i in range(len(strs[0])):\\n            d[strs[0][i]].append(i)\\n        print(d)\\n\\n        ans=\"\"\\n        L=len(strs[0])\\n        l=0\\n        for i in range(1,len(strs)):\\n            ans=\"\"\\n            l=0\\n            for j in range(len(strs[i])):\\n                if j<L:\\n                    if strs[i][j] not in d.keys():\\n                        break\\n                    elif j not in d[strs[i][j]]:\\n                        break\\n                    else:\\n                        ans+=strs[i][j]\\n                        l+=1\\n                        # d[strs[i][j]].remove(j)\\n            L=l\\n            print(ans,L)\\n        return ans`\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "I think it\\'s just N^2"
                    },
                    {
                        "username": "pradeep_selvaraj",
                        "content": "The problem is not clear.\\n\\nBecause for given input [\"reflower\",\"flow\",\"flight\"], its not accepting the answer \"fl\" as longest common prefix ? \\nDid the question mention that either all strings in array have some common prefix or none ?\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "prefix are letters that are added to the begging of the word. So common prefix means the sequence of letters that starts in common. Start, by which means from the beginning. Since the word \\'reflower\\' starts with the letter \\'r\\', those words don\\'t have common prefix.\\nThe question doesn\\'t say that all the elements of an array have common prefix, so we can\\'t suppose that there is neither. \\nWe have to program the function to find whether there is or not, and then, if there is, what is this common prefix."
                    },
                    {
                        "username": "niitk",
                        "content": "my solution is true, but allocation failure, why?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Flatten Binary Tree to Linked List",
        "question_content": "<p>Given the <code>root</code> of a binary tree, flatten the tree into a &quot;linked list&quot;:</p>\n\n<ul>\n\t<li>The &quot;linked list&quot; should use the same <code>TreeNode</code> class where the <code>right</code> child pointer points to the next node in the list and the <code>left</code> child pointer is always <code>null</code>.</li>\n\t<li>The &quot;linked list&quot; should be in the same order as a <a href=\"https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR\" target=\"_blank\"><strong>pre-order</strong><strong> traversal</strong></a> of the binary tree.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg\" style=\"width: 500px; height: 226px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,5,3,4,null,6]\n<strong>Output:</strong> [1,null,2,null,3,null,4,null,5,null,6]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [0]\n<strong>Output:</strong> [0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Can you flatten the tree in-place (with <code>O(1)</code> extra space)?",
        "solutions": [
            {
                "id": 36977,
                "title": "my-short-post-order-traversal-java-solution-for-share",
                "content": "    private TreeNode prev = null;\\n\\n    public void flatten(TreeNode root) {\\n        if (root == null)\\n            return;\\n        flatten(root.right);\\n        flatten(root.left);\\n        root.right = prev;\\n        root.left = null;\\n        prev = root;\\n    }",
                "solutionTags": [],
                "code": "    private TreeNode prev = null;\\n\\n    public void flatten(TreeNode root) {\\n        if (root == null)\\n            return;\\n        flatten(root.right);\\n        flatten(root.left);\\n        root.right = prev;\\n        root.left = null;\\n        prev = root;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 37010,
                "title": "share-my-simple-non-recursive-solution-o-1-space-complexity",
                "content": "    class Solution {\\n    public:\\n        void flatten(TreeNode *root) {\\n    \\t\\tTreeNode*now = root;\\n    \\t\\twhile (now)\\n    \\t\\t{\\n    \\t\\t\\tif(now->left)\\n    \\t\\t\\t{\\n                    //Find current node's prenode that links to current node's right subtree\\n    \\t\\t\\t\\tTreeNode* pre = now->left;\\n    \\t\\t\\t\\twhile(pre->right)\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\tpre = pre->right;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tpre->right = now->right;\\n                    //Use current node's left subtree to replace its right subtree(original right \\n                    //subtree is already linked by current node's prenode\\n    \\t\\t\\t\\tnow->right = now->left;\\n    \\t\\t\\t\\tnow->left = NULL;\\n    \\t\\t\\t}\\n    \\t\\t\\tnow = now->right;\\n    \\t\\t}\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void flatten(TreeNode *root) {\\n    \\t\\tTreeNode*now = root;\\n    \\t\\twhile (now)\\n    \\t\\t{\\n    \\t\\t\\tif(now->left)\\n    \\t\\t\\t{\\n                    //Find current node's prenode that links to current node's right subtree\\n    \\t\\t\\t\\tTreeNode* pre = now->left;\\n    \\t\\t\\t\\twhile(pre->right)\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\tpre = pre->right;\\n    \\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 37154,
                "title": "8-lines-of-python-solution-reverse-preorder-traversal",
                "content": "    def __init__(self):\\n        self.prev = None\\n        \\n    def flatten(self, root):\\n        if not root:\\n            return None\\n        self.flatten(root.right)\\n        self.flatten(root.left)\\n        \\n        root.right = self.prev\\n        root.left = None\\n        self.prev = root",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def __init__(self):\\n        self.prev = None\\n        \\n    def flatten(self, root):\\n        if not root:\\n            return None\\n        self.flatten(root.right)\\n        self.flatten(root.left)\\n        \\n        root.right = self.prev\\n        root.left = None\\n        self.prev = root",
                "codeTag": "Python3"
            },
            {
                "id": 36987,
                "title": "straightforward-java-solution",
                "content": "    public void flatten(TreeNode root) {\\n            if (root == null) return;\\n            \\n            TreeNode left = root.left;\\n            TreeNode right = root.right;\\n            \\n            root.left = null;\\n            \\n            flatten(left);\\n            flatten(right);\\n            \\n            root.right = left;\\n            TreeNode cur = root;\\n            while (cur.right != null) cur = cur.right;\\n            cur.right = right;\\n        }\\n\\n\\nThis solution is based on recursion. We simply flatten left and right subtree and paste each sublist to the right child of the root. (don't forget to set left child to null)",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public void flatten(TreeNode root) {\\n            if (root == null) return;\\n            \\n            TreeNode left = root.left;\\n            TreeNode right = root.right;\\n            \\n            root.left = null;\\n            \\n            flatten(left);\\n            flatten(right);\\n            \\n            root.right = left;\\n            TreeNode cur = root;\\n            while (cur.right != null) cur = cur.right;\\n            cur.right = right;\\n        }\\n\\n\\nThis solution is based on recursion. We simply flatten left and right subtree and paste each sublist to the right child of the root. (don't forget to set left child to null)",
                "codeTag": "Unknown"
            },
            {
                "id": 37000,
                "title": "8ms-non-recursive-no-stack-c-solution",
                "content": "    void flatten(TreeNode *root) {\\n\\t\\twhile (root) {\\n\\t\\t\\tif (root->left && root->right) {\\n\\t\\t\\t\\tTreeNode* t = root->left;\\n\\t\\t\\t\\twhile (t->right)\\n\\t\\t\\t\\t\\tt = t->right;\\n\\t\\t\\t\\tt->right = root->right;\\n\\t\\t\\t}\\n\\n            if(root->left)\\n\\t\\t\\t    root->right = root->left;\\n\\t\\t\\troot->left = NULL;\\n\\t\\t\\troot = root->right;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "    void flatten(TreeNode *root) {\\n\\t\\twhile (root) {\\n\\t\\t\\tif (root->left && root->right) {\\n\\t\\t\\t\\tTreeNode* t = root->left;\\n\\t\\t\\t\\twhile (t->right)\\n\\t\\t\\t\\t\\tt = t->right;\\n\\t\\t\\t\\tt->right = root->right;\\n\\t\\t\\t}\\n\\n            if(root->left)\\n\\t\\t\\t    root->right = root->left;\\n\\t\\t\\troot->left = NULL;\\n\\t\\t\\troot = root->right;\\n\\t\\t}\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1208004,
                "title": "extremely-intuitive-o-1-space-solution-with-simple-explanation-python",
                "content": "The prospect of solving this problem in O(1) might look tricky in the beginning, but all you need to know is how preorder traversal works. \\nThe key intuition of this solution is to preserve the \"Pre-Order\" order as we go.\\n\\nSo we maintain a pointer `curr` while going down the tree. If `curr` has a left child, we want to shift it to the right while preserving the order. This will be two step process.\\nCreate another pointer `p` to find the right most point in the left subtree. Then we shift the contents of `curr.right` into `p.right`. The tree which we have right now (stage 2 in image) if you notice, still gives the exact same preorder traversal. So now we just shift this to the right of `curr`.\\n\\nMove `curr` to the right and repeat.\\n\\n![image](https://assets.leetcode.com/users/images/1c892c17-ff56-4740-8a81-47f40d38d36e_1620996109.3450835.png)\\n\\n```\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        curr = root\\n        \\n        while curr:\\n            if curr.left != None:\\n                p = curr.left\\n                while p.right != None:\\n                    p = p.right\\n                    \\n                p.right = curr.right\\n                \\n                curr.right = curr.left\\n                curr.left = None\\n            \\n            curr = curr.right\\n ```\\n\\n**PS: This was my first ever solution submission. Please do upvote if you found it helpful and feel free to leave suggestions below.**\\n\\nThanks for stopping by!",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        curr = root\\n        \\n        while curr:\\n            if curr.left != None:\\n                p = curr.left\\n                while p.right != None:\\n                    p = p.right\\n                    \\n                p.right = curr.right\\n                \\n                curr.right = curr.left\\n                curr.left = None\\n            \\n            curr = curr.right\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 36991,
                "title": "accepted-simple-java-solution-iterative",
                "content": "it is DFS so u need a stack. Dont forget to set the left child to null, or u'll get TLE. (tricky!)\\n \\n\\n       public void flatten(TreeNode root) {\\n            if (root == null) return;\\n            Stack<TreeNode> stk = new Stack<TreeNode>();\\n            stk.push(root);\\n            while (!stk.isEmpty()){\\n                TreeNode curr = stk.pop();\\n                if (curr.right!=null)  \\n                     stk.push(curr.right);\\n                if (curr.left!=null)  \\n                     stk.push(curr.left);\\n                if (!stk.isEmpty()) \\n                     curr.right = stk.peek();\\n                curr.left = null;  // dont forget this!! \\n            }\\n        }",
                "solutionTags": [],
                "code": "it is DFS so u need a stack. Dont forget to set the left child to null, or u'll get TLE. (tricky!)\\n \\n\\n       public void flatten(TreeNode root) {\\n            if (root == null) return;\\n            Stack<TreeNode> stk = new Stack<TreeNode>();\\n            stk.push(root);\\n            while (!stk.isEmpty()){\\n                TreeNode curr = stk.pop();\\n                if (curr.right!=null)  \\n                     stk.push(curr.right);\\n                if (curr.left!=null)  \\n                     stk.push(curr.left);\\n                if (!stk.isEmpty()) \\n                     curr.right = stk.peek();\\n                curr.left = null;  // dont forget this!! \\n            }\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1207642,
                "title": "js-python-java-c-simple-o-1-space-recursive-solutions-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\n***Morris Traversal (O(1) Space, O(N) Time) Approach:***\\n\\nThere _is_ actually a way to traverse a binary tree with a **space complexity** of **O(1)** while staying at a **time complexity** of **O(N)**, though it does require modifying the tree\\'s structure. In this problem that\\'s specifically being called for, so it\\'s a valid approach, though it won\\'t always be appropriate to modify the source binary tree in other situations.\\n\\nThe approach is called the **Morris traversal**. At its heart, it takes advantage of the basic nature of ordered traversals to iterate through and unwind the tree. In a **pre-order traversal** of a binary tree, each vertex is processed in **(node, left, right)** order. This means that the entire left subtree could be placed between the node and its right subtree.\\n\\nTo do this, however, we\\'ll first have to locate the last node in the left subtree. This is easy enough, since we know that the last node of a pre-order tree can be found by moving right as many times as possible from its root.\\n\\nSo we should be able to move through the binary tree, keeping track of the curent node (**curr**). Whenever we find a left subtree, we can dispatch a **runner** to find its last node, then stitch together both ends of the left subtree into the right path of **curr**, taking heed to sever the left connection at **curr**.\\n\\nOnce that\\'s done, we can continue to move **curr** to the right, looking for the next left subtree. When **curr** can no longer move right, the tree will be successfully flattened.\\n\\n![Morris Traversal Visual](https://i.imgur.com/sqnrz9m.gif)\\n\\n - _**Time Complexity: O(N)** where **N** is the number of **nodes** in the binary tree_\\n - _**Space Complexity: O(1)**_\\n\\n---\\n\\n***O(1) Space Approach:***\\n\\nIn order to properly connect the **linked list**, we\\'ll need to start at the bottom and work up. This means that we\\'ll need to move in _reverse_ **pre-order traversal** order through the **binary tree**. Since pre-order traversal is normally **\"node, left, right\"**, we\\'ll have to move in the reverse order of **\"right, left, node\"**.\\n\\nIn order to complete this solution in **O(1) space**, we won\\'t be able to conveniently backtrack via a **stack**, so the key to this solution will be to retreat all the way back up to the **root** each time we reach a leaf. This will push the **time complexity** to **O(N^2)**.\\n\\nWe\\'ll want to first set up **head** and **curr** to keep track of the head of the linked list we\\'re building and the current node we\\'re visiting. We\\'ll know we\\'re finished once **head = root**.\\n\\nTo follow the reverse pre-order traversal order, we\\'ll first attempt to go right and then left. Since we\\'re backtracking to **root**, however, we\\'ll eventually run back into the same node that we\\'ve set as **head** doing this. To prevent this, we\\'ll stop _before_ moving to the **head** node and sever the connection.\\n\\nNow that we can\\'t run into already-completed territory, we can be confident that any leaf we move to must be the next value for **head**, so we should connect it to the old **head**, update **head**, and reset back to the **root**.\\n\\nAs noted before, once **head = root**, we\\'ve finished our traversal and can exit the function.\\n\\n - _**Time Complexity: O(N^2)** where **N** is the number of **nodes** in the binary tree, due to repeated backtracking to root_\\n - _**Space Complexity: O(1)**_\\n\\n---\\n\\n***Recursive Approach:***\\n\\nIn order to properly connect the **linked list**, we\\'ll need to start at the bottom and work up. This means that we\\'ll need to move in _reverse_ **pre-order traversal** order through the **binary tree**. Since pre-order traversal is normally **\"node, left, right\"**, we\\'ll have to move in the reverse order of **\"right, left, node\"**.\\n\\nBinary tree traversal is prime ground for a **recursive** solution, so let\\'s define a helper (**revPreOrder**) for the purpose. We\\'ll also keep a global variable **head** to keep track of the head of the linked list as we work our way backwards.\\n\\nPer our reverse pre-order traversal approach, we want to recursively work down the right path first then the left path, if they exist. Once we\\'ve flattened the left and right paths recursively, **head** should at this point be equal to the next node after the current one, so we should set it as **node.right**. We shouldn\\'t forget to set **node.left** to **null**, as well.\\n\\nOnce we\\'re done with the current node, we can update **head** to **node** and allow the recursion to complete and move back up to the next layer. Once the recursion stack is exhausted, **head** will be equal to **root** again.\\n\\nLastly, we have to deal with an edge case of an empty **root**, so we can just make sure to only call the initial recursion on **root** if **root** actually is a node. There is no need for a **return** statement, because the test suite will evaluate **root** directly.\\n\\n - _**Time Complexity: O(N)** where **N** is the number of **nodes** in the binary tree_\\n - _**Space Complexity: O(N)** for the **recursion stack**, which is as long as the maximum depth of the binary tree, which can go up to **N**_\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\n##### ***w/ Morris Traversal:***\\n\\nThe best result for the code below is **84ms / 40.6MB** (beats 96% / 66%).\\n```javascript\\nvar flatten = function(root) {\\n    let curr = root\\n    while (curr) {\\n        if (curr.left) {\\n            let runner = curr.left\\n            while (runner.right) runner = runner.right\\n            runner.right = curr.right, curr.right = curr.left, curr.left = null\\n        }\\n        curr = curr.right\\n    }\\n};\\n```\\n\\n##### ***w/ O(1) Space:***\\n\\nThe best result for the code below is **80ms / 40.6MB** (beats 98% / 66%).\\n```javascript\\nvar flatten = function(root) {\\n    let head = null, curr = root\\n    while (head != root) {\\n        if (curr.right === head) curr.right = null\\n        if (curr.left === head) curr.left = null\\n        if (curr.right) curr = curr.right\\n        else if (curr.left) curr = curr.left\\n        else curr.right = head, head = curr, curr = root\\n    }\\n};\\n```\\n\\n##### ***w/ Recursion:***\\n\\nThe best result for the code below is **84ms / 40.6MB** (beats 96% / 66%).\\n```javascript\\nvar flatten = function(root) {\\n    let head = null\\n    const revPreOrder = node => {\\n        if (node.right) revPreOrder(node.right)\\n        if (node.left) revPreOrder(node.left)\\n        node.left = null, node.right = head, head = node\\n    }\\n    if (root) revPreOrder(root)\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\n##### ***w/ Morris Traversal:***\\n\\nThe best result for the code below is **32ms / 15.0MB** (beats 92% / 91%).\\n```python\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        curr = root\\n        while curr:\\n            if curr.left:\\n                runner = curr.left\\n                while runner.right: runner = runner.right\\n                runner.right, curr.right, curr.left = curr.right, curr.left, None\\n            curr = curr.right\\n```\\n\\n##### ***w/ O(1) Space:***\\n\\nThe best result for the code below is **32ms / 15.0MB** (beats 92% / 91%).\\n```\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        head, curr = None, root\\n        while head != root:\\n            if curr.right == head: curr.right = None\\n            if curr.left == head: curr.left = None\\n            if curr.right: curr = curr.right\\n            elif curr.left: curr = curr.left\\n            else: curr.right, head, curr = head, curr, root\\n```\\n\\n##### ***w/ Recursion:***\\n\\nThe best result for the code below is **28ms / 14.9MB** (beats 98% / 98%).\\n```python\\nclass Solution:\\n    head = None\\n    def flatten(self, root: TreeNode) -> None:\\n        def revPreOrder(node: TreeNode) -> None:\\n            if node.right: revPreOrder(node.right)\\n            if node.left: revPreOrder(node.left)\\n            node.left, node.right, self.head = None, self.head, node\\n        if root: revPreOrder(root)\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\n##### ***w/ Morris Traversal:***\\n\\nThe best result for the code below is **0ms / 37.9MB** (beats 100% / 98%).\\n```java\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        TreeNode curr = root;\\n        while (curr != null) {\\n            if (curr.left != null) {\\n                TreeNode runner = curr.left;\\n                while (runner.right != null) runner = runner.right;\\n                runner.right = curr.right;\\n                curr.right = curr.left;\\n                curr.left = null;\\n            }\\n            curr = curr.right;\\n        }\\n    }\\n}\\n```\\n\\n##### ***w/ O(1) Space:***\\n\\nThe best result for the code below is **0ms / 37.9MB** (beats 100% / 98%).\\n```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        TreeNode head = null, curr = root;\\n        while (head != root) {\\n            if (curr.right == head) curr.right = null;\\n            if (curr.left == head) curr.left = null;\\n            if (curr.right != null) curr = curr.right;\\n            else if (curr.left != null) curr = curr.left;\\n            else {\\n                curr.right = head;\\n                head = curr;\\n                curr = root;\\n            }\\n        }\\n    }\\n}\\n```\\n\\n##### ***w/ Recursion:***\\n\\nThe best result for the code below is **0ms / 38.0MB** (beats 100% / 98%).\\n```java\\nclass Solution {\\n    TreeNode head = null;\\n    public void flatten(TreeNode root) {\\n        if (root != null) revPreOrder(root);\\n    }\\n    private void revPreOrder(TreeNode node) {\\n        if (node.right != null) revPreOrder(node.right);\\n        if (node.left != null) revPreOrder(node.left);\\n        node.left = null;\\n        node.right = head;\\n        head = node;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\n##### ***w/ Morris Traversal:***\\n\\nThe best result for the code below is **0ms / 12.6MB** (beats 100% / 95%).\\n```c++\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while (curr) {\\n            if (curr->left) {\\n                TreeNode* runner = curr->left;\\n                while (runner->right != nullptr) runner = runner->right;\\n                runner->right = curr->right, curr->right = curr->left, curr->left = nullptr;\\n            }\\n            curr = curr->right;\\n        }\\n    }\\n};\\n```\\n\\n##### ***w/ O(1) Space:***\\n\\nThe best result for the code below is **0ms / 12.6MB** (beats 100% / 95%).\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode *head = nullptr, *curr = root;\\n        while (head != root) {\\n            if (curr->right == head) curr->right = nullptr;\\n            if (curr->left == head) curr->left = nullptr;\\n            if (curr->right) curr = curr->right;\\n            else if (curr->left) curr = curr->left;\\n            else curr->right = head, head = curr, curr = root;\\n        }\\n    }\\n};\\n```\\n\\n##### ***w/ Recursion:***\\n\\nThe best result for the code below is **0ms / 12.6MB** (beats 100% / 95%).\\n```c++\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if (root) revPreOrder(root);\\n    }\\nprivate:\\n    TreeNode* head = nullptr;\\n    void revPreOrder(TreeNode* node) {\\n        if (node->right) revPreOrder(node->right);\\n        if (node->left) revPreOrder(node->left);\\n        node->left = nullptr, node->right = head, head = node;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar flatten = function(root) {\\n    let curr = root\\n    while (curr) {\\n        if (curr.left) {\\n            let runner = curr.left\\n            while (runner.right) runner = runner.right\\n            runner.right = curr.right, curr.right = curr.left, curr.left = null\\n        }\\n        curr = curr.right\\n    }\\n};\\n```\n```javascript\\nvar flatten = function(root) {\\n    let head = null, curr = root\\n    while (head != root) {\\n        if (curr.right === head) curr.right = null\\n        if (curr.left === head) curr.left = null\\n        if (curr.right) curr = curr.right\\n        else if (curr.left) curr = curr.left\\n        else curr.right = head, head = curr, curr = root\\n    }\\n};\\n```\n```javascript\\nvar flatten = function(root) {\\n    let head = null\\n    const revPreOrder = node => {\\n        if (node.right) revPreOrder(node.right)\\n        if (node.left) revPreOrder(node.left)\\n        node.left = null, node.right = head, head = node\\n    }\\n    if (root) revPreOrder(root)\\n};\\n```\n```python\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        curr = root\\n        while curr:\\n            if curr.left:\\n                runner = curr.left\\n                while runner.right: runner = runner.right\\n                runner.right, curr.right, curr.left = curr.right, curr.left, None\\n            curr = curr.right\\n```\n```\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        head, curr = None, root\\n        while head != root:\\n            if curr.right == head: curr.right = None\\n            if curr.left == head: curr.left = None\\n            if curr.right: curr = curr.right\\n            elif curr.left: curr = curr.left\\n            else: curr.right, head, curr = head, curr, root\\n```\n```python\\nclass Solution:\\n    head = None\\n    def flatten(self, root: TreeNode) -> None:\\n        def revPreOrder(node: TreeNode) -> None:\\n            if node.right: revPreOrder(node.right)\\n            if node.left: revPreOrder(node.left)\\n            node.left, node.right, self.head = None, self.head, node\\n        if root: revPreOrder(root)\\n```\n```java\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        TreeNode curr = root;\\n        while (curr != null) {\\n            if (curr.left != null) {\\n                TreeNode runner = curr.left;\\n                while (runner.right != null) runner = runner.right;\\n                runner.right = curr.right;\\n                curr.right = curr.left;\\n                curr.left = null;\\n            }\\n            curr = curr.right;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        TreeNode head = null, curr = root;\\n        while (head != root) {\\n            if (curr.right == head) curr.right = null;\\n            if (curr.left == head) curr.left = null;\\n            if (curr.right != null) curr = curr.right;\\n            else if (curr.left != null) curr = curr.left;\\n            else {\\n                curr.right = head;\\n                head = curr;\\n                curr = root;\\n            }\\n        }\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    TreeNode head = null;\\n    public void flatten(TreeNode root) {\\n        if (root != null) revPreOrder(root);\\n    }\\n    private void revPreOrder(TreeNode node) {\\n        if (node.right != null) revPreOrder(node.right);\\n        if (node.left != null) revPreOrder(node.left);\\n        node.left = null;\\n        node.right = head;\\n        head = node;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while (curr) {\\n            if (curr->left) {\\n                TreeNode* runner = curr->left;\\n                while (runner->right != nullptr) runner = runner->right;\\n                runner->right = curr->right, curr->right = curr->left, curr->left = nullptr;\\n            }\\n            curr = curr->right;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode *head = nullptr, *curr = root;\\n        while (head != root) {\\n            if (curr->right == head) curr->right = nullptr;\\n            if (curr->left == head) curr->left = nullptr;\\n            if (curr->right) curr = curr->right;\\n            else if (curr->left) curr = curr->left;\\n            else curr->right = head, head = curr, curr = root;\\n        }\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if (root) revPreOrder(root);\\n    }\\nprivate:\\n    TreeNode* head = nullptr;\\n    void revPreOrder(TreeNode* node) {\\n        if (node->right) revPreOrder(node->right);\\n        if (node->left) revPreOrder(node->left);\\n        node->left = nullptr, node->right = head, head = node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2338791,
                "title": "c-explained",
                "content": "**UPVOTE IF HELPFuuL**\\n\\n**APPROACH -> O ( N ) SPACE**\\nBy using brute force, we can traverse the tree in ```preorder manner``` and store the result in a vector.\\nLater using that vector , we can arrange nodes, such as \\n```\\nvector[i] -> right = vector[i+1];\\nvector[i] -> left = NULL;\\n```\\n\\n**APPROACH -> O ( 1 ) SPACE**\\n\\n* From the diagram given , it can be seen all nodes are present on the right.\\n* All the nodes in ```left subtree``` come before the nodes in ```right subtree```.\\n\\n**For each node ```i```**\\n* IF there is no left node  -> move to next right node.\\n* IF **LEFT IS PRESENT**  ->\\n* * Store the right subtree\\n* * ADD left subtree to right of root,\\n* * Now add the stored right subtree to the rightmost node of current tree.\\n* Also make ```node -> left =NULL```.\\n\\n![image](https://assets.leetcode.com/users/images/e6d4b1fa-b7ec-4056-a6ba-27a8fb5ea60b_1658887502.7798896.png)\\n\\n\\n**UPVOTE IF HELPFuuL**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* rightmost(TreeNode* root){\\n        if (root->right==NULL) return root;\\n        return rightmost(root->right);\\n    }\\n    \\n    void flatten(TreeNode* root) {\\n        if (root==NULL) return;\\n        TreeNode* nextright;\\n        TreeNode* rightMOST;\\n        \\n        while (root){\\n            \\n            if (root->left){\\n                rightMOST = rightmost(root->left);\\n                nextright = root->right;\\n                root->right = root->left;\\n                root->left=NULL;\\n                rightMOST->right=nextright;\\n            }\\n            root=root->right;\\n        }\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/d3c7d6b7-7333-4f6f-8630-54539795ee1f_1658886001.4640927.jpeg)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```preorder manner```\n```\\nvector[i] -> right = vector[i+1];\\nvector[i] -> left = NULL;\\n```\n```left subtree```\n```right subtree```\n```i```\n```node -> left =NULL```\n```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* rightmost(TreeNode* root){\\n        if (root->right==NULL) return root;\\n        return rightmost(root->right);\\n    }\\n    \\n    void flatten(TreeNode* root) {\\n        if (root==NULL) return;\\n        TreeNode* nextright;\\n        TreeNode* rightMOST;\\n        \\n        while (root){\\n            \\n            if (root->left){\\n                rightMOST = rightmost(root->left);\\n                nextright = root->right;\\n                root->right = root->left;\\n                root->left=NULL;\\n                rightMOST->right=nextright;\\n            }\\n            root=root->right;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 288414,
                "title": "c-solution-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if( root )\\n        {\\n            /*Move the left node to the right node*/\\n            TreeNode* temp = root->right;\\n            root->right = root->left;\\n            root->left = nullptr;\\n            TreeNode* node = root;\\n            \\n            /*Move to the end of the prev left node which is the new right node*/\\n            while( node->right )\\n            {\\n                node = node->right;\\n            }\\n            \\n            /*Append the right node to its end*/\\n            node->right = temp;\\n            flatten( root->right ); \\n        } \\n        return;\\n               \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if( root )\\n        {\\n            /*Move the left node to the right node*/\\n            TreeNode* temp = root->right;\\n            root->right = root->left;\\n            root->left = nullptr;\\n            TreeNode* node = root;\\n            \\n            /*Move to the end of the prev left node which is the new right node*/\\n            while( node->right )\\n            {\\n                node = node->right;\\n            }\\n            \\n            /*Append the right node to its end*/\\n            node->right = temp;\\n            flatten( root->right ); \\n        } \\n        return;\\n               \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37223,
                "title": "share-my-accepted-recursive-solution-with-comments-java",
                "content": "The idea is very simple:\\n\\n1. flatten left subtree\\n\\n2. flatten right subtree\\n\\n3. concatenate root -> left flatten subtree -> right flatten subtree\\n\\n        public void flatten(TreeNode root) {\\n            if(root == null)\\n        \\treturn;\\n        \\t\\n            flatten(root.left);\\n            flatten(root.right);\\n        \\n            // save current right for concatination\\n            TreeNode right = root.right;\\n        \\n            if(root.left != null) {\\n            \\n                // step 1: concatinate root with left flatten subtree\\n            \\troot.right = root.left;\\n            \\troot.left = null; // set left to null\\n        \\t\\n            \\t// step 2: move to the end of new added flatten subtree\\n            \\twhile(root.right != null)\\n            \\t\\troot = root.right;\\n        \\t\\t\\n            \\t// step 3: contatinate left flatten subtree with flatten right subtree\\t\\n            \\troot.right = right;\\n            }\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "The idea is very simple:\\n\\n1. flatten left subtree\\n\\n2. flatten right subtree\\n\\n3. concatenate root -> left flatten subtree -> right flatten subtree\\n\\n        public void flatten(TreeNode root) {\\n            if(root == null)\\n        \\treturn;\\n        \\t\\n            flatten(root.left);\\n            flatten(root.right);\\n        \\n            // save current right for concatination\\n            TreeNode right = root.right;\\n        \\n            if(root.left != null) {\\n            \\n                // step 1: concatinate root with left flatten subtree\\n            \\troot.right = root.left;\\n            \\troot.left = null; // set left to null\\n        \\t\\n            \\t// step 2: move to the end of new added flatten subtree\\n            \\twhile(root.right != null)\\n            \\t\\troot = root.right;\\n        \\t\\t\\n            \\t// step 3: contatinate left flatten subtree with flatten right subtree\\t\\n            \\troot.right = right;\\n            }\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 37182,
                "title": "my-recursive-solution-is-easy-and-clean",
                "content": "    void flatten(TreeNode* root) {\\n        if (!root) return;\\n        flatten(root->left);\\n        flatten(root->right);\\n        TreeNode *tmp = root->right;\\n        root->right = root->left;\\n        root->left = nullptr;\\n        while (root->right)\\n            root = root->right;\\n        root->right = tmp;\\n    }",
                "solutionTags": [],
                "code": "    void flatten(TreeNode* root) {\\n        if (!root) return;\\n        flatten(root->left);\\n        flatten(root->right);\\n        TreeNode *tmp = root->right;\\n        root->right = root->left;\\n        root->left = nullptr;\\n        while (root->right)\\n            root = root->right;\\n        root->right = tmp;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 36984,
                "title": "an-inorder-python-solution",
                "content": "    class Solution:\\n    # @param root, a tree node\\n    # @return nothing, do it in place\\n    prev = None\\n    def flatten(self, root):\\n        if not root:\\n            return\\n        self.prev = root\\n        self.flatten(root.left)\\n\\n        temp = root.right\\n        root.right, root.left = root.left, None\\n        self.prev.right = temp\\n\\n        self.flatten(temp)\\n\\n\\n\\n             *\\n           /\\n          n\\n       /     \\\\\\n     left   right\\n      \\\\ \\n       *\\n        *\\n         \\\\\\n          p\\n\\n\\nThe idea is very simple. Suppose n is the current visiting node, and p is the previous node of preorder traversal to n.right.\\n\\nWe just need to do the inorder replacement:\\n\\nn.left -> NULL\\n\\nn.right - > n.left\\n\\np->right -> n.right",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n    # @param root, a tree node\\n    # @return nothing, do it in place\\n    prev = None\\n    def flatten(self, root):\\n        if not root:\\n            return\\n        self.prev = root\\n        self.flatten(root.left)\\n\\n        temp = root.right\\n        root.right, root.left = root.left, None\\n        self.prev.right = temp\\n\\n        self.flatten(temp)\\n\\n\\n\\n             *\\n           /\\n          n\\n       /     \\\\\\n     left   right\\n      \\\\ \\n       *\\n        *\\n         \\\\\\n          p\\n\\n\\nThe idea is very simple. Suppose n is the current visiting node, and p is the previous node of preorder traversal to n.right.\\n\\nWe just need to do the inorder replacement:\\n\\nn.left -> NULL\\n\\nn.right - > n.left\\n\\np->right -> n.right",
                "codeTag": "Java"
            },
            {
                "id": 2338861,
                "title": "java-easy-solution-with-explanation",
                "content": "PLEASE UPVOTE IF YOU LIKE\\n```\\nclass Solution {\\n    TreeNode prev=null;\\n    public void flatten(TreeNode root) {\\n         if(root==null)\\n            return;\\n        flatten(root.right);//traverse till right most.\\n        flatten(root.left);//got to left of right most\\n       root.left=null;//set left as null\\n        root.right=prev;//set right to previously traversed node\\n        prev=root;  //set prev to current node.\\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode prev=null;\\n    public void flatten(TreeNode root) {\\n         if(root==null)\\n            return;\\n        flatten(root.right);//traverse till right most.\\n        flatten(root.left);//got to left of right most\\n       root.left=null;//set left as null\\n        root.right=prev;//set right to previously traversed node\\n        prev=root;  //set prev to current node.\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37065,
                "title": "simple-dfs-python-solution",
                "content": "'''\\n\\n    def flatten(self, root):\\n        last=TreeNode(-1)\\n        qstack=[root]\\n        while qstack:\\n            node=qstack.pop()\\n            last.right=node\\n            last.left=None\\n            if node and node.right:\\n                qstack.append(node.right)\\n            if node and node.left:\\n                qstack.append(node.left)\\n            last=node\\n        '''",
                "solutionTags": [],
                "code": "'''\\n\\n    def flatten(self, root):\\n        last=TreeNode(-1)\\n        qstack=[root]\\n        while qstack:\\n            node=qstack.pop()\\n            last.right=node\\n            last.left=None\\n            if node and node.right:\\n                qstack.append(node.right)\\n            if node and node.left:\\n                qstack.append(node.left)\\n            last=node\\n        '''",
                "codeTag": "Python3"
            },
            {
                "id": 1067000,
                "title": "c-both-recursive-iterative-solution",
                "content": "**Recursive Solution**\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root == NULL){\\n            return;\\n        }\\n        flatten(root->left);\\n        flatten(root->right);\\n        if(root->left){\\n            TreeNode *right = root->right;\\n            root->right = root->left;\\n            root->left = NULL;\\n            while(root->right) root = root->right;\\n            root->right = right;\\n        }\\n    }\\n};\\n```\\n**Iterative Solution (Concept of Morris  Treversal)**\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root == NULL){\\n            return;\\n        }\\n        TreeNode *curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode *pre = curr->left;\\n                while(pre->right){\\n                    pre = pre->right;\\n                }\\n                pre->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n            }\\n            curr = curr->right;\\n        }\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root == NULL){\\n            return;\\n        }\\n        flatten(root->left);\\n        flatten(root->right);\\n        if(root->left){\\n            TreeNode *right = root->right;\\n            root->right = root->left;\\n            root->left = NULL;\\n            while(root->right) root = root->right;\\n            root->right = right;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root == NULL){\\n            return;\\n        }\\n        TreeNode *curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode *pre = curr->left;\\n                while(pre->right){\\n                    pre = pre->right;\\n                }\\n                pre->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n            }\\n            curr = curr->right;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37185,
                "title": "c-solution-using-recursion",
                "content": "Recursively add the left subtree to the right subtree.\\n\\n    class Solution {\\n    public:\\n        void flatten(TreeNode* root) {\\n            if (!root) return;\\n            flatten(root->left);\\n            flatten(root->right);\\n            if (root->left) {\\n                TreeNode* right = root->right;\\n                root->right = root->left;\\n                root->left = NULL;\\n                while (root->right) root = root->right;\\n                root->right = right;\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        void flatten(TreeNode* root) {\\n            if (!root) return;\\n            flatten(root->left);\\n            flatten(root->right);\\n            if (root->left) {\\n                TreeNode* right = root->right;\\n                root->right = root->left;\\n                root->left = NULL;\\n                while (root->right) root = root->right;\\n                root->right = right;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2338948,
                "title": "explanation-so-far",
                "content": "How\\'s going **Ladies-N-Gentlemen** today we are going to solve another super question i.e. **`Flatten Binary Tree to LinkedList`**\\n\\nWell, if you look at the question, you\\'ll see that the **Linked List** has to be in **`preorder Traversal`**\\n\\nSo, if you know what **preorder** is then, you are good to go. A quick recap about preorder is, First we traverse to it\\'s **`root`** then **`left`** and then **`right`** \\n\\n**Let\\'s take an example to understand it.**\\n```\\nInput: root = [1,2,5,3,4,null,6]\\nOutput: [1,null,2,null,3,null,4,null,5,null,6]\\n```\\n![image](https://assets.leetcode.com/users/images/6cfa9324-7354-462a-945b-b56fc7bb1234_1658888844.9633684.png)\\n\\nNow, you have got the idea, let\\'s see how we can solve this problem,\\n```\\nThe first method We gonna use is # RECURSION\\n```\\nSo, let\\'s take a very small example to understand it.\\n![image](https://assets.leetcode.com/users/images/6e1ce458-d168-4612-9633-75d0602fe5e3_1658889692.5058572.png)\\n\\nThis is about the smaller tree of 3 nodes, but what if we are given a **bigger tree??**\\n\\n```\\nSo, for that one what we gonna do is, instead of removing and attaching every single time, we gonna have 2 trees\\n> Left temporary tree\\n> Right temporary tree\\nAnd we gonna flatten these 2 trees and attach to right. \\nTo flatten them we gonna use the help of recursion.\\n```\\nNow let\\'s see what new steps would be.\\n1.  We\\'ll take `temp variable` to store **left** & **right** node.\\n\\n\\n2.  Then, **left** will be point to **null**.\\n3. Now, after this we going to `flatten left & right tree` **(recursively)**\\n4.  After this we attach **left part** to **right** side\\n5.  In the last we gonna traverse the bottom most node in the attached part and attached the right it. \\n\\n```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        if(root == null) return;\\n        // step-1\\n        TreeNode Left = root.left;\\n        TreeNode Right = root.right;\\n\\t\\t\\n        // step-2\\n        root.left = null;\\n\\t\\t\\n        // step-3\\n        flatten(Left);\\n        flatten(Right);\\n        root.right = Left;\\n        TreeNode curr = root;\\n\\t\\t\\n        // step-4\\n        while(curr.right != null) curr = curr.right;\\n\\t\\t\\n        // step-5\\n        curr.right = Right;\\n    }\\n}\\n```\\nANALYSIS:-\\n* **Time Complexity :-** **`BigO(N^2)`**\\n\\n\\n* **Space Complexity :-** **`BigO(height)`**\\n\\n<hr>\\n<hr>\\n\\nNow, let\\'s talk about how we gonna reduce the space to **`O(1)`** as given in the question. To do that we gonna use,\\n```\\n# Morris Traversal\\n```\\n\\n<hr>\\n<hr>\\n\\n**To, understand this let\\'s take an example,**\\n![image](https://assets.leetcode.com/users/images/eee65480-fea1-4079-85a9-6c6de8dc42eb_1658891178.0858386.png)\\n\\n```\\n> So, in this we start from root.\\n> Then we check if it\\'s left doesn\\'t pointing to null, then go to it\\'s right most node and attach it\\'s right to become the root of my tree\\n> Let\\'s see what I\\'m talking about.\\n```\\n![image](https://assets.leetcode.com/users/images/5c630b01-605f-4bc0-a983-5b6f4d02e23a_1658891493.5801342.png)\\n\\nSo, as you can see now if I traverse the tree from **`1-->2-->3-->4-->5-->6`** as you can see now, after **4** am not going back again to **1** as my **4** node is pointing to **5**, so that\\'s how we are not using any extra space\\n\\n```\\n> After doing that, I\\'ll remove the root pointer and left of my root becomes null & right of my root will become this left tree.\\n> Let\\'s see how\\'s it goes like,\\n```\\n![image](https://assets.leetcode.com/users/images/1e74a472-93bd-49f4-8b2d-ae6e45d8ce29_1658891790.6077545.png)\\n\\n```\\nNow, again we going to repeat the same process,\\n> Check left,\\n> If not null, go to it\\'s right most child\\n> Connect it root to right\\n> Connect the whole left to root->right\\n> Make root->left = null\\n> Update root to root->right\\n```\\n![image](https://assets.leetcode.com/users/images/46b58209-89b5-48c1-a069-3f2b3f3681f0_1658892258.929328.png)\\n\\n**Now as you can see our tree has all the nodes on it\\'s right, now flatten this out and look:**\\n\\n![image](https://assets.leetcode.com/users/images/2078deee-9324-48f6-b0c3-c9ba9bf7bcde_1658892492.4848144.png)\\n```\\nAnd we\\'ll complete the process till the end, although \"3\" doesn\\'t have it\\'s left but we still go to it\\'s right and complete the process till the end. \\n```\\n\\n**Now. let\\'s code it up:-**\\n\\n```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        if(root == null) return;\\n        while(root != null){\\n            if(root.left != null) {\\n                TreeNode Left = root.left;\\n                TreeNode curr = Left;\\n                while(curr.right != null) curr = curr.right;\\n                curr.right = root.right;  // Morris Traversal main step\\n                root.left =null;\\n                root.right = Left;\\n            }\\n            root = root.right;  \\n        }\\n    }\\n}\\n```\\nANALYSIS :-\\n* **Time Complexity :-** **`BigO(N)`**\\n\\n* **Space Complexity :-** **`BigO(1)`**",
                "solutionTags": [],
                "code": "```\\nInput: root = [1,2,5,3,4,null,6]\\nOutput: [1,null,2,null,3,null,4,null,5,null,6]\\n```\n```\\nThe first method We gonna use is # RECURSION\\n```\n```\\nSo, for that one what we gonna do is, instead of removing and attaching every single time, we gonna have 2 trees\\n> Left temporary tree\\n> Right temporary tree\\nAnd we gonna flatten these 2 trees and attach to right. \\nTo flatten them we gonna use the help of recursion.\\n```\n```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        if(root == null) return;\\n        // step-1\\n        TreeNode Left = root.left;\\n        TreeNode Right = root.right;\\n\\t\\t\\n        // step-2\\n        root.left = null;\\n\\t\\t\\n        // step-3\\n        flatten(Left);\\n        flatten(Right);\\n        root.right = Left;\\n        TreeNode curr = root;\\n\\t\\t\\n        // step-4\\n        while(curr.right != null) curr = curr.right;\\n\\t\\t\\n        // step-5\\n        curr.right = Right;\\n    }\\n}\\n```\n```\\n# Morris Traversal\\n```\n```\\n> So, in this we start from root.\\n> Then we check if it\\'s left doesn\\'t pointing to null, then go to it\\'s right most node and attach it\\'s right to become the root of my tree\\n> Let\\'s see what I\\'m talking about.\\n```\n```\\n> After doing that, I\\'ll remove the root pointer and left of my root becomes null & right of my root will become this left tree.\\n> Let\\'s see how\\'s it goes like,\\n```\n```\\nNow, again we going to repeat the same process,\\n> Check left,\\n> If not null, go to it\\'s right most child\\n> Connect it root to right\\n> Connect the whole left to root->right\\n> Make root->left = null\\n> Update root to root->right\\n```\n```\\nAnd we\\'ll complete the process till the end, although \"3\" doesn\\'t have it\\'s left but we still go to it\\'s right and complete the process till the end. \\n```\n```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        if(root == null) return;\\n        while(root != null){\\n            if(root.left != null) {\\n                TreeNode Left = root.left;\\n                TreeNode curr = Left;\\n                while(curr.right != null) curr = curr.right;\\n                curr.right = root.right;  // Morris Traversal main step\\n                root.left =null;\\n                root.right = Left;\\n            }\\n            root = root.right;  \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37181,
                "title": "easy-1ms-java-dfs-solution",
                "content": "     public class Solution {\\n        public void flatten(TreeNode root) {\\n            if(root==null)\\n                return;\\n            flatten(root.left);\\n            flatten(root.right);\\n            TreeNode left  = root.left;\\n            TreeNode right = root.right;\\n            root.left  = null;\\n            root.right = left; \\n            while(root.right!=null)\\n                root = root.right;\\n            root.right = right;\\n        }\\n    \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void flatten(TreeNode root) {\\n            if(root==null)\\n                return;\\n            flatten(root.left);\\n            flatten(root.right);\\n            TreeNode left  = root.left;\\n            TreeNode right = root.right;\\n            root.left  = null;\\n            root.right = left; \\n            while(root.right!=null)\\n                root = root.right;\\n            root.right = right;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 37227,
                "title": "python-easy-to-understand-recursive-solution-with-explaination",
                "content": "We can solve this problem recursively, suppose we already flattened the left part of the root, then we need set it as the right child of the root (the previous right child of the root should be preserved first by using a temp variable before this operation), after that, the previous right child is connected to the right most of the flattened left child. Don't forget to set the left child of root to None after these operations.\\n\\n    def flatten(self, root):\\n        while root:\\n            if root.left:\\n                self.flatten(root.left)\\n                node1 = root.left\\n                while node1.right:\\n                    node1 = node1.right\\n                node2 = root.right\\n                root.right = root.left\\n                root.left = None\\n                node1.right = node2\\n            root = root.right",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "We can solve this problem recursively, suppose we already flattened the left part of the root, then we need set it as the right child of the root (the previous right child of the root should be preserved first by using a temp variable before this operation), after that, the previous right child is connected to the right most of the flattened left child. Don't forget to set the left child of root to None after these operations.\\n\\n    def flatten(self, root):\\n        while root:\\n            if root.left:\\n                self.flatten(root.left)\\n                node1 = root.left\\n                while node1.right:\\n                    node1 = node1.right\\n                node2 = root.right\\n                root.right = root.left\\n                root.left = None\\n                node1.right = node2\\n            root = root.right",
                "codeTag": "Python3"
            },
            {
                "id": 2340103,
                "title": "two-different-approaches-faster-than-100-with-detailed-explanation-java",
                "content": "**Approach 1 - Intuition** \\n\\nIf we look at the flattened binary tree closely, we\\'ll notice that if we traverse it in the reverse way `[6 -> 5 -> 4 -> 3 -> 2 -> 1]`, it\\'s actually in `(right -> left -> root)` order.\\nThus, we\\'ll traverse the tree in the above order and set each node\\'s right pointer to the previous node we encountered and set the left pointer to null. \\n\\nFor keeping track of the previous node during recursion, rather than having a global variable we\\'ll create a helper function `flattenHelper` and keep an extra argument `prev`.\\n\\n**Pro interview tip: Try to avoid global variables as much as possible!**\\n\\nNow, let\\'s look at the code.\\n\\n```\\n/*\\n    Recursive Solution\\n    ------------------\\n    Time complexity: O(N)\\n    Space complexity: O(N) -> Stack space\\n*/\\n\\nclass Solution {\\n    public TreeNode flattenHelper(TreeNode root, TreeNode prev) {\\n        // base case\\n        if (root == null)\\n            return prev;\\n        \\n        // hypothesis step\\n        TreeNode right = flattenHelper(root.right, prev);\\n\\t\\t// for left subtree prev would be the node that we get from the right subtree recursion\\n        TreeNode left = flattenHelper(root.left, right);\\n        \\n        // induction step\\n        root.right = left;\\n        root.left = null;\\n        \\n        return root;\\n    }\\n    \\n    public void flatten(TreeNode root) {\\n        flattenHelper(root, null);\\n    }\\n}\\n```\\n\\n`Now, while doing a dry run of the above solution, I noticed we\\'re actually connecting the rightmost child of left subtree to root.right.\\nThis led me to my next solution which takes O(1) space i.e it\\'s truly inplace.\\n`\\n\\n**Approach 2 - Intuition**\\n\\nThe essence of this solution is that we somehow need to make sure that we keep the preorder traversal intact. To achieve this we\\'ll do the following things:\\n1. If the *left child* exists, we\\'ll find the *rightmost* node in the *left subtree*\\n2. We\\'ll connect this *rightmost* node to *root.right* \\n3. Now, move the *left subtree* to the *right* and set *root.left = null*\\n\\nCheck out the below image for better understanding.\\n![image](https://assets.leetcode.com/users/images/754eb32a-60b8-4621-a10e-8baf46c5a035_1658904185.3068984.jpeg)\\n\\n```\\n/*\\n    Iterative Solution - Inplace\\n    ----------------------------\\n    Time complexity: O(N)\\n    Space complexity: O(1)\\n*/\\n\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        while (root != null) {\\n            if (root.left != null) {\\n                TreeNode prev = root.left;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Find the rightmost node in left subtree\\n                while (prev.right != null)\\n                    prev = prev.right;\\n                \\n                prev.right = root.right;\\n                root.right = root.left;\\n                root.left = null;\\n            }\\n            \\n            root = root.right;\\n        }\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/d79c690d-c55e-45f1-9da9-8b94e0481ba2_1658909740.5143886.png)\\n\\n\\n**Thank you for reading, do UPVOTE if you like ~(^-^)~.\\nIf you have any questions, feel free to ask.**",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\n/*\\n    Recursive Solution\\n    ------------------\\n    Time complexity: O(N)\\n    Space complexity: O(N) -> Stack space\\n*/\\n\\nclass Solution {\\n    public TreeNode flattenHelper(TreeNode root, TreeNode prev) {\\n        // base case\\n        if (root == null)\\n            return prev;\\n        \\n        // hypothesis step\\n        TreeNode right = flattenHelper(root.right, prev);\\n\\t\\t// for left subtree prev would be the node that we get from the right subtree recursion\\n        TreeNode left = flattenHelper(root.left, right);\\n        \\n        // induction step\\n        root.right = left;\\n        root.left = null;\\n        \\n        return root;\\n    }\\n    \\n    public void flatten(TreeNode root) {\\n        flattenHelper(root, null);\\n    }\\n}\\n```\n```\\n/*\\n    Iterative Solution - Inplace\\n    ----------------------------\\n    Time complexity: O(N)\\n    Space complexity: O(1)\\n*/\\n\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        while (root != null) {\\n            if (root.left != null) {\\n                TreeNode prev = root.left;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Find the rightmost node in left subtree\\n                while (prev.right != null)\\n                    prev = prev.right;\\n                \\n                prev.right = root.right;\\n                root.right = root.left;\\n                root.left = null;\\n            }\\n            \\n            root = root.right;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207708,
                "title": "flatten-binary-tree-to-linked-list-c-protip-for-beginners-explained",
                "content": "**PROTIP(for beginners):** *To solve any problem recursively just imagine we get the solution for our subproblem through recursion.We don\\'t need to worry about how that works,just focus on the base case and the operations that we gonna apply on the solutions of subproblem what we get through recursion.*\\n\\n**Explanation:**\\nAs we can see the resultant linked list is the preorder traversal of the tree.\\nSo, we simply get flatten linked list for our left sub tree by calling recursion and store it in **l**( please see in code).\\nAnd similarly for right sub-tree,we will store it in **r**(please see in code).\\n\\nNow we have flatten linked list for our left and right subtrees and we know we want our linked list to look like preorder.\\nSo now we have two cases:\\n1. **l is NULL**(means we get NULL from our left subtree): we simply put **r in the right of tree**.\\n2. **l is not NULL**: In this case we first put **l in the right of tree** and then **r at the tail of left**(because we want it to be preordered).\\n  **Final step:** Assighn NULL to the left of the root and return root.\\n  **BaseCase:** If we have nothing means we get `root==NULL` so we can\\'t do anything simply return `NULL`l\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* helper(TreeNode* root){\\n        if(!root) return NULL;\\n        TreeNode* l= helper(root->left);\\n        TreeNode* r = helper(root->right);\\n        if(l!=NULL){\\n            TreeNode* temp=l;\\n            while(temp->right){\\n                temp=temp->right;\\n            }\\n            temp->right=r;\\n            root->right=l;\\n        }else\\n        root->right=r;\\n        root->left=NULL;\\n        return root;\\n    }\\n    void flatten(TreeNode* root) {\\n        if(!root) return;\\n          root=helper(root);\\n    }\\n};\\n```\\n\\n**NOTE:** *IF anyone have any doubts,you  can freely ask in comment section.*",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* helper(TreeNode* root){\\n        if(!root) return NULL;\\n        TreeNode* l= helper(root->left);\\n        TreeNode* r = helper(root->right);\\n        if(l!=NULL){\\n            TreeNode* temp=l;\\n            while(temp->right){\\n                temp=temp->right;\\n            }\\n            temp->right=r;\\n            root->right=l;\\n        }else\\n        root->right=r;\\n        root->left=NULL;\\n        return root;\\n    }\\n    void flatten(TreeNode* root) {\\n        if(!root) return;\\n          root=helper(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502553,
                "title": "python-js-java-go-c-o-n-sol-by-dfs-w-visualization",
                "content": "Python/JS/Java/Go/C++ O( n ) sol. by DFS approach.\\n\\n---\\n\\nGoal: \\n**Convert binary tree** into a **right-skewed linked list**.\\n\\n---\\n\\nAlgorithm:\\n\\nMaintain a global node, called **previous traversal node**, initialized to None, and update as current node on each DFS traversal.\\n\\nDFS traversal with the ordering: ( Right node, Left node, Current node )\\n\\n1. Change current node\\'s **right child** as **previous traversal node**.\\n2. Change current node\\'s **left child** as **None**(i.e., NULL)\\n3. **Update previous traversal node** as current node\\n\\nObservation:\\nFor Left node, Right node is its previous traversal node.\\nFor Current node, Left node is its previous traversal node.\\n\\n---\\n\\nAbstract Model:\\n\\nBefore flatten operation: ( binary tree )\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1581161300.png)\\n\\nAfter flatten operation: ( right-skewed linked list )\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1581161348.png)\\n\\n\\t \\n---\\n\\n**Implementation**:\\n\\nPython:\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n      \\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Input: root node of binary tree\\n        Output: convert binary tree to right-skewed linked list\\n        \"\"\"\\n        \\n        # record of node of previous traversal\\n        previous_traversal = None\\n        \\n        def helper( node):\\n        \\n            if node:\\n\\n                # DFS travesal to next level\\n                \\n                helper( node.right )\\n                helper( node.left )\\n\\n                # flattern binary tree to right skewed linked list\\n                \\n                nonlocal previous_traversal\\n                node.right = previous_traversal\\n                node.left = None\\n                previous_traversal = node\\n                \\n        # ---------------------\\n        \\n        helper(root)\\n```\\n\\n---\\n\\nJava:\\n\\n```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        \\n        if( root != null ){\\n\\n            // DFS travesal to next level\\n            flatten( root.right );\\n            flatten( root.left );\\n\\n            // flattern binary tree to right skewed linked list\\n            root.right = prev;\\n            root.left = null;\\n            prev = root;\\n        }\\n        \\n        return;        \\n    }\\n    \\n    // record of node of previous traversal\\n    private TreeNode prev = null;\\n}\\n```\\n\\n---\\n\\nJavascript:\\n\\n```\\nvar flatten = function(root) {\\n    \\n    let prev = null;\\n    \\n    var helper = function( node ){\\n        \\n        if( node != null){\\n            \\n            // DFS travesal to next level\\n            helper(node.right);\\n            helper(node.left);\\n            \\n            // flattern binary tree to right skewed linked list\\n            node.right = prev;\\n            node.left = null\\n            prev = node\\n        }\\n        return;\\n    }\\n    // ------------------------------------\\n    \\n    helper( root );\\n};\\n```\\n\\n---\\n\\nGo:\\n\\n```\\nfunc flatten(root *TreeNode)  {\\n\\n    //  record of node of previous traversal\\n    var prev *TreeNode = nil\\n    \\n    var helper func( *TreeNode )\\n    \\n    helper = func( node *TreeNode){\\n        \\n        if node != nil{\\n            \\n            // DFS travesal to next level\\n            helper( node.Right )\\n            helper( node.Left )\\n\\n            // flattern binary tree to right skewed linked list\\n            node.Right = prev\\n            node.Left = nil\\n            prev = node\\n        }\\n        return\\n\\n    }\\n    // ------------------------------\\n    helper( root )\\n}\\n```\\n\\n---\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        \\n        // record of node of previous traversal\\n        TreeNode* prev = nullptr;\\n        \\n        std::function< void(TreeNode*) > helper;\\n        helper = [&](TreeNode* node) -> void {\\n            \\n            if( node != nullptr ){\\n                \\n                // DFS travesal to next level\\n                helper( node->right );\\n                helper( node->left );\\n                \\n                // flattern binary tree to right skewed linked list\\n                node->right = prev;\\n                node->left = nullptr;\\n                prev = node;\\n            }\\n            return;\\n        };\\n        \\n        // ----------------------\\n        helper( root );\\n        \\n        return;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n      \\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Input: root node of binary tree\\n        Output: convert binary tree to right-skewed linked list\\n        \"\"\"\\n        \\n        # record of node of previous traversal\\n        previous_traversal = None\\n        \\n        def helper( node):\\n        \\n            if node:\\n\\n                # DFS travesal to next level\\n                \\n                helper( node.right )\\n                helper( node.left )\\n\\n                # flattern binary tree to right skewed linked list\\n                \\n                nonlocal previous_traversal\\n                node.right = previous_traversal\\n                node.left = None\\n                previous_traversal = node\\n                \\n        # ---------------------\\n        \\n        helper(root)\\n```\n```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        \\n        if( root != null ){\\n\\n            // DFS travesal to next level\\n            flatten( root.right );\\n            flatten( root.left );\\n\\n            // flattern binary tree to right skewed linked list\\n            root.right = prev;\\n            root.left = null;\\n            prev = root;\\n        }\\n        \\n        return;        \\n    }\\n    \\n    // record of node of previous traversal\\n    private TreeNode prev = null;\\n}\\n```\n```\\nvar flatten = function(root) {\\n    \\n    let prev = null;\\n    \\n    var helper = function( node ){\\n        \\n        if( node != null){\\n            \\n            // DFS travesal to next level\\n            helper(node.right);\\n            helper(node.left);\\n            \\n            // flattern binary tree to right skewed linked list\\n            node.right = prev;\\n            node.left = null\\n            prev = node\\n        }\\n        return;\\n    }\\n    // ------------------------------------\\n    \\n    helper( root );\\n};\\n```\n```\\nfunc flatten(root *TreeNode)  {\\n\\n    //  record of node of previous traversal\\n    var prev *TreeNode = nil\\n    \\n    var helper func( *TreeNode )\\n    \\n    helper = func( node *TreeNode){\\n        \\n        if node != nil{\\n            \\n            // DFS travesal to next level\\n            helper( node.Right )\\n            helper( node.Left )\\n\\n            // flattern binary tree to right skewed linked list\\n            node.Right = prev\\n            node.Left = nil\\n            prev = node\\n        }\\n        return\\n\\n    }\\n    // ------------------------------\\n    helper( root )\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        \\n        // record of node of previous traversal\\n        TreeNode* prev = nullptr;\\n        \\n        std::function< void(TreeNode*) > helper;\\n        helper = [&](TreeNode* node) -> void {\\n            \\n            if( node != nullptr ){\\n                \\n                // DFS travesal to next level\\n                helper( node->right );\\n                helper( node->left );\\n                \\n                // flattern binary tree to right skewed linked list\\n                node->right = prev;\\n                node->left = nullptr;\\n                prev = node;\\n            }\\n            return;\\n        };\\n        \\n        // ----------------------\\n        helper( root );\\n        \\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 940394,
                "title": "python3-iterative-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        cur = root\\n        while cur:\\n            if cur.left:\\n                prev = cur.left\\n                while prev.right:\\n\\t\\t\\t\\t\\tprev = prev.right    # We go to left Subtree\\'s rightMost Node\\n                \\n                prev.right = cur.right   #We make current Node\\'s right Subtree prev\\'s right Subtree\\n                cur.right = cur.left    # We make it right Subtree\\n                cur.left = None   # Removing left \\n            \\n            cur = cur.right\\n```\\n\\nInitial Tree:    \\t\\n\\n\\t\\t\\t\\t\\t\\t\\t1\\n\\t\\t\\t\\t\\t\\t   / \\\\\\n\\t\\t\\t\\t\\t\\t  2   5\\n\\t\\t\\t\\t\\t\\t / \\\\   \\\\\\n\\t\\t\\t\\t\\t\\t3   4   6\\n\\t\\t\\t\\t\\t\\t\\nThen:  Since cur.left is True, we move to cur.left\\'s right most child ...ie.... here 4\\n          Then we make  Node (4).right, Node(1).right ...ie...\\n\\t\\t  \\n\\t\\t\\t\\t\\t\\t\\t 1\\n\\t\\t\\t\\t\\t\\t   / \\n\\t\\t\\t\\t\\t\\t  2   \\n\\t\\t\\t\\t\\t\\t / \\\\   \\n\\t\\t\\t\\t\\t\\t3   4   \\n\\t\\t\\t\\t\\t\\t\\t   \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t 5\\n\\t\\t\\t\\t\\t\\t\\t\\t   \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t     6\\n\\nThen: we make current Node(1).right = Node(1).left....ie........\\n\\n\\t\\t\\t\\t\\t\\t\\t1\\n\\t\\t\\t\\t\\t\\t\\t  \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t2   \\n\\t\\t\\t\\t\\t\\t\\t   /  \\\\   \\n\\t\\t\\t\\t\\t\\t\\t  3    4   \\n\\t\\t\\t\\t\\t\\t\\t     \\t   \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t 5\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t 6\\n\\t\\t\\t\\t\\t\\t   \\n\\t\\t\\t\\t\\t\\t \\nThen:\\n\\n\\t\\t\\t\\t\\t\\t\\t1\\n\\t\\t\\t\\t\\t\\t\\t  \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t2   \\n\\t\\t\\t\\t\\t\\t\\t   /     \\n\\t\\t\\t\\t\\t\\t\\t  3    \\n\\t\\t\\t\\t\\t\\t        \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t  4   \\n\\t\\t\\t\\t\\t\\t\\t\\t    \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  5\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t    \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  6\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\nThen:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t1\\n\\t\\t\\t\\t\\t\\t\\t  \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t2\\n\\t\\t\\t\\t\\t\\t\\t\\t  \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t    3    \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  4   \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  5\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  6\\n\\t\\t\\t\\t\\t\\t\\t\\t  \\n\\t\\t\\t\\t\\t\\t\\t\\t  \\n\\t\\t\\t\\t\\t\\t\\t  \\nIf any Doubts plz fell free to ask\\n\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        cur = root\\n        while cur:\\n            if cur.left:\\n                prev = cur.left\\n                while prev.right:\\n\\t\\t\\t\\t\\tprev = prev.right    # We go to left Subtree\\'s rightMost Node\\n                \\n                prev.right = cur.right   #We make current Node\\'s right Subtree prev\\'s right Subtree\\n                cur.right = cur.left    # We make it right Subtree\\n                cur.left = None   # Removing left \\n            \\n            cur = cur.right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37124,
                "title": "java-solution-refer-to-mirris-traversal-using-constant-place",
                "content": "    public void flatten(TreeNode root) {\\n        TreeNode cur = root;\\n        TreeNode prev = null;\\n        while(cur != null){\\n            if(cur.left == null) cur = cur.right;\\n            else {\\n                prev = cur.left;\\n                while(prev.right != null) prev = prev.right;\\n                prev.right = cur.right;\\n                cur.right = cur.left;\\n                cur.left = null;\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public void flatten(TreeNode root) {\\n        TreeNode cur = root;\\n        TreeNode prev = null;\\n        while(cur != null){\\n            if(cur.left == null) cur = cur.right;\\n            else {\\n                prev = cur.left;\\n                while(prev.right != null) prev = prev.right;\\n                prev.right = cur.right;\\n                cur.right = cur.left;\\n                cur.left = null;\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 483444,
                "title": "python-iterative-preorder",
                "content": "```python\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        if not root: \\n            return None\\n        \\n        stack = [root]\\n        while len(stack):\\n            root = stack.pop()\\n            \\n            if root.right: \\n                stack.append(root.right)\\n            if root.left: \\n                stack.append(root.left)\\n                \\n            root.left = None\\n            root.right = stack[-1] if len(stack) else None\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        if not root: \\n            return None\\n        \\n        stack = [root]\\n        while len(stack):\\n            root = stack.pop()\\n            \\n            if root.right: \\n                stack.append(root.right)\\n            if root.left: \\n                stack.append(root.left)\\n                \\n            root.left = None\\n            root.right = stack[-1] if len(stack) else None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 523446,
                "title": "c-solution-using-stack",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) \\n    {\\n        //empty tree\\n        if(root == NULL)\\n            return;\\n        \\n        //use stack to keep storing elements \\n        stack<TreeNode*> stack;\\n        stack.push(root);\\n        \\n        //somewhat similar to level order\\n        //pop each element from the stack (starting from root)\\n        //add its right and left child to the stack\\n\\t\\t//(explained below why right child is added before left)\\n        //repeat till stack is empty.\\n        while(!stack.empty())\\n        {\\n            TreeNode* currentNode = stack.top();\\n            stack.pop();\\n            \\n            //push the right node first, because when we pop\\n            //left child will be on top and we want left child first.\\n            if(currentNode->right != NULL)\\n                stack.push(currentNode->right);\\n            \\n            //push left child, this will be on top of stack now.\\n            if(currentNode->left != NULL)\\n                stack.push(currentNode->left);\\n            \\n            //assign the top most(left child) as right. \\n            if(!stack.empty())\\n                currentNode->right = stack.top();\\n            \\n            //make all left children NULL. \\n            currentNode->left = NULL;\\n        }\\n    }    \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) \\n    {\\n        //empty tree\\n        if(root == NULL)\\n            return;\\n        \\n        //use stack to keep storing elements \\n        stack<TreeNode*> stack;\\n        stack.push(root);\\n        \\n        //somewhat similar to level order\\n        //pop each element from the stack (starting from root)\\n        //add its right and left child to the stack\\n\\t\\t//(explained below why right child is added before left)\\n        //repeat till stack is empty.\\n        while(!stack.empty())\\n        {\\n            TreeNode* currentNode = stack.top();\\n            stack.pop();\\n            \\n            //push the right node first, because when we pop\\n            //left child will be on top and we want left child first.\\n            if(currentNode->right != NULL)\\n                stack.push(currentNode->right);\\n            \\n            //push left child, this will be on top of stack now.\\n            if(currentNode->left != NULL)\\n                stack.push(currentNode->left);\\n            \\n            //assign the top most(left child) as right. \\n            if(!stack.empty())\\n                currentNode->right = stack.top();\\n            \\n            //make all left children NULL. \\n            currentNode->left = NULL;\\n        }\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37074,
                "title": "preorder-vs-postorder",
                "content": "1. let's try Preorder first. First we save left child and right child. Then we can safely flatten this node. Then left and right.\\n\\n```\\npublic class Solution {\\n    TreeNode pre=null;\\n    public void flatten(TreeNode root) {\\n        if(root==null) return;\\n        TreeNode left = root.left;\\n        TreeNode right = root.right;\\n        if(pre == null) {\\n            pre = root;\\n        }else {\\n            pre.right = root;\\n            pre.left = null;\\n            pre = root;\\n        }\\n        flatten(left);\\n        flatten(right);\\n    }\\n}\\n\\n````\\n\\n2. Postorder is a little tricky and not easy to come up. Because the order we flatten will not change the relationship of remaining nodes we do not extra pointers.\\n\\n```\\npublic class Solution {\\n    TreeNode pre=null;\\n    public void flatten(TreeNode root) {\\n        if(root==null) return;\\n        flatten(root.right);\\n        flatten(root.left);\\n        root.right=pre;\\n        root.left=null;\\n        pre = root;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    TreeNode pre=null;\\n    public void flatten(TreeNode root) {\\n        if(root==null) return;\\n        TreeNode left = root.left;\\n        TreeNode right = root.right;\\n        if(pre == null) {\\n            pre = root;\\n        }else {\\n            pre.right = root;\\n            pre.left = null;\\n            pre = root;\\n        }\\n        flatten(left);\\n        flatten(right);\\n    }\\n}\\n\\n```\n```\\npublic class Solution {\\n    TreeNode pre=null;\\n    public void flatten(TreeNode root) {\\n        if(root==null) return;\\n        flatten(root.right);\\n        flatten(root.left);\\n        root.right=pre;\\n        root.left=null;\\n        pre = root;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37039,
                "title": "my-8ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        void flatten(TreeNode* root) {\\n            TreeNode *head = nullptr;\\n            flattenWorker(root, head);\\n        }\\n    private:\\n        void flattenWorker(TreeNode* root, TreeNode*& head) {\\n            if (root == nullptr) {\\n                return;\\n            }\\n            flattenWorker(root->right, head);\\n            flattenWorker(root->left, head);\\n            root->left = nullptr;\\n            root->right = head;\\n            head = root;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void flatten(TreeNode* root) {\\n            TreeNode *head = nullptr;\\n            flattenWorker(root, head);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 37047,
                "title": "16-lines-iterative-c-solution",
                "content": "    void flatten(TreeNode *root) {\\n        while(root){\\n            if(root->left == NULL)\\n                root = root->right;\\n            else {\\n                if(root->right){\\n                    TreeNode *l = root->left;\\n                    while(l->right) l = l->right;\\n                    l->right = root->right;\\n                }\\n                root->right = root->left;\\n                root->left = NULL;\\n                root = root->right;\\n            }\\n        }\\n    }\\n\\nInspired by Morris traversal.",
                "solutionTags": [],
                "code": "    void flatten(TreeNode *root) {\\n        while(root){\\n            if(root->left == NULL)\\n                root = root->right;\\n            else {\\n                if(root->right){\\n                    TreeNode *l = root->left;\\n                    while(l->right) l = l->right;\\n                    l->right = root->right;\\n                }\\n                root->right = root->left;\\n                root->left = NULL;\\n                root = root->right;\\n            }\\n        }\\n    }\\n\\nInspired by Morris traversal.",
                "codeTag": "Unknown"
            },
            {
                "id": 1207644,
                "title": "flatten-binary-tree-to-linked-list-js-python-java-c-simple-o-1-space-solution-w-expl",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\n***Morris Traversal (O(1) Space, O(N) Time) Approach:***\\n\\nThere _is_ actually a way to traverse a binary tree with a **space complexity** of **O(1)** while staying at a **time complexity** of **O(N)**, though it does require modifying the tree\\'s structure. In this problem that\\'s specifically being called for, so it\\'s a valid approach, though it won\\'t always be appropriate to modify the source binary tree in other situations.\\n\\nThe approach is called the **Morris traversal**. At its heart, it takes advantage of the basic nature of ordered traversals to iterate through and unwind the tree. In a **pre-order traversal** of a binary tree, each vertex is processed in **(node, left, right)** order. This means that the entire left subtree could be placed between the node and its right subtree.\\n\\nTo do this, however, we\\'ll first have to locate the last node in the left subtree. This is easy enough, since we know that the last node of a pre-order tree can be found by moving right as many times as possible from its root.\\n\\nSo we should be able to move through the binary tree, keeping track of the curent node (**curr**). Whenever we find a left subtree, we can dispatch a **runner** to find its last node, then stitch together both ends of the left subtree into the right path of **curr**, taking heed to sever the left connection at **curr**.\\n\\nOnce that\\'s done, we can continue to move **curr** to the right, looking for the next left subtree. When **curr** can no longer move right, the tree will be successfully flattened.\\n\\n![Morris Traversal Visual](https://i.imgur.com/sqnrz9m.gif)\\n\\n - _**Time Complexity: O(N)** where **N** is the number of **nodes** in the binary tree_\\n - _**Space Complexity: O(1)**_\\n\\n---\\n\\n***O(1) Space Approach:***\\n\\nIn order to properly connect the **linked list**, we\\'ll need to start at the bottom and work up. This means that we\\'ll need to move in _reverse_ **pre-order traversal** order through the **binary tree**. Since pre-order traversal is normally **\"node, left, right\"**, we\\'ll have to move in the reverse order of **\"right, left, node\"**.\\n\\nIn order to complete this solution in **O(1) space**, we won\\'t be able to conveniently backtrack via a **stack**, so the key to this solution will be to retreat all the way back up to the **root** each time we reach a leaf. This will push the **time complexity** to **O(N^2)**.\\n\\nWe\\'ll want to first set up **head** and **curr** to keep track of the head of the linked list we\\'re building and the current node we\\'re visiting. We\\'ll know we\\'re finished once **head = root**.\\n\\nTo follow the reverse pre-order traversal order, we\\'ll first attempt to go right and then left. Since we\\'re backtracking to **root**, however, we\\'ll eventually run back into the same node that we\\'ve set as **head** doing this. To prevent this, we\\'ll stop _before_ moving to the **head** node and sever the connection.\\n\\nNow that we can\\'t run into already-completed territory, we can be confident that any leaf we move to must be the next value for **head**, so we should connect it to the old **head**, update **head**, and reset back to the **root**.\\n\\nAs noted before, once **head = root**, we\\'ve finished our traversal and can exit the function.\\n\\n - _**Time Complexity: O(N^2)** where **N** is the number of **nodes** in the binary tree, due to repeated backtracking to root_\\n - _**Space Complexity: O(1)**_\\n\\n---\\n\\n***Recursive Approach:***\\n\\nIn order to properly connect the **linked list**, we\\'ll need to start at the bottom and work up. This means that we\\'ll need to move in _reverse_ **pre-order traversal** order through the **binary tree**. Since pre-order traversal is normally **\"node, left, right\"**, we\\'ll have to move in the reverse order of **\"right, left, node\"**.\\n\\nBinary tree traversal is prime ground for a **recursive** solution, so let\\'s define a helper (**revPreOrder**) for the purpose. We\\'ll also keep a global variable **head** to keep track of the head of the linked list as we work our way backwards.\\n\\nPer our reverse pre-order traversal approach, we want to recursively work down the right path first then the left path, if they exist. Once we\\'ve flattened the left and right paths recursively, **head** should at this point be equal to the next node after the current one, so we should set it as **node.right**. We shouldn\\'t forget to set **node.left** to **null**, as well.\\n\\nOnce we\\'re done with the current node, we can update **head** to **node** and allow the recursion to complete and move back up to the next layer. Once the recursion stack is exhausted, **head** will be equal to **root** again.\\n\\nLastly, we have to deal with an edge case of an empty **root**, so we can just make sure to only call the initial recursion on **root** if **root** actually is a node. There is no need for a **return** statement, because the test suite will evaluate **root** directly.\\n\\n - _**Time Complexity: O(N)** where **N** is the number of **nodes** in the binary tree_\\n - _**Space Complexity: O(N)** for the **recursion stack**, which is as long as the maximum depth of the binary tree, which can go up to **N**_\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\n##### ***w/ Morris Traversal:***\\n\\nThe best result for the code below is **84ms / 40.6MB** (beats 96% / 66%).\\n```javascript\\nvar flatten = function(root) {\\n    let curr = root\\n    while (curr) {\\n        if (curr.left) {\\n            let runner = curr.left\\n            while (runner.right) runner = runner.right\\n            runner.right = curr.right, curr.right = curr.left, curr.left = null\\n        }\\n        curr = curr.right\\n    }\\n};\\n```\\n\\n##### ***w/ O(1) Space:***\\n\\nThe best result for the code below is **80ms / 40.6MB** (beats 98% / 66%).\\n```javascript\\nvar flatten = function(root) {\\n    let head = null, curr = root\\n    while (head != root) {\\n        if (curr.right === head) curr.right = null\\n        if (curr.left === head) curr.left = null\\n        if (curr.right) curr = curr.right\\n        else if (curr.left) curr = curr.left\\n        else curr.right = head, head = curr, curr = root\\n    }\\n};\\n```\\n\\n##### ***w/ Recursion:***\\n\\nThe best result for the code below is **84ms / 40.6MB** (beats 96% / 66%).\\n```javascript\\nvar flatten = function(root) {\\n    let head = null\\n    const revPreOrder = node => {\\n        if (node.right) revPreOrder(node.right)\\n        if (node.left) revPreOrder(node.left)\\n        node.left = null, node.right = head, head = node\\n    }\\n    if (root) revPreOrder(root)\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\n##### ***w/ Morris Traversal:***\\n\\nThe best result for the code below is **32ms / 15.0MB** (beats 92% / 91%).\\n```python\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        curr = root\\n        while curr:\\n            if curr.left:\\n                runner = curr.left\\n                while runner.right: runner = runner.right\\n                runner.right, curr.right, curr.left = curr.right, curr.left, None\\n            curr = curr.right\\n```\\n\\n##### ***w/ O(1) Space:***\\n\\nThe best result for the code below is **32ms / 15.0MB** (beats 92% / 91%).\\n```\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        head, curr = None, root\\n        while head != root:\\n            if curr.right == head: curr.right = None\\n            if curr.left == head: curr.left = None\\n            if curr.right: curr = curr.right\\n            elif curr.left: curr = curr.left\\n            else: curr.right, head, curr = head, curr, root\\n```\\n\\n##### ***w/ Recursion:***\\n\\nThe best result for the code below is **28ms / 14.9MB** (beats 98% / 98%).\\n```python\\nclass Solution:\\n    head = None\\n    def flatten(self, root: TreeNode) -> None:\\n        def revPreOrder(node: TreeNode) -> None:\\n            if node.right: revPreOrder(node.right)\\n            if node.left: revPreOrder(node.left)\\n            node.left, node.right, self.head = None, self.head, node\\n        if root: revPreOrder(root)\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\n##### ***w/ Morris Traversal:***\\n\\nThe best result for the code below is **0ms / 37.9MB** (beats 100% / 98%).\\n```java\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        TreeNode curr = root;\\n        while (curr != null) {\\n            if (curr.left != null) {\\n                TreeNode runner = curr.left;\\n                while (runner.right != null) runner = runner.right;\\n                runner.right = curr.right;\\n                curr.right = curr.left;\\n                curr.left = null;\\n            }\\n            curr = curr.right;\\n        }\\n    }\\n}\\n```\\n\\n##### ***w/ O(1) Space:***\\n\\nThe best result for the code below is **0ms / 37.9MB** (beats 100% / 98%).\\n```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        TreeNode head = null, curr = root;\\n        while (head != root) {\\n            if (curr.right == head) curr.right = null;\\n            if (curr.left == head) curr.left = null;\\n            if (curr.right != null) curr = curr.right;\\n            else if (curr.left != null) curr = curr.left;\\n            else {\\n                curr.right = head;\\n                head = curr;\\n                curr = root;\\n            }\\n        }\\n    }\\n}\\n```\\n\\n##### ***w/ Recursion:***\\n\\nThe best result for the code below is **0ms / 38.0MB** (beats 100% / 98%).\\n```java\\nclass Solution {\\n    TreeNode head = null;\\n    public void flatten(TreeNode root) {\\n        if (root != null) revPreOrder(root);\\n    }\\n    private void revPreOrder(TreeNode node) {\\n        if (node.right != null) revPreOrder(node.right);\\n        if (node.left != null) revPreOrder(node.left);\\n        node.left = null;\\n        node.right = head;\\n        head = node;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\n##### ***w/ Morris Traversal:***\\n\\nThe best result for the code below is **0ms / 12.6MB** (beats 100% / 95%).\\n```c++\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while (curr) {\\n            if (curr->left) {\\n                TreeNode* runner = curr->left;\\n                while (runner->right != nullptr) runner = runner->right;\\n                runner->right = curr->right, curr->right = curr->left, curr->left = nullptr;\\n            }\\n            curr = curr->right;\\n        }\\n    }\\n};\\n```\\n\\n##### ***w/ O(1) Space:***\\n\\nThe best result for the code below is **0ms / 12.6MB** (beats 100% / 95%).\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode *head = nullptr, *curr = root;\\n        while (head != root) {\\n            if (curr->right == head) curr->right = nullptr;\\n            if (curr->left == head) curr->left = nullptr;\\n            if (curr->right) curr = curr->right;\\n            else if (curr->left) curr = curr->left;\\n            else curr->right = head, head = curr, curr = root;\\n        }\\n    }\\n};\\n```\\n\\n##### ***w/ Recursion:***\\n\\nThe best result for the code below is **0ms / 12.6MB** (beats 100% / 95%).\\n```c++\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if (root) revPreOrder(root);\\n    }\\nprivate:\\n    TreeNode* head = nullptr;\\n    void revPreOrder(TreeNode* node) {\\n        if (node->right) revPreOrder(node->right);\\n        if (node->left) revPreOrder(node->left);\\n        node->left = nullptr, node->right = head, head = node;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar flatten = function(root) {\\n    let curr = root\\n    while (curr) {\\n        if (curr.left) {\\n            let runner = curr.left\\n            while (runner.right) runner = runner.right\\n            runner.right = curr.right, curr.right = curr.left, curr.left = null\\n        }\\n        curr = curr.right\\n    }\\n};\\n```\n```javascript\\nvar flatten = function(root) {\\n    let head = null, curr = root\\n    while (head != root) {\\n        if (curr.right === head) curr.right = null\\n        if (curr.left === head) curr.left = null\\n        if (curr.right) curr = curr.right\\n        else if (curr.left) curr = curr.left\\n        else curr.right = head, head = curr, curr = root\\n    }\\n};\\n```\n```javascript\\nvar flatten = function(root) {\\n    let head = null\\n    const revPreOrder = node => {\\n        if (node.right) revPreOrder(node.right)\\n        if (node.left) revPreOrder(node.left)\\n        node.left = null, node.right = head, head = node\\n    }\\n    if (root) revPreOrder(root)\\n};\\n```\n```python\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        curr = root\\n        while curr:\\n            if curr.left:\\n                runner = curr.left\\n                while runner.right: runner = runner.right\\n                runner.right, curr.right, curr.left = curr.right, curr.left, None\\n            curr = curr.right\\n```\n```\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        head, curr = None, root\\n        while head != root:\\n            if curr.right == head: curr.right = None\\n            if curr.left == head: curr.left = None\\n            if curr.right: curr = curr.right\\n            elif curr.left: curr = curr.left\\n            else: curr.right, head, curr = head, curr, root\\n```\n```python\\nclass Solution:\\n    head = None\\n    def flatten(self, root: TreeNode) -> None:\\n        def revPreOrder(node: TreeNode) -> None:\\n            if node.right: revPreOrder(node.right)\\n            if node.left: revPreOrder(node.left)\\n            node.left, node.right, self.head = None, self.head, node\\n        if root: revPreOrder(root)\\n```\n```java\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        TreeNode curr = root;\\n        while (curr != null) {\\n            if (curr.left != null) {\\n                TreeNode runner = curr.left;\\n                while (runner.right != null) runner = runner.right;\\n                runner.right = curr.right;\\n                curr.right = curr.left;\\n                curr.left = null;\\n            }\\n            curr = curr.right;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        TreeNode head = null, curr = root;\\n        while (head != root) {\\n            if (curr.right == head) curr.right = null;\\n            if (curr.left == head) curr.left = null;\\n            if (curr.right != null) curr = curr.right;\\n            else if (curr.left != null) curr = curr.left;\\n            else {\\n                curr.right = head;\\n                head = curr;\\n                curr = root;\\n            }\\n        }\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    TreeNode head = null;\\n    public void flatten(TreeNode root) {\\n        if (root != null) revPreOrder(root);\\n    }\\n    private void revPreOrder(TreeNode node) {\\n        if (node.right != null) revPreOrder(node.right);\\n        if (node.left != null) revPreOrder(node.left);\\n        node.left = null;\\n        node.right = head;\\n        head = node;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while (curr) {\\n            if (curr->left) {\\n                TreeNode* runner = curr->left;\\n                while (runner->right != nullptr) runner = runner->right;\\n                runner->right = curr->right, curr->right = curr->left, curr->left = nullptr;\\n            }\\n            curr = curr->right;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode *head = nullptr, *curr = root;\\n        while (head != root) {\\n            if (curr->right == head) curr->right = nullptr;\\n            if (curr->left == head) curr->left = nullptr;\\n            if (curr->right) curr = curr->right;\\n            else if (curr->left) curr = curr->left;\\n            else curr->right = head, head = curr, curr = root;\\n        }\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if (root) revPreOrder(root);\\n    }\\nprivate:\\n    TreeNode* head = nullptr;\\n    void revPreOrder(TreeNode* node) {\\n        if (node->right) revPreOrder(node->right);\\n        if (node->left) revPreOrder(node->left);\\n        node->left = nullptr, node->right = head, head = node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325530,
                "title": "cpp-concise-solution-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* cur = root;\\n        while(cur) {\\n            if(cur->left) {\\n                TreeNode* tmp = cur->left;\\n                while(tmp->right) tmp = tmp->right;\\n                tmp->right = cur->right;\\n                cur->right = cur->left;\\n                cur->left = nullptr;\\n            }\\n            cur = cur->right;\\n        }\\n    }\\n};\\n```\\nTime: O(N) - each node would be visited at most twice\\nSpace: O(1)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* cur = root;\\n        while(cur) {\\n            if(cur->left) {\\n                TreeNode* tmp = cur->left;\\n                while(tmp->right) tmp = tmp->right;\\n                tmp->right = cur->right;\\n                cur->right = cur->left;\\n                cur->left = nullptr;\\n            }\\n            cur = cur->right;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 291995,
                "title": "simple-javascript-recursion-solution-beats-99-for-now",
                "content": "Logic is simple. If the current node is null, we will return and stop here. \\nIf the current node has a left child node\\n\\t1. find the most right leaf of current left node\\n\\t2. keep current right node in a tmp var\\n\\t3. we move the left child to our right.\\n\\t4. connect previous right node(tmp) to the right of the most right leaf we found\\n\\t5. make current left null\\nThen we call ourself and pass the right node in.\\n```\\nvar flatten = function(root) {\\n    if (root === null) return;\\n    if (root.left) {\\n\\t\\t// step 1\\n        var last = root.left;\\n        while (last.right !== null) last = last.right;\\n        // step 2\\n        var tmp = root.right;\\n\\t\\t// step 3\\n        root.right = root.left;\\n\\t\\t// step 4\\n        last.right = tmp;\\n\\t\\t// step 5\\n        root.left = null;\\n    }\\n    \\n    flatten(root.right);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar flatten = function(root) {\\n    if (root === null) return;\\n    if (root.left) {\\n\\t\\t// step 1\\n        var last = root.left;\\n        while (last.right !== null) last = last.right;\\n        // step 2\\n        var tmp = root.right;\\n\\t\\t// step 3\\n        root.right = root.left;\\n\\t\\t// step 4\\n        last.right = tmp;\\n\\t\\t// step 5\\n        root.left = null;\\n    }\\n    \\n    flatten(root.right);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 37244,
                "title": "can-you-improve-upon-my-recursive-approach",
                "content": "I am basically storing the last visited pre-order traversal node in a static \"lastVisited\" TreeNode, and re-assigning its children.\\nCan my algorithm be improved so that we don't need that static variable, and all is handled by the recursive algorithm.\\n\\n    private static TreeNode lastVisited = null;\\n    \\n    public static void flattenHelper(TreeNode root) {\\n        if(root == null)\\n            return;\\n    \\n        TreeNode savedRight = root.right;\\n        if(lastVisited != null) {\\n            lastVisited.left = null;\\n            lastVisited.right = root;\\n        }\\n        lastVisited = root;\\n        \\n        flattenHelper(root.left);\\n        flattenHelper(savedRight);\\n    }",
                "solutionTags": [],
                "code": "I am basically storing the last visited pre-order traversal node in a static \"lastVisited\" TreeNode, and re-assigning its children.\\nCan my algorithm be improved so that we don't need that static variable, and all is handled by the recursive algorithm.\\n\\n    private static TreeNode lastVisited = null;\\n    \\n    public static void flattenHelper(TreeNode root) {\\n        if(root == null)\\n            return;\\n    \\n        TreeNode savedRight = root.right;\\n        if(lastVisited != null) {\\n            lastVisited.left = null;\\n            lastVisited.right = root;\\n        }\\n        lastVisited = root;\\n        \\n        flattenHelper(root.left);\\n        flattenHelper(savedRight);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3194497,
                "title": "beats-93-12-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIn this solution, we start by initializing a prev variable to None. This variable will keep track of the previously flattened node as we recursively flatten the binary tree.\\n\\nWe then define a recursive function flatten that takes in the root node of the binary tree. This function does not return anything, but instead modifies the tree in-place.\\n\\nThe first thing we do in the flatten function is to check if the root node is None. If it is, we simply return.\\n\\nNext, we recursively flatten the right subtree of the root node by calling self.flatten(root.right). This will flatten the right subtree and set self.prev to the rightmost node in the right subtree.\\n\\nWe then recursively flatten the left subtree of the root node by calling self.flatten(root.left). This will flatten the left subtree and update self.prev to the rightmost node in the flattened left subtree.\\n\\nOnce we have flattened both the left and right subtrees, we update the root.right pointer to be the previously flattened node (self.prev). We also set the root.left pointer to None to remove the left child.\\n\\nFinally, we update self.prev to be the current node (root). This is important because it allows us to keep track of the previously flattened node as we continue to recursively flatten the tree.\\n\\nThis algorithm flattens the binary tree in pre-order traversal, so the resulting \"linked list\" will be in the same order as a pre-order traversal of the tree.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.prev = None\\n\\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        if not root:\\n            return\\n        self.flatten(root.right)  # Recursively flatten the right subtree\\n        self.flatten(root.left)  # Recursively flatten the left subtree\\n        root.right = self.prev  # Set the right child to the previously flattened node\\n        root.left = None  # Set the left child to None\\n        self.prev = root  # Update the previously flattened node to be the current node\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Stack",
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.prev = None\\n\\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        if not root:\\n            return\\n        self.flatten(root.right)  # Recursively flatten the right subtree\\n        self.flatten(root.left)  # Recursively flatten the left subtree\\n        root.right = self.prev  # Set the right child to the previously flattened node\\n        root.left = None  # Set the left child to None\\n        self.prev = root  # Update the previously flattened node to be the current node\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 567285,
                "title": "recursive-python-solution-short-and-elegant",
                "content": "```\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        self.previous_right = None\\n        def helper(root = root):\\n            if root:\\n                helper(root.right)\\n                helper(root.left)\\n                root.right, self.previous_right = self.previous_right, root\\n                root.left = None\\n        helper()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        self.previous_right = None\\n        def helper(root = root):\\n            if root:\\n                helper(root.right)\\n                helper(root.left)\\n                root.right, self.previous_right = self.previous_right, root\\n                root.left = None\\n        helper()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535781,
                "title": "python-iterative-solution-without-stack",
                "content": "```\\nclass Solution:\\n    def flatten(self, root: Optional[TreeNode]) -> None:\\n        curr=root\\n        while curr:\\n            if curr.left!=None:\\n                prev=curr.left\\n                while prev.right:\\n                    prev=prev.right\\n                prev.right=curr.right\\n                curr.right=curr.left\\n                curr.left=None\\n            curr=curr.right\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def flatten(self, root: Optional[TreeNode]) -> None:\\n        curr=root\\n        while curr:\\n            if curr.left!=None:\\n                prev=curr.left\\n                while prev.right:\\n                    prev=prev.right\\n                prev.right=curr.right\\n                curr.right=curr.left\\n                curr.left=None\\n            curr=curr.right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207839,
                "title": "python-intuitive-solution-explained",
                "content": "I saw several really nice and short solutions for this problem, howerer sometimes it is a quite difficult to digest them. Here I tried to find the solution, which can be easily reproduced during real-time interview. The idea as in other solutions is to use recursion.\\n\\nLet use `helper(node)` function which return the first and the last elements of linked lists, constucted from subtree of `node`. Then we can have several cases:\\n\\n1. If there is no `left` and no `right` children, then we just return `(node, node)`, because in this case the list for `node` has only one element.  `node ->`\\n2. If there is no `left` children but there is `right` children,  we have a case `node -> b2 -> ... -> e2 ->`. Then we need to create new connection `node -> b2`.\\n3. If there is `left` children and there is no `right` children, we have a case `node -> b1 -> ... -> e1 ->`, and we need to create connection `node -> b1`.\\n4. If there is `left` and `right` children, we have a case `node -> b1 -> ... -> e1 -> b2 -> ... -> e2 ->`.  Then we need to create two more connections: `node -> b1` and `e1 -> b2`.\\n\\n#### Complexity\\nTime complexity is `O(n)` to traverse our tree once. Space complexity we can say `O(h)`, because we reuse existing nodes with recursion stack.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def flatten(self, root):\\n        def helper(node):\\n            if not node: return (None, None)\\n            b1, e1 = helper(node.left)\\n            b2, e2 = helper(node.right)\\n            node.left = None\\n            \\n            if not e1 and not e2:\\n                return (node, node)\\n            if not e1 and e2: \\n                node.right = b2\\n                return (node, e2)\\n            if e1 and not e2:\\n                node.right = b1\\n                return (node, e1)\\n            else:\\n                node.right = b1\\n                e1.right = b2\\n                return (node, e2)\\n\\n        helper(root)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def flatten(self, root):\\n        def helper(node):\\n            if not node: return (None, None)\\n            b1, e1 = helper(node.left)\\n            b2, e2 = helper(node.right)\\n            node.left = None\\n            \\n            if not e1 and not e2:\\n                return (node, node)\\n            if not e1 and e2: \\n                node.right = b2\\n                return (node, e2)\\n            if e1 and not e2:\\n                node.right = b1\\n                return (node, e1)\\n            else:\\n                node.right = b1\\n                e1.right = b2\\n                return (node, e2)\\n\\n        helper(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340445,
                "title": "python-intuitive-explained-o-1-space-ignoring-recursion-stack-o-n-time",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.prev = None\\n        \\n    def flatten(self, root: Optional[TreeNode]) -> None:\\n        \\n        if not root: return \\n        self.flatten(root.right)\\n        self.flatten(root.left)\\n        root.right = self.prev\\n        root.left = None\\n        self.prev = root        \\n```\\nplease upvote if you found it helpful :)\\n\\nExplanation : \\nWe have to make the pre order traversal which is of the format :\\n\\t\\n\\tif not root: return                                   4\\n\\t#visit                                           2         3\\n\\trecur(root.left)                              1      7\\n\\trecur(root.right)\\nPre-order for the tree mentioned above : 4,2,1,7,3\\nNow since we want to do it in place without wasting extra space, we can not start from the first, since if we do that and change its children how will we traverse further?\\nThus we start from the very end, because chaning that would not cause problems. \\nWe store the last visited node in a variable prev, thus when we visit another node we change its left child to None and right child to prev.\\n\\nHow do we traverse this way? just do the oppiste of preorder \\nwe first go right (which takes us towards the end) since preorder first goes left \\nwe then go left\\nand we visit in the end since pre order visits first so we do the opposite.\\n\\t\\n\\tif not root: return       \\n\\trecur(root.right)\\n\\trecur(root.left)                   \\n\\t#visit                                      \\n\\nto explain further - think of it this way we want to visit/ do the changing operations when we do not have to use the current node to traverse any further, meaning its safe to change the children. And that only happens when both travsering to right and left has happened\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.prev = None\\n        \\n    def flatten(self, root: Optional[TreeNode]) -> None:\\n        \\n        if not root: return \\n        self.flatten(root.right)\\n        self.flatten(root.left)\\n        root.right = self.prev\\n        root.left = None\\n        self.prev = root        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892707,
                "title": "flatten-a-binary-tree-to-linked-list-3-approaches-c",
                "content": "# Recursion\\n```\\nclass Solution {\\npublic:\\n      TreeNode* prev=0;\\n    void flatten(TreeNode* root) {\\n       // TreeNode* prev=0;\\n        if(!root) return ;\\n        \\n        flatten(root->right);\\n        flatten(root->left);\\n        \\n        root->right=prev;\\n        root->left=0;\\n        prev=root;\\n    }\\n};\\n```\\n# Stack\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root == NULL) return; \\n        stack<TreeNode*> st; \\n        st.push(root); \\n        while(!st.empty()) {\\n            TreeNode* cur = st.top(); \\n            st.pop(); \\n            \\n            if(cur->right != NULL) {\\n                st.push(cur->right); \\n            }\\n            if(cur->left != NULL) {\\n                st.push(cur->left); \\n            }\\n            if(!st.empty()) {\\n                cur->right = st.top(); \\n            }\\n            cur->left = NULL;\\n        }\\n        \\n    }\\n};\\n```\\n# Moriss Travesal \\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* cur = root;\\n\\t\\twhile (cur)\\n\\t\\t{\\n\\t\\t\\tif(cur->left)\\n\\t\\t\\t{\\n\\t\\t\\t\\tTreeNode* pre = cur->left;\\n\\t\\t\\t\\twhile(pre->right)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tpre = pre->right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tpre->right = cur->right;\\n\\t\\t\\t\\tcur->right = cur->left;\\n\\t\\t\\t\\tcur->left = NULL;\\n\\t\\t\\t}\\n\\t\\t\\tcur = cur->right;\\n\\t\\t}\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      TreeNode* prev=0;\\n    void flatten(TreeNode* root) {\\n       // TreeNode* prev=0;\\n        if(!root) return ;\\n        \\n        flatten(root->right);\\n        flatten(root->left);\\n        \\n        root->right=prev;\\n        root->left=0;\\n        prev=root;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root == NULL) return; \\n        stack<TreeNode*> st; \\n        st.push(root); \\n        while(!st.empty()) {\\n            TreeNode* cur = st.top(); \\n            st.pop(); \\n            \\n            if(cur->right != NULL) {\\n                st.push(cur->right); \\n            }\\n            if(cur->left != NULL) {\\n                st.push(cur->left); \\n            }\\n            if(!st.empty()) {\\n                cur->right = st.top(); \\n            }\\n            cur->left = NULL;\\n        }\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* cur = root;\\n\\t\\twhile (cur)\\n\\t\\t{\\n\\t\\t\\tif(cur->left)\\n\\t\\t\\t{\\n\\t\\t\\t\\tTreeNode* pre = cur->left;\\n\\t\\t\\t\\twhile(pre->right)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tpre = pre->right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tpre->right = cur->right;\\n\\t\\t\\t\\tcur->right = cur->left;\\n\\t\\t\\t\\tcur->left = NULL;\\n\\t\\t\\t}\\n\\t\\t\\tcur = cur->right;\\n\\t\\t}\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37050,
                "title": "java-solution-recursive-non-recursive",
                "content": "I am ambiguous about if \"recursive\" is qualified for \"in place\", as sb in discussion says it's NOT.\\nHere I have Java solution in recursive and non-recursive.\\n\\n\\n\\n    /**\\n     * Move from root down,\\n     * for each node, \\n     *  attach original right as the right child of the rigthmost node of left subtree,\\n     *  set original left as new right child.\\n     * repeat with next right child.\\n     */\\n    /// SOLUTION II: non-recursive ///\\n    public void flatten(TreeNode root) {\\n        TreeNode node = root;\\n        while (node != null) {\\n            TreeNode left = node.left;\\n            TreeNode right = node.right;\\n            if (left != null) {\\n                TreeNode temp = left;\\n                while (temp.right != null)\\n                    temp = temp.right;\\n                temp.right = right;\\n                node.right = left;\\n                node.left = null;\\n            }\\n            node = node.right;\\n        }\\n    }\\n    \\n    /// SOLUTION I: accepted, recursion ///\\n    public void flatten(TreeNode root) {\\n        if (root == null)\\n            return;\\n        TreeNode left = root.left;\\n        TreeNode right = root.right;\\n        if (left != null) {\\n            TreeNode rightmost = getRightmost(left);\\n            rightmost.right = right;\\n            root.left = null; // CATCH: must set left to null explicitly\\n            root.right = left;\\n        }\\n        flatten(root.right);\\n    }\\n    \\n    // return the rightmost node of a subtree;\\n    // node must not be null.\\n    private TreeNode getRightmost(TreeNode node) {\\n        while (node.right != null)\\n            node = node.right;\\n        return node;\\n    }",
                "solutionTags": [],
                "code": "I am ambiguous about if \"recursive\" is qualified for \"in place\", as sb in discussion says it's NOT.\\nHere I have Java solution in recursive and non-recursive.\\n\\n\\n\\n    /**\\n     * Move from root down,\\n     * for each node, \\n     *  attach original right as the right child of the rigthmost node of left subtree,\\n     *  set original left as new right child.\\n     * repeat with next right child.\\n     */\\n    /// SOLUTION II: non-recursive ///\\n    public void flatten(TreeNode root) {\\n        TreeNode node = root;\\n        while (node != null) {\\n            TreeNode left = node.left;\\n            TreeNode right = node.right;\\n            if (left != null) {\\n                TreeNode temp = left;\\n                while (temp.right != null)\\n                    temp = temp.right;\\n                temp.right = right;\\n                node.right = left;\\n                node.left = null;\\n            }\\n            node = node.right;\\n        }\\n    }\\n    \\n    /// SOLUTION I: accepted, recursion ///\\n    public void flatten(TreeNode root) {\\n        if (root == null)\\n            return;\\n        TreeNode left = root.left;\\n        TreeNode right = root.right;\\n        if (left != null) {\\n            TreeNode rightmost = getRightmost(left);\\n            rightmost.right = right;\\n            root.left = null; // CATCH: must set left to null explicitly\\n            root.right = left;\\n        }\\n        flatten(root.right);\\n    }\\n    \\n    // return the rightmost node of a subtree;\\n    // node must not be null.\\n    private TreeNode getRightmost(TreeNode node) {\\n        while (node.right != null)\\n            node = node.right;\\n        return node;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 333469,
                "title": "java-3-methods-explained",
                "content": "**Method 1: Iterative**\\n* Find current node\\'s prenode that links to current node\\'s right subtree. \\n* Use current node\\'s left subtree to replace its right subtree (original right subtree is already linked by current node\\'s prenode)\\n> **T/S:** O(n)/O(1), where n = number of nodes in tree\\n```\\n/**\\n * Algo:\\n * start with N = root\\n * while N is not null:\\n * 1. Find right most node (RMN) of the left subtree.\\n * 2. do RMN\\'s right child = N\\'s right child\\n * 3. N\\'s right child = N\\'s left child\\n * 4. N\\'s left child = null\\n * 5. N = N.right\\n */\\npublic void flatten(TreeNode root) {\\n\\tfor (; root != null; root = root.right) \\n\\t\\tif (root.left != null) {\\n\\t\\t\\tvar pre = root.left; // right most node in left-sub-tree\\n\\t\\t\\tfor (; pre.right != null; pre = pre.right);             \\n\\t\\t\\tpre.right = root.right;\\n\\t\\t\\troot.right = root.left;\\n\\t\\t\\troot.left = null;    \\n\\t\\t}  \\n}\\n```\\n\\n**Method 2:** Recursive with global variable. Post order traversal: Right-Left-Node (Root/self/parent)\\n> **T/S:** O(n)/O(n)\\n```\\nTreeNode prev;\\n\\npublic void flatten(TreeNode root) {\\n\\tif (root == null)\\n\\t\\treturn;\\n\\tflatten(root.right);\\n\\tflatten(root.left);\\n\\troot.right = prev;\\n\\troot.left = null;\\n\\tprev = root;\\n}\\n```\\n\\n**Method 3:** Recursive without global variable\\n> **T/S:** O(n)/O(n)\\n```\\npublic void flatten(TreeNode root) {\\n\\tflatten(root, null);\\n}\\n\\nprivate TreeNode flatten(TreeNode root, TreeNode prev) {\\n\\tif (root == null)\\n\\t\\treturn prev;\\n\\troot.right = flatten(root.left, flatten(root.right, prev));\\n\\troot.left = null;\\n\\treturn root;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Algo:\\n * start with N = root\\n * while N is not null:\\n * 1. Find right most node (RMN) of the left subtree.\\n * 2. do RMN\\'s right child = N\\'s right child\\n * 3. N\\'s right child = N\\'s left child\\n * 4. N\\'s left child = null\\n * 5. N = N.right\\n */\\npublic void flatten(TreeNode root) {\\n\\tfor (; root != null; root = root.right) \\n\\t\\tif (root.left != null) {\\n\\t\\t\\tvar pre = root.left; // right most node in left-sub-tree\\n\\t\\t\\tfor (; pre.right != null; pre = pre.right);             \\n\\t\\t\\tpre.right = root.right;\\n\\t\\t\\troot.right = root.left;\\n\\t\\t\\troot.left = null;    \\n\\t\\t}  \\n}\\n```\n```\\nTreeNode prev;\\n\\npublic void flatten(TreeNode root) {\\n\\tif (root == null)\\n\\t\\treturn;\\n\\tflatten(root.right);\\n\\tflatten(root.left);\\n\\troot.right = prev;\\n\\troot.left = null;\\n\\tprev = root;\\n}\\n```\n```\\npublic void flatten(TreeNode root) {\\n\\tflatten(root, null);\\n}\\n\\nprivate TreeNode flatten(TreeNode root, TreeNode prev) {\\n\\tif (root == null)\\n\\t\\treturn prev;\\n\\troot.right = flatten(root.left, flatten(root.right, prev));\\n\\troot.left = null;\\n\\treturn root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1932080,
                "title": "100-fastest-swift-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func flatten(_ root: TreeNode?) {\\n        var tail: TreeNode?\\n        \\n        func preOrder(_ root: TreeNode?) {\\n            guard let root = root else { return }\\n            \\n            let left = root.left\\n            let right = root.right\\n            \\n            if tail == nil {\\n                tail = root\\n            } else {\\n                tail?.right = root\\n            }\\n            \\n            tail?.left = nil\\n            tail = root\\n            preOrder(left)\\n            preOrder(right)\\n        }\\n        \\n        preOrder(root)\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func flatten(_ root: TreeNode?) {\\n        var tail: TreeNode?\\n        \\n        func preOrder(_ root: TreeNode?) {\\n            guard let root = root else { return }\\n            \\n            let left = root.left\\n            let right = root.right\\n            \\n            if tail == nil {\\n                tail = root\\n            } else {\\n                tail?.right = root\\n            }\\n            \\n            tail?.left = nil\\n            tail = root\\n            preOrder(left)\\n            preOrder(right)\\n        }\\n        \\n        preOrder(root)\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1884701,
                "title": "image-explanation-to-understand-the-recursion-solution",
                "content": "[Leetcode](https://leetcode.com/) [114. Flatten Binary Tree to Linked List](https://leetcode.com/problems/flatten-binary-tree-to-linked-list).\\n\\n\\n***By Frank Luo***\\n\\nThe Binary Tree Traversal Algorithms can be find here [Tree Traversals All In One: PreOrder, InOrder and PostOrder](https://leetcode.com/problems/binary-tree-inorder-traversal/solutions/1860290/tree-traversal-algorithms-preorder-inorder-and-postorder-traverse-algorithms-all-in-one/).\\n\\nWe can use **DFS** to traversal the binary tree.\\n\\nTo **Flatten Binary Tree to Linked List**, there are **3** steps as the picture shows.\\n\\n![DFS](https://assets.leetcode.com/users/images/3dcbb9c1-5c2d-4d9c-930b-bbccf3f7bbe2_1648283800.2439668.png)\\n\\n1. Flatten the left subtree of the root node into a linked list;\\n2. Flatten the right subtree of the root node into a linked list;\\n3. Let the right subtree of the **step 2** be the **right child** of **the farest right node** of the left subtree of **step 1**.\\n\\nObiously, that\\'s a **recursion** process.\\n\\nLet\\'s coding it.\\n\\n```java\\n    public static void flatten_rec(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n\\n\\t\\t// left subtree\\n        flatten_rec(root.left);\\n\\t\\t// right subtree\\n        flatten_rec(root.right);\\n\\n        TreeNode temp = root.right;\\n        root.right = root.left;\\n        root.left = null;\\n\\n        // find the farest right node.\\n        while (root.right != null) {\\n            root = root.right;\\n        }\\n\\n        root.right = temp;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n)$.\\n- **Space Complexity**: $O(n)$.\\n\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```java\\n    public static void flatten_rec(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n\\n\\t\\t// left subtree\\n        flatten_rec(root.left);\\n\\t\\t// right subtree\\n        flatten_rec(root.right);\\n\\n        TreeNode temp = root.right;\\n        root.right = root.left;\\n        root.left = null;\\n\\n        // find the farest right node.\\n        while (root.right != null) {\\n            root = root.right;\\n        }\\n\\n        root.right = temp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1815655,
                "title": "c-using-recursion-iteration-morris-traversal",
                "content": "Flatten Binary Tree to Linked List -\\n\\n**1) Recursion :**\\nT.C. - O(n)\\nS.C. - O(n)\\n```\\nclass Solution {\\n    TreeNode* prev=NULL;\\npublic:\\n    void flatten(TreeNode* root) {\\n         if(root==NULL){return ;}\\n         flatten(root->right);\\n         flatten(root->left);\\n         \\n         root->right=prev;\\n         root->left=NULL;\\n         prev=root;\\n    }    \\n};\\n```\\n\\n**2) Iteration :**\\nT.C. - O(n)\\nS.C. - O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root==NULL){return ;}\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty())\\n        {\\n            TreeNode* curr=st.top();\\n            st.pop();\\n            if(curr->right!=NULL)\\n            {\\n                st.push(curr->right);\\n            }\\n            if(curr->left!=NULL)\\n            {\\n                st.push(curr->left);\\n            }\\n            if(!st.empty())\\n            {\\n                curr->right=st.top();\\n            }\\n           curr->left=NULL; \\n        }\\n    }    \\n};\\n```\\n\\n**3) Morris Traversal :**\\nT.C. - O(n)\\nS.C. - O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n         if(root==NULL){return ;}\\n         TreeNode* curr=root;\\n         while(curr!=NULL)\\n         {\\n             if(curr->left!=NULL)\\n             {\\n                 TreeNode* next=curr->left;\\n                 while(next->right!=NULL)\\n                 {\\n                     next=next->right;\\n                 }\\n                 next->right=curr->right;\\n                 curr->right=curr->left;\\n                 curr->left=NULL;\\n             }\\n            curr=curr->right; \\n         }\\n    }    \\n};\\n```\\n\\nPlease comment if you have any doubt.\\nWill get back to you as soon as possible.\\n**UPVOTE if you find it useful!**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode* prev=NULL;\\npublic:\\n    void flatten(TreeNode* root) {\\n         if(root==NULL){return ;}\\n         flatten(root->right);\\n         flatten(root->left);\\n         \\n         root->right=prev;\\n         root->left=NULL;\\n         prev=root;\\n    }    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root==NULL){return ;}\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty())\\n        {\\n            TreeNode* curr=st.top();\\n            st.pop();\\n            if(curr->right!=NULL)\\n            {\\n                st.push(curr->right);\\n            }\\n            if(curr->left!=NULL)\\n            {\\n                st.push(curr->left);\\n            }\\n            if(!st.empty())\\n            {\\n                curr->right=st.top();\\n            }\\n           curr->left=NULL; \\n        }\\n    }    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n         if(root==NULL){return ;}\\n         TreeNode* curr=root;\\n         while(curr!=NULL)\\n         {\\n             if(curr->left!=NULL)\\n             {\\n                 TreeNode* next=curr->left;\\n                 while(next->right!=NULL)\\n                 {\\n                     next=next->right;\\n                 }\\n                 next->right=curr->right;\\n                 curr->right=curr->left;\\n                 curr->left=NULL;\\n             }\\n            curr=curr->right; \\n         }\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37242,
                "title": "my-simple-c-solution-with-4-ms",
                "content": "//4 ms\\n\\n    void flatten(struct TreeNode* root) {\\n        struct TreeNode* left_r;\\n        while(root!=NULL){\\n            if(root->left != NULL) {\\n            left_r = root->left;\\n            while(left_r->right != NULL) left_r = left_r->right;\\n            left_r->right = root->right;\\n            root->right = root->left;\\n            root->left = NULL;\\n            }\\n            root = root->right;\\n        }\\n    }",
                "solutionTags": [],
                "code": "//4 ms\\n\\n    void flatten(struct TreeNode* root) {\\n        struct TreeNode* left_r;\\n        while(root!=NULL){\\n            if(root->left != NULL) {\\n            left_r = root->left;\\n            while(left_r->right != NULL) left_r = left_r->right;\\n            left_r->right = root->right;\\n            root->right = root->left;\\n            root->left = NULL;\\n            }\\n            root = root->right;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2338673,
                "title": "o-1-morris-traversal-approach-o-n-recursive-o-n-stack",
                "content": "We\\'ll see all the possible approaches for this solution.\\n### **Using Morris Traversal Approach**\\nTime complexity for Morris Traversal approach : O(n)\\nSpace complexity for Morris Traversal approach : O(1)\\n##### *Working of Morris Traversal*\\n1. Move in a tree till you find it\\'s right last node\\n2. Attach that node\\'s left last right node to node\\'s right\\n3. Attach node\\'s left node as it right\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n\\t    //Base condition\\n        if(root==nullptr) return;\\n\\t\\t//temporary node to traverse\\n        TreeNode* cur=root;\\n        while(cur!=nullptr)\\n        {\\n\\t\\t   //if you left child, move in it\\'s subtree till you find it\\'s last right child\\n            if(cur->left!=nullptr)\\n            {\\n                TreeNode* prev=cur->left;\\n                while(prev->right)\\n                    prev=prev->right;\\n\\t\\t\\t\\t//add it\\'s last right node to root right\\n                prev->right=cur->right;\\n\\t\\t\\t\\t//add it\\'s root left to root right. To make it flatten\\n                cur->right=cur->left;\\n\\t\\t\\t\\t//make left node as null\\n                cur->left=nullptr;\\n            }\\n\\t\\t\\t//change temporary node to it\\'s right for next traversal\\n            cur=cur->right;\\n        }\\n        root=cur;\\n    }\\n};\\n```\\n### **Using Recursion**\\nTime complexity for recursive approach : O(n)\\nSpace complexity for recursive approach : O(n)\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* prev=nullptr;\\n    void flatten(TreeNode* node) {\\n        if(node==nullptr)\\n            return;\\n        flatten(node->right);\\n        flatten(node->left);\\n        node->right=prev;\\n        node->left=nullptr;\\n        prev=node;\\n    }\\n};\\n```\\n### **Using Stack**\\nTime complexity for stack approach : O(n)\\nSpace complexity for stack approach : O(n)\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root==nullptr) return;\\n        stack<TreeNode*> s;\\n        s.push(root);  \\n        TreeNode* cur;\\n        while(!s.empty())\\n        {\\n            cur=s.top();\\n            s.pop(); \\n            if(cur->right)\\n                s.push(cur->right);\\n            if(cur->left)\\n                s.push(cur->left);\\n            if(!s.empty())\\n                cur->right=s.top();\\n            cur->left=nullptr;\\n        }\\n        root=cur;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n\\t    //Base condition\\n        if(root==nullptr) return;\\n\\t\\t//temporary node to traverse\\n        TreeNode* cur=root;\\n        while(cur!=nullptr)\\n        {\\n\\t\\t   //if you left child, move in it\\'s subtree till you find it\\'s last right child\\n            if(cur->left!=nullptr)\\n            {\\n                TreeNode* prev=cur->left;\\n                while(prev->right)\\n                    prev=prev->right;\\n\\t\\t\\t\\t//add it\\'s last right node to root right\\n                prev->right=cur->right;\\n\\t\\t\\t\\t//add it\\'s root left to root right. To make it flatten\\n                cur->right=cur->left;\\n\\t\\t\\t\\t//make left node as null\\n                cur->left=nullptr;\\n            }\\n\\t\\t\\t//change temporary node to it\\'s right for next traversal\\n            cur=cur->right;\\n        }\\n        root=cur;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* prev=nullptr;\\n    void flatten(TreeNode* node) {\\n        if(node==nullptr)\\n            return;\\n        flatten(node->right);\\n        flatten(node->left);\\n        node->right=prev;\\n        node->left=nullptr;\\n        prev=node;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root==nullptr) return;\\n        stack<TreeNode*> s;\\n        s.push(root);  \\n        TreeNode* cur;\\n        while(!s.empty())\\n        {\\n            cur=s.top();\\n            s.pop(); \\n            if(cur->right)\\n                s.push(cur->right);\\n            if(cur->left)\\n                s.push(cur->left);\\n            if(!s.empty())\\n                cur->right=s.top();\\n            cur->left=nullptr;\\n        }\\n        root=cur;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207552,
                "title": "c-simple-recursive-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(nullptr == root)\\n            return;\\n        \\n        TreeNode *right_node = root->right;\\n        \\n        //Recursive call on left subtree\\n        flatten(root->left);        \\n        \\n        //Adjust left and right child pointers\\n        root->right = root->left; \\n        root->left = nullptr;\\n        \\n        \\n        while(root->right)\\n            root = root->right;\\n        \\n        //Recursive call on right subtree\\n        flatten(right_node);        \\n        \\n        //Adjust right child pointer node\\n        root->right = right_node;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(nullptr == root)\\n            return;\\n        \\n        TreeNode *right_node = root->right;\\n        \\n        //Recursive call on left subtree\\n        flatten(root->left);        \\n        \\n        //Adjust left and right child pointers\\n        root->right = root->left; \\n        root->left = nullptr;\\n        \\n        \\n        while(root->right)\\n            root = root->right;\\n        \\n        //Recursive call on right subtree\\n        flatten(right_node);        \\n        \\n        //Adjust right child pointer node\\n        root->right = right_node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1096456,
                "title": "python-3-solutions-iteration-and-recursion",
                "content": "iteration:\\n```\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        #\\n        ## iteration\\n        # For each node cur, if it has a left subtree, we put it on the right\\n        # subtree of the node cur, and we put the right subtree of the node cur\\n        # at the right bottom of the left subtree. \\n        cur = root\\n        while cur:\\n            if cur.left:\\n                left = cur.left        # get the left subtree of cur\\n                right = cur.right      # get the right subtree of cur\\n                cur.left = None        # cur\\'s left subtree set to be None\\n                cur.right = left       # switch the left subtree to the right subtree\\n                while left.right:      # get the far-rigth leaf of the left subtree\\n                    left = left.right  \\n                left.right = right     # put the right subtree of cur as the right subtree of the far-right leaf\\n            cur = cur.right            # go down the right direction\\n```\\nrecursion\\n```\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.prev = None\\n    \\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        #\\n        ## recursion\\n        if not root:\\n            pass\\n        else:\\n            self.flatten(root.right)\\n            self.flatten(root.left)\\n            root.right = self.prev\\n            root.left = None\\n            self.prev = root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        #\\n        ## iteration\\n        # For each node cur, if it has a left subtree, we put it on the right\\n        # subtree of the node cur, and we put the right subtree of the node cur\\n        # at the right bottom of the left subtree. \\n        cur = root\\n        while cur:\\n            if cur.left:\\n                left = cur.left        # get the left subtree of cur\\n                right = cur.right      # get the right subtree of cur\\n                cur.left = None        # cur\\'s left subtree set to be None\\n                cur.right = left       # switch the left subtree to the right subtree\\n                while left.right:      # get the far-rigth leaf of the left subtree\\n                    left = left.right  \\n                left.right = right     # put the right subtree of cur as the right subtree of the far-right leaf\\n            cur = cur.right            # go down the right direction\\n```\n```\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.prev = None\\n    \\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        #\\n        ## recursion\\n        if not root:\\n            pass\\n        else:\\n            self.flatten(root.right)\\n            self.flatten(root.left)\\n            root.right = self.prev\\n            root.left = None\\n            self.prev = root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1023755,
                "title": "c-pre-order-solution-explained-100-time-97-space",
                "content": "My first approach was to store all the nodes using a pre-order traversal and then re-\"align\" them as requested.\\n\\nTo do so, we will need 2 class variables:\\n* `q`, an array of `2000` `TreeNode` pointers;\\n* `pos`, an index to be used on said array, initialised to `0`.\\n\\nIn our main function, we will first of all call `dfs` passing `root`.\\n\\nIn `dfs` we will:\\n* just `return` when `root` is `NULL`;\\n* add `root` to `q` and increase `pos` accordingly;\\n* call `dfs` recursively on both the `left` and `right` branch - handbook pre-order here.\\n\\nOnce done, back to our main function, we will just loop through all the elements stored in `q` and put them all one on the right of the other, removing every `left` child they might have, and we are done :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* q[2000];\\n    int pos = 0;\\n    void dfs(TreeNode* root) {\\n        if (!root) return;\\n        q[pos++] = root;\\n        dfs(root->left);\\n        dfs(root->right);\\n    }\\n    void flatten(TreeNode* root) {\\n        dfs(root);\\n        for (int i = 1; i < pos; i++) {\\n            q[i - 1]->right = q[i];\\n            q[i - 1]->left = NULL;\\n        }\\n    }\\n};\\n```\\n\\nWas I satisfied? Nah!\\n\\nI wanted to do something cooler, without (explicitly) storing the nodes and then I went to create another solution.\\n\\nIn this version all the magic will be in `dfs`, that we will call only when have `root` (our recursion invariant is that `root` has to always be a non-`NULL` node).\\n\\nOur `dfs` function now has a return value and, more specifically, will always return the last node of the transformation.\\n\\nIn its body, will:\\n* check if the current `root` is childless, in which case we return it (since it is also the last node);\\n* otherwise, we:\\n\\t*  declare a `TreeNode` pointer `res`;\\n\\t*  check if we have a `right` branch and in case give it the value of `dfs(root->right)`;\\n\\t*  check if we have a `left` branch and in case:\\n\\t\\t*  assign the value of `dfss(root->left)` to `tmp`;\\n\\t\\t*  check if we have `root->right` and in case:\\n\\t\\t\\t*  set `tmp->right` to be `root->right`\\n\\t\\t\\t*  set `res` to be `tmp` otherwise;\\n\\t\\t*  attach the now flattend `root->left` to the `right` of `root`;\\n\\t\\t*  remove the `left` branch.\\n\\nFinally, we return `res` :)\\n\\nThe code (which seems a bit faster, but overall pretty comparable in terms of performance):\\n\\n```cpp\\nclass Solution {\\npublic:  \\n    TreeNode* dfs(TreeNode* root) {\\n        // edge case: childless node\\n        if (!root->left && !root->right) return root;\\n        TreeNode* res;\\n        if (root->right) {\\n            // res set to be the last node of the right branch\\n            res = dfs(root->right);\\n        }\\n        if (root->left) {\\n            // tmp is the last node on the flattened left branch\\n            TreeNode* tmp = dfs(root->left);\\n            // attaching the right branch at the end of it, if any\\n            if (root->right) tmp->right = root->right;\\n            // otherwise, tmp->second is our last node\\n            else res = tmp;\\n            // attaching the flattened left branch directly to the right of root\\n            root->right = root->left;\\n            // removing the left branch\\n            root->left = NULL;\\n        }\\n        return res;\\n    }\\n    void flatten(TreeNode* root) {\\n        if (root) dfs(root);\\n    }\\n};\\n```\\n\\nWas I satisfied?\\n\\nNope: I gave myself the challenge of doing without extra variables (no `res` and no `temp`) and I did it!\\n\\nThe code is a refactoring of the previous and it turns consistently faster:\\n\\n```cpp\\nclass Solution {\\npublic:  \\n    TreeNode* dfs(TreeNode* root) {\\n        // edge case: childless node\\n        if (!root->left && !root->right) return root;\\n        if (root->left) {\\n            // first case: only the left branch\\n            if (!root->right) {\\n                // attaching the flattened left branch directly to the right of root\\n                root->right = root->left;\\n                // removing the left branch\\n                root->left = NULL;\\n                // returning the last node of the new right branch (previous left)\\n                return dfs(root->right);\\n            }\\n            // attaching right to the end of the flatened left branch\\n            dfs(root->left)->right = root->right;\\n            // attaching the flattened left branch directly to the right of root\\n            root->right = root->left;\\n            // removing the left branch\\n            root->left = NULL;\\n        }\\n        // if we do not have a left branch, we can just return the flattened right\\n        return dfs(root->right);\\n    }\\n    void flatten(TreeNode* root) {\\n        if (root) dfs(root);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    TreeNode* q[2000];\\n    int pos = 0;\\n    void dfs(TreeNode* root) {\\n        if (!root) return;\\n        q[pos++] = root;\\n        dfs(root->left);\\n        dfs(root->right);\\n    }\\n    void flatten(TreeNode* root) {\\n        dfs(root);\\n        for (int i = 1; i < pos; i++) {\\n            q[i - 1]->right = q[i];\\n            q[i - 1]->left = NULL;\\n        }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:  \\n    TreeNode* dfs(TreeNode* root) {\\n        // edge case: childless node\\n        if (!root->left && !root->right) return root;\\n        TreeNode* res;\\n        if (root->right) {\\n            // res set to be the last node of the right branch\\n            res = dfs(root->right);\\n        }\\n        if (root->left) {\\n            // tmp is the last node on the flattened left branch\\n            TreeNode* tmp = dfs(root->left);\\n            // attaching the right branch at the end of it, if any\\n            if (root->right) tmp->right = root->right;\\n            // otherwise, tmp->second is our last node\\n            else res = tmp;\\n            // attaching the flattened left branch directly to the right of root\\n            root->right = root->left;\\n            // removing the left branch\\n            root->left = NULL;\\n        }\\n        return res;\\n    }\\n    void flatten(TreeNode* root) {\\n        if (root) dfs(root);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:  \\n    TreeNode* dfs(TreeNode* root) {\\n        // edge case: childless node\\n        if (!root->left && !root->right) return root;\\n        if (root->left) {\\n            // first case: only the left branch\\n            if (!root->right) {\\n                // attaching the flattened left branch directly to the right of root\\n                root->right = root->left;\\n                // removing the left branch\\n                root->left = NULL;\\n                // returning the last node of the new right branch (previous left)\\n                return dfs(root->right);\\n            }\\n            // attaching right to the end of the flatened left branch\\n            dfs(root->left)->right = root->right;\\n            // attaching the flattened left branch directly to the right of root\\n            root->right = root->left;\\n            // removing the left branch\\n            root->left = NULL;\\n        }\\n        // if we do not have a left branch, we can just return the flattened right\\n        return dfs(root->right);\\n    }\\n    void flatten(TreeNode* root) {\\n        if (root) dfs(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008188,
                "title": "cpp-solution-using-preorder-vector",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    void preorder(TreeNode* root)\\n    {\\n        if(!root)\\n            return ;\\n        v.push_back(root->val);\\n        preorder(root->left);\\n        preorder(root->right);\\n    }\\n   \\n \\n    \\n    TreeNode* tree(vector<int> v)\\n    {\\n        if(v.size()==0)\\n            return NULL;\\n        TreeNode* r=new TreeNode(v[0]);\\n        TreeNode* temp=r;\\n        for(int i=1;i<v.size();i++){\\n            temp->left=NULL;\\n            temp->right=new TreeNode(v[i]);\\n            temp=temp->right;}\\n        return r ;\\n    }\\n    \\n    \\n    void flatten(TreeNode* root) {\\n        if(root==NULL){\\n            return ;\\n        }\\n        //vector preorder transveral\\n         preorder(root);\\n        //make a new tree using vector\\n        TreeNode* r= tree(v);\\n        root->right=r->right;\\n        root->left=NULL;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    void preorder(TreeNode* root)\\n    {\\n        if(!root)\\n            return ;\\n        v.push_back(root->val);\\n        preorder(root->left);\\n        preorder(root->right);\\n    }\\n   \\n \\n    \\n    TreeNode* tree(vector<int> v)\\n    {\\n        if(v.size()==0)\\n            return NULL;\\n        TreeNode* r=new TreeNode(v[0]);\\n        TreeNode* temp=r;\\n        for(int i=1;i<v.size();i++){\\n            temp->left=NULL;\\n            temp->right=new TreeNode(v[i]);\\n            temp=temp->right;}\\n        return r ;\\n    }\\n    \\n    \\n    void flatten(TreeNode* root) {\\n        if(root==NULL){\\n            return ;\\n        }\\n        //vector preorder transveral\\n         preorder(root);\\n        //make a new tree using vector\\n        TreeNode* r= tree(v);\\n        root->right=r->right;\\n        root->left=NULL;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 482065,
                "title": "intuitive-javascript-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {void} Do not return anything, modify root in-place instead.\\n */\\nvar flatten = function(root) {\\n    // right, left, root -> postorder dfs\\n    // set left child to null & set right child to the previous node\\n    let prev = null;\\n    const traverse = node => {\\n        if (node === null) {\\n            return;\\n        }\\n        \\n        traverse(node.right);\\n        traverse(node.left);\\n        \\n        // task\\n        node.left = null;\\n        node.right = prev;\\n        prev = node;\\n        \\n    } \\n    \\n    traverse(root);\\n      \\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {void} Do not return anything, modify root in-place instead.\\n */\\nvar flatten = function(root) {\\n    // right, left, root -> postorder dfs\\n    // set left child to null & set right child to the previous node\\n    let prev = null;\\n    const traverse = node => {\\n        if (node === null) {\\n            return;\\n        }\\n        \\n        traverse(node.right);\\n        traverse(node.left);\\n        \\n        // task\\n        node.left = null;\\n        node.right = prev;\\n        prev = node;\\n        \\n    } \\n    \\n    traverse(root);\\n      \\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 268085,
                "title": "divide-and-conquer-postorder-solution",
                "content": "The idea is \\n1. convert left subtree into a list; \\n2. convert right into a list; \\n3. connect root with leftList.head and then leftList.tail to rightList.head. \\n\\nThe key is to find the head and tail of each converted list. Good news is that head is always root, we only to figure out how to get the tail. The idea is that if the tail of right subtree is not null, we\\'ve got the answer, otherwise, tail of left subtree, or root.\\n```\\npublic void flatten(TreeNode root) {\\n        flattenAndGetTail(root);    \\n    }\\n    public TreeNode flattenAndGetTail(TreeNode root)\\n    {\\n        if(root==null) return null;\\n        \\n        TreeNode leftTail = flattenAndGetTail(root.left);\\n        TreeNode rightTail = flattenAndGetTail(root.right);\\n        \\n        if(leftTail!=null)\\n        {\\n            leftTail.right = root.right;\\n            root.right = root.left;\\n            root.left = null;\\n        }\\n        \\n        if(rightTail!=null) return rightTail;\\n        if(leftTail!=null) return leftTail;\\n        return root;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic void flatten(TreeNode root) {\\n        flattenAndGetTail(root);    \\n    }\\n    public TreeNode flattenAndGetTail(TreeNode root)\\n    {\\n        if(root==null) return null;\\n        \\n        TreeNode leftTail = flattenAndGetTail(root.left);\\n        TreeNode rightTail = flattenAndGetTail(root.right);\\n        \\n        if(leftTail!=null)\\n        {\\n            leftTail.right = root.right;\\n            root.right = root.left;\\n            root.left = null;\\n        }\\n        \\n        if(rightTail!=null) return rightTail;\\n        if(leftTail!=null) return leftTail;\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 36980,
                "title": "clean-straight-forward-postorder-solution-easy-to-understand",
                "content": "I came up with another postorder solution, the idea is simple:\\n(1) flatten left subtree, return its tail node 'leftTail'\\n(2) flatten right subtree, return its tail node 'rightTail'\\n(3) if left subtree exists and has been flattened, we need to move it to the right:\\nset flattened right subtree as leftTail.right\\nset flattened left subtree to be the new right subtree(root.right)\\nset root.left=null\\n(4) return the tail node of this flattened tree (return rightTail if it isn't null, else return leftTail if it isn't null, else return root)\\n![0_1507853437658_Screen Shot 2017-10-12 at 5.10.04 PM.png](/assets/uploads/files/1507853438122-screen-shot-2017-10-12-at-5.10.04-pm.png) \\nI change the return type in order to keep only one recursive fuction, it works for leetcode:)\\n\\n    public TreeNode flatten(TreeNode root) {\\n        if(root==null) return null;\\n        TreeNode leftTail = flatten(root.left);\\n        TreeNode rightTail = flatten(root.right);        \\n        if(root.left!=null) {\\n            leftTail.right = root.right;\\n            root.right=root.left;\\n            root.left=null;\\n        }        \\n        return rightTail!=null?rightTail:(leftTail!=null?leftTail:root);\\n    }",
                "solutionTags": [],
                "code": "I came up with another postorder solution, the idea is simple:\\n(1) flatten left subtree, return its tail node 'leftTail'\\n(2) flatten right subtree, return its tail node 'rightTail'\\n(3) if left subtree exists and has been flattened, we need to move it to the right:\\nset flattened right subtree as leftTail.right\\nset flattened left subtree to be the new right subtree(root.right)\\nset root.left=null\\n(4) return the tail node of this flattened tree (return rightTail if it isn't null, else return leftTail if it isn't null, else return root)\\n![0_1507853437658_Screen Shot 2017-10-12 at 5.10.04 PM.png](/assets/uploads/files/1507853438122-screen-shot-2017-10-12-at-5.10.04-pm.png) \\nI change the return type in order to keep only one recursive fuction, it works for leetcode:)\\n\\n    public TreeNode flatten(TreeNode root) {\\n        if(root==null) return null;\\n        TreeNode leftTail = flatten(root.left);\\n        TreeNode rightTail = flatten(root.right);        \\n        if(root.left!=null) {\\n            leftTail.right = root.right;\\n            root.right=root.left;\\n            root.left=null;\\n        }        \\n        return rightTail!=null?rightTail:(leftTail!=null?leftTail:root);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2338726,
                "title": "python3-recursive-approach",
                "content": "```\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.prev = None\\n    \\n    def flatten(self, root):\\n        if not root:\\n            return None\\n        self.flatten(root.right)\\n        self.flatten(root.left)\\n\\n        root.right = self.prev\\n        root.left = None\\n        self.prev = root\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.prev = None\\n    \\n    def flatten(self, root):\\n        if not root:\\n            return None\\n        self.flatten(root.right)\\n        self.flatten(root.left)\\n\\n        root.right = self.prev\\n        root.left = None\\n        self.prev = root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325131,
                "title": "python-dfs",
                "content": "* Python DFS solution 1 with run time O(T), space O(T)\\n\\n```\\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        dfs = []\\n        dfs.append(root)\\n        while root and dfs:\\n            root = dfs.pop()\\n            if root.right:\\n                dfs.append(root.right)\\n            if root.left:\\n                dfs.append(root.left)\\n                root.right = root.left\\n                root.left = None\\n            else:\\n                if dfs:\\n                    root.right = dfs[-1]\\n                    root.left = None\\n```\\n* Python DFS solution 2 with run time O(T), space O(1) (O(maxDepth) including calling stack by recursion)\\n```\\nclass Solution:\\n    dummy = TreeNode(None)\\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        ans = self.dummy\\n        self.MFS(root)\\n    \\n    def MFS(self,root):\\n        if not root:\\n            return\\n        # print(root.val)\\n        self.dummy.left = None\\n        self.dummy.right = root\\n        self.dummy = root\\n        l, r = root.left, root.right\\n        self.MFS(l)\\n        self.MFS(r)\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        dfs = []\\n        dfs.append(root)\\n        while root and dfs:\\n            root = dfs.pop()\\n            if root.right:\\n                dfs.append(root.right)\\n            if root.left:\\n                dfs.append(root.left)\\n                root.right = root.left\\n                root.left = None\\n            else:\\n                if dfs:\\n                    root.right = dfs[-1]\\n                    root.left = None\\n```\n```\\nclass Solution:\\n    dummy = TreeNode(None)\\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        ans = self.dummy\\n        self.MFS(root)\\n    \\n    def MFS(self,root):\\n        if not root:\\n            return\\n        # print(root.val)\\n        self.dummy.left = None\\n        self.dummy.right = root\\n        self.dummy = root\\n        l, r = root.left, root.right\\n        self.MFS(l)\\n        self.MFS(r)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 37280,
                "title": "an-standard-recursive-dfs-solution",
                "content": "    void flatten(TreeNode *root) {\\n        dfs(root);\\n    }\\n    \\n    TreeNode *dfs(TreeNode *root) {\\n        if (!root) return root;\\n        \\n        TreeNode *cur = root;\\n        TreeNode *left = dfs(root->left);\\n        TreeNode *right = dfs(root->right);\\n        \\n        if (left) {\\n            cur->left = NULL;\\n            cur->right = left; // set right pointer of the root node\\n            while (cur->right) cur = cur->right; // get the last node of the left side\\n        }\\n        \\n        cur->right = right; // right pointer of the last node of the left side\\n        return root;\\n    }",
                "solutionTags": [],
                "code": "    void flatten(TreeNode *root) {\\n        dfs(root);\\n    }\\n    \\n    TreeNode *dfs(TreeNode *root) {\\n        if (!root) return root;\\n        \\n        TreeNode *cur = root;\\n        TreeNode *left = dfs(root->left);\\n        TreeNode *right = dfs(root->right);\\n        \\n        if (left) {\\n            cur->left = NULL;\\n            cur->right = left; // set right pointer of the root node\\n            while (cur->right) cur = cur->right; // get the last node of the left side\\n        }\\n        \\n        cur->right = right; // right pointer of the last node of the left side\\n        return root;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3030571,
                "title": "c-beginner-friendly-two-solutions-o-n-o-1-space-complexity",
                "content": "**If You Helped, Please Upvote**\\n#### Brute Force\\n* Time Complexity = `O(N)`\\n* Space Complexity = `O(N)`\\n\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> order;\\n    void preorder(TreeNode* root) {\\n        if(!root) return;\\n        order.push_back(root);\\n        preorder(root->left);\\n        preorder(root->right);\\n    }\\n\\n    void flatten(TreeNode* root) {\\n        preorder(root);\\n        for(int i = 1; i < order.size(); i++) {\\n            order[i-1] -> left = nullptr;\\n            order[i-1] -> right = order[i];\\n        }\\n    }\\n};\\n```\\n\\n#### Better Solution\\n* Time Complexity = `O(N)`\\n* Space Complexity = `O(1)`\\n\\n```\\nclass Solution {\\npublic:\\n     void flatten(TreeNode* root) {\\n        auto now = root;\\n\\n        while(now) {\\n            if(now -> left) {\\n                auto prev = now -> left;\\n                while(prev -> right) prev = prev -> right;\\n                prev -> right = now -> right;\\n                now -> right = now -> left;\\n                now -> left = nullptr;\\n            }\\n            now = now -> right;\\n        }\\n     }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> order;\\n    void preorder(TreeNode* root) {\\n        if(!root) return;\\n        order.push_back(root);\\n        preorder(root->left);\\n        preorder(root->right);\\n    }\\n\\n    void flatten(TreeNode* root) {\\n        preorder(root);\\n        for(int i = 1; i < order.size(); i++) {\\n            order[i-1] -> left = nullptr;\\n            order[i-1] -> right = order[i];\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n     void flatten(TreeNode* root) {\\n        auto now = root;\\n\\n        while(now) {\\n            if(now -> left) {\\n                auto prev = now -> left;\\n                while(prev -> right) prev = prev -> right;\\n                prev -> right = now -> right;\\n                now -> right = now -> left;\\n                now -> left = nullptr;\\n            }\\n            now = now -> right;\\n        }\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362469,
                "title": "python-explained-recursion-faster-than-99-simple-solution",
                "content": "![image](https://assets.leetcode.com/users/images/cb226ebe-d627-43a3-8d8f-86a1b2402d84_1659325499.174214.png)\\n\\n```\\nclass Solution:\\n    def flatten(self, root: Optional[TreeNode]) -> None:\\n\\n        # check if root exists\\n        if root:\\n            \\n            temp = root.right # store the right part of root\\n            \\n            root.right = root.left  # move the left part to the right\\n            root.left = None        # clear left part\\n            \\n            curr = root\\n            while curr.right:       # use while loop to find the bottom right side\\n                curr = curr.right\\n            curr.right = temp       # attach temp back\\n            \\n            #recursion\\n            self.flatten(root.right)\\n```\\nPlease UPVOTE if you like !!",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def flatten(self, root: Optional[TreeNode]) -> None:\\n\\n        # check if root exists\\n        if root:\\n            \\n            temp = root.right # store the right part of root\\n            \\n            root.right = root.left  # move the left part to the right\\n            root.left = None        # clear left part\\n            \\n            curr = root\\n            while curr.right:       # use while loop to find the bottom right side\\n                curr = curr.right\\n            curr.right = temp       # attach temp back\\n            \\n            #recursion\\n            self.flatten(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2341115,
                "title": "c-fastest-and-easy-to-understand-solution-with-line-by-line-explanation",
                "content": "Just do the preorder traversal and make the neccsary changes in the links\\nSee the C++ solution below\\n\\n```\\nclass Solution {\\npublic:\\n    void pre(TreeNode* root,TreeNode* &prev)\\n    {\\n        if(root==NULL)\\n            return;\\n        TreeNode* left = root->left; // store the values of left and right childs\\n        TreeNode* right = root->right;// as we are changing the links afterwards any may loose our original links\\n        if(prev == NULL) // if prev is NULL this means it is our head of the linked list\\n        {\\n            prev = root;\\n        }\\n        else // if not NULL then we need to make the required changes\\n        {\\n            prev->left = NULL;  // we make the left of prev as NULL\\n            prev->right = root; // and right of prev as current element\\n            prev = root; // Now make the current element as prev for further iterations\\n        }\\n        pre(left,prev); // simply do calls on left \\n        pre(right,prev);// and right child \\n    }\\n    void flatten(TreeNode* root) {\\n        TreeNode *prev = NULL; // prev stores the previous element in the preorder traversal\\n        pre(root,prev);\\n        \\n    }\\n};\\n```\\n\\nPlease upvote if you liked the solution. It really motivates me to post more solutions.",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void pre(TreeNode* root,TreeNode* &prev)\\n    {\\n        if(root==NULL)\\n            return;\\n        TreeNode* left = root->left; // store the values of left and right childs\\n        TreeNode* right = root->right;// as we are changing the links afterwards any may loose our original links\\n        if(prev == NULL) // if prev is NULL this means it is our head of the linked list\\n        {\\n            prev = root;\\n        }\\n        else // if not NULL then we need to make the required changes\\n        {\\n            prev->left = NULL;  // we make the left of prev as NULL\\n            prev->right = root; // and right of prev as current element\\n            prev = root; // Now make the current element as prev for further iterations\\n        }\\n        pre(left,prev); // simply do calls on left \\n        pre(right,prev);// and right child \\n    }\\n    void flatten(TreeNode* root) {\\n        TreeNode *prev = NULL; // prev stores the previous element in the preorder traversal\\n        pre(root,prev);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1556044,
                "title": "c-recursive-and-morris-traversal-code-o-1-space",
                "content": "**Recursive solution space:O(n)**\\n```\\n void flatten(TreeNode* root) {\\n        if(!root){\\n            return ;\\n        }\\n        if(root->left){\\n            TreeNode* pred = root->left;\\n            while(pred->right){\\n                pred = pred->right;\\n            }\\n            pred->right = root->right;\\n            root->right = root->left;\\n            root->left = nullptr;\\n        }\\n        flatten(root->right);\\n    }\\n```\\n\\n**Constant space O(1) - Morris traversal implementation**\\n\\t\\n```\\n\\t void flatten(TreeNode* root) {\\n     if(!root){\\n         return;\\n     }   \\n        \\n     while(root){\\n         if(root->left){\\n         TreeNode* iter = root->left;\\n         while(iter->right){\\n             iter = iter->right;\\n         }\\n          iter->right = root->right;\\n          root->right = root->left;\\n          root->left = nullptr;\\n         }\\n         root  = root->right;\\n     }\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n void flatten(TreeNode* root) {\\n        if(!root){\\n            return ;\\n        }\\n        if(root->left){\\n            TreeNode* pred = root->left;\\n            while(pred->right){\\n                pred = pred->right;\\n            }\\n            pred->right = root->right;\\n            root->right = root->left;\\n            root->left = nullptr;\\n        }\\n        flatten(root->right);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1538893,
                "title": "easy-and-clean-c-code-o-1-space-just-do-reverse-preorder-traversal",
                "content": "```\\nclass Solution {\\n    \\n    void solve(TreeNode* root , TreeNode* &prev)\\n    {\\n          if(root == NULL) return ;\\n        \\n          solve(root->right , prev ) ;\\n          solve(root->left , prev ) ;\\n        \\n          root->right = prev ;\\n          root->left = NULL ;\\n        \\n          prev = root ;\\n          \\n    }\\n    \\npublic:\\n    void flatten(TreeNode* root) {\\n        \\n        TreeNode* prev = NULL ;\\n        solve(root , prev) ;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    void solve(TreeNode* root , TreeNode* &prev)\\n    {\\n          if(root == NULL) return ;\\n        \\n          solve(root->right , prev ) ;\\n          solve(root->left , prev ) ;\\n        \\n          root->right = prev ;\\n          root->left = NULL ;\\n        \\n          prev = root ;\\n          \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 870784,
                "title": "python-very-easy-to-understand-pre-order-traversal",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        if not root:\\n            return\\n\\n        nodes = []\\n        stack = [root]\\n        while stack:\\n            node = stack.pop()\\n            if not node:\\n                continue\\n            nodes.append(node)\\n            stack.append(node.right)\\n            stack.append(node.left)\\n\\n        root = nodes.pop(0)\\n        for node in nodes:\\n            root.right = node\\n            root.left = None\\n            root = node\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        if not root:\\n            return\\n\\n        nodes = []\\n        stack = [root]\\n        while stack:\\n            node = stack.pop()\\n            if not node:\\n                continue\\n            nodes.append(node)\\n            stack.append(node.right)\\n            stack.append(node.left)\\n\\n        root = nodes.pop(0)\\n        for node in nodes:\\n            root.right = node\\n            root.left = None\\n            root = node\\n```",
                "codeTag": "Java"
            },
            {
                "id": 307669,
                "title": "javascript-recursive-reverse-traversal",
                "content": "Inspired by this solution https://leetcode.com/problems/convert-bst-to-greater-tree/discuss/197556/Javascript-very-fast-solution\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {void} Do not return anything, modify root in-place instead.\\n */\\nvar flatten = function(root) {\\n    let nextOne = null;\\n    \\n    const update = node => {\\n        if (!node) return node;\\n        \\n        update(node.right);\\n        update(node.left);\\n        node.right = nextOne;\\n        node.left = null;\\n        nextOne = node;   \\n    }\\n    \\n    update(root);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {void} Do not return anything, modify root in-place instead.\\n */\\nvar flatten = function(root) {\\n    let nextOne = null;\\n    \\n    const update = node => {\\n        if (!node) return node;\\n        \\n        update(node.right);\\n        update(node.left);\\n        node.right = nextOne;\\n        node.left = null;\\n        nextOne = node;   \\n    }\\n    \\n    update(root);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 37195,
                "title": "concise-java-recursive-solution",
                "content": "    \\tpublic void flatten(TreeNode root) {\\n\\t\\tif (root == null)\\n\\t\\t\\treturn;\\n\\n\\t\\tflatten(root.left);\\n\\t\\tflatten(root.right);\\n\\t\\tTreeNode left = root.left;\\n\\t\\tTreeNode right = root.right;\\n\\t\\troot.left = null;\\n\\t\\troot.right = left;\\n\\t\\twhile (root.right != null)\\n\\t\\t\\troot = root.right;\\n\\t\\troot.right = right;\\n\\t}",
                "solutionTags": [],
                "code": "    \\tpublic void flatten(TreeNode root) {\\n\\t\\tif (root == null)\\n\\t\\t\\treturn;\\n\\n\\t\\tflatten(root.left);\\n\\t\\tflatten(root.right);\\n\\t\\tTreeNode left = root.left;\\n\\t\\tTreeNode right = root.right;\\n\\t\\troot.left = null;\\n\\t\\troot.right = left;\\n\\t\\twhile (root.right != null)\\n\\t\\t\\troot = root.right;\\n\\t\\troot.right = right;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 37214,
                "title": "python-recursive-solution-with-comments",
                "content": "        \\n    # recusively       \\n    def flatten1(self, root):\\n        self.helper(root)\\n        \\n    def helper(self, root):\\n        if not root:\\n            return\\n        l = self.helper(root.left)\\n        r = self.helper(root.right)\\n        if l:\\n            root.right = l\\n            while l and l.right:\\n                l = l.right\\n            l.right = r\\n            root.left = None # take care here\\n        return root\\n        \\n    # recusively\\n    def flatten(self, root):\\n        if not root:\\n            return \\n        # flatten left child \\n        self.flatten(root.left)\\n        # flatten right child\\n        self.flatten(root.right)\\n        # insert left child to the middle of \\n        # root and right child\\n        tail = root.left\\n        if tail:\\n            while tail and tail.right:\\n                tail = tail.right\\n            tail.right = root.right\\n            root.right = root.left\\n            root.left = None",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "        \\n    # recusively       \\n    def flatten1(self, root):\\n        self.helper(root)\\n        \\n    def helper(self, root):\\n        if not root:\\n            return\\n        l = self.helper(root.left)\\n        r = self.helper(root.right)\\n        if l:\\n            root.right = l\\n            while l and l.right:\\n                l = l.right\\n            l.right = r\\n            root.left = None # take care here\\n        return root\\n        \\n    # recusively\\n    def flatten(self, root):\\n        if not root:\\n            return \\n        # flatten left child \\n        self.flatten(root.left)\\n        # flatten right child\\n        self.flatten(root.right)\\n        # insert left child to the middle of \\n        # root and right child\\n        tail = root.left\\n        if tail:\\n            while tail and tail.right:\\n                tail = tail.right\\n            tail.right = root.right\\n            root.right = root.left\\n            root.left = None",
                "codeTag": "Python3"
            },
            {
                "id": 37238,
                "title": "pre-order-solution",
                "content": "use a pointer \"pre\", then  pre order the tree.\\n\\n    void flatten(TreeNode* root) {\\n        if (!root) return;\\n        TreeNode dummy(-1), *pre = &dummy;\\n        flatten(root, pre);\\n    }\\n    \\n    void flatten(TreeNode* root, TreeNode* &pre) {\\n        if (!root) return;\\n        TreeNode *rightChild = root->right;\\n        pre->right = root;\\n        pre->left = NULL;\\n        pre = root;\\n        flatten(root->left, pre);\\n        flatten(rightChild, pre);\\n    }",
                "solutionTags": [],
                "code": "use a pointer \"pre\", then  pre order the tree.\\n\\n    void flatten(TreeNode* root) {\\n        if (!root) return;\\n        TreeNode dummy(-1), *pre = &dummy;\\n        flatten(root, pre);\\n    }\\n    \\n    void flatten(TreeNode* root, TreeNode* &pre) {\\n        if (!root) return;\\n        TreeNode *rightChild = root->right;\\n        pre->right = root;\\n        pre->left = NULL;\\n        pre = root;\\n        flatten(root->left, pre);\\n        flatten(rightChild, pre);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3820585,
                "title": "2-methods-explained-easy-code-c-beats-100",
                "content": "# Method #1: \\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Make a helper function to do all tasks neatly \\uD83D\\uDE01\\n- Let\\'s say the root is **NULL** return (nothing to do \\uD83E\\uDD73)\\n- And if a single node present (nothing to do)\\n- Otherwise we need to make cases and understand.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We can create a function for handling the cases and it will return pair of treeNode.\\n- Store the result from the left and right using recursion.\\n- Cases\\n    - Let\\'s say the left is NULL:\\n        - Now the right of root should connects from right-head.\\n        - Return root, tail-right\\n        \\n- Make root->left = NULL\\n    - Else:\\n        - Root right will be the head-left, and if right-head is NULL:\\n            - Return root, tail-left\\n        - else \\n            - Root right should connect with left-head\\n            - And in right of left-tail there should be right-head.\\n            - Return root, right-tail \\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) or stack space = O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        go(root);\\n    }\\n\\n    pair<TreeNode*, TreeNode*> go(TreeNode* root){\\n        if(!root){\\n            return {root, root};\\n        }\\n        if(!root->left && !root->right){\\n            return {root, root};\\n        }\\n\\n        pair<TreeNode*, TreeNode*> left = go(root->left);\\n        pair<TreeNode*, TreeNode*> right = go(root->right);\\n        \\n        TreeNode *headl = left.first;\\n        TreeNode *headr = right.first;\\n        TreeNode *taill = left.second;\\n        TreeNode *tailr = right.second;\\n\\n        if(!root->left){\\n            root->right = headr;\\n            return {root, tailr};\\n        }\\n        root->left = NULL;\\n\\n        if(!headr){\\n            root->right = headl;\\n            return {root, taill};\\n        }else{\\n            root->right = headl;\\n            taill->right = headr;\\n            return {root, tailr};\\n        }    \\n    }\\n};\\n```\\n\\n\\n\\n# Method #2: \\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Use **Morris Traversal**\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    TreeNode *findPredicate(TreeNode *curr){\\n        curr=curr->left;\\n        while(curr->right!=NULL){\\n            curr=curr->right;\\n        }\\n        return curr;\\n    }\\n\\n    void flatten(TreeNode *root){\\n        TreeNode *curr=root;\\n        while(curr!=NULL){\\n            if(curr->left){\\n                TreeNode *pred=findPredicate(curr);\\n                pred->right=curr->right;\\n                curr->right=curr->left;\\n                curr->left=NULL;\\n            }\\n            \\n        curr=curr->right;\\n        }\\n    \\n        return;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Stack",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        go(root);\\n    }\\n\\n    pair<TreeNode*, TreeNode*> go(TreeNode* root){\\n        if(!root){\\n            return {root, root};\\n        }\\n        if(!root->left && !root->right){\\n            return {root, root};\\n        }\\n\\n        pair<TreeNode*, TreeNode*> left = go(root->left);\\n        pair<TreeNode*, TreeNode*> right = go(root->right);\\n        \\n        TreeNode *headl = left.first;\\n        TreeNode *headr = right.first;\\n        TreeNode *taill = left.second;\\n        TreeNode *tailr = right.second;\\n\\n        if(!root->left){\\n            root->right = headr;\\n            return {root, tailr};\\n        }\\n        root->left = NULL;\\n\\n        if(!headr){\\n            root->right = headl;\\n            return {root, taill};\\n        }else{\\n            root->right = headl;\\n            taill->right = headr;\\n            return {root, tailr};\\n        }    \\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    TreeNode *findPredicate(TreeNode *curr){\\n        curr=curr->left;\\n        while(curr->right!=NULL){\\n            curr=curr->right;\\n        }\\n        return curr;\\n    }\\n\\n    void flatten(TreeNode *root){\\n        TreeNode *curr=root;\\n        while(curr!=NULL){\\n            if(curr->left){\\n                TreeNode *pred=findPredicate(curr);\\n                pred->right=curr->right;\\n                curr->right=curr->left;\\n                curr->left=NULL;\\n            }\\n            \\n        curr=curr->right;\\n        }\\n    \\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605325,
                "title": "short-easy-c-solution-faster-than-100",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nTreeNode* prev = NULL;\\n    void flatten(TreeNode* root) {\\n        if(root==NULL)\\n        return;\\n        flatten(root->right);\\n        flatten(root->left);\\n        root->right = prev;\\n        root->left = NULL;\\n        prev = root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nTreeNode* prev = NULL;\\n    void flatten(TreeNode* root) {\\n        if(root==NULL)\\n        return;\\n        flatten(root->right);\\n        flatten(root->left);\\n        root->right = prev;\\n        root->left = NULL;\\n        prev = root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169579,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        std::ios_base::sync_with_stdio(false);\\n        std::cin.tie(nullptr);\\n        std::cout.tie(nullptr);\\n        if(!root)   return;\\n        if(!root->left && !root->right) return;\\n\\n        flatten(root->left);\\n        if(root->left){\\n            TreeNode* save= root->right;\\n            root->right= root->left;\\n            root->left= NULL;\\n            TreeNode* temp= root;\\n            while(temp->right){\\n                temp= temp->right;\\n            }\\n            temp->right= save;\\n        }\\n        flatten(root->right);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def flatten(self, root: Optional[TreeNode]) -> None:\\n        \\n        self.cur = None\\n        \\n        def dfs(node):\\n            if not node:\\n                return\\n            left, right = node.left, node.right\\n            node.left = None\\n            if self.cur:\\n                self.cur.right = node\\n                self.cur = self.cur.right\\n            else:\\n                self.cur = node\\n            dfs(left)\\n            dfs(right)\\n        \\n        dfs(root)\\n```\\n\\n```Java []\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        TreeNode node = root;\\n        while(node != null)\\n        {\\n            if(node.left != null)\\n            {\\n                TreeNode left = node.left;\\n                while(left.right != null)\\n                    left = left.right;\\n                left.right = node.right;\\n                node.right = node.left;\\n                node.left = null;\\n            }\\n            node = node.right;\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        std::ios_base::sync_with_stdio(false);\\n        std::cin.tie(nullptr);\\n        std::cout.tie(nullptr);\\n        if(!root)   return;\\n        if(!root->left && !root->right) return;\\n\\n        flatten(root->left);\\n        if(root->left){\\n            TreeNode* save= root->right;\\n            root->right= root->left;\\n            root->left= NULL;\\n            TreeNode* temp= root;\\n            while(temp->right){\\n                temp= temp->right;\\n            }\\n            temp->right= save;\\n        }\\n        flatten(root->right);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def flatten(self, root: Optional[TreeNode]) -> None:\\n        \\n        self.cur = None\\n        \\n        def dfs(node):\\n            if not node:\\n                return\\n            left, right = node.left, node.right\\n            node.left = None\\n            if self.cur:\\n                self.cur.right = node\\n                self.cur = self.cur.right\\n            else:\\n                self.cur = node\\n            dfs(left)\\n            dfs(right)\\n        \\n        dfs(root)\\n```\n```Java []\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        TreeNode node = root;\\n        while(node != null)\\n        {\\n            if(node.left != null)\\n            {\\n                TreeNode left = node.left;\\n                while(left.right != null)\\n                    left = left.right;\\n                left.right = node.right;\\n                node.right = node.left;\\n                node.left = null;\\n            }\\n            node = node.right;\\n        }\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2338633,
                "title": "daily-leetcoding-challenge-july-day-27",
                "content": "This problem is the Daily LeetCoding Challenge for July, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iterative Solution using Stack \n\n  \n**Approach 3:** O(1) Iterative Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n**Approach 3:** O(1) Iterative Solution\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1403249,
                "title": "python-simple-dfs-solution-no-helper-method",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def flatten(self, root: Optional[TreeNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        if root is None:\\n            return\\n        \\n        self.flatten(root.left)\\n        self.flatten(root.right)\\n        \\n        right = root.right\\n        root.right = root.left\\n        root.left = None\\n        \\n        while root.right:\\n            root = root.right\\n        \\n        root.right = right\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def flatten(self, root: Optional[TreeNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        if root is None:\\n            return\\n        \\n        self.flatten(root.left)\\n        self.flatten(root.right)\\n        \\n        right = root.right\\n        root.right = root.left\\n        root.left = None\\n        \\n        while root.right:\\n            root = root.right\\n        \\n        root.right = right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240099,
                "title": "easy-in-place-c-solution-recursive-and-iterative-approach",
                "content": "**Recursive solution**\\n```\\nclass Solution \\n{\\npublic:\\n    void flatten(TreeNode* root) \\n    {\\n        if(!root || (!root->left && !root->right))\\n        {\\n            return;\\n        }\\n        if(root->left)\\n        {\\n            flatten(root->left);\\n            TreeNode *tmp=root->right;\\n            root->right=root->left;\\n            root->left=NULL;\\n            TreeNode *t=root->right;\\n            while(t->right)\\n            {\\n                t=t->right;\\n            }\\n            t->right=tmp;\\n        }\\n        flatten(root->right);\\n    }\\n};\\n```\\n\\n**Iterative solution**\\n```\\nclass Solution \\n{\\npublic:\\n    void flatten(TreeNode* root) \\n    {\\n        while(root)\\n        {\\n            if(root->left)\\n            {\\n                TreeNode *tmp=root->left;\\n                while(tmp->right)\\n                {\\n                    tmp=tmp->right;\\n                }\\n                tmp->right=root->right;\\n                root->right=root->left;\\n                root->left=NULL;\\n            }\\n            root=root->right;\\n        }\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    void flatten(TreeNode* root) \\n    {\\n        if(!root || (!root->left && !root->right))\\n        {\\n            return;\\n        }\\n        if(root->left)\\n        {\\n            flatten(root->left);\\n            TreeNode *tmp=root->right;\\n            root->right=root->left;\\n            root->left=NULL;\\n            TreeNode *t=root->right;\\n            while(t->right)\\n            {\\n                t=t->right;\\n            }\\n            t->right=tmp;\\n        }\\n        flatten(root->right);\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\npublic:\\n    void flatten(TreeNode* root) \\n    {\\n        while(root)\\n        {\\n            if(root->left)\\n            {\\n                TreeNode *tmp=root->left;\\n                while(tmp->right)\\n                {\\n                    tmp=tmp->right;\\n                }\\n                tmp->right=root->right;\\n                root->right=root->left;\\n                root->left=NULL;\\n            }\\n            root=root->right;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 778647,
                "title": "simple-and-clean-iterative-space-o-1-solution-java",
                "content": "## Summary\\nIterative, O(1) space, O(n) time, Morris Traversal\\n\\n## Thinking Process\\nThe thinking process is inspired by the \"rotation\" operations in red-black trees, i.e. find some operations that can simplify the tree structure.\\n\\n* 0. For root without left subtree, there doesn\\'t need any operation on root and its links.\\n\\nThe following operations do not change the order in flattened list since the tree is flattened in preorder (root-left-right):\\n* 1. For root with both non-empty left and right subtrees, move right subtree to the right child of the last node in preorder in left subtree, i.e. the right tail of left subtree. **(\"shift left\")**\\n* 2. For root with only left subtree, move left subtree to right **(\"shift right\")**\\n\\nBy repeating operation 1 and 2, we can always turn the tree into one that satisfies observation 0 and simply move on to root.right.\\n\\n## Complexity\\n* Space complexity is O(1)\\n* Time complexity is O(n), each node is visited at most twice, once in the main for loop, once in finding rightTail while loop.\\n\\nThe final code is very similar to Morris Traversal, but much much easier to understand.\\n\\n```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        for (TreeNode curr = root; curr != null; curr = curr.right) {\\n            shiftLeft(curr);\\n            shiftRight(curr);\\n        }\\n    }\\n    \\n    // move right subtree to the right child of rightTail of left subtree\\n    private void shiftLeft(TreeNode node) {\\n        if (node.left != null && node.right != null) {\\n            TreeNode rightMost = node.left;\\n            while (rightMost.right != null) {\\n                rightMost = rightMost.right;\\n            }\\n            rightMost.right = node.right;\\n            node.right = null;\\n        }\\n    }\\n\\n    // move left subtree to right when right subtree is empty\\n    private void shiftRight(TreeNode node) {\\n        if (node.left != null && node.right == null) {\\n            node.right = node.left;\\n            node.left = null;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        for (TreeNode curr = root; curr != null; curr = curr.right) {\\n            shiftLeft(curr);\\n            shiftRight(curr);\\n        }\\n    }\\n    \\n    // move right subtree to the right child of rightTail of left subtree\\n    private void shiftLeft(TreeNode node) {\\n        if (node.left != null && node.right != null) {\\n            TreeNode rightMost = node.left;\\n            while (rightMost.right != null) {\\n                rightMost = rightMost.right;\\n            }\\n            rightMost.right = node.right;\\n            node.right = null;\\n        }\\n    }\\n\\n    // move left subtree to right when right subtree is empty\\n    private void shiftRight(TreeNode node) {\\n        if (node.left != null && node.right == null) {\\n            node.right = node.left;\\n            node.left = null;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 716185,
                "title": "0ms-beats-100-morris-traversal-approach",
                "content": "```\\nclass Solution { //using Morris Approach\\n    public void flatten(TreeNode root) {\\n        \\n        TreeNode pre;\\n        if (root==null || (root.left==null && root.right==null)) return;\\n        while(root!=null){\\n            if(root.left==null){\\n                root=root.right;\\n            }\\n            else{\\n                pre=root.left;\\n                while(pre.right!=null){\\n                    pre=pred.right;\\n                }\\n\\t\\t\\t\\t\\n                pre.right=root.right;\\n                root.right=root.left;\\n                root.left=null;\\n                root=root.right;\\n                \\n            }\\n        }\\n            \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution { //using Morris Approach\\n    public void flatten(TreeNode root) {\\n        \\n        TreeNode pre;\\n        if (root==null || (root.left==null && root.right==null)) return;\\n        while(root!=null){\\n            if(root.left==null){\\n                root=root.right;\\n            }\\n            else{\\n                pre=root.left;\\n                while(pre.right!=null){\\n                    pre=pred.right;\\n                }\\n\\t\\t\\t\\t\\n                pre.right=root.right;\\n                root.right=root.left;\\n                root.left=null;\\n                root=root.right;\\n                \\n            }\\n        }\\n            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 689298,
                "title": "c-short-solution",
                "content": "I just put the right node (if exist) to stack.\\nReconnect left subtree to right\\nIf it occurs that there is nothing to right - take from stack\\nAnd just go right till null and empty stack.\\n\\n```\\n    public void Flatten(TreeNode root) {\\n        var stack = new Stack<TreeNode>();\\n        while(root != null) {\\n            if(root.right != null)\\n                stack.Push(root.right);\\n\\n            root.right = root.left;\\n            root.left = null;\\n            if(root.right == null && stack.Count > 0)\\n                root.right = stack.Pop();\\n            root = root.right;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\n    public void Flatten(TreeNode root) {\\n        var stack = new Stack<TreeNode>();\\n        while(root != null) {\\n            if(root.right != null)\\n                stack.Push(root.right);\\n\\n            root.right = root.left;\\n            root.left = null;\\n            if(root.right == null && stack.Count > 0)\\n                root.right = stack.Pop();\\n            root = root.right;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 426976,
                "title": "kotlin-5-lines",
                "content": "```\\nfun flatten(root: TreeNode?, right: TreeNode? = null): Unit {\\n\\troot ?: return\\n\\n\\tflatten(root.left, root.right ?: right)\\n\\tflatten(root.right, right)\\n\\troot.right = root.left ?: root.right ?: right\\n\\troot.left = null\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nfun flatten(root: TreeNode?, right: TreeNode? = null): Unit {\\n\\troot ?: return\\n\\n\\tflatten(root.left, root.right ?: right)\\n\\tflatten(root.right, right)\\n\\troot.right = root.left ?: root.right ?: right\\n\\troot.left = null\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 331804,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    private TreeNode prev = null;\\n\\n    public void flatten(TreeNode root) {\\n        if (root == null)\\n            return;\\n        flatten(root.right);\\n        flatten(root.left);\\n        root.right = prev;\\n        root.left = null;\\n        prev = root;\\n    }\\n}\\n```\\n\\nRuntime: 1 ms, faster than 40.73% of Java online submissions for Flatten Binary Tree to Linked List.\\nMemory Usage: 35.8 MB, less than 99.96% of Java online submissions for Flatten Binary Tree to Linked List.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private TreeNode prev = null;\\n\\n    public void flatten(TreeNode root) {\\n        if (root == null)\\n            return;\\n        flatten(root.right);\\n        flatten(root.left);\\n        root.right = prev;\\n        root.left = null;\\n        prev = root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 320662,
                "title": "c-o-n-linear-speed-solution-using-stored-node-from-right-subtree",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    TreeNode *mTail = NULL;\\n    void flatten(TreeNode* root) {\\n        if (root == NULL) return;\\n        flatten(root->right);\\n        flatten(root->left);\\n        root->left = NULL;\\n        root->right = mTail;\\n        TreeNode *aPrev = root;\\n        mTail = aPrev;\\n    }\\n    \\n};\\n```\\n\\nThis makes sense if you draw it out on paper and run through a few examples..... Makes some sense to me.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    TreeNode *mTail = NULL;\\n    void flatten(TreeNode* root) {\\n        if (root == NULL) return;\\n        flatten(root->right);\\n        flatten(root->left);\\n        root->left = NULL;\\n        root->right = mTail;\\n        TreeNode *aPrev = root;\\n        mTail = aPrev;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 292424,
                "title": "python-very-simple-iterative-solution-o-1-space-16ms",
                "content": "1. Set root\\'s right as root\\'s left. \\n2. Set right most node as root\\'s right\\n3. Continue until end \\n\\nO(1) space. Avoids recursive stack present in many other solutions.\\n\\nEdit: Had no idea, but I guess this is somehow related to a \"Morris Traversal?\"\\n\\n```\\nclass Solution(object):\\n    def flatten(self, root):\\n        while root != None:\\n            if root.left == None:\\n                root = root.right \\n            else:\\n                temp = root.right\\n                root.right = root.left\\n                root.left = None\\n                root = root.right\\n                right = root\\n                while right.right != None:\\n                    right = right.right\\n                right.right = temp\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\nclass Solution(object):\\n    def flatten(self, root):\\n        while root != None:\\n            if root.left == None:\\n                root = root.right \\n            else:\\n                temp = root.right\\n                root.right = root.left\\n                root.left = None\\n                root = root.right\\n                right = root\\n                while right.right != None:\\n                    right = right.right\\n                right.right = temp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416547,
                "title": "java-100-faster-2-approaches-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/855a5ff3-27d1-45e6-bd71-ee635493ad87_1681479710.8322535.png)\\n\\n# First Approach\\n```\\n\\n\\n// Initialize a global variable \"prev\" as null to keep track of the previous node in the flattened tree\\n    TreeNode prev = null;\\n\\n    // A method to flatten the given binary tree into a singly linked list in-place\\n    public void flatten(TreeNode root) {\\n        // If the root node is null, return\\n        if(root == null){\\n            return;\\n        }\\n\\n        // Recursively flatten the right subtree first\\n        flatten(root.right);\\n        // Recursively flatten the left subtree second\\n        flatten(root.left);\\n\\n        // Set the right child of the current node to the previous node in the flattened tree\\n        root.right = prev;\\n        // Set the left child of the current node to null\\n        root.left = null;\\n        // Update the previous node to be the current node\\n        prev = root;\\n    }\\n```\\n---\\n\\n\\n\\n\\n\\n# Second Approach\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public void flatten(TreeNode root) {\\n        \\n        // Call flattenHelper to recursively flatten the binary tree.\\n        flattenHelper(root);\\n    }\\n\\n    private TreeNode flattenHelper(TreeNode root) {\\n\\n        if (root == null) {\\n            // Base case: Return null if the current node is null.\\n            return null;\\n        }\\n\\n        // Recursively flatten the left and right subtrees of the current node.\\n        TreeNode leftTail = flattenHelper(root.left);\\n        TreeNode rightTail = flattenHelper(root.right);\\n\\n        if (leftTail != null) {\\n            // If the left subtree is not null, append it to the right subtree of the current node.\\n            // Set the right child of the left subtree\\'s tail to the right subtree of the current node.\\n            // Set the right child of the current node to the left subtree.\\n            // Set the left child of the current node to null.\\n            leftTail.right = root.right;\\n            root.right = root.left;\\n            root.left = null;\\n        }\\n\\n        if (rightTail != null) {\\n            // If the right subtree is not null, return its tail.\\n            return rightTail;\\n        }\\n\\n        if (leftTail != null) {\\n            // If the right subtree is null but the left subtree is not null, return the tail of the left subtree.\\n            return leftTail;\\n        }\\n\\n        // If both the left and right subtrees are null, return the current node as the tail.\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n\\n\\n// Initialize a global variable \"prev\" as null to keep track of the previous node in the flattened tree\\n    TreeNode prev = null;\\n\\n    // A method to flatten the given binary tree into a singly linked list in-place\\n    public void flatten(TreeNode root) {\\n        // If the root node is null, return\\n        if(root == null){\\n            return;\\n        }\\n\\n        // Recursively flatten the right subtree first\\n        flatten(root.right);\\n        // Recursively flatten the left subtree second\\n        flatten(root.left);\\n\\n        // Set the right child of the current node to the previous node in the flattened tree\\n        root.right = prev;\\n        // Set the left child of the current node to null\\n        root.left = null;\\n        // Update the previous node to be the current node\\n        prev = root;\\n    }\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public void flatten(TreeNode root) {\\n        \\n        // Call flattenHelper to recursively flatten the binary tree.\\n        flattenHelper(root);\\n    }\\n\\n    private TreeNode flattenHelper(TreeNode root) {\\n\\n        if (root == null) {\\n            // Base case: Return null if the current node is null.\\n            return null;\\n        }\\n\\n        // Recursively flatten the left and right subtrees of the current node.\\n        TreeNode leftTail = flattenHelper(root.left);\\n        TreeNode rightTail = flattenHelper(root.right);\\n\\n        if (leftTail != null) {\\n            // If the left subtree is not null, append it to the right subtree of the current node.\\n            // Set the right child of the left subtree\\'s tail to the right subtree of the current node.\\n            // Set the right child of the current node to the left subtree.\\n            // Set the left child of the current node to null.\\n            leftTail.right = root.right;\\n            root.right = root.left;\\n            root.left = null;\\n        }\\n\\n        if (rightTail != null) {\\n            // If the right subtree is not null, return its tail.\\n            return rightTail;\\n        }\\n\\n        if (leftTail != null) {\\n            // If the right subtree is null but the left subtree is not null, return the tail of the left subtree.\\n            return leftTail;\\n        }\\n\\n        // If both the left and right subtrees are null, return the current node as the tail.\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295513,
                "title": "recursive-and-iterative-java-solution",
                "content": "\\n# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n# Recursive Code\\n```\\n\\nclass Solution {\\n   \\n    public void flatten(TreeNode root) {\\n        if(root == null) return;\\n\\n        flatten(root.left);\\n        flatten(root.right);\\n\\n        TreeNode left = root.left;\\n        TreeNode right = root.right;\\n\\n        root.left = null;\\n        root.right = left;\\n\\n        TreeNode temp = root;\\n        while(temp != null && temp.right != null) temp =temp.right;\\n\\n        temp.right = right;\\n    }\\n   \\n}\\n```\\n# Complexity\\n- Time Complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n     O(N)\\n- Space Complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n     O(N)\\n\\n# Iterative Code Using Stack\\n```\\n\\nclass Solution {\\n   \\n    public void flatten(TreeNode root) {\\n        if(root == null) return;\\n\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n\\n        f(stack,root);\\n    }\\n    void f(Stack<TreeNode> stack , TreeNode root) {\\n\\n        while(!stack.isEmpty()) {\\n\\n            TreeNode curr = stack.peek();\\n            stack.pop();\\n\\n            if(curr.right != null) stack.push(curr.right);\\n            if(curr.left != null) stack.push(curr.left);\\n\\n            if(!stack.isEmpty()) {\\n                curr.right = stack.peek();\\n            }\\n\\n            curr.left = null;\\n\\n        }\\n    }\\n   \\n}\\n\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n   \\n    public void flatten(TreeNode root) {\\n        if(root == null) return;\\n\\n        flatten(root.left);\\n        flatten(root.right);\\n\\n        TreeNode left = root.left;\\n        TreeNode right = root.right;\\n\\n        root.left = null;\\n        root.right = left;\\n\\n        TreeNode temp = root;\\n        while(temp != null && temp.right != null) temp =temp.right;\\n\\n        temp.right = right;\\n    }\\n   \\n}\\n```\n```\\n\\nclass Solution {\\n   \\n    public void flatten(TreeNode root) {\\n        if(root == null) return;\\n\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n\\n        f(stack,root);\\n    }\\n    void f(Stack<TreeNode> stack , TreeNode root) {\\n\\n        while(!stack.isEmpty()) {\\n\\n            TreeNode curr = stack.peek();\\n            stack.pop();\\n\\n            if(curr.right != null) stack.push(curr.right);\\n            if(curr.left != null) stack.push(curr.left);\\n\\n            if(!stack.isEmpty()) {\\n                curr.right = stack.peek();\\n            }\\n\\n            curr.left = null;\\n\\n        }\\n    }\\n   \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340398,
                "title": "beats-100-other-s-solutions",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def flatten(self, root: Optional[TreeNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        \\n        # flatten the root tree and return the list tail\\n        def dfs(root):\\n            if not root: return None\\n            \\n            leftTail= dfs(root.left)\\n            rightTail = dfs(root.right)\\n            \\n            if leftTail: #can also be written as root.left\\n                leftTail.right = root.right\\n                root.right = root.left\\n                root.left = None\\n                \\n            # python trick, if rightTail is not null then it will be returned before computing entire expression\\n            return rightTail or leftTail or root\\n        \\n        return dfs(root)\\n```",
                "solutionTags": [
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def flatten(self, root: Optional[TreeNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        \\n        # flatten the root tree and return the list tail\\n        def dfs(root):\\n            if not root: return None\\n            \\n            leftTail= dfs(root.left)\\n            rightTail = dfs(root.right)\\n            \\n            if leftTail: #can also be written as root.left\\n                leftTail.right = root.right\\n                root.right = root.left\\n                root.left = None\\n                \\n            # python trick, if rightTail is not null then it will be returned before computing entire expression\\n            return rightTail or leftTail or root\\n        \\n        return dfs(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2339815,
                "title": "java-short-sweet-solution",
                "content": "```\\nclass Solution {\\n  private TreeNode prev = null;\\n    public void flatten(TreeNode root) {\\n      if(root == null) return;\\n      \\n      flatten(root.right);\\n      flatten(root.left);\\n      root.right = prev;\\n      root.left = null;\\n     prev = root; \\n    }\\n}\\n```\\n\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n  private TreeNode prev = null;\\n    public void flatten(TreeNode root) {\\n      if(root == null) return;\\n      \\n      flatten(root.right);\\n      flatten(root.left);\\n      root.right = prev;\\n      root.left = null;\\n     prev = root; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2339813,
                "title": "c-without-with-preorder-traversal-easy-fastest",
                "content": "------------------------------Without preorder traversal------------------------------\\n```\\nvoid flatten(TreeNode* root){\\n\\tTreeNode* curr = root;\\n\\tTreeNode* now;\\n\\twhile(curr!=NULL){\\n\\t\\tif(curr->left!=NULL){\\n\\t\\t\\tnow = curr->left;\\n\\t\\t\\twhile(now->right!=NULL)\\n\\t\\t\\t\\t  now = now->right;\\n\\t\\t\\tnow->right = curr->right;\\n\\t\\t\\tcurr->right = curr->left;\\n\\t\\t\\tcurr->left = nullptr;\\n\\t\\t}\\n\\t\\tcurr = curr->right;\\n\\t}\\n}\\n```\\n\\n------------------------------With preorder traversal------------------------------\\n```\\nvector<int> vec;\\nvoid preorder(TreeNode* root){\\n\\tif(root==NULL)\\n\\t\\treturn;\\n\\tvec.push_back(root->val);\\n\\tpreorder(root->left);\\n\\tpreorder(root->right);\\n}\\n\\nvoid flatten(TreeNode* root) {\\n\\tif(root==NULL)\\n\\t\\treturn;\\n\\tpreorder(root);\\n\\tTreeNode* temp = root;\\n\\tfor(auto i: vec){\\n\\t\\ttemp->val = i;\\n\\t\\ttemp->left = NULL;\\n\\t\\ttemp->right = new TreeNode();\\n\\t\\ttemp = temp->right;\\n\\t}\\n\\ttemp = root;\\n\\twhile(temp->right->right!=nullptr){\\n\\t\\ttemp = temp->right;\\n\\t}\\n\\ttemp->right = NULL;\\n\\troot = temp;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nvoid flatten(TreeNode* root){\\n\\tTreeNode* curr = root;\\n\\tTreeNode* now;\\n\\twhile(curr!=NULL){\\n\\t\\tif(curr->left!=NULL){\\n\\t\\t\\tnow = curr->left;\\n\\t\\t\\twhile(now->right!=NULL)\\n\\t\\t\\t\\t  now = now->right;\\n\\t\\t\\tnow->right = curr->right;\\n\\t\\t\\tcurr->right = curr->left;\\n\\t\\t\\tcurr->left = nullptr;\\n\\t\\t}\\n\\t\\tcurr = curr->right;\\n\\t}\\n}\\n```\n```\\nvector<int> vec;\\nvoid preorder(TreeNode* root){\\n\\tif(root==NULL)\\n\\t\\treturn;\\n\\tvec.push_back(root->val);\\n\\tpreorder(root->left);\\n\\tpreorder(root->right);\\n}\\n\\nvoid flatten(TreeNode* root) {\\n\\tif(root==NULL)\\n\\t\\treturn;\\n\\tpreorder(root);\\n\\tTreeNode* temp = root;\\n\\tfor(auto i: vec){\\n\\t\\ttemp->val = i;\\n\\t\\ttemp->left = NULL;\\n\\t\\ttemp->right = new TreeNode();\\n\\t\\ttemp = temp->right;\\n\\t}\\n\\ttemp = root;\\n\\twhile(temp->right->right!=nullptr){\\n\\t\\ttemp = temp->right;\\n\\t}\\n\\ttemp->right = NULL;\\n\\troot = temp;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2339174,
                "title": "easy-c-sol-naive-efficient-approaches-time-o-n",
                "content": "```\\nAuthor : https://github.com/RajaKunalPandit1\\n\\n\\n// Recursive Sol : Time : O(N) :: Aux_Space : O(N)\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode *prev = NULL;\\n\\n    void flatten(TreeNode* root) {\\n\\n        if(root == NULL) return;\\n\\n        flatten(root->right);\\n        flatten(root->left);\\n\\n        root->right = prev;\\n        root->left = NULL;\\n        prev = root;\\n\\n    }\\n};\\n\\n// Iterative Solution Using Stack :: Time : O(N) :: Aux_Space : O(N)\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:    \\n    void flatten(TreeNode* root) {\\n\\n        if(root == NULL) return;\\n\\n        stack<TreeNode *> st;\\n\\n        st.push(root);\\n\\n        while(!st.empty()){\\n\\n            TreeNode *curr = st.top();\\n            st.pop();\\n\\n            if(curr->right != NULL)\\n                st.push(curr->right);\\n            if(curr->left != NULL)\\n                st.push(curr->left);\\n\\n            if(!st.empty()){\\n                curr->right = st.top();\\n            }\\n            curr->left = NULL;\\n        }\\n\\n    }\\n};\\n\\n// Efficient Solution :: Time : O(N) :: Aux_Space : O(1)\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n\\n        TreeNode *curr = root;\\n        TreeNode *prev;\\n\\n        while(curr!= NULL){\\n\\n            if(curr->left != NULL){\\n\\n                prev = curr->left;\\n\\n                while(prev->right != NULL)\\n                    prev = prev->right;\\n\\n                prev->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n            }\\n            curr = curr->right;\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode *prev = NULL;\\n\\n    void flatten(TreeNode* root) {\\n\\n        if(root == NULL) return;\\n\\n        flatten(root->right);\\n        flatten(root->left);\\n\\n        root->right = prev;\\n        root->left = NULL;\\n        prev = root;\\n\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2153770,
                "title": "recursive-o-n-time-o-1-extra-space-changed-links",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid link(TreeNode* root,TreeNode* &end){\\n\\t\\t\\tif(!root) return;\\n\\t\\t\\tTreeNode* temp = root->right;\\n\\t\\t\\tend = root;\\n\\t\\t\\tif(root->left){\\n\\t\\t\\t\\troot->right = root->left;\\n\\t\\t\\t\\troot->left = NULL;\\n\\t\\t\\t\\tlink(root->right,end);  // end will change once it goes inside the function\\n\\t\\t\\t\\tend->right = temp;      \\n\\t\\t\\t\\t// end contains the last element of preorder traversal of \\n\\t\\t\\t\\t// left subtree(which is now on right of root)\\n\\t\\t\\t}\\n\\t\\t\\tlink(temp,end); // end will change once it goes inside the function\\n\\n\\t\\t}\\n\\n\\t\\tvoid flatten(TreeNode* root) {\\n\\t\\t\\tTreeNode* end=NULL;\\n\\t\\t\\tlink(root,end);\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid link(TreeNode* root,TreeNode* &end){\\n\\t\\t\\tif(!root) return;\\n\\t\\t\\tTreeNode* temp = root->right;\\n\\t\\t\\tend = root;\\n\\t\\t\\tif(root->left){\\n\\t\\t\\t\\troot->right = root->left;\\n\\t\\t\\t\\troot->left = NULL;\\n\\t\\t\\t\\tlink(root->right,end);  // end will change once it goes inside the function\\n\\t\\t\\t\\tend->right = temp;      \\n\\t\\t\\t\\t// end contains the last element of preorder traversal of \\n\\t\\t\\t\\t// left subtree(which is now on right of root)\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1331782,
                "title": "easy-java-code-using-o-1-space-and-1ms-time",
                "content": "```\\n   public  TreeNode rightMost(TreeNode root) {\\n        while(root.right != null) {\\n            root = root.right;\\n        }\\n        return root;\\n    }\\n    public  void flatten(TreeNode root)\\n    {\\n        TreeNode curr = root;\\n        while(curr != null) {\\n            TreeNode left = curr.left;\\n                if(left != null) {\\n                    TreeNode rightMost = rightMost(left);\\n                    rightMost.right = curr.right;\\n                    curr.right = left;\\n                    curr.left = null;    \\n            }\\n            curr = curr.right;\\n        }\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n   public  TreeNode rightMost(TreeNode root) {\\n        while(root.right != null) {\\n            root = root.right;\\n        }\\n        return root;\\n    }\\n    public  void flatten(TreeNode root)\\n    {\\n        TreeNode curr = root;\\n        while(curr != null) {\\n            TreeNode left = curr.left;\\n                if(left != null) {\\n                    TreeNode rightMost = rightMost(left);\\n                    rightMost.right = curr.right;\\n                    curr.right = left;\\n                    curr.left = null;    \\n            }\\n            curr = curr.right;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1291042,
                "title": "c-recursive-solution-with-comments",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        //if root is null or it is a leaf node then return\\n        if(root==NULL)\\n            return;\\n        if(root->left == NULL && root->right==NULL)return ;\\n        \\n        // flattening process\\n        if(root->left != NULL){\\n            // get the left node\\n            flatten(root->left);\\n            \\n            // store the right node and make left node as right\\n            TreeNode* temp = root->right;\\n            root->right = root->left;\\n            root->left = NULL;\\n            \\n            TreeNode* current = root->right;\\n            // get the rightmost node\\n            while(current->right != NULL)current = current->right;\\n            \\n            // store the earlier right node as the rightmost node\\'s child\\n            current->right = temp;\\n        }\\n        // recurr the same process with the right child\\n        flatten(root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        //if root is null or it is a leaf node then return\\n        if(root==NULL)\\n            return;\\n        if(root->left == NULL && root->right==NULL)return ;\\n        \\n        // flattening process\\n        if(root->left != NULL){\\n            // get the left node\\n            flatten(root->left);\\n            \\n            // store the right node and make left node as right\\n            TreeNode* temp = root->right;\\n            root->right = root->left;\\n            root->left = NULL;\\n            \\n            TreeNode* current = root->right;\\n            // get the rightmost node\\n            while(current->right != NULL)current = current->right;\\n            \\n            // store the earlier right node as the rightmost node\\'s child\\n            current->right = temp;\\n        }\\n        // recurr the same process with the right child\\n        flatten(root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1279918,
                "title": "runtime-0-ms-faster-than-100-00-of-c-online-submissions-for-flatten-binary-tree-to-linked-list",
                "content": "```\\nvoid flatten(TreeNode* root) {\\n        if(!root){\\n            return;\\n        }\\n        if(root->left==NULL&&root->right==NULL){\\n            return;\\n        }\\n        if(root->left==NULL){\\n            flatten(root->right);\\n        }\\n        if(root->right==NULL){\\n            swap(root->left,root->right);\\n            flatten(root->right);\\n        }\\n        if(root->right&&root->left){\\n            flatten(root->left);\\n            flatten(root->right);\\n            swap(root->left,root->right);\\n          \\n            \\n           TreeNode* left = root->left;\\n            TreeNode* right = root->right;\\n            \\n            \\n            while(right->right!=NULL){\\n                right = right->right;\\n            }\\n            \\n                right->right = left;\\n           root->left = NULL;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvoid flatten(TreeNode* root) {\\n        if(!root){\\n            return;\\n        }\\n        if(root->left==NULL&&root->right==NULL){\\n            return;\\n        }\\n        if(root->left==NULL){\\n            flatten(root->right);\\n        }\\n        if(root->right==NULL){\\n            swap(root->left,root->right);\\n            flatten(root->right);\\n        }\\n        if(root->right&&root->left){\\n            flatten(root->left);\\n            flatten(root->right);\\n            swap(root->left,root->right);\\n          \\n            \\n           TreeNode* left = root->left;\\n            TreeNode* right = root->right;\\n            \\n            \\n            while(right->right!=NULL){\\n                right = right->right;\\n            }\\n            \\n                right->right = left;\\n           root->left = NULL;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1194995,
                "title": "java-two-solutions-recursion-in-order-traversal-o-n-and-iterative-0-ms",
                "content": "Time complexity:  `O(N)`.\\nSpace complexity: `O(H)`, for recursion stack, where `H` is the tree\\'s height.\\n\\n```\\nclass Solution {\\n    private TreeNode tail = new TreeNode(-1);\\n    \\n    public void flatten(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        tail.right = root;\\n        tail = root;\\n\\t\\t\\n        var left = root.left;\\n        var right = root.right;\\n        root.left = null;\\n        root.right = null;\\n\\t\\t\\n        flatten(left);\\n        flatten(right);\\n    }\\n}\\n```\\n\\n\\nTime complexity:  `O(N)`.\\nSpace complexity: `O(1)`.\\n```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        TreeNode node = root;\\n        while (node != null) {\\n            TreeNode left = node.left;\\n            node.left = null;\\n            TreeNode right = node.right;\\n            \\n            if (left == null) {\\n                node = right;\\n                continue;\\n            }\\n            \\n            TreeNode leftRight = left;\\n            while (leftRight.right != null) {\\n                leftRight = leftRight.right;\\n            }\\n            \\n            leftRight.right = right;\\n            node.right = left;\\n            node = node.right;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    private TreeNode tail = new TreeNode(-1);\\n    \\n    public void flatten(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        tail.right = root;\\n        tail = root;\\n\\t\\t\\n        var left = root.left;\\n        var right = root.right;\\n        root.left = null;\\n        root.right = null;\\n\\t\\t\\n        flatten(left);\\n        flatten(right);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        TreeNode node = root;\\n        while (node != null) {\\n            TreeNode left = node.left;\\n            node.left = null;\\n            TreeNode right = node.right;\\n            \\n            if (left == null) {\\n                node = right;\\n                continue;\\n            }\\n            \\n            TreeNode leftRight = left;\\n            while (leftRight.right != null) {\\n                leftRight = leftRight.right;\\n            }\\n            \\n            leftRight.right = right;\\n            node.right = left;\\n            node = node.right;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138528,
                "title": "c-simple-code-100-faster",
                "content": "Approach:\\n1)Recursively flatten left and right subtree\\n2)Store right subtree in a Temp variable and then assign right subtree as left subtree and make left subtree as null\\n3)Now store the tail of right subtree (i.e is our left subtree) and assign that tail to temp variable\\n\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root == NULL||(root->right == NULL && root->left == NULL)){\\n            return;\\n        }\\n        if(root->left != NULL){\\n            flatten(root->left);\\n            TreeNode* temp = root->right;\\n            root->right = root->left;\\n            root->left = NULL;\\n            \\n            TreeNode* t = root->right;\\n            while(t->right!=NULL){\\n                t = t->right;\\n            }\\n            t->right = temp;\\n        }\\n```\\n        flatten(root->right);\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root == NULL||(root->right == NULL && root->left == NULL)){\\n            return;\\n        }\\n        if(root->left != NULL){\\n            flatten(root->left);\\n            TreeNode* temp = root->right;\\n            root->right = root->left;\\n            root->left = NULL;\\n            \\n            TreeNode* t = root->right;\\n            while(t->right!=NULL){\\n                t = t->right;\\n            }\\n            t->right = temp;\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107010,
                "title": "solution-without-recursion-or-stack-true-o-1",
                "content": "Guys, the problem statement states O(1). That means we cannot use a stack or resursion. Yet, I see most people in the discussions are using either a stack or recursion. Those solutions wont get accepted in an interview!\\n\\n\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root == NULL)\\n            return;\\n        \\n        TreeNode* curr = root;\\n        \\n        // Left subtree\\n        while(curr != NULL)\\n        {\\n            if(curr->left != NULL)\\n            {\\n                TreeNode* left = curr->left;\\n                TreeNode* right = curr->right;\\n                \\n                curr->left = NULL;\\n                curr->right = left;\\n                \\n                while(left->right != NULL)\\n                {\\n                    left = left->right;\\n                }\\n                left->right = right;\\n            }\\n            curr = curr->right;\\n           \\n        }\\n        \\n       \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root == NULL)\\n            return;\\n        \\n        TreeNode* curr = root;\\n        \\n        // Left subtree\\n        while(curr != NULL)\\n        {\\n            if(curr->left != NULL)\\n            {\\n                TreeNode* left = curr->left;\\n                TreeNode* right = curr->right;\\n                \\n                curr->left = NULL;\\n                curr->right = left;\\n                \\n                while(left->right != NULL)\\n                {\\n                    left = left->right;\\n                }\\n                left->right = right;\\n            }\\n            curr = curr->right;\\n           \\n        }\\n        \\n       \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978184,
                "title": "java-using-stack",
                "content": "\\tclass Solution {\\n    public void flatten(TreeNode root) {\\n         if (root == null)   return;\\n         Deque<TreeNode> stack = new LinkedList<>();\\n         stack.offer(root);\\n         while (!stack.isEmpty()) {             \\n             TreeNode cur = stack.pollLast();\\n            if(cur.right!=null) stack.offer(cur.right);\\n            if(cur.left!=null) stack.offer(cur.left);\\n             if (!stack.isEmpty()) cur.right = stack.peekLast();\\n             cur.left = null; \\n         }\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public void flatten(TreeNode root) {\\n         if (root == null)   return;\\n         Deque<TreeNode> stack = new LinkedList<>();\\n         stack.offer(root);\\n         while (!stack.isEmpty()) {             \\n             TreeNode cur = stack.pollLast();\\n            if(cur.right!=null) stack.offer(cur.right);\\n            if(cur.left!=null) stack.offer(cur.left);\\n             if (!stack.isEmpty()) cur.right = stack.peekLast();\\n             cur.left = null; \\n         }",
                "codeTag": "Java"
            },
            {
                "id": 841606,
                "title": "simple-9-line-cpp-solution-without-stack-and-recursion",
                "content": "```\\n void flatten(TreeNode* root) {\\n        while(root)\\n        {   TreeNode* temp=root;\\n            TreeNode* t=root->right;\\n            root->right=root->left;\\n            root->left=NULL;\\n            while(temp->right)\\n                temp=temp->right;\\n            temp->right=t;\\n            root=root->right;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\n void flatten(TreeNode* root) {\\n        while(root)\\n        {   TreeNode* temp=root;\\n            TreeNode* t=root->right;\\n            root->right=root->left;\\n            root->left=NULL;\\n            while(temp->right)\\n                temp=temp->right;\\n            temp->right=t;\\n            root=root->right;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 750312,
                "title": "python3-solution-with-a-detailed-explanation-flatten-binary-tree-to-linkedlist",
                "content": "First note: most of the people on this website missed the first session of coding 101 class when instructor told them to comment your code so that others can read :D \\n\\nTry first to fully understand the problem. The tree is a binary tree but not binary search tree. Binary trees are structured in a way to be traversed recursively, and we\\'ll be using this properties of them in this solution. \\n\\nThe big picture is you need to flatten left subtree, replace right subtree with the flattened left subtree, and then flatten right subtree, and finally add it to the end of previously flatten (and now on right side of the root) left subtree. \\n```\\n\\t          root\\nleft subtree        right subtree\\n```\\n\\nshould change to \\n\\n```\\nroot\\n\\tleft subtree flattened\\n\\t\\t\\t\\t\\t\\tright subtree flattened\\n```\\n\\nYou would follow the same logic for every subtree using recursion. The recursion stops when you get to a node with a children (leaf) and no grand children. Basically, a node and one or two children. Let\\'s call node `a`, left child `b`, and right child `c`. \\n\\n```\\n\\t\\ta\\n\\tb\\t\\tc\\n```\\nOnce you have such a scenario, it will be changed to the following. Note that left children are `null`. \\n```\\n\\t\\t  a\\n\\t\\t/\\t  \\\\\\n\\tNone\\t     b\\t\\n\\t\\t\\t   /\\t\\\\\\n\\t\\t    None\\t c \\n```\\nMakes sense? Once you `flatten` the left bottom subtree, you move up from left side until you reach to `root`. Once you get to `root`, you do the same with `root.right`, and add it to the tail of `flatten`ed left subtree. Check the video link below for some numeric examples.\\n\\n\\nI didn\\'t come up with this solution and got it from the discussion posts (combination of a bunch of them). Mostly I used the idea and code from [here](https://www.youtube.com/watch?v=598gdjE6Quo).  I changed it to Python3. \\n\\n\\nThe code as follows: \\nIn line `#1`, we check whether root exists, otherwise, `return` nothing. In addition to the case when tree is empty, it also happens when you get to a leaf node and run line `#3` and there is not left child (because it\\'s leaf). \\n\\nLine `#2`: We first try to `flatten` left subtree. You can do it first for right subtree with some changes in the code. As mentioned above, we do it recursively. Check this image from the link above: \\n![image](https://assets.leetcode.com/users/images/5a277ea6-4d3e-40ad-962a-03c1d68f84b9_1595534726.875856.png)\\n\\n\\nYou focus on the left bottom first. Let\\'s say we\\'re on node `2`, we first make `3` the right subtree of `2` (line `#5`) while saving `4` to a temporary variable (line `#4`, `temp`). Next we add `4` to the tail of `2` (line `#10`) to get the middle blue graph. Next, we move left subtree (which is flattened) to the right side of root (line `#5`), while saving right subtree to a temporary variable (line `#5`). Later on after replacing right subtree with left one, we first flatten initial right subtree (line `#11`) and add it to the tail of new right subtree (previously left) to get the last tree (line `#10`). Note the recursion here, line `#11` gets activated and then we end up doing to line `10` at some points for some nodes.   \\n\\nLine `#3` is trying to recursively get to the bottom left of tree, when there, it saves the right subtree to `temp` (line `#4`). Replace the right subtree with left one (line `#5`). Note than in the base case of line `#5`, we\\'re dealing with one node as left subtree and one node as right subtree (check the `a`, `b`, `c` example above). We set the left subtree to `None` as instructed (line `#6`), and finally save the current right subtree (which was left subtree initially) to the `curr` variable (line `#7`). The reason is that we want to get to the tail of initially left subtree (currently right) so that we could add initially right subtree there. \\n\\nLine `#8` and `#9` do the traversal to get to the tail of current right subtree. When we get there, we attached the saved right subtree (`temp` variable) to the `curr` (which is the tail now) to get the final results. Now, so far everything is done for left side of `root`. However, similar approach can be done for the right side of the `root` as shown in line `#11`. You just need to pass the `root.right` to the `flatten` function and it\\'ll do the rest for you. Note that we don\\'t need to do all the work we\\'ve done between lines `#2` and `10` because once you pass the `root.right`, it\\'s similar to passing `root.left` in line `#3`. \\n\\n\\n```\\nclass Solution:\\n    def flatten(self, root):\\n        if not root: #1\\n            return\\n        \\n        if root.left: #2\\n            self.flatten(root.left) #3\\n            temp = root.right #4\\n            root.right = root.left #5\\n            root.left = None #6\\n            curr = root.right #7\\n            \\n            while curr.right: #8\\n                curr = curr.right #9\\n            \\n            curr.right = temp #10\\n        \\n        if root.right: #11\\n            self.flatten(root.right)\\n```\\n\\nThat\\'s it. I hope it\\'s clear. \\n\\n\\n=======================================================\\nFinal note: please let me know if you found any typo/error/etc. I\\'ll try to fix it. \\n\\nFinal note 2: I think explaninng something in a simple way would be instructive for myself. That\\'s why I\\'m doing this kind of writing. If you\\'d like to read more of my posts, check `peymannp` tag. \\n\\n\\n\\n\\n\\n\\n\\n```\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\t          root\\nleft subtree        right subtree\\n```\n```\\nroot\\n\\tleft subtree flattened\\n\\t\\t\\t\\t\\t\\tright subtree flattened\\n```\n```\\n\\t\\ta\\n\\tb\\t\\tc\\n```\n```\\n\\t\\t  a\\n\\t\\t/\\t  \\\\\\n\\tNone\\t     b\\t\\n\\t\\t\\t   /\\t\\\\\\n\\t\\t    None\\t c \\n```\n```\\nclass Solution:\\n    def flatten(self, root):\\n        if not root: #1\\n            return\\n        \\n        if root.left: #2\\n            self.flatten(root.left) #3\\n            temp = root.right #4\\n            root.right = root.left #5\\n            root.left = None #6\\n            curr = root.right #7\\n            \\n            while curr.right: #8\\n                curr = curr.right #9\\n            \\n            curr.right = temp #10\\n        \\n        if root.right: #11\\n            self.flatten(root.right)\\n```\n```\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 681774,
                "title": "python3-solution-using-postorder-traversal-o-1-space-complexity",
                "content": "```\\nclass Solution:\\n    \\n    def get_result(self,root):\\n        if root==None:\\n            return None\\n        left = self.get_result(root.left)\\n        right = self.get_result(root.right)\\n        x = left\\n        if left!=None:\\n            while left.right:\\n                left = left.right\\n            left.right = right\\n            root.left = None\\n            root.right = x\\n        return root\\n    \\n    def flatten(self, root: TreeNode) -> None:\\n        return self.get_result(root)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def get_result(self,root):\\n        if root==None:\\n            return None\\n        left = self.get_result(root.left)\\n        right = self.get_result(root.right)\\n        x = left\\n        if left!=None:\\n            while left.right:\\n                left = left.right\\n            left.right = right\\n            root.left = None\\n            root.right = x\\n        return root\\n    \\n    def flatten(self, root: TreeNode) -> None:\\n        return self.get_result(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 272929,
                "title": "golang-edition-of-the-most-voted-resolution-in-java",
                "content": "```\\nfunc flatten(root *TreeNode) {\\n\\tvar handler func(node *TreeNode)\\n\\n\\tvar next *TreeNode\\n\\thandler = func (node *TreeNode) {\\n\\t\\tif node == nil {\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\thandler(node.Right)\\n\\t\\thandler(node.Left)\\n\\t\\tnode.Right = next\\n\\t\\tnode.Left = nil\\n\\t\\tnext = node\\n\\t}\\n\\thandler(root)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc flatten(root *TreeNode) {\\n\\tvar handler func(node *TreeNode)\\n\\n\\tvar next *TreeNode\\n\\thandler = func (node *TreeNode) {\\n\\t\\tif node == nil {\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\thandler(node.Right)\\n\\t\\thandler(node.Left)\\n\\t\\tnode.Right = next\\n\\t\\tnode.Left = nil\\n\\t\\tnext = node\\n\\t}\\n\\thandler(root)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 172710,
                "title": "4ms-o-1-space-o-n-time-10-lines-c-solution-inspired-by-morris-traversal",
                "content": "This question asks in-place so most of the recursive methods are not what expected.\\n\\nThere is a hint telling us it is looking for a preOrder traversal. Therefore we can translate the steps:\\n1, visit the root;\\n2, visit the left children\\n3, visit the right children\\n\\nIn step 2 we need to preserve the context for step 3. Instead of saving it in a stack, either by yourself or system by recursion, we can save it to the root\\'s immediate left children\\'s farest right children.\\nBut you can see as the code, it has a inner while loop. Then why claim it as O(N) time complexity?\\nThe reason is although we have a inner loop, we will visit at most all the left children 1 time when looking for the place to preserve the context. Therefore the worst case is visiting every node in the tree twice which is O(2N) ~ O(N).\\n\\nHere is my solution:\\n\\n```\\n    void flatten(TreeNode* root) {\\n        for(auto it = root; root; root = root->right) {\\n            if (!root->right) swap(root->right, root->left);\\n            else if (root->left) {\\n                swap(root->left, root->right);\\n                for(it = root; it->right; it = it->right);\\n                swap(it->right, root->left);\\n            }\\n        }\\n    }\\n```\\n\\nAnd after more than 1 year, I came across this q again and I have a more straight forward solution:\\n```\\nvoid flatten(TreeNode* root) {\\n        while (root) {\\n            if (root->left && root->right) {\\n                auto it = root->left;\\n                for (; it->right; it = it->right);\\n                swap(it->right, root->right);\\n            }\\n            root->right = root->left ? root->left : root->right;\\n            root->left = NULL;            \\n            root = root->right;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    void flatten(TreeNode* root) {\\n        for(auto it = root; root; root = root->right) {\\n            if (!root->right) swap(root->right, root->left);\\n            else if (root->left) {\\n                swap(root->left, root->right);\\n                for(it = root; it->right; it = it->right);\\n                swap(it->right, root->left);\\n            }\\n        }\\n    }\\n```\n```\\nvoid flatten(TreeNode* root) {\\n        while (root) {\\n            if (root->left && root->right) {\\n                auto it = root->left;\\n                for (; it->right; it = it->right);\\n                swap(it->right, root->right);\\n            }\\n            root->right = root->left ? root->left : root->right;\\n            root->left = NULL;            \\n            root = root->right;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 172385,
                "title": "python-recursive-solution",
                "content": "This solution is adapted from [this](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/discuss/36977/My-short-post-order-traversal-Java-solution-for-share) Java solution. You basically maintain a global variable `prev` which stores the last node that was flattened. First you flatten `root.right`, after which `prev` is `root.right`. Then you flatten `root.left`, which gets called recursively until you hit the \\'end\\', at which point the flattened `root.right` is attached to the right of the \\'end\\', and finally `prev` gets set to `root.left`. After the recursive calls, `root.right` get set to `root.left`, which already has the `root.right` attached to its end.\\n\\n```python\\nclass Solution(object):\\n    prev = None\\n\\n    def flatten(self, root):\\n        if not root:\\n            return\\n        self.flatten(root.right)\\n        self.flatten(root.left)\\n        root.right = self.prev\\n        root.left = None\\n        self.prev = root\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    prev = None\\n\\n    def flatten(self, root):\\n        if not root:\\n            return\\n        self.flatten(root.right)\\n        self.flatten(root.left)\\n        root.right = self.prev\\n        root.left = None\\n        self.prev = root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37134,
                "title": "two-easy-to-understand-c-pre-order-traversal-solution-recursive-and-iterative-with-demo",
                "content": "Recursive solution\\n\\n    class Solution {\\n    private:\\n        TreeNode* pre = NULL;\\n        \\n    public:\\n        void flatten(TreeNode* root) {\\n            if(!root) return;\\n            pre = root;\\n            \\n            TreeNode* right = root->right;\\n            if(root->left) root->right = root->left;\\n            flatten(root->left);\\n            pre->right = right;\\n            flatten(root->right);\\n            \\n            root->left = NULL;\\n        }\\n    };\\n\\n\\nIterative solution: Starting from parent node `runner`,  keep a copy of right child, let it be `right` first since we are going to reset `runner->right`: if runner has `left child`(`runner->left`), it will become the new right child of runner, and then we set `left child` to `nullptr`. How to deal the old right child `right`? We need to find it a new parent, which should be the rightmost node in the subtree rooted at the old left child, which we just set as the new right child(`runner->right`), so rRunner is doing this work to find the new parent for right. After all of this, we continue with runner's right child.\\n\\n\\n    current runner: 1\\n\\n    before update:\\n         1\\n        / \\\\\\n       2   5\\n      / \\\\   \\\\\\n     3   4   6\\n\\n    update:\\n    right = 1->right = 5\\n    1->right = 2\\n    rRunner = 4\\n    4->right = right = 5\\n\\n    after update:   \\n         1\\n          \\\\\\n           2   \\n          / \\\\   \\n         3   4   \\n              \\\\\\n               5\\n                \\\\\\n                 6\\n\\n    next runner: 2\\n\\nCode\\n\\n    class Solution {\\n    public:\\n        void flatten(TreeNode* root) {\\n            TreeNode* runner = root;\\n            \\n            while(runner){\\n                if(runner->left){\\n                    TreeNode* right = runner->right;\\n                    runner->right = runner->left;\\n                    runner->left = nullptr;\\n                    runner = runner->right;\\n                    \\n                    TreeNode* rRunner = runner;             \\n                    while(rRunner->right){\\n                        rRunner = rRunner->right;\\n                    }                   \\n                    rRunner->right = right;  /*rRunner is the new parent of `right`*/\\n                }else{\\n                    runner = runner->right;    \\n                }         \\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    private:\\n        TreeNode* pre = NULL;\\n        \\n    public:\\n        void flatten(TreeNode* root) {\\n            if(!root) return;\\n            pre = root;\\n            \\n            TreeNode* right = root->right;\\n            if(root->left) root->right = root->left;\\n            flatten(root->left);\\n            pre->right = right;\\n            flatten(root->right);\\n            \\n            root->left = NULL;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 37171,
                "title": "concise-c-recursion-solution",
                "content": "    class Solution {\\n    public:\\n        void flatten(TreeNode* root) {\\n            if (!root) return;\\n            if (root->left){\\n                flatten(root->left);\\n                ptr->right = root->right;\\n                root->right = root->left;\\n                root->left = NULL;\\n            }\\n            ptr = root;\\n            flatten(root->right);\\n        }\\n    private:\\n        TreeNode* ptr;\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        void flatten(TreeNode* root) {\\n            if (!root) return;\\n            if (root->left){\\n                flatten(root->left);\\n                ptr->right = root->right;\\n                root->right = root->left;\\n                root->left = NULL;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 37067,
                "title": "12-line-python-in-place-solution",
                "content": "    class Solution:\\n        def flatten(self, root):\\n            if not root:\\n                return\\n            self.flatten(root.right)\\n            if not root.left:\\n                return\\n            self.flatten(root.left)\\n            tail = root.left\\n            while tail.right:\\n                tail = tail.right\\n            tail.right = root.right\\n            root.right = root.left\\n            root.left = None",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        def flatten(self, root):\\n            if not root:\\n                return\\n            self.flatten(root.right)\\n            if not root.left:\\n                return\\n            self.flatten(root.left)\\n            tail = root.left\\n            while tail.right:\\n                tail = tail.right\\n            tail.right = root.right\\n            root.right = root.left\\n            root.left = None",
                "codeTag": "Java"
            },
            {
                "id": 37289,
                "title": "perhaps-the-most-simple-code-c",
                "content": "    class Solution {\\n    public:\\n        TreeNode *sidend = NULL;// this record the left most node;\\n        void flatten(TreeNode *root) {\\n            if (root == NULL) return;\\n            sidend = root;\\n            TreeNode *r = root->right;\\n            root->right = root->left;\\n            root->left = NULL;\\n            flatten(root->right);\\n            sidend->right = r;\\n            flatten(r);\\n            return ;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        TreeNode *sidend = NULL;// this record the left most node;\\n        void flatten(TreeNode *root) {\\n            if (root == NULL) return;\\n            sidend = root;\\n            TreeNode *r = root->right;\\n            root->right = root->left;\\n            root->left = NULL;\\n            flatten(root->right);\\n            sidend->right = r;\\n            flatten(r);\\n            return ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 37310,
                "title": "a-solution-with-python-generators",
                "content": "I split the problem into two parts:\\n\\n - A generator that create a sequence of nodes from a pre-order traversal.\\n - The flatten method uses the generator to fix the tree, just link prev.right with curr.\\n\\nIs recursive, but nice, and the code is reusable, easy to understand and maintain.\\n\\nComplessity: O(n)?\\n\\n    class Solution:\\n    \\n        # @param root, a tree node\\n        # @return nothing, do it in place\\n        def flatten(self, root):\\n            \\n            if not root: return\\n            \\n            prev = None\\n            for node in self.preOrder(root):\\n                \\n                node.left = None\\n                if prev: prev.right = node\\n                prev = node\\n        \\n        \\n        def preOrder(self, node):\\n            \\n            left = node.left\\n            right = node.right\\n            \\n            yield node\\n            if left:\\n                for node in self.preOrder(left):\\n                    yield node\\n            \\n            if right:\\n                for node in self.preOrder(right):\\n                    yield node",
                "solutionTags": [],
                "code": "I split the problem into two parts:\\n\\n - A generator that create a sequence of nodes from a pre-order traversal.\\n - The flatten method uses the generator to fix the tree, just link prev.right with curr.\\n\\nIs recursive, but nice, and the code is reusable, easy to understand and maintain.\\n\\nComplessity: O(n)?\\n\\n    class Solution:\\n    \\n        # @param root, a tree node\\n        # @return nothing, do it in place\\n        def flatten(self, root):\\n            \\n            if not root: return\\n            \\n            prev = None\\n            for node in self.preOrder(root):\\n                \\n                node.left = None\\n                if prev: prev.right = node\\n                prev = node\\n        \\n        \\n        def preOrder(self, node):\\n            \\n            left = node.left\\n            right = node.right\\n            \\n            yield node\\n            if left:\\n                for node in self.preOrder(left):\\n                    yield node\\n            \\n            if right:\\n                for node in self.preOrder(right):\\n                    yield node",
                "codeTag": "Java"
            },
            {
                "id": 3987618,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nRecursive\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    TreeNode* dummy = NULL;    \\npublic:\\n    void flatten(TreeNode* root) {\\n        if (!root)\\n            return;\\n        flatten(root->right);    \\n        flatten(root->left); \\n        root->right = dummy;\\n        root->left = NULL;\\n        dummy = root;\\n    }\\n};\\n```\\n\\n# Approach 2\\nIterative\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution { \\npublic:\\n    void flatten(TreeNode* root) {\\n        if (!root)\\n            return;\\n        stack <TreeNode*> st;\\n        st.push(root);\\n        TreeNode* dummy = new TreeNode(); \\n        while (!st.empty()) {\\n            TreeNode* cur = st.top();\\n            st.pop();\\n            if (cur->right)\\n                st.push(cur->right);\\n            if (cur->left)\\n                st.push(cur->left);\\n            cur->left = NULL;    \\n            dummy->right = cur;\\n            dummy = cur;     \\n        }    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    TreeNode* dummy = NULL;    \\npublic:\\n    void flatten(TreeNode* root) {\\n        if (!root)\\n            return;\\n        flatten(root->right);    \\n        flatten(root->left); \\n        root->right = dummy;\\n        root->left = NULL;\\n        dummy = root;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution { \\npublic:\\n    void flatten(TreeNode* root) {\\n        if (!root)\\n            return;\\n        stack <TreeNode*> st;\\n        st.push(root);\\n        TreeNode* dummy = new TreeNode(); \\n        while (!st.empty()) {\\n            TreeNode* cur = st.top();\\n            st.pop();\\n            if (cur->right)\\n                st.push(cur->right);\\n            if (cur->left)\\n                st.push(cur->left);\\n            cur->left = NULL;    \\n            dummy->right = cur;\\n            dummy = cur;     \\n        }    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534363,
                "title": "python-easy-iterative-recursive-both-solution",
                "content": "**Iterative Solution:**\\n```\\nclass Solution:\\n    def flatten(self, root: Optional[TreeNode]) -> None:\\n        if root==None:\\n            return None\\n        st=[root]\\n        while st:\\n            node=st.pop()\\n            if node.right:\\n                st.append(node.right)\\n            if node.left:\\n                st.append(node.left)\\n            if len(st)>0:\\n                node.right=st[-1]\\n            node.left=None\\n```\\n**Recursive Solution:**\\n```\\nclass Solution:\\n    prev=None\\n    def flatten(self, root: Optional[TreeNode]) -> None:\\n        if root==None:\\n            return \\n        self.flatten(root.right)\\n        self.flatten(root.left)\\n        root.left=None\\n        root.right=self.prev\\n        self.prev=root\\n```\\n**An upvote will be encouraging**\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def flatten(self, root: Optional[TreeNode]) -> None:\\n        if root==None:\\n            return None\\n        st=[root]\\n        while st:\\n            node=st.pop()\\n            if node.right:\\n                st.append(node.right)\\n            if node.left:\\n                st.append(node.left)\\n            if len(st)>0:\\n                node.right=st[-1]\\n            node.left=None\\n```\n```\\nclass Solution:\\n    prev=None\\n    def flatten(self, root: Optional[TreeNode]) -> None:\\n        if root==None:\\n            return \\n        self.flatten(root.right)\\n        self.flatten(root.left)\\n        root.left=None\\n        root.right=self.prev\\n        self.prev=root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437731,
                "title": "easy-java-solution-for-beginners-explained",
                "content": "# Approach\\n- Create a helper function that is basically a pre-ordered traversal recursive function and collect all the nodes and store them in an global data structure ( ArrayList ) named arr.\\n- pass root node into the helper function.\\n- Once the pre-ordered traversal is done through the tree, traverse through all the n nodes stored sequentially in the arr.\\n- connect all the nodes to their sucessive nodes using right pointers and set their left pointers as null.\\n- return the first node of the arraylist.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode flatten(TreeNode root) {\\n\\n        helper(root);\\n\\n        System.out.println(arr);\\n\\n        for(int i = 0;i<arr.size()-1;i++){\\n            arr.get(i).right = arr.get(i+1);\\n            arr.get(i).left = null;\\n        }\\n\\n        arr.get(arr.size()-1).right = null;\\n\\n        return arr.get(0);\\n    }\\n\\n    public static List<TreeNode> arr = new ArrayList<>();\\n\\n    public static void helper(TreeNode node){\\n        \\n        if(node == null){\\n            return;\\n        }\\n \\n        System.out.print(node.val+\" \");\\n        arr.add(node);\\n        helper(node.left);        \\n        helper(node.right);\\n\\n    }\\n}\\n```\\n\\n![images.jpeg](https://assets.leetcode.com/users/images/54f0dd79-e727-449e-89d6-511412597ae0_1681987648.1056275.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode flatten(TreeNode root) {\\n\\n        helper(root);\\n\\n        System.out.println(arr);\\n\\n        for(int i = 0;i<arr.size()-1;i++){\\n            arr.get(i).right = arr.get(i+1);\\n            arr.get(i).left = null;\\n        }\\n\\n        arr.get(arr.size()-1).right = null;\\n\\n        return arr.get(0);\\n    }\\n\\n    public static List<TreeNode> arr = new ArrayList<>();\\n\\n    public static void helper(TreeNode node){\\n        \\n        if(node == null){\\n            return;\\n        }\\n \\n        System.out.print(node.val+\" \");\\n        arr.add(node);\\n        helper(node.left);        \\n        helper(node.right);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282445,
                "title": "recursive-easy-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    TreeNode prev=null;\\n    public void flatten(TreeNode root) {\\n        if(root==null) return;\\n        flatten(root.right);\\n        flatten(root.left);\\n        root.right=prev;\\n        root.left=null;\\n        prev=root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    TreeNode prev=null;\\n    public void flatten(TreeNode root) {\\n        if(root==null) return;\\n        flatten(root.right);\\n        flatten(root.left);\\n        root.right=prev;\\n        root.left=null;\\n        prev=root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362513,
                "title": "c-0ms-explained-recursion-faster-than-100",
                "content": "![image](https://assets.leetcode.com/users/images/757d4eee-ddd7-4bb7-9f91-d8989d1af257_1659326327.549598.png)\\n\\n```\\nvoid flatten(struct TreeNode* root){\\n    \\n    // check if root exists\\n    if (root){\\n        \\n        struct TreeNode* temp = root->right;    // store the right part of root\\n        \\n        root->right = root->left;           // move the left part to the right\\n        root->left = NULL;                  // clear left part\\n        \\n        struct TreeNode* curr = root;\\n        while(curr->right){                 // use while loop to find the bottom right side\\n            curr = curr->right;\\n        }\\n        curr->right = temp;                 // attach temp back\\n        \\n        // recursion\\n        flatten(root->right);\\n    }\\n\\n}\\n```\\nPlease UPVOTE if you Like !!\\n![image](https://assets.leetcode.com/users/images/67cea45c-243b-48eb-915d-996cd2c35f4d_1659326258.096931.png)\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nvoid flatten(struct TreeNode* root){\\n    \\n    // check if root exists\\n    if (root){\\n        \\n        struct TreeNode* temp = root->right;    // store the right part of root\\n        \\n        root->right = root->left;           // move the left part to the right\\n        root->left = NULL;                  // clear left part\\n        \\n        struct TreeNode* curr = root;\\n        while(curr->right){                 // use while loop to find the bottom right side\\n            curr = curr->right;\\n        }\\n        curr->right = temp;                 // attach temp back\\n        \\n        // recursion\\n        flatten(root->right);\\n    }\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2340817,
                "title": "success-details-runtime-35-ms-faster-than-97-02-of-python3",
                "content": "![image](https://assets.leetcode.com/users/images/bf4d326f-9a82-41d5-835c-3e7014f4306c_1658921383.316379.png)\\n```\\n def flatten(self, root: Optional[TreeNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        def dfs(root):\\n            if not root: return None\\n            \\n            leftTail= dfs(root.left)\\n            rightTail = dfs(root.right)\\n            \\n            if leftTail: #can also be written as root.left\\n                leftTail.right = root.right\\n                root.right = root.left\\n                root.left = None\\n                \\n            # python trick, if rightTail is not null then it will be returned before computing entire expression\\n            return rightTail or leftTail or root\\n        \\n        return dfs(root)\\n```\\nupvote if my post helps you out",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n def flatten(self, root: Optional[TreeNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        def dfs(root):\\n            if not root: return None\\n            \\n            leftTail= dfs(root.left)\\n            rightTail = dfs(root.right)\\n            \\n            if leftTail: #can also be written as root.left\\n                leftTail.right = root.right\\n                root.right = root.left\\n                root.left = None\\n                \\n            # python trick, if rightTail is not null then it will be returned before computing entire expression\\n            return rightTail or leftTail or root\\n        \\n        return dfs(root)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2339141,
                "title": "recursive-preorder-c",
                "content": "This can be divided into 2  subproblems  i.e. left subtree as a linklist and right subtree as a linklist . After we get both left and right as a linklist by doing recursive calls , we attach the left list to right of root and then at the end of the left list we attached , we will attach the right subtree to form the preOrder traversal.\\n\\n**Time Complexity : O (n x n)** ( *as we are reaching every node and for each node after attaching left list we have to traverse the list to find the end*)\\n\\n**Space Complexity : O( height of tree )**\\n\\n```\\n       if(!root)return ;\\n       \\n       TreeNode* rootLeft = root->left;\\n        root->left = NULL;\\n       TreeNode* rootRight = root->right;\\n        root->right = NULL;\\n        \\n        flatten(rootLeft);\\n        flatten(rootRight);\\n        \\n       \\n        root->right = rootLeft;\\n        TreeNode* cur = root;\\n        while(cur->right){\\n            cur= cur->right;\\n        }\\n        cur->right = rootRight;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n       if(!root)return ;\\n       \\n       TreeNode* rootLeft = root->left;\\n        root->left = NULL;\\n       TreeNode* rootRight = root->right;\\n        root->right = NULL;\\n        \\n        flatten(rootLeft);\\n        flatten(rootRight);\\n        \\n       \\n        root->right = rootLeft;\\n        TreeNode* cur = root;\\n        while(cur->right){\\n            cur= cur->right;\\n        }\\n        cur->right = rootRight;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2127152,
                "title": "java-solution-w-o-n-time-o-n-space-for-beginners",
                "content": "Here\\'s my Java solution w/ O(n) time | O(n) space. It might not be meaningful to people who have mastered the problem already. But if you are struggling w/ the problem, I hope it helps. Basically, I just use preorder Traversal helper method and then make the new connection. Once you understand the concept, I believe it would be easier to understand how to achieve O(1) space complexity as a follow-up question.\\n\\n  Also, anyone is welcomed to reach out to me if my solution is not clear to you. I\\'m very willing to help.\\n\\n```\\nclass Solution \\n{\\n    Queue<TreeNode> Q = new LinkedList<>();\\n    \\n    public void flatten(TreeNode root) \\n    {\\n        // O(n) time | O(n) space\\n        preorderTraversal(root);\\n        \\n        // do nothing when it\\'s null or only 1 node\\n        if(root == null || Q.size() == 1)   return;\\n        \\n        if(!Q.isEmpty())\\n        {\\n            root = Q.poll();\\n            root.left = null;\\n            TreeNode tmp = root;\\n            \\n            while(!Q.isEmpty())\\n            {\\n                TreeNode node = Q.poll();\\n                node.left = null;\\n                tmp.right = node;\\n                tmp = tmp.right;\\n            }\\n        }\\n    }\\n    \\n    public void preorderTraversal(TreeNode root)\\n    {\\n        if(root == null)    return;\\n        \\n        Q.offer(root);\\n        preorderTraversal(root.left);\\n        preorderTraversal(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Queue",
                    "Iterator"
                ],
                "code": "```\\nclass Solution \\n{\\n    Queue<TreeNode> Q = new LinkedList<>();\\n    \\n    public void flatten(TreeNode root) \\n    {\\n        // O(n) time | O(n) space\\n        preorderTraversal(root);\\n        \\n        // do nothing when it\\'s null or only 1 node\\n        if(root == null || Q.size() == 1)   return;\\n        \\n        if(!Q.isEmpty())\\n        {\\n            root = Q.poll();\\n            root.left = null;\\n            TreeNode tmp = root;\\n            \\n            while(!Q.isEmpty())\\n            {\\n                TreeNode node = Q.poll();\\n                node.left = null;\\n                tmp.right = node;\\n                tmp = tmp.right;\\n            }\\n        }\\n    }\\n    \\n    public void preorderTraversal(TreeNode root)\\n    {\\n        if(root == null)    return;\\n        \\n        Q.offer(root);\\n        preorderTraversal(root.left);\\n        preorderTraversal(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2101154,
                "title": "java-solution-easy-to-understand-100-faster",
                "content": "easy to understand\\n![image](https://assets.leetcode.com/users/images/abbe1809-abfe-460c-a77f-89833903aa5a_1654150623.2005098.png)\\n\\n```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        if(root == null)\\n            return ;\\n        if(root.left != null){\\n            TreeNode leftRightMost = root.left;\\n            while(leftRightMost.right != null)   // find left right most node\\n                leftRightMost = leftRightMost.right;\\n            TreeNode rootRight = root.right;\\n            root.right = root.left;\\n            leftRightMost.right = rootRight;\\n            root.left = null; \\n        }\\n        flatten(root.right);\\n    }\\n}\\n\\n```\\nIf this explanation is really helpful please upvote \\uD83D\\uDC4D \\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        if(root == null)\\n            return ;\\n        if(root.left != null){\\n            TreeNode leftRightMost = root.left;\\n            while(leftRightMost.right != null)   // find left right most node\\n                leftRightMost = leftRightMost.right;\\n            TreeNode rootRight = root.right;\\n            root.right = root.left;\\n            leftRightMost.right = rootRight;\\n            root.left = null; \\n        }\\n        flatten(root.right);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902175,
                "title": "all-3-approach-with-notes",
                "content": "**1st approach -> Recursive Approach** \\n\\n```\\nclass Solution {\\n    TreeNode prev = null;\\n    public void flatten(TreeNode root) {\\n        if(root == null) return;\\n        \\n        flatten(root.right);\\n        flatten(root.left);\\n        \\n        root.right = prev;\\n        root.left = null;\\n        \\n        prev = root;\\n    }\\n}\\n\\nT.C -> O(N)\\nS.C -> O(N)\\n```\\n\\n**2nd approach -> Iterative  Approach**\\n```\\nclass Solution {\\n\\n    public void flatten(TreeNode root) {\\n        if(root == null) return; \\n        \\n        Deque<TreeNode> st = new ArrayDeque<>(); \\n        st.push(root); \\n        while(!st.isEmpty()) {\\n            TreeNode cur = st.peek();\\n            st.pop();\\n            \\n            if(cur.right != null) {\\n                st.push(cur.right); \\n            }\\n            if(cur.left != null) {\\n                st.push(cur.left); \\n            }\\n            if(!st.isEmpty()) {\\n                cur.right = st.peek(); \\n            }\\n            cur.left = null;\\n        }\\n        \\n    }\\n}\\n\\nT.C -> O(N)\\nS.C -> O(N)\\n```\\n\\n**3rd approach -> Morris Traversal**\\n```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        TreeNode cur = root;\\n        while (cur != null)\\n        {\\n            if(cur.left != null)\\n            {\\n                TreeNode pre = cur.left;\\n                while(pre.right != null)\\n                {\\n                    pre = pre.right;\\n                }\\n                pre.right = cur.right;\\n                cur.right = cur.left;\\n                cur.left = null;\\n            }\\n            cur = cur.right;\\n        }\\n    }\\n}\\n\\nT.C -> O(N)\\nS.C -> O(1)\\n```\\n\\n**Notes Link** : https://github.com/rizonkumar/LeetCode-Notes/blob/main/114.pdf\\n\\nIf you find it useful **do upvote**",
                "solutionTags": [
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode prev = null;\\n    public void flatten(TreeNode root) {\\n        if(root == null) return;\\n        \\n        flatten(root.right);\\n        flatten(root.left);\\n        \\n        root.right = prev;\\n        root.left = null;\\n        \\n        prev = root;\\n    }\\n}\\n\\nT.C -> O(N)\\nS.C -> O(N)\\n```\n```\\nclass Solution {\\n\\n    public void flatten(TreeNode root) {\\n        if(root == null) return; \\n        \\n        Deque<TreeNode> st = new ArrayDeque<>(); \\n        st.push(root); \\n        while(!st.isEmpty()) {\\n            TreeNode cur = st.peek();\\n            st.pop();\\n            \\n            if(cur.right != null) {\\n                st.push(cur.right); \\n            }\\n            if(cur.left != null) {\\n                st.push(cur.left); \\n            }\\n            if(!st.isEmpty()) {\\n                cur.right = st.peek(); \\n            }\\n            cur.left = null;\\n        }\\n        \\n    }\\n}\\n\\nT.C -> O(N)\\nS.C -> O(N)\\n```\n```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        TreeNode cur = root;\\n        while (cur != null)\\n        {\\n            if(cur.left != null)\\n            {\\n                TreeNode pre = cur.left;\\n                while(pre.right != null)\\n                {\\n                    pre = pre.right;\\n                }\\n                pre.right = cur.right;\\n                cur.right = cur.left;\\n                cur.left = null;\\n            }\\n            cur = cur.right;\\n        }\\n    }\\n}\\n\\nT.C -> O(N)\\nS.C -> O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832740,
                "title": "c-faster-reverse-postorder-short-precise-easy-to-understand",
                "content": "Please Upvote if you like the solution.\\n```\\nclass Solution {\\npublic:\\n    TreeNode* prev=nullptr;\\n    void flatten(TreeNode* root) {\\n        if(root==nullptr)\\n            return;\\n        flatten(root->right);\\n        flatten(root->left);\\n        root->left=nullptr;\\n        root->right=prev;\\n        prev=root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* prev=nullptr;\\n    void flatten(TreeNode* root) {\\n        if(root==nullptr)\\n            return;\\n        flatten(root->right);\\n        flatten(root->left);\\n        root->left=nullptr;\\n        root->right=prev;\\n        prev=root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775956,
                "title": "easiest-solution-with-o-1-space",
                "content": "Approch:\\n1.Add node->right to end of node->left side .\\n2.Then add node->left side to the node->right side .\\n\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root)\\n\\t{\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        while(root!=NULL)\\n        {\\n            \\n            if(root->left)\\n            {\\n                TreeNode *LEFT=root->left;\\n                TreeNode *curr=LEFT;\\n                while(curr->right)\\n                {\\n                    curr=curr->right;\\n                }\\n                curr->right=root->right;\\n                root->right=LEFT;\\n                root->left=NULL;\\n            }\\n            root=root->right;\\n            \\n        }\\n    }\\n};\\n```\\n\\nMorris traversal is used for the solution.",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root)\\n\\t{\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        while(root!=NULL)\\n        {\\n            \\n            if(root->left)\\n            {\\n                TreeNode *LEFT=root->left;\\n                TreeNode *curr=LEFT;\\n                while(curr->right)\\n                {\\n                    curr=curr->right;\\n                }\\n                curr->right=root->right;\\n                root->right=LEFT;\\n                root->left=NULL;\\n            }\\n            root=root->right;\\n            \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1543162,
                "title": "c-simple-approach-using-recursion-o-1-space-complexity",
                "content": "class Solution {\\npublic:\\n    \\n    TreeNode* prev=NULL;\\n    \\n    void flatten(TreeNode* root) {\\n        //Do Reverse Postorder (Right Left Root)\\n        //Attach the current node\\'s right to the immediate previous node whose reverse postorder just finished (prev node).\\n    \\n        if(!root) return;\\n        flatten(root->right);\\n        flatten(root->left);\\n        \\n        root->right=prev;\\n        root->left=NULL;\\n        \\n        prev=root;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    TreeNode* prev=NULL;\\n    \\n    void flatten(TreeNode* root) {\\n        //Do Reverse Postorder (Right Left Root)\\n        //Attach the current node\\'s right to the immediate previous node whose reverse postorder just finished (prev node).\\n    \\n        if(!root) return;\\n        flatten(root->right);\\n        flatten(root->left);\\n        \\n        root->right=prev;\\n        root->left=NULL;\\n        \\n        prev=root;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1536670,
                "title": "java-easy-understanding-100-0ms",
                "content": "class Solution {\\n\\n\\n    public void flatten(TreeNode root) {\\n        helper(root);\\n    }\\n    \\n    public static TreeNode helper(TreeNode root){\\n        if(root==null){\\n            return null;\\n        }\\n        \\n       \\n        TreeNode lf=helper(root.left);\\n        TreeNode rt=helper(root.right);\\n        \\n        \\n        \\n        if(lf==null && rt==null){\\n            root.left=null;\\n            root.right=null;\\n            return root;\\n        }\\n        else if(lf!=null && rt==null){\\n            root.left=null;\\n            root.right=lf;\\n            return root;\\n        }\\n        \\n        else if (lf==null && rt!=null){\\n            root.left=null;\\n            root.right=rt;\\n            return root;\\n        }\\n        else{\\n        root.left=null;\\n        TreeNode a =lf;\\n        while(a.right!=null){\\n            a=a.right;\\n        }\\n        a.right=rt;\\n            \\n        root.right=lf;\\n           TreeNode t=root;\\n            // while(t!=null){-->for debugging\\n            //     System.out.println(t.val);\\n            //     t=t.right;\\n            // }\\n         \\n        \\n            \\n              return root;\\n        }\\n      \\n        \\n    }\\n        \\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n\\n    public void flatten(TreeNode root) {\\n        helper(root);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1443503,
                "title": "o-1-space-solution-in-java-with-detailed-expalanation-and-dry-run",
                "content": "**PLEASE UPVOTE IF YOU LIKED THE POST**\\n```\\n//APPROACH TIME COMPLEXITY : O(N), SPACE COMPLEXITY: O(1)\\n\\n/*\\n    Code is very very Easy just see the given example 1 and trace the code, what \\n    we are doing here is that as we require preoder traversal and in preorder traversal\\n    we do Root Left Right for every subtree that is what we are doing here\\n    we see if there is left child of root , go to its extreme right child. The question\\n    is why ? and the ans is we know that in preorder of root\\'s left subtree last node\\n    traversed will be this node only (root\\'s left and then the extreme right). so after\\n    preorder traversal completion from root and its left subtree we should go to root\\'s\\n    right , that is why we go to it and attach its right to root\\'s right , and change\\n    root\\'s right to point on root\\'s left. At the end move to root\\'s right in this \\n    modified tree which means we move one node downward and do the same thing again.\\n    \\n    We are making connection here so that we don\\'t have to use the recursion call \\n    stack for memorizing our traversal , we just are tweaking our preorder recursive\\n    traversal so that our space complextiy become o(1)\\n*/\\nclass Solution {\\n    public void flatten(TreeNode cur) {\\n        TreeNode prev = null;\\n        while(cur != null){\\n            if(cur.left != null){\\n                prev = cur.left;    //mark this node\\n                while(prev.right != null)\\n                    prev = prev.right; //it is cur\\'s left subtree\\'s extreme right child\\n                \\n                prev.right = cur.right; //join it to right of cur\\n                cur.right = cur.left;   //change cur\\'s right to cur\\'s left\\n            }\\n            cur = cur.right; //get ready for next iteration (i.e move one node down)\\n        }\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/1546f8f6-0bd8-4301-92d1-196a06f2ace7_1630741600.0964684.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\n//APPROACH TIME COMPLEXITY : O(N), SPACE COMPLEXITY: O(1)\\n\\n/*\\n    Code is very very Easy just see the given example 1 and trace the code, what \\n    we are doing here is that as we require preoder traversal and in preorder traversal\\n    we do Root Left Right for every subtree that is what we are doing here\\n    we see if there is left child of root , go to its extreme right child. The question\\n    is why ? and the ans is we know that in preorder of root\\'s left subtree last node\\n    traversed will be this node only (root\\'s left and then the extreme right). so after\\n    preorder traversal completion from root and its left subtree we should go to root\\'s\\n    right , that is why we go to it and attach its right to root\\'s right , and change\\n    root\\'s right to point on root\\'s left. At the end move to root\\'s right in this \\n    modified tree which means we move one node downward and do the same thing again.\\n    \\n    We are making connection here so that we don\\'t have to use the recursion call \\n    stack for memorizing our traversal , we just are tweaking our preorder recursive\\n    traversal so that our space complextiy become o(1)\\n*/\\nclass Solution {\\n    public void flatten(TreeNode cur) {\\n        TreeNode prev = null;\\n        while(cur != null){\\n            if(cur.left != null){\\n                prev = cur.left;    //mark this node\\n                while(prev.right != null)\\n                    prev = prev.right; //it is cur\\'s left subtree\\'s extreme right child\\n                \\n                prev.right = cur.right; //join it to right of cur\\n                cur.right = cur.left;   //change cur\\'s right to cur\\'s left\\n            }\\n            cur = cur.right; //get ready for next iteration (i.e move one node down)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1385401,
                "title": "c-recusion-easy",
                "content": "\\nclass Solution {\\npublic: \\n\\n     TreeNode* prev = NULL;\\n     void flatten(TreeNode* root) {\\n        \\n       if(!root) return;\\n        \\n        flatten(root->right);\\n        flatten(root->left);\\n\\n        root->right = prev;\\n        root->left = NULL;  \\n        prev = root;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic: \\n\\n     TreeNode* prev = NULL;\\n     void flatten(TreeNode* root) {\\n        \\n       if(!root) return;\\n        \\n        flatten(root->right);\\n        flatten(root->left);\\n\\n        root->right = prev;\\n        root->left = NULL;  \\n        prev = root;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1353396,
                "title": "java-easy-approach-with-explanation-o-n-arraydeque-bfs",
                "content": "```\\nclass Solution \\n{\\n    public void flatten(TreeNode root)\\n    {//preorder iterative(Root Left Right)\\n        if(root == null)//base case for null graph \\n            return;\\n        \\n        ArrayDeque<TreeNode> stack= new ArrayDeque<>();//Faster than Stack \\n        \\n        stack.addLast(root);//adding the root node \\n        while(!stack.isEmpty())//terminating condition \\n        {\\n            TreeNode temp= stack.removeLast();//popping the top of the stack, the inorder root//Root\\n            \\n            if(temp.right != null)\\n                stack.addLast(temp.right);//we are pushing the right first to access the the left fast //Right\\n            if(temp.left != null)\\n                stack.addLast(temp.left);//we are pushing the left at last to access it faster as it is the next preorder element //Left\\n            \\n            if(!stack.isEmpty())\\n               temp.right= stack.peekLast();//only item left on the top of the stack is the next inorder root, so creating a dependency linking each other \\n            temp.left= null;//destroying the left link and pointing to the null\\n        }\\n        return;//returning to the main  method \\n    }\\n}//please do Upvote, it helps a lot\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution \\n{\\n    public void flatten(TreeNode root)\\n    {//preorder iterative(Root Left Right)\\n        if(root == null)//base case for null graph \\n            return;\\n        \\n        ArrayDeque<TreeNode> stack= new ArrayDeque<>();//Faster than Stack \\n        \\n        stack.addLast(root);//adding the root node \\n        while(!stack.isEmpty())//terminating condition \\n        {\\n            TreeNode temp= stack.removeLast();//popping the top of the stack, the inorder root//Root\\n            \\n            if(temp.right != null)\\n                stack.addLast(temp.right);//we are pushing the right first to access the the left fast //Right\\n            if(temp.left != null)\\n                stack.addLast(temp.left);//we are pushing the left at last to access it faster as it is the next preorder element //Left\\n            \\n            if(!stack.isEmpty())\\n               temp.right= stack.peekLast();//only item left on the top of the stack is the next inorder root, so creating a dependency linking each other \\n            temp.left= null;//destroying the left link and pointing to the null\\n        }\\n        return;//returning to the main  method \\n    }\\n}//please do Upvote, it helps a lot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1280482,
                "title": "c-o-1-space",
                "content": "...\\n\\n    void flatten(TreeNode* root) {\\n        if(root==NULL)\\n            return;\\n        if(root->left!=NULL)\\n        {\\n             flatten(root->left);\\n            TreeNode *tmp=root->right;\\n            root->right=root->left;\\n            root->left=NULL;\\n            TreeNode *curr=root;\\n            while(curr->right!=NULL)\\n            {\\n                curr=curr->right;\\n            }\\n            curr->right=tmp;\\n              \\n        }\\n       flatten(root->right);\\n        \\n    }\\n...",
                "solutionTags": [],
                "code": "...\\n\\n    void flatten(TreeNode* root) {\\n        if(root==NULL)\\n            return;\\n        if(root->left!=NULL)\\n        {\\n             flatten(root->left);\\n            TreeNode *tmp=root->right;\\n            root->right=root->left;\\n            root->left=NULL;\\n            TreeNode *curr=root;\\n            while(curr->right!=NULL)\\n            {\\n                curr=curr->right;\\n            }\\n            curr->right=tmp;\\n              \\n        }\\n       flatten(root->right);\\n        \\n    }\\n...",
                "codeTag": "Unknown"
            },
            {
                "id": 1266669,
                "title": "clean-python-solution-with-explanation",
                "content": "The idea is pretty simple, let us first discuss the base cases. \\n1. If the current node is None, we return None as there is not anything for us to do. \\n2. If the left of current node is None, we return the node. \\n(Note that in the final output, we want that each Node only has a right subtree and not a left Subtree)\\nNow for the solving part, What to do when out node has a left subtree. \\n1. We define a temp pointer that points to the rightmost node of the left subtree.\\n2. We then set temp.right as node.right\\n3. We then set node.right to node.left\\n4. We finally delete node.left or set it to None\\nThe logic behind these steps is quite simple. Our aim is to remove the left subtrees and we want to ensure that for each node, the right subtree comes after the left subtree, hence we add the right subtree to the rightmost occurence of the left subtree and delete the left subtree after declaring it as the right subtree. This also covers the case when the right subtree is None, the proposed algorithm would simply set the right subtree as the left subtree and the left subtree to None.\\nHope this helps.\\n\\n\\n```\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        def travel(node):\\n            if node==None:\\n                return\\n            travel(node.left)\\n            travel(node.right)\\n            if not node.left:\\n                return node\\n            temp = node.left\\n            while temp.right:\\n                temp=temp.right\\n            temp.right = node.right\\n            node.right = node.left\\n            node.left = None\\n            return node\\n        \\n        return travel(root)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        def travel(node):\\n            if node==None:\\n                return\\n            travel(node.left)\\n            travel(node.right)\\n            if not node.left:\\n                return node\\n            temp = node.left\\n            while temp.right:\\n                temp=temp.right\\n            temp.right = node.right\\n            node.right = node.left\\n            node.left = None\\n            return node\\n        \\n        return travel(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206208,
                "title": "c-intuitive-solution-3-steps-explanation",
                "content": "1. **Base Condition:** If root is NULL no need to flatten just return.\\n2. **Hypothesis:** flatten(root->left) , flatten(root->right) . Recursive function will do this work, no need to think how it\\'s doing. Now left subtree is flattened, right subtree is flattened we just need to do work for root.\\n3. **Induction:** \\n\\t* \\tStore right subtree in a temp node. \\n\\t* \\tMake root->right = root->left.\\n\\t* \\tMake root->left = NULL\\n\\tNow we just need to attach temp (old right subtree ) to tail node of new right subtree.\\n\\t* Find tail node and make tail->right = temp.\\n\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) \\n    {\\n        if(root == NULL)\\n            return;\\n        \\n        flatten(root->left);\\n        flatten(root->right);\\n        \\n        TreeNode *temp = root->right;\\n        root->right = root->left;\\n        root->left = NULL;\\n        \\n        TreeNode *tail = root;\\n        while(tail->right != NULL)\\n            tail = tail -> right;\\n        \\n        tail->right = temp;\\n        return;    \\n    }\\n};\\n```\\n\\n***Happy Coding! :)***\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) \\n    {\\n        if(root == NULL)\\n            return;\\n        \\n        flatten(root->left);\\n        flatten(root->right);\\n        \\n        TreeNode *temp = root->right;\\n        root->right = root->left;\\n        root->left = NULL;\\n        \\n        TreeNode *tail = root;\\n        while(tail->right != NULL)\\n            tail = tail -> right;\\n        \\n        tail->right = temp;\\n        return;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1001228,
                "title": "preorder-c-solution-with-exapmle",
                "content": "The problem can be solved using preOrder traversal. If the problem would have asked to make a BST then we should have used InOrder.\\n\\nSo lets say, left of tree is LeftRoot and right of tree is RightRoot.\\nour solution would be:\\nroot->left = NULL;\\nroot->right = LeftRoot (recursively PreOrder LeftRoot too now)\\nright most child of root = RightRoot (recursively PreOrder LeftRoot too now)\\n\\nExample.,\\n![image](https://assets.leetcode.com/users/images/3de0a9d8-23f6-4e96-a237-849d20acd53c_1609744619.630561.png)\\nHere LeftRoot would be:\\n![image](https://assets.leetcode.com/users/images/ab2a3b49-3a33-4b89-a003-6ab015efe7e0_1609744694.64367.png)\\nand RightRoot would be:\\n![image](https://assets.leetcode.com/users/images/db4e28e0-d217-42ba-9bc4-7a5124858930_1609744732.7645311.png)\\n\\nNow step 1 : \\nroot->left = NULL;\\nroot->right = LeftRoot\\nthis would make Root as following:\\n![image](https://assets.leetcode.com/users/images/804f17c9-ae91-4d9c-8557-88d6fedcb116_1609744826.659586.png)\\nNow step 2 :\\nRecursively do the same to root->right\\nThis would make Root as following:\\n![image](https://assets.leetcode.com/users/images/68987bba-9381-4e93-b65d-1a278b439bd2_1609744940.7608232.png)\\nNow step 3:\\nright most child of root5 = RightRootOf5 (which is 6)\\nThis would make Root as following:\\n![image](https://assets.leetcode.com/users/images/98398610-9166-4b61-be83-eeabe4e7c389_1609745101.191471.png)\\nNow step 4:\\nAs we are donw with RootLeft, hence, let us move to RootRight.\\nright most child of root = RightRoot.\\nThis would make the root as following:\\n![image](https://assets.leetcode.com/users/images/03526e95-4668-4d8a-b157-f010b17c7c53_1609745222.3897603.png)\\nNow step 5:\\nRecursively do the same to RootRight (it is already in the requested form, not required for this example)\\n\\n```\\nclass Solution {\\npublic:\\n    void preOrder(TreeNode* root){\\n        if(!root)\\n            return;\\n        TreeNode* leftRoot = root->left;\\n        TreeNode* rightRoot = root->right;\\n        \\n        TreeNode * temp = root;\\n        \\n        root->left = NULL;\\n        root->right = leftRoot;\\n        preOrder(root->right);\\n        while(temp->right)\\n            temp = temp->right;\\n        temp->right = rightRoot;\\n        preOrder(temp->right);\\n    }\\n    void flatten(TreeNode* root) {\\n        preOrder(root);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void preOrder(TreeNode* root){\\n        if(!root)\\n            return;\\n        TreeNode* leftRoot = root->left;\\n        TreeNode* rightRoot = root->right;\\n        \\n        TreeNode * temp = root;\\n        \\n        root->left = NULL;\\n        root->right = leftRoot;\\n        preOrder(root->right);\\n        while(temp->right)\\n            temp = temp->right;\\n        temp->right = rightRoot;\\n        preOrder(temp->right);\\n    }\\n    void flatten(TreeNode* root) {\\n        preOrder(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 997037,
                "title": "flatten-binary-tree-to-linked-list-dfs-pictorial-view-simple-solution",
                "content": "**Time: O(n)**\\n(**Please upVote If you found it Useful ;)**)\\n![image](https://assets.leetcode.com/users/images/e951ac22-ff6c-4632-b125-941ef96d7c17_1609527703.9131186.png)\\n![image](https://assets.leetcode.com/users/images/8d8302ba-cb53-4759-82a6-8daabed80ea3_1609528369.1178982.png)\\n![image](https://assets.leetcode.com/users/images/304131e2-9d2d-410f-b8e9-23c30362ae0b_1609528910.195043.png)\\n![image](https://assets.leetcode.com/users/images/ccb9cca2-e160-41b9-86cf-1cc2ee45c910_1609529746.1924458.png)\\n!![image](https://assets.leetcode.com/users/images/8245e571-de46-42a2-a579-73dc087b694e_1609530229.6895788.png)\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    void flattenUtil(TreeNode* root)\\n    {\\n        if(root==NULL || (root->left==NULL && root->right==NULL))\\n            return;\\n        if(root->left!=NULL)\\n        {\\n            flattenUtil(root->left);\\n            TreeNode *temp=root->right;\\n            root->right=root->left;\\n            root->left=NULL;\\n            TreeNode *curr=root->right;\\n            while(curr->right!=NULL)\\n                curr=curr->right;    \\n            curr->right=temp;\\n            \\n        }\\n        if(root->right!=NULL)\\n            flattenUtil(root->right);\\n        return;\\n    }\\n    void flatten(TreeNode* root) {\\n        flattenUtil(root);\\n         \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void flattenUtil(TreeNode* root)\\n    {\\n        if(root==NULL || (root->left==NULL && root->right==NULL))\\n            return;\\n        if(root->left!=NULL)\\n        {\\n            flattenUtil(root->left);\\n            TreeNode *temp=root->right;\\n            root->right=root->left;\\n            root->left=NULL;\\n            TreeNode *curr=root->right;\\n            while(curr->right!=NULL)\\n                curr=curr->right;    \\n            curr->right=temp;\\n            \\n        }\\n        if(root->right!=NULL)\\n            flattenUtil(root->right);\\n        return;\\n    }\\n    void flatten(TreeNode* root) {\\n        flattenUtil(root);\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 953667,
                "title": "two-js-solutions",
                "content": "```\\n/*\\nSolution: Recursion\\nWe should turn the entire tree into a right-most skewed tree.\\n1. We traverse nodes in post-order because we need to turn every subtree into a right-most skewed tree\\n2. We keep track of right-most node (tail of right subtree) for every tree because we will put our left subtree\\nbetween root node and right subtree. We will do this at each tree: root receives left subtree\\'s right-most node, set its right pointer to current root\\'s right subtree, make left subtree null and return right-most node again.\\n*/\\nvar flatten = function(root) {\\n    dfs(root);\\n    return root;\\n    // T.C: O(N)\\n    // S.C: O(H)\\n};\\n\\nfunction dfs(root) {\\n    if (!root) {\\n        return null;\\n    }\\n    if (!root.left && !root.right) {\\n        return root;\\n    }\\n    let leftTail = dfs(root.left);\\n    let rightTail = dfs(root.right);\\n    // we put left subtree between root and right subtree\\n    if (leftTail) {\\n        leftTail.right = root.right;\\n        root.right = root.left;\\n        root.left = null;\\n    }\\n    // if right subtree is empty, right subtree\\'s tail is actually left subtree\\'s tail\\n    if (!rightTail) {\\n        rightTail = leftTail;\\n    }\\n    return rightTail;\\n}\\n```\\n\\n```\\n/*\\nWe need to turn given tree into a right-most skewed tree.\\n\\nAt each root, if it has a left child, we do the following operation:\\nleft subtree\\'s right-most node = root\\'s right subtree\\nright subtree = left leftsubtree\\nleft subtree = null\\n\\nThen, we traverse right because left node will be null at this point\\n*/\\nvar flatten = function(root) {\\n    let cur = root;\\n    // every time root has a left child\\n    // we rearrange so that left subtree gets placed in the correct position of right subtree\\n    while (cur !== null) {\\n        // ensure that left subtree is moved to the right subtree\\n        // and hence left subtree is null\\n        if (cur.left) {\\n            rightMost = findRightMost(cur.left);\\n            rightMost.right = cur.right;\\n            cur.right = cur.left;\\n            cur.left = null;\\n        }\\n        // left subtree is null so there is no need to traverse left\\n        cur = cur.right;\\n    }\\n    return root;\\n    // T.C: O(N), we traverse each node twice at most\\n    // S.C: O(1)\\n};\\n\\nfunction findRightMost(root) {\\n    let cur = root;\\n    while (cur.right) {\\n        cur = cur.right;\\n    }\\n    return cur;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\nSolution: Recursion\\nWe should turn the entire tree into a right-most skewed tree.\\n1. We traverse nodes in post-order because we need to turn every subtree into a right-most skewed tree\\n2. We keep track of right-most node (tail of right subtree) for every tree because we will put our left subtree\\nbetween root node and right subtree. We will do this at each tree: root receives left subtree\\'s right-most node, set its right pointer to current root\\'s right subtree, make left subtree null and return right-most node again.\\n*/\\nvar flatten = function(root) {\\n    dfs(root);\\n    return root;\\n    // T.C: O(N)\\n    // S.C: O(H)\\n};\\n\\nfunction dfs(root) {\\n    if (!root) {\\n        return null;\\n    }\\n    if (!root.left && !root.right) {\\n        return root;\\n    }\\n    let leftTail = dfs(root.left);\\n    let rightTail = dfs(root.right);\\n    // we put left subtree between root and right subtree\\n    if (leftTail) {\\n        leftTail.right = root.right;\\n        root.right = root.left;\\n        root.left = null;\\n    }\\n    // if right subtree is empty, right subtree\\'s tail is actually left subtree\\'s tail\\n    if (!rightTail) {\\n        rightTail = leftTail;\\n    }\\n    return rightTail;\\n}\\n```\n```\\n/*\\nWe need to turn given tree into a right-most skewed tree.\\n\\nAt each root, if it has a left child, we do the following operation:\\nleft subtree\\'s right-most node = root\\'s right subtree\\nright subtree = left leftsubtree\\nleft subtree = null\\n\\nThen, we traverse right because left node will be null at this point\\n*/\\nvar flatten = function(root) {\\n    let cur = root;\\n    // every time root has a left child\\n    // we rearrange so that left subtree gets placed in the correct position of right subtree\\n    while (cur !== null) {\\n        // ensure that left subtree is moved to the right subtree\\n        // and hence left subtree is null\\n        if (cur.left) {\\n            rightMost = findRightMost(cur.left);\\n            rightMost.right = cur.right;\\n            cur.right = cur.left;\\n            cur.left = null;\\n        }\\n        // left subtree is null so there is no need to traverse left\\n        cur = cur.right;\\n    }\\n    return root;\\n    // T.C: O(N), we traverse each node twice at most\\n    // S.C: O(1)\\n};\\n\\nfunction findRightMost(root) {\\n    let cur = root;\\n    while (cur.right) {\\n        cur = cur.right;\\n    }\\n    return cur;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 854857,
                "title": "python-dfs-recursive-easy-to-understand-with-great-details",
                "content": "I used the helper function to help organize the left and right subtree and there are four situations:\\n1. left O right X : \\n\\t\\tReorganize the left subtree and put it to the right subtree\\n\\t\\tReset the left subtree\\n\\t\\t\\n2. left O right O:\\n\\t   1.  Reorganize the right subtree and store it to a temporary pointer\\n\\t   2.  Reorganize the left subtree and store it to the right\\n\\t   3.  Create a current pointer point to the head of right subtree (already be replace by left subtree)\\n\\t   4.  Use current pointer to loop through the right subtree till the end and connect it with temporary pointer\\n\\t       (so the left and right subtree are organized and connected together)\\n\\t   5. Reset the left subtree\\n\\n3. left X right O\\n\\t\\tReorganize the right subtree and put it back to the right subtree\\n\\n4. left X right X\\n       Just return current node\\n\\n```\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        # call helper function to reorganize the subtree\\n        self.helper(root)\\n    \\n    # reorganize function\\n    def helper(self, node):\\n        if node:\\n            if node.left:\\n                \\n                # helper function helps me reorganize the left subtree\\n                node.left = self.helper(node.left)\\n                \\n                # if there is a right subtree \\n                if node.right:\\n                    \\n                    # reorganize the right subtree and store it in temporary pointer\\n                    tmp = self.helper(node.right)\\n                    \\n                    # replace the right subtree with the organized left subtree\\n                    node.right = node.left\\n                    \\n                    # create a current pointer point to the head of right subtree\\n                    cur = node.right\\n                    \\n                    # loop till the end of the organized right subtreee\\n                    while cur.right:\\n                        cur = cur.right\\n                    \\n                    # reconnect back the temporary pointer(previous organized right subtree) \\n                    # to the end of current right subtree\\n                    cur.right = tmp\\n                    \\n                    # reset the left subtree since I already organized it and put it to the right subtree \\n                    node.left = None\\n                    \\n                else:\\n                    # if there is no right subtree, then just organize the \\n                    # left sutree and put it to the right subtree \\n                    node.right = self.helper(node.left)\\n                    \\n                    # reset the left subtree\\n                    node.left = None\\n            else:\\n                # if there is no left subtree, then just reorganize the right subtree\\n                # and put it to the right\\n                node.right = self.helper(node.right)\\n                \\n        return node\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        # call helper function to reorganize the subtree\\n        self.helper(root)\\n    \\n    # reorganize function\\n    def helper(self, node):\\n        if node:\\n            if node.left:\\n                \\n                # helper function helps me reorganize the left subtree\\n                node.left = self.helper(node.left)\\n                \\n                # if there is a right subtree \\n                if node.right:\\n                    \\n                    # reorganize the right subtree and store it in temporary pointer\\n                    tmp = self.helper(node.right)\\n                    \\n                    # replace the right subtree with the organized left subtree\\n                    node.right = node.left\\n                    \\n                    # create a current pointer point to the head of right subtree\\n                    cur = node.right\\n                    \\n                    # loop till the end of the organized right subtreee\\n                    while cur.right:\\n                        cur = cur.right\\n                    \\n                    # reconnect back the temporary pointer(previous organized right subtree) \\n                    # to the end of current right subtree\\n                    cur.right = tmp\\n                    \\n                    # reset the left subtree since I already organized it and put it to the right subtree \\n                    node.left = None\\n                    \\n                else:\\n                    # if there is no right subtree, then just organize the \\n                    # left sutree and put it to the right subtree \\n                    node.right = self.helper(node.left)\\n                    \\n                    # reset the left subtree\\n                    node.left = None\\n            else:\\n                # if there is no left subtree, then just reorganize the right subtree\\n                # and put it to the right\\n                node.right = self.helper(node.right)\\n                \\n        return node\\n```",
                "codeTag": "Java"
            },
            {
                "id": 846468,
                "title": "javascript-solution-preorder-traversal-approach",
                "content": "```\\nvar flatten = function(root) {\\n    let last = null;\\n    \\n    preOrderTraversal(root);\\n    return root;\\n    \\n    function preOrderTraversal(node) {\\n        if (node) {\\n            if (last) {\\n                last.left = null;\\n                last.right = node;\\n            }\\n            \\n            last = node;\\n            const right = node.right;  // (1)\\n            \\n            preOrderTraversal(node.left);\\n            preOrderTraversal(right);\\n        }\\n    }\\n};\\n\\n/*\\n\\nComments:\\n\\n(1) The reason we need this is because when we first recursively traverse the left subtree and hit the \"if(last)\" conditional and \\n\\twe set the last.right = node, we don\\'t have the correct reference to node.right by the time we hit the right subtree.\\n\\t\\n*/\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar flatten = function(root) {\\n    let last = null;\\n    \\n    preOrderTraversal(root);\\n    return root;\\n    \\n    function preOrderTraversal(node) {\\n        if (node) {\\n            if (last) {\\n                last.left = null;\\n                last.right = node;\\n            }\\n            \\n            last = node;\\n            const right = node.right;  // (1)\\n            \\n            preOrderTraversal(node.left);\\n            preOrderTraversal(right);\\n        }\\n    }\\n};\\n\\n/*\\n\\nComments:\\n\\n(1) The reason we need this is because when we first recursively traverse the left subtree and hit the \"if(last)\" conditional and \\n\\twe set the last.right = node, we don\\'t have the correct reference to node.right by the time we hit the right subtree.\\n\\t\\n*/\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 768317,
                "title": "my-100-faster-c-solution",
                "content": "The approach is to recursively construct preorder traversal.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void inorder(TreeNode *A, TreeNode *&prev)\\n    {\\n        if(A==NULL) return;        \\n        inorder(A->right,prev);\\n        inorder(A->left,prev);\\n        // if(prev) cout << prev->val << \" -> \";\\n        // cout << A->val << \"\\\\n \";\\n        A->left= NULL;\\n        A->right= prev;\\n        prev= A;\\n    }\\n    void flatten(TreeNode* root) {\\n        TreeNode *A= root, *prev= NULL;\\n        inorder(A, prev);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void inorder(TreeNode *A, TreeNode *&prev)\\n    {\\n        if(A==NULL) return;        \\n        inorder(A->right,prev);\\n        inorder(A->left,prev);\\n        // if(prev) cout << prev->val << \" -> \";\\n        // cout << A->val << \"\\\\n \";\\n        A->left= NULL;\\n        A->right= prev;\\n        prev= A;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 762856,
                "title": "c-update-in-place-using-inorder-predecessor",
                "content": "```csharp\\npublic void Flatten(TreeNode root) \\n{\\n\\tTreeNode tree = root;\\n\\n\\twhile(tree != null)\\n\\t{\\n\\t\\tif(tree.left != null)\\n\\t\\t{            \\n\\t\\t\\tvar predecessor = tree.left;\\n\\n\\t\\t\\twhile(predecessor.right != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tpredecessor = predecessor.right;\\n\\t\\t\\t}\\n\\n\\t\\t\\tpredecessor.right = tree.right;\\n\\t\\t\\ttree.right = tree.left;\\n\\t\\t\\ttree.left = null;\\n\\t\\t}\\n\\n\\t\\ttree = tree.right;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic void Flatten(TreeNode root) \\n{\\n\\tTreeNode tree = root;\\n\\n\\twhile(tree != null)\\n\\t{\\n\\t\\tif(tree.left != null)\\n\\t\\t{            \\n\\t\\t\\tvar predecessor = tree.left;\\n\\n\\t\\t\\twhile(predecessor.right != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tpredecessor = predecessor.right;\\n\\t\\t\\t}\\n\\n\\t\\t\\tpredecessor.right = tree.right;\\n\\t\\t\\ttree.right = tree.left;\\n\\t\\t\\ttree.left = null;\\n\\t\\t}\\n\\n\\t\\ttree = tree.right;\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 683792,
                "title": "java-beats-100",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        while (root != null){\\n            if (root.left == null){\\n                root = root.right;\\n            } else {\\n                TreeNode pred = root.left;\\n                while (pred.right != null){\\n                    pred = pred.right;\\n                }\\n                pred.right = root.right;\\n                root.right = root.left;\\n                root.left = null;\\n                root = root.right;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        while (root != null){\\n            if (root.left == null){\\n                root = root.right;\\n            } else {\\n                TreeNode pred = root.left;\\n                while (pred.right != null){\\n                    pred = pred.right;\\n                }\\n                pred.right = root.right;\\n                root.right = root.left;\\n                root.left = null;\\n                root = root.right;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 674898,
                "title": "c-8-lines-of-code-o-1-space-probably-best-solution-so-far-recursive",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* prev = nullptr;\\n    void flatten(TreeNode* root) {\\n        if (root == nullptr)\\n            return;\\n        flatten(root->right);\\n        flatten(root->left);\\n        root->right = prev;\\n        root->left = nullptr;\\n        prev = root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* prev = nullptr;\\n    void flatten(TreeNode* root) {\\n        if (root == nullptr)\\n            return;\\n        flatten(root->right);\\n        flatten(root->left);\\n        root->right = prev;\\n        root->left = nullptr;\\n        prev = root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 578596,
                "title": "c-with-queue",
                "content": "```\\npublic class Solution {\\n     Queue<TreeNode> q=new  Queue<TreeNode>();\\n    public void Flatten(TreeNode root) {\\n        if(root==null) return;\\n     PreOrder(root);\\n    root=q.Dequeue();\\n        \\n     while(q.Count>0)\\n     {\\n         root.right=q.Dequeue();\\n         root.left=null;\\n         root=root.right;\\n     }\\n        \\n    }\\n    public void PreOrder(TreeNode root)\\n    {\\n        if(root==null) return;\\n        q.Enqueue(root);\\n        PreOrder( root.left);\\n        PreOrder( root.right);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n     Queue<TreeNode> q=new  Queue<TreeNode>();\\n    public void Flatten(TreeNode root) {\\n        if(root==null) return;\\n     PreOrder(root);\\n    root=q.Dequeue();\\n        \\n     while(q.Count>0)\\n     {\\n         root.right=q.Dequeue();\\n         root.left=null;\\n         root=root.right;\\n     }",
                "codeTag": "Java"
            },
            {
                "id": 519647,
                "title": "javascript-simple-pre-order-list",
                "content": "* build a pre-order list of nodes\\n* iterate list one at a time (from first to one before last), and re-wire nodes\\n* handle last node\\n\\n```javascript\\nconst flatten = (root) => {\\n    const list = [];\\n    helper(root, list);\\n    \\n    if(list.length === 0 ) return;\\n    \\n    for(let i = 0; i < list.length - 1; i++) {\\n        const node = list[i];\\n        node.left = null;\\n        node.right = list[i + 1];\\n    }\\n    \\n    const lastNode = list[list.length -1];\\n    lastNode.left = null;\\n    lastNode.right = null;\\n};\\n\\nconst helper = (node, list) => {\\n    if(!node) return;\\n    \\n    list.push(node);\\n    helper(node.left, list);\\n    helper(node.right, list);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst flatten = (root) => {\\n    const list = [];\\n    helper(root, list);\\n    \\n    if(list.length === 0 ) return;\\n    \\n    for(let i = 0; i < list.length - 1; i++) {\\n        const node = list[i];\\n        node.left = null;\\n        node.right = list[i + 1];\\n    }\\n    \\n    const lastNode = list[list.length -1];\\n    lastNode.left = null;\\n    lastNode.right = null;\\n};\\n\\nconst helper = (node, list) => {\\n    if(!node) return;\\n    \\n    list.push(node);\\n    helper(node.left, list);\\n    helper(node.right, list);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 375312,
                "title": "easy-python-solution",
                "content": "```python\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        # put right subtree to the left subtree\\'s right-most\\n        # put left subtrees to the right\\n        # go to right subtrees and repeat\\n        if not root:\\n            return\\n        node = root.left\\n        if node:\\n            while node.right:\\n                node = node.right\\n            node.right = root.right\\n            root.right = root.left\\n            root.left = None\\n        self.flatten(root.right)\\n```\\nAssume there are `N` nodes, the function recurs `N` times, the `while` loops at most costs `N - 1` totally, so it is `O(N)`.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        # put right subtree to the left subtree\\'s right-most\\n        # put left subtrees to the right\\n        # go to right subtrees and repeat\\n        if not root:\\n            return\\n        node = root.left\\n        if node:\\n            while node.right:\\n                node = node.right\\n            node.right = root.right\\n            root.right = root.left\\n            root.left = None\\n        self.flatten(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 319149,
                "title": "simple-python-solution-straightforward-recursion",
                "content": "```\\n    def flatten(self, root: TreeNode) -> None:\\n        if not root:\\n            return\\n        self.flatten(root.left)\\n        self.flatten(root.right)\\n        if root.left:\\n            node = root.left\\n            while node.right:\\n                node = node.right\\n            node.right = root.right\\n            root.right = root.left\\n            root.left = None\\n```",
                "solutionTags": [],
                "code": "```\\n    def flatten(self, root: TreeNode) -> None:\\n        if not root:\\n            return\\n        self.flatten(root.left)\\n        self.flatten(root.right)\\n        if root.left:\\n            node = root.left\\n            while node.right:\\n                node = node.right\\n            node.right = root.right\\n            root.right = root.left\\n            root.left = None\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 314001,
                "title": "very-easy-to-understand-java-solution",
                "content": "```\\npublic void flatten(TreeNode root) {\\n        if(root == null) return;\\n        TreeNode left = root.left, right = root.right;\\n        flatten(left);\\n        flatten(right);\\n        TreeNode tailleft = tail(left);\\n        root.left = null;\\n\\t\\n\\t\\t//if the tree does not have left subtree, connect right subtree directly\\n        if(tailleft == null) root.right = right;\\n        else {\\n            root.right = left;\\n            tailleft.right = right;\\n        }\\n    }\\n\\t//find the tail of left subtree\\n    private TreeNode tail(TreeNode root){\\n        if(root == null) return root;\\n        while(root.right != null)\\n            root = root.right;\\n        return root;\\n\\t}",
                "solutionTags": [],
                "code": "```\\npublic void flatten(TreeNode root) {\\n        if(root == null) return;\\n        TreeNode left = root.left, right = root.right;\\n        flatten(left);\\n        flatten(right);\\n        TreeNode tailleft = tail(left);\\n        root.left = null;\\n\\t\\n\\t\\t//if the tree does not have left subtree, connect right subtree directly\\n        if(tailleft == null) root.right = right;\\n        else {\\n            root.right = left;\\n            tailleft.right = right;\\n        }\\n    }\\n\\t//find the tail of left subtree\\n    private TreeNode tail(TreeNode root){\\n        if(root == null) return root;\\n        while(root.right != null)\\n            root = root.right;\\n        return root;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 212981,
                "title": "beats-100-swift-solution-o-n-time",
                "content": "```\\nclass Solution {\\n    var cur: TreeNode?\\n    \\n    func function(_ root: TreeNode?) {\\n        if var node = root {\\n            var left = node.left\\n            var right = node.right\\n            node.left = nil\\n            node.right = nil\\n            if cur != nil {\\n                cur!.right = node    \\n            }\\n            cur = node\\n            function(left)\\n            function(right)\\n        }\\n    }\\n    func flatten(_ root: TreeNode?) {\\n        function(root)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    var cur: TreeNode?\\n    \\n    func function(_ root: TreeNode?) {\\n        if var node = root {\\n            var left = node.left\\n            var right = node.right\\n            node.left = nil\\n            node.right = nil\\n            if cur != nil {\\n                cur!.right = node    \\n            }\\n            cur = node\\n            function(left)\\n            function(right)\\n        }\\n    }\\n    func flatten(_ root: TreeNode?) {\\n        function(root)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 184711,
                "title": "java-solution-iterative-using-queue",
                "content": "```java\\n\\t/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        if (root == null)\\n            return;\\n        \\n        Queue<TreeNode> q = new LinkedList();\\n        populateQueue(q, root);\\n        \\n        TreeNode curr = q.poll();\\n        while (q.size() > 0){\\n            curr.right = q.poll();\\n            curr.left = null;\\n            curr = curr.right;\\n        }\\n    }\\n    \\n    private void populateQueue(Queue q, TreeNode node){\\n        if (node == null)\\n            return;\\n        \\n        q.add(node);\\n        populateQueue(q, node.left);\\n        populateQueue(q, node.right);\\n    }\\n}\\n\\t```",
                "solutionTags": [],
                "code": "```java\\n\\t/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        if (root == null)\\n            return;\\n        \\n        Queue<TreeNode> q = new LinkedList();\\n        populateQueue(q, root);\\n        \\n        TreeNode curr = q.poll();\\n        while (q.size() > 0){\\n            curr.right = q.poll();\\n            curr.left = null;\\n            curr = curr.right;\\n        }\\n    }\\n    \\n    private void populateQueue(Queue q, TreeNode node){\\n        if (node == null)\\n            return;\\n        \\n        q.add(node);\\n        populateQueue(q, node.left);\\n        populateQueue(q, node.right);\\n    }\\n}\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 158025,
                "title": "python-dfs",
                "content": "###  114. Flatten the Binary Tree to Linked List\\n```\\n> \\u7C7B\\u578B\\uFF1ADFS\\u904D\\u5386\\n> Time Complexity O(n)\\n> Space Complexity O(h)\\n```\\n\\n\\u901A\\u8FC7\\u50A8\\u5B58\\u4E00\\u4E2A\\u5168\\u7403\\u53D8\\u91CF\\uFF0C\\u4ECE\\u6700\\u53F3\\u8FB9\\u6700\\u4E0B\\u9762\\u7684Node\\u5F00\\u59CB\\u8FD4\\u56DE\\uFF0C\\u6BCF\\u6B21\\u8FD4\\u56DE\\u7684\\u65F6\\u5019\\u66F4\\u65B0\\u5F53\\u524D\\u8282\\u70B9\\u548C\\u5168\\u7403\\u53D8\\u91CF\\u7684\\u5173\\u7CFB\\uFF0C\\u5177\\u4F53\\u53EF\\u4EE5\\u770B\\u4EE5\\u4E0B\\u89C6\\u9891\\n\\n[\\u516C\\u747E\\u8BB2\\u89E3](https://www.youtube.com/watch?v=LfKRZ_qCmYQ)\\n\\n```\\nclass Solution(object):\\n    def __init__(self):\\n        self.prev = None\\n        \\n    def flatten(self, root):\\n        if not root: \\n            return None\\n        \\n        self.flatten(root.right)\\n        self.flatten(root.left)\\n        \\n        root.right = self.prev\\n        root.left = None\\n        self.prev = root\\n```",
                "solutionTags": [],
                "code": "```\\n> \\u7C7B\\u578B\\uFF1ADFS\\u904D\\u5386\\n> Time Complexity O(n)\\n> Space Complexity O(h)\\n```\n```\\nclass Solution(object):\\n    def __init__(self):\\n        self.prev = None\\n        \\n    def flatten(self, root):\\n        if not root: \\n            return None\\n        \\n        self.flatten(root.right)\\n        self.flatten(root.left)\\n        \\n        root.right = self.prev\\n        root.left = None\\n        self.prev = root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37033,
                "title": "javascript-solution-using-recursion",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {void} Do not return anything, modify root in-place instead.\\n */\\nvar flatten = function(root) {\\n  if (!root) { return; }\\n  \\n  let left = root.left;\\n  let right = root.right;\\n  \\n  flatten(left);\\n  flatten(right);\\n  \\n  root.left = null;\\n  root.right = left;\\n  let cur = root;\\n  while (cur.right !== null) { cur = cur.right; }\\n  cur.right = right;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {void} Do not return anything, modify root in-place instead.\\n */\\nvar flatten = function(root) {\\n  if (!root) { return; }\\n  \\n  let left = root.left;\\n  let right = root.right;\\n  \\n  flatten(left);\\n  flatten(right);\\n  \\n  root.left = null;\\n  root.right = left;\\n  let cur = root;\\n  while (cur.right !== null) { cur = cur.right; }\\n  cur.right = right;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 37108,
                "title": "easy-solution-in-c",
                "content": "    class Solution {\\n    public:\\n       \\tvoid flatten(TreeNode* root) {\\n    \\t\\tif (root != NULL)\\n    \\t\\t\\tflat(root);\\n    \\t}\\n    \\n    \\tTreeNode* flat(TreeNode* root) {\\n    \\t\\tTreeNode *left = root->left;\\n    \\t\\tTreeNode *right = root->right;\\n    \\t\\tTreeNode *tail = root;\\n    \\t\\tif (left != NULL) {\\n     \\t\\t\\ttail->right = left;\\n    \\t\\t\\ttail->left = NULL;\\n    \\t\\t\\ttail =flat(left);\\n    \\t\\t}\\n    \\t\\tif (right != NULL) {\\n     \\t\\t\\ttail->right = right;\\n    \\t\\t\\ttail->left = NULL;\\n    \\t\\t\\ttail =flat(right);\\n    \\t\\t}\\n    \\t\\treturn tail;\\n    \\n    \\t}\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n       \\tvoid flatten(TreeNode* root) {\\n    \\t\\tif (root != NULL)\\n    \\t\\t\\tflat(root);\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 37113,
                "title": "java-preorder-1ms-solution",
                "content": "    public class Solution {\\n        TreeNode current;\\n        public void flatten(TreeNode root) {\\n            //if we've been given a null root, just return\\n            if(root == null){ return; }\\n            flattenTree(root);\\n            \\n        }\\n        \\n        private void flattenTree(TreeNode root)\\n        {\\n            if(root == null){ return; }\\n            //set local variables for left and right\\n            TreeNode left = root.left, right = root.right;\\n            //set root.left and root.right to null since we don't want to add them to our resulting linked list\\n            root.left = null;\\n            root.right = null;\\n            //if it's the first run of this function set current to root (the start of the linked list)\\n            if( current == null ){ current = root; }\\n            else\\n            {\\n                //add current TreeNode to the end of the list\\n                current.right = root;\\n                current = current.right;\\n            }\\n            \\n            //DFS, so go left and then right\\n            flattenTree(left);\\n            flattenTree(right);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        TreeNode current;\\n        public void flatten(TreeNode root) {\\n            //if we've been given a null root, just return\\n            if(root == null){ return; }",
                "codeTag": "Java"
            },
            {
                "id": 37081,
                "title": "share-my-7-line-o-1-space-java-code-with-explanations",
                "content": "    /*\\n        \\u628apre-order\\u904d\\u5386\\u5230\\u7684\\u8282\\u70b9\\u6309\\u987a\\u5e8f\\u63a5\\u8d77\\u6765\\u5373\\u53ef.\\n        \\u8981\\u6c42in-place... pre-order\\u5c31\\u662f\\u5148\\u5904\\u7406\\u6839, \\u518d\\u5904\\u7406\\u5de6\\u5b50\\u6811, \\u518d\\u5904\\u7406\\u53f3\\u5b50\\u6811.\\n        \\u6240\\u4ee5\\u53ea\\u8981\\n        -- root.left\\u63a5\\u5728root.right\\u7684\\u4f4d\\u7f6e\\u4e0a\\n        -- \\u539f\\u5148\\u7684root.right\\u63a5\\u5728left subtree\\u7684\"\\u6700\\u53f3\\u8fb9\"\\n    */\\n    public class Solution {\\n        public void flatten(TreeNode root) {\\n            for (; root!=null; root=root.right) {\\n                if (root.left == null) { continue; }\\n                TreeNode p = root.left;  // p != null guaranteed\\n                while (p.right != null) { p = p.right; }\\n                p.right = root.right;\\n                root.right = root.left;\\n                root.left = null;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public void flatten(TreeNode root) {\\n            for (; root!=null; root=root.right) {\\n                if (root.left == null) { continue; }",
                "codeTag": "Java"
            },
            {
                "id": 37184,
                "title": "ac-solution-based-on-morris-traversal",
                "content": "Flattening in this question is actually PRE-ORDER traversal. For each NODE, the sequence after flattening is:\\n\\n    NODE's previous element: the right-most leaf of the root's left branch     \\n    NODE's next     element: NODE's left\\n\\n**Morris traversal algorithm** takes use of the leaf's left and right nodes, so that there's no extra space needed for the traversal. The steps are as the following: \\n\\n1) Find the right-most leaf of the root's left branch:  set leaf's right = root's right; \\n\\n2) Set root's right = root's left if root's left exists; \\n\\n3) Move to root's left branch, if no left branch exists, then move to root's right branch. \\n\\nKeep the above steps until no nodes left, as the following: O(1) extra space\\n\\n    void flatten(TreeNode root) {\\n        while (root != null) {\\n            if (root.left != null && root.right != null) {\\n                TreeNode node = root.left;\\n                while (node.right != null) \\n                    node = node.right; \\n                node.right = root.right;// 1) Find the right-most leaf of the root's left branch:  set leaf's right = root's right; \\n            }  \\n            \\n            if(root.left != null) // 2) Set root's right = root's left if root's left exists; \\n                root.right = root.left; \\n            root.left = null;  \\n            root = root.right;// 3) Move to root's left branch, if no left branch exists, then move to root's right branch.\\n        }\\n    }",
                "solutionTags": [],
                "code": "Flattening in this question is actually PRE-ORDER traversal. For each NODE, the sequence after flattening is:\\n\\n    NODE's previous element: the right-most leaf of the root's left branch     \\n    NODE's next     element: NODE's left\\n\\n**Morris traversal algorithm** takes use of the leaf's left and right nodes, so that there's no extra space needed for the traversal. The steps are as the following: \\n\\n1) Find the right-most leaf of the root's left branch:  set leaf's right = root's right; \\n\\n2) Set root's right = root's left if root's left exists; \\n\\n3) Move to root's left branch, if no left branch exists, then move to root's right branch. \\n\\nKeep the above steps until no nodes left, as the following: O(1) extra space\\n\\n    void flatten(TreeNode root) {\\n        while (root != null) {\\n            if (root.left != null && root.right != null) {\\n                TreeNode node = root.left;\\n                while (node.right != null) \\n                    node = node.right; \\n                node.right = root.right;// 1) Find the right-most leaf of the root's left branch:  set leaf's right = root's right; \\n            }  \\n            \\n            if(root.left != null) // 2) Set root's right = root's left if root's left exists; \\n                root.right = root.left; \\n            root.left = null;  \\n            root = root.right;// 3) Move to root's left branch, if no left branch exists, then move to root's right branch.\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 37259,
                "title": "a-relative-concise-python-code",
                "content": "    class Solution:\\n        # @param root, a tree node\\n        # @return nothing, do it in place\\n        def flatten1(self, root):\\n            if not root:\\n                return\\n            self.flatten(root.left)\\n            self.flatten(root.right)\\n            if root.left:\\n                temp = root.right\\n                root.right = root.left\\n                root.left = None\\n                while root.right:\\n                    root = root.right\\n                root.right = temp",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param root, a tree node\\n        # @return nothing, do it in place\\n        def flatten1(self, root):\\n            if not root:\\n                return\\n            self.flatten(root.left)\\n            self.flatten(root.right)\\n            if root.left:\\n                temp = root.right\\n                root.right = root.left\\n                root.left = None\\n                while root.right:\\n                    root = root.right\\n                root.right = temp",
                "codeTag": "Java"
            },
            {
                "id": 4026232,
                "title": "6",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#include<vector>\\nclass Solution {\\npublic:\\n    vector<int> x;\\n    void helper(TreeNode* root){\\n        if(root==NULL){return;}\\n        x.push_back(root->val);\\n        helper(root->left);\\n        helper(root->right);\\n    }\\n\\n    void flatten(TreeNode* root) {\\n        helper(root);\\n        for(int i=1;i<x.size();i++){\\n            if(root->right!=NULL && root->left!=NULL){\\n            root->right->val=x[i];\\n            root->left=NULL;}\\n            else if(root->right!=NULL){\\n                root->right->val=x[i];}\\n            else if(root->right==NULL && root->left!=NULL){\\n                TreeNode* p = new TreeNode(x[i]);\\n                root->right=p;\\n                root->left=NULL;\\n            }\\n            else{TreeNode* p = new TreeNode(x[i]);\\n                root->right=p;}\\n            root=root->right;\\n        }    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#include<vector>\\nclass Solution {\\npublic:\\n    vector<int> x;\\n    void helper(TreeNode* root){\\n        if(root==NULL){return;}\\n        x.push_back(root->val);\\n        helper(root->left);\\n        helper(root->right);\\n    }\\n\\n    void flatten(TreeNode* root) {\\n        helper(root);\\n        for(int i=1;i<x.size();i++){\\n            if(root->right!=NULL && root->left!=NULL){\\n            root->right->val=x[i];\\n            root->left=NULL;}\\n            else if(root->right!=NULL){\\n                root->right->val=x[i];}\\n            else if(root->right==NULL && root->left!=NULL){\\n                TreeNode* p = new TreeNode(x[i]);\\n                root->right=p;\\n                root->left=NULL;\\n            }\\n            else{TreeNode* p = new TreeNode(x[i]);\\n                root->right=p;}\\n            root=root->right;\\n        }    \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3990488,
                "title": "3-approaches-explanation",
                "content": "# APPROACH - 1 (Using Recursion)\\n\\n\\n## Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe algorithm steps can be stated as: \\n\\n1. If we observe, we are moving in a reverse postorder way : i.e  right, left, root. \\n2. We take a reference variable (say prev) to store the previous node( initialized to NULL).\\n3. Whenever we visit a node, we set the right child to the prev and left child to NULL. \\n4. Next we assign this current node to prev.\\n5. We perform the above two operations on all the nodes in the traversal.\\n\\n## Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n## Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root,TreeNode*& prev) {\\n        if(root == NULL)\\n            return;\\n\\n        flatten(root->right,prev);\\n        flatten(root->left,prev);\\n\\n        root->right = prev;\\n        root->left = NULL;\\n        prev = root;\\n    }\\n\\n    void flatten(TreeNode* root) {\\n        if(root == NULL)\\n            return;\\n\\n        TreeNode* prev = NULL;\\n\\n        flatten(root,prev);\\n\\n    }\\n};\\n```\\n\\n# APPROACH - 2 (Using Stack)\\n\\n## Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn a binary tree, generally, we need to set the right child of the node to the left and the left child to NULL. If the given tree is a left-skewed tree, this action alone will flatten the binary tree.\\n\\nNow the main question arises is what if the current node doesn\\u2019t have a left child? In that case, we don\\u2019t want to assign its right child to NULL( its left child), rather we want it to assign to itself so that our preorder sequence is maintained. In case the right child is also not present(a leaf node) we would want to assign the right child to some parent node\\u2019s right child.\\n\\nTo get to this parent\\u2019s right node we will use a stack. Whenever we are at a node we want to prioritize its left child if it is present. If it is not present we want to look at the right child. A stack is a LIFO data structure, we first push the right child and then the left child. Then we set the right child of the node to the stack\\u2019s top and left child as NULL. This way the stack always provides the correct next node.\\n\\n## Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe algorithm approach can be stated as:\\n\\n1. Take a stack and push the root node to it.\\n2. Set a while loop till the stack is non-empty.\\n3. In every iteration, take the node at the top of the stack( say cur) and pop the stack.\\n4. If cur has a right child, push it to the stack.\\n5. If cur has a left child, push it to the stack.\\n5. Set the right child of cur to node at stack\\u2019s top.\\n6. Set the left child of cur as NULL.\\n\\n## Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n## Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root == NULL)    \\n        return;\\n\\n        stack<TreeNode*> st;\\n\\n        st.push(root);\\n\\n        while(!st.empty()) {\\n            TreeNode* curr = st.top();\\n            st.pop();\\n\\n            if(curr->right)\\n                st.push(curr->right);\\n\\n            if(curr->left)\\n                st.push(curr->left);\\n\\n            if(!st.empty()) {\\n                curr->right = st.top();\\n            }\\n            curr->left = NULL;\\n        }\\n    }\\n};\\n```\\n\\n# APPROACH - 3 (Using Morris Traversal)\\n\\n## Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will use the intuition behind morris\\u2019s traversal. In Morris Traversal we use the concept of a threaded binary tree.\\n\\nIf we set the right child of every node like this(marked in red) and the left child as NULL, our job will be done.\\n\\n## Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. At a node(say cur) if there exists a left child, we will find the rightmost node in the left subtree(say prev).\\n2. We will set prev\\u2019s right child to cur\\u2019s right child,\\n3. We will then set cur\\u2019s right child to it\\u2019s left child.\\n4. We will then move cur to the next node by assigning cur it to its right child\\n5. We will stop the execution when cur points to NULL.\\n\\n## Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n## Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root == NULL)\\n            return;\\n\\n        TreeNode* curr = root;\\n\\n        while(curr) {\\n\\n            if(curr->left) {\\n                TreeNode* prev = curr->left;\\n\\n                while(prev->right) {\\n                    prev = prev->right;\\n                }\\n\\n                prev->right = curr->right;\\n                curr->right = curr->left;\\n\\n\\n            }\\n            curr->left = NULL;\\n            curr = curr->right;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root,TreeNode*& prev) {\\n        if(root == NULL)\\n            return;\\n\\n        flatten(root->right,prev);\\n        flatten(root->left,prev);\\n\\n        root->right = prev;\\n        root->left = NULL;\\n        prev = root;\\n    }\\n\\n    void flatten(TreeNode* root) {\\n        if(root == NULL)\\n            return;\\n\\n        TreeNode* prev = NULL;\\n\\n        flatten(root,prev);\\n\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root == NULL)    \\n        return;\\n\\n        stack<TreeNode*> st;\\n\\n        st.push(root);\\n\\n        while(!st.empty()) {\\n            TreeNode* curr = st.top();\\n            st.pop();\\n\\n            if(curr->right)\\n                st.push(curr->right);\\n\\n            if(curr->left)\\n                st.push(curr->left);\\n\\n            if(!st.empty()) {\\n                curr->right = st.top();\\n            }\\n            curr->left = NULL;\\n        }\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root == NULL)\\n            return;\\n\\n        TreeNode* curr = root;\\n\\n        while(curr) {\\n\\n            if(curr->left) {\\n                TreeNode* prev = curr->left;\\n\\n                while(prev->right) {\\n                    prev = prev->right;\\n                }\\n\\n                prev->right = curr->right;\\n                curr->right = curr->left;\\n\\n\\n            }\\n            curr->left = NULL;\\n            curr = curr->right;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568936,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1803547,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1569861,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1568126,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1568935,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1567860,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1728214,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1576171,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1575264,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1571237,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1568936,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1803547,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1569861,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1568126,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1568935,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1567860,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1728214,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1576171,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1575264,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1571237,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 2075284,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can anyone tell me how to solve problem  ?  I wrote some code  \\nclass Solution { \\n    static ArrayList<Integer> arr = new ArrayList<>();\\n    public void flatten(TreeNode root) {\\n        \\n        if(root == null)\\n        {\\n            return;\\n        }  \\n        arr.add(root.val); \\n        arr.add(null);\\n        flatten(root.left); \\n        flatten(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "That\\'s not the right solution. why are you adding null to your array list. just check on youtube many good videos"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "Question should be convert binary tree to skewed binary tree"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "i might take a lot of time to find logic behind this in an actual interview if i haven\\'t done this earlier"
                    },
                    {
                        "username": "sn82990eha",
                        "content": "Morris Traversal method\n\nClass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        TreeNode * curr=root;\n        while(curr!=NULL){\n            if(curr->left!=NULL){\n                TreeNode *prev=curr->left;\n                while(prev->right){\n                    prev=prev->right;\n                }\n                prev->right=curr->right;\n                curr->right=curr->left;\n                curr->left=NULL;\n            }\n            curr=curr->right;\n        }\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Leetcode Rules Method.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "-_-\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "#### WHY THERE IS NULL IN THE OUTPUT ?\\nBecause essentially we are returning a ***Skewed Binary Tree***, and not a ***Linear Linked List***.\\n\\n- The \"linked list\" should use the same `TreeNode` class where the `right child pointer` points to the ***NEXT NODE*** in the list and the `left child pointer` is always ***NULL***."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "You said it yourself left child is always NULL and thats the main factor for defining a Skewed Binary tree so i dont see it ? \nwhat is your question \n"
                    },
                    {
                        "username": "pravesh_252505",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void recursion(TreeNode *root,TreeNode *&tail,TreeNode *&head){\\n        if(!root)return  ;\\n        cout<<root->val<<endl;\\n        if(!head){\\n            tail=new TreeNode (root->val);\\n            head=tail;\\n             recursion(root->left,tail,head);\\n             recursion(root->right,tail,head);\\n        }\\n        else{ \\n            tail->right=new TreeNode(root->val);\\n            tail->left=NULL;\\n            tail=tail->right;\\n            recursion(root->left,tail,head);\\n            recursion(root->right,tail,head);\\n        }\\n       \\n    }\\n    void flatten(TreeNode* &root) {\\n        TreeNode *tail=NULL,*head=NULL;\\n        recursion(root,tail,head);\\n        root=head;\\n    }\\n};\\nokay so this code is working fine ,wait I mean, after completion of recursion function I\\'m assigning head to root  and on printing root I\\'m getting correct answer but on submitting ,it shows that root is not changed why is it so ?"
                    },
                    {
                        "username": "ayushjha1",
                        "content": "what is the error in this code pls reply\\ngive runtime error\\n\\nclass Solution {\\npublic:\\n    TreeNode* p;\\n    void solve(TreeNode* t){\\n        if(!t)\\n            return;\\n        TreeNode* a=t->right;\\n        p->right=t;\\n        p=p->right;\\n        cout<<p->val<<endl;\\n        TreeNode* b=t->left;\\n        p->left=0;\\n        solve(b);\\n        solve(a);\\n    }\\n\\n    void flatten(TreeNode* root) {\\n        p=root;\\n        solve(root);\\n        root=root->right;\\n    }\\n};"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "The question implicitly frees all memory on every node\\'s left leaf, that is why I got \"use-after-free bug\" because I had left and right pointing to the same node when building the linked list.\\n\\n This caused me hours to debug.\\n"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "Why is this solution giving me wrong answer?\\nI checked in vs code. It gives correct output. Somebody please help pe with this, I\\'m loosing my mind!!!!\\n\\n\\n\\nTreeNode* help(TreeNode *root, TreeNode* &cur)\\n    {\\n        if(root == NULL) return root;\\n        cur = root;\\n        TreeNode *left = root->left, *right = root->right;\\n        root->left = NULL;\\n        cur->right = help(left, cur);\\n        cur->right = help(right, cur);\\n        return root;\\n    }\\n        \\n    void flatten(TreeNode* &root) {\\n        TreeNode *cur = NULL;\\n        root = help(root,cur);\\n    }"
                    },
                    {
                        "username": "AthenaCodes2605",
                        "content": "it is a super easy question, just tests basic linkedlist knowledge "
                    },
                    {
                        "username": "2uringTested",
                        "content": "ohh, it's easy if you do it with recursion, but that taken O(n) stack space. Do it without using that stack space, in O(1) space complexity"
                    }
                ]
            },
            {
                "id": 2057731,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can anyone tell me how to solve problem  ?  I wrote some code  \\nclass Solution { \\n    static ArrayList<Integer> arr = new ArrayList<>();\\n    public void flatten(TreeNode root) {\\n        \\n        if(root == null)\\n        {\\n            return;\\n        }  \\n        arr.add(root.val); \\n        arr.add(null);\\n        flatten(root.left); \\n        flatten(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "That\\'s not the right solution. why are you adding null to your array list. just check on youtube many good videos"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "Question should be convert binary tree to skewed binary tree"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "i might take a lot of time to find logic behind this in an actual interview if i haven\\'t done this earlier"
                    },
                    {
                        "username": "sn82990eha",
                        "content": "Morris Traversal method\n\nClass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        TreeNode * curr=root;\n        while(curr!=NULL){\n            if(curr->left!=NULL){\n                TreeNode *prev=curr->left;\n                while(prev->right){\n                    prev=prev->right;\n                }\n                prev->right=curr->right;\n                curr->right=curr->left;\n                curr->left=NULL;\n            }\n            curr=curr->right;\n        }\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Leetcode Rules Method.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "-_-\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "#### WHY THERE IS NULL IN THE OUTPUT ?\\nBecause essentially we are returning a ***Skewed Binary Tree***, and not a ***Linear Linked List***.\\n\\n- The \"linked list\" should use the same `TreeNode` class where the `right child pointer` points to the ***NEXT NODE*** in the list and the `left child pointer` is always ***NULL***."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "You said it yourself left child is always NULL and thats the main factor for defining a Skewed Binary tree so i dont see it ? \nwhat is your question \n"
                    },
                    {
                        "username": "pravesh_252505",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void recursion(TreeNode *root,TreeNode *&tail,TreeNode *&head){\\n        if(!root)return  ;\\n        cout<<root->val<<endl;\\n        if(!head){\\n            tail=new TreeNode (root->val);\\n            head=tail;\\n             recursion(root->left,tail,head);\\n             recursion(root->right,tail,head);\\n        }\\n        else{ \\n            tail->right=new TreeNode(root->val);\\n            tail->left=NULL;\\n            tail=tail->right;\\n            recursion(root->left,tail,head);\\n            recursion(root->right,tail,head);\\n        }\\n       \\n    }\\n    void flatten(TreeNode* &root) {\\n        TreeNode *tail=NULL,*head=NULL;\\n        recursion(root,tail,head);\\n        root=head;\\n    }\\n};\\nokay so this code is working fine ,wait I mean, after completion of recursion function I\\'m assigning head to root  and on printing root I\\'m getting correct answer but on submitting ,it shows that root is not changed why is it so ?"
                    },
                    {
                        "username": "ayushjha1",
                        "content": "what is the error in this code pls reply\\ngive runtime error\\n\\nclass Solution {\\npublic:\\n    TreeNode* p;\\n    void solve(TreeNode* t){\\n        if(!t)\\n            return;\\n        TreeNode* a=t->right;\\n        p->right=t;\\n        p=p->right;\\n        cout<<p->val<<endl;\\n        TreeNode* b=t->left;\\n        p->left=0;\\n        solve(b);\\n        solve(a);\\n    }\\n\\n    void flatten(TreeNode* root) {\\n        p=root;\\n        solve(root);\\n        root=root->right;\\n    }\\n};"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "The question implicitly frees all memory on every node\\'s left leaf, that is why I got \"use-after-free bug\" because I had left and right pointing to the same node when building the linked list.\\n\\n This caused me hours to debug.\\n"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "Why is this solution giving me wrong answer?\\nI checked in vs code. It gives correct output. Somebody please help pe with this, I\\'m loosing my mind!!!!\\n\\n\\n\\nTreeNode* help(TreeNode *root, TreeNode* &cur)\\n    {\\n        if(root == NULL) return root;\\n        cur = root;\\n        TreeNode *left = root->left, *right = root->right;\\n        root->left = NULL;\\n        cur->right = help(left, cur);\\n        cur->right = help(right, cur);\\n        return root;\\n    }\\n        \\n    void flatten(TreeNode* &root) {\\n        TreeNode *cur = NULL;\\n        root = help(root,cur);\\n    }"
                    },
                    {
                        "username": "AthenaCodes2605",
                        "content": "it is a super easy question, just tests basic linkedlist knowledge "
                    },
                    {
                        "username": "2uringTested",
                        "content": "ohh, it's easy if you do it with recursion, but that taken O(n) stack space. Do it without using that stack space, in O(1) space complexity"
                    }
                ]
            },
            {
                "id": 2031192,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can anyone tell me how to solve problem  ?  I wrote some code  \\nclass Solution { \\n    static ArrayList<Integer> arr = new ArrayList<>();\\n    public void flatten(TreeNode root) {\\n        \\n        if(root == null)\\n        {\\n            return;\\n        }  \\n        arr.add(root.val); \\n        arr.add(null);\\n        flatten(root.left); \\n        flatten(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "That\\'s not the right solution. why are you adding null to your array list. just check on youtube many good videos"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "Question should be convert binary tree to skewed binary tree"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "i might take a lot of time to find logic behind this in an actual interview if i haven\\'t done this earlier"
                    },
                    {
                        "username": "sn82990eha",
                        "content": "Morris Traversal method\n\nClass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        TreeNode * curr=root;\n        while(curr!=NULL){\n            if(curr->left!=NULL){\n                TreeNode *prev=curr->left;\n                while(prev->right){\n                    prev=prev->right;\n                }\n                prev->right=curr->right;\n                curr->right=curr->left;\n                curr->left=NULL;\n            }\n            curr=curr->right;\n        }\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Leetcode Rules Method.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "-_-\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "#### WHY THERE IS NULL IN THE OUTPUT ?\\nBecause essentially we are returning a ***Skewed Binary Tree***, and not a ***Linear Linked List***.\\n\\n- The \"linked list\" should use the same `TreeNode` class where the `right child pointer` points to the ***NEXT NODE*** in the list and the `left child pointer` is always ***NULL***."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "You said it yourself left child is always NULL and thats the main factor for defining a Skewed Binary tree so i dont see it ? \nwhat is your question \n"
                    },
                    {
                        "username": "pravesh_252505",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void recursion(TreeNode *root,TreeNode *&tail,TreeNode *&head){\\n        if(!root)return  ;\\n        cout<<root->val<<endl;\\n        if(!head){\\n            tail=new TreeNode (root->val);\\n            head=tail;\\n             recursion(root->left,tail,head);\\n             recursion(root->right,tail,head);\\n        }\\n        else{ \\n            tail->right=new TreeNode(root->val);\\n            tail->left=NULL;\\n            tail=tail->right;\\n            recursion(root->left,tail,head);\\n            recursion(root->right,tail,head);\\n        }\\n       \\n    }\\n    void flatten(TreeNode* &root) {\\n        TreeNode *tail=NULL,*head=NULL;\\n        recursion(root,tail,head);\\n        root=head;\\n    }\\n};\\nokay so this code is working fine ,wait I mean, after completion of recursion function I\\'m assigning head to root  and on printing root I\\'m getting correct answer but on submitting ,it shows that root is not changed why is it so ?"
                    },
                    {
                        "username": "ayushjha1",
                        "content": "what is the error in this code pls reply\\ngive runtime error\\n\\nclass Solution {\\npublic:\\n    TreeNode* p;\\n    void solve(TreeNode* t){\\n        if(!t)\\n            return;\\n        TreeNode* a=t->right;\\n        p->right=t;\\n        p=p->right;\\n        cout<<p->val<<endl;\\n        TreeNode* b=t->left;\\n        p->left=0;\\n        solve(b);\\n        solve(a);\\n    }\\n\\n    void flatten(TreeNode* root) {\\n        p=root;\\n        solve(root);\\n        root=root->right;\\n    }\\n};"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "The question implicitly frees all memory on every node\\'s left leaf, that is why I got \"use-after-free bug\" because I had left and right pointing to the same node when building the linked list.\\n\\n This caused me hours to debug.\\n"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "Why is this solution giving me wrong answer?\\nI checked in vs code. It gives correct output. Somebody please help pe with this, I\\'m loosing my mind!!!!\\n\\n\\n\\nTreeNode* help(TreeNode *root, TreeNode* &cur)\\n    {\\n        if(root == NULL) return root;\\n        cur = root;\\n        TreeNode *left = root->left, *right = root->right;\\n        root->left = NULL;\\n        cur->right = help(left, cur);\\n        cur->right = help(right, cur);\\n        return root;\\n    }\\n        \\n    void flatten(TreeNode* &root) {\\n        TreeNode *cur = NULL;\\n        root = help(root,cur);\\n    }"
                    },
                    {
                        "username": "AthenaCodes2605",
                        "content": "it is a super easy question, just tests basic linkedlist knowledge "
                    },
                    {
                        "username": "2uringTested",
                        "content": "ohh, it's easy if you do it with recursion, but that taken O(n) stack space. Do it without using that stack space, in O(1) space complexity"
                    }
                ]
            },
            {
                "id": 2012121,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can anyone tell me how to solve problem  ?  I wrote some code  \\nclass Solution { \\n    static ArrayList<Integer> arr = new ArrayList<>();\\n    public void flatten(TreeNode root) {\\n        \\n        if(root == null)\\n        {\\n            return;\\n        }  \\n        arr.add(root.val); \\n        arr.add(null);\\n        flatten(root.left); \\n        flatten(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "That\\'s not the right solution. why are you adding null to your array list. just check on youtube many good videos"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "Question should be convert binary tree to skewed binary tree"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "i might take a lot of time to find logic behind this in an actual interview if i haven\\'t done this earlier"
                    },
                    {
                        "username": "sn82990eha",
                        "content": "Morris Traversal method\n\nClass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        TreeNode * curr=root;\n        while(curr!=NULL){\n            if(curr->left!=NULL){\n                TreeNode *prev=curr->left;\n                while(prev->right){\n                    prev=prev->right;\n                }\n                prev->right=curr->right;\n                curr->right=curr->left;\n                curr->left=NULL;\n            }\n            curr=curr->right;\n        }\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Leetcode Rules Method.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "-_-\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "#### WHY THERE IS NULL IN THE OUTPUT ?\\nBecause essentially we are returning a ***Skewed Binary Tree***, and not a ***Linear Linked List***.\\n\\n- The \"linked list\" should use the same `TreeNode` class where the `right child pointer` points to the ***NEXT NODE*** in the list and the `left child pointer` is always ***NULL***."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "You said it yourself left child is always NULL and thats the main factor for defining a Skewed Binary tree so i dont see it ? \nwhat is your question \n"
                    },
                    {
                        "username": "pravesh_252505",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void recursion(TreeNode *root,TreeNode *&tail,TreeNode *&head){\\n        if(!root)return  ;\\n        cout<<root->val<<endl;\\n        if(!head){\\n            tail=new TreeNode (root->val);\\n            head=tail;\\n             recursion(root->left,tail,head);\\n             recursion(root->right,tail,head);\\n        }\\n        else{ \\n            tail->right=new TreeNode(root->val);\\n            tail->left=NULL;\\n            tail=tail->right;\\n            recursion(root->left,tail,head);\\n            recursion(root->right,tail,head);\\n        }\\n       \\n    }\\n    void flatten(TreeNode* &root) {\\n        TreeNode *tail=NULL,*head=NULL;\\n        recursion(root,tail,head);\\n        root=head;\\n    }\\n};\\nokay so this code is working fine ,wait I mean, after completion of recursion function I\\'m assigning head to root  and on printing root I\\'m getting correct answer but on submitting ,it shows that root is not changed why is it so ?"
                    },
                    {
                        "username": "ayushjha1",
                        "content": "what is the error in this code pls reply\\ngive runtime error\\n\\nclass Solution {\\npublic:\\n    TreeNode* p;\\n    void solve(TreeNode* t){\\n        if(!t)\\n            return;\\n        TreeNode* a=t->right;\\n        p->right=t;\\n        p=p->right;\\n        cout<<p->val<<endl;\\n        TreeNode* b=t->left;\\n        p->left=0;\\n        solve(b);\\n        solve(a);\\n    }\\n\\n    void flatten(TreeNode* root) {\\n        p=root;\\n        solve(root);\\n        root=root->right;\\n    }\\n};"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "The question implicitly frees all memory on every node\\'s left leaf, that is why I got \"use-after-free bug\" because I had left and right pointing to the same node when building the linked list.\\n\\n This caused me hours to debug.\\n"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "Why is this solution giving me wrong answer?\\nI checked in vs code. It gives correct output. Somebody please help pe with this, I\\'m loosing my mind!!!!\\n\\n\\n\\nTreeNode* help(TreeNode *root, TreeNode* &cur)\\n    {\\n        if(root == NULL) return root;\\n        cur = root;\\n        TreeNode *left = root->left, *right = root->right;\\n        root->left = NULL;\\n        cur->right = help(left, cur);\\n        cur->right = help(right, cur);\\n        return root;\\n    }\\n        \\n    void flatten(TreeNode* &root) {\\n        TreeNode *cur = NULL;\\n        root = help(root,cur);\\n    }"
                    },
                    {
                        "username": "AthenaCodes2605",
                        "content": "it is a super easy question, just tests basic linkedlist knowledge "
                    },
                    {
                        "username": "2uringTested",
                        "content": "ohh, it's easy if you do it with recursion, but that taken O(n) stack space. Do it without using that stack space, in O(1) space complexity"
                    }
                ]
            },
            {
                "id": 1995358,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can anyone tell me how to solve problem  ?  I wrote some code  \\nclass Solution { \\n    static ArrayList<Integer> arr = new ArrayList<>();\\n    public void flatten(TreeNode root) {\\n        \\n        if(root == null)\\n        {\\n            return;\\n        }  \\n        arr.add(root.val); \\n        arr.add(null);\\n        flatten(root.left); \\n        flatten(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "That\\'s not the right solution. why are you adding null to your array list. just check on youtube many good videos"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "Question should be convert binary tree to skewed binary tree"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "i might take a lot of time to find logic behind this in an actual interview if i haven\\'t done this earlier"
                    },
                    {
                        "username": "sn82990eha",
                        "content": "Morris Traversal method\n\nClass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        TreeNode * curr=root;\n        while(curr!=NULL){\n            if(curr->left!=NULL){\n                TreeNode *prev=curr->left;\n                while(prev->right){\n                    prev=prev->right;\n                }\n                prev->right=curr->right;\n                curr->right=curr->left;\n                curr->left=NULL;\n            }\n            curr=curr->right;\n        }\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Leetcode Rules Method.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "-_-\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "#### WHY THERE IS NULL IN THE OUTPUT ?\\nBecause essentially we are returning a ***Skewed Binary Tree***, and not a ***Linear Linked List***.\\n\\n- The \"linked list\" should use the same `TreeNode` class where the `right child pointer` points to the ***NEXT NODE*** in the list and the `left child pointer` is always ***NULL***."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "You said it yourself left child is always NULL and thats the main factor for defining a Skewed Binary tree so i dont see it ? \nwhat is your question \n"
                    },
                    {
                        "username": "pravesh_252505",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void recursion(TreeNode *root,TreeNode *&tail,TreeNode *&head){\\n        if(!root)return  ;\\n        cout<<root->val<<endl;\\n        if(!head){\\n            tail=new TreeNode (root->val);\\n            head=tail;\\n             recursion(root->left,tail,head);\\n             recursion(root->right,tail,head);\\n        }\\n        else{ \\n            tail->right=new TreeNode(root->val);\\n            tail->left=NULL;\\n            tail=tail->right;\\n            recursion(root->left,tail,head);\\n            recursion(root->right,tail,head);\\n        }\\n       \\n    }\\n    void flatten(TreeNode* &root) {\\n        TreeNode *tail=NULL,*head=NULL;\\n        recursion(root,tail,head);\\n        root=head;\\n    }\\n};\\nokay so this code is working fine ,wait I mean, after completion of recursion function I\\'m assigning head to root  and on printing root I\\'m getting correct answer but on submitting ,it shows that root is not changed why is it so ?"
                    },
                    {
                        "username": "ayushjha1",
                        "content": "what is the error in this code pls reply\\ngive runtime error\\n\\nclass Solution {\\npublic:\\n    TreeNode* p;\\n    void solve(TreeNode* t){\\n        if(!t)\\n            return;\\n        TreeNode* a=t->right;\\n        p->right=t;\\n        p=p->right;\\n        cout<<p->val<<endl;\\n        TreeNode* b=t->left;\\n        p->left=0;\\n        solve(b);\\n        solve(a);\\n    }\\n\\n    void flatten(TreeNode* root) {\\n        p=root;\\n        solve(root);\\n        root=root->right;\\n    }\\n};"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "The question implicitly frees all memory on every node\\'s left leaf, that is why I got \"use-after-free bug\" because I had left and right pointing to the same node when building the linked list.\\n\\n This caused me hours to debug.\\n"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "Why is this solution giving me wrong answer?\\nI checked in vs code. It gives correct output. Somebody please help pe with this, I\\'m loosing my mind!!!!\\n\\n\\n\\nTreeNode* help(TreeNode *root, TreeNode* &cur)\\n    {\\n        if(root == NULL) return root;\\n        cur = root;\\n        TreeNode *left = root->left, *right = root->right;\\n        root->left = NULL;\\n        cur->right = help(left, cur);\\n        cur->right = help(right, cur);\\n        return root;\\n    }\\n        \\n    void flatten(TreeNode* &root) {\\n        TreeNode *cur = NULL;\\n        root = help(root,cur);\\n    }"
                    },
                    {
                        "username": "AthenaCodes2605",
                        "content": "it is a super easy question, just tests basic linkedlist knowledge "
                    },
                    {
                        "username": "2uringTested",
                        "content": "ohh, it's easy if you do it with recursion, but that taken O(n) stack space. Do it without using that stack space, in O(1) space complexity"
                    }
                ]
            },
            {
                "id": 1982411,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can anyone tell me how to solve problem  ?  I wrote some code  \\nclass Solution { \\n    static ArrayList<Integer> arr = new ArrayList<>();\\n    public void flatten(TreeNode root) {\\n        \\n        if(root == null)\\n        {\\n            return;\\n        }  \\n        arr.add(root.val); \\n        arr.add(null);\\n        flatten(root.left); \\n        flatten(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "That\\'s not the right solution. why are you adding null to your array list. just check on youtube many good videos"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "Question should be convert binary tree to skewed binary tree"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "i might take a lot of time to find logic behind this in an actual interview if i haven\\'t done this earlier"
                    },
                    {
                        "username": "sn82990eha",
                        "content": "Morris Traversal method\n\nClass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        TreeNode * curr=root;\n        while(curr!=NULL){\n            if(curr->left!=NULL){\n                TreeNode *prev=curr->left;\n                while(prev->right){\n                    prev=prev->right;\n                }\n                prev->right=curr->right;\n                curr->right=curr->left;\n                curr->left=NULL;\n            }\n            curr=curr->right;\n        }\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Leetcode Rules Method.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "-_-\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "#### WHY THERE IS NULL IN THE OUTPUT ?\\nBecause essentially we are returning a ***Skewed Binary Tree***, and not a ***Linear Linked List***.\\n\\n- The \"linked list\" should use the same `TreeNode` class where the `right child pointer` points to the ***NEXT NODE*** in the list and the `left child pointer` is always ***NULL***."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "You said it yourself left child is always NULL and thats the main factor for defining a Skewed Binary tree so i dont see it ? \nwhat is your question \n"
                    },
                    {
                        "username": "pravesh_252505",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void recursion(TreeNode *root,TreeNode *&tail,TreeNode *&head){\\n        if(!root)return  ;\\n        cout<<root->val<<endl;\\n        if(!head){\\n            tail=new TreeNode (root->val);\\n            head=tail;\\n             recursion(root->left,tail,head);\\n             recursion(root->right,tail,head);\\n        }\\n        else{ \\n            tail->right=new TreeNode(root->val);\\n            tail->left=NULL;\\n            tail=tail->right;\\n            recursion(root->left,tail,head);\\n            recursion(root->right,tail,head);\\n        }\\n       \\n    }\\n    void flatten(TreeNode* &root) {\\n        TreeNode *tail=NULL,*head=NULL;\\n        recursion(root,tail,head);\\n        root=head;\\n    }\\n};\\nokay so this code is working fine ,wait I mean, after completion of recursion function I\\'m assigning head to root  and on printing root I\\'m getting correct answer but on submitting ,it shows that root is not changed why is it so ?"
                    },
                    {
                        "username": "ayushjha1",
                        "content": "what is the error in this code pls reply\\ngive runtime error\\n\\nclass Solution {\\npublic:\\n    TreeNode* p;\\n    void solve(TreeNode* t){\\n        if(!t)\\n            return;\\n        TreeNode* a=t->right;\\n        p->right=t;\\n        p=p->right;\\n        cout<<p->val<<endl;\\n        TreeNode* b=t->left;\\n        p->left=0;\\n        solve(b);\\n        solve(a);\\n    }\\n\\n    void flatten(TreeNode* root) {\\n        p=root;\\n        solve(root);\\n        root=root->right;\\n    }\\n};"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "The question implicitly frees all memory on every node\\'s left leaf, that is why I got \"use-after-free bug\" because I had left and right pointing to the same node when building the linked list.\\n\\n This caused me hours to debug.\\n"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "Why is this solution giving me wrong answer?\\nI checked in vs code. It gives correct output. Somebody please help pe with this, I\\'m loosing my mind!!!!\\n\\n\\n\\nTreeNode* help(TreeNode *root, TreeNode* &cur)\\n    {\\n        if(root == NULL) return root;\\n        cur = root;\\n        TreeNode *left = root->left, *right = root->right;\\n        root->left = NULL;\\n        cur->right = help(left, cur);\\n        cur->right = help(right, cur);\\n        return root;\\n    }\\n        \\n    void flatten(TreeNode* &root) {\\n        TreeNode *cur = NULL;\\n        root = help(root,cur);\\n    }"
                    },
                    {
                        "username": "AthenaCodes2605",
                        "content": "it is a super easy question, just tests basic linkedlist knowledge "
                    },
                    {
                        "username": "2uringTested",
                        "content": "ohh, it's easy if you do it with recursion, but that taken O(n) stack space. Do it without using that stack space, in O(1) space complexity"
                    }
                ]
            },
            {
                "id": 1966908,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can anyone tell me how to solve problem  ?  I wrote some code  \\nclass Solution { \\n    static ArrayList<Integer> arr = new ArrayList<>();\\n    public void flatten(TreeNode root) {\\n        \\n        if(root == null)\\n        {\\n            return;\\n        }  \\n        arr.add(root.val); \\n        arr.add(null);\\n        flatten(root.left); \\n        flatten(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "That\\'s not the right solution. why are you adding null to your array list. just check on youtube many good videos"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "Question should be convert binary tree to skewed binary tree"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "i might take a lot of time to find logic behind this in an actual interview if i haven\\'t done this earlier"
                    },
                    {
                        "username": "sn82990eha",
                        "content": "Morris Traversal method\n\nClass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        TreeNode * curr=root;\n        while(curr!=NULL){\n            if(curr->left!=NULL){\n                TreeNode *prev=curr->left;\n                while(prev->right){\n                    prev=prev->right;\n                }\n                prev->right=curr->right;\n                curr->right=curr->left;\n                curr->left=NULL;\n            }\n            curr=curr->right;\n        }\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Leetcode Rules Method.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "-_-\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "#### WHY THERE IS NULL IN THE OUTPUT ?\\nBecause essentially we are returning a ***Skewed Binary Tree***, and not a ***Linear Linked List***.\\n\\n- The \"linked list\" should use the same `TreeNode` class where the `right child pointer` points to the ***NEXT NODE*** in the list and the `left child pointer` is always ***NULL***."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "You said it yourself left child is always NULL and thats the main factor for defining a Skewed Binary tree so i dont see it ? \nwhat is your question \n"
                    },
                    {
                        "username": "pravesh_252505",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void recursion(TreeNode *root,TreeNode *&tail,TreeNode *&head){\\n        if(!root)return  ;\\n        cout<<root->val<<endl;\\n        if(!head){\\n            tail=new TreeNode (root->val);\\n            head=tail;\\n             recursion(root->left,tail,head);\\n             recursion(root->right,tail,head);\\n        }\\n        else{ \\n            tail->right=new TreeNode(root->val);\\n            tail->left=NULL;\\n            tail=tail->right;\\n            recursion(root->left,tail,head);\\n            recursion(root->right,tail,head);\\n        }\\n       \\n    }\\n    void flatten(TreeNode* &root) {\\n        TreeNode *tail=NULL,*head=NULL;\\n        recursion(root,tail,head);\\n        root=head;\\n    }\\n};\\nokay so this code is working fine ,wait I mean, after completion of recursion function I\\'m assigning head to root  and on printing root I\\'m getting correct answer but on submitting ,it shows that root is not changed why is it so ?"
                    },
                    {
                        "username": "ayushjha1",
                        "content": "what is the error in this code pls reply\\ngive runtime error\\n\\nclass Solution {\\npublic:\\n    TreeNode* p;\\n    void solve(TreeNode* t){\\n        if(!t)\\n            return;\\n        TreeNode* a=t->right;\\n        p->right=t;\\n        p=p->right;\\n        cout<<p->val<<endl;\\n        TreeNode* b=t->left;\\n        p->left=0;\\n        solve(b);\\n        solve(a);\\n    }\\n\\n    void flatten(TreeNode* root) {\\n        p=root;\\n        solve(root);\\n        root=root->right;\\n    }\\n};"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "The question implicitly frees all memory on every node\\'s left leaf, that is why I got \"use-after-free bug\" because I had left and right pointing to the same node when building the linked list.\\n\\n This caused me hours to debug.\\n"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "Why is this solution giving me wrong answer?\\nI checked in vs code. It gives correct output. Somebody please help pe with this, I\\'m loosing my mind!!!!\\n\\n\\n\\nTreeNode* help(TreeNode *root, TreeNode* &cur)\\n    {\\n        if(root == NULL) return root;\\n        cur = root;\\n        TreeNode *left = root->left, *right = root->right;\\n        root->left = NULL;\\n        cur->right = help(left, cur);\\n        cur->right = help(right, cur);\\n        return root;\\n    }\\n        \\n    void flatten(TreeNode* &root) {\\n        TreeNode *cur = NULL;\\n        root = help(root,cur);\\n    }"
                    },
                    {
                        "username": "AthenaCodes2605",
                        "content": "it is a super easy question, just tests basic linkedlist knowledge "
                    },
                    {
                        "username": "2uringTested",
                        "content": "ohh, it's easy if you do it with recursion, but that taken O(n) stack space. Do it without using that stack space, in O(1) space complexity"
                    }
                ]
            },
            {
                "id": 1957155,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can anyone tell me how to solve problem  ?  I wrote some code  \\nclass Solution { \\n    static ArrayList<Integer> arr = new ArrayList<>();\\n    public void flatten(TreeNode root) {\\n        \\n        if(root == null)\\n        {\\n            return;\\n        }  \\n        arr.add(root.val); \\n        arr.add(null);\\n        flatten(root.left); \\n        flatten(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "That\\'s not the right solution. why are you adding null to your array list. just check on youtube many good videos"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "Question should be convert binary tree to skewed binary tree"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "i might take a lot of time to find logic behind this in an actual interview if i haven\\'t done this earlier"
                    },
                    {
                        "username": "sn82990eha",
                        "content": "Morris Traversal method\n\nClass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        TreeNode * curr=root;\n        while(curr!=NULL){\n            if(curr->left!=NULL){\n                TreeNode *prev=curr->left;\n                while(prev->right){\n                    prev=prev->right;\n                }\n                prev->right=curr->right;\n                curr->right=curr->left;\n                curr->left=NULL;\n            }\n            curr=curr->right;\n        }\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Leetcode Rules Method.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "-_-\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "#### WHY THERE IS NULL IN THE OUTPUT ?\\nBecause essentially we are returning a ***Skewed Binary Tree***, and not a ***Linear Linked List***.\\n\\n- The \"linked list\" should use the same `TreeNode` class where the `right child pointer` points to the ***NEXT NODE*** in the list and the `left child pointer` is always ***NULL***."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "You said it yourself left child is always NULL and thats the main factor for defining a Skewed Binary tree so i dont see it ? \nwhat is your question \n"
                    },
                    {
                        "username": "pravesh_252505",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void recursion(TreeNode *root,TreeNode *&tail,TreeNode *&head){\\n        if(!root)return  ;\\n        cout<<root->val<<endl;\\n        if(!head){\\n            tail=new TreeNode (root->val);\\n            head=tail;\\n             recursion(root->left,tail,head);\\n             recursion(root->right,tail,head);\\n        }\\n        else{ \\n            tail->right=new TreeNode(root->val);\\n            tail->left=NULL;\\n            tail=tail->right;\\n            recursion(root->left,tail,head);\\n            recursion(root->right,tail,head);\\n        }\\n       \\n    }\\n    void flatten(TreeNode* &root) {\\n        TreeNode *tail=NULL,*head=NULL;\\n        recursion(root,tail,head);\\n        root=head;\\n    }\\n};\\nokay so this code is working fine ,wait I mean, after completion of recursion function I\\'m assigning head to root  and on printing root I\\'m getting correct answer but on submitting ,it shows that root is not changed why is it so ?"
                    },
                    {
                        "username": "ayushjha1",
                        "content": "what is the error in this code pls reply\\ngive runtime error\\n\\nclass Solution {\\npublic:\\n    TreeNode* p;\\n    void solve(TreeNode* t){\\n        if(!t)\\n            return;\\n        TreeNode* a=t->right;\\n        p->right=t;\\n        p=p->right;\\n        cout<<p->val<<endl;\\n        TreeNode* b=t->left;\\n        p->left=0;\\n        solve(b);\\n        solve(a);\\n    }\\n\\n    void flatten(TreeNode* root) {\\n        p=root;\\n        solve(root);\\n        root=root->right;\\n    }\\n};"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "The question implicitly frees all memory on every node\\'s left leaf, that is why I got \"use-after-free bug\" because I had left and right pointing to the same node when building the linked list.\\n\\n This caused me hours to debug.\\n"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "Why is this solution giving me wrong answer?\\nI checked in vs code. It gives correct output. Somebody please help pe with this, I\\'m loosing my mind!!!!\\n\\n\\n\\nTreeNode* help(TreeNode *root, TreeNode* &cur)\\n    {\\n        if(root == NULL) return root;\\n        cur = root;\\n        TreeNode *left = root->left, *right = root->right;\\n        root->left = NULL;\\n        cur->right = help(left, cur);\\n        cur->right = help(right, cur);\\n        return root;\\n    }\\n        \\n    void flatten(TreeNode* &root) {\\n        TreeNode *cur = NULL;\\n        root = help(root,cur);\\n    }"
                    },
                    {
                        "username": "AthenaCodes2605",
                        "content": "it is a super easy question, just tests basic linkedlist knowledge "
                    },
                    {
                        "username": "2uringTested",
                        "content": "ohh, it's easy if you do it with recursion, but that taken O(n) stack space. Do it without using that stack space, in O(1) space complexity"
                    }
                ]
            },
            {
                "id": 1950765,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can anyone tell me how to solve problem  ?  I wrote some code  \\nclass Solution { \\n    static ArrayList<Integer> arr = new ArrayList<>();\\n    public void flatten(TreeNode root) {\\n        \\n        if(root == null)\\n        {\\n            return;\\n        }  \\n        arr.add(root.val); \\n        arr.add(null);\\n        flatten(root.left); \\n        flatten(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "That\\'s not the right solution. why are you adding null to your array list. just check on youtube many good videos"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "Question should be convert binary tree to skewed binary tree"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "i might take a lot of time to find logic behind this in an actual interview if i haven\\'t done this earlier"
                    },
                    {
                        "username": "sn82990eha",
                        "content": "Morris Traversal method\n\nClass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        TreeNode * curr=root;\n        while(curr!=NULL){\n            if(curr->left!=NULL){\n                TreeNode *prev=curr->left;\n                while(prev->right){\n                    prev=prev->right;\n                }\n                prev->right=curr->right;\n                curr->right=curr->left;\n                curr->left=NULL;\n            }\n            curr=curr->right;\n        }\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Leetcode Rules Method.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "-_-\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "#### WHY THERE IS NULL IN THE OUTPUT ?\\nBecause essentially we are returning a ***Skewed Binary Tree***, and not a ***Linear Linked List***.\\n\\n- The \"linked list\" should use the same `TreeNode` class where the `right child pointer` points to the ***NEXT NODE*** in the list and the `left child pointer` is always ***NULL***."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "You said it yourself left child is always NULL and thats the main factor for defining a Skewed Binary tree so i dont see it ? \nwhat is your question \n"
                    },
                    {
                        "username": "pravesh_252505",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void recursion(TreeNode *root,TreeNode *&tail,TreeNode *&head){\\n        if(!root)return  ;\\n        cout<<root->val<<endl;\\n        if(!head){\\n            tail=new TreeNode (root->val);\\n            head=tail;\\n             recursion(root->left,tail,head);\\n             recursion(root->right,tail,head);\\n        }\\n        else{ \\n            tail->right=new TreeNode(root->val);\\n            tail->left=NULL;\\n            tail=tail->right;\\n            recursion(root->left,tail,head);\\n            recursion(root->right,tail,head);\\n        }\\n       \\n    }\\n    void flatten(TreeNode* &root) {\\n        TreeNode *tail=NULL,*head=NULL;\\n        recursion(root,tail,head);\\n        root=head;\\n    }\\n};\\nokay so this code is working fine ,wait I mean, after completion of recursion function I\\'m assigning head to root  and on printing root I\\'m getting correct answer but on submitting ,it shows that root is not changed why is it so ?"
                    },
                    {
                        "username": "ayushjha1",
                        "content": "what is the error in this code pls reply\\ngive runtime error\\n\\nclass Solution {\\npublic:\\n    TreeNode* p;\\n    void solve(TreeNode* t){\\n        if(!t)\\n            return;\\n        TreeNode* a=t->right;\\n        p->right=t;\\n        p=p->right;\\n        cout<<p->val<<endl;\\n        TreeNode* b=t->left;\\n        p->left=0;\\n        solve(b);\\n        solve(a);\\n    }\\n\\n    void flatten(TreeNode* root) {\\n        p=root;\\n        solve(root);\\n        root=root->right;\\n    }\\n};"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "The question implicitly frees all memory on every node\\'s left leaf, that is why I got \"use-after-free bug\" because I had left and right pointing to the same node when building the linked list.\\n\\n This caused me hours to debug.\\n"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "Why is this solution giving me wrong answer?\\nI checked in vs code. It gives correct output. Somebody please help pe with this, I\\'m loosing my mind!!!!\\n\\n\\n\\nTreeNode* help(TreeNode *root, TreeNode* &cur)\\n    {\\n        if(root == NULL) return root;\\n        cur = root;\\n        TreeNode *left = root->left, *right = root->right;\\n        root->left = NULL;\\n        cur->right = help(left, cur);\\n        cur->right = help(right, cur);\\n        return root;\\n    }\\n        \\n    void flatten(TreeNode* &root) {\\n        TreeNode *cur = NULL;\\n        root = help(root,cur);\\n    }"
                    },
                    {
                        "username": "AthenaCodes2605",
                        "content": "it is a super easy question, just tests basic linkedlist knowledge "
                    },
                    {
                        "username": "2uringTested",
                        "content": "ohh, it's easy if you do it with recursion, but that taken O(n) stack space. Do it without using that stack space, in O(1) space complexity"
                    }
                ]
            },
            {
                "id": 1949217,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can anyone tell me how to solve problem  ?  I wrote some code  \\nclass Solution { \\n    static ArrayList<Integer> arr = new ArrayList<>();\\n    public void flatten(TreeNode root) {\\n        \\n        if(root == null)\\n        {\\n            return;\\n        }  \\n        arr.add(root.val); \\n        arr.add(null);\\n        flatten(root.left); \\n        flatten(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "That\\'s not the right solution. why are you adding null to your array list. just check on youtube many good videos"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "Question should be convert binary tree to skewed binary tree"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "i might take a lot of time to find logic behind this in an actual interview if i haven\\'t done this earlier"
                    },
                    {
                        "username": "sn82990eha",
                        "content": "Morris Traversal method\n\nClass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        TreeNode * curr=root;\n        while(curr!=NULL){\n            if(curr->left!=NULL){\n                TreeNode *prev=curr->left;\n                while(prev->right){\n                    prev=prev->right;\n                }\n                prev->right=curr->right;\n                curr->right=curr->left;\n                curr->left=NULL;\n            }\n            curr=curr->right;\n        }\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Leetcode Rules Method.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "-_-\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "#### WHY THERE IS NULL IN THE OUTPUT ?\\nBecause essentially we are returning a ***Skewed Binary Tree***, and not a ***Linear Linked List***.\\n\\n- The \"linked list\" should use the same `TreeNode` class where the `right child pointer` points to the ***NEXT NODE*** in the list and the `left child pointer` is always ***NULL***."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "You said it yourself left child is always NULL and thats the main factor for defining a Skewed Binary tree so i dont see it ? \nwhat is your question \n"
                    },
                    {
                        "username": "pravesh_252505",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void recursion(TreeNode *root,TreeNode *&tail,TreeNode *&head){\\n        if(!root)return  ;\\n        cout<<root->val<<endl;\\n        if(!head){\\n            tail=new TreeNode (root->val);\\n            head=tail;\\n             recursion(root->left,tail,head);\\n             recursion(root->right,tail,head);\\n        }\\n        else{ \\n            tail->right=new TreeNode(root->val);\\n            tail->left=NULL;\\n            tail=tail->right;\\n            recursion(root->left,tail,head);\\n            recursion(root->right,tail,head);\\n        }\\n       \\n    }\\n    void flatten(TreeNode* &root) {\\n        TreeNode *tail=NULL,*head=NULL;\\n        recursion(root,tail,head);\\n        root=head;\\n    }\\n};\\nokay so this code is working fine ,wait I mean, after completion of recursion function I\\'m assigning head to root  and on printing root I\\'m getting correct answer but on submitting ,it shows that root is not changed why is it so ?"
                    },
                    {
                        "username": "ayushjha1",
                        "content": "what is the error in this code pls reply\\ngive runtime error\\n\\nclass Solution {\\npublic:\\n    TreeNode* p;\\n    void solve(TreeNode* t){\\n        if(!t)\\n            return;\\n        TreeNode* a=t->right;\\n        p->right=t;\\n        p=p->right;\\n        cout<<p->val<<endl;\\n        TreeNode* b=t->left;\\n        p->left=0;\\n        solve(b);\\n        solve(a);\\n    }\\n\\n    void flatten(TreeNode* root) {\\n        p=root;\\n        solve(root);\\n        root=root->right;\\n    }\\n};"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "The question implicitly frees all memory on every node\\'s left leaf, that is why I got \"use-after-free bug\" because I had left and right pointing to the same node when building the linked list.\\n\\n This caused me hours to debug.\\n"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "Why is this solution giving me wrong answer?\\nI checked in vs code. It gives correct output. Somebody please help pe with this, I\\'m loosing my mind!!!!\\n\\n\\n\\nTreeNode* help(TreeNode *root, TreeNode* &cur)\\n    {\\n        if(root == NULL) return root;\\n        cur = root;\\n        TreeNode *left = root->left, *right = root->right;\\n        root->left = NULL;\\n        cur->right = help(left, cur);\\n        cur->right = help(right, cur);\\n        return root;\\n    }\\n        \\n    void flatten(TreeNode* &root) {\\n        TreeNode *cur = NULL;\\n        root = help(root,cur);\\n    }"
                    },
                    {
                        "username": "AthenaCodes2605",
                        "content": "it is a super easy question, just tests basic linkedlist knowledge "
                    },
                    {
                        "username": "2uringTested",
                        "content": "ohh, it's easy if you do it with recursion, but that taken O(n) stack space. Do it without using that stack space, in O(1) space complexity"
                    }
                ]
            },
            {
                "id": 1946730,
                "content": [
                    {
                        "username": "shrish-nitb",
                        "content": "Is is possible without using stack?"
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) \\uD83D\\uDE4F\\uD83D\\uDE04 nice catch buddy compelling to change my mind"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@shrish-nitb](/shrish-nitb) Great work but the thing is, recursive approach itself takes an internal stack to implement. "
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) thanks for help\\nI\\'ve figured out a recursive approach\\nclass Solution {\\npublic:\\n    TreeNode* head; \\n    TreeNode* prev = NULL;\\n    void flatten(TreeNode* root) {\\n        if(root == NULL) return;\\n        TreeNode* left = root->left;\\n        TreeNode* right = root->right;\\n        root->left = NULL;\\n        if(prev != NULL) {\\n            prev->right = root;\\n        }\\n        prev = root;\\n        flatten(left);\\n        flatten(right);\\n    }\\n};"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes it is.\\n\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Anup292001",
                        "content": "please someone tell me what is issue in this solution\\n\\nclass Solution {\\npublic:\\n    void fun(TreeNode* root,TreeNode* list){\\n        if(root==NULL){\\n            return ;\\n        }\\n        list->right = new TreeNode(root->val);\\n        list->left = NULL;\\n        fun(root->left,list->right);\\n        fun(root->right,list->right);\\n    }\\n    void flatten(TreeNode* root) {\\n        TreeNode* list=new TreeNode();\\n        fun(root,list);\\n        root = list->right;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "dondublon",
                        "content": "I failed with the case:\\n[1,null,2,3]\\n\\nHow could it be? The node at index 3, value 3 - seems decsend from the \\'null\\' node? Null node, index==1, 2*1+1=3.  "
                    },
                    {
                        "username": "gauravbharti",
                        "content": "So all what question asks is - Traverse and solve using Morris Traversal. It solves in O(n) time and O(1) space and its the only way to solve it in-place. Recursion and stack iterative vise is neither O(1) space nor inplace. "
                    },
                    {
                        "username": "masterbaiter",
                        "content": "Can someone helps me to debug\\n```\\nvoid flatten(TreeNode* root) {\\n        if (root == NULL) {\\n            return;\\n        }\\n\\n        flatten(root->left);\\n        flatten(root->right);\\n\\n        if (root->left == NULL) \\n            return;\\n        \\n\\n        TreeNode* p = root->left;\\n\\n        while (p != NULL && p->right != NULL) {\\n            p = p->right;\\n        }\\n\\n        p->right = root->right;\\n        root->right = root->left;\\n    \\n    }\\n```\\nI got ==22==ERROR: AddressSanitizer: heap-use-after-free on address error, running the default test cases"
                    },
                    {
                        "username": "aman3091",
                        "content": "kindly guide where i am wrong in this code or what changes i need to make to resolve error\\n\\nvoid flatten(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            TreeNode* temp=st.top();\\n            st.pop();\\n           if(temp->right!=NULL){\\n               st.push(temp->right);\\n           }\\n            if(temp->left!=NULL){\\n               st.push(temp->left);\\n           }\\n             q.push(temp);\\n        }\\nwhile(!q.empty()){\\n    TreeNode* temp=q.front();\\n q.pop();\\n temp->left=NULL;\\n if(!q.empty()){\\n temp->right=q.front();\\n }\\n}\\n    \\n    }"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my straightforward approach:-\\n\\n1. Perform a preorder traversal of the binary tree, storing the node values in the preorder list.\\n2. Set the root node as node.\\n3. For each value in preorder starting from index 1 (the second value), create a new TreeNode object with the value and set it as the right child of node. Also, set the left child of node to null.\\n4. Update node to point to the newly created right child.\\n5. Return the modified tree."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "can someone help me find out as to what is wrong in my code. It seems fine to me but not giving results. @ @ `class Solution {\\n    TreeNode preptr = new TreeNode(0);\\n    TreeNode thead = preptr;\\n    public void flatten(TreeNode root) {\\n        if(root==null)\\n        return ;\\n        else{\\n            thead.right=new TreeNode(root.val);\\n            thead=thead.right;\\n            flatten(root.left);\\n            flatten(root.right);\\n        }root=preptr.right;\\n    }\\n}`"
                    },
                    {
                        "username": "pattharock",
                        "content": "I have simply stored the ROOT -> LEFT -> RIGHT traversal in an array and then once we have the desired nodes in an array - we can rewire the connections in one more pass of the array to achieve desired result. What is wrong with this method compared to the conventional method. Both are using O(N) space time"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1944429,
                "content": [
                    {
                        "username": "shrish-nitb",
                        "content": "Is is possible without using stack?"
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) \\uD83D\\uDE4F\\uD83D\\uDE04 nice catch buddy compelling to change my mind"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@shrish-nitb](/shrish-nitb) Great work but the thing is, recursive approach itself takes an internal stack to implement. "
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) thanks for help\\nI\\'ve figured out a recursive approach\\nclass Solution {\\npublic:\\n    TreeNode* head; \\n    TreeNode* prev = NULL;\\n    void flatten(TreeNode* root) {\\n        if(root == NULL) return;\\n        TreeNode* left = root->left;\\n        TreeNode* right = root->right;\\n        root->left = NULL;\\n        if(prev != NULL) {\\n            prev->right = root;\\n        }\\n        prev = root;\\n        flatten(left);\\n        flatten(right);\\n    }\\n};"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes it is.\\n\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Anup292001",
                        "content": "please someone tell me what is issue in this solution\\n\\nclass Solution {\\npublic:\\n    void fun(TreeNode* root,TreeNode* list){\\n        if(root==NULL){\\n            return ;\\n        }\\n        list->right = new TreeNode(root->val);\\n        list->left = NULL;\\n        fun(root->left,list->right);\\n        fun(root->right,list->right);\\n    }\\n    void flatten(TreeNode* root) {\\n        TreeNode* list=new TreeNode();\\n        fun(root,list);\\n        root = list->right;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "dondublon",
                        "content": "I failed with the case:\\n[1,null,2,3]\\n\\nHow could it be? The node at index 3, value 3 - seems decsend from the \\'null\\' node? Null node, index==1, 2*1+1=3.  "
                    },
                    {
                        "username": "gauravbharti",
                        "content": "So all what question asks is - Traverse and solve using Morris Traversal. It solves in O(n) time and O(1) space and its the only way to solve it in-place. Recursion and stack iterative vise is neither O(1) space nor inplace. "
                    },
                    {
                        "username": "masterbaiter",
                        "content": "Can someone helps me to debug\\n```\\nvoid flatten(TreeNode* root) {\\n        if (root == NULL) {\\n            return;\\n        }\\n\\n        flatten(root->left);\\n        flatten(root->right);\\n\\n        if (root->left == NULL) \\n            return;\\n        \\n\\n        TreeNode* p = root->left;\\n\\n        while (p != NULL && p->right != NULL) {\\n            p = p->right;\\n        }\\n\\n        p->right = root->right;\\n        root->right = root->left;\\n    \\n    }\\n```\\nI got ==22==ERROR: AddressSanitizer: heap-use-after-free on address error, running the default test cases"
                    },
                    {
                        "username": "aman3091",
                        "content": "kindly guide where i am wrong in this code or what changes i need to make to resolve error\\n\\nvoid flatten(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            TreeNode* temp=st.top();\\n            st.pop();\\n           if(temp->right!=NULL){\\n               st.push(temp->right);\\n           }\\n            if(temp->left!=NULL){\\n               st.push(temp->left);\\n           }\\n             q.push(temp);\\n        }\\nwhile(!q.empty()){\\n    TreeNode* temp=q.front();\\n q.pop();\\n temp->left=NULL;\\n if(!q.empty()){\\n temp->right=q.front();\\n }\\n}\\n    \\n    }"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my straightforward approach:-\\n\\n1. Perform a preorder traversal of the binary tree, storing the node values in the preorder list.\\n2. Set the root node as node.\\n3. For each value in preorder starting from index 1 (the second value), create a new TreeNode object with the value and set it as the right child of node. Also, set the left child of node to null.\\n4. Update node to point to the newly created right child.\\n5. Return the modified tree."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "can someone help me find out as to what is wrong in my code. It seems fine to me but not giving results. @ @ `class Solution {\\n    TreeNode preptr = new TreeNode(0);\\n    TreeNode thead = preptr;\\n    public void flatten(TreeNode root) {\\n        if(root==null)\\n        return ;\\n        else{\\n            thead.right=new TreeNode(root.val);\\n            thead=thead.right;\\n            flatten(root.left);\\n            flatten(root.right);\\n        }root=preptr.right;\\n    }\\n}`"
                    },
                    {
                        "username": "pattharock",
                        "content": "I have simply stored the ROOT -> LEFT -> RIGHT traversal in an array and then once we have the desired nodes in an array - we can rewire the connections in one more pass of the array to achieve desired result. What is wrong with this method compared to the conventional method. Both are using O(N) space time"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1934432,
                "content": [
                    {
                        "username": "shrish-nitb",
                        "content": "Is is possible without using stack?"
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) \\uD83D\\uDE4F\\uD83D\\uDE04 nice catch buddy compelling to change my mind"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@shrish-nitb](/shrish-nitb) Great work but the thing is, recursive approach itself takes an internal stack to implement. "
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) thanks for help\\nI\\'ve figured out a recursive approach\\nclass Solution {\\npublic:\\n    TreeNode* head; \\n    TreeNode* prev = NULL;\\n    void flatten(TreeNode* root) {\\n        if(root == NULL) return;\\n        TreeNode* left = root->left;\\n        TreeNode* right = root->right;\\n        root->left = NULL;\\n        if(prev != NULL) {\\n            prev->right = root;\\n        }\\n        prev = root;\\n        flatten(left);\\n        flatten(right);\\n    }\\n};"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes it is.\\n\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Anup292001",
                        "content": "please someone tell me what is issue in this solution\\n\\nclass Solution {\\npublic:\\n    void fun(TreeNode* root,TreeNode* list){\\n        if(root==NULL){\\n            return ;\\n        }\\n        list->right = new TreeNode(root->val);\\n        list->left = NULL;\\n        fun(root->left,list->right);\\n        fun(root->right,list->right);\\n    }\\n    void flatten(TreeNode* root) {\\n        TreeNode* list=new TreeNode();\\n        fun(root,list);\\n        root = list->right;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "dondublon",
                        "content": "I failed with the case:\\n[1,null,2,3]\\n\\nHow could it be? The node at index 3, value 3 - seems decsend from the \\'null\\' node? Null node, index==1, 2*1+1=3.  "
                    },
                    {
                        "username": "gauravbharti",
                        "content": "So all what question asks is - Traverse and solve using Morris Traversal. It solves in O(n) time and O(1) space and its the only way to solve it in-place. Recursion and stack iterative vise is neither O(1) space nor inplace. "
                    },
                    {
                        "username": "masterbaiter",
                        "content": "Can someone helps me to debug\\n```\\nvoid flatten(TreeNode* root) {\\n        if (root == NULL) {\\n            return;\\n        }\\n\\n        flatten(root->left);\\n        flatten(root->right);\\n\\n        if (root->left == NULL) \\n            return;\\n        \\n\\n        TreeNode* p = root->left;\\n\\n        while (p != NULL && p->right != NULL) {\\n            p = p->right;\\n        }\\n\\n        p->right = root->right;\\n        root->right = root->left;\\n    \\n    }\\n```\\nI got ==22==ERROR: AddressSanitizer: heap-use-after-free on address error, running the default test cases"
                    },
                    {
                        "username": "aman3091",
                        "content": "kindly guide where i am wrong in this code or what changes i need to make to resolve error\\n\\nvoid flatten(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            TreeNode* temp=st.top();\\n            st.pop();\\n           if(temp->right!=NULL){\\n               st.push(temp->right);\\n           }\\n            if(temp->left!=NULL){\\n               st.push(temp->left);\\n           }\\n             q.push(temp);\\n        }\\nwhile(!q.empty()){\\n    TreeNode* temp=q.front();\\n q.pop();\\n temp->left=NULL;\\n if(!q.empty()){\\n temp->right=q.front();\\n }\\n}\\n    \\n    }"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my straightforward approach:-\\n\\n1. Perform a preorder traversal of the binary tree, storing the node values in the preorder list.\\n2. Set the root node as node.\\n3. For each value in preorder starting from index 1 (the second value), create a new TreeNode object with the value and set it as the right child of node. Also, set the left child of node to null.\\n4. Update node to point to the newly created right child.\\n5. Return the modified tree."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "can someone help me find out as to what is wrong in my code. It seems fine to me but not giving results. @ @ `class Solution {\\n    TreeNode preptr = new TreeNode(0);\\n    TreeNode thead = preptr;\\n    public void flatten(TreeNode root) {\\n        if(root==null)\\n        return ;\\n        else{\\n            thead.right=new TreeNode(root.val);\\n            thead=thead.right;\\n            flatten(root.left);\\n            flatten(root.right);\\n        }root=preptr.right;\\n    }\\n}`"
                    },
                    {
                        "username": "pattharock",
                        "content": "I have simply stored the ROOT -> LEFT -> RIGHT traversal in an array and then once we have the desired nodes in an array - we can rewire the connections in one more pass of the array to achieve desired result. What is wrong with this method compared to the conventional method. Both are using O(N) space time"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1919035,
                "content": [
                    {
                        "username": "shrish-nitb",
                        "content": "Is is possible without using stack?"
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) \\uD83D\\uDE4F\\uD83D\\uDE04 nice catch buddy compelling to change my mind"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@shrish-nitb](/shrish-nitb) Great work but the thing is, recursive approach itself takes an internal stack to implement. "
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) thanks for help\\nI\\'ve figured out a recursive approach\\nclass Solution {\\npublic:\\n    TreeNode* head; \\n    TreeNode* prev = NULL;\\n    void flatten(TreeNode* root) {\\n        if(root == NULL) return;\\n        TreeNode* left = root->left;\\n        TreeNode* right = root->right;\\n        root->left = NULL;\\n        if(prev != NULL) {\\n            prev->right = root;\\n        }\\n        prev = root;\\n        flatten(left);\\n        flatten(right);\\n    }\\n};"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes it is.\\n\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Anup292001",
                        "content": "please someone tell me what is issue in this solution\\n\\nclass Solution {\\npublic:\\n    void fun(TreeNode* root,TreeNode* list){\\n        if(root==NULL){\\n            return ;\\n        }\\n        list->right = new TreeNode(root->val);\\n        list->left = NULL;\\n        fun(root->left,list->right);\\n        fun(root->right,list->right);\\n    }\\n    void flatten(TreeNode* root) {\\n        TreeNode* list=new TreeNode();\\n        fun(root,list);\\n        root = list->right;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "dondublon",
                        "content": "I failed with the case:\\n[1,null,2,3]\\n\\nHow could it be? The node at index 3, value 3 - seems decsend from the \\'null\\' node? Null node, index==1, 2*1+1=3.  "
                    },
                    {
                        "username": "gauravbharti",
                        "content": "So all what question asks is - Traverse and solve using Morris Traversal. It solves in O(n) time and O(1) space and its the only way to solve it in-place. Recursion and stack iterative vise is neither O(1) space nor inplace. "
                    },
                    {
                        "username": "masterbaiter",
                        "content": "Can someone helps me to debug\\n```\\nvoid flatten(TreeNode* root) {\\n        if (root == NULL) {\\n            return;\\n        }\\n\\n        flatten(root->left);\\n        flatten(root->right);\\n\\n        if (root->left == NULL) \\n            return;\\n        \\n\\n        TreeNode* p = root->left;\\n\\n        while (p != NULL && p->right != NULL) {\\n            p = p->right;\\n        }\\n\\n        p->right = root->right;\\n        root->right = root->left;\\n    \\n    }\\n```\\nI got ==22==ERROR: AddressSanitizer: heap-use-after-free on address error, running the default test cases"
                    },
                    {
                        "username": "aman3091",
                        "content": "kindly guide where i am wrong in this code or what changes i need to make to resolve error\\n\\nvoid flatten(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            TreeNode* temp=st.top();\\n            st.pop();\\n           if(temp->right!=NULL){\\n               st.push(temp->right);\\n           }\\n            if(temp->left!=NULL){\\n               st.push(temp->left);\\n           }\\n             q.push(temp);\\n        }\\nwhile(!q.empty()){\\n    TreeNode* temp=q.front();\\n q.pop();\\n temp->left=NULL;\\n if(!q.empty()){\\n temp->right=q.front();\\n }\\n}\\n    \\n    }"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my straightforward approach:-\\n\\n1. Perform a preorder traversal of the binary tree, storing the node values in the preorder list.\\n2. Set the root node as node.\\n3. For each value in preorder starting from index 1 (the second value), create a new TreeNode object with the value and set it as the right child of node. Also, set the left child of node to null.\\n4. Update node to point to the newly created right child.\\n5. Return the modified tree."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "can someone help me find out as to what is wrong in my code. It seems fine to me but not giving results. @ @ `class Solution {\\n    TreeNode preptr = new TreeNode(0);\\n    TreeNode thead = preptr;\\n    public void flatten(TreeNode root) {\\n        if(root==null)\\n        return ;\\n        else{\\n            thead.right=new TreeNode(root.val);\\n            thead=thead.right;\\n            flatten(root.left);\\n            flatten(root.right);\\n        }root=preptr.right;\\n    }\\n}`"
                    },
                    {
                        "username": "pattharock",
                        "content": "I have simply stored the ROOT -> LEFT -> RIGHT traversal in an array and then once we have the desired nodes in an array - we can rewire the connections in one more pass of the array to achieve desired result. What is wrong with this method compared to the conventional method. Both are using O(N) space time"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1917937,
                "content": [
                    {
                        "username": "shrish-nitb",
                        "content": "Is is possible without using stack?"
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) \\uD83D\\uDE4F\\uD83D\\uDE04 nice catch buddy compelling to change my mind"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@shrish-nitb](/shrish-nitb) Great work but the thing is, recursive approach itself takes an internal stack to implement. "
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) thanks for help\\nI\\'ve figured out a recursive approach\\nclass Solution {\\npublic:\\n    TreeNode* head; \\n    TreeNode* prev = NULL;\\n    void flatten(TreeNode* root) {\\n        if(root == NULL) return;\\n        TreeNode* left = root->left;\\n        TreeNode* right = root->right;\\n        root->left = NULL;\\n        if(prev != NULL) {\\n            prev->right = root;\\n        }\\n        prev = root;\\n        flatten(left);\\n        flatten(right);\\n    }\\n};"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes it is.\\n\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Anup292001",
                        "content": "please someone tell me what is issue in this solution\\n\\nclass Solution {\\npublic:\\n    void fun(TreeNode* root,TreeNode* list){\\n        if(root==NULL){\\n            return ;\\n        }\\n        list->right = new TreeNode(root->val);\\n        list->left = NULL;\\n        fun(root->left,list->right);\\n        fun(root->right,list->right);\\n    }\\n    void flatten(TreeNode* root) {\\n        TreeNode* list=new TreeNode();\\n        fun(root,list);\\n        root = list->right;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "dondublon",
                        "content": "I failed with the case:\\n[1,null,2,3]\\n\\nHow could it be? The node at index 3, value 3 - seems decsend from the \\'null\\' node? Null node, index==1, 2*1+1=3.  "
                    },
                    {
                        "username": "gauravbharti",
                        "content": "So all what question asks is - Traverse and solve using Morris Traversal. It solves in O(n) time and O(1) space and its the only way to solve it in-place. Recursion and stack iterative vise is neither O(1) space nor inplace. "
                    },
                    {
                        "username": "masterbaiter",
                        "content": "Can someone helps me to debug\\n```\\nvoid flatten(TreeNode* root) {\\n        if (root == NULL) {\\n            return;\\n        }\\n\\n        flatten(root->left);\\n        flatten(root->right);\\n\\n        if (root->left == NULL) \\n            return;\\n        \\n\\n        TreeNode* p = root->left;\\n\\n        while (p != NULL && p->right != NULL) {\\n            p = p->right;\\n        }\\n\\n        p->right = root->right;\\n        root->right = root->left;\\n    \\n    }\\n```\\nI got ==22==ERROR: AddressSanitizer: heap-use-after-free on address error, running the default test cases"
                    },
                    {
                        "username": "aman3091",
                        "content": "kindly guide where i am wrong in this code or what changes i need to make to resolve error\\n\\nvoid flatten(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            TreeNode* temp=st.top();\\n            st.pop();\\n           if(temp->right!=NULL){\\n               st.push(temp->right);\\n           }\\n            if(temp->left!=NULL){\\n               st.push(temp->left);\\n           }\\n             q.push(temp);\\n        }\\nwhile(!q.empty()){\\n    TreeNode* temp=q.front();\\n q.pop();\\n temp->left=NULL;\\n if(!q.empty()){\\n temp->right=q.front();\\n }\\n}\\n    \\n    }"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my straightforward approach:-\\n\\n1. Perform a preorder traversal of the binary tree, storing the node values in the preorder list.\\n2. Set the root node as node.\\n3. For each value in preorder starting from index 1 (the second value), create a new TreeNode object with the value and set it as the right child of node. Also, set the left child of node to null.\\n4. Update node to point to the newly created right child.\\n5. Return the modified tree."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "can someone help me find out as to what is wrong in my code. It seems fine to me but not giving results. @ @ `class Solution {\\n    TreeNode preptr = new TreeNode(0);\\n    TreeNode thead = preptr;\\n    public void flatten(TreeNode root) {\\n        if(root==null)\\n        return ;\\n        else{\\n            thead.right=new TreeNode(root.val);\\n            thead=thead.right;\\n            flatten(root.left);\\n            flatten(root.right);\\n        }root=preptr.right;\\n    }\\n}`"
                    },
                    {
                        "username": "pattharock",
                        "content": "I have simply stored the ROOT -> LEFT -> RIGHT traversal in an array and then once we have the desired nodes in an array - we can rewire the connections in one more pass of the array to achieve desired result. What is wrong with this method compared to the conventional method. Both are using O(N) space time"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1841391,
                "content": [
                    {
                        "username": "shrish-nitb",
                        "content": "Is is possible without using stack?"
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) \\uD83D\\uDE4F\\uD83D\\uDE04 nice catch buddy compelling to change my mind"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@shrish-nitb](/shrish-nitb) Great work but the thing is, recursive approach itself takes an internal stack to implement. "
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) thanks for help\\nI\\'ve figured out a recursive approach\\nclass Solution {\\npublic:\\n    TreeNode* head; \\n    TreeNode* prev = NULL;\\n    void flatten(TreeNode* root) {\\n        if(root == NULL) return;\\n        TreeNode* left = root->left;\\n        TreeNode* right = root->right;\\n        root->left = NULL;\\n        if(prev != NULL) {\\n            prev->right = root;\\n        }\\n        prev = root;\\n        flatten(left);\\n        flatten(right);\\n    }\\n};"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes it is.\\n\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Anup292001",
                        "content": "please someone tell me what is issue in this solution\\n\\nclass Solution {\\npublic:\\n    void fun(TreeNode* root,TreeNode* list){\\n        if(root==NULL){\\n            return ;\\n        }\\n        list->right = new TreeNode(root->val);\\n        list->left = NULL;\\n        fun(root->left,list->right);\\n        fun(root->right,list->right);\\n    }\\n    void flatten(TreeNode* root) {\\n        TreeNode* list=new TreeNode();\\n        fun(root,list);\\n        root = list->right;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "dondublon",
                        "content": "I failed with the case:\\n[1,null,2,3]\\n\\nHow could it be? The node at index 3, value 3 - seems decsend from the \\'null\\' node? Null node, index==1, 2*1+1=3.  "
                    },
                    {
                        "username": "gauravbharti",
                        "content": "So all what question asks is - Traverse and solve using Morris Traversal. It solves in O(n) time and O(1) space and its the only way to solve it in-place. Recursion and stack iterative vise is neither O(1) space nor inplace. "
                    },
                    {
                        "username": "masterbaiter",
                        "content": "Can someone helps me to debug\\n```\\nvoid flatten(TreeNode* root) {\\n        if (root == NULL) {\\n            return;\\n        }\\n\\n        flatten(root->left);\\n        flatten(root->right);\\n\\n        if (root->left == NULL) \\n            return;\\n        \\n\\n        TreeNode* p = root->left;\\n\\n        while (p != NULL && p->right != NULL) {\\n            p = p->right;\\n        }\\n\\n        p->right = root->right;\\n        root->right = root->left;\\n    \\n    }\\n```\\nI got ==22==ERROR: AddressSanitizer: heap-use-after-free on address error, running the default test cases"
                    },
                    {
                        "username": "aman3091",
                        "content": "kindly guide where i am wrong in this code or what changes i need to make to resolve error\\n\\nvoid flatten(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            TreeNode* temp=st.top();\\n            st.pop();\\n           if(temp->right!=NULL){\\n               st.push(temp->right);\\n           }\\n            if(temp->left!=NULL){\\n               st.push(temp->left);\\n           }\\n             q.push(temp);\\n        }\\nwhile(!q.empty()){\\n    TreeNode* temp=q.front();\\n q.pop();\\n temp->left=NULL;\\n if(!q.empty()){\\n temp->right=q.front();\\n }\\n}\\n    \\n    }"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my straightforward approach:-\\n\\n1. Perform a preorder traversal of the binary tree, storing the node values in the preorder list.\\n2. Set the root node as node.\\n3. For each value in preorder starting from index 1 (the second value), create a new TreeNode object with the value and set it as the right child of node. Also, set the left child of node to null.\\n4. Update node to point to the newly created right child.\\n5. Return the modified tree."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "can someone help me find out as to what is wrong in my code. It seems fine to me but not giving results. @ @ `class Solution {\\n    TreeNode preptr = new TreeNode(0);\\n    TreeNode thead = preptr;\\n    public void flatten(TreeNode root) {\\n        if(root==null)\\n        return ;\\n        else{\\n            thead.right=new TreeNode(root.val);\\n            thead=thead.right;\\n            flatten(root.left);\\n            flatten(root.right);\\n        }root=preptr.right;\\n    }\\n}`"
                    },
                    {
                        "username": "pattharock",
                        "content": "I have simply stored the ROOT -> LEFT -> RIGHT traversal in an array and then once we have the desired nodes in an array - we can rewire the connections in one more pass of the array to achieve desired result. What is wrong with this method compared to the conventional method. Both are using O(N) space time"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1835651,
                "content": [
                    {
                        "username": "shrish-nitb",
                        "content": "Is is possible without using stack?"
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) \\uD83D\\uDE4F\\uD83D\\uDE04 nice catch buddy compelling to change my mind"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@shrish-nitb](/shrish-nitb) Great work but the thing is, recursive approach itself takes an internal stack to implement. "
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) thanks for help\\nI\\'ve figured out a recursive approach\\nclass Solution {\\npublic:\\n    TreeNode* head; \\n    TreeNode* prev = NULL;\\n    void flatten(TreeNode* root) {\\n        if(root == NULL) return;\\n        TreeNode* left = root->left;\\n        TreeNode* right = root->right;\\n        root->left = NULL;\\n        if(prev != NULL) {\\n            prev->right = root;\\n        }\\n        prev = root;\\n        flatten(left);\\n        flatten(right);\\n    }\\n};"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes it is.\\n\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Anup292001",
                        "content": "please someone tell me what is issue in this solution\\n\\nclass Solution {\\npublic:\\n    void fun(TreeNode* root,TreeNode* list){\\n        if(root==NULL){\\n            return ;\\n        }\\n        list->right = new TreeNode(root->val);\\n        list->left = NULL;\\n        fun(root->left,list->right);\\n        fun(root->right,list->right);\\n    }\\n    void flatten(TreeNode* root) {\\n        TreeNode* list=new TreeNode();\\n        fun(root,list);\\n        root = list->right;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "dondublon",
                        "content": "I failed with the case:\\n[1,null,2,3]\\n\\nHow could it be? The node at index 3, value 3 - seems decsend from the \\'null\\' node? Null node, index==1, 2*1+1=3.  "
                    },
                    {
                        "username": "gauravbharti",
                        "content": "So all what question asks is - Traverse and solve using Morris Traversal. It solves in O(n) time and O(1) space and its the only way to solve it in-place. Recursion and stack iterative vise is neither O(1) space nor inplace. "
                    },
                    {
                        "username": "masterbaiter",
                        "content": "Can someone helps me to debug\\n```\\nvoid flatten(TreeNode* root) {\\n        if (root == NULL) {\\n            return;\\n        }\\n\\n        flatten(root->left);\\n        flatten(root->right);\\n\\n        if (root->left == NULL) \\n            return;\\n        \\n\\n        TreeNode* p = root->left;\\n\\n        while (p != NULL && p->right != NULL) {\\n            p = p->right;\\n        }\\n\\n        p->right = root->right;\\n        root->right = root->left;\\n    \\n    }\\n```\\nI got ==22==ERROR: AddressSanitizer: heap-use-after-free on address error, running the default test cases"
                    },
                    {
                        "username": "aman3091",
                        "content": "kindly guide where i am wrong in this code or what changes i need to make to resolve error\\n\\nvoid flatten(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            TreeNode* temp=st.top();\\n            st.pop();\\n           if(temp->right!=NULL){\\n               st.push(temp->right);\\n           }\\n            if(temp->left!=NULL){\\n               st.push(temp->left);\\n           }\\n             q.push(temp);\\n        }\\nwhile(!q.empty()){\\n    TreeNode* temp=q.front();\\n q.pop();\\n temp->left=NULL;\\n if(!q.empty()){\\n temp->right=q.front();\\n }\\n}\\n    \\n    }"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my straightforward approach:-\\n\\n1. Perform a preorder traversal of the binary tree, storing the node values in the preorder list.\\n2. Set the root node as node.\\n3. For each value in preorder starting from index 1 (the second value), create a new TreeNode object with the value and set it as the right child of node. Also, set the left child of node to null.\\n4. Update node to point to the newly created right child.\\n5. Return the modified tree."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "can someone help me find out as to what is wrong in my code. It seems fine to me but not giving results. @ @ `class Solution {\\n    TreeNode preptr = new TreeNode(0);\\n    TreeNode thead = preptr;\\n    public void flatten(TreeNode root) {\\n        if(root==null)\\n        return ;\\n        else{\\n            thead.right=new TreeNode(root.val);\\n            thead=thead.right;\\n            flatten(root.left);\\n            flatten(root.right);\\n        }root=preptr.right;\\n    }\\n}`"
                    },
                    {
                        "username": "pattharock",
                        "content": "I have simply stored the ROOT -> LEFT -> RIGHT traversal in an array and then once we have the desired nodes in an array - we can rewire the connections in one more pass of the array to achieve desired result. What is wrong with this method compared to the conventional method. Both are using O(N) space time"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1828005,
                "content": [
                    {
                        "username": "shrish-nitb",
                        "content": "Is is possible without using stack?"
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) \\uD83D\\uDE4F\\uD83D\\uDE04 nice catch buddy compelling to change my mind"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@shrish-nitb](/shrish-nitb) Great work but the thing is, recursive approach itself takes an internal stack to implement. "
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) thanks for help\\nI\\'ve figured out a recursive approach\\nclass Solution {\\npublic:\\n    TreeNode* head; \\n    TreeNode* prev = NULL;\\n    void flatten(TreeNode* root) {\\n        if(root == NULL) return;\\n        TreeNode* left = root->left;\\n        TreeNode* right = root->right;\\n        root->left = NULL;\\n        if(prev != NULL) {\\n            prev->right = root;\\n        }\\n        prev = root;\\n        flatten(left);\\n        flatten(right);\\n    }\\n};"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes it is.\\n\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Anup292001",
                        "content": "please someone tell me what is issue in this solution\\n\\nclass Solution {\\npublic:\\n    void fun(TreeNode* root,TreeNode* list){\\n        if(root==NULL){\\n            return ;\\n        }\\n        list->right = new TreeNode(root->val);\\n        list->left = NULL;\\n        fun(root->left,list->right);\\n        fun(root->right,list->right);\\n    }\\n    void flatten(TreeNode* root) {\\n        TreeNode* list=new TreeNode();\\n        fun(root,list);\\n        root = list->right;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "dondublon",
                        "content": "I failed with the case:\\n[1,null,2,3]\\n\\nHow could it be? The node at index 3, value 3 - seems decsend from the \\'null\\' node? Null node, index==1, 2*1+1=3.  "
                    },
                    {
                        "username": "gauravbharti",
                        "content": "So all what question asks is - Traverse and solve using Morris Traversal. It solves in O(n) time and O(1) space and its the only way to solve it in-place. Recursion and stack iterative vise is neither O(1) space nor inplace. "
                    },
                    {
                        "username": "masterbaiter",
                        "content": "Can someone helps me to debug\\n```\\nvoid flatten(TreeNode* root) {\\n        if (root == NULL) {\\n            return;\\n        }\\n\\n        flatten(root->left);\\n        flatten(root->right);\\n\\n        if (root->left == NULL) \\n            return;\\n        \\n\\n        TreeNode* p = root->left;\\n\\n        while (p != NULL && p->right != NULL) {\\n            p = p->right;\\n        }\\n\\n        p->right = root->right;\\n        root->right = root->left;\\n    \\n    }\\n```\\nI got ==22==ERROR: AddressSanitizer: heap-use-after-free on address error, running the default test cases"
                    },
                    {
                        "username": "aman3091",
                        "content": "kindly guide where i am wrong in this code or what changes i need to make to resolve error\\n\\nvoid flatten(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            TreeNode* temp=st.top();\\n            st.pop();\\n           if(temp->right!=NULL){\\n               st.push(temp->right);\\n           }\\n            if(temp->left!=NULL){\\n               st.push(temp->left);\\n           }\\n             q.push(temp);\\n        }\\nwhile(!q.empty()){\\n    TreeNode* temp=q.front();\\n q.pop();\\n temp->left=NULL;\\n if(!q.empty()){\\n temp->right=q.front();\\n }\\n}\\n    \\n    }"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my straightforward approach:-\\n\\n1. Perform a preorder traversal of the binary tree, storing the node values in the preorder list.\\n2. Set the root node as node.\\n3. For each value in preorder starting from index 1 (the second value), create a new TreeNode object with the value and set it as the right child of node. Also, set the left child of node to null.\\n4. Update node to point to the newly created right child.\\n5. Return the modified tree."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "can someone help me find out as to what is wrong in my code. It seems fine to me but not giving results. @ @ `class Solution {\\n    TreeNode preptr = new TreeNode(0);\\n    TreeNode thead = preptr;\\n    public void flatten(TreeNode root) {\\n        if(root==null)\\n        return ;\\n        else{\\n            thead.right=new TreeNode(root.val);\\n            thead=thead.right;\\n            flatten(root.left);\\n            flatten(root.right);\\n        }root=preptr.right;\\n    }\\n}`"
                    },
                    {
                        "username": "pattharock",
                        "content": "I have simply stored the ROOT -> LEFT -> RIGHT traversal in an array and then once we have the desired nodes in an array - we can rewire the connections in one more pass of the array to achieve desired result. What is wrong with this method compared to the conventional method. Both are using O(N) space time"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1803532,
                "content": [
                    {
                        "username": "shrish-nitb",
                        "content": "Is is possible without using stack?"
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) \\uD83D\\uDE4F\\uD83D\\uDE04 nice catch buddy compelling to change my mind"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@shrish-nitb](/shrish-nitb) Great work but the thing is, recursive approach itself takes an internal stack to implement. "
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) thanks for help\\nI\\'ve figured out a recursive approach\\nclass Solution {\\npublic:\\n    TreeNode* head; \\n    TreeNode* prev = NULL;\\n    void flatten(TreeNode* root) {\\n        if(root == NULL) return;\\n        TreeNode* left = root->left;\\n        TreeNode* right = root->right;\\n        root->left = NULL;\\n        if(prev != NULL) {\\n            prev->right = root;\\n        }\\n        prev = root;\\n        flatten(left);\\n        flatten(right);\\n    }\\n};"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes it is.\\n\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Anup292001",
                        "content": "please someone tell me what is issue in this solution\\n\\nclass Solution {\\npublic:\\n    void fun(TreeNode* root,TreeNode* list){\\n        if(root==NULL){\\n            return ;\\n        }\\n        list->right = new TreeNode(root->val);\\n        list->left = NULL;\\n        fun(root->left,list->right);\\n        fun(root->right,list->right);\\n    }\\n    void flatten(TreeNode* root) {\\n        TreeNode* list=new TreeNode();\\n        fun(root,list);\\n        root = list->right;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "dondublon",
                        "content": "I failed with the case:\\n[1,null,2,3]\\n\\nHow could it be? The node at index 3, value 3 - seems decsend from the \\'null\\' node? Null node, index==1, 2*1+1=3.  "
                    },
                    {
                        "username": "gauravbharti",
                        "content": "So all what question asks is - Traverse and solve using Morris Traversal. It solves in O(n) time and O(1) space and its the only way to solve it in-place. Recursion and stack iterative vise is neither O(1) space nor inplace. "
                    },
                    {
                        "username": "masterbaiter",
                        "content": "Can someone helps me to debug\\n```\\nvoid flatten(TreeNode* root) {\\n        if (root == NULL) {\\n            return;\\n        }\\n\\n        flatten(root->left);\\n        flatten(root->right);\\n\\n        if (root->left == NULL) \\n            return;\\n        \\n\\n        TreeNode* p = root->left;\\n\\n        while (p != NULL && p->right != NULL) {\\n            p = p->right;\\n        }\\n\\n        p->right = root->right;\\n        root->right = root->left;\\n    \\n    }\\n```\\nI got ==22==ERROR: AddressSanitizer: heap-use-after-free on address error, running the default test cases"
                    },
                    {
                        "username": "aman3091",
                        "content": "kindly guide where i am wrong in this code or what changes i need to make to resolve error\\n\\nvoid flatten(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            TreeNode* temp=st.top();\\n            st.pop();\\n           if(temp->right!=NULL){\\n               st.push(temp->right);\\n           }\\n            if(temp->left!=NULL){\\n               st.push(temp->left);\\n           }\\n             q.push(temp);\\n        }\\nwhile(!q.empty()){\\n    TreeNode* temp=q.front();\\n q.pop();\\n temp->left=NULL;\\n if(!q.empty()){\\n temp->right=q.front();\\n }\\n}\\n    \\n    }"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my straightforward approach:-\\n\\n1. Perform a preorder traversal of the binary tree, storing the node values in the preorder list.\\n2. Set the root node as node.\\n3. For each value in preorder starting from index 1 (the second value), create a new TreeNode object with the value and set it as the right child of node. Also, set the left child of node to null.\\n4. Update node to point to the newly created right child.\\n5. Return the modified tree."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "can someone help me find out as to what is wrong in my code. It seems fine to me but not giving results. @ @ `class Solution {\\n    TreeNode preptr = new TreeNode(0);\\n    TreeNode thead = preptr;\\n    public void flatten(TreeNode root) {\\n        if(root==null)\\n        return ;\\n        else{\\n            thead.right=new TreeNode(root.val);\\n            thead=thead.right;\\n            flatten(root.left);\\n            flatten(root.right);\\n        }root=preptr.right;\\n    }\\n}`"
                    },
                    {
                        "username": "pattharock",
                        "content": "I have simply stored the ROOT -> LEFT -> RIGHT traversal in an array and then once we have the desired nodes in an array - we can rewire the connections in one more pass of the array to achieve desired result. What is wrong with this method compared to the conventional method. Both are using O(N) space time"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1761006,
                "content": [
                    {
                        "username": "shrish-nitb",
                        "content": "Is is possible without using stack?"
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) \\uD83D\\uDE4F\\uD83D\\uDE04 nice catch buddy compelling to change my mind"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@shrish-nitb](/shrish-nitb) Great work but the thing is, recursive approach itself takes an internal stack to implement. "
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) thanks for help\\nI\\'ve figured out a recursive approach\\nclass Solution {\\npublic:\\n    TreeNode* head; \\n    TreeNode* prev = NULL;\\n    void flatten(TreeNode* root) {\\n        if(root == NULL) return;\\n        TreeNode* left = root->left;\\n        TreeNode* right = root->right;\\n        root->left = NULL;\\n        if(prev != NULL) {\\n            prev->right = root;\\n        }\\n        prev = root;\\n        flatten(left);\\n        flatten(right);\\n    }\\n};"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes it is.\\n\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Anup292001",
                        "content": "please someone tell me what is issue in this solution\\n\\nclass Solution {\\npublic:\\n    void fun(TreeNode* root,TreeNode* list){\\n        if(root==NULL){\\n            return ;\\n        }\\n        list->right = new TreeNode(root->val);\\n        list->left = NULL;\\n        fun(root->left,list->right);\\n        fun(root->right,list->right);\\n    }\\n    void flatten(TreeNode* root) {\\n        TreeNode* list=new TreeNode();\\n        fun(root,list);\\n        root = list->right;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "dondublon",
                        "content": "I failed with the case:\\n[1,null,2,3]\\n\\nHow could it be? The node at index 3, value 3 - seems decsend from the \\'null\\' node? Null node, index==1, 2*1+1=3.  "
                    },
                    {
                        "username": "gauravbharti",
                        "content": "So all what question asks is - Traverse and solve using Morris Traversal. It solves in O(n) time and O(1) space and its the only way to solve it in-place. Recursion and stack iterative vise is neither O(1) space nor inplace. "
                    },
                    {
                        "username": "masterbaiter",
                        "content": "Can someone helps me to debug\\n```\\nvoid flatten(TreeNode* root) {\\n        if (root == NULL) {\\n            return;\\n        }\\n\\n        flatten(root->left);\\n        flatten(root->right);\\n\\n        if (root->left == NULL) \\n            return;\\n        \\n\\n        TreeNode* p = root->left;\\n\\n        while (p != NULL && p->right != NULL) {\\n            p = p->right;\\n        }\\n\\n        p->right = root->right;\\n        root->right = root->left;\\n    \\n    }\\n```\\nI got ==22==ERROR: AddressSanitizer: heap-use-after-free on address error, running the default test cases"
                    },
                    {
                        "username": "aman3091",
                        "content": "kindly guide where i am wrong in this code or what changes i need to make to resolve error\\n\\nvoid flatten(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            TreeNode* temp=st.top();\\n            st.pop();\\n           if(temp->right!=NULL){\\n               st.push(temp->right);\\n           }\\n            if(temp->left!=NULL){\\n               st.push(temp->left);\\n           }\\n             q.push(temp);\\n        }\\nwhile(!q.empty()){\\n    TreeNode* temp=q.front();\\n q.pop();\\n temp->left=NULL;\\n if(!q.empty()){\\n temp->right=q.front();\\n }\\n}\\n    \\n    }"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my straightforward approach:-\\n\\n1. Perform a preorder traversal of the binary tree, storing the node values in the preorder list.\\n2. Set the root node as node.\\n3. For each value in preorder starting from index 1 (the second value), create a new TreeNode object with the value and set it as the right child of node. Also, set the left child of node to null.\\n4. Update node to point to the newly created right child.\\n5. Return the modified tree."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "can someone help me find out as to what is wrong in my code. It seems fine to me but not giving results. @ @ `class Solution {\\n    TreeNode preptr = new TreeNode(0);\\n    TreeNode thead = preptr;\\n    public void flatten(TreeNode root) {\\n        if(root==null)\\n        return ;\\n        else{\\n            thead.right=new TreeNode(root.val);\\n            thead=thead.right;\\n            flatten(root.left);\\n            flatten(root.right);\\n        }root=preptr.right;\\n    }\\n}`"
                    },
                    {
                        "username": "pattharock",
                        "content": "I have simply stored the ROOT -> LEFT -> RIGHT traversal in an array and then once we have the desired nodes in an array - we can rewire the connections in one more pass of the array to achieve desired result. What is wrong with this method compared to the conventional method. Both are using O(N) space time"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            }
        ]
    },
    {
        "title": "Shortest Palindrome",
        "question_content": "<p>You are given a string <code>s</code>. You can convert <code>s</code> to a <span data-keyword=\"palindrome-string\">palindrome</span> by adding characters in front of it.</p>\n\n<p>Return <em>the shortest palindrome you can find by performing this transformation</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"aacecaaa\"\n<strong>Output:</strong> \"aaacecaaa\"\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"abcd\"\n<strong>Output:</strong> \"dcbabcd\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists of lowercase English letters only.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 60113,
                "title": "clean-kmp-solution-with-super-detailed-explanation",
                "content": "Firstly, let me share my understanding of KMP algorithm.\\nThe key of KMP is to build a look up table that records the match result of prefix and postfix.\\nValue in the table means the max len of matching substring that exists in both prefix and postfix.\\nIn the prefix this substring should starts from 0, while in the postfix this substring should ends at current index.\\n\\nFor example, now we have a string \"ababc\"\\nThe KMP table will look like this:\\n\\n> a b a b c\\n> \\n> 0 0 1 2 0\\n\\n(Note: we will not match substring with itself, so we will skip index 0)\\n\\nSo how does this table help us search string match faster? \\n\\nWell, the answer is if we are trying to match a char after postfix with target string and failed, then we can smartly shift the string, so that the matching string in prefix will replace postfix and now we can try to match the char after prefix with this char in target. \\n\\nTake above string as an example.\\n\\nNow we try to match string \"ababc\" with \"abababc\".\\n\\nWe will initially have match as below\\n\\n> a b a b a b c                  (string x)\\n> \\n> a b a b c                        (string y)\\n> \\n> 0 1 2 3 4 5 6\\n\\nWe found char at index 4 does not match, then we can use lookup table and shift the string y wisely.\\nWe found table[3] = 2, which means we can shift the string y rightward by 2, and still have same but shorter prefix before index 4, like this:\\n\\n> a b a b a b c (string x)\\n\\n> ___a b a b c (string y)\\n> \\n> 0 1 2 3 4 5 6\\n\\nIf there is a long gap between prefix and postfix, this shift can help us save a lot of time.\\nIn the brute force way, we cannot do that because we have no information of the string. We have to compare each possible pair of chars. While in kmp, we know the information of string y so we can move smartly. We can directly jump to the next possible matching pair while discard useless pair of chars.\\n\\nWe are almost done with KMP, but we still have one special case that needs to be taken care of.\\n\\nSay now we have a input like this:\\n\\n> a a b a a a  (input String)\\n\\n> 0 1 2 3 4 5  (index)\\n\\n> 0 1 0 1 2 ? (KMP table)\\n\\nHow should we build the KMP table for this string?\\n\\nSay the pointer in prefix is \"x\", which is at index 2 now and the pointer in postfix is \"y\" which is at index 5 now. we need to match \"b\" pointed by x with \"a\" pointed by y. It is an unmatched pair, how should we update the cell?\\n\\nWell, we really don't need to reset it to 0, that will make us skip a valid shorter matching substring \"aa\". \\nWhat we do now is just to shorten the length of substring by 1 unit and try to match a shorter substring \"aa\". This can be done by moving pointer x to the index recorded in [indexOf(x)-1] while keep pointer y stay still. This is because by following the value in KMP table we can always make sure previous part of prefix and postfix is matched even we have shorten their length, so we only need to care about the char after matched part in prefix and postfix.\\n\\n\\nUse above example:\\n\\nFirstly we try to compare prefix \"aab\" with postfix \"aaa\", pointer in prefix now points to \"b\" while pointer in postfix now points to \"a\". So this means current len of postfix/prefix will not give a match, we need to shorten it.\\n\\n\\nSo in the second step, we will fix pointer in postfix, and move pointer in prefix so that we can compare shorter prefix and postfix. The movement of pointer in prefix (say at index x) is done by using KMP table. We will set pointer in prefix to be table [indexOf(x)-1].  In this case, we will move prefix pointer to index 1. So now we try to compare prefix \"aa\" with postfix \"aa\".\\n\\nFinally, we found the matching prefix and postfix, we just update the cell accordingly.\\n\\n\\nAbove is my understanding of KMP algorithm, so how could we apply KMP to this problem\\n\\n\\n\\n========================== I am just a splitter =================================\\n\\n\\n\\nThis problem asks us to add string before the input so the result string will be a palindrome.\\nWe can convert it to an alternative problem\"find the longest palindrome substring starts from index 0\".\\nIf we can get the length of such substring, then we can easily build a palindrome string by inserting the reverse part of substring after such substring before the original string. \\n\\nExample:\\n\\ninput string:\\n\\n>  abacd\\n\\nlongest palindrome substring starts from 0:\\n\\n> aba\\n\\nInsert the reverse part of substring after palindrome substring before the head:\\n\\n> dcabacd\\n\\nNow the problem becomes how to find the longest palindrome substring starts from 0.\\nWe can solve it by using a trick + KMP.\\n\\nThe trick is to build a temp string like this:\\n\\n> s + \"#\" + reverse(s)\\n\\nThen we run KMP on it, the value in last cell will be our solution. In this problem, we don't need to use KMP\\nto match strings but instead we use the lookup table in KMP to find the palindrome.\\n\\nWe add \"#\" here to force the match in reverse(s) starts from its first index\\nWhat we do in KMP here is trying to find a match between prefix in s  and a postfix in reverse(s). The match part will be palindrome substring.\\n\\nExample:\\ninput:\\n\\n> catacb\\n\\nTemp String:\\n\\n> catacb # bcatac\\n\\nKMP table:\\n\\n> c  a  t  a  c  b  #  b  c  a  t  a  c\\n> \\n> 0  0 0  0  1  0  0 0  1  2  3  4  5\\n\\nIn the last cell, we got a value  5. It means in s we have a substring of length 5 that is palindrome.\\n\\nSo, above is my understanding of KMP any solution towards this problem. Below is my code\\n\\n\\n    public String shortestPalindrome(String s) {\\n        String temp = s + \"#\" + new StringBuilder(s).reverse().toString();\\n        int[] table = getTable(temp);\\n        \\n        //get the maximum palin part in s starts from 0\\n        return new StringBuilder(s.substring(table[table.length - 1])).reverse().toString() + s;\\n    }\\n    \\n    public int[] getTable(String s){\\n        //get lookup table\\n        int[] table = new int[s.length()];\\n        \\n        //pointer that points to matched char in prefix part\\n        \\n        int index = 0;\\n        //skip index 0, we will not match a string with itself\\n        for(int i = 1; i < s.length(); i++){\\n            if(s.charAt(index) == s.charAt(i)){\\n                //we can extend match in prefix and postfix\\n                table[i] = table[i-1] + 1;\\n                index ++;\\n            }else{\\n                //match failed, we try to match a shorter substring\\n                \\n                //by assigning index to table[i-1], we will shorten the match string length, and jump to the \\n                //prefix part that we used to match postfix ended at i - 1\\n                index = table[i-1];\\n                \\n                while(index > 0 && s.charAt(index) != s.charAt(i)){\\n                    //we will try to shorten the match string length until we revert to the beginning of match (index 1)\\n                    index = table[index-1];\\n                }\\n                \\n                //when we are here may either found a match char or we reach the boundary and still no luck\\n                //so we need check char match\\n                if(s.charAt(index) == s.charAt(i)){\\n                    //if match, then extend one char \\n                    index ++ ;\\n                }\\n                \\n                table[i] = index;\\n            }\\n            \\n        }\\n        \\n        return table;\\n    }\\n\\nIf I messed up or misunderstood something, please leave comment below. Thanks ~",
                "solutionTags": [],
                "code": "Firstly, let me share my understanding of KMP algorithm.\\nThe key of KMP is to build a look up table that records the match result of prefix and postfix.\\nValue in the table means the max len of matching substring that exists in both prefix and postfix.\\nIn the prefix this substring should starts from 0, while in the postfix this substring should ends at current index.\\n\\nFor example, now we have a string \"ababc\"\\nThe KMP table will look like this:\\n\\n> a b a b c\\n> \\n> 0 0 1 2 0\\n\\n(Note: we will not match substring with itself, so we will skip index 0)\\n\\nSo how does this table help us search string match faster? \\n\\nWell, the answer is if we are trying to match a char after postfix with target string and failed, then we can smartly shift the string, so that the matching string in prefix will replace postfix and now we can try to match the char after prefix with this char in target. \\n\\nTake above string as an example.\\n\\nNow we try to match string \"ababc\" with \"abababc\".\\n\\nWe will initially have match as below\\n\\n> a b a b a b c                  (string x)\\n> \\n> a b a b c                        (string y)\\n> \\n> 0 1 2 3 4 5 6\\n\\nWe found char at index 4 does not match, then we can use lookup table and shift the string y wisely.\\nWe found table[3] = 2, which means we can shift the string y rightward by 2, and still have same but shorter prefix before index 4, like this:\\n\\n> a b a b a b c (string x)\\n\\n> ___a b a b c (string y)\\n> \\n> 0 1 2 3 4 5 6\\n\\nIf there is a long gap between prefix and postfix, this shift can help us save a lot of time.\\nIn the brute force way, we cannot do that because we have no information of the string. We have to compare each possible pair of chars. While in kmp, we know the information of string y so we can move smartly. We can directly jump to the next possible matching pair while discard useless pair of chars.\\n\\nWe are almost done with KMP, but we still have one special case that needs to be taken care of.\\n\\nSay now we have a input like this:\\n\\n> a a b a a a  (input String)\\n\\n> 0 1 2 3 4 5  (index)\\n\\n> 0 1 0 1 2 ? (KMP table)\\n\\nHow should we build the KMP table for this string?\\n\\nSay the pointer in prefix is \"x\", which is at index 2 now and the pointer in postfix is \"y\" which is at index 5 now. we need to match \"b\" pointed by x with \"a\" pointed by y. It is an unmatched pair, how should we update the cell?\\n\\nWell, we really don't need to reset it to 0, that will make us skip a valid shorter matching substring \"aa\". \\nWhat we do now is just to shorten the length of substring by 1 unit and try to match a shorter substring \"aa\". This can be done by moving pointer x to the index recorded in [indexOf(x)-1] while keep pointer y stay still. This is because by following the value in KMP table we can always make sure previous part of prefix and postfix is matched even we have shorten their length, so we only need to care about the char after matched part in prefix and postfix.\\n\\n\\nUse above example:\\n\\nFirstly we try to compare prefix \"aab\" with postfix \"aaa\", pointer in prefix now points to \"b\" while pointer in postfix now points to \"a\". So this means current len of postfix/prefix will not give a match, we need to shorten it.\\n\\n\\nSo in the second step, we will fix pointer in postfix, and move pointer in prefix so that we can compare shorter prefix and postfix. The movement of pointer in prefix (say at index x) is done by using KMP table. We will set pointer in prefix to be table [indexOf(x)-1].  In this case, we will move prefix pointer to index 1. So now we try to compare prefix \"aa\" with postfix \"aa\".\\n\\nFinally, we found the matching prefix and postfix, we just update the cell accordingly.\\n\\n\\nAbove is my understanding of KMP algorithm, so how could we apply KMP to this problem\\n\\n\\n\\n========================== I am just a splitter =================================\\n\\n\\n\\nThis problem asks us to add string before the input so the result string will be a palindrome.\\nWe can convert it to an alternative problem\"find the longest palindrome substring starts from index 0\".\\nIf we can get the length of such substring, then we can easily build a palindrome string by inserting the reverse part of substring after such substring before the original string. \\n\\nExample:\\n\\ninput string:\\n\\n>  abacd\\n\\nlongest palindrome substring starts from 0:\\n\\n> aba\\n\\nInsert the reverse part of substring after palindrome substring before the head:\\n\\n> dcabacd\\n\\nNow the problem becomes how to find the longest palindrome substring starts from 0.\\nWe can solve it by using a trick + KMP.\\n\\nThe trick is to build a temp string like this:\\n\\n> s + \"#\" + reverse(s)\\n\\nThen we run KMP on it, the value in last cell will be our solution. In this problem, we don't need to use KMP\\nto match strings but instead we use the lookup table in KMP to find the palindrome.\\n\\nWe add \"#\" here to force the match in reverse(s) starts from its first index\\nWhat we do in KMP here is trying to find a match between prefix in s  and a postfix in reverse(s). The match part will be palindrome substring.\\n\\nExample:\\ninput:\\n\\n> catacb\\n\\nTemp String:\\n\\n> catacb # bcatac\\n\\nKMP table:\\n\\n> c  a  t  a  c  b  #  b  c  a  t  a  c\\n> \\n> 0  0 0  0  1  0  0 0  1  2  3  4  5\\n\\nIn the last cell, we got a value  5. It means in s we have a substring of length 5 that is palindrome.\\n\\nSo, above is my understanding of KMP any solution towards this problem. Below is my code\\n\\n\\n    public String shortestPalindrome(String s) {\\n        String temp = s + \"#\" + new StringBuilder(s).reverse().toString();\\n        int[] table = getTable(temp);\\n        \\n        //get the maximum palin part in s starts from 0\\n        return new StringBuilder(s.substring(table[table.length - 1])).reverse().toString() + s;\\n    }\\n    \\n    public int[] getTable(String s){\\n        //get lookup table\\n        int[] table = new int[s.length()];\\n        \\n        //pointer that points to matched char in prefix part\\n        \\n        int index = 0;\\n        //skip index 0, we will not match a string with itself\\n        for(int i = 1; i < s.length(); i++){\\n            if(s.charAt(index) == s.charAt(i)){\\n                //we can extend match in prefix and postfix\\n                table[i] = table[i-1] + 1;\\n                index ++;\\n            }else{\\n                //match failed, we try to match a shorter substring\\n                \\n                //by assigning index to table[i-1], we will shorten the match string length, and jump to the \\n                //prefix part that we used to match postfix ended at i - 1\\n                index = table[i-1];\\n                \\n                while(index > 0 && s.charAt(index) != s.charAt(i)){\\n                    //we will try to shorten the match string length until we revert to the beginning of match (index 1)\\n                    index = table[index-1];\\n                }\\n                \\n                //when we are here may either found a match char or we reach the boundary and still no luck\\n                //so we need check char match\\n                if(s.charAt(index) == s.charAt(i)){\\n                    //if match, then extend one char \\n                    index ++ ;\\n                }\\n                \\n                table[i] = index;\\n            }\\n            \\n        }\\n        \\n        return table;\\n    }\\n\\nIf I messed up or misunderstood something, please leave comment below. Thanks ~",
                "codeTag": "Unknown"
            },
            {
                "id": 60099,
                "title": "ac-in-288-ms-simple-brute-force",
                "content": "    def shortestPalindrome(self, s):\\n        r = s[::-1]\\n        for i in range(len(s) + 1):\\n            if s.startswith(r[i:]):\\n                return r[:i] + s\\n\\nExample: s = `dedcba`. Then r = `abcded` and I try these overlays (the part in `(...)` is the prefix I cut off, I just include it in the display for better understanding):\\n\\n      s          dedcba\\n      r[0:]      abcded    Nope...\\n      r[1:]   (a)bcded     Nope...\\n      r[2:]  (ab)cded      Nope...\\n      r[3:] (abc)ded       Yes! Return abc + dedcba",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def shortestPalindrome(self, s):\\n        r = s[::-1]\\n        for i in range(len(s) + 1):\\n            if s.startswith(r[i:]):\\n                return r[:i] + s\\n\\nExample: s = `dedcba`. Then r = `abcded` and I try these overlays (the part in `(...)` is the prefix I cut off, I just include it in the display for better understanding):\\n\\n      s          dedcba\\n      r[0:]      abcded    Nope...\\n      r[1:]   (a)bcded     Nope...\\n      r[2:]  (ab)cded      Nope...\\n      r[3:] (abc)ded       Yes! Return abc + dedcba",
                "codeTag": "Python3"
            },
            {
                "id": 60098,
                "title": "my-7-lines-recursive-java-solution",
                "content": "The idea is to use two anchors `j` and `i` to compare the String from beginning and end.\\nIf `j` can reach the end, the String itself is Palindrome. Otherwise, we divide the String by `j`, and get `mid = s.substring(0, j)` and `suffix`.\\n\\nWe reverse `suffix` as beginning of result and recursively call `shortestPalindrome` to get result of `mid` then appedn `suffix` to get result.\\n\\n        int j = 0;\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            if (s.charAt(i) == s.charAt(j)) { j += 1; }\\n        }\\n        if (j == s.length()) { return s; }\\n        String suffix = s.substring(j);\\n        return new StringBuffer(suffix).reverse().toString() + shortestPalindrome(s.substring(0, j)) + suffix;",
                "solutionTags": [
                    "Java"
                ],
                "code": "The idea is to use two anchors `j` and `i` to compare the String from beginning and end.\\nIf `j` can reach the end, the String itself is Palindrome. Otherwise, we divide the String by `j`, and get `mid = s.substring(0, j)` and `suffix`.\\n\\nWe reverse `suffix` as beginning of result and recursively call `shortestPalindrome` to get result of `mid` then appedn `suffix` to get result.\\n\\n        int j = 0;\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            if (s.charAt(i) == s.charAt(j)) { j += 1; }\\n        }\\n        if (j == s.length()) { return s; }\\n        String suffix = s.substring(j);\\n        return new StringBuffer(suffix).reverse().toString() + shortestPalindrome(s.substring(0, j)) + suffix;",
                "codeTag": "Unknown"
            },
            {
                "id": 60141,
                "title": "c-8-ms-kmp-based-o-n-time-o-n-memory-solution",
                "content": "We can construct the following string and run KMP algorithm on it:\\n(s) + (some symbol not present in s) + (reversed string)\\n\\nAfter running KMP on that string as result we get a vector **p** with values of a prefix function for each character (for definition of a prefix function see KMP algorithm description). We are only interested in the last value because it shows us the largest suffix of the reversed string that matches the prefix of the original string. So basically all we left to do is to add the first k characters of the reversed string to the original string, where k is a difference between original string size and the prefix function for the last character of a constructed string. \\n\\n    class Solution {\\n    public:\\n        string shortestPalindrome(string s) {\\n            string rev_s = s;\\n            reverse(rev_s.begin(), rev_s.end());\\n            string l = s + \"#\" + rev_s;\\n            \\n            vector<int> p(l.size(), 0);\\n            for (int i = 1; i < l.size(); i++) {\\n                int j = p[i - 1];\\n                while (j > 0 && l[i] != l[j])\\n                    j = p[j - 1];\\n                p[i] = (j += l[i] == l[j]);\\n            }\\n            \\n            return rev_s.substr(0, s.size() - p[l.size() - 1]) + s;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string shortestPalindrome(string s) {\\n            string rev_s = s;\\n            reverse(rev_s.begin(), rev_s.end());\\n            string l = s + \"#\" + rev_s;\\n            \\n            vector<int> p(l.size(), 0);\\n            for (int i = 1; i < l.size(); i++) {\\n                int j = p[i - 1];\\n                while (j > 0 && l[i] != l[j])\\n                    j = p[j - 1];\\n                p[i] = (j += l[i] == l[j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 60106,
                "title": "my-9-lines-three-pointers-java-solution-with-explanation",
                "content": "## Explanation ##\\n\\nThe key point is to find the longest palindrome starting from the first character, and then reverse the remaining part as the prefix to s. Any advice will be welcome!\\n\\n\\n    public String shortestPalindrome(String s) {\\n        int i = 0, end = s.length() - 1, j = end; char chs[] = s.toCharArray();\\n        while(i < j) {\\n             if (chs[i] == chs[j]) {\\n                 i++; j--;\\n             } else { \\n                 i = 0; end--; j = end;\\n             }\\n        }\\n        return new StringBuilder(s.substring(end+1)).reverse().toString() + s;\\n    }",
                "solutionTags": [],
                "code": "## Explanation ##\\n\\nThe key point is to find the longest palindrome starting from the first character, and then reverse the remaining part as the prefix to s. Any advice will be welcome!\\n\\n\\n    public String shortestPalindrome(String s) {\\n        int i = 0, end = s.length() - 1, j = end; char chs[] = s.toCharArray();\\n        while(i < j) {\\n             if (chs[i] == chs[j]) {\\n                 i++; j--;\\n             } else { \\n                 i = 0; end--; j = end;\\n             }\\n        }\\n        return new StringBuilder(s.substring(end+1)).reverse().toString() + s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 60153,
                "title": "8-line-o-n-method-using-rabin-karp-rolling-hash",
                "content": "This problem is indeed computing the longest palindromic prefix of a string s.\\nA naive approach would be computing all the prefixes of s and its reverse, and\\nthen finding the longest pair of prefixes that are equal.\\n\\nUnfortunately, this method requires quadratic time and space since\\nthe length sum of all prefixes is 1+2+...+|s| = \\u0398(|s|^2).\\n\\nVia the help of the Rolling Hash method, the above process can be optimized down to linear time.\\nFor more details, you can visit [here][1] and [here][2].\\n\\n[Java Code:][3]\\n\\n    public String shortestPalindrome(String s) {\\n        int n = s.length(), pos = -1;\\n        long B = 29, MOD = 1000000007, POW = 1, hash1 = 0, hash2 = 0;\\n        for (int i = 0; i < n; i++, POW = POW * B % MOD) {\\n            hash1 = (hash1 * B + s.charAt(i) - 'a' + 1) % MOD;\\n            hash2 = (hash2 + (s.charAt(i) - 'a' + 1) * POW) % MOD;\\n            if (hash1 == hash2) pos = i;\\n        }\\n        return new StringBuilder().append(s.substring(pos + 1, n)).reverse().append(s).toString();\\n    }\\n\\n\\n----------\\n\\nBelow is another solution by using KMP. For details, please refer to [here][4].\\n\\n[Java Code:][5]\\n\\n    public String shortestPalindrome(String s) {\\n        String concat = new StringBuilder(s).append('.').append(new StringBuffer(s).reverse()).toString();\\n        int[] next = new int[concat.length()];\\n        for (int i = 0, ptr = -1; i < next.length; ptr = next[i], i++) {\\n            while (ptr > -1 && concat.charAt(ptr + 1) != concat.charAt(i)) ptr = next[ptr];\\n            next[i] = i > 0 && concat.charAt(ptr + 1) == concat.charAt(i) ? ptr + 1 : -1;\\n        }\\n        return new StringBuilder(s.substring(next[next.length - 1] + 1, s.length())).reverse().append(s).toString();\\n    }\\n\\n\\n  [1]: https://en.wikipedia.org/wiki/Rolling_hash\\n  [2]: http://courses.csail.mit.edu/6.006/spring11/rec/rec06.pdf\\n  [3]: https://github.com/lydxlx1/LeetCode/blob/master/src/_214.java\\n  [4]: https://leetcode.com/discuss/36807/c-8-ms-kmp-based-o-n-time-&-o-n-memory-solution\\n  [5]: https://github.com/lydxlx1/LeetCode/blob/master/src/_214_1.java",
                "solutionTags": [
                    "Java",
                    "Rolling Hash"
                ],
                "code": "This problem is indeed computing the longest palindromic prefix of a string s.\\nA naive approach would be computing all the prefixes of s and its reverse, and\\nthen finding the longest pair of prefixes that are equal.\\n\\nUnfortunately, this method requires quadratic time and space since\\nthe length sum of all prefixes is 1+2+...+|s| = \\u0398(|s|^2).\\n\\nVia the help of the Rolling Hash method, the above process can be optimized down to linear time.\\nFor more details, you can visit [here][1] and [here][2].\\n\\n[Java Code:][3]\\n\\n    public String shortestPalindrome(String s) {\\n        int n = s.length(), pos = -1;\\n        long B = 29, MOD = 1000000007, POW = 1, hash1 = 0, hash2 = 0;\\n        for (int i = 0; i < n; i++, POW = POW * B % MOD) {\\n            hash1 = (hash1 * B + s.charAt(i) - 'a' + 1) % MOD;\\n            hash2 = (hash2 + (s.charAt(i) - 'a' + 1) * POW) % MOD;\\n            if (hash1 == hash2) pos = i;\\n        }\\n        return new StringBuilder().append(s.substring(pos + 1, n)).reverse().append(s).toString();\\n    }\\n\\n\\n----------\\n\\nBelow is another solution by using KMP. For details, please refer to [here][4].\\n\\n[Java Code:][5]\\n\\n    public String shortestPalindrome(String s) {\\n        String concat = new StringBuilder(s).append('.').append(new StringBuffer(s).reverse()).toString();\\n        int[] next = new int[concat.length()];\\n        for (int i = 0, ptr = -1; i < next.length; ptr = next[i], i++) {\\n            while (ptr > -1 && concat.charAt(ptr + 1) != concat.charAt(i)) ptr = next[ptr];\\n            next[i] = i > 0 && concat.charAt(ptr + 1) == concat.charAt(i) ? ptr + 1 : -1;\\n        }\\n        return new StringBuilder(s.substring(next[next.length - 1] + 1, s.length())).reverse().append(s).toString();\\n    }\\n\\n\\n  [1]: https://en.wikipedia.org/wiki/Rolling_hash\\n  [2]: http://courses.csail.mit.edu/6.006/spring11/rec/rec06.pdf\\n  [3]: https://github.com/lydxlx1/LeetCode/blob/master/src/_214.java\\n  [4]: https://leetcode.com/discuss/36807/c-8-ms-kmp-based-o-n-time-&-o-n-memory-solution\\n  [5]: https://github.com/lydxlx1/LeetCode/blob/master/src/_214_1.java",
                "codeTag": "Unknown"
            },
            {
                "id": 60096,
                "title": "my-easily-understandable-but-time-consuming-c-solution",
                "content": "The key idea is to first reverse the string, then check the max length from n to 0\\n\\n    class Solution {\\n    public:\\n        string shortestPalindrome(string s) {\\n            string s2=s;\\n            reverse(s2.begin(),s2.end());\\n            int n=s.size(),l;\\n            for(l=n;l>=0;l--)\\n            {\\n                if(s.substr(0,l)==s2.substr(n-l))\\n                    break;\\n            }\\n            return s2.substr(0,n-l)+s;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string shortestPalindrome(string s) {\\n            string s2=s;\\n            reverse(s2.begin(),s2.end());\\n            int n=s.size(),l;\\n            for(l=n;l>=0;l--)\\n            {\\n                if(s.substr(0,l)==s2.substr(n-l))\\n                    break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 60216,
                "title": "a-kmp-based-java-solution-with-explanation",
                "content": "The Idea of using KMP to find the shortest palindrome has been proposed in the previous post but did not have a very clear explanation on how this simple piece of code works. I will post my own understanding of why KMP method works well on this problem followed by my thinking process. \\n\\nFirst of All, My origin thought on this problem is to find the longest palindrome from the starting character of the string. Then we can just adding the reverse of the remaining characters to the front of the origin string to get the required shortest palindrome. However, the time complexity for finding the longest palindrome from front can cost O(n^2) and will cause a TLE when coding in Java.\\n\\nThen I found this solution post [C++ 8 ms KMP-based O(n) time & O(n) memory solution][1]\\n\\n\\n  [1]: https://leetcode.com/discuss/36807/c-8-ms-kmp-based-o-n-time-&-o-n-memory-solution\\n \\nThe code and the idea were great but the explanation was somehow lacking some insight of how people construct this solution. After read the code as well as the provided explanation, I became quiet confused with the following questions:\\n\\n1. Why should we have a combined string and why this string should be combined like this. Can we combined the string with the reverse string first and the origin string second?\\n2. What's the use of the array/vector and what value does it store? Is the numeric value represent length or something else?\\n3. What is \"recursively\" updating the index means?\\n\\nIn order to answer these questions, we have to look back to my origin idea which is finding the longest palindrome from the front. In fact the KMP solution use a similar idea which is **finding the longest prefix which has an identical counter part string that ends at the tail of the combined string(longest suffix)**  For example, let's say we have a string \"abac#caba\", then the qualified string will be \"aba\". \\nHow can we find this string? The KMP method provide us with a way to accomplish that.The detail implementation is using an array of the length of the combined string **to store the index of the character which need to be compared with the next character if current character matches the prefix's last character**. If they are the same, the index that need to be stored for the next character will be the previous stored index+1. Otherwise, we will jump further back to the index of the index to perform the same procedure until the index become zero. Then in the end, the value-1 in the last array element will represent the longest common prefix's last index value and we find the longest common prefix. Since these two strings are reversed and identical string, it must be a palindrome which fulfills my origin goal of finding the longest palindrome from the starting character. \\n\\nOne example for the above process for the string s **\"abac#caba\"**. we will have the stored indexes be **\"0,0,1,0,0,1,2,3\"** .Let's say we are at index 7 of the string s and the character is 'b' and in the array we have 1 for the previous index 6. This means the character at index 1 will need to be compared with character b to decide whether the common prefix from the front can continue to grow or not. Since both characters at  index 1 and at index 7 are 'b', the common prefix grows into length 2 which is\"ab\". \\n\\nBack to the first question, since the KMP method will help us find the longest prefix that exist in the body of the new string and we want to find the longest palindrome prefix of the origin string. We have to have the origin string at front and reverse string follows. For the second question, the array store index of the prefix that need to be match for the next character. For the last question, the recursive update happens when the matching failure so we jump to the further back to match early index in the prefix.\\n\\nBelow is my AC code in Java \\n\\n\\n    public class Solution {\\n        public String shortestPalindrome(String s) {\\n            if(s.length()<=1) return s;\\n            String new_s = s+\"#\"+new StringBuilder(s).reverse().toString();\\n            int[] position = new int[new_s.length()];\\n            \\n            for(int i=1;i<position.length;i++)\\n            {\\n                int pre_pos = position[i-1];\\n                while(pre_pos>0 && new_s.charAt(pre_pos)!=new_s.charAt(i))\\n                    pre_pos = position[pre_pos-1];\\n                position[i] = pre_pos+((new_s.charAt(pre_pos)==new_s.charAt(i))?1:0);\\n            }\\n            \\n            return new StringBuilder(s.substring(position[position.length-1])).reverse().toString()+s;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String shortestPalindrome(String s) {\\n            if(s.length()<=1) return s;\\n            String new_s = s+\"#\"+new StringBuilder(s).reverse().toString();\\n            int[] position = new int[new_s.length()];\\n            \\n            for(int i=1;i<position.length;i++)\\n            {\\n                int pre_pos = position[i-1];\\n                while(pre_pos>0 && new_s.charAt(pre_pos)!=new_s.charAt(i))\\n                    pre_pos = position[pre_pos-1];\\n                position[i] = pre_pos+((new_s.charAt(pre_pos)==new_s.charAt(i))?1:0);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 60250,
                "title": "my-recursive-python-solution",
                "content": "The Idea is simple, we use `j` to compare character from end of `s` and beginning of `s`. If it's equal, increment `j` by `1`.\\n\\nSo we can use `j-len(s)` to divide `s` in two parts. The first part is that we don't know it's Palindrome. The second part its that we know for sure its the `suffix` of result and it may need reversed and insert at beginning of result.\\n\\nThe fun part is this: `s[::-1][:len(s)-j]`\\nif `len(s)-j` is `0`, it will eliminate as `''`, otherwise it equals `reversed(s[j-len(s):])`\\nIt's same as:\\n\\n    if len(s) - j == 0:\\n        return ''\\n    else:\\n        return s[j-len(s):][::-1]\\n\\nWhole solution:\\n\\n        if not s or len(s) == 1:\\n            return s\\n        j = 0\\n        for i in reversed(range(len(s))):\\n            if s[i] == s[j]:\\n                j += 1\\n        return s[::-1][:len(s)-j] + self.shortestPalindrome(s[:j-len(s)]) + s[j-len(s):]",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "The Idea is simple, we use `j` to compare character from end of `s` and beginning of `s`. If it's equal, increment `j` by `1`.\\n\\nSo we can use `j-len(s)` to divide `s` in two parts. The first part is that we don't know it's Palindrome. The second part its that we know for sure its the `suffix` of result and it may need reversed and insert at beginning of result.\\n\\nThe fun part is this: `s[::-1][:len(s)-j]`\\nif `len(s)-j` is `0`, it will eliminate as `''`, otherwise it equals `reversed(s[j-len(s):])`\\nIt's same as:\\n\\n    if len(s) - j == 0:\\n        return ''\\n    else:\\n        return s[j-len(s):][::-1]\\n\\nWhole solution:\\n\\n        if not s or len(s) == 1:\\n            return s\\n        j = 0\\n        for i in reversed(range(len(s))):\\n            if s[i] == s[j]:\\n                j += 1\\n        return s[::-1][:len(s)-j] + self.shortestPalindrome(s[:j-len(s)]) + s[j-len(s):]",
                "codeTag": "Unknown"
            },
            {
                "id": 60204,
                "title": "using-kmp-s-lps-longest-prefix-suffix-computation-to-solve-in-linear-o-n-time",
                "content": "\\n    class Solution {\\n    private:\\n    \\n        // the straightforward solution is in O(N^2); using KMP's preprocessing algorithm,\\n        // we can reduce this to O(N)\\n        int longest_palindrome_prefix(const string &s) const\\n        {\\n            /**\\n             * The LPS computation can determine, at any given index i in a string S, the maximum suffix length that\\n             * make up a suffix equal to the prefix. For example: S = \"acexxxaceyyy\": at S[6], S[7], and S[8] will be\\n             * marked with \"1\", \"2\", and \"3\" respectively because \"a\", \"ac\", and \"ace\" at this points in the string\\n             * make up substrings whose suffixes equal to the string's prefix. This computation can be done in one\\n             * linear scan of the string in O(N) time, using a secondary integer array in O(N) space.\\n             * \\n             * For our purpose in finding the longest palindrome prefix of a string, the idea is simple:\\n             * if we reverse the string, then appending it to the original string (after a special marker),\\n             * the palindromic prefix will show up at the end of the compound string! If we then apply the above algorithm,\\n             * by the end of the linear scan, we'll have a number that correspond to the maximum suffix length of\\n             * the entire compound string, which correspond to a suffix = prefix. And since a palindromic prefix, when\\n             * reversed and appended, will show up as the suffix, we will conveniently have computed the maximum\\n             * length of the palindromic prefix!\\n             * \\n             * For example: consider the string S = \"abbaaax\". The longest palindrome prefix is \"abba\".\\n             * 1. Create S' = \"abbaaax#xaaabba\"\\n             * 2. Compute LPS: lps[] = { 0,  0,  0,  1,  1,  1,  0,  0,  0,  1,  1,  1,  2,  3,  4 }\\n             *            from  S'[] = {'a','b','b','a','a','a','x','#','x','a','a','a','b','b','a'}\\n             * 3. The last element of LPS, 4, is our longest palindrome prefix length!\\n             */\\n            string kmprev = s;\\n            std::reverse(kmprev.begin(), kmprev.end());\\n            string kmp = s + \"#\" + kmprev;\\n    \\n            vector<int> lps(kmp.size(), 0);   // lps[i] = longest suffix length for substring kmp[0..i] where the suffix == prefix\\n            for (int i = 1; i < (int)lps.size(); ++i)\\n            {\\n                int prev_idx = lps[i - 1];\\n    \\n                while (prev_idx > 0 && kmp[i] != kmp[prev_idx])\\n                {\\n                    prev_idx = lps[prev_idx - 1];\\n                }\\n    \\n                lps[i] = prev_idx + (kmp[i] == kmp[prev_idx] ? 1 : 0);\\n            }\\n    \\n            // after KMP's LPS preprocessing, the last index of the LPS array will contain the longest palindrome prefix' length!\\n            return lps[lps.size() - 1];\\n        }\\n    \\n    public:\\n    \\n        string shortestPalindrome(const string &s)\\n        {\\n            //\\n            // The idea is simple: find the longest palindrome that prefixes the string S.\\n            // The shortest palindrome we can make is by reversing the rest of the string S, and then\\n            // prepending it to the string.\\n            //\\n            // The trick is finding that longest palindrome prefix in an efficient manner.\\n            //\\n            if (s.size() <= 1)\\n            {\\n                return string(s);\\n            }\\n    \\n            int k = longest_palindrome_prefix(s);\\n    \\n            string the_rest = s.substr(k);\\n            std::reverse(the_rest.begin(), the_rest.end());\\n    \\n            return the_rest + s;\\n        }\\n    \\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    private:\\n    \\n        // the straightforward solution is in O(N^2); using KMP's preprocessing algorithm,\\n        // we can reduce this to O(N)\\n        int longest_palindrome_prefix(const string &s) const\\n        {\\n            /**\\n             * The LPS computation can determine, at any given index i in a string S, the maximum suffix length that\\n             * make up a suffix equal to the prefix. For example: S = \"acexxxaceyyy\": at S[6], S[7], and S[8] will be\\n             * marked with \"1\", \"2\", and \"3\" respectively because \"a\", \"ac\", and \"ace\" at this points in the string\\n             * make up substrings whose suffixes equal to the string's prefix. This computation can be done in one\\n             * linear scan of the string in O(N) time, using a secondary integer array in O(N) space.\\n             * \\n             * For our purpose in finding the longest palindrome prefix of a string, the idea is simple:\\n             * if we reverse the string, then appending it to the original string (after a special marker),\\n             * the palindromic prefix will show up at the end of the compound string! If we then apply the above algorithm,\\n             * by the end of the linear scan, we'll have a number that correspond to the maximum suffix length of\\n             * the entire compound string, which correspond to a suffix = prefix. And since a palindromic prefix, when\\n             * reversed and appended, will show up as the suffix, we will conveniently have computed the maximum\\n             * length of the palindromic prefix!\\n             * \\n             * For example: consider the string S = \"abbaaax\". The longest palindrome prefix is \"abba\".\\n             * 1. Create S' = \"abbaaax#xaaabba\"\\n             * 2. Compute LPS: lps[] = { 0,  0,  0,  1,  1,  1,  0,  0,  0,  1,  1,  1,  2,  3,  4 }",
                "codeTag": "Java"
            },
            {
                "id": 60243,
                "title": "accepted-4ms-c-solution-different-with-kmp-based-solution-and-easy-understand",
                "content": "For this problem,  [KMP-based solution][1] is a very typical and classic O(n) solution. Here is a different solution, it's also O(n), and I think it is more easy to understand.\\n\\nIn order to slove this problem, the key is to get the length of the longest palindromic prefix substring. if the length of s is `len`, and the length of the longest palindromic prefix substring is `longest`, the remaining substring will be `s.substr(longest, len - longest)`, than we should reverse the remaining substring and adding it in front of s.\\n\\nFor example, if s is `\"abacbbcda\"`, so the longest palindromic prefix substring is `\"aba\"`(not `\"cbbc\"` because it's not prefix string), and the remaining substring is `\"cbbcda\"`, we reverse the remaining substring and get `\"adcbbc\"`, so the result is `\"adcbbc\" + \"abacbbcda\"`.\\n\\nThe follow is my c++ solution, only 4ms. Please note that the condition in for loop is `begin <= len / 2` instead of `begin < len`, because if `begin > len / 2`, the substring can not be prefix string, so there is no need to continue.\\n\\n**Update: I made wrong analysis, the complexity is O(N^2) but not O(N). Thanks very much for Sammax's reminder.**\\n\\n    class Solution {\\n    public:\\n        std::string shortestPalindrome(std::string s) {\\n    \\t\\tint len = s.length();\\n    \\t\\tif (len < 2)\\n    \\t\\t\\treturn s;\\n\\t\\t\\t// calculate the length of the longest palindromic prefix substring.\\n    \\t\\tint longest = 1, start, end;\\n    \\t\\tfor (int begin = 0; begin <= len / 2;) {\\n    \\t\\t\\tstart = end = begin;\\n    \\t\\t\\twhile (end < len - 1 && s[end + 1] == s[end])\\n    \\t\\t\\t\\t++end;\\n    \\t\\t\\tbegin = end + 1;\\n    \\t\\t\\twhile (end < len - 1 && start > 0 && s[end + 1] == s[start - 1]) {\\n    \\t\\t\\t\\t++end;\\n    \\t\\t\\t\\t--start;\\n    \\t\\t\\t}\\n\\t\\t\\t\\t// start == 0 means the palindromic substring is also prefix string.\\n    \\t\\t\\tif (start == 0 && longest < end - start + 1)\\n    \\t\\t\\t\\tlongest = end - start + 1;\\n    \\t\\t}\\n\\t\\t\\t// reverse the remaining substring and adding it in front of s.\\n    \\t\\tstd::string remaining = s.substr(longest, len - longest);\\n    \\t\\tstd::reverse(remaining.begin(), remaining.end());\\n    \\t\\treturn remaining + s;\\n        }\\n    };\\n\\n  [1]: https://leetcode.com/discuss/36807/c-8-ms-kmp-based-o-n-time-&-o-n-memory-solution",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        std::string shortestPalindrome(std::string s) {\\n    \\t\\tint len = s.length();\\n    \\t\\tif (len < 2)\\n    \\t\\t\\treturn s;\\n\\t\\t\\t// calculate the length of the longest palindromic prefix substring.\\n    \\t\\tint longest = 1, start, end;\\n    \\t\\tfor (int begin = 0; begin <= len / 2;) {\\n    \\t\\t\\tstart = end = begin;\\n    \\t\\t\\twhile (end < len - 1 && s[end + 1] == s[end])\\n    \\t\\t\\t\\t++end;\\n    \\t\\t\\tbegin = end + 1;\\n    \\t\\t\\twhile (end < len - 1 && start > 0 && s[end + 1] == s[start - 1]) {\\n    \\t\\t\\t\\t++end;\\n    \\t\\t\\t\\t--start;\\n    \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 60261,
                "title": "python-solution-kmp",
                "content": "    class Solution:\\n    # @param {string} s\\n    # @return {string}\\n    def shortestPalindrome(self, s):\\n        A=s+\"*\"+s[::-1]\\n        cont=[0]\\n        for i in range(1,len(A)):\\n            index=cont[i-1]\\n            while(index>0 and A[index]!=A[i]):\\n                index=cont[index-1]\\n            cont.append(index+(1 if A[index]==A[i] else 0))\\n        return s[cont[-1]:][::-1]+s",
                "solutionTags": [],
                "code": "class Solution:\\n    # @param {string}",
                "codeTag": "Java"
            },
            {
                "id": 60230,
                "title": "easy-java-solution",
                "content": "First, we can find the longest palindrome which include the first character in s, then we just need to reverse the suffix and add it to the front of string s.\\n\\nWhen looking for the longest palindrome, we start from the center and traverse to left and right, and we need to think the length of the palindrome could be odd or even.\\n\\n    public class Solution {\\n    public String shortestPalindrome(String s) {\\n        int n = s.length();\\n        if(n<=1){\\n            return s;\\n        }\\n        int idx = 0;\\n        for(int center = n/2; center>=0; center--){\\n            if(valid(s, center, 1)){   //is the longest valid palindrome? (assume length is even)\\n                idx = 2*center+1;\\n                break;\\n            }\\n            if(valid(s, center, 0)){  //assume length is odd\\n                idx = 2*center;\\n                break;\\n            }\\n            \\n        }\\n        String suffix = s.substring(idx+1);\\n        StringBuilder b = new StringBuilder(suffix);\\n        return b.reverse().toString()+s;\\n    }\\n    boolean valid(String s, int center, int shift){\\n        int i = center, j = center+shift;\\n        while(i>=0 && j<s.length()){\\n            if(s.charAt(i)!=s.charAt(j)){\\n                break;\\n            }\\n            i--;\\n            j++;\\n        }\\n        return i<0;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String shortestPalindrome(String s) {\\n        int n = s.length();\\n        if(n<=1){\\n            return s;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 60151,
                "title": "accepted-c-solution-easy-to-understand",
                "content": "The general idea is very simple: reverse s at first and compare substr of s with its reversed version.\\n\\n\\n    string shortestPalindrome(string s)\\n        {\\n            int n = s.size();\\n            if(n == 0) return s;\\n            \\n            int i = n;\\n            string v = s; \\n            reverse(v.begin(), v.end());  //Reverse s.\\n            \\n            for(; i >= 1; --i)\\n            {\\n                if(s.substr(0, i) == v.substr(n - i)) break;    //palindrome?\\n            }\\n            for(; i < s.size(); i += 2) s = s[i] + s;   //Construct\\n            return s;\\n        }",
                "solutionTags": [],
                "code": "The general idea is very simple: reverse s at first and compare substr of s with its reversed version.\\n\\n\\n    string shortestPalindrome(string s)\\n        {\\n            int n = s.size();\\n            if(n == 0) return s;\\n            \\n            int i = n;\\n            string v = s; \\n            reverse(v.begin(), v.end());  //Reverse s.\\n            \\n            for(; i >= 1; --i)\\n            {\\n                if(s.substr(0, i) == v.substr(n - i)) break;    //palindrome?\\n            }\\n            for(; i < s.size(); i += 2) s = s[i] + s;   //Construct\\n            return s;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 60188,
                "title": "my-c-o-n-solution-based-on-manacher-s-algorithm",
                "content": "The brute-force method is O(N^2),which gets TLE. So have to move to Manacher's algorithm, which is O(N) time. Such algorithm returns the maximum length of the palindrome string centered at i, so we just need to find the maximum length palindrome string with the left end point at 0. Then we can construct the result. The Manacher's algorithm codes are partially copied from this site.\\n\\n    class Solution {\\n    public:\\n    // Transform S into T.\\n    // For example, S = \"abba\", T = \"^#a#b#b#a#$\".\\n    // ^ and $ signs are sentinels appended to each end to avoid bounds checking\\n    string preProcess(string s) {\\n      int n = s.length();\\n      if (n == 0) return \"^$\";\\n      string ret(2*n+3, '#');\\n      ret[0] = '^';ret[2*n+1] = '$';\\n      for (int i = 1; i <= n; i++)  ret[2*i]=s[i-1];\\n     \\n      return ret;\\n    }\\n        \\n    string shortestPalindrome(string s) {\\n    \\n      int len = s.size();\\n      if(len<=1) return s;\\n      string T = preProcess(s);\\n      const int n = T.length();\\n      int P[n], i_mirror;\\n      int C = 0, R = 0;\\n      \\n      for (int i = 1; i < n-1; i++) {\\n        i_mirror = 2*C-i; // equals to i' = C - (i-C)\\n        \\n        P[i] = (R > i) ? min(R-i, P[i_mirror]) : 0;\\n        \\n        // Attempt to expand palindrome centered at i\\n        while (T[i + 1 + P[i]] == T[i - 1 - P[i]])\\n          P[i]++;\\n     \\n        // If palindrome centered at i expand past R,\\n        // adjust center based on expanded palindrome.\\n        if (i + P[i] > R) {\\n          C = i;\\n          R = i + P[i];\\n        }\\n      }\\n     \\n      // Just changed this part, \\n      int maxLen = 0;\\n      int centerIndex = 0;\\n      for (int i = 1; i < n-1; i++) {\\n        if (1==i-P[i]) maxLen = P[i];\\n      }\\n      string temp = s.substr(maxLen);\\n      reverse(temp.begin(),temp.end());\\n      return temp+s;\\n            \\n        }\\n    };\\n\\nAlso KMP based method added, where T is an array to save the maximum length of the Palindrome substring ending at res[i]. \\n\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s) {\\n       const int len = s.size();\\n       string res = s;\\n       if(len>1)\\n       {\\n           reverse(res.begin(), res.end());\\n           res = s + '&' + res;\\n           \\n           int i, T[2*len+1];\\n           T[0] = 0;\\n           \\n           for(i=1; i<=2*len; i++)\\n           {\\n               T[i] = T[i-1];\\n               while(T[i]>0 && res[i]!=res[T[i]]) T[i] = T[T[i]-1];\\n               T[i] += (res[i] ==res[T[i]]);\\n           }\\n           \\n           return res.substr(len+1,len-T[2*len]) + s;\\n       }\\n       return s;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    // Transform S into T.\\n    // For example, S = \"abba\", T = \"^#a#b#b#a#$\".\\n    // ^ and $ signs are sentinels appended to each end to avoid bounds checking\\n    string preProcess(string s) {\\n      int n = s.length();\\n      if (n == 0) return \"^$\";\\n      string ret(2*n+3, '#');\\n      ret[0] = '^';ret[2*n+1] = '$';\\n      for (int i = 1; i <= n; i++)  ret[2*i]=s[i-1];\\n     \\n      return ret;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2586434,
                "title": "100-faster-solution-using-rolling-hash-c-well-explained",
                "content": "**Please upvote if you like my solution .**\\n```\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s) {\\n        if(s.length() < 2) return s;\\n        // rolling hash means we are hashing and adding char to it\\n        int prime = 31 , m = 1e9 + 7;\\n        long long int pnos = 31 ; \\n        // we can solve this by sliding window approach as we have to find maximum length of palindrome \\n\\t\\t// that starts at 0 and ends at ind i so we have to add i + 1 th to end of string to our previous string\\n        // so this will be like if we add ith char it will be palindrome or not if it is then good to go but it not then break\\n        // we are creating 2 hash forward and reverse hash so that if both are equal means that we have palindrome \\n        // in forward hash we are adding character value (a - 1) and multiplying it with i\\'th power of prime \\n        // in reverse hash we are multiplying previous hash with prime and then adding character value to previous hash and\\n        int ind = 0;\\n        long long int shash = s[0] - \\'a\\' + 1;\\n        long long int rhash = s[0] - \\'a\\' + 1;\\n        for(int i = 1;i<s.length();i++){\\n            // forward hash\\n            shash = shash + (s[i] - \\'a\\' + 1)*pnos;\\n            shash = shash%m;\\n            // reverse hash\\n            rhash = rhash*prime + (s[i] - \\'a\\' + 1);\\n            rhash = rhash%m;\\n            // updating power of prime\\n            pnos *= prime;\\n            pnos = pnos%m;\\n            if(shash == rhash){\\n                // till this index string is palindrome\\n                ind = i;\\n            }\\n        }\\n        // now take string from ind + 1 and reverse it and paste it to rear of given string\\n        string rev = s.substr(ind+1);\\n        reverse(rev.begin(),rev.end());\\n        return rev + s;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/8e0bea5d-4020-422d-b48a-3dda1bca4631_1663402566.9968023.png)\\n",
                "solutionTags": [
                    "C",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s) {\\n        if(s.length() < 2) return s;\\n        // rolling hash means we are hashing and adding char to it\\n        int prime = 31 , m = 1e9 + 7;\\n        long long int pnos = 31 ; \\n        // we can solve this by sliding window approach as we have to find maximum length of palindrome \\n\\t\\t// that starts at 0 and ends at ind i so we have to add i + 1 th to end of string to our previous string\\n        // so this will be like if we add ith char it will be palindrome or not if it is then good to go but it not then break\\n        // we are creating 2 hash forward and reverse hash so that if both are equal means that we have palindrome \\n        // in forward hash we are adding character value (a - 1) and multiplying it with i\\'th power of prime \\n        // in reverse hash we are multiplying previous hash with prime and then adding character value to previous hash and\\n        int ind = 0;\\n        long long int shash = s[0] - \\'a\\' + 1;\\n        long long int rhash = s[0] - \\'a\\' + 1;\\n        for(int i = 1;i<s.length();i++){\\n            // forward hash\\n            shash = shash + (s[i] - \\'a\\' + 1)*pnos;\\n            shash = shash%m;\\n            // reverse hash\\n            rhash = rhash*prime + (s[i] - \\'a\\' + 1);\\n            rhash = rhash%m;\\n            // updating power of prime\\n            pnos *= prime;\\n            pnos = pnos%m;\\n            if(shash == rhash){\\n                // till this index string is palindrome\\n                ind = i;\\n            }\\n        }\\n        // now take string from ind + 1 and reverse it and paste it to rear of given string\\n        string rev = s.substr(ind+1);\\n        reverse(rev.begin(),rev.end());\\n        return rev + s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529864,
                "title": "c-kmp-solution-short-and-simple",
                "content": "\\n    // kmp function to find kmp array, taken array of size n+1, to make things little simple and the code short\\n\\t\\n    vector<int> KMP(string &s){\\n        int n = s.length();\\n        vector<int> kmp(n+1);\\n        int i = 0,j = -1;\\n        kmp[0] = -1;   // set that to -1 so avoid comparison further in nested while loop in the code below as the array front end is hit when, we get j as -1 which means we have to stop\\n        \\n        while(i < n){\\n            while(j != -1 && s[j] != s[i]){\\n                j = kmp[j];      // jumping backwards in kmp array to find any other possibility of match in cases of mismatches\\n            }\\n            j++; i++;     \\n            kmp[i] = j;      // set the curr index kmp array value\\n        }\\n        \\n        return kmp;   \\n    }\\n\\t// Just remember this kmp code . Believe me it will be easier. (just 6 lines of main logic in this kmp code)\\n\\n..............................\\n\\nTest case 1 :\\n\\t\\t\\n        s = \"aacecaaa\"\\n        x = \"aaacecaa\"\\n\\n     T = \"aacecaaa#aaacecaa\" // apply kmp on this. \"#\" is used for separating both the s and rev(s). To avoid wrong matching.\\n\\n     index =  0 1 2 3 4 5 6 7 8  9  10 11 12 13 14 15 16 17\\n         T =   {a a c e c a a}a  #   a [a  a  c  e  c  a  a]\\n       kmp = -1 0 1 0 0 0 1 2 2  0   1  2  2  3  4  5  6  7\\n\\n    \"(aacecaa)a\" , the part in the small bracket is common in both. So if append \"a\" at start of the original string s, we will get the shortest palindrome. -> (1)\\n\\n....................\\n\\nSteps to follow :\\n\\n    Step 1 : Find kmp array for string T = original string + \"#\" + reversed string (pattern to be matched)\\n    Step 2 : Get the last element in the kmp array, represents the length matched with the reverse string pattern -> say length l.\\n    Step 3 : Remove the first l characters from the original string (represented in small brackets above) , reverse the remaining characters (say string temp)\\n    Step 4 : Add this temp to start of the original string. i.e., Answer = temp + s.\\n\\n.........................................\\n\\n\\n    string shortestPalindrome(string s) {\\n        \\n        string x = s;\\n        reverse(x.begin(),x.end());     // reverse the original string \\n        \\n        \\n        string T = s + \"#\" + x;   \\n        int n = T.length();      \\n        vector<int> kmp = KMP(T);   // form kmp array for this string T\\n\\n\\n        int l = kmp[n];   // find the length of matched part\\n        \\n        string temp = s.substr(l);         // remove first l elements from s , and store the remaining string in temp.\\n        reverse(temp.begin(),temp.end());   // revrersed the temp string\\n        \\n        return temp + s;  // add temp to start of s, to get the shortest palindrome.\\n    }\\n    \\n    /*\\n    \\n    Note : In  this problem they have asked to make the string palindrome by appending minimum characters at start. We used string T = s + \"#\" + rev(s).\\n    Also we have removed first first l elements from s. Reverse the remaining string and append it to start of s.\\n\\n    But if were being asked to find the same by appending minimum characters at start . We would have used T = rev(s) + \"#\" + s. \\n    Also we would have removed last l elements from s. Reverse the remaining elements and append it to end of s.\\n\\t\\n\\t*/\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "\\n    // kmp function to find kmp array, taken array of size n+1, to make things little simple and the code short\\n\\t\\n    vector<int> KMP(string &s){\\n        int n = s.length();\\n        vector<int> kmp(n+1);\\n        int i = 0,j = -1;\\n        kmp[0] = -1;   // set that to -1 so avoid comparison further in nested while loop in the code below as the array front end is hit when, we get j as -1 which means we have to stop\\n        \\n        while(i < n){\\n            while(j != -1 && s[j] != s[i]){\\n                j = kmp[j];      // jumping backwards in kmp array to find any other possibility of match in cases of mismatches\\n            }\\n            j++; i++;     \\n            kmp[i] = j;      // set the curr index kmp array value\\n        }\\n        \\n        return kmp;   \\n    }\\n\\t// Just remember this kmp code . Believe me it will be easier. (just 6 lines of main logic in this kmp code)\\n\\n..............................\\n\\nTest case 1 :\\n\\t\\t\\n        s = \"aacecaaa\"\\n        x = \"aaacecaa\"\\n\\n     T = \"aacecaaa#aaacecaa\" // apply kmp on this. \"#\" is used for separating both the s and rev(s). To avoid wrong matching.\\n\\n     index =  0 1 2 3 4 5 6 7 8  9  10 11 12 13 14 15 16 17\\n         T =   {a a c e c a a}a  #   a [a  a  c  e  c  a  a]\\n       kmp = -1 0 1 0 0 0 1 2 2  0   1  2  2  3  4  5  6  7\\n\\n    \"(aacecaa)a\" , the part in the small bracket is common in both. So if append \"a\" at start of the original string s, we will get the shortest palindrome. -> (1)\\n\\n....................\\n\\nSteps to follow :\\n\\n    Step 1 : Find kmp array for string T = original string + \"#\" + reversed string (pattern to be matched)\\n    Step 2 : Get the last element in the kmp array, represents the length matched with the reverse string pattern -> say length l.\\n    Step 3 : Remove the first l characters from the original string (represented in small brackets above) , reverse the remaining characters (say string temp)\\n    Step 4 : Add this temp to start of the original string. i.e., Answer = temp + s.\\n\\n.........................................\\n\\n\\n    string shortestPalindrome(string s) {\\n        \\n        string x = s;\\n        reverse(x.begin(),x.end());     // reverse the original string \\n        \\n        \\n        string T = s + \"#\" + x;   \\n        int n = T.length();      \\n        vector<int> kmp = KMP(T);   // form kmp array for this string T\\n\\n\\n        int l = kmp[n];   // find the length of matched part\\n        \\n        string temp = s.substr(l);         // remove first l elements from s , and store the remaining string in temp.\\n        reverse(temp.begin(),temp.end());   // revrersed the temp string\\n        \\n        return temp + s;  // add temp to start of s, to get the shortest palindrome.\\n    }\\n    \\n    /*\\n    \\n    Note : In  this problem they have asked to make the string palindrome by appending minimum characters at start. We used string T = s + \"#\" + rev(s).\\n    Also we have removed first first l elements from s. Reverse the remaining string and append it to start of s.\\n\\n    But if were being asked to find the same by appending minimum characters at start . We would have used T = rev(s) + \"#\" + s. \\n    Also we would have removed last l elements from s. Reverse the remaining elements and append it to end of s.\\n\\t\\n\\t*/\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 60234,
                "title": "easy-c-manacher",
                "content": "The idea is to find the longest palindromic substring of `s` that begins with `s[0]`. Then take the remaining susbtring, reverse it and append it to the beginning of `s`.\\n\\nFor example, given `s = \"aacecaaa\"`, the longest palindromic substring beginning with `s[0] = 'a'` is `\"aacecaa\"` and the remaining substring is `\"a\"`. Reverse it and append it to the beginning of `s` gives `\"aaacecaaa\"`. \\n\\nFor `s = \"abcd\"`, the longest palindromic substring beginning with `s[0] = 'a'` is `\"a\"` and the remaining substring is `\"bcd\"`. Reverse it and append it to the beginning of `s` gives `\"dcbabcd\"`.\\n \\nThe most difficult part is to implement the Manacher's algorithm to find the longest palindromic substring starting with `s[0]`. Please refer to this [nice article][1] if you want to know how it works. \\n \\nThe code is as follows. \\n\\n    class Solution {\\n    public:\\n        string shortestPalindrome(string s) {\\n            string t = process(s);\\n            int n = t.length(), center = 0, right = 0;\\n            int* palin = new int[n];\\n            for (int i = 1; i < n - 1; i++) {\\n                int i_mirror = 2 * center - i;\\n                palin[i] = (right > i) ? min(palin[i_mirror], right - i) : 0;\\n                while (t[i + palin[i] + 1] == t[i - palin[i] - 1])\\n                    palin[i]++;\\n                if (i + palin[i] > right) {\\n                    center = i;\\n                    right = i + palin[i];\\n                }\\n            }\\n            int pos;\\n            for (int i = n - 2; i; i--) {\\n                if (i - palin[i] == 1) {\\n                    pos = palin[i];\\n                    break;\\n                }\\n            }\\n            string tail = s.substr(pos); \\n            reverse(tail.begin(), tail.end());\\n            return tail + s;\\n        }\\n    private:\\n        string process(string& s) {\\n            int n = s.length();\\n            string t(2 * n + 3, '#');\\n            t[0] = '$'; t[2 * n + 2] = '%';\\n            for (int i = 0; i < n; i++)\\n                t[2 * (i + 1)] = s[i];\\n            return t;\\n        }\\n    };\\n\\nNote that this part of the code is just to find the ending position of the longest palindromic substring begining with `s[0]`.\\n\\n    int pos;\\n    for (int i = n - 2; i; i--) {\\n        if (i - palin[i] == 1) {\\n            pos = palin[i];\\n            break;\\n        } \\n    } \\n\\n  [1]: http://articles.leetcode.com/2011/11/longest-palindromic-substring-part-ii.html",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "class Solution {\\n    public:\\n        string shortestPalindrome(string s) {\\n            string t = process(s);\\n            int n = t.length(), center = 0, right = 0;\\n            int* palin = new int[n];\\n            for (int i = 1; i < n - 1; i++) {\\n                int i_mirror = 2 * center - i;\\n                palin[i] = (right > i) ? min(palin[i_mirror], right - i) : 0;\\n                while (t[i + palin[i] + 1] == t[i - palin[i] - 1])\\n                    palin[i]++;\\n                if (i + palin[i] > right) {\\n                    center = i;\\n                    right = i + palin[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3224602,
                "title": "214-90-2-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis is a simple and efficient solution that uses string slicing to reverse the original string and check prefixes of the reversed string to find the longest palindrome suffix in the original string. Then it prepends the remaining characters in the reversed string to the original string to get the shortest palindrome.\\n\\nHere is a step-by-step explanation of the code:\\n\\n1. Reverse the original string and store it in a variable t.\\n```\\nt = s[::-1]\\n```\\n2. Iterate through each index i in the reversed string t.\\n\\n3. Check if the original string s starts with the suffix of t from index i to the end.\\n```\\nif s.startswith(t[i:]):\\n```\\n4. If a palindrome suffix is found, prepend the remaining characters in t to s to create the shortest palindrome.\\n```\\nreturn t[:i] + s\\n```\\n5. If no palindrome suffix is found, the entire reversed string t must be added to the front of s to create the shortest palindrome.\\n```\\nreturn t + s\\n```\\n# Complexity\\n- Time complexity:\\nBeats 90.2%\\n\\n- Space complexity:\\nBeats 45.21%\\n\\n# Code\\n```\\nclass Solution:\\n    def shortestPalindrome(self, s: str) -> str:\\n        t = s[::-1]\\n\\n        for i in range(len(t)):\\n            if s.startswith(t[i:]):\\n                return t[:i] + s\\n\\n        return t + s\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Rolling Hash",
                    "String Matching"
                ],
                "code": "```\\nt = s[::-1]\\n```\n```\\nif s.startswith(t[i:]):\\n```\n```\\nreturn t[:i] + s\\n```\n```\\nreturn t + s\\n```\n```\\nclass Solution:\\n    def shortestPalindrome(self, s: str) -> str:\\n        t = s[::-1]\\n\\n        for i in range(len(t)):\\n            if s.startswith(t[i:]):\\n                return t[:i] + s\\n\\n        return t + s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2444747,
                "title": "simple-python-in-7-lines-with-comment",
                "content": "\\'\\'\\'\\n\\n    def shortestPalindrome(self, s: str) -> str:\\n        if s==\"\": return \"\"\\n        if s==s[::-1]: return s\\n\\t\\t\\n\\t\\t# start removing chars from the end until we find a valid palindrome\\n\\t\\t# then, reverse whatever was left at the end and append to the beginning\\n        for i in range(len(s)-1, -1, -1):\\n            if(s[:i]==s[:i][::-1]):\\n                to_add = s[i:][::-1]\\n                break\\n        return to_add+s\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\'\\'\\'\\n\\n    def shortestPalindrome(self, s: str) -> str:\\n        if s==\"\": return \"\"\\n        if s==s[::-1]: return s\\n\\t\\t\\n\\t\\t# start removing chars from the end until we find a valid palindrome\\n\\t\\t# then, reverse whatever was left at the end and append to the beginning\\n        for i in range(len(s)-1, -1, -1):\\n            if(s[:i]==s[:i][::-1]):\\n                to_add = s[i:][::-1]\\n                break\\n        return to_add+s\\n\\n\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 259096,
                "title": "using-z-algorithm-o-n",
                "content": "class Solution {\\npublic:\\n    string shortestPalindrome(string s) {\\n        \\n        if(s == \"\")\\n            return s;\\n        int len = s.length();\\n        string r = s;\\n        reverse(r.begin(), r.end());\\n        int z[2 * len + 5];\\n        memset(z, 0, sizeof z);\\n        string x = s + \"$\" + r;\\n        int L, R;\\n        int xsize = 2 * len + 1;\\n        L = R = 0;\\n        for(int i = 0 ; i < xsize; i++)\\n        {\\n            if(i > R)\\n            {\\n                L = R = i;\\n                while(R < xsize && x[R] == x[R - L]) R++;\\n                z[i] = R - L; R--;\\n            }\\n            else\\n            {\\n                int k = i - L;\\n                if(z[k] < R - i + 1)\\n                    z[i] = z[k];\\n                else\\n                {\\n                    L = i;\\n                    while(R < xsize && x[R] == x[R - L]) R++;\\n                    z[i] = R - L; R--;\\n                }\\n            }\\n            if(i > len && i + z[i] == xsize) // found answer\\n                return x.substr(len + 1, i - len - 1) + s;\\n        }\\n        return \"\";\\n    }\\n};\\n\\n\\nResources :\\nhttps://codeforces.com/blog/entry/3107\\nhttps://www.youtube.com/watch?v=MFK0WYeVEag (detailed)\\nhttps://www.youtube.com/watch?v=CpZh4eF8QBw (short)\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string shortestPalindrome(string s) {\\n        \\n        if(s == \"\")\\n            return s;\\n        int len = s.length();\\n        string r = s;\\n        reverse(r.begin(), r.end());\\n        int z[2 * len + 5];\\n        memset(z, 0, sizeof z);\\n        string x = s + \"$\" + r;\\n        int L, R;\\n        int xsize = 2 * len + 1;\\n        L = R = 0;\\n        for(int i = 0 ; i < xsize; i++)\\n        {\\n            if(i > R)\\n            {\\n                L = R = i;\\n                while(R < xsize && x[R] == x[R - L]) R++;\\n                z[i] = R - L; R--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1697046,
                "title": "3ms-clean-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> prefix_function(string s) {\\n    int n = (int) s.size();\\n    vector<int> pi(n);\\n    for (int i = 1; i < n; i++) {\\n        int j = pi[i-1];\\n        while (j > 0 && s[i] != s[j])\\n            j = pi[j-1];\\n        if (s[i] == s[j])\\n            j++;\\n        pi[i] = j;\\n     }\\n      return pi;\\n    }\\n\\n    string shortestPalindrome(string s) {\\n        string _s = s;\\n        reverse(_s.begin(), _s.end());\\n        auto kmp = prefix_function(s + \\'#\\' + _s).back();\\n        string add = s.substr(kmp, s.size() - kmp);\\n        reverse(add.begin(), add.end());\\n        return add + s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> prefix_function(string s) {\\n    int n = (int) s.size();\\n    vector<int> pi(n);\\n    for (int i = 1; i < n; i++) {\\n        int j = pi[i-1];\\n        while (j > 0 && s[i] != s[j])\\n            j = pi[j-1];\\n        if (s[i] == s[j])\\n            j++;\\n        pi[i] = j;\\n     }\\n      return pi;\\n    }\\n\\n    string shortestPalindrome(string s) {\\n        string _s = s;\\n        reverse(_s.begin(), _s.end());\\n        auto kmp = prefix_function(s + \\'#\\' + _s).back();\\n        string add = s.substr(kmp, s.size() - kmp);\\n        reverse(add.begin(), add.end());\\n        return add + s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60117,
                "title": "brute-force-solution-java-longest-palindrome-prefix",
                "content": "This is a straightforward Java solution via finding the longest palindrome prefix. I don't think I can come out with the KMP solution or the magical recursive solution during the interview, so I post what I would write here.\\n\\n```java\\npublic class Solution {\\n    public String shortestPalindrome(String s) {\\n        if (s == null || s.isEmpty()) return s;\\n\\n        int maxIndex = 0;\\n        for(int i=s.length()-1; i>=0; --i) {\\n            if (_isPalindrome(s, 0, i)) {\\n                maxIndex = i;\\n                break;\\n            }\\n        }\\n\\n        if (maxIndex == s.length()-1) return s;\\n\\n        StringBuilder sb = new StringBuilder(s.substring(maxIndex+1, s.length()));\\n        return sb.reverse().append(s).toString();\\n    }\\n\\n    private boolean _isPalindrome(String s, int l, int r){\\n        if (s == null || s.isEmpty()) return true;\\n\\n        while(l <= r) {\\n            if (s.charAt(l++) != s.charAt(r--)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic class Solution {\\n    public String shortestPalindrome(String s) {\\n        if (s == null || s.isEmpty()) return s;\\n\\n        int maxIndex = 0;\\n        for(int i=s.length()-1; i>=0; --i) {\\n            if (_isPalindrome(s, 0, i)) {\\n                maxIndex = i;\\n                break;\\n            }\\n        }\\n\\n        if (maxIndex == s.length()-1) return s;\\n\\n        StringBuilder sb = new StringBuilder(s.substring(maxIndex+1, s.length()));\\n        return sb.reverse().append(s).toString();\\n    }\\n\\n    private boolean _isPalindrome(String s, int l, int r){\\n        if (s == null || s.isEmpty()) return true;\\n\\n        while(l <= r) {\\n            if (s.charAt(l++) != s.charAt(r--)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60281,
                "title": "simple-javascript-o-n-2-solution-140ms",
                "content": "The idea of this solution is trying to find the palindrome center.  \\nWe have 2 pointers 'head' and 'tail pointing to the expected center.  \\nAt the begining of each loop, we find neighbors which have the same value, then adjust the pointers.  \\nIf s[head] is equals to the s[tail], head--, tail++.   \\nIf head is equals to 0, the result is the inverted string behind 'tail'.    \\nNoticed that 1. Palindrome center only existing in the first half of the string.   \\n2. If the center is not a single character,  they should be same letters.     \\n\\n     /**\\n     * @param {string} s\\n     * @return {string}\\n     */\\n    var shortestPalindrome = function(s) {\\n        var prefix = \"\";\\n        var pos, head, tail;\\n    \\n         for(pos = head = tail = parseInt(s.length / 2); pos > 0; head = tail = --pos){\\n            while(head !== 0 && s[head - 1] === s[head]){\\n                head--; pos--;\\n            }\\n            while(tail != s.length - 1 && s[tail + 1] === s[tail]){\\n                tail++;\\n            }\\n            var isSame = true;\\n            while(head >= 0){\\n                if(s[head] !== s[tail]){\\n                    isSame = false;\\n                    break;\\n                }\\n                head--; tail++;\\n            }\\n            if(isSame){\\n                break;\\n            }\\n        }\\n    \\n        for(var k = s.length - 1; k >= tail && k !== 0; k--){\\n            prefix += s[k];\\n        }\\n        return prefix + s;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "The idea of this solution is trying to find the palindrome center.  \\nWe have 2 pointers 'head' and 'tail pointing to the expected center.  \\nAt the begining of each loop, we find neighbors which have the same value, then adjust the pointers.  \\nIf s[head] is equals to the s[tail], head--, tail++.   \\nIf head is equals to 0, the result is the inverted string behind 'tail'.    \\nNoticed that 1. Palindrome center only existing in the first half of the string.   \\n2. If the center is not a single character,  they should be same letters.     \\n\\n     /**\\n     * @param {string} s\\n     * @return {string}\\n     */\\n    var shortestPalindrome = function(s) {\\n        var prefix = \"\";\\n        var pos, head, tail;\\n    \\n         for(pos = head = tail = parseInt(s.length / 2); pos > 0; head = tail = --pos){\\n            while(head !== 0 && s[head - 1] === s[head]){\\n                head--; pos--;\\n            }\\n            while(tail != s.length - 1 && s[tail + 1] === s[tail]){\\n                tail++;\\n            }\\n            var isSame = true;\\n            while(head >= 0){\\n                if(s[head] !== s[tail]){\\n                    isSame = false;\\n                    break;\\n                }\\n                head--; tail++;\\n            }\\n            if(isSame){\\n                break;\\n            }\\n        }\\n    \\n        for(var k = s.length - 1; k >= tail && k !== 0; k--){\\n            prefix += s[k];\\n        }\\n        return prefix + s;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3500396,
                "title": "kmp-approach-find-longest-palindrome-from-index-0-c-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid computelps(vector<int>&lps,string s,int m)\\n{\\n    int len=0,i=1;\\n    while(i<m)\\n    {\\n        if(s[len]==s[i])\\n        {\\n            len++;\\n            lps[i]=len;\\n            i++;\\n        }\\n        else\\n        {\\n            if(len!=0) len=lps[len-1];\\n            else\\n            {\\n                lps[i]=0;\\n                i++;\\n            }\\n        }\\n    }\\n}\\n    string shortestPalindrome(string s) {\\n      int n=s.size();\\n      string ans=s;\\n      s+=\\'#\\';\\n\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            s+=s[i];\\n        }\\n        vector<int>lps(2*n+2,0);\\n        computelps(lps,s,n+n+1);\\n        string temp=\"\";\\n        for(int i=n-1;i>=lps[2*n];i--)\\n        {\\n            temp+=s[i];\\n        }\\n        return temp+ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid computelps(vector<int>&lps,string s,int m)\\n{\\n    int len=0,i=1;\\n    while(i<m)\\n    {\\n        if(s[len]==s[i])\\n        {\\n            len++;\\n            lps[i]=len;\\n            i++;\\n        }\\n        else\\n        {\\n            if(len!=0) len=lps[len-1];\\n            else\\n            {\\n                lps[i]=0;\\n                i++;\\n            }\\n        }\\n    }\\n}\\n    string shortestPalindrome(string s) {\\n      int n=s.size();\\n      string ans=s;\\n      s+=\\'#\\';\\n\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            s+=s[i];\\n        }\\n        vector<int>lps(2*n+2,0);\\n        computelps(lps,s,n+n+1);\\n        string temp=\"\";\\n        for(int i=n-1;i>=lps[2*n];i--)\\n        {\\n            temp+=s[i];\\n        }\\n        return temp+ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2204327,
                "title": "z-algorithm-o-n-linear-complexity",
                "content": "```\\n    vector<int> z_function(string s) {\\n    int n = (int) s.length();\\n    vector<int> z(n);\\n    for (int i = 1, l = 0, r = 0; i < n; ++i) {\\n        if (i <= r)\\n            z[i] = min (r - i + 1, z[i - l]);\\n        while (i + z[i] < n && s[z[i]] == s[i + z[i]])\\n            ++z[i];\\n        if (i + z[i] - 1 > r)\\n            l = i, r = i + z[i] - 1;\\n    }\\n    return z;\\n}\\n    string shortestPalindrome(string s) {\\n        \\n        // s \\n        // rev(s) + s\\n        // cba  abc\\n        // \\n       string a=s;\\n        int ans=0;\\n       reverse(a.begin(),a.end());\\n        \\n  string now = s+\\'#\\'+a;\\n        \\n  vector<int>z = z_function(now);\\n        int n=z.size();\\n        int m= a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            cout<<z[i]<<\" \";\\n        }\\n  for(int i=a.size()+1,j=0;i<n;i++,j++)\\n  {\\n       if(z[i] == m-j)\\n      {\\n          ans=z[i];\\n          break;\\n      }\\n     \\n  }\\n        \\n   string mia= a.substr(0,a.size()-ans)+s;\\n   return mia;\\n        \\n     }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<int> z_function(string s) {\\n    int n = (int) s.length();\\n    vector<int> z(n);\\n    for (int i = 1, l = 0, r = 0; i < n; ++i) {\\n        if (i <= r)\\n            z[i] = min (r - i + 1, z[i - l]);\\n        while (i + z[i] < n && s[z[i]] == s[i + z[i]])\\n            ++z[i];\\n        if (i + z[i] - 1 > r)\\n            l = i, r = i + z[i] - 1;\\n    }\\n    return z;\\n}\\n    string shortestPalindrome(string s) {\\n        \\n        // s \\n        // rev(s) + s\\n        // cba  abc\\n        // \\n       string a=s;\\n        int ans=0;\\n       reverse(a.begin(),a.end());\\n        \\n  string now = s+\\'#\\'+a;\\n        \\n  vector<int>z = z_function(now);\\n        int n=z.size();\\n        int m= a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            cout<<z[i]<<\" \";\\n        }\\n  for(int i=a.size()+1,j=0;i<n;i++,j++)\\n  {\\n       if(z[i] == m-j)\\n      {\\n          ans=z[i];\\n          break;\\n      }\\n     \\n  }\\n        \\n   string mia= a.substr(0,a.size()-ans)+s;\\n   return mia;\\n        \\n     }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 441984,
                "title": "python-kmp-with-explanation",
                "content": "You must first understand how KMP algorithm works.\\n\\n\\nIn KMP, we build an auxillary list called as longestPrefixes list (say lps). \\nThis list will have information about the longest Prefixes.\\nlps[i] will have the value where the earlier prefix was seen.\\n\\nWhen we concatenate a string with it\\'s reverse, the last element of the lps list will have the information about the largest prefix for this combined string that was seen for the last element.\\n\\nFor example:\\ns = \"abca\"\\na = \"abca\\\\*acba\"\\nlps(a) => [0,0,0,1,0,1,0,0,1]\\nthe only longest-prefix for last element in s is the first element.\\nIn order to make s a pallindrome, we have to repeat everything else than the longest-prefix for the last element in s.\\nanswer => lps[-1] is 1, so s[1:] is bca, repeat this in reverse for s (as a prefix) to make it a pallindrome.\\ns[1:] = \\'bca\\'\\ns[1:][::-1] = \\'acb\\'\\ns[1:][::-1] + s = \\'acb\\' + \\'abca\\' = \\'acbabca\\'\\n\\n```\\nclass Solution(object):\\n    def shortestPalindrome(self, s):\\n        a = s+\"*\"+s[::-1]\\n        lps = self.getLPS(a)\\n        return s[lps[-1]:][::-1] + s\\n\\n    def getLPS(self, pattern): \\n        m = len(pattern)\\n        lps = [0] * m\\n        i, j = 0, 1\\n\\n        while j < m: \\n            if pattern[i] == pattern[j]: \\n                lps[j] = i + 1\\n                i, j = i+1, j+1\\n            elif i != 0:\\n                i = lps[i - 1]\\n            else:\\n                lps[j] = 0\\n                j += 1\\n        return lps\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def shortestPalindrome(self, s):\\n        a = s+\"*\"+s[::-1]\\n        lps = self.getLPS(a)\\n        return s[lps[-1]:][::-1] + s\\n\\n    def getLPS(self, pattern): \\n        m = len(pattern)\\n        lps = [0] * m\\n        i, j = 0, 1\\n\\n        while j < m: \\n            if pattern[i] == pattern[j]: \\n                lps[j] = i + 1\\n                i, j = i+1, j+1\\n            elif i != 0:\\n                i = lps[i - 1]\\n            else:\\n                lps[j] = 0\\n                j += 1\\n        return lps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 310902,
                "title": "java-recursion-1-ms-faster-than-100-00-35-7-mb-less-than-67-04",
                "content": "```\\nclass Solution {\\n    public String shortestPalindrome(String str) {\\n        int j = 0;\\n        int n = str.length();\\n        char[] c = str.toCharArray();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (c[i] == c[j]) {\\n                ++j;\\n            }\\n        }\\n        if (j == n) {\\n            return str;\\n        }\\n        String suffix = str.substring(j);\\n        String prefix = new StringBuilder(suffix).reverse().toString();\\n        String mid = shortestPalindrome(str.substring(0, j));\\n        return prefix + mid + suffix;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String shortestPalindrome(String str) {\\n        int j = 0;\\n        int n = str.length();\\n        char[] c = str.toCharArray();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (c[i] == c[j]) {\\n                ++j;\\n            }\\n        }\\n        if (j == n) {\\n            return str;\\n        }\\n        String suffix = str.substring(j);\\n        String prefix = new StringBuilder(suffix).reverse().toString();\\n        String mid = shortestPalindrome(str.substring(0, j));\\n        return prefix + mid + suffix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60267,
                "title": "4ms-c-solution-based-on-kmp-with-detailed-comments",
                "content": "    class Solution \\n    {\\n        // The entries of T are constructed so that if we have a match \\n        // starting at s[j] that fails when comparing s[j + i] with W[i], \\n        // then the next possible match will start at index (j + i - T[i]) \\n        // in s (that is, T[i] is the amount of \"backtracking\" we need to \\n        // do after a mismatch).\\n        // W -- the pattern string which is searched for in s.\\n        // T -- the backtrack table.\\n        // m -- the length of W.\\n        void BuildBackTrackTable(string &W, vector<int> &T, int m)\\n        {\\n            // To find T[i], we must discover a proper suffix of W[0,...,(i - 1)]\\n            // which is also a proper prefix of W.\\n            // If s[j] doesn't match W[0], we should jump to s[j + 1].\\n            T[0] = -1;\\n            if (m >= 2)\\n            {\\n                // There is no proper suffix of W[0, 1], so T[1] = 0.\\n                T[1] = 0;\\n                \\n                // Calculate T[i] for 2 <= i <= m - 1.\\n                int pos = 2;\\n                int cnd = 0; // the end character of the proper prefix\\n                while (pos <= m - 1)\\n                {\\n                    if (W[pos - 1] == W[cnd])\\n                    {\\n                        // The new character is equal to the character right \\n                        // after the previous prefix, so we increase the \\n                        // proper prefix by 1 character.\\n                        cnd++;\\n                        T[pos] = cnd;\\n                        pos++;\\n                    }\\n                    else if (cnd > 0)\\n                    {\\n                        // The previous proper prefix can't be prolonged, so \\n                        // we fall back to previous proper prefix.\\n                        cnd = T[cnd];\\n                    }\\n                    else\\n                    {\\n                        // If cnd == 0, i.e., the minimum proper prefix still \\n                        // doesn't work, then set T[pos] to 0.\\n                        T[pos] = 0;\\n                        pos++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n    public:\\n        string shortestPalindrome(string s) \\n        {\\n            int len = s.length();\\n            // If the string length is smaller than 2, the string \\n            // itself is a palindrome.\\n            if (len < 2)\\n            {\\n                return s;\\n            }\\n            \\n            // To find the shortest palindrome, it is equivalent to \\n            // find the longest substring which is a prefix of s and \\n            // also a palindrome. This is essentially a string comparison  \\n            // problem: given a substring, check whether its first half \\n            // is equal to its second half. \\n            // (1) If two halves are equal, we are done.\\n            // (2) If not, we can shrink the substring and do the \\n            // string comparison again. Assume that subLen is the length \\n            // of the substring; s[i] is the first character in the first \\n            // half of the substring which is not equal to the corresponding \\n            // character s[subLen - 1 - i] in the second half of the substring.\\n            // Then the next substring for the palindrome check is the \\n            // prefix of the current substring with length subLen - i + T[i], \\n            // where T[i] is the i-th entry in the backtrack table used \\n            // in the KMP algorithm.\\n    \\n            // 1. Build the backtrack table for the first half of s.\\n            vector<int> T(len/2);\\n            string firstHalf = s.substr(0, len/2);\\n            BuildBackTrackTable(firstHalf, T, len/2);\\n            \\n            // 2. Keep checking whether the substring is a palindrome \\n            // until we find one. Initially the substring is the string \\n            // s itself.\\n            int subLen = len;\\n            int initialI = 0;\\n            int initialJ = subLen - 1;\\n            while (subLen > 1)\\n            {\\n                // Index of the first half of the substring.\\n                int i = initialI; \\n                // Index of the second half of the substring.\\n                int j = initialJ; \\n                bool isPalindrome = false;\\n                while (i < j)\\n                {\\n                    if (s[i] == s[j])\\n                    {\\n                        if ((i + 1 == j) || (i + 2 == j))\\n                        {\\n                            // This is a palindrome.\\n                            isPalindrome = true;\\n                            break;\\n                        }\\n                        else\\n                        {\\n                            // Check next pair of characters.\\n                            i++;\\n                            j--;\\n                        }\\n                    }\\n                    else\\n                    {\\n                        subLen = subLen - i + T[i];\\n                        // The first T[i] characters are the same, so we \\n                        // start the comparison from s[T[i]].\\n                        if (i > 0)\\n                        {\\n                            initialI = T[i];\\n                            initialJ = subLen - 1 - T[i];\\n                        }\\n                        else\\n                        {\\n                            initialI = 0;\\n                            initialJ = subLen - 1;\\n                        }\\n                        \\n                        break;\\n                    }\\n                }\\n                \\n                if (isPalindrome)\\n                {\\n                    break;\\n                }\\n            }\\n            \\n            if (subLen < len)\\n            {\\n                // The string s is not a palindrome and we need to add \\n                // characters in front of it.\\n                string addedPrefix = s.substr(subLen);\\n                reverse(addedPrefix.begin(), addedPrefix.end());\\n                s = addedPrefix + s;\\n            }\\n    \\n            return s;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution \\n    {\\n        // The entries of T are constructed so that if we have a match \\n        // starting at s[j] that fails when comparing s[j + i] with W[i], \\n        // then the next possible match will start at index (j + i - T[i]) \\n        // in s (that is, T[i] is the amount of \"backtracking\" we need to \\n        // do after a mismatch).\\n        // W -- the pattern string which is searched for in s.\\n        // T -- the backtrack table.\\n        // m -- the length of W.\\n        void BuildBackTrackTable(string &W, vector<int> &T, int m)\\n        {\\n            // To find T[i], we must discover a proper suffix of W[0,...,(i - 1)]\\n            // which is also a proper prefix of W.\\n            // If s[j] doesn't match W[0], we should jump to s[j + 1].\\n            T[0] = -1;\\n            if (m >= 2)\\n            {\\n                // There is no proper suffix of W[0, 1], so T[1] = 0.\\n                T[1] = 0;\\n                \\n                // Calculate T[i] for 2 <= i <= m - 1.\\n                int pos = 2;\\n                int cnd = 0; // the end character of the proper prefix\\n                while (pos <= m - 1)\\n                {\\n                    if (W[pos - 1] == W[cnd])\\n                    {\\n                        // The new character is equal to the character right \\n                        // after the previous prefix, so we increase the \\n                        // proper prefix by 1 character.\\n                        cnd++;\\n                        T[pos] = cnd;\\n                        pos++;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2177200,
                "title": "go-o-n-hashmap",
                "content": "```\\nfunc shortestPalindrome(s string) string {\\n    if len(s) < 2 {return s}\\n    \\n    r := 0\\n    longestPalindrome := fmt.Sprintf(\"%c\", s[0])\\n    \\n    var isPalindromic func(string) bool\\n    isPalindromic = func(str string) bool {\\n        if len(s) < 2 {return true}\\n        \\n        l, r := 0, len(str) - 1\\n        \\n        for l < r {\\n            if str[l] != str[r] {\\n                return false\\n            }\\n            \\n            l++\\n            r--\\n        }\\n        \\n        return true\\n    }\\n    \\n    m := make(map[byte][]int)\\n    \\n    for i := 0; i < len(s); i++ {\\n        m[s[i]] = append(m[s[i]], i)\\n        \\n        if len(m[s[i]]) > 1 {\\n            for _, val := range m[s[i]] {\\n                if val == 0 {\\n                    if i != val && isPalindromic(s[val:i+1]) {\\n                        if i - val + 1 > len(longestPalindrome) {\\n                            longestPalindrome = s[val:i+1]\\n                            r = i + 1\\n                        }\\n                    }             \\n                }\\n\\n            }\\n        }\\n    }\\n    \\n    if r == 0 {r = 1}\\n    \\n    for i := r; i < len(s); i++ {\\n        longestPalindrome = fmt.Sprintf(\"%c\", s[i]) + longestPalindrome + fmt.Sprintf(\"%c\", s[i]) \\n    }\\n    \\n    return longestPalindrome\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc shortestPalindrome(s string) string {\\n    if len(s) < 2 {return s}\\n    \\n    r := 0\\n    longestPalindrome := fmt.Sprintf(\"%c\", s[0])\\n    \\n    var isPalindromic func(string) bool\\n    isPalindromic = func(str string) bool {\\n        if len(s) < 2 {return true}\\n        \\n        l, r := 0, len(str) - 1\\n        \\n        for l < r {\\n            if str[l] != str[r] {\\n                return false\\n            }\\n            \\n            l++\\n            r--\\n        }\\n        \\n        return true\\n    }\\n    \\n    m := make(map[byte][]int)\\n    \\n    for i := 0; i < len(s); i++ {\\n        m[s[i]] = append(m[s[i]], i)\\n        \\n        if len(m[s[i]]) > 1 {\\n            for _, val := range m[s[i]] {\\n                if val == 0 {\\n                    if i != val && isPalindromic(s[val:i+1]) {\\n                        if i - val + 1 > len(longestPalindrome) {\\n                            longestPalindrome = s[val:i+1]\\n                            r = i + 1\\n                        }\\n                    }             \\n                }\\n\\n            }\\n        }\\n    }\\n    \\n    if r == 0 {r = 1}\\n    \\n    for i := r; i < len(s); i++ {\\n        longestPalindrome = fmt.Sprintf(\"%c\", s[i]) + longestPalindrome + fmt.Sprintf(\"%c\", s[i]) \\n    }\\n    \\n    return longestPalindrome\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2157206,
                "title": "simple-and-easy-solution-java-code",
                "content": "```\\nclass Solution {\\n    public String shortestPalindrome(String s) {\\n        int i=0; \\n    int j=s.length()-1;\\n \\n    while(j>=0){\\n        if(s.charAt(i)==s.charAt(j)){\\n            i++;\\n        }\\n        j--;\\n    }\\n \\n    if(i==s.length())\\n        return s;\\n \\n    String suffix = s.substring(i);\\n    String prefix = new StringBuilder(suffix).reverse().toString();\\n    String mid = shortestPalindrome(s.substring(0, i));\\n    return prefix+mid+suffix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public String shortestPalindrome(String s) {\\n        int i=0; \\n    int j=s.length()-1;\\n \\n    while(j>=0){\\n        if(s.charAt(i)==s.charAt(j)){\\n            i++;\\n        }\\n        j--;\\n    }\\n \\n    if(i==s.length())\\n        return s;\\n \\n    String suffix = s.substring(i);\\n    String prefix = new StringBuilder(suffix).reverse().toString();\\n    String mid = shortestPalindrome(s.substring(0, i));\\n    return prefix+mid+suffix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 467822,
                "title": "java-kmp-o-n-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic String shortestPalindrome(String s) {\\n\\t\\t\\tint n = s.length();\\n\\t\\t\\tString revS = new StringBuilder().append(s).reverse().toString();\\n\\t\\t\\tString newS = s + \"#\" + revS;\\n\\t\\t\\tint size = newS.length();\\n\\t\\t\\tint[] dp = new int[size];\\n\\t\\t\\tfor (int i = 1; i < size; i++) {\\n\\t\\t\\t\\tint j = dp[i-1];\\n\\t\\t\\t\\twhile(j > 0 && newS.charAt(i)!=newS.charAt(j)) {\\n\\t\\t\\t\\t\\tj = dp[j-1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(newS.charAt(i) == newS.charAt(j)) {\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdp[i] = j;\\n\\t\\t\\t}\\n\\t\\t\\treturn revS.substring(0, n-dp[dp.length-1]) + s;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic String shortestPalindrome(String s) {\\n\\t\\t\\tint n = s.length();\\n\\t\\t\\tString revS = new StringBuilder().append(s).reverse().toString();\\n\\t\\t\\tString newS = s + \"#\" + revS;\\n\\t\\t\\tint size = newS.length();\\n\\t\\t\\tint[] dp = new int[size];\\n\\t\\t\\tfor (int i = 1; i < size; i++) {\\n\\t\\t\\t\\tint j = dp[i-1];\\n\\t\\t\\t\\twhile(j > 0 && newS.charAt(i)!=newS.charAt(j)) {\\n\\t\\t\\t\\t\\tj = dp[j-1];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 60143,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Shortest Palindrome** https://leetcode.com/problems/shortest-palindrome/\\n\\n1. X = \"abcd\". If we reverse X and add it to front of X, we will for sure have a palindrome.\"dcbaabcd\".\\n2. However there may be redundant characters in this palindrome which doesnt make it the shortest. For example: \"dcbabcd\" is a valid palindrome with one less character. Try other examples: s=\"ananab\". rev_s = \"banana\". New Palindrom: \"bananaananab\". Shorter one: \"banananab\" \\n3. The general approach is then: X = PS. P is the longest prefix which is also a palindrome. S is remainder suffix. Thus the new palindrome is: New palindrom = SPS. Implementing above in a naive manner gives you an N^2 algorithm.\\n4. Notice one more thing: X = \"ananab\" and R_X = \"banana\". Longest prefix in X which is a suffix in R_X is \"anana\". Remove that from R_X and we have \"ban\" + \"ananab\" as palindrome.\\n5. KMP can be used to solve  *Longest prefix in X which is a suffix in RX *\\n6. Another interesting idea is to use **startswith** API in Python. s.startswith(rev_s[i:]) and we vary i from 0 to N. This automatically gives us the longest prefix to work with.\\nhttps://discuss.leetcode.com/topic/14542/ac-in-288-ms-simple-brute-force\\n```\\nclass Solution(object):\\n    def shortestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        if s == \"\":\\n            return s\\n        rev_s = s[::-1]\\n        for i in range(len(s)):\\n            if s.startswith(rev_s[i:]):\\n                return rev_s[:i]+s\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def shortestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        if s == \"\":\\n            return s\\n        rev_s = s[::-1]\\n        for i in range(len(s)):\\n            if s.startswith(rev_s[i:]):\\n                return rev_s[:i]+s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60154,
                "title": "no-kmp-simple-easy-to-understand-c",
                "content": "1. Find the longest prefix which is a palindrome\\n2. The remaining characters are the ones which need to be added to the beginning of the original string.\\n\\n```\\npublic class Solution {\\n    public string ShortestPalindrome(string s) {\\n        int offset = LongestPalindromicPrefix(s);\\n        \\n        var builder = new StringBuilder();\\n        for (int i = s.Length - 1; i > offset; --i) {\\n            builder.Append(s[i]);\\n        }\\n        \\n        builder.Append(s);\\n        \\n        return builder.ToString();\\n    }\\n    \\n    // returns the end index of the longest palindromic prefix in s\\n    // e.g. abcde returns 0 ('a'); bcba returns 2 ('b')\\n    private int LongestPalindromicPrefix(string s) {\\n        \\n        int end = s.Length - 1;\\n        \\n        while (end >= 0) {\\n            \\n            if (IsPalindrome(s, 0, end)) {\\n                return end;\\n            }\\n            \\n            --end;\\n        }\\n        \\n        return 0;\\n    }\\n    \\n    private bool IsPalindrome(string s, int begin, int end) {\\n        while (begin < end) {\\n            if (s[begin] != s[end]) {\\n                return false;\\n            }\\n            \\n            ++begin;\\n            --end;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string ShortestPalindrome(string s) {\\n        int offset = LongestPalindromicPrefix(s);\\n        \\n        var builder = new StringBuilder();\\n        for (int i = s.Length - 1; i > offset; --i) {\\n            builder.Append(s[i]);\\n        }\\n        \\n        builder.Append(s);\\n        \\n        return builder.ToString();\\n    }\\n    \\n    // returns the end index of the longest palindromic prefix in s\\n    // e.g. abcde returns 0 ('a'); bcba returns 2 ('b')\\n    private int LongestPalindromicPrefix(string s) {\\n        \\n        int end = s.Length - 1;\\n        \\n        while (end >= 0) {\\n            \\n            if (IsPalindrome(s, 0, end)) {\\n                return end;\\n            }\\n            \\n            --end;\\n        }\\n        \\n        return 0;\\n    }\\n    \\n    private bool IsPalindrome(string s, int begin, int end) {\\n        while (begin < end) {\\n            if (s[begin] != s[end]) {\\n                return false;\\n            }\\n            \\n            ++begin;\\n            --end;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60207,
                "title": "sharing-my-4ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        string shortestPalindrome(string s) {\\n            int n = s.length();\\n            int leftMost=0;\\n            int rightMost=0;\\n            int i=0, start, end;\\n            while(i<n)\\n            {\\n                start = i;\\n                while(s[i]==s[start])\\n                {\\n                    i++;\\n                }\\n                end = i-1;\\n                while(start-1>=0 && end+1<n && s[start-1]==s[end+1])\\n                {\\n                    start--;\\n                    end++;\\n                }\\n                if(start==0 && (end-start) > (rightMost-leftMost))\\n                {\\n                    leftMost = 0;\\n                    rightMost = end;\\n                }\\n            }\\n            \\n            string result;\\n            if(rightMost<n-1)\\n            {\\n                result = s.substr(rightMost+1, n-rightMost);\\n                reverse(result.begin(), result.end());\\n            }\\n            result = result + s;\\n            \\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string shortestPalindrome(string s) {\\n            int n = s.length();\\n            int leftMost=0;\\n            int rightMost=0;\\n            int i=0, start, end;\\n            while(i<n)\\n            {\\n                start = i;\\n                while(s[i]==s[start])\\n                {\\n                    i++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 60233,
                "title": "java-solution-using-manacher-algorithm",
                "content": "This is my solution using [Manacher Algorithm][1].\\n\\nThe Manacher Algorithm is used to find the longest palindromic substring, we can modify it to search to obtain the longest palindromic substring starting at index 0.\\n\\nOnce we have the longest palindrome starting at 0, we insert the remaining characters from the original string 1 by 1 at the head of the original string.\\n\\n\\t\\n\\n        public static String manacherize(String s) {\\n    \\t\\tStringBuilder ms = new StringBuilder(\"^\");\\n    \\t\\tfor(int i=0;i<s.length();i++) {\\n    \\t\\t\\tms.append(\"#\"+s.charAt(i));\\n    \\t\\t}\\n    \\t\\tms.append(\"#$\");\\n    \\t\\treturn ms.toString();\\n    \\t}\\n    \\tpublic static String longestPalindromeStartingFrom0(String s) {\\n    \\t\\tif(s.length()==0) return \"\";\\n    \\t\\tString T = manacherize(s);\\n    \\t\\tint[] P = new int[T.length()];\\n    \\t\\tint C = 0;\\n    \\t\\tint R = 0;\\n    \\t\\tfor(int i=1;i<T.length()-1;i++) {\\n    \\t\\t\\tint imirror = C-(i-C);\\n    \\t\\t\\tP[i] = (R > i) ? Math.min(R-i, P[imirror]) : 0;\\n    \\t\\t\\twhile(T.charAt(i+1+P[i])==T.charAt(i-1-P[i])) {\\n    \\t\\t\\t\\tP[i]++;\\n    \\t\\t\\t}\\n    \\t\\t\\tif(i+P[i]>R) {\\n    \\t\\t\\t\\tC = i;\\n    \\t\\t\\t\\tR = i + P[i];\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tint maxLen = 0;\\n    \\t\\tint maxCenter = 0;\\n    \\t\\tfor(int i=1;i<P.length-1;i++) {\\n    \\t\\t\\tif(P[i]>maxLen && i-P[i]==1) {\\n    \\t\\t\\t\\tmaxLen = P[i];\\n    \\t\\t\\t\\tmaxCenter = i;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tint start = (maxCenter-1-maxLen)/2;\\n    \\t\\treturn s.substring(start,start+maxLen);\\n    \\t}\\n    \\t\\n    \\tpublic static String shortestPalindrome(String s) {\\n    \\t\\tString pal = longestPalindromeStartingFrom0(s);\\n    \\t\\tStringBuilder prefix = new StringBuilder();\\n    \\t\\tfor(int i=pal.length();i<s.length();i++) {\\n    \\t\\t\\tprefix.insert(0, s.charAt(i));\\n    \\t\\t}\\n    \\t\\treturn prefix+s;\\n    \\t}\\n\\n\\n  [1]: http://articles.leetcode.com/2011/11/longest-palindromic-substring-part-ii.html",
                "solutionTags": [],
                "code": "This is my solution using [Manacher Algorithm][1].\\n\\nThe Manacher Algorithm is used to find the longest palindromic substring, we can modify it to search to obtain the longest palindromic substring starting at index 0.\\n\\nOnce we have the longest palindrome starting at 0, we insert the remaining characters from the original string 1 by 1 at the head of the original string.\\n\\n\\t\\n\\n        public static String manacherize(String s) {\\n    \\t\\tStringBuilder ms = new StringBuilder(\"^\");\\n    \\t\\tfor(int i=0;i<s.length();i++) {\\n    \\t\\t\\tms.append(\"#\"+s.charAt(i));\\n    \\t\\t}\\n    \\t\\tms.append(\"#$\");\\n    \\t\\treturn ms.toString();\\n    \\t}\\n    \\tpublic static String longestPalindromeStartingFrom0(String s) {\\n    \\t\\tif(s.length()==0) return \"\";\\n    \\t\\tString T = manacherize(s);\\n    \\t\\tint[] P = new int[T.length()];\\n    \\t\\tint C = 0;\\n    \\t\\tint R = 0;\\n    \\t\\tfor(int i=1;i<T.length()-1;i++) {\\n    \\t\\t\\tint imirror = C-(i-C);\\n    \\t\\t\\tP[i] = (R > i) ? Math.min(R-i, P[imirror]) : 0;\\n    \\t\\t\\twhile(T.charAt(i+1+P[i])==T.charAt(i-1-P[i])) {\\n    \\t\\t\\t\\tP[i]++;\\n    \\t\\t\\t}\\n    \\t\\t\\tif(i+P[i]>R) {\\n    \\t\\t\\t\\tC = i;\\n    \\t\\t\\t\\tR = i + P[i];\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tint maxLen = 0;\\n    \\t\\tint maxCenter = 0;\\n    \\t\\tfor(int i=1;i<P.length-1;i++) {\\n    \\t\\t\\tif(P[i]>maxLen && i-P[i]==1) {\\n    \\t\\t\\t\\tmaxLen = P[i];\\n    \\t\\t\\t\\tmaxCenter = i;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tint start = (maxCenter-1-maxLen)/2;\\n    \\t\\treturn s.substring(start,start+maxLen);\\n    \\t}\\n    \\t\\n    \\tpublic static String shortestPalindrome(String s) {\\n    \\t\\tString pal = longestPalindromeStartingFrom0(s);\\n    \\t\\tStringBuilder prefix = new StringBuilder();\\n    \\t\\tfor(int i=pal.length();i<s.length();i++) {\\n    \\t\\t\\tprefix.insert(0, s.charAt(i));\\n    \\t\\t}\\n    \\t\\treturn prefix+s;\\n    \\t}\\n\\n\\n  [1]: http://articles.leetcode.com/2011/11/longest-palindromic-substring-part-ii.html",
                "codeTag": "Unknown"
            },
            {
                "id": 3252249,
                "title": "shortest-palindrome-c-solution-explained",
                "content": "***Do Upvote If Found Helpful !***\\n\\n# Approach\\nThe problem is quite good and needs pretty good observation. Its obvious that naive approach would not be able to pass. We need some linear time algorithm that can do this work. Now the first hint given is that **we can only insert characters at front of the string**. Thus the end characters are the ones that would come in front in case of any mismatch of palindromes. Now basically we need to find minimum characters to add in front to make string palindrome. We can actually reframe this problem as to find the **longest prefix of the string that is palindromic**. In such case we only need to add **N - maxlen** characters from end of original string to front. Now the naive algorithm would take quadratic time to find this maximum length. Can we do better ? Yes we can using **Knuth Morris Patt or KMP algorithm**. But how do we do it ? So basically we need to find the longest proper prefix that is also suffix. For this purpose, we create a new string, say **t** as **t = s + \"#\" + rev** where **rev** is reverse of string s and **#** is a character that does not appear in s in order to limit the length of **lps** to **N-1**. When we add reverse of string s at back of t, we can see that now the reverse part acts as a suffix which we can easily check for equality using KMP. Implementation of the above algorithm goes below.\\n\\n# Complexity\\n- Time complexity: **O(N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(N)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s) {\\n        ios_base::sync_with_stdio(0);\\n        string rev = s;\\n        reverse(rev.begin(),rev.end());\\n        int n = s.size();\\n        s = s + \"#\" + rev;\\n        vector<int>lps(2*n+1,0);\\n        for(int i = 1; i <= 2*n; i++){\\n            int j = lps[i-1];\\n            while(j > 0 && s[i] != s[j]){\\n                j = lps[j-1];\\n            }\\n            if(s[i] == s[j]){\\n                j++;\\n            }\\n            lps[i] = j;\\n        }\\n        int diff = n - lps[2*n];\\n        while(diff){\\n            rev.push_back(rev[diff-1]);\\n            diff--;\\n        }\\n        return rev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s) {\\n        ios_base::sync_with_stdio(0);\\n        string rev = s;\\n        reverse(rev.begin(),rev.end());\\n        int n = s.size();\\n        s = s + \"#\" + rev;\\n        vector<int>lps(2*n+1,0);\\n        for(int i = 1; i <= 2*n; i++){\\n            int j = lps[i-1];\\n            while(j > 0 && s[i] != s[j]){\\n                j = lps[j-1];\\n            }\\n            if(s[i] == s[j]){\\n                j++;\\n            }\\n            lps[i] = j;\\n        }\\n        int diff = n - lps[2*n];\\n        while(diff){\\n            rev.push_back(rev[diff-1]);\\n            diff--;\\n        }\\n        return rev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048217,
                "title": "i-don-t-think-this-problem-needs-to-be-marked-as-hard",
                "content": "```\\nclass Solution:\\n    def shortestPalindrome(self, s: str) -> str:\\n        longest_palin_idx = 0\\n        s1 = \\'\\'\\n        s2 = \\'\\'\\n        for i, c in enumerate(s):\\n            s1 = s1 + c\\n            s2 = c + s2\\n            \\n            if s1 == s2:\\n                longest_palin_idx = i\\n        \\n        return \\'\\'.join(reversed(s[longest_palin_idx+1:])) + s\\n```\\n\\nSame approach can be used to solve https://leetcode.com/problems/longest-palindromic-substring/\\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        lps = \\'\\'\\n        for i in range(len(s)):\\n            s1 = \\'\\'\\n            s2 = \\'\\'\\n            for j in range(i, len(s)):\\n                s1 += s[j]\\n                s2 = s[j] + s2\\n                \\n                if s1 == s2 and len(lps)<len(s1):\\n                    lps = s1\\n                \\n        return lps\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def shortestPalindrome(self, s: str) -> str:\\n        longest_palin_idx = 0\\n        s1 = \\'\\'\\n        s2 = \\'\\'\\n        for i, c in enumerate(s):\\n            s1 = s1 + c\\n            s2 = c + s2\\n            \\n            if s1 == s2:\\n                longest_palin_idx = i\\n        \\n        return \\'\\'.join(reversed(s[longest_palin_idx+1:])) + s\\n```\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        lps = \\'\\'\\n        for i in range(len(s)):\\n            s1 = \\'\\'\\n            s2 = \\'\\'\\n            for j in range(i, len(s)):\\n                s1 += s[j]\\n                s2 = s[j] + s2\\n                \\n                if s1 == s2 and len(lps)<len(s1):\\n                    lps = s1\\n                \\n        return lps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403224,
                "title": "python-o-n-solution-using-kmp",
                "content": "Idea: Using the idea of Longest prefix suffix of KMP algorithm.\\n```\\n\\'\\'\\'\\n    Time Complexity: O(n)\\n    Space Complexity: O(n)\\n\\'\\'\\'\\nclass Solution:\\n    def shortestPalindrome(self, s: str) -> str:\\n        lth, i, n = 0, 1, len(s)\\n        if n == 0:\\n            return s\\n        s1, lps = s + \\'#\\' + s[::-1], [0] * (2 * n)\\n        while i < 2 * n:\\n            if s1[lth] == s1[i]:\\n                lth += 1\\n                lps[i] = lth\\n                i += 1\\n            elif lth > 0:\\n                lth = lps[lth - 1]\\n            else:\\n                i += 1\\n        return s[-1:lps[2 * n - 1]:-1] + s\\n```\\n**PS: Please upvote if you liked the solution.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\'\\'\\'\\n    Time Complexity: O(n)\\n    Space Complexity: O(n)\\n\\'\\'\\'\\nclass Solution:\\n    def shortestPalindrome(self, s: str) -> str:\\n        lth, i, n = 0, 1, len(s)\\n        if n == 0:\\n            return s\\n        s1, lps = s + \\'#\\' + s[::-1], [0] * (2 * n)\\n        while i < 2 * n:\\n            if s1[lth] == s1[i]:\\n                lth += 1\\n                lps[i] = lth\\n                i += 1\\n            elif lth > 0:\\n                lth = lps[lth - 1]\\n            else:\\n                i += 1\\n        return s[-1:lps[2 * n - 1]:-1] + s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 976752,
                "title": "python-knuth-morris-pratt",
                "content": "Before we can use KMP on this problem we have to transform the intput string into `new_s` as done in the code below. Then we can run KMP on it to find the longest prefix that is a suffix in the reversed string. After that we prepend the remaining characters from the front of the reversed string to the original one and return the answer:\\n```\\ndef shortestPalindrome(self, s: str) -> str:\\n\\tN = len(s)\\n\\trev_s = s[::-1]\\n\\tnew_s = s + \\'*\\' + rev_s\\n\\n\\tdp = [0] * len(new_s)\\n\\n\\tfor i in range(1, len(new_s)):\\n\\t\\tj = dp[i-1]\\n\\t\\twhile j > 0 and new_s[j] != new_s[i]:\\n\\t\\t\\tj = dp[j-1]\\n\\t\\tif new_s[i] == new_s[j]:\\n\\t\\t\\tdp[i] = j+1\\n\\n\\treturn rev_s[:N-dp[-1]] + s\\n```\\n\\nNice video (not mine) explaining how KMP works:\\nhttps://www.youtube.com/watch?v=BXCEFAzhxGY",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef shortestPalindrome(self, s: str) -> str:\\n\\tN = len(s)\\n\\trev_s = s[::-1]\\n\\tnew_s = s + \\'*\\' + rev_s\\n\\n\\tdp = [0] * len(new_s)\\n\\n\\tfor i in range(1, len(new_s)):\\n\\t\\tj = dp[i-1]\\n\\t\\twhile j > 0 and new_s[j] != new_s[i]:\\n\\t\\t\\tj = dp[j-1]\\n\\t\\tif new_s[i] == new_s[j]:\\n\\t\\t\\tdp[i] = j+1\\n\\n\\treturn rev_s[:N-dp[-1]] + s\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 584236,
                "title": "c-rolling-hash",
                "content": "```c++\\nclass Solution {\\n    const int M = INT_MAX;\\n    const int Base = 26;\\n    \\n    int code(char c) {\\n        return c - \\'a\\';\\n    }\\n    \\npublic:\\n    string shortestPalindrome(string s) {\\n        const int N = s.size();\\n        if (N == 0) return s;\\n        \\n        long h = 0;\\n        long rh = 0;\\n        long P = 1;\\n        int pos = -1;\\n        for (int i = 0; i < N; ++i) {\\n            h = (h * Base + code(s[i])) % M;\\n            rh = (rh + code(s[i]) * P) % M;\\n            if (h == rh) {\\n\\t\\t\\t    // explain to the interviewer: \\n\\t\\t\\t\\t// this is how you would avoid false positives due to hash collisions\\n\\t\\t\\t    // && rev.substr(i + 1) == s.substr(0, j)) {\\n                pos = i;\\n            }\\n            \\n            P = (P * Base) % M;\\n        }\\n        \\n        string prefix = s.substr(pos + 1);\\n        reverse(prefix.begin(), prefix.end());\\n        return prefix + s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\n    const int M = INT_MAX;\\n    const int Base = 26;\\n    \\n    int code(char c) {\\n        return c - \\'a\\';\\n    }\\n    \\npublic:\\n    string shortestPalindrome(string s) {\\n        const int N = s.size();\\n        if (N == 0) return s;\\n        \\n        long h = 0;\\n        long rh = 0;\\n        long P = 1;\\n        int pos = -1;\\n        for (int i = 0; i < N; ++i) {\\n            h = (h * Base + code(s[i])) % M;\\n            rh = (rh + code(s[i]) * P) % M;\\n            if (h == rh) {\\n\\t\\t\\t    // explain to the interviewer: \\n\\t\\t\\t\\t// this is how you would avoid false positives due to hash collisions\\n\\t\\t\\t    // && rev.substr(i + 1) == s.substr(0, j)) {\\n                pos = i;\\n            }\\n            \\n            P = (P * Base) % M;\\n        }\\n        \\n        string prefix = s.substr(pos + 1);\\n        reverse(prefix.begin(), prefix.end());\\n        return prefix + s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60191,
                "title": "share-my-easy-ac-python-solution-without-fancy-algorithm",
                "content": "    class Solution(object):\\n    def shortestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        s2 = s[::-1]\\n        n = len(s)\\n        final_index = 0\\n        for i in xrange(n):\\n            if s[:n-i] == s2[i:]:\\n                final_index = i\\n                break\\n        \\n        return s2[:final_index]+s\\n\\nTo avoid TLE, reverse s first and then just compare the substring. I think this is the easiest acceptable way.",
                "solutionTags": [],
                "code": "    class Solution(object):\\n    def shortestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        s2 = s[::-1]\\n        n = len(s)\\n        final_index = 0\\n        for i in xrange(n):\\n            if s[:n-i] == s2[i:]:\\n                final_index = i\\n                break\\n        \\n        return s2[:final_index]+s\\n\\nTo avoid TLE, reverse s first and then just compare the substring. I think this is the easiest acceptable way.",
                "codeTag": "Java"
            },
            {
                "id": 60236,
                "title": "using-longest-palindrome",
                "content": "        public String shortestPalindrome(String s) {\\n            if (s == null || s.length() <= 1) return s;\\n            // find the longest palin beginning at the left\\n            int l = s.length();\\n            int maxL = 0;\\n            for(int i = 0; i <= l /2 ; i++) {\\n                maxL = Math.max(maxL, Math.max(expand(s, i, false),expand(s, i, true)));\\n            }\\n            // use maxL as point\\n            String suffix = s.substring(maxL+1);\\n            return new StringBuffer(suffix).reverse().toString() + s.substring(0, maxL+1) + suffix;\\n        }\\n        \\n        // return the end index if the palin starts at beginning\\n        private int expand(String s, int i, boolean isCenter) {\\n            int j = isCenter? i: i+1;\\n            while(i >=0 && j < s.length() && s.charAt(i) == s.charAt(j)){\\n                i--;\\n                j++;\\n            }\\n            // only return if goes to the start\\n            if (i < 0 ) return --j;\\n            return -1;\\n        }",
                "solutionTags": [],
                "code": "        public String shortestPalindrome(String s) {\\n            if (s == null || s.length() <= 1) return s;\\n            // find the longest palin beginning at the left\\n            int l = s.length();\\n            int maxL = 0;\\n            for(int i = 0; i <= l /2 ; i++) {\\n                maxL = Math.max(maxL, Math.max(expand(s, i, false),expand(s, i, true)));\\n            }\\n            // use maxL as point\\n            String suffix = s.substring(maxL+1);\\n            return new StringBuffer(suffix).reverse().toString() + s.substring(0, maxL+1) + suffix;\\n        }\\n        \\n        // return the end index if the palin starts at beginning\\n        private int expand(String s, int i, boolean isCenter) {\\n            int j = isCenter? i: i+1;\\n            while(i >=0 && j < s.length() && s.charAt(i) == s.charAt(j)){\\n                i--;\\n                j++;\\n            }\\n            // only return if goes to the start\\n            if (i < 0 ) return --j;\\n            return -1;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3390712,
                "title": "shortest-palindrome-easy-approach-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s) \\n    {\\n        if(s.empty())\\n        {\\n            return \"\";\\n        }\\n        int ans = 0;\\n        int start = 0;\\n        int end = s.size()-1;\\n        int i = 0;\\n        int j = end;\\n        while(i<j)\\n        {\\n            i = start;\\n            j = end-ans;\\n\\n            while(s[i] != s[j])\\n            {\\n                ans++;\\n                j--;\\n            }\\n            if(s[i]==s[j])\\n            {\\n                while(s[i]==s[j] and i<j)\\n                {\\n                    i++;\\n                    j--;\\n                }\\n            }\\n            if(i<j)\\n            {\\n                ans++;\\n            }\\n\\n        }\\n        int m = s.size()-ans;\\n        string su = s.substr(m,ans);\\n        reverse(su.begin(),su.end());\\n        return su+s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s) \\n    {\\n        if(s.empty())\\n        {\\n            return \"\";\\n        }\\n        int ans = 0;\\n        int start = 0;\\n        int end = s.size()-1;\\n        int i = 0;\\n        int j = end;\\n        while(i<j)\\n        {\\n            i = start;\\n            j = end-ans;\\n\\n            while(s[i] != s[j])\\n            {\\n                ans++;\\n                j--;\\n            }\\n            if(s[i]==s[j])\\n            {\\n                while(s[i]==s[j] and i<j)\\n                {\\n                    i++;\\n                    j--;\\n                }\\n            }\\n            if(i<j)\\n            {\\n                ans++;\\n            }\\n\\n        }\\n        int m = s.size()-ans;\\n        string su = s.substr(m,ans);\\n        reverse(su.begin(),su.end());\\n        return su+s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549654,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using LPS ARRAY***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // function for finding lps array\\n    \\n    int find_lps(string str)\\n    {\\n        int n = str.size();\\n    \\n        vector<int> lps(n, 0);\\n    \\n        int i = 1;\\n    \\n        int j = 0;\\n    \\n        while(i < n)\\n        {\\n            if(str[i] == str[j])\\n            {\\n                lps[i] = j + 1;\\n            \\n                j++;\\n            \\n                i++;\\n            }\\n            else\\n            {\\n                if(j == 0)\\n                {\\n                    lps[i] = 0;\\n                \\n                    i++;\\n                }\\n                else\\n                {\\n                    j = lps[j - 1];\\n                }\\n            }\\n        }\\n    \\n        return lps[n - 1];\\n    }\\n    \\n    string shortestPalindrome(string str) {\\n        \\n        int n = str.size();\\n        \\n        string rev = str;\\n        \\n        reverse(rev.begin(), rev.end());\\n        \\n        // find lps\\n        \\n        int lps = find_lps(str + \"#\" + rev);\\n        \\n        // find the characters that must be appended\\n        \\n        string append = str.substr(lps);\\n        \\n        reverse(append.begin(), append.end());\\n        \\n        return append + str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // function for finding lps array\\n    \\n    int find_lps(string str)\\n    {\\n        int n = str.size();\\n    \\n        vector<int> lps(n, 0);\\n    \\n        int i = 1;\\n    \\n        int j = 0;\\n    \\n        while(i < n)\\n        {\\n            if(str[i] == str[j])\\n            {\\n                lps[i] = j + 1;\\n            \\n                j++;\\n            \\n                i++;\\n            }\\n            else\\n            {\\n                if(j == 0)\\n                {\\n                    lps[i] = 0;\\n                \\n                    i++;\\n                }\\n                else\\n                {\\n                    j = lps[j - 1];\\n                }\\n            }\\n        }\\n    \\n        return lps[n - 1];\\n    }\\n    \\n    string shortestPalindrome(string str) {\\n        \\n        int n = str.size();\\n        \\n        string rev = str;\\n        \\n        reverse(rev.begin(), rev.end());\\n        \\n        // find lps\\n        \\n        int lps = find_lps(str + \"#\" + rev);\\n        \\n        // find the characters that must be appended\\n        \\n        string append = str.substr(lps);\\n        \\n        reverse(append.begin(), append.end());\\n        \\n        return append + str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2513124,
                "title": "shortest-and-easiest-solution-in-python",
                "content": "\\n        for i in range(len(s)-1,-1,-1):\\n            a = s[:i+1]\\n            b = a[::-1]\\n            if a==b:\\n                c = s[i+1:]\\n                c = c[::-1]\\n                return c+a+c[::-1]\\n        s1 = s[1:]\\n        s = s1[::-1] + s\\n        return s",
                "solutionTags": [],
                "code": "\\n        for i in range(len(s)-1,-1,-1):\\n            a = s[:i+1]\\n            b = a[::-1]\\n            if a==b:\\n                c = s[i+1:]\\n                c = c[::-1]\\n                return c+a+c[::-1]\\n        s1 = s[1:]\\n        s = s1[::-1] + s\\n        return s",
                "codeTag": "Unknown"
            },
            {
                "id": 2157861,
                "title": "no-dp-no-ds-intuitive-with-comments-python",
                "content": "This solution is very intuitive.\\n\\nCase 1: \\nThe given string is a palindrome; return the string itself.\\n\\nCase 2:\\nFind the longest palindromic substring that starts from the first character of the given string. \\nThen reverse the remaining part of the string and add it to the front.\\n\\nTake a look at the code below:\\n\\n```\\nclass Solution:\\n    def shortestPalindrome(self, s: str) -> str:\\n        \\n        end = 0\\n        \\n        # if the string itself is a palindrome return it\\n        if(s == s[::-1]):\\n            return s\\n        \\n        # Otherwise find the end index of the longest palindrome that starts\\n        # from the first character of the string\\n        \\n        for i in range(len(s)+1):\\n            if(s[:i]==s[:i][::-1]):\\n                end=i-1\\n        \\n        # return the string with the remaining characters other than\\n        # the palindrome reversed and added at the beginning\\n        \\n        return (s[end+1:][::-1])+s\\n```\\n\\nUpvote if you found it hepful",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestPalindrome(self, s: str) -> str:\\n        \\n        end = 0\\n        \\n        # if the string itself is a palindrome return it\\n        if(s == s[::-1]):\\n            return s\\n        \\n        # Otherwise find the end index of the longest palindrome that starts\\n        # from the first character of the string\\n        \\n        for i in range(len(s)+1):\\n            if(s[:i]==s[:i][::-1]):\\n                end=i-1\\n        \\n        # return the string with the remaining characters other than\\n        # the palindrome reversed and added at the beginning\\n        \\n        return (s[end+1:][::-1])+s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2148383,
                "title": "c-kmp-algorithm",
                "content": "```\\nclass Solution {\\nprivate:\\n    // using kmp algorithm\\n    int find_lps(string str) {\\n        int n = str.length();\\n        vector<int> lps(n, 0);\\n        \\n        int len = 0, i = 1;\\n        while(i < n) {\\n            if(str[len] == str[i]) {\\n                lps[i++] = ++len;\\n            } else {\\n                if(len != 0)\\n                    len = lps[len-1];\\n                else \\n                    lps[i++] = 0;\\n            }\\n        }\\n        \\n        return lps[n-1];\\n    }\\n    \\npublic:\\n    string shortestPalindrome(string str) {\\n        string rev = str;\\n        reverse(rev.rbegin(), rev.rend());\\n        \\n        // \"#\" icluded for case like: aaaa#aaaa\\n        // max length of palindrom we can keep from the string itself \\n        int len = find_lps(str + \"#\" + rev);\\n        \\n        return rev.substr(0, rev.length()-len) + str;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    // using kmp algorithm\\n    int find_lps(string str) {\\n        int n = str.length();\\n        vector<int> lps(n, 0);\\n        \\n        int len = 0, i = 1;\\n        while(i < n) {\\n            if(str[len] == str[i]) {\\n                lps[i++] = ++len;\\n            } else {\\n                if(len != 0)\\n                    len = lps[len-1];\\n                else \\n                    lps[i++] = 0;\\n            }\\n        }\\n        \\n        return lps[n-1];\\n    }\\n    \\npublic:\\n    string shortestPalindrome(string str) {\\n        string rev = str;\\n        reverse(rev.rbegin(), rev.rend());\\n        \\n        // \"#\" icluded for case like: aaaa#aaaa\\n        // max length of palindrom we can keep from the string itself \\n        int len = find_lps(str + \"#\" + rev);\\n        \\n        return rev.substr(0, rev.length()-len) + str;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1743672,
                "title": "magic-of-prefix-function",
                "content": "**Idea?**\\n* We need to find shortest string which is palindrome, by appending characters at beginning.\\n* We\\'ll append only those characters which are already present at the back of string s.\\n* So, we need to find **longest prefix which is palindrome(say L)**\\n* **Our answer will be rev(substr[L,n] + s)**.\\n* We can find the longest prefix which is a palindrome using prefix function in linear time.\\n\\n```\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s) {\\n        int n = s.length();\\n        \\n        string str = s + \"#\";\\n        reverse(s.begin(),s.end());\\n        \\n        str += s;\\n        reverse(s.begin(),s.end());\\n        \\n        int m = str.length();\\n        vector<int> lps(m);\\n        \\n        for(int i=1;i<m;i++){\\n            int j = lps[i-1];\\n            while(j>0 and str[i]!=str[j]){\\n                j = lps[j-1];\\n            }\\n            \\n            if(str[i]==str[j])\\n                j++;\\n            \\n            lps[i] = j;\\n        }\\n        \\n        int L = lps.back(); // largest prefix which is palindrome\\n        string ans = s.substr(L);\\n        \\n        reverse(ans.begin(),ans.end());\\n        \\n        ans += s;\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Don\\'t Forget to Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s) {\\n        int n = s.length();\\n        \\n        string str = s + \"#\";\\n        reverse(s.begin(),s.end());\\n        \\n        str += s;\\n        reverse(s.begin(),s.end());\\n        \\n        int m = str.length();\\n        vector<int> lps(m);\\n        \\n        for(int i=1;i<m;i++){\\n            int j = lps[i-1];\\n            while(j>0 and str[i]!=str[j]){\\n                j = lps[j-1];\\n            }\\n            \\n            if(str[i]==str[j])\\n                j++;\\n            \\n            lps[i] = j;\\n        }\\n        \\n        int L = lps.back(); // largest prefix which is palindrome\\n        string ans = s.substr(L);\\n        \\n        reverse(ans.begin(),ans.end());\\n        \\n        ans += s;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1516256,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar shortestPalindrome = function(s) {\\n    const reverseString = s.split(\\'\\').reverse().join(\\'\\');\\n    const length = s.length;\\n    \\n    for (let i = 0; i < length; i++) {\\n        if (s.slice(0, length - i) === reverseString.slice(i)) {\\n            return `${reverseString.slice(0, i)}${s}`;\\n        }\\n    }\\n    \\n    return \\'\\';\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar shortestPalindrome = function(s) {\\n    const reverseString = s.split(\\'\\').reverse().join(\\'\\');\\n    const length = s.length;\\n    \\n    for (let i = 0; i < length; i++) {\\n        if (s.slice(0, length - i) === reverseString.slice(i)) {\\n            return `${reverseString.slice(0, i)}${s}`;\\n        }\\n    }\\n    \\n    return \\'\\';\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1506682,
                "title": "3ms-solution-beats-92-73-of-submission",
                "content": "\"\\'\\n\\n\\n       \\n       \\n        //Longest palindrome starting from index 0 - concept\\n\\tclass Solution {\\n\\t\\tpublic String shortestPalindrome(String s) {\\n\\t\\t int n = s.length();\\n        StringBuilder sb =new StringBuilder(String.valueOf(s)); \\n        StringBuilder str =new StringBuilder();\\n        str.append(sb);\\n        str.append(\"#\");\\n        str.append(sb.reverse());\\n        int LPS[] = new int[str.length()];  //Longest proper prefix which is also suffix.\\n        computeLPS(LPS,str);\\n        \\n        int lenLP = LPS[LPS.length - 1]; //length of Longest Palindrome starting at index 0\\n        StringBuilder ros = new StringBuilder(s.substring(lenLP));  \\n        ros = ros.reverse();\\n        return (ros + s).toString();\\n        \\n    }\\n    \\n    public void computeLPS(int LPS[], StringBuilder s)\\n    {\\n        int n = s.length();\\n        int i=1,len = 0;\\n        while(i < n){\\n            if(s.charAt(i) == s.charAt(len)) LPS[i++] = ++len;\\n            else if(len == 0) i++;\\n            else len = LPS[len - 1];\\n        }\\n    }\\n}\\n\"\\'",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic String shortestPalindrome(String s) {\\n\\t\\t int n = s.length();\\n        StringBuilder sb =new StringBuilder(String.valueOf(s)); \\n        StringBuilder str =new StringBuilder();\\n        str.append(sb);\\n        str.append(\"#\");\\n        str.append(sb.reverse());\\n        int LPS[] = new int[str.length()];  //Longest proper prefix which is also suffix.\\n        computeLPS(LPS,str);\\n        \\n        int lenLP = LPS[LPS.length - 1]; //length of Longest Palindrome starting at index 0\\n        StringBuilder ros = new StringBuilder(s.substring(lenLP));  \\n        ros = ros.reverse();\\n        return (ros + s).toString();\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1336295,
                "title": "a-few-lines-of-code-in-python",
                "content": "```class Solution:\\n    def shortestPalindrome(self, s: str) -> str:\\n        s=list(s)\\n        x=len(s)\\n        if x<=1 or s==s[::-1]:\\n            return \"\".join(s)\\n        for j in range(0,x):\\n            s.insert(j,s[x-1])\\n            if s==s[::-1]:\\n                return \"\".join(s)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```class Solution:\\n    def shortestPalindrome(self, s: str) -> str:\\n        s=list(s)\\n        x=len(s)\\n        if x<=1 or s==s[::-1]:\\n            return \"\".join(s)\\n        for j in range(0,x):\\n            s.insert(j,s[x-1])\\n            if s==s[::-1]:\\n                return \"\".join(s)\\n",
                "codeTag": "Java"
            },
            {
                "id": 1090659,
                "title": "c-kmp-algorithm-with-explanation",
                "content": "```\\n    /*\\n     * Algorithm used is KMP - knath, Morris, Pratt algorithm\\n     * Eg: abab  -> rev is baba\\n     *   add it at end such that it becomes ababbaba, this is palindrome but the solution should\\n     *   be smallest, so need to find the proper suffix in reverse string that matches the\\n     *   proper suffix of input string and needs to be evaluated from the reverse string and\\n     *   insert remaining at the front of ip string.\\n     * \\n     * proper suffix or proper prefix of a string is not equal to the string itself\\n     * proper suffixes of reverse string baba are -    a,   ba,  aba,\\n     * proper prefixes of iput string abab are - a   , ab  , aba ,\\n     * From above it is clearly seen that longest proper suffix that matches prefix are aba,\\n     * so the result is\\n     *   removal of the length of the common prefix sufix substring + ip string ie...\\n     *       b + abab => babab\\n     *\\n     * In short it goes in following steps\\n     * 1. generate reverse of ip string\\n     * 2. s + rev_s\\n     * 3. Find the longest suffix of the appended string that is also prefix of the appended string\\n     * 4. (rev_s - largest suffix) + ip string\\n     *\\n     * For step 3, KMP lookup table needs to be generated, in order to generate the KMP lookup the\\n     * string shouldn\\'t overlap so step 2 becomes s + \\'#\\' + rev_s  # is used in order for the strings\\n     * not to overlap. Without #, the stirngs could mix eachother and produce wrong results.\\n     * for eg: if ip is aaaa, then rev string also aaaa and appended string is aaaaaa. The longest\\n     * would be of length 7 which is wrong, so a delimetter is added in between.\\n    */\\n    string shortestPalindrome(string s) {\\n        // Base case - If string is empty return\\n        if (s.empty())\\n            return s;\\n\\n        // step 1: generate reverse of ip string\\n        string rev_s(s.rbegin(), s.rend());\\n\\n        // step 2: Append the ip and reverse strings\\n        // # delimiter is used for the string not to overlap and not to produce wrong results\\n        string a_s = s + \\'#\\' + rev_s;\\n\\n        // step 3: Find the longest suffix that is also a prefix.\\n        // array to store the longest suffix\\n       int lookup[a_s.length()];\\n\\n        // Generate the kMP loop table that calculates the longest suffix that is also a prefix\\n        int i = 0;\\n        // There won\\'t be any proper suffix at index 0, so\\n        lookup[0] = 0;\\n\\n        // As index 0 is done, proceed to generate the table form index 1\\n        for (int j = 1; j < a_s.length();) {\\n            if (a_s[i] == a_s[j]) {\\n                // If chars at i and j are matching, then there is a prefix that matching the suffix\\n                // store the i + 1 at j and procced further\\n                lookup[j] = ++i;\\n                j++;\\n            }\\n            else {\\n                // If the char doesn\\'t match, then if i > 0, then contents at i -1 will be i and\\n                // should compare with contents of s[j]\\n                i > 0 ? (i = lookup[i - 1]) : (lookup[j++] = 0);\\n            }\\n        }\\n\\n        // step 4: generate the shortest palindrome\\n        return rev_s.substr(0, rev_s.length() - lookup[a_s.length()-1]) + s;\\n    }\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Shortest Palindrome.\\nMemory Usage: 7.8 MB, less than 59.76% of C++ online submissions for Shortest Palindrome.\\t\\n```",
                "solutionTags": [],
                "code": "```\\n    /*\\n     * Algorithm used is KMP - knath, Morris, Pratt algorithm\\n     * Eg: abab  -> rev is baba\\n     *   add it at end such that it becomes ababbaba, this is palindrome but the solution should\\n     *   be smallest, so need to find the proper suffix in reverse string that matches the\\n     *   proper suffix of input string and needs to be evaluated from the reverse string and\\n     *   insert remaining at the front of ip string.\\n     * \\n     * proper suffix or proper prefix of a string is not equal to the string itself\\n     * proper suffixes of reverse string baba are -    a,   ba,  aba,\\n     * proper prefixes of iput string abab are - a   , ab  , aba ,\\n     * From above it is clearly seen that longest proper suffix that matches prefix are aba,\\n     * so the result is\\n     *   removal of the length of the common prefix sufix substring + ip string ie...\\n     *       b + abab => babab\\n     *\\n     * In short it goes in following steps\\n     * 1. generate reverse of ip string\\n     * 2. s + rev_s\\n     * 3. Find the longest suffix of the appended string that is also prefix of the appended string\\n     * 4. (rev_s - largest suffix) + ip string\\n     *\\n     * For step 3, KMP lookup table needs to be generated, in order to generate the KMP lookup the\\n     * string shouldn\\'t overlap so step 2 becomes s + \\'#\\' + rev_s  # is used in order for the strings\\n     * not to overlap. Without #, the stirngs could mix eachother and produce wrong results.\\n     * for eg: if ip is aaaa, then rev string also aaaa and appended string is aaaaaa. The longest\\n     * would be of length 7 which is wrong, so a delimetter is added in between.\\n    */\\n    string shortestPalindrome(string s) {\\n        // Base case - If string is empty return\\n        if (s.empty())\\n            return s;\\n\\n        // step 1: generate reverse of ip string\\n        string rev_s(s.rbegin(), s.rend());\\n\\n        // step 2: Append the ip and reverse strings\\n        // # delimiter is used for the string not to overlap and not to produce wrong results\\n        string a_s = s + \\'#\\' + rev_s;\\n\\n        // step 3: Find the longest suffix that is also a prefix.\\n        // array to store the longest suffix\\n       int lookup[a_s.length()];\\n\\n        // Generate the kMP loop table that calculates the longest suffix that is also a prefix\\n        int i = 0;\\n        // There won\\'t be any proper suffix at index 0, so\\n        lookup[0] = 0;\\n\\n        // As index 0 is done, proceed to generate the table form index 1\\n        for (int j = 1; j < a_s.length();) {\\n            if (a_s[i] == a_s[j]) {\\n                // If chars at i and j are matching, then there is a prefix that matching the suffix\\n                // store the i + 1 at j and procced further\\n                lookup[j] = ++i;\\n                j++;\\n            }\\n            else {\\n                // If the char doesn\\'t match, then if i > 0, then contents at i -1 will be i and\\n                // should compare with contents of s[j]\\n                i > 0 ? (i = lookup[i - 1]) : (lookup[j++] = 0);\\n            }\\n        }\\n\\n        // step 4: generate the shortest palindrome\\n        return rev_s.substr(0, rev_s.length() - lookup[a_s.length()-1]) + s;\\n    }\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Shortest Palindrome.\\nMemory Usage: 7.8 MB, less than 59.76% of C++ online submissions for Shortest Palindrome.\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 785914,
                "title": "brute-force-javascript-solution-easy-to-read",
                "content": "```\\nvar shortestPalindrome = function(s) {\\n    let n = s.length\\n    let rev = s.split(\"\").reverse().join(\"\")\\n    \\n    for(let i=0; i< n; i++){\\n        if(s.substring(0, n-i) === rev.substring(i)){\\n            return rev.substr(0, i) + s\\n        }\\n    }\\n    \\n    return \\'\\'\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shortestPalindrome = function(s) {\\n    let n = s.length\\n    let rev = s.split(\"\").reverse().join(\"\")\\n    \\n    for(let i=0; i< n; i++){\\n        if(s.substring(0, n-i) === rev.substring(i)){\\n            return rev.substr(0, i) + s\\n        }\\n    }\\n    \\n    return \\'\\'\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 728240,
                "title": "python-constant-space-with-prefix-space-o-n-linear-time-complexity-solution-using-averages",
                "content": "hey, people, I\\'ve come up with a solution which I think is unique.\\nAs this solution uses a dictionary with lowercase alphabets as keys with value as an array of size 2, hence I believe that this uses Constant space barring the prefix to be added.\\n\\n```\\nclass Average:\\n    def __init__(self):\\n        self.sum = 0\\n        self.count = 0\\n\\n    def add(self, val):\\n        self.sum += val\\n        self.count += 1\\n\\n    def average(self):\\n        return self.sum/self.count\\n\\nclass Solution:\\n    def shortestPalindrome(self, s: str) -> str:\\n        char_position_averages = defaultdict(Average)\\n        end_i = 0\\n        for i in range(len(s)):\\n            char_position_averages[s[i]].add(i)\\n            if s[i] == s[0] and all(each.average() == i/2 for each in char_position_averages.values()):\\n                end_i = i+1\\n\\n        return \\'\\'.join(reversed(s[end_i:])) + s\\n```\\nit is based on the observation that the average of all the indices for each alphabet should be equal to the average of start and end indices ie. (start+end)/2, Here start=0 and i=end so required average (req_mid) becomes i/d2\\nnow, for each end_i we may perform 26 comparisons at max, hence the Time complexity is O(26*n) => O(n)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Average:\\n    def __init__(self):\\n        self.sum = 0\\n        self.count = 0\\n\\n    def add(self, val):\\n        self.sum += val\\n        self.count += 1\\n\\n    def average(self):\\n        return self.sum/self.count\\n\\nclass Solution:\\n    def shortestPalindrome(self, s: str) -> str:\\n        char_position_averages = defaultdict(Average)\\n        end_i = 0\\n        for i in range(len(s)):\\n            char_position_averages[s[i]].add(i)\\n            if s[i] == s[0] and all(each.average() == i/2 for each in char_position_averages.values()):\\n                end_i = i+1\\n\\n        return \\'\\'.join(reversed(s[end_i:])) + s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697634,
                "title": "python-3-iterative-expanding-o-n-2-time-o-1-extra-space-32ms-runtime-beats-98",
                "content": "\\tclass Solution:\\n\\n\\t\\tdef shortestPalindrome(self, s: str) -> str:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tFind the longest palindrome starting from index 0\\n\\t\\t\\t\"\"\"        \\n\\t\\t\\t# search for the end of the longest palindrome starting at index 0 \\n\\t\\t\\tidx, j = len(s)//2, 0 # idx init as median-right, j is the end index of longest palindrome\\n\\t\\t\\twhile idx >= 0: \\n\\t\\t\\t\\t# find the left/right bounds of repeated-value-chunk\\n\\t\\t\\t\\tl = r = idx\\n\\t\\t\\t\\twhile l-1 >= 0 and s[l-1] == s[idx]: l -= 1\\n\\t\\t\\t\\twhile r+1 < len(s) and s[r+1] == s[idx]: r += 1\\n\\t\\t\\t\\tidx = l - 1 # update idx to the left most\\n\\n\\t\\t\\t\\t# expand from (l, r)\\n\\t\\t\\t\\twhile l >= 0 and r < len(s) and s[l] == s[r]:\\n\\t\\t\\t\\t\\tl, r = l-1, r+1 # grow palindrome\\n\\n\\t\\t\\t\\t# check, first match must be the longest possible\\n\\t\\t\\t\\tif l+1 == 0 and r-1 != 0:\\n\\t\\t\\t\\t\\tj = r-1\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t# return\\n\\t\\t\\treturn s[j+1:][::-1] + s\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\n\\t\\tdef shortestPalindrome(self, s: str) -> str:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tFind the longest palindrome starting from index 0\\n\\t\\t\\t\"\"\"        \\n\\t\\t\\t# search for the end of the longest palindrome starting at index 0 \\n\\t\\t\\tidx, j = len(s)//2, 0 # idx init as median-right, j is the end index of longest palindrome\\n\\t\\t\\twhile idx >= 0: \\n\\t\\t\\t\\t# find the left/right bounds of repeated-value-chunk\\n\\t\\t\\t\\tl = r = idx\\n\\t\\t\\t\\twhile l-1 >= 0 and s[l-1] == s[idx]: l -= 1\\n\\t\\t\\t\\twhile r+1 < len(s) and s[r+1] == s[idx]: r += 1\\n\\t\\t\\t\\tidx = l - 1 # update idx to the left most\\n\\n\\t\\t\\t\\t# expand from (l, r)\\n\\t\\t\\t\\twhile l >= 0 and r < len(s) and s[l] == s[r]:\\n\\t\\t\\t\\t\\tl, r = l-1, r+1 # grow palindrome\\n\\n\\t\\t\\t\\t# check, first match must be the longest possible\\n\\t\\t\\t\\tif l+1 == 0 and r-1 != 0:\\n\\t\\t\\t\\t\\tj = r-1\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t# return\\n\\t\\t\\treturn s[j+1:][::-1] + s\\n",
                "codeTag": "Java"
            },
            {
                "id": 308559,
                "title": "why-not-simple-hashing-in-o-n-will-you-reproduce-kmp-or-manacher-on-interview",
                "content": "Why is everyone writing KMP and Manacher?\\nI wonder are you able to write  (and explain!) one of these algorithms from scratch in 40min interview?\\nWhy not a simple hashing algorithm:\\n```C++\\n    const int p = 31;\\n    const int M = 1e9 + 7; // I prefer always use mod prime even if we don\\'t need to \\n\\t// find a reverse element. Just for consistancy, it is faster to write one standard way\\n\\t// every time instead of creating something ad hoc\\n    string shortestPalindrome(string s) {\\n        const int n = s.size();\\n        if (s.size() == 0) return \"\";\\n        // compute the length of longest prefix palindrome\\n        long long fhash = 0, bhash = 0;\\n        int lenMaxPrefixPalindrome = 0;\\n        long long pp = 1;\\n        for (int i = 0; i < n; ++i) {\\n            int c = s[i] - \\'a\\';\\n            fhash = (fhash + (c*pp)%M)%M;\\n            pp = (p * pp)%M;\\n            \\n            bhash = ((bhash * p)%M + c)%M;\\n            \\n            if (fhash == bhash) {\\n                lenMaxPrefixPalindrome = i;\\n            }\\n        }\\n        lenMaxPrefixPalindrome += 1;\\n        // now just copy the not palindromic suffix in reversed order\\n\\t\\t// to the buffer and than copy original string there\\n        string res(2*n - lenMaxPrefixPalindrome, \\'a\\');\\n        int j = s.size() - 1;\\n        for (int i = 0; i < 2*n - lenMaxPrefixPalindrome; ++i) {\\n            if (i < n - lenMaxPrefixPalindrome) {\\n                res[i] = s[j];\\n                --j;\\n            } else {\\n                res[i] = s[i - (n - lenMaxPrefixPalindrome)];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```C++\\n    const int p = 31;\\n    const int M = 1e9 + 7; // I prefer always use mod prime even if we don\\'t need to \\n\\t// find a reverse element. Just for consistancy, it is faster to write one standard way\\n\\t// every time instead of creating something ad hoc\\n    string shortestPalindrome(string s) {\\n        const int n = s.size();\\n        if (s.size() == 0) return \"\";\\n        // compute the length of longest prefix palindrome\\n        long long fhash = 0, bhash = 0;\\n        int lenMaxPrefixPalindrome = 0;\\n        long long pp = 1;\\n        for (int i = 0; i < n; ++i) {\\n            int c = s[i] - \\'a\\';\\n            fhash = (fhash + (c*pp)%M)%M;\\n            pp = (p * pp)%M;\\n            \\n            bhash = ((bhash * p)%M + c)%M;\\n            \\n            if (fhash == bhash) {\\n                lenMaxPrefixPalindrome = i;\\n            }\\n        }\\n        lenMaxPrefixPalindrome += 1;\\n        // now just copy the not palindromic suffix in reversed order\\n\\t\\t// to the buffer and than copy original string there\\n        string res(2*n - lenMaxPrefixPalindrome, \\'a\\');\\n        int j = s.size() - 1;\\n        for (int i = 0; i < 2*n - lenMaxPrefixPalindrome; ++i) {\\n            if (i < n - lenMaxPrefixPalindrome) {\\n                res[i] = s[j];\\n                --j;\\n            } else {\\n                res[i] = s[i - (n - lenMaxPrefixPalindrome)];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 60119,
                "title": "3ms-solution-using-hash",
                "content": "```\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s) {\\n        int p = 1000000009;\\n        int m = 1, a= 0 , b = 0, i = -1;\\n        for (int j = 0; j < s.size(); ++j) {\\n            a += m * s[j];\\n            m *=p;\\n            b = b*p + s[j];\\n            if (a == b) i = j;\\n        }\\n        string add = s.substr(i+1);\\n        reverse(add.begin(), add.end());\\n        return add + s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s) {\\n        int p = 1000000009;\\n        int m = 1, a= 0 , b = 0, i = -1;\\n        for (int j = 0; j < s.size(); ++j) {\\n            a += m * s[j];\\n            m *=p;\\n            b = b*p + s[j];\\n            if (a == b) i = j;\\n        }\\n        string add = s.substr(i+1);\\n        reverse(add.begin(), add.end());\\n        return add + s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60192,
                "title": "clear-c-solution-with-kmp-next",
                "content": "    string shortestPalindrome(string s) {\\n    \\tstring s2 = s;\\n    \\treverse(s2.begin(), s2.end());\\n    \\tstring ss = s + '#' + s2;\\n    \\tint n = ss.size();\\n    \\tvector<int> next(n, 0);\\n    \\tint k = 0;\\n    \\tfor (int i = 1; i < n; i++) {\\n    \\t\\twhile (k > 0 && ss[i] != ss[k])\\n    \\t\\t\\tk = next[k - 1];\\n    \\t\\tif (ss[i] == ss[k])\\n    \\t\\t\\tk++;\\n    \\t\\tnext[i] = k;\\n    \\t}\\n    \\tint m = s.size() - next[n - 1];\\n    \\tstring res = s2.substr(0, m) + s;\\n    \\treturn res;\\n    }",
                "solutionTags": [],
                "code": "    string shortestPalindrome(string s) {\\n    \\tstring s2 = s;\\n    \\treverse(s2.begin(), s2.end());\\n    \\tstring ss = s + '#' + s2;\\n    \\tint n = ss.size();\\n    \\tvector<int> next(n, 0);\\n    \\tint k = 0;\\n    \\tfor (int i = 1; i < n; i++) {\\n    \\t\\twhile (k > 0 && ss[i] != ss[k])\\n    \\t\\t\\tk = next[k - 1];\\n    \\t\\tif (ss[i] == ss[k])\\n    \\t\\t\\tk++;\\n    \\t\\tnext[i] = k;\\n    \\t}\\n    \\tint m = s.size() - next[n - 1];\\n    \\tstring res = s2.substr(0, m) + s;\\n    \\treturn res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 60223,
                "title": "my-python-solution",
                "content": "I don't think this is most efficient. This algorithm compares: `n/2` letters, `(n-1)/2` letters, `(n-2)/2` letters... `1` letter. So the worst case complexity is `n^2`.\\n\\n\\n    class Solution(object):\\n        def shortestPalindrome(self, str):\\n            \"\"\"\\n            :type str: str\\n            :rtype: str\\n            \"\"\"\\n            l = len(str)\\n            revstr = str[::-1]\\n            for i in xrange(l):\\n                if str[:(l-i+1)/2] == revstr[i:(l+i+1)/2]:\\n                    return  revstr[:i] + str\\n\\n            return  revstr[:-1] + str",
                "solutionTags": [
                    "Python"
                ],
                "code": "I don't think this is most efficient. This algorithm compares: `n/2` letters, `(n-1)/2` letters, `(n-2)/2` letters... `1` letter. So the worst case complexity is `n^2`.\\n\\n\\n    class Solution(object):\\n        def shortestPalindrome(self, str):\\n            \"\"\"\\n            :type str: str\\n            :rtype: str\\n            \"\"\"\\n            l = len(str)\\n            revstr = str[::-1]\\n            for i in xrange(l):\\n                if str[:(l-i+1)/2] == revstr[i:(l+i+1)/2]:\\n                    return  revstr[:i] + str\\n\\n            return  revstr[:-1] + str",
                "codeTag": "Java"
            },
            {
                "id": 60226,
                "title": "share-my-c-o-n-kmp-method",
                "content": "The Key idea is to generate the prefix suffix match array. Please note that I add an \"#\" between the string and the reversed one, in case of too long matched suffix.\\n\\n    class Solution {\\n    public:\\n        string shortestPalindrome(string s) {\\n            string p=s;\\n            reverse(p.begin(),p.end());\\n            p=s+\"#\"+p;\\n            vector<int> next(p.size()+1,0); //\\n            getNext(p,next);\\n            return p.substr(s.size()+1,s.size()-next.back())+s;\\n        }\\n        //prefix suffix match, O(N)\\n        void getNext(string &p, vector<int> &next){\\n            next[0]=-1;\\n            int k=-1,j=0,len=next.size();\\n            while(j<len-1){\\n                //p[k] denotes prefix, p[j] denotes suffix\\n                if(k==-1||p[j]==p[k])next[++j]=++k;\\n                else k=next[k];\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string shortestPalindrome(string s) {\\n            string p=s;\\n            reverse(p.begin(),p.end());\\n            p=s+\"#\"+p;\\n            vector<int> next(p.size()+1,0); //\\n            getNext(p,next);\\n            return p.substr(s.size()+1,s.size()-next.back())+s;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 60238,
                "title": "o-n-solution-based-on-hashmaps-no-manacher-no-kmp",
                "content": "In a palindrome, If we sum up all the positions of all the different characters separately, and divide it by their count (basically getting the average position of every different character) we must get equal values. \\n\\n    public class Solution {\\n    private <T> void removeOne(HashMap<T, Integer> map, T key){\\n        int value = map.get(key);\\n        if (value == 1){\\n            map.remove(key);\\n        } else{\\n            map.put(key, value-1);\\n        }\\n    }\\n    \\n    private <T> void addValue(HashMap<T, Integer> map, T key, int value){\\n        Integer val = map.get(key);\\n        if (val == null){\\n            map.put(key,value);\\n        } else{\\n            map.put(key, val + value);\\n        }\\n    }\\n\\n    \\n    public String shortestPalindrome(String s) {\\n        char[] chars = s.toCharArray();\\n        HashMap<Character, Integer> count = new HashMap<>();\\n        HashMap<Character, Integer> sum = new HashMap<>();\\n        HashMap<Double, Integer> averages = new HashMap<>();\\n        \\n        for (int i=0; i<chars.length; ++i){\\n            char c = chars[i];\\n            addValue(count,c,1);\\n            addValue(sum,c,i);\\n        }\\n        for (char c: count.keySet()){\\n            double d = (1.0 * sum.get(c)) / (double)count.get(c);\\n            addValue(averages,d,1);\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        if (averages.size()==1){\\n            sb.append(s);\\n            return sb.toString();\\n        }\\n        /*\\n          starting from the far right in the string, we remove character by character, \\n          and check in constant time whether the remaining string is a palindrome \\n          (the average position of all characters is equal)\\n        */\\n        for (int i=chars.length -1; i>0; --i){\\n            sb.append(chars[i]);\\n            int cou = count.get(chars[i]);\\n            int su = sum.get(chars[i]);\\n            double avg = (1.0 * su) / cou;\\n            removeOne(averages,(1.0 * su) / cou);\\n\\n            if (cou == 1){\\n                count.remove(chars[i]);\\n                sum.remove(chars[i]);\\n            } else{\\n                count.put(chars[i], cou - 1);\\n                sum.put(chars[i], su - i);\\n                avg = (1.0 * (su - i))/(cou - 1);\\n                addValue(averages,avg,1);\\n            }\\n            if (averages.size()==1){\\n                sb.append(s);\\n                return sb.toString();\\n            }\\n        }\\n        sb.append(s);\\n        return sb.toString();\\n    }\\n}\\n\\nThis got accepted, but I'm not convinced 100% that there is no string, for which the average position of all characters are equal, but still it's not a palindrome.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    private <T> void removeOne(HashMap<T, Integer> map, T key){\\n        int value = map.get(key);\\n        if (value == 1){\\n            map.remove(key);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 60255,
                "title": "ac-java-kmp-solution",
                "content": "    public class Solution {\\n        public String shortestPalindrome(String s) {\\n            String r = new StringBuilder(s).reverse().toString();\\n            int[] lps = getLPS(s + '|' + r);\\n            return r.substring(0, r.length() - lps[lps.length - 1]) + s;\\n        }\\n        \\n        // KMP get longest prefix and suffix count\\n        int[] getLPS(String s) {\\n          int[] lps = new int[s.length()];\\n          int i = 1, len = 0;\\n          \\n          while (i < s.length()) {\\n            if (s.charAt(i) == s.charAt(len)) \\n              lps[i++] = ++len;\\n            else if (len == 0)                \\n              lps[i++] = 0;\\n            else                              \\n              len = lps[len - 1];\\n          }\\n          \\n          return lps;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String shortestPalindrome(String s) {\\n            String r = new StringBuilder(s).reverse().toString();\\n            int[] lps = getLPS(s + '|' + r);\\n            return r.substring(0, r.length() - lps[lps.length - 1]) + s;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3640235,
                "title": "c-beats-100-recursive-easy",
                "content": "## Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStart with a pointers ```l = 0```. Iterate from ```j = n-1``` to ```j = 0``` where ```n = s.length()```. For each iteration, if ```s[l] == s[j]```, increment ```l``` by 1.\\n\\nSince  ```j``` iterates over the entire string, the substring ```s[l] --> s[n]``` must be reversed and added to the front to produce the final answer; and the substring ```s[0] --> s[l]``` needs to be searched recursively to find the shortest Palindromic sequence for this substring.\\n\\nSo, in each iteration, the size of the substring being searched is reduced as:\\n- If ```l == n```, then ```s``` is a palindrome and return ```s``` as the final answer.\\n- Else return ```reverse(s[l] --> s[n]) + shortestPalindrom(s[0] --> s[l]) + (s[l] --> s[n])``` as the final answer.\\n\\n----\\n\\n## Complexity\\n- Time complexity: *(O(n<sup>2</sup>))* &nbsp;&nbsp;&nbsp;&nbsp;*where n is the length of the string*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *O(n) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;where n is the length of the string*\\n*(Since recursive calls are stacked and thus occupy some space)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n----\\n###### Please upvote if yoou find this solution useful.\\n----\\n\\n## Code\\n``` cpp []\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s) {\\n        if(s.length()<=1)\\n            return s;\\n        \\n        int l = 0, r = s.size()-1;\\n\\n        while(r>=0){\\n            if(s[l]==s[r])\\n                l++;\\n            r--;\\n        }\\n        \\n        if(l==s.size())\\n            return s;\\n\\n        string rem (s.begin()+l,s.end());\\n        reverse(rem.begin(),rem.end());\\n        string out = rem + shortestPalindrome(s.substr(0,l)) + s.substr(l,s.size());\\n\\n        return out;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String",
                    "String Matching"
                ],
                "code": "```l = 0```\n```j = n-1```\n```j = 0```\n```n = s.length()```\n```s[l] == s[j]```\n```l```\n```j```\n```s[l] --> s[n]```\n```s[0] --> s[l]```\n```l == n```\n```s```\n```s```\n```reverse(s[l] --> s[n]) + shortestPalindrom(s[0] --> s[l]) + (s[l] --> s[n])```\n``` cpp []\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s) {\\n        if(s.length()<=1)\\n            return s;\\n        \\n        int l = 0, r = s.size()-1;\\n\\n        while(r>=0){\\n            if(s[l]==s[r])\\n                l++;\\n            r--;\\n        }\\n        \\n        if(l==s.size())\\n            return s;\\n\\n        string rem (s.begin()+l,s.end());\\n        reverse(rem.begin(),rem.end());\\n        string out = rem + shortestPalindrome(s.substr(0,l)) + s.substr(l,s.size());\\n\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549664,
                "title": "recursion",
                "content": "# Approach\\nFirst, found the longest prefix of the string that is a palindrome and stored the length. Then reversed the remaining substring. Recursively found the palindrome of the remaining substring and appended it to original string. For base case, if i equals to n (length of string), then s is returned.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def shortestPalindrome(self, s: str) -> str:\\n        i = 0\\n        n = len(s)\\n        for j in range(n):\\n            if s[i] == s[n-j-1]:\\n                i += 1\\n        if i==n:\\n            return s\\n        p = s[i:n][::-1]\\n        return p + self.shortestPalindrome(s[:i]) + s[i:]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestPalindrome(self, s: str) -> str:\\n        i = 0\\n        n = len(s)\\n        for j in range(n):\\n            if s[i] == s[n-j-1]:\\n                i += 1\\n        if i==n:\\n            return s\\n        p = s[i:n][::-1]\\n        return p + self.shortestPalindrome(s[:i]) + s[i:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541412,
                "title": "approach1-two-pointers-and-recursion",
                "content": "# Intuition\\nHere we take two pointers i and j,and increment i whenever value at ith and jth position is equal. j is iterated in a loop from end to start.here the idea is that we get a loose range [0,i)in which the longest palindrome from left to right exists. Here the best case is when string is palindrome and i becomes n. Here the range [0,i)  reduced by a minimum of 2 in each recursion.Hence reducing the search space and improving the time complexity. Finally after identifying palindrome the rest of the section is reversed and added to the front to get shortest palindrome.Here with recursion we are constantly reducing the length of the string to check until we hit the base case\\n\\n# Approach\\n- Initialsed i=0 and i is incremented in a for loop (j=0->n-1) whenever (s[i]==s[j])\\n- If(i==n) that means we found the palindrome and returns the string\\n- Then we reverse the string from range(i,n) :this substring is not part of the palindrome\\n- Finally the reversed substring is added to the string recursively to get the shortest palindrome\\n\\n# Complexity\\n- Time complexity:\\n=O(n)+O(n-2)+O(n-4)+...O(1)=O($n^2$)\\n- Space complexity:\\nO(n) extra space for rem string\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     string shortestPalindrome(string s) {\\n        int n = s.size();\\n        int i = 0;\\n        for(int j=0; j<n; j++) {\\n            if(s[i] == s[n-j-1]) i++;\\n        }\\n        if(i==n) return s;\\n        string rem = s.substr(i,n);\\n        reverse(rem.begin(), rem.end());\\n        return rem + shortestPalindrome(s.substr(0,i)) + s.substr(i);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     string shortestPalindrome(string s) {\\n        int n = s.size();\\n        int i = 0;\\n        for(int j=0; j<n; j++) {\\n            if(s[i] == s[n-j-1]) i++;\\n        }\\n        if(i==n) return s;\\n        string rem = s.substr(i,n);\\n        reverse(rem.begin(), rem.end());\\n        return rem + shortestPalindrome(s.substr(0,i)) + s.substr(i);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335558,
                "title": "no-brain-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def shortestPalindrome(self, s: str) -> str:\\n        if s == s[::-1]:\\n            return s\\n        for i in range(1, len(s)):\\n            if s[-i:][::-1]+s == (s[-i:][::-1]+s)[::-1]:\\n                return s[-i:][::-1]+s\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestPalindrome(self, s: str) -> str:\\n        if s == s[::-1]:\\n            return s\\n        for i in range(1, len(s)):\\n            if s[-i:][::-1]+s == (s[-i:][::-1]+s)[::-1]:\\n                return s[-i:][::-1]+s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952454,
                "title": "c-z-algo-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nReverse the given string and the problem becomes: Minimum character to add to the end of the string to make the given string palindrome. This is a trivial problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet solve the above problem, since it\\'s equivalent to the initial problem.\\n\\nLet t = reverse(s), make a new string of the form s + \"#\" + t.\\n\\nCompute Z function on that string, and find first character after the # symbol such that the suffix starting from it is also a prefix.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s) {\\n        string t = s;\\n        reverse(s.begin(), s.end());\\n\\n        s = t + \"$\" + s;\\n\\n        int n = s.length();\\n        vector <int> Z(n, 0);\\n        Z[0] = n;\\n        int L = 0, R = 0;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (i > R) {\\n                L = R = i;\\n                while (R < n && s[R] == s[R - L]) R++;\\n                Z[i] = R - L; R--;\\n            } else {\\n                int k = i - L;\\n                if (i + Z[k] - 1 < R) Z[i] = Z[k];\\n                else {\\n                    L = i;\\n                    while (R < n && s[R] == s[R - L]) R++;\\n                    Z[i] = R - L; R--;\\n                }\\n            }\\n        }\\n\\n        string ans = t;\\n        reverse(ans.begin(), ans.end());\\n        for (int i = t.length() + 1; i < n; i++) {\\n            if (i + Z[i] == n) {\\n                int needed = i - t.length() - 1;\\n                for (int j = (int)t.length() - needed; j < t.length(); j++) {\\n                    ans += t[j];\\n                }\\n\\n                break;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s) {\\n        string t = s;\\n        reverse(s.begin(), s.end());\\n\\n        s = t + \"$\" + s;\\n\\n        int n = s.length();\\n        vector <int> Z(n, 0);\\n        Z[0] = n;\\n        int L = 0, R = 0;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (i > R) {\\n                L = R = i;\\n                while (R < n && s[R] == s[R - L]) R++;\\n                Z[i] = R - L; R--;\\n            } else {\\n                int k = i - L;\\n                if (i + Z[k] - 1 < R) Z[i] = Z[k];\\n                else {\\n                    L = i;\\n                    while (R < n && s[R] == s[R - L]) R++;\\n                    Z[i] = R - L; R--;\\n                }\\n            }\\n        }\\n\\n        string ans = t;\\n        reverse(ans.begin(), ans.end());\\n        for (int i = t.length() + 1; i < n; i++) {\\n            if (i + Z[i] == n) {\\n                int needed = i - t.length() - 1;\\n                for (int j = (int)t.length() - needed; j < t.length(); j++) {\\n                    ans += t[j];\\n                }\\n\\n                break;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2820508,
                "title": "100-faster-python-solution-using-kmp-algorithm",
                "content": "\\tclass Solution:\\n\\t\\tdef shortestPalindrome(self, s: str) -> str:\\n\\t\\t\\tdef kmp(txt, patt):\\n\\t\\t\\t\\tnewString = patt + \\'#\\' + txt\\n\\t\\t\\t\\tfreqArray = [0 for _ in range(len(newString))]\\n\\t\\t\\t\\ti = 1\\n\\t\\t\\t\\tlength = 0\\n\\t\\t\\t\\twhile i < len(newString):\\n\\t\\t\\t\\t\\tif newString[i] == newString[length]:\\n\\t\\t\\t\\t\\t\\tlength += 1\\n\\t\\t\\t\\t\\t\\tfreqArray[i] = length\\n\\t\\t\\t\\t\\t\\ti += 1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tif length > 0:\\n\\t\\t\\t\\t\\t\\t\\tlength = freqArray[length - 1]\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tfreqArray[i] = 0\\n\\t\\t\\t\\t\\t\\t\\ti += 1\\n\\t\\t\\t\\treturn freqArray[-1]\\n\\t\\t\\tcnt = kmp(s[::-1],s)\\n\\t\\t\\treturn s[cnt:][::-1]+s\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "String"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef shortestPalindrome(self, s: str) -> str:\\n\\t\\t\\tdef kmp(txt, patt):\\n\\t\\t\\t\\tnewString = patt + \\'#\\' + txt\\n\\t\\t\\t\\tfreqArray = [0 for _ in range(len(newString))]\\n\\t\\t\\t\\ti = 1\\n\\t\\t\\t\\tlength = 0\\n\\t\\t\\t\\twhile i < len(newString):\\n\\t\\t\\t\\t\\tif newString[i] == newString[length]:\\n\\t\\t\\t\\t\\t\\tlength += 1\\n\\t\\t\\t\\t\\t\\tfreqArray[i] = length\\n\\t\\t\\t\\t\\t\\ti += 1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tif length > 0:\\n\\t\\t\\t\\t\\t\\t\\tlength = freqArray[length - 1]\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tfreqArray[i] = 0\\n\\t\\t\\t\\t\\t\\t\\ti += 1\\n\\t\\t\\t\\treturn freqArray[-1]\\n\\t\\t\\tcnt = kmp(s[::-1],s)\\n\\t\\t\\treturn s[cnt:][::-1]+s\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2755542,
                "title": "beats-100-kmp-lps-cpp",
                "content": "### *based on longest proper prefix which is also longest proper suffix*\\nfastest solution\\n<a href=\"https://youtu.be/__Cu92rei1s\" target=\"_blank\">kmp explination -vedio link</a><br>\\n\\n```\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s) {\\n        string rev=s;\\n        reverse(rev.begin(),rev.end());\\n        string temp=s+\\'#\\'+rev;\\n        //kmp  lps\\n        int n=temp.length();\\n        vector<int> lps(n,0);\\n        int len = 0, i = 1;\\n        while(i < n) {\\n            if(temp[len] == temp[i]) {\\n                len++;\\n                lps[i] =len;\\n                i++;\\n            } \\n            else {\\n                if(len != 0){\\n                    len = lps[len-1];\\n                }\\n                else {\\n                    lps[i] = 0;\\n                    i++;\\n                }\\n            }\\n        }\\n        temp=s.substr(lps[n-1]);\\n        reverse(temp.begin(),temp.end());\\n        return temp+s;\\n    }\\n};\\n```\\n*** 2nd solution (TLE) ***\\n```\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s){\\n        string temp=s;\\n        reverse(temp.begin(),temp.end());\\n        string pl1=\"\";\\n        string pl2=\"\";\\n        int index=-1;\\n        int n=s.length();\\n        for(int i=0;i<n;i++){\\n            pl1=pl1+s[i];\\n            pl2=temp[n-1-i]+pl2;\\n            if(pl1==pl2){index=i;}\\n        }\\n        string non_palindromicpart=s.substr(index+1);\\n        reverse(non_palindromicpart.begin(),non_palindromicpart.end());\\n        s=non_palindromicpart+s;\\n        return s;\\n    }\\n};\\n\\'\\'\\'\\n# please upvote if you love the solution # \\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s) {\\n        string rev=s;\\n        reverse(rev.begin(),rev.end());\\n        string temp=s+\\'#\\'+rev;\\n        //kmp  lps\\n        int n=temp.length();\\n        vector<int> lps(n,0);\\n        int len = 0, i = 1;\\n        while(i < n) {\\n            if(temp[len] == temp[i]) {\\n                len++;\\n                lps[i] =len;\\n                i++;\\n            } \\n            else {\\n                if(len != 0){\\n                    len = lps[len-1];\\n                }\\n                else {\\n                    lps[i] = 0;\\n                    i++;\\n                }\\n            }\\n        }\\n        temp=s.substr(lps[n-1]);\\n        reverse(temp.begin(),temp.end());\\n        return temp+s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704955,
                "title": "reverse-hash-easy-understanding-faster",
                "content": "1. Let try to find the biggest palindrom from the 0\\'th index\\n2. And then add the remaining charachters to the first part of the string , in a reverse manner, as it has to be a palindrom.\\n3. for finding the biggest palindrom , we should keep a hash value and rolling hash is well\\n4. if these two hash value is same then its a palindrom so far.\\n5. In this manner we will find the biggest palindrom\\n\\nHere is the implementation\\n```\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s) {\\n        long long m1 = 1e9+9ll;\\n        long long m2 = 1e9+7ll;\\n        long long p1 = 31;\\n        long long p2 = 31;\\n        int n = s.size();\\n        long long H1 = 0,H2 = 0;\\n        int so_far = 0;\\n        for(int i=0;i<n;i++){\\n            int a = s[i]-\\'a\\'+1;\\n            H1 = (H1 + (a*p1)%m1 )%m1;\\n            p1 = p1*31;\\n            if(p1>m1)p1%=m1;\\n            \\n            \\n            H2 = H2*31;\\n            if(H2>m1)H2%=m1;\\n            H2 = (H2 + (a*p2)%m1)%m1;\\n            //cout<<H1 <<\" \"<<H2<<endl;\\n            if(H1 == H2 ){\\n                so_far = max(so_far,i+1);\\n            }\\n            \\n        }\\n        string pref =\"\";\\n        for(int i=n-1;i>=so_far;i--)pref+=s[i];\\n        string ans = pref+s;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s) {\\n        long long m1 = 1e9+9ll;\\n        long long m2 = 1e9+7ll;\\n        long long p1 = 31;\\n        long long p2 = 31;\\n        int n = s.size();\\n        long long H1 = 0,H2 = 0;\\n        int so_far = 0;\\n        for(int i=0;i<n;i++){\\n            int a = s[i]-\\'a\\'+1;\\n            H1 = (H1 + (a*p1)%m1 )%m1;\\n            p1 = p1*31;\\n            if(p1>m1)p1%=m1;\\n            \\n            \\n            H2 = H2*31;\\n            if(H2>m1)H2%=m1;\\n            H2 = (H2 + (a*p2)%m1)%m1;\\n            //cout<<H1 <<\" \"<<H2<<endl;\\n            if(H1 == H2 ){\\n                so_far = max(so_far,i+1);\\n            }\\n            \\n        }\\n        string pref =\"\";\\n        for(int i=n-1;i>=so_far;i--)pref+=s[i];\\n        string ans = pref+s;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2418876,
                "title": "c-efficient-solution-using-hashing-array",
                "content": "class Solution {\\npublic:\\n    bool checkPalindrome(string s, int i, int j){\\n        for(;i<j;i++,j--){\\n            if(s[i]!=s[j])\\n                return 0;\\n        }\\n        return 1;\\n    }\\n    \\n    string shortestPalindrome(string s) {\\n        int i,n=s.size();\\n        vector<int> v(n+1,0);\\n        for(i=1;i<=n;i++){\\n            v[i]=v[i]+v[i-1]+s[i-1]-\\'a\\';\\n        }\\n        string ans;\\n        for(i=n;i>=1;i--){\\n            if((i%2==0 and v[i/2]==v[i]-v[i/2]) or (i%2!=0 and v[i/2]==v[i]-v[i/2+1])){\\n                if(checkPalindrome(s,0,i-1)){\\n                    ans=s.substr(i);\\n                    reverse(ans.begin(),ans.end());\\n                    break;\\n                }\\n            }\\n        }\\n        return ans+s;\\n    }\\n};````",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool checkPalindrome(string s, int i, int j){\\n        for(;i<j;i++,j--){\\n            if(s[i]!=s[j])\\n                return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2406987,
                "title": "short-and-easy-javascript-solution-with-explanation",
                "content": "The idea is when we put a reversed string next to the string it was reversed from, then we\\'d get a palindrome\\n```\\nword = \\'abcd\\'\\nreversed = \\'dcba\\'\\nreversed + word = \\'dcbaabcd\\'\\n```\\nIt\\'s now a palindrome but it\\'s not the _shortest_ palindrome.\\nThe shortest palindrome for `abcd` is `dcbabcd`\\nIf you notice we just need to add `dcb` in front of the string`abcd` to accomplish it.\\n\\nAlso notice that `dcb` is a prefix of the reversed string `dcba`.\\nThe solution is really just a matter of prepending the prefix of the reversed string so now we just have to find out which prefix we\\'ll be grabbing from the reversed string.\\n\\nLuckily, it\\'s very easy to find the prefix\\n```\\n\\tword = \\'abcd\\'\\n\\treversed = \\'dcba\\'\\n\\t// now all we have to do is keep removing one character from the end of word\\n\\t// and remove one character from the beginning of the reversed word\\n\\t// We keep doing this until both words become equal\\n\\t\\'abcd\\' \\'dcba\\'\\n\\t\\'abc\\' \\'cba\\'\\n\\t\\'ab\\' \\'ba\\'\\n\\t\\'a\\' \\'a\\'\\n\\t// Now they\\'re equal \\n\\t// The length remaining is 1\\n\\t// Which means removing 1 character from the end of dcba will give us our prefix\\n\\t// \\'dcba\\' -> \\'dcb\\'\\n\\t// dcb + abcd = dcbabcd //shortest palindrome\\n```\\n\\n\\nSolution:\\n```\\nvar shortestPalindrome = function(s) {\\n    const originalString = s\\n    const originalReversed = s.split(\\'\\').reverse().join(\\'\\')\\n    let reversed = originalReversed\\n    while(reversed !== s) {\\n        s = s.slice(0,-1)\\n        reversed = reversed.slice(1)\\n    }\\n    return originalReversed.slice(0,-s.length) + originalString\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nword = \\'abcd\\'\\nreversed = \\'dcba\\'\\nreversed + word = \\'dcbaabcd\\'\\n```\n```\\n\\tword = \\'abcd\\'\\n\\treversed = \\'dcba\\'\\n\\t// now all we have to do is keep removing one character from the end of word\\n\\t// and remove one character from the beginning of the reversed word\\n\\t// We keep doing this until both words become equal\\n\\t\\'abcd\\' \\'dcba\\'\\n\\t\\'abc\\' \\'cba\\'\\n\\t\\'ab\\' \\'ba\\'\\n\\t\\'a\\' \\'a\\'\\n\\t// Now they\\'re equal \\n\\t// The length remaining is 1\\n\\t// Which means removing 1 character from the end of dcba will give us our prefix\\n\\t// \\'dcba\\' -> \\'dcb\\'\\n\\t// dcb + abcd = dcbabcd //shortest palindrome\\n```\n```\\nvar shortestPalindrome = function(s) {\\n    const originalString = s\\n    const originalReversed = s.split(\\'\\').reverse().join(\\'\\')\\n    let reversed = originalReversed\\n    while(reversed !== s) {\\n        s = s.slice(0,-1)\\n        reversed = reversed.slice(1)\\n    }\\n    return originalReversed.slice(0,-s.length) + originalString\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2321168,
                "title": "how-to-use-string-hashing-to-solve-this-problem-with-o-1-space",
                "content": "## Calculating string hash\\nLet\\'s introduce the idea of **string hashes** be able to compare strings of length n in o(1) time.\\nEvery letter could be seen as a number.\\nIt is a number, it even has an ASCI code. \\na = 97, b = 98, c = 99, d =100, .. and so on.\\nLet\\'s create a string hash for string **\"avocado\"** using **13** as a smallPrime number:\\n![image](https://assets.leetcode.com/users/images/c31c79aa-a803-4ac7-999b-97de26494ef4_1658569028.4697235.png)\\n\\n\\nYou can see that number could get really big really fast. To keep it inside an integer, let\\'s use an other **big prime number** to construct our space.\\nYou can get a prime number that fits in integer here: https://bigprimes.org/\\nI will use 8869867 as our bigPrime. Instead of comparing two integers as they are, we will compare their remaiders of bigPrime.\\nIf the remaiders are the same, there is a big chance that our numbers are equal.\\nRead [wiki](https://en.wikipedia.org/wiki/Modular_arithmetic#Congruence) about modular aritmetic, to know more. \\n\\n```c++\\nstring s = \"avocado\";\\nint hash = 0;\\nint smallPrime = 13;\\nint bigPrime = 8869867;\\nint mult = 1; // every number in power 0 is 1\\nint hash = 0;\\nfor (int i = 0; i < s.size(); i++) {\\n\\t\\thash += s[i] * mult;\\n\\t\\tmult *= smallPrime;\\n\\t\\thash %= bigPrime;\\n\\t\\tmult %= bigPrime;\\n}\\n```\\n## Calculating hash of reversed string\\n\\nIf strings are palindromes, hash of the string and hash of reversed strings should be equal.\\nLet\\'s calculate hash and reverse hash of the word \"kayak\".\\nReverseHash(s + letter) = ReverseHash(s) * smallPrime + letter\\n\\n![image](https://assets.leetcode.com/users/images/fe7950bb-f522-4903-85f4-26a1f4989f61_1658568983.7578292.png)\\n\\n## Solution\\nC++:\\n```c++\\nint prime = 13;\\n        int mod = 8869867;\\n        int longest = 0;\\n        int hash1 = 0, hash2 = 0;\\n        int mult = 1;\\n        for (int i = 0; i < s.size(); i++) {\\n            hash1 += mult * s[i];\\n            hash2 *= prime;\\n            hash2 += s[i];\\n            hash1 %= mod;\\n            hash2 %= mod;\\n            mult *= prime;\\n            mult %= mod;\\n            if (hash1 == hash2) longest = i + 1;\\n        }\\n        string front;\\n        for (int i = s.size() - 1; i >= longest; i--) {\\n            front.push_back(s[i]);\\n        }\\n        return front + s;\\n```\\n\\nJava:\\n```java\\nint prime = 13;\\n        int mod = 8869867;\\n        int longest = 0;\\n        int hash1 = 0, hash2 = 0;\\n        int mult = 1;\\n        for (int i = 0; i < s.length(); i++) {\\n            hash1 += mult * s.charAt(i);\\n            hash2 *= prime;\\n            hash2 += s.charAt(i);\\n            hash1 %= mod;\\n            hash2 %= mod;\\n            mult *= prime;\\n            mult %= mod;\\n            if (hash1 == hash2) longest = i + 1;\\n        }\\n        StringBuilder front = new StringBuilder();\\n        for (int i = s.length() - 1; i >= longest; i--) {\\n            front.append(s.charAt(i));\\n        }\\n        front.append(s);\\n        return front.toString();\\n```\\n\\nPython:\\n```python\\n\\t\\tprime = 13\\n        mod = 8869867\\n        longest = 0\\n        hash1 = 0\\n        hash2 = 0\\n        mult = 1\\n        for i in range(len(s)):\\n            hash1 += mult * ord(s[i])\\n            hash2 *= prime\\n            hash2 += ord(s[i])\\n            hash1 %= mod\\n            hash2 %= mod\\n            mult *= prime\\n            mult %= mod\\n            if hash1 == hash2: longest = i + 1\\n            \\n        front = []\\n        for i in range(len(s) - 1, longest - 1, -1):\\n            front.append(s[i])\\n        return \"\".join(front + list(s))\\n```\\nJavascript:\\n```js\\n\\t\\tconst prime = 13;\\n        const mod = 8869867;\\n        let longest = 0;\\n        let hash1 = 0, hash2 = 0;\\n        let mult = 1;\\n        for (let i = 0; i < s.length; i++) {\\n            hash1 += mult * s.charCodeAt(i);\\n            hash2 *= prime;\\n            hash2 += s.charCodeAt(i);\\n            hash1 %= mod;\\n            hash2 %= mod;\\n            mult *= prime;\\n            mult %= mod;\\n            if (hash1 === hash2) longest = i + 1;\\n        }\\n        let front = [];\\n        for (let i = s.length - 1; i >= longest; i--) {\\n            front.push(s[i]);\\n        }\\n        return front.join(\"\") + s;\\n```\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "String"
                ],
                "code": "```c++\\nstring s = \"avocado\";\\nint hash = 0;\\nint smallPrime = 13;\\nint bigPrime = 8869867;\\nint mult = 1; // every number in power 0 is 1\\nint hash = 0;\\nfor (int i = 0; i < s.size(); i++) {\\n\\t\\thash += s[i] * mult;\\n\\t\\tmult *= smallPrime;\\n\\t\\thash %= bigPrime;\\n\\t\\tmult %= bigPrime;\\n}\\n```\n```c++\\nint prime = 13;\\n        int mod = 8869867;\\n        int longest = 0;\\n        int hash1 = 0, hash2 = 0;\\n        int mult = 1;\\n        for (int i = 0; i < s.size(); i++) {\\n            hash1 += mult * s[i];\\n            hash2 *= prime;\\n            hash2 += s[i];\\n            hash1 %= mod;\\n            hash2 %= mod;\\n            mult *= prime;\\n            mult %= mod;\\n            if (hash1 == hash2) longest = i + 1;\\n        }\\n        string front;\\n        for (int i = s.size() - 1; i >= longest; i--) {\\n            front.push_back(s[i]);\\n        }\\n        return front + s;\\n```\n```java\\nint prime = 13;\\n        int mod = 8869867;\\n        int longest = 0;\\n        int hash1 = 0, hash2 = 0;\\n        int mult = 1;\\n        for (int i = 0; i < s.length(); i++) {\\n            hash1 += mult * s.charAt(i);\\n            hash2 *= prime;\\n            hash2 += s.charAt(i);\\n            hash1 %= mod;\\n            hash2 %= mod;\\n            mult *= prime;\\n            mult %= mod;\\n            if (hash1 == hash2) longest = i + 1;\\n        }\\n        StringBuilder front = new StringBuilder();\\n        for (int i = s.length() - 1; i >= longest; i--) {\\n            front.append(s.charAt(i));\\n        }\\n        front.append(s);\\n        return front.toString();\\n```\n```python\\n\\t\\tprime = 13\\n        mod = 8869867\\n        longest = 0\\n        hash1 = 0\\n        hash2 = 0\\n        mult = 1\\n        for i in range(len(s)):\\n            hash1 += mult * ord(s[i])\\n            hash2 *= prime\\n            hash2 += ord(s[i])\\n            hash1 %= mod\\n            hash2 %= mod\\n            mult *= prime\\n            mult %= mod\\n            if hash1 == hash2: longest = i + 1\\n            \\n        front = []\\n        for i in range(len(s) - 1, longest - 1, -1):\\n            front.append(s[i])\\n        return \"\".join(front + list(s))\\n```\n```js\\n\\t\\tconst prime = 13;\\n        const mod = 8869867;\\n        let longest = 0;\\n        let hash1 = 0, hash2 = 0;\\n        let mult = 1;\\n        for (let i = 0; i < s.length; i++) {\\n            hash1 += mult * s.charCodeAt(i);\\n            hash2 *= prime;\\n            hash2 += s.charCodeAt(i);\\n            hash1 %= mod;\\n            hash2 %= mod;\\n            mult *= prime;\\n            mult %= mod;\\n            if (hash1 === hash2) longest = i + 1;\\n        }\\n        let front = [];\\n        for (let i = s.length - 1; i >= longest; i--) {\\n            front.push(s[i]);\\n        }\\n        return front.join(\"\") + s;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2182905,
                "title": "java-solution",
                "content": "Concept similar to Longest Palindrome Substring(Take a Reverse of String and find LCS)\\n\\nBasic idea - add a reversed string of the given string and use KMP ( s + \"#\" + s.reverse() )\\n\\n```\\nclass Solution {\\n    public String shortestPalindrome(String s) {\\n        String temp = s;\\n        s += \"#\" + new StringBuilder(s).reverse().toString();\\n        int n = s.length();\\n        int lps[] = new int[n];\\n        int i = 1;\\n        int j = 0;\\n        \\n        while(i<n){\\n            if(s.charAt(i)==s.charAt(j)){\\n                lps[i++] = ++j;\\n            } else {\\n                if(j==0){\\n                    lps[i++]=j;\\n                } else {\\n                    j = lps[j-1];\\n                }\\n            }\\n        }\\n        \\n        return new StringBuilder(temp.substring(lps[lps.length-1])).reverse().toString()+temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String shortestPalindrome(String s) {\\n        String temp = s;\\n        s += \"#\" + new StringBuilder(s).reverse().toString();\\n        int n = s.length();\\n        int lps[] = new int[n];\\n        int i = 1;\\n        int j = 0;\\n        \\n        while(i<n){\\n            if(s.charAt(i)==s.charAt(j)){\\n                lps[i++] = ++j;\\n            } else {\\n                if(j==0){\\n                    lps[i++]=j;\\n                } else {\\n                    j = lps[j-1];\\n                }\\n            }\\n        }\\n        \\n        return new StringBuilder(temp.substring(lps[lps.length-1])).reverse().toString()+temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2129989,
                "title": "c-0-ms-prefix-computation",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefix(string& s){\\n        int n = s.size();\\n        vector<int> pre(n, 0);\\n        for(int i=1; i<n; i++){\\n            int j = pre[i-1];\\n            while(j>0 && s[i]!=s[j])\\n                j = pre[j-1];\\n            if(s[i] == s[j])\\n                j++;\\n            pre[i] = j;\\n        }\\n        return pre[n-1];\\n    }\\n\\t\\n    string shortestPalindrome(string s) {\\n        string temp = s;\\n        reverse(temp.begin(), temp.end());\\n        string st = s + \\'$\\' + temp;\\n        int len = prefix(st);\\n        string sub = s.substr(len);\\n        reverse(sub.begin(), sub.end());\\n        return sub+s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefix(string& s){\\n        int n = s.size();\\n        vector<int> pre(n, 0);\\n        for(int i=1; i<n; i++){\\n            int j = pre[i-1];\\n            while(j>0 && s[i]!=s[j])\\n                j = pre[j-1];\\n            if(s[i] == s[j])\\n                j++;\\n            pre[i] = j;\\n        }\\n        return pre[n-1];\\n    }\\n\\t\\n    string shortestPalindrome(string s) {\\n        string temp = s;\\n        reverse(temp.begin(), temp.end());\\n        string st = s + \\'$\\' + temp;\\n        int len = prefix(st);\\n        string sub = s.substr(len);\\n        reverse(sub.begin(), sub.end());\\n        return sub+s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2025944,
                "title": "fastest-java-solution-for-finding-shortest-palindrome",
                "content": "class Solution {\\npublic String shortestPalindrome(String s) {\\nfinal String l = new StringBuilder(s).reverse().toString();\\n\\nfor (int i = 0; i < l.length(); ++i)\\n  if (s.startsWith(l.substring(i)))\\n    return l.substring(0, i) + s;\\n\\nreturn l + s;\\n}\\n}",
                "solutionTags": [],
                "code": "class Solution {\\npublic String shortestPalindrome(String s) {\\nfinal String l = new StringBuilder(s).reverse().toString();\\n\\nfor (int i = 0; i < l.length(); ++i)\\n  if (s.startsWith(l.substring(i)))\\n    return l.substring(0, i) + s;\\n\\nreturn l + s;\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1949675,
                "title": "python-simple-solution-with-rabin-karp-optimization",
                "content": "The goal of the problem is to find the max substring palidrome of `s[:i]`\\n\\nFor example, `s=\\'aabaacd\\'`, we know that the max substring palidrome is `\\'aabaa\\'` and the result is `\\'dc\\' + \\'aabaacd\\' -> dcaabaacd` where `\\'dc\\'` is the reversed of the remain chars `\\'dc\\'`\\n\\n\\nStarting from Brute force solution:\\n\\t1. iterate `s` backward and check if the sub string `s[:i]` is a palindrome by `s[:i] == s[:i][::-1]`\\n\\t2. If True: we can return `s[i:][::-1] + s`\\n\\t3. else: move on to `i -= 1`\\n\\nBrute Force Solution Code:\\n - Pass with `556 ms`\\n - Time: O(N^2)\\n - Space: O(N)\\n```python\\nclass Solution:\\n    def shortestPalindrome(self, s: str) -> str:\\n        if not s:\\n            return \\'\\'\\n        \\n        for i in range(len(s), 0, -1):\\n            sub = s[:i]\\n            if sub == sub[::-1]:\\n                return s[i:][::-1] + s\\n```\\n\\nNow we know how to solve it with brute force solution. Let\\'s try to do the optimization.\\nOur ultimate goal is to reduce the time complexity to O(N)\\n\\nAs we can see from the Brute Force solution, when we do the statement `sub == sub[::-1]`, it will need another O(N) time. Hence, we need to figure out a way to compare the sub str more efficiently.\\n\\nSince we are judging whether if 2 strings are identical, we can use Rabin-Karp algorithm very handy. \\nThe idea is basically to calculate the hash value of the 2 strings and compare the them.\\n\\n\\n```python\\nclass Solution:\\n    def shortestPalindrome(self, s: str) -> str:\\n        m = len(s)\\n        reversed_s = s[::-1]\\n        base_num = 2        \\n        # hash value of the string\\n        hash_s = sum(base_num ** i * hash(s[i]) for i in range(m))\\n        # hash value of the reversed string\\n        hash_r = sum(base_num ** i * hash(reversed_s[i]) for i in range(m))\\n        \\n        if hash_s == hash_r:\\n            return s\\n        \\n        for right in range(m - 1, -1, -1):\\n            hash_s = hash_s - hash(s[right]) * (base_num ** right)\\n            hash_r = (hash_r - hash(s[right])) // base_num\\n            if hash_s == hash_r:  # hash values are the same -> s[:right + 1] is palindrome\\n                return reversed_s[:m - right] + s\\n        return reversed_s + s\\n```\\n\\nHowever, here we introduce another operation `base_num ** i`, which will take `log(i)` time. We can optimize it by using multiplication and modulus (Thanks to [maheshpondugula5](https://leetcode.com/problems/shortest-palindrome/discuss/753575/Python-or-Rabin-Karp-Algorithm)):\\n\\n```python\\nclass Solution:\\n    def shortestPalindrome(self, s: str) -> str:\\n        m = len(s)\\n        base_num = 2\\n        cur_power = 1\\n        mod = 175391\\n        \\n        # hash value of the string\\n        hash_s = 0\\n        # hash value of the reversed string\\n        hash_r = 0\\n        idx = -1  # longest palindrome is s[:idx + 1]\\n        for i in range(m):\\n            hash_s = (hash_s + cur_power * hash(s[i])) % mod\\n            hash_r = (hash_r * base_num + hash(s[i])) % mod\\n            if hash_s == hash_r:\\n                idx = i\\n            cur_power =  cur_power * base_num % mod\\n\\n        return s[idx + 1:][::-1] + s\\n```\\nFeel free to ask if u hv any queries\\nUpvote if u like the solutions!",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def shortestPalindrome(self, s: str) -> str:\\n        if not s:\\n            return \\'\\'\\n        \\n        for i in range(len(s), 0, -1):\\n            sub = s[:i]\\n            if sub == sub[::-1]:\\n                return s[i:][::-1] + s\\n```\n```python\\nclass Solution:\\n    def shortestPalindrome(self, s: str) -> str:\\n        m = len(s)\\n        reversed_s = s[::-1]\\n        base_num = 2        \\n        # hash value of the string\\n        hash_s = sum(base_num ** i * hash(s[i]) for i in range(m))\\n        # hash value of the reversed string\\n        hash_r = sum(base_num ** i * hash(reversed_s[i]) for i in range(m))\\n        \\n        if hash_s == hash_r:\\n            return s\\n        \\n        for right in range(m - 1, -1, -1):\\n            hash_s = hash_s - hash(s[right]) * (base_num ** right)\\n            hash_r = (hash_r - hash(s[right])) // base_num\\n            if hash_s == hash_r:  # hash values are the same -> s[:right + 1] is palindrome\\n                return reversed_s[:m - right] + s\\n        return reversed_s + s\\n```\n```python\\nclass Solution:\\n    def shortestPalindrome(self, s: str) -> str:\\n        m = len(s)\\n        base_num = 2\\n        cur_power = 1\\n        mod = 175391\\n        \\n        # hash value of the string\\n        hash_s = 0\\n        # hash value of the reversed string\\n        hash_r = 0\\n        idx = -1  # longest palindrome is s[:idx + 1]\\n        for i in range(m):\\n            hash_s = (hash_s + cur_power * hash(s[i])) % mod\\n            hash_r = (hash_r * base_num + hash(s[i])) % mod\\n            if hash_s == hash_r:\\n                idx = i\\n            cur_power =  cur_power * base_num % mod\\n\\n        return s[idx + 1:][::-1] + s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1946570,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Longest Prefix Suffix***\\n\\n* ***Time Complexity : O(N)***\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic: \\n    int find_lps(string str)\\n    {\\n        int n = str.size();\\n        \\n        vector<int> lps(n, 0);\\n        \\n        lps[0] = 0;\\n        \\n        int i = 1;\\n        \\n        int len = 0;\\n        \\n        while(i < n)\\n        {\\n            if(str[i] == str[len])\\n            {\\n                len++;\\n                \\n                lps[i] = len;\\n                \\n                i++;\\n            }\\n            else\\n            {\\n                if(len == 0)\\n                {\\n                    lps[i] = 0;\\n                    \\n                    i++;\\n                }\\n                else\\n                {\\n                    len = lps[len - 1];\\n                }\\n            }\\n        }\\n        \\n        return lps[n - 1];\\n    }\\n    \\n    string shortestPalindrome(string str) {\\n        \\n        int n = str.size();\\n        \\n        string rev = str;\\n        \\n        reverse(rev.begin(), rev.end());\\n        \\n        string temp = str + \"#\";\\n        \\n        temp += rev;\\n        \\n        int lps = find_lps(temp);\\n        \\n        string res = str.substr(lps);\\n        \\n        reverse(res.begin(), res.end());\\n        \\n        return res + str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    int find_lps(string str)\\n    {\\n        int n = str.size();\\n        \\n        vector<int> lps(n, 0);\\n        \\n        lps[0] = 0;\\n        \\n        int i = 1;\\n        \\n        int len = 0;\\n        \\n        while(i < n)\\n        {\\n            if(str[i] == str[len])\\n            {\\n                len++;\\n                \\n                lps[i] = len;\\n                \\n                i++;\\n            }\\n            else\\n            {\\n                if(len == 0)\\n                {\\n                    lps[i] = 0;\\n                    \\n                    i++;\\n                }\\n                else\\n                {\\n                    len = lps[len - 1];\\n                }\\n            }\\n        }\\n        \\n        return lps[n - 1];\\n    }\\n    \\n    string shortestPalindrome(string str) {\\n        \\n        int n = str.size();\\n        \\n        string rev = str;\\n        \\n        reverse(rev.begin(), rev.end());\\n        \\n        string temp = str + \"#\";\\n        \\n        temp += rev;\\n        \\n        int lps = find_lps(temp);\\n        \\n        string res = str.substr(lps);\\n        \\n        reverse(res.begin(), res.end());\\n        \\n        return res + str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1913810,
                "title": "python-z-algorithm-with-detail-explanation-o-n-solution",
                "content": "# Background\\n\\nAfter doing the bi-weekly contest and meet this https://leetcode.com/problems/sum-of-scores-of-built-strings/ question, I learned about the z_function and find out it can be applied here to solve this question.\\n\\n# z_function\\nIf you dont know what is z function, pls refer to:\\n[1] https://leetcode.com/problems/sum-of-scores-of-built-strings/discuss/1907066/C%2B%2B-or-Z-Function-or-Resources-to-learn\\n[2] https://leetcode.com/problems/sum-of-scores-of-built-strings/discuss/1906961/Python-z-funcion-solution-explained.\\n\\n# Strategy\\n## [1] contruct a double size string by:\\nfor our original string input s: `s = s1, s2, ..., sn`\\nss = s1, s2, ..., sn-1, sn, sn, sn-1, ..., s2, s1\\n\\n## [2] let\\'s calculate the z_function for ss\\n\\nss[0] = 0 (by defination\\nss[1] = longest sub string include head for following two string\\n```\\ns1, s2, ..., sn-1, sn, sn, sn-1, ..., s2\\ns2, ..., sn-1, sn, sn, sn-1, ..., s2, s1\\n```\\nss[2] = longest sub string include head for following two string\\n```\\ns1, s2, ..., sn-1, sn, sn, sn-1, ..., s3\\ns3, ..., sn-1, sn, sn, sn-1, ..., s2, s1\\n```\\n...\\n\\nss[n] = longest sub string include head for following two string\\n```\\ns1, s2, ..., sn-1, sn\\nsn, sn-1, ..., s2, s1\\n```\\n...\\nss[n+k] =  longest sub string include head for following two string\\n```\\ns1,...,sn-k\\nsn-k,...,s1\\n```\\n...\\nss[2*n-2] =  longest sub string include head for following two string\\n```\\ns1,s2\\ns2,s1\\n```\\nss[2*n-1] =  longest sub string include head for following two string\\n```\\ns1\\ns1\\n```\\n\\n## [3] let\\'s use z_function of ss to get our longest palindrome sub_string include the head\\nso we can check for z_array[n] to z_array[2*n-1]\\nif z_array[n] length is n, then by above argument\\n```\\ns1, s2, ..., sn-1, sn\\nsn, sn-1, ..., s2, s1\\n```\\nwe get `s1 ... sn` == `sn...s1`\\nif z_array[n+k] length is n-k, then by above argument\\n```\\ns1,...sn-k\\nsn-k,...s1\\n```\\nwe get `s1 ... sn-k` == `sn-k...s1`\\nThus we can get max_palindrome_include_the_head of s.\\n\\n## [4] the last step would be to output the ans which will be\\n```\\nmax_palindrome_substring_include_head = s[:max_length]\\nright_str = s[max_length:]\\nleft_str = s[max_length:][::-1]\\nans = left_str + max_palindrome_substring_include_head + right_str\\n```\\n\\n# Solutions\\n\\nHere is the details implementation for above strategy:\\n\\n```\\nclass Solution(object):\\n    def shortestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        palindrome_include_head = self.get_longest_palindrome_include_head(s)\\n        right_str = s[len(palindrome_include_head):]\\n        left_str = right_str[::-1]\\n        return \"{}{}{}\".format(left_str, palindrome_include_head, right_str)\\n\\n    def get_longest_palindrome_include_head(self, s):\\n        n = len(s)\\n        ss = s + s[::-1]\\n        z_array_of_ss = self.get_z_array(ss)\\n        max_length = 0\\n        for idx in range(n, 2*n):\\n            if z_array_of_ss[idx] == 2*n-idx:\\n                max_length = z_array_of_ss[idx]\\n                break  # do early return because the rest of length would be smaller coz for 2*n-idx (idx keep increasing\\n        return s[:max_length]\\n\\n    def get_z_array(self, s):\\n        n = len(s)\\n        z = [0 for _ in range(n)]\\n        l, r = 0, 0\\n        for i in range(1, n):\\n            if i<=r:\\n                z[i] = min(z[i-l], r-i+1)\\n            while i + z[i] < n and s[z[i]] == s[i+z[i]]:\\n                z[i] += 1\\n            if i + z[i] - 1 > r:\\n                l, r = i, i + z[i] - 1\\n        return z\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ns1, s2, ..., sn-1, sn, sn, sn-1, ..., s2\\ns2, ..., sn-1, sn, sn, sn-1, ..., s2, s1\\n```\n```\\ns1, s2, ..., sn-1, sn, sn, sn-1, ..., s3\\ns3, ..., sn-1, sn, sn, sn-1, ..., s2, s1\\n```\n```\\ns1, s2, ..., sn-1, sn\\nsn, sn-1, ..., s2, s1\\n```\n```\\ns1,...,sn-k\\nsn-k,...,s1\\n```\n```\\ns1,s2\\ns2,s1\\n```\n```\\ns1\\ns1\\n```\n```\\ns1, s2, ..., sn-1, sn\\nsn, sn-1, ..., s2, s1\\n```\n```\\ns1,...sn-k\\nsn-k,...s1\\n```\n```\\nmax_palindrome_substring_include_head = s[:max_length]\\nright_str = s[max_length:]\\nleft_str = s[max_length:][::-1]\\nans = left_str + max_palindrome_substring_include_head + right_str\\n```\n```\\nclass Solution(object):\\n    def shortestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        palindrome_include_head = self.get_longest_palindrome_include_head(s)\\n        right_str = s[len(palindrome_include_head):]\\n        left_str = right_str[::-1]\\n        return \"{}{}{}\".format(left_str, palindrome_include_head, right_str)\\n\\n    def get_longest_palindrome_include_head(self, s):\\n        n = len(s)\\n        ss = s + s[::-1]\\n        z_array_of_ss = self.get_z_array(ss)\\n        max_length = 0\\n        for idx in range(n, 2*n):\\n            if z_array_of_ss[idx] == 2*n-idx:\\n                max_length = z_array_of_ss[idx]\\n                break  # do early return because the rest of length would be smaller coz for 2*n-idx (idx keep increasing\\n        return s[:max_length]\\n\\n    def get_z_array(self, s):\\n        n = len(s)\\n        z = [0 for _ in range(n)]\\n        l, r = 0, 0\\n        for i in range(1, n):\\n            if i<=r:\\n                z[i] = min(z[i-l], r-i+1)\\n            while i + z[i] < n and s[z[i]] == s[i+z[i]]:\\n                z[i] += 1\\n            if i + z[i] - 1 > r:\\n                l, r = i, i + z[i] - 1\\n        return z\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1773426,
                "title": "solution-swift-shortest-palindrome-test-cases",
                "content": "```swift\\nclass Solution {\\n    func shortestPalindrome(_ s: String) -> String {\\n        let len = s.count\\n        let arr = Array(s), arrRev = Array(s.reversed())\\n        for i in 0..<len where arr.prefix(len - i) == arrRev.suffix(len - i) {\\n            return arrRev.prefix(i - 0) + s\\n        }\\n        return \"\"\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 2 tests, with 0 failures (0 unexpected) in 0.005 (0.007) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.shortestPalindrome(\"aacecaaa\")\\n        XCTAssertEqual(value, \"aaacecaaa\")\\n    }\\n    \\n    func test1() {\\n        let value = solution.shortestPalindrome(\"abcd\")\\n        XCTAssertEqual(value, \"dcbabcd\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func shortestPalindrome(_ s: String) -> String {\\n        let len = s.count\\n        let arr = Array(s), arrRev = Array(s.reversed())\\n        for i in 0..<len where arr.prefix(len - i) == arrRev.suffix(len - i) {\\n            return arrRev.prefix(i - 0) + s\\n        }\\n        return \"\"\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.shortestPalindrome(\"aacecaaa\")\\n        XCTAssertEqual(value, \"aaacecaaa\")\\n    }\\n    \\n    func test1() {\\n        let value = solution.shortestPalindrome(\"abcd\")\\n        XCTAssertEqual(value, \"dcbabcd\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756459,
                "title": "clean-z-function-solution-in-o-n-space-and-time-complexity",
                "content": "Time Complexity = O(N) \\nSpace Complexity = O(N)  \\n\\n``` \\nstring shortestPalindrome(string s) {\\n         string str = s + \"$\";\\n         string te = s;\\n         int n = s.size();\\n        if(n < 2)\\n            return s;\\n         reverse(s.begin(),s.end());\\n         str += s;\\n         vector<int> z(str.size());\\n        \\n         int l = 0, r = 0;\\n         for(int i = 1 ; i < str.size() ; i++){\\n             if(i > r){\\n                 l = r = i;\\n                 while(r < str.size() && str[r] == str[r-l])\\n                      r++;\\n                 z[i] = r-l;\\n                 r--;\\n             }\\n             else{\\n                 int idx = i - l;\\n                 if(i + z[idx] <= r)\\n                   z[i] = z[idx];\\n                 else{\\n                     l = i;\\n                     while(r < str.size() && str[r] == str[r-l])\\n                         r++;\\n                     z[i] = r-l;\\n                     r--;\\n                 }\\n             }\\n         }\\n        \\n        int pos = -1;\\n        for(int i = n + 1 ; i < str.size() ; i++){\\n                int temp = n - (str.size() - i);\\n                if(temp + z[i] >= n){\\n                    pos = temp;\\n                    break;\\n                }\\n        } \\n        str = s.substr(0,pos);\\n        str += te;\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "``` \\nstring shortestPalindrome(string s) {\\n         string str = s + \"$\";\\n         string te = s;\\n         int n = s.size();\\n        if(n < 2)\\n            return s;\\n         reverse(s.begin(),s.end());\\n         str += s;\\n         vector<int> z(str.size());\\n        \\n         int l = 0, r = 0;\\n         for(int i = 1 ; i < str.size() ; i++){\\n             if(i > r){\\n                 l = r = i;\\n                 while(r < str.size() && str[r] == str[r-l])\\n                      r++;\\n                 z[i] = r-l;\\n                 r--;\\n             }\\n             else{\\n                 int idx = i - l;\\n                 if(i + z[idx] <= r)\\n                   z[i] = z[idx];\\n                 else{\\n                     l = i;\\n                     while(r < str.size() && str[r] == str[r-l])\\n                         r++;\\n                     z[i] = r-l;\\n                     r--;\\n                 }\\n             }\\n         }\\n        \\n        int pos = -1;\\n        for(int i = n + 1 ; i < str.size() ; i++){\\n                int temp = n - (str.size() - i);\\n                if(temp + z[i] >= n){\\n                    pos = temp;\\n                    break;\\n                }\\n        } \\n        str = s.substr(0,pos);\\n        str += te;\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1665104,
                "title": "python3-groupby-solution-without-kmp",
                "content": "```python\\nclass Solution1:\\n    def shortestPalindrome(self, s: str) -> str:\\n        \"\"\"We create two new arrays to represent the original string. We use\\n        `groupby` to count the number of repeats of each consecutive letters\\n        and record them in two arrays. One is letters, recording all\\n        consecutively distinct letters. The other is indices, recording the\\n        index of the last appearance of the corresponding letter in letters.\\n\\n        Let idx = len(indices) - 2. We want to examine whether a palindrome can\\n        be formed from the start of s with the repeats of letters[idx] being in\\n        the middle. There are three scenarios.\\n\\n        1. idx reaches the first letter and still no palindrome insight. We\\n        need to reverse the substring starting from indices[idx + 1] to the end\\n        and add it to the front of s.\\n        \\n        2. A palindrome is found when idx is not pointing to the first letter\\n        of s. This means we just need to reverse the remaining of s outside the\\n        palindrome and add it to the front of s.\\n\\n        3. idx has not reached the first letter of s, yet a palindrome almost\\n        forms. By almost forms, it means that the palindrome check has reaches\\n        the first letter and the first letter is equal to the last letter in\\n        the current palindrome check, yet the number of repeats of these two\\n        do not match. In particular, the number of repeats of the first letter\\n        is smaller than that of the last letter in check. In this case, we can\\n        simply add to the front the difference in count between the first and\\n        the last letter to form the palindrome, and then add the reversed\\n        remaining substring to the front.\\n\\n        O(N), 56 ms, 73% ranking.\\n        \"\"\"\\n        letters = [\\'#\\']\\n        indices = [-1]\\n        for k, g in groupby(s):\\n            letters.append(k)\\n            indices.append(indices[-1] + len(list(g)))\\n        idx = len(indices) - 2\\n        while idx >= 0:\\n            # scenario 1\\n            if idx == 1:\\n                return s[:indices[1]:-1] + s\\n            # palindrome check\\n            lo, hi = idx - 1, idx + 1\\n            while lo >= 1 and hi < len(indices):\\n                if letters[lo] != letters[hi] or (indices[lo] - indices[lo - 1]) != (indices[hi] - indices[hi - 1]):\\n                    break\\n                lo -= 1\\n                hi += 1\\n            # scenario 2\\n            if lo == 0:\\n                return s[:indices[hi - 1]:-1] + s\\n            # scenario 3\\n            if lo == 1 and hi < len(indices) and letters[lo] == letters[hi]:\\n                dif = (indices[hi] - indices[hi - 1]) - (indices[lo] - indices[lo - 1])\\n                if dif > 0:\\n                    return s[:indices[hi]:-1] + letters[lo] * dif + s\\n            idx -= 1\\n        return s\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution1:\\n    def shortestPalindrome(self, s: str) -> str:\\n        \"\"\"We create two new arrays to represent the original string. We use\\n        `groupby` to count the number of repeats of each consecutive letters\\n        and record them in two arrays. One is letters, recording all\\n        consecutively distinct letters. The other is indices, recording the\\n        index of the last appearance of the corresponding letter in letters.\\n\\n        Let idx = len(indices) - 2. We want to examine whether a palindrome can\\n        be formed from the start of s with the repeats of letters[idx] being in\\n        the middle. There are three scenarios.\\n\\n        1. idx reaches the first letter and still no palindrome insight. We\\n        need to reverse the substring starting from indices[idx + 1] to the end\\n        and add it to the front of s.\\n        \\n        2. A palindrome is found when idx is not pointing to the first letter\\n        of s. This means we just need to reverse the remaining of s outside the\\n        palindrome and add it to the front of s.\\n\\n        3. idx has not reached the first letter of s, yet a palindrome almost\\n        forms. By almost forms, it means that the palindrome check has reaches\\n        the first letter and the first letter is equal to the last letter in\\n        the current palindrome check, yet the number of repeats of these two\\n        do not match. In particular, the number of repeats of the first letter\\n        is smaller than that of the last letter in check. In this case, we can\\n        simply add to the front the difference in count between the first and\\n        the last letter to form the palindrome, and then add the reversed\\n        remaining substring to the front.\\n\\n        O(N), 56 ms, 73% ranking.\\n        \"\"\"\\n        letters = [\\'#\\']\\n        indices = [-1]\\n        for k, g in groupby(s):\\n            letters.append(k)\\n            indices.append(indices[-1] + len(list(g)))\\n        idx = len(indices) - 2\\n        while idx >= 0:\\n            # scenario 1\\n            if idx == 1:\\n                return s[:indices[1]:-1] + s\\n            # palindrome check\\n            lo, hi = idx - 1, idx + 1\\n            while lo >= 1 and hi < len(indices):\\n                if letters[lo] != letters[hi] or (indices[lo] - indices[lo - 1]) != (indices[hi] - indices[hi - 1]):\\n                    break\\n                lo -= 1\\n                hi += 1\\n            # scenario 2\\n            if lo == 0:\\n                return s[:indices[hi - 1]:-1] + s\\n            # scenario 3\\n            if lo == 1 and hi < len(indices) and letters[lo] == letters[hi]:\\n                dif = (indices[hi] - indices[hi - 1]) - (indices[lo] - indices[lo - 1])\\n                if dif > 0:\\n                    return s[:indices[hi]:-1] + letters[lo] * dif + s\\n            idx -= 1\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1609717,
                "title": "go-a-simple-xor-trick-improves-a-naive-solution-from-100ms-to-0ms-still-o-n-2-worst-case-though",
                "content": "If we xor together all characters in a palindrome, the result will be 0 for even length ones or the middle letter for odd length. This is used an a preliminary O(1) check, and only then the real O(N) check is performed.\\n\\n```\\nfunc shortestPalindrome(s string) string {\\n  // calculate xor of the entire string\\n  x := byte(0)\\n  for _, b := range []byte(s) {\\n    x ^= b\\n  }\\n  \\n  for i := len(s); i > 0; i-- {\\n    // check the len i prefix\\n    if (i&1 == 0 && x == 0 || i&1 == 1 && x == s[i/2]) && check(s[0:i]) {\\n\\t  // if it is a palindrome, reverse the rest of the string and prepend\\n      return reverse(s[i:]) + s\\n    }\\n    \\n\\t// unxor the current char before trying a smaller prefix\\n    x ^= s[i-1]\\n  }\\n  \\n  // should only get here in case of an empty input\\n  return \"\"\\n}\\n\\nfunc check(s string) bool {\\n  for i, j := 0, len(s)-1; i<j; i, j = i+1, j-1 {\\n    if s[i] != s[j] {\\n      return false\\n    }\\n  }\\n  \\n  return true\\n}\\n\\nfunc reverse(s string) string {\\n  bs := []byte(s)\\n  for i, j := 0, len(bs)-1; i<j; i, j = i+1, j-1 {\\n    bs[i], bs[j] = bs[j], bs[i]\\n  }\\n  \\n  return string(bs)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc shortestPalindrome(s string) string {\\n  // calculate xor of the entire string\\n  x := byte(0)\\n  for _, b := range []byte(s) {\\n    x ^= b\\n  }\\n  \\n  for i := len(s); i > 0; i-- {\\n    // check the len i prefix\\n    if (i&1 == 0 && x == 0 || i&1 == 1 && x == s[i/2]) && check(s[0:i]) {\\n\\t  // if it is a palindrome, reverse the rest of the string and prepend\\n      return reverse(s[i:]) + s\\n    }\\n    \\n\\t// unxor the current char before trying a smaller prefix\\n    x ^= s[i-1]\\n  }\\n  \\n  // should only get here in case of an empty input\\n  return \"\"\\n}\\n\\nfunc check(s string) bool {\\n  for i, j := 0, len(s)-1; i<j; i, j = i+1, j-1 {\\n    if s[i] != s[j] {\\n      return false\\n    }\\n  }\\n  \\n  return true\\n}\\n\\nfunc reverse(s string) string {\\n  bs := []byte(s)\\n  for i, j := 0, len(bs)-1; i<j; i, j = i+1, j-1 {\\n    bs[i], bs[j] = bs[j], bs[i]\\n  }\\n  \\n  return string(bs)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1545007,
                "title": "javascript-solution",
                "content": "```\\nvar shortestPalindrome = function(s) {\\n    let index = 0;\\n    \\n    for(let i = s.length - 1; i >= 0; i--) {\\n        if(s[i] === s[index]) index++;\\n    }\\n    \\n    if(index === s.length) return s;\\n    \\n    let remainingRev = s.substring(index, s.length);\\n    remainingRev = reverse(remainingRev, 0 , remainingRev.length - 1);\\n    \\n    return remainingRev + shortestPalindrome(s.substring(0, index)) + s.substring(index);\\n    \\n    function reverse(string, i, j) {\\n        let arr = string.split(\\'\\');\\n        \\n        while(i < j) {\\n            let temp = arr[i];\\n            arr[i++] = arr[j];\\n            arr[j--] = temp;\\n        }\\n        return arr.join(\\'\\');\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shortestPalindrome = function(s) {\\n    let index = 0;\\n    \\n    for(let i = s.length - 1; i >= 0; i--) {\\n        if(s[i] === s[index]) index++;\\n    }\\n    \\n    if(index === s.length) return s;\\n    \\n    let remainingRev = s.substring(index, s.length);\\n    remainingRev = reverse(remainingRev, 0 , remainingRev.length - 1);\\n    \\n    return remainingRev + shortestPalindrome(s.substring(0, index)) + s.substring(index);\\n    \\n    function reverse(string, i, j) {\\n        let arr = string.split(\\'\\');\\n        \\n        while(i < j) {\\n            let temp = arr[i];\\n            arr[i++] = arr[j];\\n            arr[j--] = temp;\\n        }\\n        return arr.join(\\'\\');\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1466293,
                "title": "c-o-n-using-pre-processing-part-of-kmp-algoritm",
                "content": "```\\nclass Solution {\\npublic:\\n    int fun(string& s)\\n    {\\n        int n=s.length();\\n        vector<int> lps(n);\\n        int len=0;\\n        lps[0]=0;\\n        int i=1;\\n        while(i<n)\\n        {\\n            if(s[len]==s[i])\\n            {\\n                len++;\\n                lps[i]=len;\\n                i++;\\n            }\\n            else\\n            {\\n                if(len!=0)len=lps[len-1];\\n                else\\n                {\\n                    lps[i]=0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps[n-1];\\n    }\\n    string shortestPalindrome(string s) {\\n        string s1=s;\\n        int n=s.length();\\n        reverse(s1.begin(),s1.end());\\n        string res=s+\"#\"+s1;\\n        int x=fun(res);\\n        string ans;\\n        // cout<<n-x<<endl;\\n        for(int i=0;i<n-x;i++)\\n        {\\n            ans.push_back(s1[i]);\\n        }\\n        ans+=s;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(string& s)\\n    {\\n        int n=s.length();\\n        vector<int> lps(n);\\n        int len=0;\\n        lps[0]=0;\\n        int i=1;\\n        while(i<n)\\n        {\\n            if(s[len]==s[i])\\n            {\\n                len++;\\n                lps[i]=len;\\n                i++;\\n            }\\n            else\\n            {\\n                if(len!=0)len=lps[len-1];\\n                else\\n                {\\n                    lps[i]=0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps[n-1];\\n    }\\n    string shortestPalindrome(string s) {\\n        string s1=s;\\n        int n=s.length();\\n        reverse(s1.begin(),s1.end());\\n        string res=s+\"#\"+s1;\\n        int x=fun(res);\\n        string ans;\\n        // cout<<n-x<<endl;\\n        for(int i=0;i<n-x;i++)\\n        {\\n            ans.push_back(s1[i]);\\n        }\\n        ans+=s;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1379987,
                "title": "simple-2-pointer-approach-iterative-accepted",
                "content": "```\\npublic class Solution {\\n        \\n    public string ShortestPalindrome(string s) {\\n        \\n        if(s.Length<2) return s;\\n               \\n        var i = GetPalindrome(s);\\n                \\n        var revString = Reverse(s.Substring(i,s.Length-i));\\n\\n        return revString + s;\\n    }\\n    \\n    public string Reverse( string s )\\n    {\\n        char[] charArray = s.ToCharArray();\\n        Array.Reverse( charArray );\\n        return new string( charArray );\\n    }\\n    \\n    public int GetPalindrome(string s)\\n    {        \\n        int left=0; \\n        int right=s.Length-1; \\n        int last = right;\\n        while(left<=last)\\n        {\\n            while(left<=right)\\n            {\\n                if(s[left]==s[right])\\n                {\\n                    right--;\\n                    left++;\\n                    \\n                    if(left>=right) return ++last;\\n                    continue;\\n                }\\n                else \\n                {                    \\n                    last--;\\n                    right = last;\\n                    left=0;\\n                    break;\\n                }\\n            }\\n        }\\n        return 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Iterator"
                ],
                "code": "```\\npublic class Solution {\\n        \\n    public string ShortestPalindrome(string s) {\\n        \\n        if(s.Length<2) return s;\\n               \\n        var i = GetPalindrome(s);\\n                \\n        var revString = Reverse(s.Substring(i,s.Length-i));\\n\\n        return revString + s;\\n    }\\n    \\n    public string Reverse( string s )\\n    {\\n        char[] charArray = s.ToCharArray();\\n        Array.Reverse( charArray );\\n        return new string( charArray );\\n    }\\n    \\n    public int GetPalindrome(string s)\\n    {        \\n        int left=0; \\n        int right=s.Length-1; \\n        int last = right;\\n        while(left<=last)\\n        {\\n            while(left<=right)\\n            {\\n                if(s[left]==s[right])\\n                {\\n                    right--;\\n                    left++;\\n                    \\n                    if(left>=right) return ++last;\\n                    continue;\\n                }\\n                else \\n                {                    \\n                    last--;\\n                    right = last;\\n                    left=0;\\n                    break;\\n                }\\n            }\\n        }\\n        return 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1358043,
                "title": "c-solution-with-67-faster",
                "content": "```\\npublic class Solution {\\n    public string ShortestPalindrome(string s) {\\n        int maxLen = 0;\\n        for(int i = s.Length-1; i>=0; i--)\\n        {\\n            int start = 0;\\n            int end = i;\\n            while(start<= end)\\n            {\\n                if(s[start] == s[end])\\n                {\\n                    start++;  \\n\\t\\t\\t\\t\\tend--;                   \\n                }\\n                else\\n                    break;\\n            }\\n            \\n            if(end< start)\\n            {\\n                maxLen = i+1;\\n                break;\\n            }            \\n        }        \\n        char[] addition = s.Substring(maxLen).Reverse().ToArray();        \\n        return new string(addition) + s; \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public string ShortestPalindrome(string s) {\\n        int maxLen = 0;\\n        for(int i = s.Length-1; i>=0; i--)\\n        {\\n            int start = 0;\\n            int end = i;\\n            while(start<= end)\\n            {\\n                if(s[start] == s[end])\\n                {\\n                    start++;  \\n\\t\\t\\t\\t\\tend--;                   \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1339178,
                "title": "120-120-test-cases-passed-but-took-too-long-please-guide-me-where-i-am-wrong",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(string s){\\n        int i=0,j=s.length()-1;\\n        while(i<j){\\n            if(s[i]!=s[j]){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    string reverse(string s){\\n        string p=\"\";\\n        for(int i=s.length()-1;i>=0;i--){\\n            p+=s[i];\\n        }\\n        return p;\\n    }\\n    string shortestPalindrome(string s) {\\n        int n=s.length();\\n        if(check(s)){\\n            return s;\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            int j=0,k=i;\\n            while(j<k){\\n                if(s[j]!=s[k]){\\n                    j=-1;\\n                    break;\\n                }\\n                j++,k--;\\n            }\\n            if(j!=-1){\\n                string p=s.substr(i+1,n-1-i);\\n                p=reverse(p);\\n                s=p+s;\\n                return s;\\n            }\\n           \\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string s){\\n        int i=0,j=s.length()-1;\\n        while(i<j){\\n            if(s[i]!=s[j]){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    string reverse(string s){\\n        string p=\"\";\\n        for(int i=s.length()-1;i>=0;i--){\\n            p+=s[i];\\n        }\\n        return p;\\n    }\\n    string shortestPalindrome(string s) {\\n        int n=s.length();\\n        if(check(s)){\\n            return s;\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            int j=0,k=i;\\n            while(j<k){\\n                if(s[j]!=s[k]){\\n                    j=-1;\\n                    break;\\n                }\\n                j++,k--;\\n            }\\n            if(j!=-1){\\n                string p=s.substr(i+1,n-1-i);\\n                p=reverse(p);\\n                s=p+s;\\n                return s;\\n            }\\n           \\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1319841,
                "title": "ugly-hashing-solution",
                "content": "Basically If you add x numbers you would want them to match first x numbers of the original array and the remaining original array should be a palindrome . \\nSo our task is to find the minimum length of prefix that if we leave it, the remaining string should be a palindrome. \\nFor a string of length n, we can prove that it is a palindrome by comparing its first n/2 character to the last n/2 characters in reversed order. If they are equal then it is a palindrome otherwise not. And we have used hashing to make that comparison. We have used two hashes to make sure that the probability of getting same hash function from two different strings is quite less. \\n```\\nclass Solution {\\npublic:\\n  #define int long long\\n  int power(int a,int b,int mod){\\n    if(b==0)return 1; \\n    int u=power(a,b/2,mod);\\n    u=(u*u)%mod; \\n    if(b&1)u=(u*a)%mod; \\n    return u; \\n  }\\n    string shortestPalindrome(string s) {\\n\\t reverse(s.begin(),s.end());  // Since we have written code for adding characters at the end of the string so we have to first reverse our string. \\n\\t \\n\\tint hash[s.size()+1][2]; // To store the hash function  of all the prefixes \\n\\t// Now hash array is 2D because we are creating two different hashes one for p=37 and mod =1e9+7 and other for p=43 and mod =1e8+7\\n    hash[0][0]=hash[0][1]=0; \\n\\t//Two mod values \\n    int mod[2]={(int)1e9+7,(int)1e8+7};\\n\\t// pp stores the value of ith prime for which we are creating ith hash \\n    int pp[2]={37,43};\\n\\t// p will store the value of ith prime^(prefix_length) since for first element of string its prefix length will be we have initialised it with the value of prime number for ith hash \\n    int p[2]={37,43};\\n\\t// It pw[i][j] stores inverse of pp[j]^i % mod[j]\\n    int pw[s.size()+1][2]; \\n    pw[0][0]=pw[0][1]=1; \\n\\t// ipp [i] store inverse of pp[i] \\n    int ipp[2]={power(37,mod[0]-2,mod[0]),power(43,mod[1]-2,mod[1])};\\n\\t// evaluating pw[i][j] with the help of pw[i-1][j] \\n    for(int i=0;i<s.size();i++)for(int j=0;j<2;j++)pw[i+1][j]=pw[i][j]*ipp[j]%mod[j];\\n\\t// Evaluating hashes for every prefix \\n    for(int i=0;i<s.size();i++)\\n    {\\n      for(int j=0;j<2;j++)hash[i+1][j]=(hash[i][j]+p[j]*(s[i]-\\'a\\'+1)%mod[j])%mod[j],p[j]=p[j]*pp[j]%mod[j]; \\n    }\\n\\t// It stores hashes for every suffix and we have evaluated in the similar way that we have used to calculate hash array \\n    int rhash[s.size()+1][2]; \\n    rhash[s.size()][0]=rhash[s.size()][1]=0; \\n    p[0]=37; p[1]=43; \\n    for(int i=s.size()-1;i>=0;i--)\\n    {\\n      for(int j=0;j<2;j++)rhash[i][j]=(rhash[i+1][j]+p[j]*(s[i]-\\'a\\'+1)%mod[j])%mod[j],p[j]=p[j]*pp[j]%mod[j]; \\n    }\\n    int ans=s.size(); \\n    for(int i=s.size()-1;i>=0;i--)\\n    {\\n      int left=s.size()-i; \\n      bool ok=1; \\n      for(int j=0;j<2;j++)\\n      {\\n        int hasha=(hash[i+left/2][j]-hash[i][j]+mod[j])%mod[j];\\n        hasha=hasha*pw[i][j]%mod[j]; \\n        int hashb=rhash[s.size()-left/2][j]; \\n        if(hasha!=hashb)ok=0; \\n      }\\n      if(ok)ans=i; \\n    }\\n      string toadd=\"\"; \\n      for(int i=0;i<ans;i++)toadd+=s[i]; \\n      reverse(toadd.begin(),toadd.end()); \\n      s+=toadd;\\n      reverse(s.begin(),s.end()); \\n      return s; \\n      \\n      \\n    \\n      \\n      \\n    }\\n  #undef int \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  #define int long long\\n  int power(int a,int b,int mod){\\n    if(b==0)return 1; \\n    int u=power(a,b/2,mod);\\n    u=(u*u)%mod; \\n    if(b&1)u=(u*a)%mod; \\n    return u; \\n  }\\n    string shortestPalindrome(string s) {\\n\\t reverse(s.begin(),s.end());  // Since we have written code for adding characters at the end of the string so we have to first reverse our string. \\n\\t \\n\\tint hash[s.size()+1][2]; // To store the hash function  of all the prefixes \\n\\t// Now hash array is 2D because we are creating two different hashes one for p=37 and mod =1e9+7 and other for p=43 and mod =1e8+7\\n    hash[0][0]=hash[0][1]=0; \\n\\t//Two mod values \\n    int mod[2]={(int)1e9+7,(int)1e8+7};\\n\\t// pp stores the value of ith prime for which we are creating ith hash \\n    int pp[2]={37,43};\\n\\t// p will store the value of ith prime^(prefix_length) since for first element of string its prefix length will be we have initialised it with the value of prime number for ith hash \\n    int p[2]={37,43};\\n\\t// It pw[i][j] stores inverse of pp[j]^i % mod[j]\\n    int pw[s.size()+1][2]; \\n    pw[0][0]=pw[0][1]=1; \\n\\t// ipp [i] store inverse of pp[i] \\n    int ipp[2]={power(37,mod[0]-2,mod[0]),power(43,mod[1]-2,mod[1])};\\n\\t// evaluating pw[i][j] with the help of pw[i-1][j] \\n    for(int i=0;i<s.size();i++)for(int j=0;j<2;j++)pw[i+1][j]=pw[i][j]*ipp[j]%mod[j];\\n\\t// Evaluating hashes for every prefix \\n    for(int i=0;i<s.size();i++)\\n    {\\n      for(int j=0;j<2;j++)hash[i+1][j]=(hash[i][j]+p[j]*(s[i]-\\'a\\'+1)%mod[j])%mod[j],p[j]=p[j]*pp[j]%mod[j]; \\n    }\\n\\t// It stores hashes for every suffix and we have evaluated in the similar way that we have used to calculate hash array \\n    int rhash[s.size()+1][2]; \\n    rhash[s.size()][0]=rhash[s.size()][1]=0; \\n    p[0]=37; p[1]=43; \\n    for(int i=s.size()-1;i>=0;i--)\\n    {\\n      for(int j=0;j<2;j++)rhash[i][j]=(rhash[i+1][j]+p[j]*(s[i]-\\'a\\'+1)%mod[j])%mod[j],p[j]=p[j]*pp[j]%mod[j]; \\n    }\\n    int ans=s.size(); \\n    for(int i=s.size()-1;i>=0;i--)\\n    {\\n      int left=s.size()-i; \\n      bool ok=1; \\n      for(int j=0;j<2;j++)\\n      {\\n        int hasha=(hash[i+left/2][j]-hash[i][j]+mod[j])%mod[j];\\n        hasha=hasha*pw[i][j]%mod[j]; \\n        int hashb=rhash[s.size()-left/2][j]; \\n        if(hasha!=hashb)ok=0; \\n      }\\n      if(ok)ans=i; \\n    }\\n      string toadd=\"\"; \\n      for(int i=0;i<ans;i++)toadd+=s[i]; \\n      reverse(toadd.begin(),toadd.end()); \\n      s+=toadd;\\n      reverse(s.begin(),s.end()); \\n      return s; \\n      \\n      \\n    \\n      \\n      \\n    }\\n  #undef int \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1280654,
                "title": "100-faster-finding-longest-prefix-that-is-also-a-suffix",
                "content": "Concatenate the given string with a special character and then with reverse of the given string. Now find the lps array (longest prefix that is also a suffix) that we find in KMP algorithm. The last index of the lps array gives the length of prefix string that is a palindrome. So now copy the remaining part of the string in front of it after reversing it to get the required string.\\n\\nclass Solution {\\npublic:\\n   \\n    string shortestPalindrome(string s) {\\n        \\n        string st=s;\\n        st+=\\'$\\';\\n        reverse(s.begin(), s.end());\\n        st+=s;\\n        int m=st.length();\\n        reverse(s.begin(), s.end());\\n        \\n        int* lps=getLps(st);\\n        \\n        int k=lps[m-1];\\n        \\n        string s2=s.substr(k);\\n        reverse(s2.begin(), s2.end());\\n        s2+=s;\\n        \\n        return s2;\\n    }\\n\\t int* getLps(string s){\\n        int n=s.length();\\n        int* lps=new int[n]();\\n        \\n        int i=1, j=0;\\n        \\n        while(i<n){\\n            if(s[i]==s[j]){\\n                lps[i]=j+1;\\n                i++;\\n                j++;\\n            }else{\\n                if(j!=0){\\n                    j=lps[j-1];\\n                }else{\\n                  lps[i]=0;\\n                  i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n};\\n100% faster ( Finding longest prefix that is also a suffix)",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n   \\n    string shortestPalindrome(string s) {\\n        \\n        string st=s;\\n        st+=\\'$\\';\\n        reverse(s.begin(), s.end());\\n        st+=s;\\n        int m=st.length();\\n        reverse(s.begin(), s.end());\\n        \\n        int* lps=getLps(st);\\n        \\n        int k=lps[m-1];\\n        \\n        string s2=s.substr(k);\\n        reverse(s2.begin(), s2.end());\\n        s2+=s;\\n        \\n        return s2;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1154831,
                "title": "beats-100-c-kmp",
                "content": "\\n    vector<int> pre(string s){\\n        int n = s.length();\\n        vector<int> lps(n,0);\\n        int i=1,j=0;\\n        \\n        while(i < n){\\n            if(s[i]==s[j]){\\n                lps[i] = j+1;\\n                i++,j++;\\n            }else{\\n                if(j==0)lps[i++] = 0;\\n                else j = lps[j-1];\\n            }\\n        }\\n        return lps;\\n    }\\n    string shortestPalindrome(string s) {\\n        string rev = s;\\n        reverse(rev.begin(),rev.end());\\n        vector<int> lps = pre(s+\"#\"+rev);\\n        int n = s.length();\\n        int i = lps.back();\\n        string t = s.substr(i);\\n        reverse(t.begin(),t.end());\\n        return t+s;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    vector<int> pre(string s){\\n        int n = s.length();\\n        vector<int> lps(n,0);\\n        int i=1,j=0;\\n        \\n        while(i < n){\\n            if(s[i]==s[j]){\\n                lps[i] = j+1;\\n                i++,j++;\\n            }else{\\n                if(j==0)lps[i++] = 0;\\n                else j = lps[j-1];\\n            }\\n        }\\n        return lps;\\n    }\\n    string shortestPalindrome(string s) {\\n        string rev = s;\\n        reverse(rev.begin(),rev.end());\\n        vector<int> lps = pre(s+\"#\"+rev);\\n        int n = s.length();\\n        int i = lps.back();\\n        string t = s.substr(i);\\n        reverse(t.begin(),t.end());\\n        return t+s;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 960012,
                "title": "simple-javascript-solution-92ms-65-98",
                "content": "```/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar shortestPalindrome = function(s) {\\n    let reversedString = s.split(\"\").reverse().join(\"\");\\n    const oldReversedString = reversedString;\\n    const oldString = s;\\n    while (reversedString != s) {\\n      reversedString = reversedString.slice(1);\\n      s = s.slice(0, -1);\\n    }\\n    const extraLength = oldReversedString.length - reversedString.length;\\n    if (extraLength === 0) {\\n        return oldString;\\n    }\\n    return oldString.slice(-extraLength).split(\"\").reverse().join(\"\").concat(oldString);\\n};```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar shortestPalindrome = function(s) {\\n    let reversedString = s.split(\"\").reverse().join(\"\");\\n    const oldReversedString = reversedString;\\n    const oldString = s;\\n    while (reversedString != s) {\\n      reversedString = reversedString.slice(1);\\n      s = s.slice(0, -1);\\n    }\\n    const extraLength = oldReversedString.length - reversedString.length;\\n    if (extraLength === 0) {\\n        return oldString;\\n    }\\n    return oldString.slice(-extraLength).split(\"\").reverse().join(\"\").concat(oldString);\\n};```",
                "codeTag": "Unknown"
            },
            {
                "id": 937315,
                "title": "clear-logic",
                "content": "https://www.youtube.com/watch?v=c4akpqTwE5g&ab_channel=IDeserve\\n\\nThank you IDeserve channel for making this video :)",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=c4akpqTwE5g&ab_channel=IDeserve\\n\\nThank you IDeserve channel for making this video :)",
                "codeTag": "Unknown"
            },
            {
                "id": 773663,
                "title": "python-3-solution-short-code",
                "content": "Short and sweet solution just using string slicing:\\n```\\n    def shortestPalindrome(self, s: str) -> str:\\n        i = len(s)\\n        while not s[:i] == s[:i][::-1]:\\n            i -= 1\\n        return s[i:][::-1] + s \\n```",
                "solutionTags": [],
                "code": "```\\n    def shortestPalindrome(self, s: str) -> str:\\n        i = len(s)\\n        while not s[:i] == s[:i][::-1]:\\n            i -= 1\\n        return s[i:][::-1] + s \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 757369,
                "title": "c-easy-kmp-approach-explained-with-an-example",
                "content": "```\\n\\n    vector<int> table(string pattern) {\\n        int l = pattern.length();\\n        int i = 1;\\n        int j = 0;\\n        vector<int>res;\\n        res.push_back(0);\\n        while(i<l) {\\n            if (pattern[i] == pattern[j]) {\\n                res.push_back(j+1);\\n                i++;\\n                j++;\\n            }\\n            else {\\n                if (j != 0) {\\n                    j = res[j-1];\\n                }\\n                else {\\n                    res.push_back(0);\\n                    i++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    string shortestPalindrome(string s) {\\n        \\n        // idea: let s = ab\\n        // reverse of s = ba. now concatenate s + rev(s)\\n        // concat = abba =>palindrome\\n        // but probably not the shortest. \\'a\\' is the prefix which is also the suffix\\n        // The length of shortest prefix that\\'s also the suffix is 1,\\n\\t\\t// therefore, it means we need only 1 char to add to the front of the string.\\n\\t\\t// So first char of reverse string in this example is \"b\". Hence add \"b\" to front.\\n        // therefore shortest palindrome = \"bab\"\\n        \\n        string rev = s;\\n        reverse(rev.begin(), rev.end());\\n        string concat = s + \"$\" + rev;\\n        \\n        vector<int>prefix = table(concat);\\n        // The last entry of this table will denote\\n        // the length of longest suffix which is also the prefix\\n        \\n        \\n        // Chars_needed tells us how many chars we need from rev\\n        // string to make the shortest possible palindromic string\\n        int chars_needed = s.length()-prefix.back();\\n        int i = 0;\\n        string res = \"\";\\n        while(i < chars_needed) {\\n            res += rev[i];\\n            i++;\\n        }\\n        int j = 0;\\n        while(j < s.length()) {\\n            res += s[j];\\n            j++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\n\\n    vector<int> table(string pattern) {\\n        int l = pattern.length();\\n        int i = 1;\\n        int j = 0;\\n        vector<int>res;\\n        res.push_back(0);\\n        while(i<l) {\\n            if (pattern[i] == pattern[j]) {\\n                res.push_back(j+1);\\n                i++;\\n                j++;\\n            }\\n            else {\\n                if (j != 0) {\\n                    j = res[j-1];\\n                }\\n                else {\\n                    res.push_back(0);\\n                    i++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    string shortestPalindrome(string s) {\\n        \\n        // idea: let s = ab\\n        // reverse of s = ba. now concatenate s + rev(s)\\n        // concat = abba =>palindrome\\n        // but probably not the shortest. \\'a\\' is the prefix which is also the suffix\\n        // The length of shortest prefix that\\'s also the suffix is 1,\\n\\t\\t// therefore, it means we need only 1 char to add to the front of the string.\\n\\t\\t// So first char of reverse string in this example is \"b\". Hence add \"b\" to front.\\n        // therefore shortest palindrome = \"bab\"\\n        \\n        string rev = s;\\n        reverse(rev.begin(), rev.end());\\n        string concat = s + \"$\" + rev;\\n        \\n        vector<int>prefix = table(concat);\\n        // The last entry of this table will denote\\n        // the length of longest suffix which is also the prefix\\n        \\n        \\n        // Chars_needed tells us how many chars we need from rev\\n        // string to make the shortest possible palindromic string\\n        int chars_needed = s.length()-prefix.back();\\n        int i = 0;\\n        string res = \"\";\\n        while(i < chars_needed) {\\n            res += rev[i];\\n            i++;\\n        }\\n        int j = 0;\\n        while(j < s.length()) {\\n            res += s[j];\\n            j++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 646754,
                "title": "simple-brute-force-java-code",
                "content": "```\\n    public String shortestPalindrome(String s) {\\n        String r = new StringBuilder(s).reverse().toString();\\n        int n = s.length();\\n        for (int i = 0; i < n; i++) {\\n            if (r.substring(i).equals(s.substring(0, n-i))) {\\n                return r.substring(0, i) + s;\\n            }\\n        }\\n        return \"\";\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String shortestPalindrome(String s) {\\n        String r = new StringBuilder(s).reverse().toString();\\n        int n = s.length();\\n        for (int i = 0; i < n; i++) {\\n            if (r.substring(i).equals(s.substring(0, n-i))) {\\n                return r.substring(0, i) + s;\\n            }\\n        }\\n        return \"\";\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 644107,
                "title": "kmp-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s) {\\n        int n=s.size();\\n        string rev(s);\\n        reverse(rev.begin(),rev.end());\\n        string s_n=s+\"#\"+rev;\\n        cout<<s_n<<\"\\\\n\";\\n        vector<int> lps(s_n.size()+1);\\n        int k=0;\\n        lps[0]=0;\\n        for(int i=1;i<s_n.size();){\\n            if(s_n[i]==s_n[k]){\\n                k++;\\n                lps[i++]=k;\\n            }\\n            else{\\n                if(k!=0){\\n                    k=lps[k-1];\\n                }\\n                else{\\n                    k=0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return rev.substr(0,n-lps[s_n.size()-1])+s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s) {\\n        int n=s.size();\\n        string rev(s);\\n        reverse(rev.begin(),rev.end());\\n        string s_n=s+\"#\"+rev;\\n        cout<<s_n<<\"\\\\n\";\\n        vector<int> lps(s_n.size()+1);\\n        int k=0;\\n        lps[0]=0;\\n        for(int i=1;i<s_n.size();){\\n            if(s_n[i]==s_n[k]){\\n                k++;\\n                lps[i++]=k;\\n            }\\n            else{\\n                if(k!=0){\\n                    k=lps[k-1];\\n                }\\n                else{\\n                    k=0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return rev.substr(0,n-lps[s_n.size()-1])+s;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 498393,
                "title": "java-o-n-rabin-karp-solution",
                "content": "```\\nclass Solution {\\n    public Solution() {\\n        map.put(0, 1);\\n        map.put(1, base);\\n    }\\n    public String shortestPalindrome(String s) {\\n        if (s.length() <= 1) return s;\\n\\n        int left = 0;\\n        int right = 0;\\n        char[] c= s.toCharArray();\\n        int max = 0;\\n        int hashLeft = c[0] - \\'a\\';\\n        int hashRight = c[0] - \\'a\\';\\n        \\n        while (right + 1 < c.length) {\\n        \\thashRight = removeFirstAddLast(hashRight, right - left + 1, c[left], c[right + 1]);\\n        \\tif (hashRight == hashLeft) max = right + 1;\\n        \\t//System.out.println(hashLeft+ \" :: \" + hashRight + \" : \" + (left + 1)+\", \"+(right + 1) );\\n        \\tif (right + 2 == c.length) break;\\n        \\thashLeft = addFirst(hashLeft, left + 1, c[left + 1]);\\n        \\thashRight = addLast(hashRight, right - left + 2,  c[right + 2]);\\n        \\tif (hashLeft == hashRight) max = right + 2;\\n        \\t//System.out.println(hashLeft+ \" :: \" + hashRight + \" : \" + (left + 1)+\", \"+(right + 2) );\\n        \\tleft ++ ;\\n        \\tright += 2;\\n        }\\n        String rest = s.substring(max + 1);\\n        char[] r = rest.toCharArray();\\n        \\n        left = 0;\\n        right = r.length - 1;\\n        while (left < right){\\n            char temp = r[left];\\n            r[left] = r[right];\\n            r[right] = temp;\\n            left ++ ;\\n            right --;\\n        }\\n        return new String(r) + s;\\n    }\\n    final int modulus = 1000000;\\n    final int base= 31;\\n    HashMap<Integer, Integer> map = new HashMap<>();\\n    public int powerFun(int x) {\\n    \\tif (map.containsKey(x)) return map.get(x);\\n    \\tint y = powerFun(x - 1);\\n    \\ty *= base;\\n    \\ty %= modulus;\\n    \\tmap.put(x, y);\\n    \\treturn y;\\n    }\\n    \\n    public int addFirst(int val, int len, char c) {\\n    \\tint power = powerFun(len);\\n\\n    \\tval += (c - \\'a\\') * power;\\n    \\twhile (val < 0) val += modulus;\\n    \\treturn val % modulus;\\n    }\\n    \\n    public int removeFirstAddLast(int val, int len, char first, char last) {\\n    \\tint power = powerFun(len - 1);\\n    \\tval -= (first - \\'a\\') * power;\\n    \\twhile (val < 0) val += modulus;\\n    \\tval %= modulus;\\n    \\tval *= base;\\n    \\tval %= modulus;\\n    \\tval += last - \\'a\\';\\n    \\tval %= modulus;    \\t\\n    \\treturn val;\\n    }\\n    \\n    public int addLast(int val, int len, char c) {\\n    \\tval %= modulus;\\n    \\tval *= base;\\n    \\tval %= modulus;\\n    \\tval += c - \\'a\\';\\n    \\tval %= modulus;    \\t\\n    \\treturn val;\\n    }\\n\\t\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public Solution() {\\n        map.put(0, 1);\\n        map.put(1, base);\\n    }\\n    public String shortestPalindrome(String s) {\\n        if (s.length() <= 1) return s;\\n\\n        int left = 0;\\n        int right = 0;\\n        char[] c= s.toCharArray();\\n        int max = 0;\\n        int hashLeft = c[0] - \\'a\\';\\n        int hashRight = c[0] - \\'a\\';\\n        \\n        while (right + 1 < c.length) {\\n        \\thashRight = removeFirstAddLast(hashRight, right - left + 1, c[left], c[right + 1]);\\n        \\tif (hashRight == hashLeft) max = right + 1;\\n        \\t//System.out.println(hashLeft+ \" :: \" + hashRight + \" : \" + (left + 1)+\", \"+(right + 1) );\\n        \\tif (right + 2 == c.length) break;\\n        \\thashLeft = addFirst(hashLeft, left + 1, c[left + 1]);\\n        \\thashRight = addLast(hashRight, right - left + 2,  c[right + 2]);\\n        \\tif (hashLeft == hashRight) max = right + 2;\\n        \\t//System.out.println(hashLeft+ \" :: \" + hashRight + \" : \" + (left + 1)+\", \"+(right + 2) );\\n        \\tleft ++ ;\\n        \\tright += 2;\\n        }\\n        String rest = s.substring(max + 1);\\n        char[] r = rest.toCharArray();\\n        \\n        left = 0;\\n        right = r.length - 1;\\n        while (left < right){\\n            char temp = r[left];\\n            r[left] = r[right];\\n            r[right] = temp;\\n            left ++ ;\\n            right --;\\n        }\\n        return new String(r) + s;\\n    }\\n    final int modulus = 1000000;\\n    final int base= 31;\\n    HashMap<Integer, Integer> map = new HashMap<>();\\n    public int powerFun(int x) {\\n    \\tif (map.containsKey(x)) return map.get(x);\\n    \\tint y = powerFun(x - 1);\\n    \\ty *= base;\\n    \\ty %= modulus;\\n    \\tmap.put(x, y);\\n    \\treturn y;\\n    }\\n    \\n    public int addFirst(int val, int len, char c) {\\n    \\tint power = powerFun(len);\\n\\n    \\tval += (c - \\'a\\') * power;\\n    \\twhile (val < 0) val += modulus;\\n    \\treturn val % modulus;\\n    }\\n    \\n    public int removeFirstAddLast(int val, int len, char first, char last) {\\n    \\tint power = powerFun(len - 1);\\n    \\tval -= (first - \\'a\\') * power;\\n    \\twhile (val < 0) val += modulus;\\n    \\tval %= modulus;\\n    \\tval *= base;\\n    \\tval %= modulus;\\n    \\tval += last - \\'a\\';\\n    \\tval %= modulus;    \\t\\n    \\treturn val;\\n    }\\n    \\n    public int addLast(int val, int len, char c) {\\n    \\tval %= modulus;\\n    \\tval *= base;\\n    \\tval %= modulus;\\n    \\tval += c - \\'a\\';\\n    \\tval %= modulus;    \\t\\n    \\treturn val;\\n    }\\n\\t\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394153,
                "title": "simple-python-solution",
                "content": "```\\n    def shortestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        n = len(s)\\n        l, r = s, \"\"\\n        rev_s = s[::-1]\\n        \\n        while(rev_s != r + l and n > 1):\\n            r += l[-1]\\n            l = l[:n - 1]\\n            n -= 1\\n        return r + s\\n```",
                "solutionTags": [],
                "code": "```\\n    def shortestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        n = len(s)\\n        l, r = s, \"\"\\n        rev_s = s[::-1]\\n        \\n        while(rev_s != r + l and n > 1):\\n            r += l[-1]\\n            l = l[:n - 1]\\n            n -= 1\\n        return r + s\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 269865,
                "title": "10line-easy-python-with-explanation",
                "content": "```\\nclass Solution:\\n    \\'\\'\\'\\n        1. Shrink from right to left to get the longest palindrome and the inverse of right part string\\n        2. add the right part in front of the original string\\n\\n        e.g.\\n        step 1. aacecaaab                 right:\\'\\'\\n        step 2. aacecaaab -> aacecaaa b   right:\\'b\\'\\n        step 3. aacecaaab -> aacecaa  ab  right:\\'ba\\'\\n        step 4. ab + aacecaaab = baaacecaaab\\n        \\n    \\'\\'\\'\\n    def shortestPalindrome(self, s: str) -> str:\\n        i = 0\\n        n = len(s)\\n        right = \\'\\'\\n        for i in range(n):\\n            t = s[:n-i]\\n            if t == t[::-1]:\\n                break\\n            right += t[n-i-1]\\n        return right + s\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\'\\'\\'\\n        1. Shrink from right to left to get the longest palindrome and the inverse of right part string\\n        2. add the right part in front of the original string\\n\\n        e.g.\\n        step 1. aacecaaab                 right:\\'\\'\\n        step 2. aacecaaab -> aacecaaa b   right:\\'b\\'\\n        step 3. aacecaaab -> aacecaa  ab  right:\\'ba\\'\\n        step 4. ab + aacecaaab = baaacecaaab\\n        \\n    \\'\\'\\'\\n    def shortestPalindrome(self, s: str) -> str:\\n        i = 0\\n        n = len(s)\\n        right = \\'\\'\\n        for i in range(n):\\n            t = s[:n-i]\\n            if t == t[::-1]:\\n                break\\n            right += t[n-i-1]\\n        return right + s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 233109,
                "title": "solved-using-palindrome-expand-around-center",
                "content": "This is my attempt to optimize after solving this using brute force. [Accepted 50%]\\n```\\nclass Solution {\\n    private int expandAround(String s, int l, int r) {\\n        int n = s.length();\\n        \\n        while (l >= 0 && r < n && s.charAt(l) == s.charAt(r)) {\\n            l--;\\n            r++;\\n        }\\n        \\n        \\n        if (l == -1) {\\n            return r;\\n        }\\n        return -1;\\n    }\\n    \\n    private String getResult(String s, int i) {\\n        return new StringBuilder(s.substring(i)).reverse().toString() + s;\\n    }\\n    \\n   public String shortestPalindrome(String s) {\\n        int n = s.length();\\n        int mid = (n-1)/2;\\n        \\n        while(mid >= 0) {\\n            int r = expandAround(s, mid, mid+1);\\n            if (r != -1) {\\n                return getResult(s, r);\\n            }\\n            \\n            r = expandAround(s, mid, mid);\\n            if (r != -1) {\\n                return getResult(s, r);\\n            }\\n            \\n            mid--;\\n        }\\n        \\n        return \"\";\\n    }\\n}\\n```\\n\\nBrute force[Accepted]:\\n```\\nclass Solution {\\n    private boolean isPalindrome(String s) {\\n        for (int l=0, r=s.length()-1; l<r; l++, r--) {\\n            if (s.charAt(l) != s.charAt(r)) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    // aabaabbbaa\\n    public String shortestPalindrome(String s) {\\n        int n = s.length();\\n        String shortest = new StringBuilder(s).reverse().toString() + s;\\n        for (int i=0; i<n; i++) {\\n            if (isPalindrome(s.substring(0, i+1))) {\\n                shortest = new StringBuilder(s.substring(i+1)).reverse().toString() + s;\\n            }\\n        }\\n        \\n        return shortest;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int expandAround(String s, int l, int r) {\\n        int n = s.length();\\n        \\n        while (l >= 0 && r < n && s.charAt(l) == s.charAt(r)) {\\n            l--;\\n            r++;\\n        }\\n        \\n        \\n        if (l == -1) {\\n            return r;\\n        }\\n        return -1;\\n    }\\n    \\n    private String getResult(String s, int i) {\\n        return new StringBuilder(s.substring(i)).reverse().toString() + s;\\n    }\\n    \\n   public String shortestPalindrome(String s) {\\n        int n = s.length();\\n        int mid = (n-1)/2;\\n        \\n        while(mid >= 0) {\\n            int r = expandAround(s, mid, mid+1);\\n            if (r != -1) {\\n                return getResult(s, r);\\n            }\\n            \\n            r = expandAround(s, mid, mid);\\n            if (r != -1) {\\n                return getResult(s, r);\\n            }\\n            \\n            mid--;\\n        }\\n        \\n        return \"\";\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private boolean isPalindrome(String s) {\\n        for (int l=0, r=s.length()-1; l<r; l++, r--) {\\n            if (s.charAt(l) != s.charAt(r)) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    // aabaabbbaa\\n    public String shortestPalindrome(String s) {\\n        int n = s.length();\\n        String shortest = new StringBuilder(s).reverse().toString() + s;\\n        for (int i=0; i<n; i++) {\\n            if (isPalindrome(s.substring(0, i+1))) {\\n                shortest = new StringBuilder(s.substring(i+1)).reverse().toString() + s;\\n            }\\n        }\\n        \\n        return shortest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 194038,
                "title": "very-simple-4ms-99-4-c-average-o-n-time-o-1-space-solution",
                "content": "Uses xor hashing for fast non-palindrome filtering\\n```\\nbool is_pal(const char* s, int l, uint8_t hash) {\\n    if (l%2 == 1 and hash != s[l/2]) return false;\\n    if (l%2 == 0 and hash) return false;\\n    \\n    for (int i = 0; i < l/2; ++i)\\n        if (s[i] != s[l-i-1])\\n            return false;\\n    return true;\\n}\\n\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s) {\\n        if (s.size() <= 1) return s;\\n        uint8_t hash = accumulate(s.begin(), s.end(), (uint8_t)0, [] (uint8_t h, char a) { return h^a; });\\n        int i;\\n        for (i = s.size(); i > 1; --i) {\\n            if (is_pal(s.data(), i, hash))\\n                break;\\n            hash ^= s[i-1];\\n        }\\n        \\n        \\n        auto bonus = string(s.data() + i, s.size() - i);\\n        reverse(bonus.begin(), bonus.end());\\n        return bonus + s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nbool is_pal(const char* s, int l, uint8_t hash) {\\n    if (l%2 == 1 and hash != s[l/2]) return false;\\n    if (l%2 == 0 and hash) return false;\\n    \\n    for (int i = 0; i < l/2; ++i)\\n        if (s[i] != s[l-i-1])\\n            return false;\\n    return true;\\n}\\n\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s) {\\n        if (s.size() <= 1) return s;\\n        uint8_t hash = accumulate(s.begin(), s.end(), (uint8_t)0, [] (uint8_t h, char a) { return h^a; });\\n        int i;\\n        for (i = s.size(); i > 1; --i) {\\n            if (is_pal(s.data(), i, hash))\\n                break;\\n            hash ^= s[i-1];\\n        }\\n        \\n        \\n        auto bonus = string(s.data() + i, s.size() - i);\\n        reverse(bonus.begin(), bonus.end());\\n        return bonus + s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 185185,
                "title": "python-o-n-rabin-karp-based-on-solution-1",
                "content": "O(n) Rabin-Karp based on solution 1. I failed to understand solution 2 & 3. I\\'m not sure I can do KMP in interview. However I\\'m sure I can do Rabin-Karp. Folloing code recude substring comparison time from O(n) to O(1) in solution 1.\\n```\\nclass Solution:\\n    def shortestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        if not s or len(s) == 1: return s\\n        \\n        s_l = 0\\n        s_r = len(s)-1\\n        rev = s[::-1]\\n        r_l = 0\\n        r_r = s_r\\n        \\n        MOD = 131\\n        P = 127\\n        INV_P = pow(P, MOD-2) % MOD\\n        \\n        def code(t):\\n            return ord(t)-ord(\\'a\\')+1\\n        \\n        def rkHash(text, P, MOD):\\n            power = 1\\n            ans = 0\\n            for t in text:\\n                power = (power*P) % MOD\\n                ans = (ans + code(t)*power) % MOD\\n            return ans, power\\n        \\n        hash_s, power = rkHash(s, P, MOD)\\n        hash_r, power = rkHash(rev, P, MOD)\\n        if hash_s == hash_r and s == rev:\\n            return s\\n        \\n        s_power = power\\n        for i in range(len(s)):\\n            s_i = len(s)-1-i\\n            hash_s = (hash_s - code(s[s_i])*s_power) % MOD\\n            hash_r = ((hash_r - code(rev[i])*P) * INV_P) % MOD\\n            s_power = (s_power * INV_P) % MOD\\n            if hash_s == hash_r and rev[i+1:] == s[:-(i+1)]:\\n                return rev[:i+1] + s\\n        return rev + s\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        if not s or len(s) == 1: return s\\n        \\n        s_l = 0\\n        s_r = len(s)-1\\n        rev = s[::-1]\\n        r_l = 0\\n        r_r = s_r\\n        \\n        MOD = 131\\n        P = 127\\n        INV_P = pow(P, MOD-2) % MOD\\n        \\n        def code(t):\\n            return ord(t)-ord(\\'a\\')+1\\n        \\n        def rkHash(text, P, MOD):\\n            power = 1\\n            ans = 0\\n            for t in text:\\n                power = (power*P) % MOD\\n                ans = (ans + code(t)*power) % MOD\\n            return ans, power\\n        \\n        hash_s, power = rkHash(s, P, MOD)\\n        hash_r, power = rkHash(rev, P, MOD)\\n        if hash_s == hash_r and s == rev:\\n            return s\\n        \\n        s_power = power\\n        for i in range(len(s)):\\n            s_i = len(s)-1-i\\n            hash_s = (hash_s - code(s[s_i])*s_power) % MOD\\n            hash_r = ((hash_r - code(rev[i])*P) * INV_P) % MOD\\n            s_power = (s_power * INV_P) % MOD\\n            if hash_s == hash_r and rev[i+1:] == s[:-(i+1)]:\\n                return rev[:i+1] + s\\n        return rev + s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 171756,
                "title": "beats-74-62-kmp-java-with-explanations",
                "content": "**Logical Thought**\\nThe shortest palindrome I can find by adding characters in front of s should be constructed in the way as below:\\n```\\nIf we define startStr = longest palindrome substring starting at 0 in s, the rest of s as restStr,\\nour target is reverse(restStr) + startStr + restStr.\\n```\\nTo get `startStr`, we take advantage of **LPS array** in **KMP** algorithm. If we get lps[] of `str = s + # + reverse(s)`, `lps[str.length() - 1]` is the length of  `startStr`. Thus,  `restStr = s.substring(lps[str.length() - 1])`.\\n**Essence**\\n`lps[i] is longest prefix which is also a suffix of s[0..i]`.\\n**Code**\\n```\\n    public String shortestPalindrome(String s) { \\n        \\n        StringBuilder stringBuilder = new StringBuilder(s);\\n        StringBuilder reverseStringBuilder = new StringBuilder(s).reverse();        \\n        stringBuilder.append(\"#\").append(reverseStringBuilder);\\n        int[] lps = computeLPS(stringBuilder.toString());\\n\\n        return new StringBuilder(s.substring(lps[lps.length - 1])).reverse().toString() + s;\\n    }\\n    \\n    private static int[] computeLPS(String t) {\\n        \\n        int tLength = t.length(), i = 1, preLengthLPS = 0;\\n        int[] lps = new int[tLength];\\n        lps[0] = 0; \\n        while (i < tLength) {\\n            if (t.charAt(i) == t.charAt(preLengthLPS)) {\\n                preLengthLPS++;\\n                lps[i] = preLengthLPS;\\n                i++;\\n            } else {\\n                if (preLengthLPS != 0)\\n                    preLengthLPS = lps[preLengthLPS - 1];\\n                else {\\n                    lps[i] = 0;\\n                    i++;\\n                }\\n            }\\n        }\\n        \\n        return lps;\\n    }\\n```\\nI appreciate your **VOTE UP** (\\u02CAo\\u0334\\u0336\\u0337\\u0324\\u2304o\\u0334\\u0336\\u0337\\u0324\\u02CB) ",
                "solutionTags": [],
                "code": "```\\nIf we define startStr = longest palindrome substring starting at 0 in s, the rest of s as restStr,\\nour target is reverse(restStr) + startStr + restStr.\\n```\n```\\n    public String shortestPalindrome(String s) { \\n        \\n        StringBuilder stringBuilder = new StringBuilder(s);\\n        StringBuilder reverseStringBuilder = new StringBuilder(s).reverse();        \\n        stringBuilder.append(\"#\").append(reverseStringBuilder);\\n        int[] lps = computeLPS(stringBuilder.toString());\\n\\n        return new StringBuilder(s.substring(lps[lps.length - 1])).reverse().toString() + s;\\n    }\\n    \\n    private static int[] computeLPS(String t) {\\n        \\n        int tLength = t.length(), i = 1, preLengthLPS = 0;\\n        int[] lps = new int[tLength];\\n        lps[0] = 0; \\n        while (i < tLength) {\\n            if (t.charAt(i) == t.charAt(preLengthLPS)) {\\n                preLengthLPS++;\\n                lps[i] = preLengthLPS;\\n                i++;\\n            } else {\\n                if (preLengthLPS != 0)\\n                    preLengthLPS = lps[preLengthLPS - 1];\\n                else {\\n                    lps[i] = 0;\\n                    i++;\\n                }\\n            }\\n        }\\n        \\n        return lps;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 149983,
                "title": "a-concise-kmp-algorithm-beat-95",
                "content": "Since the KMP can only record the proper prefix (substring only), I first exclude the case `s` is palindrome. Then just refer to KMP method.\\n\\n```\\nclass Solution:\\n    def shortestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        r = s[::-1]\\n        if r == s:\\n            return s\\n        kmp = [0] * len(s)\\n        i = 0\\n        j = 1\\n        while j < len(s):\\n            if r[j] == s[i]:\\n                i += 1\\n                kmp[j] = i\\n                j += 1\\n            else:\\n                if i > 0:\\n                    i = kmp[i-1]\\n                else:\\n                    kmp[j] = 0\\n                    j += 1\\n        pre = r[:len(r) - kmp[-1]]\\n        return pre + s\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        r = s[::-1]\\n        if r == s:\\n            return s\\n        kmp = [0] * len(s)\\n        i = 0\\n        j = 1\\n        while j < len(s):\\n            if r[j] == s[i]:\\n                i += 1\\n                kmp[j] = i\\n                j += 1\\n            else:\\n                if i > 0:\\n                    i = kmp[i-1]\\n                else:\\n                    kmp[j] = 0\\n                    j += 1\\n        pre = r[:len(r) - kmp[-1]]\\n        return pre + s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 111463,
                "title": "java-solution",
                "content": "```\\n  public String shortestPalindrome(String s) {\\n    // using char array can pass the OJ, it is more efficient\\n    char[] chars = s.toCharArray();\\n    // find the longest palin from left\\n    int end = chars.length - 1;\\n    for (; end>= 0; end--) {\\n      if (isPalin(chars, 0, end)) {\\n        break;\\n      }\\n    }\\n\\n    StringBuilder sb = new StringBuilder();\\n    for (int i = chars.length - 1; i > end; i--) {\\n      sb.append(chars[i]);\\n    }\\n    sb.append(chars);\\n\\n    return sb.toString();\\n  }\\n\\n  private boolean isPalin(char[] chars, int start, int end) {\\n    while (start < end) {\\n      Character l = chars[start];\\n      Character r = chars[end];\\n\\n      if (l != r) {\\n        return false;\\n      }\\n\\n      start++;\\n      end--;\\n    }\\n\\n    return true;\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  public String shortestPalindrome(String s) {\\n    // using char array can pass the OJ, it is more efficient\\n    char[] chars = s.toCharArray();\\n    // find the longest palin from left\\n    int end = chars.length - 1;\\n    for (; end>= 0; end--) {\\n      if (isPalin(chars, 0, end)) {\\n        break;\\n      }\\n    }\\n\\n    StringBuilder sb = new StringBuilder();\\n    for (int i = chars.length - 1; i > end; i--) {\\n      sb.append(chars[i]);\\n    }\\n    sb.append(chars);\\n\\n    return sb.toString();\\n  }\\n\\n  private boolean isPalin(char[] chars, int start, int end) {\\n    while (start < end) {\\n      Character l = chars[start];\\n      Character r = chars[end];\\n\\n      if (l != r) {\\n        return false;\\n      }\\n\\n      start++;\\n      end--;\\n    }\\n\\n    return true;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 60107,
                "title": "my-solution-is-giving-a-shorter-output-compared-to-expected-answer-i-think-expected-answer-is-wrong",
                "content": "\\ndef shortestPalindrome(  s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n \\n        len_s=len(s)\\n        if len_s==0 or len_s==1:\\n        \\treturn s\\n        list_s=list(s)\\n        i=0\\n        j=len_s-1\\n        res=[]\\n        while(1):\\n        \\tif list_s[i]==list_s[j]:\\n        \\t\\tres.append(list_s[i])\\n        \\t\\ti+=1\\n        \\t\\tj-=1\\n        \\t\\tif i>j:\\n        \\t\\t\\tstart=i\\n        \\t\\t\\tbreak\\n        \\telse:\\n        \\t\\tres.append(list_s[j])\\n        \\t\\tj-=1\\n        \\tif i==j:\\n        \\t\\t     start=i\\n        \\t\\tbreak\\n        for k in range(i,len_s):\\n        \\tres.append(list_s[k])\\n        return ''.join(res)\\n\\ns1=\"aabba\"\\nprint shortestPalindrome(s1)\\n\\noutput = abbabba\\nexpected output = abbaabba\\n\\nCan someone confirm?",
                "solutionTags": [],
                "code": "\\ndef shortestPalindrome(  s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n \\n        len_s=len(s)\\n        if len_s==0 or len_s==1:\\n        \\treturn s\\n        list_s=list(s)\\n        i=0\\n        j=len_s-1\\n        res=[]\\n        while(1):\\n        \\tif list_s[i]==list_s[j]:\\n        \\t\\tres.append(list_s[i])\\n        \\t\\ti+=1\\n        \\t\\tj-=1\\n        \\t\\tif i>j:\\n        \\t\\t\\tstart=i\\n        \\t\\t\\tbreak\\n        \\telse:\\n        \\t\\tres.append(list_s[j])\\n        \\t\\tj-=1\\n        \\tif i==j:\\n        \\t\\t     start=i\\n        \\t\\tbreak\\n        for k in range(i,len_s):\\n        \\tres.append(list_s[k])\\n        return ''.join(res)\\n\\ns1=\"aabba\"\\nprint shortestPalindrome(s1)\\n\\noutput = abbabba\\nexpected output = abbaabba\\n\\nCan someone confirm?",
                "codeTag": "Python3"
            },
            {
                "id": 60128,
                "title": "fast-recursive-solution-in-python-beats-96-of-submissions",
                "content": "```\\nclass Solution(object):\\n    def shortestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        # find prefix that can be a palindrome\\n        prefix_idx = 0 \\n        for i in range(len(s)-1, -1, -1):\\n            if s[i] == s[prefix_idx ]:\\n                prefix_idx  += 1\\n\\n        if prefix_idx == len(s): # the whole string is palindrome\\n            return s\\n\\n        suffix = s[prefix_idx:] # this is definitely not palindromic\\n        return suffix[::-1] + self.shortestPalindrome(s[:prefix_idx]) + suffix",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def shortestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        # find prefix that can be a palindrome\\n        prefix_idx = 0 \\n        for i in range(len(s)-1, -1, -1):\\n            if s[i] == s[prefix_idx ]:\\n                prefix_idx  += 1\\n\\n        if prefix_idx == len(s): # the whole string is palindrome\\n            return s\\n\\n        suffix = s[prefix_idx:] # this is definitely not palindromic\\n        return suffix[::-1] + self.shortestPalindrome(s[:prefix_idx]) + suffix",
                "codeTag": "Java"
            },
            {
                "id": 60180,
                "title": "disparity-of-tle-based-on-languages",
                "content": "I tried to follow this solution (https://discuss.leetcode.com/topic/41047/o-n-using-idea-similar-to-lps-358-msec/2) in **C++**.  \\nHis original **JAVA** solution passes in ~358 ms (as claimed). Contrary to what's written in the title, the solution runs in no less than `O(n**2)`. I have taken note of that.  \\nReplicating this in **C++** <sup>1</sup> takes up 1480 ms for one large test case alone (the one with `\"aaaaaa....cd......aaaa\"`) and obviously times out when submitted.\\n\\nThis is an obvious disparity over run time costs in different languages for a test case. I know that  much faster solutions exist for this problem. But the fact that a slow approach is accepted in one language and not in another is unsettling. Any suggestions on how to fix this?\\n\\nThis issue not entirely isolated. Another `O(n**2)` solution (https://discuss.leetcode.com/topic/47699/accepted-c-solution-easy-to-understand) seems to be accepted.\\n\\n---\\n<sup>1</sup> The rogue code looks like this:\\n```c\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s) {\\n        int mid = s.length()/2, n = s.length();\\n        string pre;\\n        pair<int, int> ret;\\n      \\n        for(int i=mid-1; i>=0; i--) {\\n            // even length\\n            ret = expandString(s, i, i+1);\\n            if(ret.first == -1) {\\n                pre = s.substr(ret.second);\\n                reverse(pre.begin(), pre.end());\\n                return pre + s;\\n            }\\n            \\n            // odd length\\n            ret = expandString(s, i, i);\\n            if(ret.first == -1) {\\n                pre = s.substr(ret.second);\\n                reverse(pre.begin(), pre.end());\\n                return pre + s;\\n            }\\n        }\\n        \\n        return \"\";\\n    }\\n    \\n    pair<int, int> expandString(string &s, int left, int right) {\\n        while(left >= 0 && right < s.length() && (s[left] == s[right])) {\\n            left--;\\n            right++;\\n        }\\n        return make_pair(left, right);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s) {\\n        int mid = s.length()/2, n = s.length();\\n        string pre;\\n        pair<int, int> ret;\\n      \\n        for(int i=mid-1; i>=0; i--) {\\n            // even length\\n            ret = expandString(s, i, i+1);\\n            if(ret.first == -1) {\\n                pre = s.substr(ret.second);\\n                reverse(pre.begin(), pre.end());\\n                return pre + s;\\n            }\\n            \\n            // odd length\\n            ret = expandString(s, i, i);\\n            if(ret.first == -1) {\\n                pre = s.substr(ret.second);\\n                reverse(pre.begin(), pre.end());\\n                return pre + s;\\n            }\\n        }\\n        \\n        return \"\";\\n    }\\n    \\n    pair<int, int> expandString(string &s, int left, int right) {\\n        while(left >= 0 && right < s.length() && (s[left] == s[right])) {\\n            left--;\\n            right++;\\n        }\\n        return make_pair(left, right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60137,
                "title": "beat-99-java-solution",
                "content": "    public String shortestPalindrome(String s) {\\n        if(s==null||s.length()==0){\\n            return s;\\n        }\\n        char[] arr = s.toCharArray();\\n        StringBuilder sb = new StringBuilder();\\n        int cent = getCentralPoint(arr);\\n        for(int i = arr.length-1;i>=cent;i--){\\n            sb.append(arr[i]);\\n        }\\n        sb.append(s);\\n        return sb.toString();\\n    }\\n    \\n    private int getCentralPoint(char[] arr){\\n        int mid = (arr.length-1)/2;\\n        int i = mid;\\n        int j = mid;\\n        while(i>=0){\\n        \\ti = mid;\\n        \\tj = mid;\\n            while(i>=0&&arr[i]==arr[mid]){\\n                i--;\\n            }\\n            while(j<arr.length&&arr[j]==arr[mid]){\\n                j++;\\n            }\\n            int cp = centralPoint(arr,i,j);\\n            if(cp!=-1){\\n            \\treturn cp;\\n            }\\n            mid = i;\\n        }\\n        return 0;\\n    }\\n    \\n    private int centralPoint(char[] arr,int i,int j){\\n        while(i>=0&&j<arr.length){\\n            if(arr[i]!=arr[j]){\\n                return -1;\\n            }\\n            i--;\\n            j++;\\n        }\\n        return i!=-1?-1:j;\\n    }",
                "solutionTags": [],
                "code": "    public String shortestPalindrome(String s) {\\n        if(s==null||s.length()==0){\\n            return s;\\n        }\\n        char[] arr = s.toCharArray();\\n        StringBuilder sb = new StringBuilder();\\n        int cent = getCentralPoint(arr);\\n        for(int i = arr.length-1;i>=cent;i--){\\n            sb.append(arr[i]);\\n        }\\n        sb.append(s);\\n        return sb.toString();\\n    }\\n    \\n    private int getCentralPoint(char[] arr){\\n        int mid = (arr.length-1)/2;\\n        int i = mid;\\n        int j = mid;\\n        while(i>=0){\\n        \\ti = mid;\\n        \\tj = mid;\\n            while(i>=0&&arr[i]==arr[mid]){\\n                i--;\\n            }\\n            while(j<arr.length&&arr[j]==arr[mid]){\\n                j++;\\n            }\\n            int cp = centralPoint(arr,i,j);\\n            if(cp!=-1){\\n            \\treturn cp;\\n            }\\n            mid = i;\\n        }\\n        return 0;\\n    }\\n    \\n    private int centralPoint(char[] arr,int i,int j){\\n        while(i>=0&&j<arr.length){\\n            if(arr[i]!=arr[j]){\\n                return -1;\\n            }\\n            i--;\\n            j++;\\n        }\\n        return i!=-1?-1:j;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 60197,
                "title": "c-o-n-time-solution-using-manacher-s-algorithm",
                "content": "The problem can be converted to solve this problem instead: find the longest palindrome string starting from the beginning position, which you can apply the approach in solving \"[Longest Palindromic Substring][1]\". Let the length of this longest palindrome be **maxLen**. Then we reverse the Substring without the longest palindrome Substring, let it be **append**:\\n\\n    string append = s.substr(maxLen, s.size() - maxLen);\\n    reverse(append.begin(), append.end());\\n\\nand append it to the beginning of s. If Manacher's algorithm sounds unfamiliar to you, [here][2] is a good editorial article describing it.\\n\\n    class Solution {\\n    public:\\n        string shortestPalindrome(string s) {\\n            string T = \"^\";\\n            for(int i = 0; i < s.size(); i++){\\n                T += \"#\" + s.substr(i,1);\\n            }\\n            T += \"#@\";\\n            \\n            int n = T.size();\\n            vector<int> P(n, 0);\\n            \\n            int R = 0, C = 0;\\n            for(int i = 1; i < n - 1; i++){\\n                int i_mirr = 2 * C - i;\\n                P[i] = i < R ? min(P[i_mirr], R - i) : 0;\\n                // expand\\n                while(T[i + P[i] + 1] == T[i - P[i] - 1]){\\n                    P[i]++;\\n                    if(i + P[i] > R){\\n                        C = i;\\n                        R = i + P[i];\\n                    }\\n                }\\n            }\\n            \\n            int maxLen = 0;\\n            for(int i = 1; i < n - 1; i++){\\n                if(i - P[i] == 1) maxLen = max(maxLen, P[i]); // only consider palindrome starting from beginning position\\n            }\\n            \\n            string append = s.substr(maxLen, s.size() - maxLen);\\n            reverse(append.begin(), append.end());\\n            \\n            return append + s;\\n        }\\n    };\\n\\n\\n  [1]: https://leetcode.com/problems/longest-palindromic-substring/\\n  [2]: http://articles.leetcode.com/longest-palindromic-substring-part-ii",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string shortestPalindrome(string s) {\\n            string T = \"^\";\\n            for(int i = 0; i < s.size(); i++){\\n                T += \"#\" + s.substr(i,1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 60200,
                "title": "short-python-codes-discuss-on-2-methods-both-o-n-time",
                "content": "Our goal is to find the longest palindrome starting from the first index.\\n\\n1st method:\\nConcatenate the input string with its reverse by a special character, i.e. '$'. Then we find the longest palindrome from the first index by finding the prefix suffix (see kmp algorithm) at the last index.\\n\\n    def LPS(p):\\n        lps = [0] * len(p)\\n        l = 0\\n        for i in range(1, len(p)):\\n            while l > 0 and p[i] != p[l]:\\n                l = lps[l-1]\\n            if p[i] == p[l]:\\n                l += 1\\n                lps[i] = l\\n        return lps\\n\\n    def shortestPalindrome(s):\\n        lps = LPS(s+'$'+s[::-1])\\n        return s[lps[len(lps)-1]:len(s)][::-1] + s\\n\\nBut this method will not work if our input string also contains that special character. Another method to get around this is to use KMP matching. Consider i going from first index to the right as the index for the pattern, and j goes from the last index to the left as the index in the string to match in KMP.\\n\\n    def LPS(p):\\n        lps = [0] * len(p)\\n        l = 0\\n        for i in range(1, len(p)):\\n            while l > 0 and p[i] != p[l]:\\n                l = lps[l-1]\\n            if p[i] == p[l]:\\n                l += 1\\n                lps[i] = l\\n        return lps\\n\\n    def shortestPalindrome(s):\\n        lps = LPS(s)\\n        i = 0; j = len(s)-1\\n        while i < j:\\n            while i > 0 and s[i] != s[j]:\\n    \\t        i = lps[i-1]\\n    \\t    if s[i] == s[j]:\\n                i += 1\\n    \\t    j -= 1\\n        return s[(i+j)+1:len(s)][::-1] + s",
                "solutionTags": [],
                "code": "Our goal is to find the longest palindrome starting from the first index.\\n\\n1st method:\\nConcatenate the input string with its reverse by a special character, i.e. '$'. Then we find the longest palindrome from the first index by finding the prefix suffix (see kmp algorithm) at the last index.\\n\\n    def LPS(p):\\n        lps = [0] * len(p)\\n        l = 0\\n        for i in range(1, len(p)):\\n            while l > 0 and p[i] != p[l]:\\n                l = lps[l-1]\\n            if p[i] == p[l]:\\n                l += 1\\n                lps[i] = l\\n        return lps\\n\\n    def shortestPalindrome(s):\\n        lps = LPS(s+'$'+s[::-1])\\n        return s[lps[len(lps)-1]:len(s)][::-1] + s\\n\\nBut this method will not work if our input string also contains that special character. Another method to get around this is to use KMP matching. Consider i going from first index to the right as the index for the pattern, and j goes from the last index to the left as the index in the string to match in KMP.\\n\\n    def LPS(p):\\n        lps = [0] * len(p)\\n        l = 0\\n        for i in range(1, len(p)):\\n            while l > 0 and p[i] != p[l]:\\n                l = lps[l-1]\\n            if p[i] == p[l]:\\n                l += 1\\n                lps[i] = l\\n        return lps\\n\\n    def shortestPalindrome(s):\\n        lps = LPS(s)\\n        i = 0; j = len(s)-1\\n        while i < j:\\n            while i > 0 and s[i] != s[j]:\\n    \\t        i = lps[i-1]\\n    \\t    if s[i] == s[j]:\\n                i += 1\\n    \\t    j -= 1\\n        return s[(i+j)+1:len(s)][::-1] + s",
                "codeTag": "Python3"
            },
            {
                "id": 60212,
                "title": "manacher-u2019s-algorithm-solution-in-python",
                "content": "The main idea is that find the longest palindrome substring `s[0:i]` starting from `s[0]`, and reverse the left part `s[i:]` to `s[i:][::-1]`, at last return `s[i:][::-1] + s`.\\n\\nIn Manacher\\u2019s algorithm, `s` is converted to a string `newS` splitted by `#`, for example `abc` -> `#a#b#c#`. And we know that `p[i]` is the radius of palindrome whose center is `newS[i]`, and `p[i] - 1` is the actually length of palindrome in `s`. So we only need to find the last `i` whose radius reaches the start of `newS`.\\n\\n    class Solution(object):\\n        def shortestPalindrome(self, s):\\n            original, s, n = s, '#{}#'.format('#'.join(list(s))),  2 * len(s) + 1\\n            p, idx, maxReach = [0] * n, 0, 0\\n    \\n            for i in xrange(n):\\n                p[i] = min(maxReach - i, p[2 * idx - i]) if maxReach > i else 1\\n    \\n                while i - p[i] >= 0 and i + p[i] < n and s[i - p[i]] == s[i + p[i]]:\\n                    p[i] += 1\\n    \\n                if i + p[i] > maxReach:\\n                    idx = i\\n                    maxReach = i + p[i]\\n    \\n            for i in xrange(n - 1, -1, -1):\\n                if p[i] == i + 1:\\n                    return original[p[i] - 1:][::-1] + original\\n            return original",
                "solutionTags": [],
                "code": "class Solution(object):\\n        def shortestPalindrome(self, s):\\n            original, s, n = s, '#{}",
                "codeTag": "Java"
            },
            {
                "id": 60169,
                "title": "simple-java-solution",
                "content": "  The main idea is to find the longest palindrome from the first index, cost O(n)\\n\\n    public String shortestPalindrome(String s) {\\n        if(s.length() == 0) return \"\";\\n        int len = s.length(), left, right,  maxLen = 0;\\n        for(int i = 0 ; i < len;){\\n            left = right = i;\\n            while(right < len - 1 && s.charAt(right) == s.charAt(right + 1))\\n                right ++;\\n            \\n            i = right + 1;\\n            \\n            while(left > 0 && right < len - 1 && s.charAt(left - 1) == s.charAt(right + 1)){\\n                left --;\\n                right ++;\\n            }\\n            \\n            if(left == 0 && maxLen < right + 1){\\n                maxLen = right + 1;\\n            }\\n        }\\n        \\n        String prefix = new StringBuilder(s.substring(maxLen)).reverse().toString();\\n\\n        return prefix + s;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "  The main idea is to find the longest palindrome from the first index, cost O(n)\\n\\n    public String shortestPalindrome(String s) {\\n        if(s.length() == 0) return \"\";\\n        int len = s.length(), left, right,  maxLen = 0;\\n        for(int i = 0 ; i < len;){\\n            left = right = i;\\n            while(right < len - 1 && s.charAt(right) == s.charAt(right + 1))\\n                right ++;\\n            \\n            i = right + 1;\\n            \\n            while(left > 0 && right < len - 1 && s.charAt(left - 1) == s.charAt(right + 1)){\\n                left --;\\n                right ++;\\n            }\\n            \\n            if(left == 0 && maxLen < right + 1){\\n                maxLen = right + 1;\\n            }\\n        }\\n        \\n        String prefix = new StringBuilder(s.substring(maxLen)).reverse().toString();\\n\\n        return prefix + s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 60208,
                "title": "kmp-table-building-java-solution-implemented-the-pseudocode-from-wiki-easy-to-understand",
                "content": "    public class Solution {\\n        public String shortestPalindrome(String s) {\\n            if(s.length()<=1) return s;\\n            String rev_s = new StringBuilder(s).reverse().toString();\\n            //add a # to the last to do one more match on the last character\\n            String new_s = s + \"#\" + rev_s + \"#\";\\n            \\n            // KMP table building, each entry indicates how many characters needs to fall back if a mismatch happens\\n            int[] res = new int[new_s.length()];\\n            int pos = 2; // the current position we are computing in the res table\\n            int cnd = 0; // the zero-based index in s of the next character of the current candidate substring\\n            res[0] = -1;\\n            res[1] = 0;\\n            while(pos < new_s.length()) {\\n                // the substring continues\\n                if(new_s.charAt(pos - 1) == new_s.charAt(cnd)) {\\n                    cnd++;\\n                    res[pos] = cnd;\\n                    pos++;\\n                }\\n                // it doesn't, but we can fall back\\n                else if (cnd > 0) cnd = res[cnd];\\n                // we have run out of candidates.  Note cnd = 0\\n                else {\\n                    res[pos] = 0;\\n                    pos++;\\n                }\\n            }\\n            // compute the largest prefix of s that is a palindrome\\n            return rev_s.substring(0, s.length() - res[new_s.length() - 1]) + s;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String shortestPalindrome(String s) {\\n            if(s.length()<=1) return s;\\n            String rev_s = new StringBuilder(s).reverse().toString();\\n            //add a # to the last to do one more match on the last character\\n            String new_s = s + \"#\" + rev_s + \"#\";\\n            \\n            // KMP table building, each entry indicates how many characters needs to fall back if a mismatch happens\\n            int[] res = new int[new_s.length()];\\n            int pos = 2; // the current position we are computing in the res table\\n            int cnd = 0; // the zero-based index in s of the next character of the current candidate substring\\n            res[0] = -1;\\n            res[1] = 0;\\n            while(pos < new_s.length()) {\\n                // the substring continues\\n                if(new_s.charAt(pos - 1) == new_s.charAt(cnd)) {\\n                    cnd++;\\n                    res[pos] = cnd;\\n                    pos++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 60219,
                "title": "why-is-this-python-solution-giving-tle",
                "content": "    def shortestPalindrome(self, s):\\n        start = 0\\n        end = len(s)-1\\n        lastValidEnd = end\\n        while start<end:\\n            if s[start]==s[end]:\\n                start += 1\\n                end -= 1\\n            else:\\n                start = 0\\n                lastValidEnd -= 1\\n                end = lastValidEnd\\n        return s[len(s)-1:lastValidEnd:-1]+s",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def shortestPalindrome(self, s):\\n        start = 0\\n        end = len(s)-1\\n        lastValidEnd = end\\n        while start<end:\\n            if s[start]==s[end]:\\n                start += 1\\n                end -= 1\\n            else:\\n                start = 0\\n                lastValidEnd -= 1\\n                end = lastValidEnd\\n        return s[len(s)-1:lastValidEnd:-1]+s",
                "codeTag": "Python3"
            },
            {
                "id": 60240,
                "title": "my-fingerprint-based-solution-in-c-4ms",
                "content": "The idea is to compute the fingerprints of the first k characters of the string, and fingerprints of the first k characters reversed. Then find the largest k where the fingerprint and reversed fingerprint of the first k characters  are the same. Of course you verify s.substr(0, k) is a palindrome (it's likely to be) and continue finding if it's not.\\n\\nThe key is that fingerprints can be computed in O(n) time.\\n\\n\\n    class Solution {\\n    public:\\n        static const int BASE = 19;\\n        string shortestPalindrome(string s) {\\n            int n = s.size();\\n            if (n == 0) {\\n                return \"\";\\n            }\\n            int fp[n];\\n            int fp_r[n];\\n            fp_r[0] = fp[0] = static_cast<int>(s[0]);\\n            int mul = BASE;\\n            for (int i = 1; i < n; ++i) {\\n                // it's ok to overflow.\\n                int tmp = static_cast<int>(s[i]);\\n                fp[i] = fp[i - 1] * BASE + tmp;\\n                fp_r[i] = fp_r[i - 1] + tmp * mul;\\n                mul *= BASE;\\n            }\\n            int i = n - 1;\\n            while (i) {\\n                if (fp[i] == fp_r[i] && verify(s, i)) {\\n                    break;\\n                }\\n                i--;\\n            }\\n            return string(s.rbegin(), s.rend()) + s.substr(i + 1, n - i - 1);\\n        }\\n        bool verify(const string& s, int idx) {\\n            for (int i = 0, j = idx; i < j; ++i, --j) {\\n                if (s[i] != s[j]) {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        static const int BASE = 19;\\n        string shortestPalindrome(string s) {\\n            int n = s.size();\\n            if (n == 0) {\\n                return \"\";\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 60246,
                "title": "java-kmp-accepted-simple-idea",
                "content": "the idea is very straight-forward, basically you get p= s.reverse(), and use p as a \"long string\" and s as a \"query pattern\" and cast it as a KMP pattern search problem. the only tweak is that we are only search for a ***prefix of **** s, so the only change from standard KMP is to exit on i==length(s), not j==length(pattern)\\n\\n \\n\\n    public class Solution {\\n        public String shortestPalindrome(String s) {\\n            String p = new StringBuffer(s).reverse().toString();\\n            char pp[] = p.toCharArray();\\n            char ss[] = s.toCharArray();\\n            int m = ss.length;\\n            if (m == 0) return \"\";\\n            \\n            // trying to find the greatest overlap of pp[] and ss[]\\n            // using the buildLPS() method of KMP\\n            int lps[] = buildLPS(ss);\\n            int i=0;// points to pp[]\\n            int len = 0; //points to ss[]\\n    \\n            while(i<m) {\\n                if (pp[i] == ss[len]) {\\n                    i++;\\n                    len++;\\n                    if (i == m)\\n                        break;\\n                } else {\\n                    if (len == 0) {\\n                        i++;\\n                    } else {\\n                        len = lps[len-1];\\n                    }\\n                }\\n            }\\n            // after the loop, len is the overlap of the suffix of pp and prefix of ss\\n            return new String(pp) + s.substring(len, m);\\n            \\n        }\\n        \\n        int [] buildLPS(char ss[]) {\\n            int m = ss.length;\\n            int lps[] = new int[m];\\n            int len = 0;\\n            int i = 1;\\n            lps[0] = 0;\\n            while(i < m) {\\n                if (ss[i] == ss[len]) {\\n                    len++;\\n                    lps[i] = len;\\n                    i++;\\n                } else {\\n                    if (len == 0) {\\n                        i++;\\n                    } else {\\n                        len = lps[len-1];\\n                    }\\n                        \\n                }\\n            }\\n            \\n            return lps;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public String shortestPalindrome(String s) {\\n            String p = new StringBuffer(s).reverse().toString();\\n            char pp[] = p.toCharArray();\\n            char ss[] = s.toCharArray();\\n            int m = ss.length;\\n            if (m == 0) return \"\";\\n            \\n            // trying to find the greatest overlap of pp[] and ss[]\\n            // using the buildLPS() method of KMP\\n            int lps[] = buildLPS(ss);\\n            int i=0;// points to pp[]\\n            int len = 0; //points to ss[]\\n    \\n            while(i<m) {\\n                if (pp[i] == ss[len]) {\\n                    i++;\\n                    len++;\\n                    if (i == m)\\n                        break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 60258,
                "title": "java-kmp-preprocess-o-n",
                "content": "    //S is the pattern to be preprocessed\\n\\t//output[i] is the failure index that output redirected to\\n\\tpublic static int[] KMPpreprocess(String S){\\n\\t\\tint[] pi=new int[S.length()];\\n\\t\\t//init start of pi\\n\\t\\tpi[0]=-1;\\n\\t\\t//get each index in pi, i is the index being processed\\n\\t\\tfor (int i=1;i<pi.length;i++){\\n\\t\\t\\tint j=pi[i-1];\\n\\t\\t\\twhile (j!=-1 && S.charAt(j+1)!=S.charAt(i)) {j=pi[j];}\\n\\t\\t\\tif (j==-1){\\n\\t\\t\\t\\tif (S.charAt(0)==S.charAt(i)) pi[i]=0;\\n\\t\\t\\t\\telse pi[i]=-1;\\n\\t\\t\\t}\\n\\t\\t\\telse if (S.charAt(j+1)==S.charAt(i)){\\n\\t\\t\\t\\tpi[i]=j+1;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn pi;\\n\\t}\\n\\t\\n\\tpublic static String reverse(String s){\\n\\t\\tchar[] outC=new char[s.length()];\\n\\t\\tfor (int i=0;i<outC.length;i++){\\n\\t\\t\\toutC[i]=s.charAt(outC.length-1-i);\\n\\t\\t}\\n\\t\\treturn new String(outC);\\n\\t}\\n\\t\\n\\tpublic static String shortestPalindrome(String s) {\\n        String sPlus=s+\"#\"+reverse(s);\\n        int[] PI=KMPpreprocess(sPlus);\\n        int palinIndex=Math.min(PI[PI.length-1],s.length()-1);\\n        \\n        String nonPalin=s.substring(palinIndex+1);\\n        String Palin=s.substring(0,palinIndex+1);\\n        return reverse(nonPalin)+Palin+nonPalin;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    //S is the pattern to be preprocessed\\n\\t//output[i] is the failure index that output redirected to\\n\\tpublic static int[] KMPpreprocess(String S){\\n\\t\\tint[] pi=new int[S.length()];\\n\\t\\t//init start of pi\\n\\t\\tpi[0]=-1;\\n\\t\\t//get each index in pi, i is the index being processed\\n\\t\\tfor (int i=1;i<pi.length;i++){\\n\\t\\t\\tint j=pi[i-1];\\n\\t\\t\\twhile (j!=-1 && S.charAt(j+1)!=S.charAt(i)) {j=pi[j];}\\n\\t\\t\\tif (j==-1){\\n\\t\\t\\t\\tif (S.charAt(0)==S.charAt(i)) pi[i]=0;\\n\\t\\t\\t\\telse pi[i]=-1;\\n\\t\\t\\t}\\n\\t\\t\\telse if (S.charAt(j+1)==S.charAt(i)){\\n\\t\\t\\t\\tpi[i]=j+1;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn pi;\\n\\t}\\n\\t\\n\\tpublic static String reverse(String s){\\n\\t\\tchar[] outC=new char[s.length()];\\n\\t\\tfor (int i=0;i<outC.length;i++){\\n\\t\\t\\toutC[i]=s.charAt(outC.length-1-i);\\n\\t\\t}\\n\\t\\treturn new String(outC);\\n\\t}\\n\\t\\n\\tpublic static String shortestPalindrome(String s) {\\n        String sPlus=s+\"#\"+reverse(s);\\n        int[] PI=KMPpreprocess(sPlus);\\n        int palinIndex=Math.min(PI[PI.length-1],s.length()-1);\\n        \\n        String nonPalin=s.substring(palinIndex+1);\\n        String Palin=s.substring(0,palinIndex+1);\\n        return reverse(nonPalin)+Palin+nonPalin;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 60272,
                "title": "a-10-line-in-space-accepted-c-solution-608ms",
                "content": "    public string ShortestPalindrome(string s) {\\n        for(int iCursor = s.Length - 1; iCursor >= 0; iCursor--)\\n            for (int i = 0, j = iCursor; i <= j; i++, j--){\\n                if (s[i] != s[j]) break;\\n                if (i == j || i == j - 1){\\n                    char[] sHead = s.Substring(iCursor + 1).ToArray();\\n                    Array.Reverse(sHead);\\n                    return new string(sHead) + s;\\n                }\\n            }\\n        return s;\\n    }",
                "solutionTags": [],
                "code": "    public string ShortestPalindrome(string s) {\\n        for(int iCursor = s.Length - 1; iCursor >= 0; iCursor--)\\n            for (int i = 0, j = iCursor; i <= j; i++, j--){\\n                if (s[i] != s[j]) break;\\n                if (i == j || i == j - 1){\\n                    char[] sHead = s.Substring(iCursor + 1).ToArray();\\n                    Array.Reverse(sHead);\\n                    return new string(sHead) + s;\\n                }\\n            }\\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 60283,
                "title": "java-solution-ac-o-n-2-with-lots-of-comments",
                "content": "    public class Solution {\\n        public String shortestPalindrome(String s) {\\n            //a or empty string\\n            if (s.length()<2) return s;\\n            \\n            char[] c=s.toCharArray();\\n            //We can always use the first character of an odd length solution\\n            int r=s.length()%2;\\n\\n            //start at the end, the first one we find will be the longest internal palindrome\\n            for(int j=c.length-1;j>=0;j--) {\\n                if(c[0]==c[j]) {\\n                    int i=j;\\n                    int nk=j;\\n                    boolean fail=false;\\n                    //check that it's a palindrome till we hit the halfway mark\\n                    for(;i>=j/2;i--) {\\n                        if(c[i]==c[j]) {\\n                            //keep track of where to pick up if this fails\\n                            nk=j;\\n                        }\\n                        if (c[j-i]!=c[i]) { \\n                            //not a palindrome\\n                            fail=true;\\n                            break;\\n                        }\\n                    }\\n                    if (!fail) {\\n                       //we found the longest one, we're done\\n                        r=j;\\n                        break;\\n                    } else {\\n                       //pick up at a possible palindrome spot\\n                        j=nk;\\n                    }\\n                }\\n            }\\n            //If the whole thing is a palindrome then return it unchanged\\n            if (r==s.length()) return s;\\n            StringBuffer prepend=new StringBuffer();\\n            //otherwise reverse prepend to the string\\n            for(int i=c.length-1;i>r;i--) {\\n                 prepend.append(c[i]);\\n            }\\n            //and put the rest of the word on the end.\\n            prepend.append(s);\\n            \\n                \\n            return prepend.toString();\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String shortestPalindrome(String s) {\\n            //a or empty string\\n            if (s.length()<2) return s;\\n            \\n            char[] c=s.toCharArray();\\n            //We can always use the first character of an odd length solution\\n            int r=s.length()%2;\\n\\n            //start at the end, the first one we find will be the longest internal palindrome\\n            for(int j=c.length-1;j>=0;j--) {\\n                if(c[0]==c[j]) {\\n                    int i=j;\\n                    int nk=j;\\n                    boolean fail=false;\\n                    //check that it's a palindrome till we hit the halfway mark\\n                    for(;i>=j/2;i--) {\\n                        if(c[i]==c[j]) {\\n                            //keep track of where to pick up if this fails\\n                            nk=j;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 3967852,
                "title": "rolling-hash-rabin-karp-s",
                "content": "# Intuition\\nAs we have to add extra chars in the front, it\\'s something to do with the prefix or suffix of the string.\\n\\n# Approach\\n(Written in the comments)\\nAlso refer to the Longest pallondromic Prefix problem once.\\n# Complexity\\n- Time complexity:\\nO(n+n+n)\\n1 for finding the pallindromic prefix pos\\n2 for substr\\n3 for reverse\\n\\n- Space complexity:\\nO(n)\\nsubstr\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\n\\n    //  1.  aacecaaa\\n    //  2.  abcd\\n    /*\\n        let p = -1;\\n        find p => longest pallindromic prefix in s\\n        in 1st \\n            p = 7\\n            so add letters after 7th letter in the front and reverse\\n            here a+aacecaaa\\n        in 2nd\\n            p = 0\\n            means, add all the letters from 1st to last but reversed\\n            here dcba+abcd\\n        \\n        so use rabin karp\\'s rolling hash method to find longest pallindromic prefix\\n    */\\npublic:\\n    string shortestPalindrome(string s) {\\n        const int n = s.length();\\n        int palpos = -1, mod = 1000000007;\\n        ll p = 31, ph = 0, sh = 0, pow = 1;\\n        for(int i=0; i<n; i++){\\n            ph = (ph*p + (s[i] - \\'a\\' + 1))%mod;\\n            sh = (sh + (s[i] - \\'a\\' + 1)*pow)%mod;\\n            pow = pow*p%mod;\\n            if(sh == ph)\\n                palpos = i;\\n        }\\n        string extra = \"\";\\n        extra = s.substr(palpos+1, n);\\n        reverse(extra.begin(), extra.end());\\n        return (extra+s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Rolling Hash",
                    "Hash Function"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\n\\n    //  1.  aacecaaa\\n    //  2.  abcd\\n    /*\\n        let p = -1;\\n        find p => longest pallindromic prefix in s\\n        in 1st \\n            p = 7\\n            so add letters after 7th letter in the front and reverse\\n            here a+aacecaaa\\n        in 2nd\\n            p = 0\\n            means, add all the letters from 1st to last but reversed\\n            here dcba+abcd\\n        \\n        so use rabin karp\\'s rolling hash method to find longest pallindromic prefix\\n    */\\npublic:\\n    string shortestPalindrome(string s) {\\n        const int n = s.length();\\n        int palpos = -1, mod = 1000000007;\\n        ll p = 31, ph = 0, sh = 0, pow = 1;\\n        for(int i=0; i<n; i++){\\n            ph = (ph*p + (s[i] - \\'a\\' + 1))%mod;\\n            sh = (sh + (s[i] - \\'a\\' + 1)*pow)%mod;\\n            pow = pow*p%mod;\\n            if(sh == ph)\\n                palpos = i;\\n        }\\n        string extra = \"\";\\n        extra = s.substr(palpos+1, n);\\n        reverse(extra.begin(), extra.end());\\n        return (extra+s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839216,
                "title": "get-the-common-prefix-which-also-a-suffix",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> prefixArray(string &s){\\n    int n = s.length();\\n    vector<int> kmp(n+1);\\n    int i = 0,j = -1;\\n    kmp[0] = -1;\\n    while(i < n){\\n        while(j != -1 && s[j] != s[i]){\\n            j = kmp[j];      \\n        }\\n        j++; i++;     \\n        kmp[i] = j; \\n    }\\n    \\n    return kmp;   \\n}\\n    \\n    \\n    string shortestPalindrome(string s) {\\n        \\n        string rev = s;\\n        reverse(rev.begin(),rev.end());\\n        \\n        string mx = s+\\'$\\'+rev;\\n        \\n        \\n        int n = mx.length();\\n        \\n        vector ps = prefixArray(mx);\\n        int v = ps[n];\\n        \\n        \\n        string res = s.substr(v);\\n        \\n        reverse(res.begin(),res.end());\\n        \\n        return res+s;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> prefixArray(string &s){\\n    int n = s.length();\\n    vector<int> kmp(n+1);\\n    int i = 0,j = -1;\\n    kmp[0] = -1;\\n    while(i < n){\\n        while(j != -1 && s[j] != s[i]){\\n            j = kmp[j];      \\n        }\\n        j++; i++;     \\n        kmp[i] = j; \\n    }\\n    \\n    return kmp;   \\n}\\n    \\n    \\n    string shortestPalindrome(string s) {\\n        \\n        string rev = s;\\n        reverse(rev.begin(),rev.end());\\n        \\n        string mx = s+\\'$\\'+rev;\\n        \\n        \\n        int n = mx.length();\\n        \\n        vector ps = prefixArray(mx);\\n        int v = ps[n];\\n        \\n        \\n        string res = s.substr(v);\\n        \\n        reverse(res.begin(),res.end());\\n        \\n        return res+s;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626197,
                "title": "easy-kmp-algorithm",
                "content": "# Intuition\\nIn this question, we can add chars only to the beginning of the string. So, whatever characters we add, those will be tha matching pairs for the characters present at the ending of the given string. Hence, there will be a prefix substring left for whom we don\\'t have to add any characters at the beginning of the string, as they must be a palindrome. Hence, we have to find the longest palindrome prefix of the given string. And the strings other than this palindrome prefix, we have to add characters for them in the beginning of the string.\\n# Approach\\nTo find longest palindrome prefix we will use KMP. Longest prefix that is suffix, a standard problem of KMP, found using Failure function construction. \\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s) \\n    {\\n        reverse(s.begin(), s.end());\\n        string rev = s;\\n        reverse(s.begin(), s.end());\\n        string temp = s + \"@\" + rev;\\n        vector<int> vr = fail_fun(temp);\\n\\n        int maxm = vr[vr.size()-1];\\n\\n        temp = \"\";\\n        for(int i = maxm; i < s.length(); i++)\\n        {\\n            temp = temp + s[i];\\n        }        \\n        reverse(temp.begin(), temp.end());\\n        return temp + s;\\n    }\\n\\n    vector<int> fail_fun(string &s)\\n    {\\n        int n = s.length();\\n        vector<int> fail_ar(n, 0);\\n\\n        for(int i = 1, k = 0; i < n; i++)\\n        {\\n            while(k > 0 && s[k] != s[i])\\n            {\\n                k = fail_ar[k-1];\\n            }\\n\\n            if(s[k] == s[i])\\n            {\\n                fail_ar[i] = ++k;\\n            }\\n        }\\n\\n        return fail_ar;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s) \\n    {\\n        reverse(s.begin(), s.end());\\n        string rev = s;\\n        reverse(s.begin(), s.end());\\n        string temp = s + \"@\" + rev;\\n        vector<int> vr = fail_fun(temp);\\n\\n        int maxm = vr[vr.size()-1];\\n\\n        temp = \"\";\\n        for(int i = maxm; i < s.length(); i++)\\n        {\\n            temp = temp + s[i];\\n        }        \\n        reverse(temp.begin(), temp.end());\\n        return temp + s;\\n    }\\n\\n    vector<int> fail_fun(string &s)\\n    {\\n        int n = s.length();\\n        vector<int> fail_ar(n, 0);\\n\\n        for(int i = 1, k = 0; i < n; i++)\\n        {\\n            while(k > 0 && s[k] != s[i])\\n            {\\n                k = fail_ar[k-1];\\n            }\\n\\n            if(s[k] == s[i])\\n            {\\n                fail_ar[i] = ++k;\\n            }\\n        }\\n\\n        return fail_ar;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549444,
                "title": "brute-force",
                "content": "# Intuition\\nFirst, we need to find the pre-existing palindrome in the string (if it is there). Then, we\\'ll add characters to complete that palindrome.\\n\\n# Approach\\nI created a reversed string \\'p\\'. Then, I iterated over the length of \\'s\\' and check if the inital \\'n-i\\' characters of \\'s\\' are same as the last \\'n-i\\' characters of \\'p\\'. If they are equal, loop breaks as we\\'ve found a palindrome. Else, the last character is added to a string, which is eventually added to the original string \\'s\\'.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\nBecause there\\'s a for loop and then we\\'re slicing the string. (n+n-1+n-2 .. ~ n(n-1)/2)\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def shortestPalindrome(self, s: str) -> str:\\n        p = s[::-1]\\n        add = \"\"\\n        n = len(s)\\n        for i in range (n):\\n            a = s[0:n-i]\\n            b = p[i:]\\n            if (a!=b):\\n                add+=a[-1]\\n            else:\\n                break\\n        return add+s\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestPalindrome(self, s: str) -> str:\\n        p = s[::-1]\\n        add = \"\"\\n        n = len(s)\\n        for i in range (n):\\n            a = s[0:n-i]\\n            b = p[i:]\\n            if (a!=b):\\n                add+=a[-1]\\n            else:\\n                break\\n        return add+s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541945,
                "title": "approacg2-using-kmp-algorithm",
                "content": "# Intuition\\nHere we tweak the KMP algorithm used to calculate the function lookup table.So the problem reduces to just calculating maximul length prefix which is equal to suffix which reduces the time complexity a\\n\\n# Approach\\n- First we create s_new which is s+#+reverse(s) and use this to generate lookup table\\n- The \"#\" in the middle is required, since without the #, the 2 strings could mix with each ther, producing wrong answer.\\n- we then calculate the lookup table using the KMP algorithm\\n ```\\nf(0) = 0\\nfor (i = 1 , i < n , i++) {\\n    t = f(i-1)\\n    while (t > 0 && b[i] != b[t]) {\\n        t = f(t-1)\\n    }\\n    if (b[i] == b[t]) {\\n        ++t\\n    }\\n    f(i) = t\\n}\\n```\\n- Then return reversed string after the largest palindrome from beginning length(\\nev.substr(0,n-lps[n_new-1])) + original string\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n       string shortestPalindrome(string s) {\\n        int n=s.size();\\n        string rev=s;\\n        reverse(rev.begin(), rev.end());\\n        string s_new = s + \"#\" + rev;\\n        int n_new = s_new.size();\\n        vector<int> lps(n_new, 0);\\n        int t=0;\\n        for(int i=1;i<n_new;i++){\\n            t=lps[i-1];\\n            while(t>0 && s_new[i]!=s_new[t]){\\n                t=lps[t-1];\\n            }\\n            if(s_new[i]==s_new[t]){\\n                ++t;\\n            }\\n            lps[i]=t;\\n        }\\n        return rev.substr(0,n-lps[n_new-1]) + s;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nf(0) = 0\\nfor (i = 1 , i < n , i++) {\\n    t = f(i-1)\\n    while (t > 0 && b[i] != b[t]) {\\n        t = f(t-1)\\n    }\\n    if (b[i] == b[t]) {\\n        ++t\\n    }\\n    f(i) = t\\n}\\n```\n```\\nclass Solution {\\npublic:\\n       string shortestPalindrome(string s) {\\n        int n=s.size();\\n        string rev=s;\\n        reverse(rev.begin(), rev.end());\\n        string s_new = s + \"#\" + rev;\\n        int n_new = s_new.size();\\n        vector<int> lps(n_new, 0);\\n        int t=0;\\n        for(int i=1;i<n_new;i++){\\n            t=lps[i-1];\\n            while(t>0 && s_new[i]!=s_new[t]){\\n                t=lps[t-1];\\n            }\\n            if(s_new[i]==s_new[t]){\\n                ++t;\\n            }\\n            lps[i]=t;\\n        }\\n        return rev.substr(0,n-lps[n_new-1]) + s;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389935,
                "title": "string-hashing-easy-solution-c-99-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    ll mod=1e9+7;\\n    string shortestPalindrome(string s) {\\n        int n=s.length();\\n        int ans=1;\\n        ll fact=31;\\n        ll pref=(s[0]-\\'a\\'+1);\\n        ll suff=pref;\\n        \\n        for(int i=1;i<n;i++){\\n            pref+=(s[i]-\\'a\\'+1)*fact;\\n            suff=suff*31+(s[i]-\\'a\\'+1);\\n            pref%=mod;\\n            suff%=mod;\\n            \\n            if(pref==suff){\\n                ans=i+1;\\n            }\\n            \\n            fact=fact*31;\\n            fact%=mod;\\n        }\\n        \\n        string ss=\"\";\\n        for(int i=n-1;i>=ans;i--)ss+=s[i];\\n        ss+=s;\\n        return ss;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "String",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    ll mod=1e9+7;\\n    string shortestPalindrome(string s) {\\n        int n=s.length();\\n        int ans=1;\\n        ll fact=31;\\n        ll pref=(s[0]-\\'a\\'+1);\\n        ll suff=pref;\\n        \\n        for(int i=1;i<n;i++){\\n            pref+=(s[i]-\\'a\\'+1)*fact;\\n            suff=suff*31+(s[i]-\\'a\\'+1);\\n            pref%=mod;\\n            suff%=mod;\\n            \\n            if(pref==suff){\\n                ans=i+1;\\n            }\\n            \\n            fact=fact*31;\\n            fact%=mod;\\n        }\\n        \\n        string ss=\"\";\\n        for(int i=n-1;i>=ans;i--)ss+=s[i];\\n        ss+=s;\\n        return ss;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295814,
                "title": "shortest-palindrome-using-rust",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAdd characters in beginning to make the whole string into Palindrome\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Reverse the original string and store it in a variable rev_str.\\n```\\nlet rev_str = s.chars().rev().collect::<String>();\\n```\\n2. Iterate through each index i in the reversed string rev_str.\\n```\\nfor i in 0..rev_str.len()\\n```\\n3. Check if the original string s starts with the suffix of rev_str from index i to the end.\\n```\\nif s.starts_with(&rev_str[i..])\\n```\\n4. If a palindrome suffix is found, prepend the remaining characters in rev_str to s to create the shortest palindrome.\\n```\\nreturn format!(\"{}{}\", &rev_str[..i], s)\\n```\\n5. If no palindrome suffix is found, the entire reversed string rev_str must be added to the front of s to create the shortest palindrome.\\n```\\nformat!(\"{}{}\", &rev_str, s)\\n```\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn shortest_palindrome(s: String) -> String {\\n        let rev_str = s.chars().rev().collect::<String>();\\n        \\n        for i in 0..rev_str.len() {\\n            if s.starts_with(&rev_str[i..]) {\\n                return format!(\"{}{}\", &rev_str[..i], s);\\n            }\\n        }\\n\\n        format!(\"{}{}\", &rev_str, s)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nlet rev_str = s.chars().rev().collect::<String>();\\n```\n```\\nfor i in 0..rev_str.len()\\n```\n```\\nif s.starts_with(&rev_str[i..])\\n```\n```\\nreturn format!(\"{}{}\", &rev_str[..i], s)\\n```\n```\\nformat!(\"{}{}\", &rev_str, s)\\n```\n```\\nimpl Solution {\\n    pub fn shortest_palindrome(s: String) -> String {\\n        let rev_str = s.chars().rev().collect::<String>();\\n        \\n        for i in 0..rev_str.len() {\\n            if s.starts_with(&rev_str[i..]) {\\n                return format!(\"{}{}\", &rev_str[..i], s);\\n            }\\n        }\\n\\n        format!(\"{}{}\", &rev_str, s)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3212484,
                "title": "rabin-karp-and-kmp",
                "content": "# Code\\n```\\nclass Solution:\\n\\n    # https://leetcode.com/problems/shortest-palindrome/solutions/60153/8-line-o-n-method-using-rabin-karp-rolling-hash/\\n    # There is a slight chance that ther could be a hash collision. But this is very \\n    # unlikely. And we can add check for this where we save all the i values when \\n    # hash was equal and then compare the i values to see if the sbstring is a palandrome\\n    def usingRK(self, s):\\n        # Convert letter to id\\n        def id(letter): return ord(letter) - ord(\\'a\\')\\n\\n        hash1, hash2 = 0, 0\\n        base = 26\\n        mod = 10**9 + 7\\n        power = 1 # We update power so new incoming letter gets highest weight \\n        # The first character will be a palandrome. So we no longer palandrome we can atleast \\n        # use this: abcd --> dcbabcd (we reuse a and only reverse bcd since a is a palandrome)\\n        pal = 0 \\n        for i in range(len(s)):\\n            hash1 = (hash1 * base + id(s[i])) % mod # First char has highest weight \\n            hash2 = (hash2 + id(s[i]) * power) % mod # Last char has highest weight \\n            power = power * base # Power is updated each time so its equal to base ^ (n-1)\\n            if hash1 == hash2:\\n                print(i)\\n                # For aacecaaa this will be true for 0, 1, 6 index \\n                # This works because we calculate hash in 2 directions \\n                # 1st - Leftmost char has highest weight \\n                # 2nd - Leftmost char has least weight\\n                # When all the characters in string form palandrome \\n                # The weights will balance each other and the hash will be same \\n                pal = i\\n        # Reverse substring that is not part of palandrome \\n        reversed_suffix = s[pal+1:][::-1]\\n        return  reversed_suffix + s\\n\\n    def usingKMP(self, s):\\n        def longestSuffixPrefix(s):\\n            lsp = [0] * len(s)\\n            for end in range(1, len(s)):\\n                start = lsp[end-1]\\n                while start > 0 and s[start] != s[end]:\\n                    start = lsp[start - 1]\\n                if s[start] == s[end]:\\n                    lsp[end] = start + 1\\n            return lsp\\n\\n        # We need # to seperate string and its reverse \\n        # Consider aaaa\\n        # s + rev: aaaa|aaaa \\n        # The LPS value for last a will be 7 for aaaaaaa. \\n        # But we don\\'t want this. We are only interested in LSP of original string \\n        # When we add a # the hash will be close to prefix start than suffix start \\n        # So any thing beyond the length of original string will not be considered \\n        # [a{aaa#aaa]a} notice how # is closer to 1 than other? \\n        rev =  s[::-1]\\n        s_and_rev = s + \"#\" + rev\\n\\n        # We are calculating the LSP table of KMP. \\n        lsp = longestSuffixPrefix(s_and_rev)\\n        \\n        # Ref - https://www.youtube.com/watch?v=c4akpqTwE5g\\n        # Consider abab\\n        # If we appended its reverese to the start then we would definiely get a palandrome \\n        # baba|abab\\n        # But this is not the shortest palandrome. This is because abab has a palandrome in it \\n        # [aba]b. \\n        # So we get extra aba in the reverse string we attach. \\n        # This extra aba is nothing but longest commpon prefix suffix when we attach s and s reversed:\\n        # [aba]b|b[aba]\\n        # Now KMPs LSP table for last element will have value 3, since we have aba matching. \\n        # So if we ignore those characters then we can just append b from reverse to start of abab to \\n        # get shortest palandrome. \\n        return rev[0:len(s) - lsp[-1]] + s\\n            \\n\\n\\n    # Will run in O(N)\\n    def shortestPalindrome(self, s: str) -> str:\\n\\n        return self.usingRK(s)\\n\\n        # return self.usingKMP(s)\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    # https://leetcode.com/problems/shortest-palindrome/solutions/60153/8-line-o-n-method-using-rabin-karp-rolling-hash/\\n    # There is a slight chance that ther could be a hash collision. But this is very \\n    # unlikely. And we can add check for this where we save all the i values when \\n    # hash was equal and then compare the i values to see if the sbstring is a palandrome\\n    def usingRK(self, s):\\n        # Convert letter to id\\n        def id(letter): return ord(letter) - ord(\\'a\\')\\n\\n        hash1, hash2 = 0, 0\\n        base = 26\\n        mod = 10**9 + 7\\n        power = 1 # We update power so new incoming letter gets highest weight \\n        # The first character will be a palandrome. So we no longer palandrome we can atleast \\n        # use this: abcd --> dcbabcd (we reuse a and only reverse bcd since a is a palandrome)\\n        pal = 0 \\n        for i in range(len(s)):\\n            hash1 = (hash1 * base + id(s[i])) % mod # First char has highest weight \\n            hash2 = (hash2 + id(s[i]) * power) % mod # Last char has highest weight \\n            power = power * base # Power is updated each time so its equal to base ^ (n-1)\\n            if hash1 == hash2:\\n                print(i)\\n                # For aacecaaa this will be true for 0, 1, 6 index \\n                # This works because we calculate hash in 2 directions \\n                # 1st - Leftmost char has highest weight \\n                # 2nd - Leftmost char has least weight\\n                # When all the characters in string form palandrome \\n                # The weights will balance each other and the hash will be same \\n                pal = i\\n        # Reverse substring that is not part of palandrome \\n        reversed_suffix = s[pal+1:][::-1]\\n        return  reversed_suffix + s\\n\\n    def usingKMP(self, s):\\n        def longestSuffixPrefix(s):\\n            lsp = [0] * len(s)\\n            for end in range(1, len(s)):\\n                start = lsp[end-1]\\n                while start > 0 and s[start] != s[end]:\\n                    start = lsp[start - 1]\\n                if s[start] == s[end]:\\n                    lsp[end] = start + 1\\n            return lsp\\n\\n        # We need # to seperate string and its reverse \\n        # Consider aaaa\\n        # s + rev: aaaa|aaaa \\n        # The LPS value for last a will be 7 for aaaaaaa. \\n        # But we don\\'t want this. We are only interested in LSP of original string \\n        # When we add a # the hash will be close to prefix start than suffix start \\n        # So any thing beyond the length of original string will not be considered \\n        # [a{aaa#aaa]a} notice how # is closer to 1 than other? \\n        rev =  s[::-1]\\n        s_and_rev = s + \"#\" + rev\\n\\n        # We are calculating the LSP table of KMP. \\n        lsp = longestSuffixPrefix(s_and_rev)\\n        \\n        # Ref - https://www.youtube.com/watch?v=c4akpqTwE5g\\n        # Consider abab\\n        # If we appended its reverese to the start then we would definiely get a palandrome \\n        # baba|abab\\n        # But this is not the shortest palandrome. This is because abab has a palandrome in it \\n        # [aba]b. \\n        # So we get extra aba in the reverse string we attach. \\n        # This extra aba is nothing but longest commpon prefix suffix when we attach s and s reversed:\\n        # [aba]b|b[aba]\\n        # Now KMPs LSP table for last element will have value 3, since we have aba matching. \\n        # So if we ignore those characters then we can just append b from reverse to start of abab to \\n        # get shortest palandrome. \\n        return rev[0:len(s) - lsp[-1]] + s\\n            \\n\\n\\n    # Will run in O(N)\\n    def shortestPalindrome(self, s: str) -> str:\\n\\n        return self.usingRK(s)\\n\\n        # return self.usingKMP(s)\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020446,
                "title": "don-t-you-wanna-check-this-simple-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s) {\\n        int n = s.length();\\n        int i = 0;\\n        for (int j = n - 1; j >= 0; j--) {\\n            if (s[i] == s[j]) i++;\\n        }\\n        if (i == n) return s;\\n        string rem = s.substr(i);\\n        reverse(rem.begin(), rem.end());\\n        return rem + shortestPalindrome(s.substr(0, i)) + s.substr(i);\\n    }\\n\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s) {\\n        int n = s.length();\\n        int i = 0;\\n        for (int j = n - 1; j >= 0; j--) {\\n            if (s[i] == s[j]) i++;\\n        }\\n        if (i == n) return s;\\n        string rem = s.substr(i);\\n        reverse(rem.begin(), rem.end());\\n        return rem + shortestPalindrome(s.substr(0, i)) + s.substr(i);\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753772,
                "title": "with-2-pointer-easy-to-understand-121-121-test-cases-passed-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s) {\\n        int endPointer=s.length()-1;\\n        int start = 0;\\n        int end = s.length()-1;\\n        string temp=\"\";\\n        while(start<end){\\n             if(s[start]==s[end]){\\n                 start++;\\n                 end--;\\n             }else{\\n                 temp.push_back(s[endPointer]);\\n                 endPointer--;\\n                 start=0;\\n                 end=endPointer;\\n                 if(end==0){\\n                     break;\\n                 }  \\n             }\\n        }\\n        \\n        temp=temp+s;\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s) {\\n        int endPointer=s.length()-1;\\n        int start = 0;\\n        int end = s.length()-1;\\n        string temp=\"\";\\n        while(start<end){\\n             if(s[start]==s[end]){\\n                 start++;\\n                 end--;\\n             }else{\\n                 temp.push_back(s[endPointer]);\\n                 endPointer--;\\n                 start=0;\\n                 end=endPointer;\\n                 if(end==0){\\n                     break;\\n                 }  \\n             }\\n        }\\n        \\n        temp=temp+s;\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2699971,
                "title": "javascript-o-n-time-lps-approach",
                "content": "# Intuition\\nUsing LPS (Longest proper prefix which is also a suffix) of `str + \"#\" + str.reverse()`, we can find out the longest palindrome in the string starting from 1st character.\\n\\n# Approach\\nIf we know the longest palindrome from the start, we just need to add the remaining characters of the string to the start of the string in reverse order, to make the complete string palindrome.\\n\\n# Complexity\\n- Time complexity:\\nFinding reverse of string = $$O(n)$$\\nFinding Longest palindrome in string = $$O(n)$$\\n\\nOverall = $$O(n)$$\\n\\n- Space complexity:\\n$$O(2n)$$\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\n\\nString.prototype.reverse = function () {\\n    return this.valueOf().split(\"\").reverse().join(\"\");\\n}\\n\\nvar shortestPalindrome = function (s) {\\n    if (s === \"\") {\\n        return s;\\n    }\\n\\n    let tempStr = s + \"#\" + s.reverse();\\n    let len = lps(tempStr);\\n    let strLength = s.length;\\n\\n    return s.substring(len, strLength).reverse() + s;\\n};\\n\\n\\nfunction lps(s) {\\n\\n    let lps = new Array(s.length);\\n    let i = 1;\\n    let len = 0;\\n    lps[0] = 0;\\n\\n    while (i < s.length) {\\n        if (s[i] === s[len]) {\\n            len++;\\n            lps[i] = len;\\n            i++;\\n        } else {\\n            if (len > 0) {\\n                len = lps[len - 1];\\n            } else {\\n                lps[i] = 0;\\n                i++;\\n            }\\n        }\\n    }\\n\\n    return lps[lps.length - 1];\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\n\\nString.prototype.reverse = function () {\\n    return this.valueOf().split(\"\").reverse().join(\"\");\\n}\\n\\nvar shortestPalindrome = function (s) {\\n    if (s === \"\") {\\n        return s;\\n    }\\n\\n    let tempStr = s + \"#\" + s.reverse();\\n    let len = lps(tempStr);\\n    let strLength = s.length;\\n\\n    return s.substring(len, strLength).reverse() + s;\\n};\\n\\n\\nfunction lps(s) {\\n\\n    let lps = new Array(s.length);\\n    let i = 1;\\n    let len = 0;\\n    lps[0] = 0;\\n\\n    while (i < s.length) {\\n        if (s[i] === s[len]) {\\n            len++;\\n            lps[i] = len;\\n            i++;\\n        } else {\\n            if (len > 0) {\\n                len = lps[len - 1];\\n            } else {\\n                lps[i] = 0;\\n                i++;\\n            }\\n        }\\n    }\\n\\n    return lps[lps.length - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2541808,
                "title": "python3-epic-3-liner",
                "content": ":)\\n```\\nclass Solution:\\n    def shortestPalindrome(self, s: str) -> str:\\n        for i in range(len(s), -1, -1):\\n            if s[:i] == s[i-1::-1]:\\n                return s[:i-1:-1] + s",
                "solutionTags": [
                    "Python3"
                ],
                "code": ":)\\n```\\nclass Solution:\\n    def shortestPalindrome(self, s: str) -> str:\\n        for i in range(len(s), -1, -1):\\n            if s[:i] == s[i-1::-1]:\\n                return s[:i-1:-1] + s",
                "codeTag": "Java"
            },
            {
                "id": 2352765,
                "title": "bruteforce-approach",
                "content": "public String shortestPalindrome(String s) {\\n        String result = \"\";\\n        if (isPalindrome(s)) {\\n            return s;\\n        }\\n        StringBuilder stringBuilder = new StringBuilder();\\n        for (int i=1; i<s.length(); i++) {\\n            stringBuilder.append(s.charAt(s.length()-i));\\n            String temp = stringBuilder.toString()+s;\\n            if(isPalindrome(temp)) {\\n                return temp;\\n            }\\n        }\\n        return result;\\n    }\\n    private boolean isPalindrome(String s) {\\n        StringBuilder stringBuilder = new StringBuilder(s);\\n        String s1 = stringBuilder.reverse().toString();\\n        if(s.equalsIgnoreCase(s1)) {\\n            return true;\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "public String shortestPalindrome(String s) {\\n        String result = \"\";\\n        if (isPalindrome(s)) {\\n            return s;\\n        }\\n        StringBuilder stringBuilder = new StringBuilder();\\n        for (int i=1; i<s.length(); i++) {\\n            stringBuilder.append(s.charAt(s.length()-i));\\n            String temp = stringBuilder.toString()+s;\\n            if(isPalindrome(temp)) {\\n                return temp;\\n            }\\n        }\\n        return result;\\n    }\\n    private boolean isPalindrome(String s) {\\n        StringBuilder stringBuilder = new StringBuilder(s);\\n        String s1 = stringBuilder.reverse().toString();\\n        if(s.equalsIgnoreCase(s1)) {\\n            return true;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2265724,
                "title": "java-brute-force-kmp-2-solutions",
                "content": "**Brute-Force approach:**\\n\\n```\\nclass Solution {\\n    public String shortestPalindrome(String s) {\\n        for(int i=s.length()-1; i >= 0; i--){\\n            if(isPalindrome(s, 0, i)){\\n                String toAppend = s.substring(i+1);\\n                String result = new StringBuilder(toAppend).reverse().append(s).toString();\\n                return result;\\n            }\\n        }\\n        String result = new StringBuilder(s).reverse().append(s).toString();\\n        return result;        \\n    }\\n    \\n    boolean isPalindrome(String s, int left, int right){\\n        while(left < right){\\n            if(s.charAt(left) != s.charAt(right))\\n                return false;\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n\\n**KMP - Longest Prefix which is also a suffix**\\n\\nThe idea is to find the longest prefix which is also a suffix for the merged string (s + rev(s))\\n1. Generate reverse of the input String\\n2. Append the reverse of the String to the input string\\n3. Find the lps in the merged String\\n4. Get the substring from the input string, from index that is equal to the lps till the end.\\n5. Append that substring to the input to get the final string\\n\\n**Code:**\\n\\n```\\nclass Solution {\\n    public String shortestPalindrome(String s) {\\n        if(s.isEmpty())\\n            return s;\\n        String rev = new StringBuilder(s).reverse().toString();\\n        String merged = s + rev;        \\n        int lps = getLPS(merged, s.length());\\n        if(lps >= s.length())\\n            return s;\\n        String sub = s.substring(lps);\\n        return new StringBuilder(sub).reverse().append(s).toString();\\n    }\\n    \\n    int getLPS(String str, int length){\\n        int[] lps = new int[str.length()];\\n        int i=1, j=0;\\n        while(i < str.length()){\\n            if(i == length)\\n                j = 0;\\n            if(str.charAt(i) == str.charAt(j)){\\n                lps[i] = j+1;\\n                i++;\\n                j++;\\n            } else {\\n                if(j > 0){\\n                    j = lps[j-1];\\n                } else {\\n                    lps[i]=0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps[str.length()-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String shortestPalindrome(String s) {\\n        for(int i=s.length()-1; i >= 0; i--){\\n            if(isPalindrome(s, 0, i)){\\n                String toAppend = s.substring(i+1);\\n                String result = new StringBuilder(toAppend).reverse().append(s).toString();\\n                return result;\\n            }\\n        }\\n        String result = new StringBuilder(s).reverse().append(s).toString();\\n        return result;        \\n    }\\n    \\n    boolean isPalindrome(String s, int left, int right){\\n        while(left < right){\\n            if(s.charAt(left) != s.charAt(right))\\n                return false;\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String shortestPalindrome(String s) {\\n        if(s.isEmpty())\\n            return s;\\n        String rev = new StringBuilder(s).reverse().toString();\\n        String merged = s + rev;        \\n        int lps = getLPS(merged, s.length());\\n        if(lps >= s.length())\\n            return s;\\n        String sub = s.substring(lps);\\n        return new StringBuilder(sub).reverse().append(s).toString();\\n    }\\n    \\n    int getLPS(String str, int length){\\n        int[] lps = new int[str.length()];\\n        int i=1, j=0;\\n        while(i < str.length()){\\n            if(i == length)\\n                j = 0;\\n            if(str.charAt(i) == str.charAt(j)){\\n                lps[i] = j+1;\\n                i++;\\n                j++;\\n            } else {\\n                if(j > 0){\\n                    j = lps[j-1];\\n                } else {\\n                    lps[i]=0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps[str.length()-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2192229,
                "title": "my-accepted-brute-force-solution",
                "content": "```\\n    public String shortestPalindrome(String s) {\\n        int n = s.length();\\n        if (s == null || n == 0) \\n            return s;\\n        \\n        StringBuilder sb = new StringBuilder(s);\\n        sb.reverse();\\n        for (int i = 0; i <= n; i++) {\\n            if (s.startsWith(sb.substring(i))) \\n                return sb.substring(0, i) + s;\\n        }\\n        return sb + s;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String shortestPalindrome(String s) {\\n        int n = s.length();\\n        if (s == null || n == 0) \\n            return s;\\n        \\n        StringBuilder sb = new StringBuilder(s);\\n        sb.reverse();\\n        for (int i = 0; i <= n; i++) {\\n            if (s.startsWith(sb.substring(i))) \\n                return sb.substring(0, i) + s;\\n        }\\n        return sb + s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2159727,
                "title": "use-longest-palindromic-string-concept-intital-approach-constructive",
                "content": "**Here approach is We can find the LPS of the string and the rest right part we can add to start of the given string**\\n**Case like:- abbd  , the lps is BB but we canot add right part, coz the staring point of LPS  (bb) is not at the left corner ie start =-1**\\n**So , while handling the above case, our LPS would be in consideration only When our start pointer on -1**\\n\\n**As we want our s=-1 , so if , we find LPS taking i>n/2 , we will never have the s=-1 as before reaching s=-1, end would be  e>n**\\n**OUR optimised solution would be , if we start fing lps from mid, so that large section of left and right can get in LPS**\\n*So once we get s=-1, while traversing from mid to start of string from i=n/2 to i , so That would be our maximum LPS*\\n**MAXimum LPS result in least left part .\\nAnswer is reverse(left)+str.**\\n```\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string str) {\\n        int n = str.length();\\n        if (n == 0) {\\n            return \"\";\\n        }\\n        int comlen = 1;\\n        int end = 0;\\n\\t\\t//find LPS from mid\\n        for (int i = n / 2; i >= 0 ; i--) {\\n            int s = i - 1;\\n            int e = i + 1;\\n            while (s >= 0 && str[s] == str[i])\\n                s--;\\n            while (e < n && str[e] == str[i])\\n                e++;\\n            while (s >= 0 && e < n && str[s] == str[e]) {\\n                s--;\\n                e++;\\n            }\\n            if (s == -1) {\\n                string left = str.substr(e);\\n                reverse(left.begin(), left.end());\\n                return left + str;\\n            }\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string str) {\\n        int n = str.length();\\n        if (n == 0) {\\n            return \"\";\\n        }\\n        int comlen = 1;\\n        int end = 0;\\n\\t\\t//find LPS from mid\\n        for (int i = n / 2; i >= 0 ; i--) {\\n            int s = i - 1;\\n            int e = i + 1;\\n            while (s >= 0 && str[s] == str[i])\\n                s--;\\n            while (e < n && str[e] == str[i])\\n                e++;\\n            while (s >= 0 && e < n && str[s] == str[e]) {\\n                s--;\\n                e++;\\n            }\\n            if (s == -1) {\\n                string left = str.substr(e);\\n                reverse(left.begin(), left.end());\\n                return left + str;\\n            }\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2159251,
                "title": "python-stupidly-simple-5-lines-solution",
                "content": "```\\nclass Solution:\\n    def shortestPalindrome(self, s: str) -> str:\\n        if not s: return \"\"\\n        for i in reversed(range(len(s))):\\n            if s[0:i+1] == s[i::-1]:\\n                return s[:i:-1] + s\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestPalindrome(self, s: str) -> str:\\n        if not s: return \"\"\\n        for i in reversed(range(len(s))):\\n            if s[0:i+1] == s[i::-1]:\\n                return s[:i:-1] + s\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128627,
                "title": "java-kmp",
                "content": "```\\n/* You are given a string s. You can convert s to a palindrome by adding characters in front of it.\\n\\nReturn the shortest palindrome you can find by performing this transformation. \\n\\nBasic Idea:\\nMainly utilize the KMP algorithm to shorten the runtime : \\nhttps://www.youtube.com/watch?v=BXCEFAzhxGY&ab_channel=BackToBackSWE\\n\\nKMP allows us to find the longest prefix and suffix in a string\\uFF0C where prefix == suffix.\\nThis basically means that by using the KMP algorithm, we are able to locate the longest substring\\nwhich starts and ends with the same string of characters.\\n\\nThis property gains a huge insight into solving this problem. \\nPalindromes are sequence of characters that reads the same forward or backwards\\nThe idea here is to create an arbitrary solution, which is to concatenate the string s with\\nanother reversed s, creating an arbitrary palindrome.\\n\\nNow by using KMP, we can form a table which contains the lengths of every substring\\nwhich has its prefix == suffix.\\n\\nSince the second half of the arbitrary palindrome is reversed and prefix is the same as suffix, \\nthen we know that prefix/suffix must be a palindromic substring of the original string s.\\nThen, all we need to do is to locate the longest prefix/suffix string in the arbitrary string, which is also the longest palindrome pattern appeared in the original string s, and copy whatever is left to\\nthe other side of s, thus forming a shortest palindrome.\\n*/\\n\\n\\n\\n\\nclass Solution {\\n    public String shortestPalindrome(String s) {\\n        String arbitraryPalindrome = s + \"\\u5F20\\u7F57\\u7FD4\\u8BB8\\u6B27\\u5DF4\" + new StringBuilder(s).reverse().toString();\\n        int ap_len = arbitraryPalindrome.length();\\n        int[] KMPtable = new int[ap_len];\\n        KMPtable[0] = 0;\\n\\n        for (int i = 0, j = 1; j < ap_len; j++) {\\n            while (i > 0 && arbitraryPalindrome.charAt(i) != arbitraryPalindrome.charAt(j)) {\\n                i = KMPtable[i - 1];\\n            }\\n            if (arbitraryPalindrome.charAt(i) == arbitraryPalindrome.charAt(j)) {\\n                i++;\\n                KMPtable[j] = i;\\n            }\\n            \\n            \\n        }\\n        return new StringBuilder(s.substring(KMPtable[ap_len - 1])).reverse().toString() + s;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n/* You are given a string s. You can convert s to a palindrome by adding characters in front of it.\\n\\nReturn the shortest palindrome you can find by performing this transformation. \\n\\nBasic Idea:\\nMainly utilize the KMP algorithm to shorten the runtime : \\nhttps://www.youtube.com/watch?v=BXCEFAzhxGY&ab_channel=BackToBackSWE\\n\\nKMP allows us to find the longest prefix and suffix in a string\\uFF0C where prefix == suffix.\\nThis basically means that by using the KMP algorithm, we are able to locate the longest substring\\nwhich starts and ends with the same string of characters.\\n\\nThis property gains a huge insight into solving this problem. \\nPalindromes are sequence of characters that reads the same forward or backwards\\nThe idea here is to create an arbitrary solution, which is to concatenate the string s with\\nanother reversed s, creating an arbitrary palindrome.\\n\\nNow by using KMP, we can form a table which contains the lengths of every substring\\nwhich has its prefix == suffix.\\n\\nSince the second half of the arbitrary palindrome is reversed and prefix is the same as suffix, \\nthen we know that prefix/suffix must be a palindromic substring of the original string s.\\nThen, all we need to do is to locate the longest prefix/suffix string in the arbitrary string, which is also the longest palindrome pattern appeared in the original string s, and copy whatever is left to\\nthe other side of s, thus forming a shortest palindrome.\\n*/\\n\\n\\n\\n\\nclass Solution {\\n    public String shortestPalindrome(String s) {\\n        String arbitraryPalindrome = s + \"\\u5F20\\u7F57\\u7FD4\\u8BB8\\u6B27\\u5DF4\" + new StringBuilder(s).reverse().toString();\\n        int ap_len = arbitraryPalindrome.length();\\n        int[] KMPtable = new int[ap_len];\\n        KMPtable[0] = 0;\\n\\n        for (int i = 0, j = 1; j < ap_len; j++) {\\n            while (i > 0 && arbitraryPalindrome.charAt(i) != arbitraryPalindrome.charAt(j)) {\\n                i = KMPtable[i - 1];\\n            }\\n            if (arbitraryPalindrome.charAt(i) == arbitraryPalindrome.charAt(j)) {\\n                i++;\\n                KMPtable[j] = i;\\n            }\\n            \\n            \\n        }\\n        return new StringBuilder(s.substring(KMPtable[ap_len - 1])).reverse().toString() + s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128145,
                "title": "java-with-explanation",
                "content": "**Approach**:\\nSlide the original string from index 0 to n-1 of reversed string till all the overlapping chars doesn\\'t match.\\n\\n**Explanation**:\\n```\\nTake s = \"mnop\" s_reverse = \"ponm\"\\n\\n[p o n m]\\n | | | |\\n[m n o p]\\nchars doesn\\'t match -> move one place to right\\n\\n[p o n m]\\n   | | |\\n  [m n o p]\\nchars doesn\\'t match -> move one place to right\\n\\n[p o n m]\\n     | |\\n    [m n o p]\\nchars doesn\\'t match -> move one place to right\\n\\n[p o n m]\\n       |\\n      [m n o p]\\nchars match \\n\\ncombining the two\\n p o n m\\n | | | |\\n | | | m n o p\\n | | | | | | |\\n p o n m n o p\\n\\nans = [unmatched chars from s] + [matching chars] + [unmatched chars from s_reverse] = \"ponmnop\"\\n\\n```\\n\\n.\\n**Solution**:\\n```\\nclass Solution {\\n    public String shortestPalindrome(String s) {\\n        if(s == null || s.length() == 0) return s;\\n        \\n        StringBuilder rs = new StringBuilder(s);\\n        rs.reverse();\\n        \\n        for(int i = 0; i < rs.length(); i++)\\n            if(s.startsWith(rs.substring(i)))\\n                return rs.substring(0, i) + s;\\n        \\n        return rs.append(s).toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nTake s = \"mnop\" s_reverse = \"ponm\"\\n\\n[p o n m]\\n | | | |\\n[m n o p]\\nchars doesn\\'t match -> move one place to right\\n\\n[p o n m]\\n   | | |\\n  [m n o p]\\nchars doesn\\'t match -> move one place to right\\n\\n[p o n m]\\n     | |\\n    [m n o p]\\nchars doesn\\'t match -> move one place to right\\n\\n[p o n m]\\n       |\\n      [m n o p]\\nchars match \\n\\ncombining the two\\n p o n m\\n | | | |\\n | | | m n o p\\n | | | | | | |\\n p o n m n o p\\n\\nans = [unmatched chars from s] + [matching chars] + [unmatched chars from s_reverse] = \"ponmnop\"\\n\\n```\n```\\nclass Solution {\\n    public String shortestPalindrome(String s) {\\n        if(s == null || s.length() == 0) return s;\\n        \\n        StringBuilder rs = new StringBuilder(s);\\n        rs.reverse();\\n        \\n        for(int i = 0; i < rs.length(); i++)\\n            if(s.startsWith(rs.substring(i)))\\n                return rs.substring(0, i) + s;\\n        \\n        return rs.append(s).toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2102770,
                "title": "c-non-kmp-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s) {\\n        int n=s.size();\\n        if(n==0)\\n            return \"\";\\n        int i=n/2;\\n        while(i>=0)\\n        {\\n            int l=i-1;\\n            while(l>=0 && s[l]==s[i])\\n                --l;\\n            int r=i+1;\\n            while(r<n && s[r]==s[i])\\n                ++r;\\n            while(l>=0 && r<n && s[l]==s[r])\\n            {\\n                --l;\\n                ++r;\\n            }\\n            if(l==-1 && r==n)\\n                return s;\\n            if(l>=0)\\n            {\\n                i--;\\n                continue;\\n            }\\n            if(l==-1)\\n            {\\n                string temp=s.substr(r);\\n                reverse(temp.begin(),temp.end());\\n                temp+=s;\\n                return temp;\\n            }\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s) {\\n        int n=s.size();\\n        if(n==0)\\n            return \"\";\\n        int i=n/2;\\n        while(i>=0)\\n        {\\n            int l=i-1;\\n            while(l>=0 && s[l]==s[i])\\n                --l;\\n            int r=i+1;\\n            while(r<n && s[r]==s[i])\\n                ++r;\\n            while(l>=0 && r<n && s[l]==s[r])\\n            {\\n                --l;\\n                ++r;\\n            }\\n            if(l==-1 && r==n)\\n                return s;\\n            if(l>=0)\\n            {\\n                i--;\\n                continue;\\n            }\\n            if(l==-1)\\n            {\\n                string temp=s.substr(r);\\n                reverse(temp.begin(),temp.end());\\n                temp+=s;\\n                return temp;\\n            }\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098697,
                "title": "c-rolling-hash-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isEqual(string& s, string& t, int subLen){\\n        int len = t.length();\\n        for(int i = 0; i < subLen; i++){\\n            if(s[i] != t[len - subLen + i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n        \\n    string shortestPalindrome(string s) {\\n        int i, len = s.length();\\n        const int mod = 1e9 + 7;\\n        const int index = 26;\\n        \\n        string t = s;\\n        reverse(t.begin(), t.end());\\n        \\n        vector<long long> prefixMap(len);\\n        vector<long long> suffixMap(len);\\n        \\n        long long hash = 0;\\n        for(i = 0; i < len; i++){\\n            hash *= index;\\n            hash %= mod;\\n            hash += s[i];\\n            hash %= mod;\\n            prefixMap[i] = hash;\\n        }\\n        \\n        long long mult = 1;\\n        hash = 0;\\n        long long next;\\n        for(i = len - 1; i >= 0; i--){\\n            next = mult * t[i];\\n            next %= mod;\\n            hash += next;\\n            hash %= mod;\\n            mult *= index;\\n            mult %= mod;\\n            suffixMap[len - 1 - i] = hash;\\n        }\\n                \\n        for(i = len; i >= 1; i--){\\n            if(prefixMap[i - 1] == suffixMap[i - 1] && isEqual(s, t, i)){\\n                string rem;\\n                if(i < len){\\n                    rem = s.substr(i, len - i);\\n                }\\n                \\n                reverse(rem.begin(), rem.end());\\n                return rem + s;\\n            }\\n        }\\n        \\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isEqual(string& s, string& t, int subLen){\\n        int len = t.length();\\n        for(int i = 0; i < subLen; i++){\\n            if(s[i] != t[len - subLen + i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n        \\n    string shortestPalindrome(string s) {\\n        int i, len = s.length();\\n        const int mod = 1e9 + 7;\\n        const int index = 26;\\n        \\n        string t = s;\\n        reverse(t.begin(), t.end());\\n        \\n        vector<long long> prefixMap(len);\\n        vector<long long> suffixMap(len);\\n        \\n        long long hash = 0;\\n        for(i = 0; i < len; i++){\\n            hash *= index;\\n            hash %= mod;\\n            hash += s[i];\\n            hash %= mod;\\n            prefixMap[i] = hash;\\n        }\\n        \\n        long long mult = 1;\\n        hash = 0;\\n        long long next;\\n        for(i = len - 1; i >= 0; i--){\\n            next = mult * t[i];\\n            next %= mod;\\n            hash += next;\\n            hash %= mod;\\n            mult *= index;\\n            mult %= mod;\\n            suffixMap[len - 1 - i] = hash;\\n        }\\n                \\n        for(i = len; i >= 1; i--){\\n            if(prefixMap[i - 1] == suffixMap[i - 1] && isEqual(s, t, i)){\\n                string rem;\\n                if(i < len){\\n                    rem = s.substr(i, len - i);\\n                }\\n                \\n                reverse(rem.begin(), rem.end());\\n                return rem + s;\\n            }\\n        }\\n        \\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2076499,
                "title": "simple-python-solution-in-o-n-in-9-lines",
                "content": "1) Create a string which is combination of s and reveresed s joined by unique character.\\n2) Create a lps array for new string.\\n3) The last value of lps is the length of longest palindrome starting from the beginning.\\n4) Finally return the string ahead of palindroming substring joined with original string.\\n\\n```\\nclass Solution:\\n    def shortestPalindrome(self, s: str) -> str:\\n        n = len(s)\\n        s1 = s+\\'!\\'+s[::-1] # new string of length 2n+1\\n        i,st,lps = 1,0,[0]*(2*n+1)\\n        while i<=(2*n):\\n            if s1[i]==s1[st]:st+=1;lps[i]=st;i+=1\\n            else:\\n                if st!=0:st=lps[st-1]\\n                else:lps[i]=0;i+=1\\n        return s[lps[-1]:][::-1]+s  # final string  = substring after palindroming substring added with original string\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def shortestPalindrome(self, s: str) -> str:\\n        n = len(s)\\n        s1 = s+\\'!\\'+s[::-1] # new string of length 2n+1\\n        i,st,lps = 1,0,[0]*(2*n+1)\\n        while i<=(2*n):\\n            if s1[i]==s1[st]:st+=1;lps[i]=st;i+=1\\n            else:\\n                if st!=0:st=lps[st-1]\\n                else:lps[i]=0;i+=1\\n        return s[lps[-1]:][::-1]+s  # final string  = substring after palindroming substring added with original string\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2022927,
                "title": "python-intuitive-expand-from-the-middle-95",
                "content": "\\n\\n```\\nclass Solution:\\n    def shortestPalindrome(self, s: str) -> str:\\n        if s == s[::-1]:\\n            return s\\n        \\n        m_idx = (len(s)-1)//2\\n        \\n        while m_idx>=0:\\n            middle_char = s[m_idx]\\n            l_idx = m_idx-1\\n            r_idx = m_idx+1\\n            \\n            while (r_idx <= len(s)-1 and s[r_idx]==middle_char) or (l_idx>=0 and s[l_idx]==middle_char):\\n                \\n                if (l_idx>=0 and s[l_idx]==middle_char):\\n                    l_idx-=1\\n                if (r_idx <= len(s)-1 and s[r_idx]==middle_char):\\n                    r_idx+=1\\n            \\n            left = s[:l_idx+1]\\n            middle = s[l_idx+1:r_idx] \\n            right = s[r_idx:]\\n            \\n            if not left or left[::-1] == right[:len(left)]:\\n                return right[::-1] + s[l_idx+1:]\\n            \\n            m_idx = l_idx\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestPalindrome(self, s: str) -> str:\\n        if s == s[::-1]:\\n            return s\\n        \\n        m_idx = (len(s)-1)//2\\n        \\n        while m_idx>=0:\\n            middle_char = s[m_idx]\\n            l_idx = m_idx-1\\n            r_idx = m_idx+1\\n            \\n            while (r_idx <= len(s)-1 and s[r_idx]==middle_char) or (l_idx>=0 and s[l_idx]==middle_char):\\n                \\n                if (l_idx>=0 and s[l_idx]==middle_char):\\n                    l_idx-=1\\n                if (r_idx <= len(s)-1 and s[r_idx]==middle_char):\\n                    r_idx+=1\\n            \\n            left = s[:l_idx+1]\\n            middle = s[l_idx+1:r_idx] \\n            right = s[r_idx:]\\n            \\n            if not left or left[::-1] == right[:len(left)]:\\n                return right[::-1] + s[l_idx+1:]\\n            \\n            m_idx = l_idx\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1954083,
                "title": "brute-force-python-sollution",
                "content": "\\n\\tdef shortestPalindrome(self, s: str) -> str:\\n        if not s or len(s) == 1 or s == s[::-1]:\\n            return s\\n        r = s[::-1]\\n        n = len(s)\\n        \\n        for i in range(n - 1, -1, -1):\\n            if s[:i] == r[n - i:]:\\n                return r[:n - i] + s\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n\\tdef shortestPalindrome(self, s: str) -> str:\\n        if not s or len(s) == 1 or s == s[::-1]:\\n            return s\\n        r = s[::-1]\\n        n = len(s)\\n        \\n        for i in range(n - 1, -1, -1):\\n            if s[:i] == r[n - i:]:\\n                return r[:n - i] + s\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1953482,
                "title": "simple-java-solution-without-kmp-easy-understanding",
                "content": "* First check for input string if input string is palindrome \\n* Then find out at which our input string is palindrome. \\n* for example if we have \\'aababaavf\\'\\n* In above input string \\'aababaa\\' is palindrome\\n* Nor from that point take the rest string(fv) in stringbuilder and reverse it(fv).\\n* Now append input string in stringbuilder (fv+aababaavf =fvaababaavf here is your answer \\n\\n```\\nclass Solution {\\n    public String shortestPalindrome(String s) {\\n        \\n        if(isPalindrome(s)){\\n            return s;\\n        }\\n        \\n        int start,end;\\n        \\n        start=0;\\n        end=s.length()-1;\\n        \\n        while(start<end){\\n            if(isPalindrome(s.substring(start,end))){\\n                break;\\n            }else{\\n                end--;\\n            }\\n        }\\n        \\n        StringBuilder sb=new StringBuilder(s.substring(end));\\n        sb.reverse();\\n        sb.append(s);       \\n        \\n        return sb.toString();\\n    }\\n    \\n    public boolean isPalindrome(String s){\\n      \\n        int mid=s.length()/2;\\n        if(s.length()%2==0){\\n            for(int i=mid-1,j=mid;i>=0;i--,j++){\\n                if(s.charAt(i)!=s.charAt(j)){                    \\n                    return false;\\n                }\\n            }\\n        }else{\\n            for(int i=mid-1,j=mid+1;i>=0;i--,j++){\\n                if(s.charAt(i)!=s.charAt(j)){\\n                    return false;\\n                }\\n            }\\n        }\\n       \\n        return true;\\n    }\\n}\\n```\\n\\n**NOTE: To check if string is palindrome or not, check from middle of string (this is trick to overcome TLE)**",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String shortestPalindrome(String s) {\\n        \\n        if(isPalindrome(s)){\\n            return s;\\n        }\\n        \\n        int start,end;\\n        \\n        start=0;\\n        end=s.length()-1;\\n        \\n        while(start<end){\\n            if(isPalindrome(s.substring(start,end))){\\n                break;\\n            }else{\\n                end--;\\n            }\\n        }\\n        \\n        StringBuilder sb=new StringBuilder(s.substring(end));\\n        sb.reverse();\\n        sb.append(s);       \\n        \\n        return sb.toString();\\n    }\\n    \\n    public boolean isPalindrome(String s){\\n      \\n        int mid=s.length()/2;\\n        if(s.length()%2==0){\\n            for(int i=mid-1,j=mid;i>=0;i--,j++){\\n                if(s.charAt(i)!=s.charAt(j)){                    \\n                    return false;\\n                }\\n            }\\n        }else{\\n            for(int i=mid-1,j=mid+1;i>=0;i--,j++){\\n                if(s.charAt(i)!=s.charAt(j)){\\n                    return false;\\n                }\\n            }\\n        }\\n       \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1933504,
                "title": "c",
                "content": "```\\n    public string ShortestPalindrome(string s) {\\n        \\n        int end = s.Length - 1;\\n\\n        while (!IsPalindrome(s, 0, end))\\n        {\\n            end--;\\n        }\\n\\n        string middle = s.Substring(0, end+1);\\n        string right = s.Substring(end + 1);\\n        string left = string.Join(\"\", right.ToCharArray().Reverse());\\n\\n        return left + middle + right;\\n        \\n    }\\n    \\n    private bool IsPalindrome(string s, int start, int end)\\n    {\\n        while (start < end)\\n        {\\n            if (s[start++] != s[end--])\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public string ShortestPalindrome(string s) {\\n        \\n        int end = s.Length - 1;\\n\\n        while (!IsPalindrome(s, 0, end))\\n        {\\n            end--;\\n        }\\n\\n        string middle = s.Substring(0, end+1);\\n        string right = s.Substring(end + 1);\\n        string left = string.Join(\"\", right.ToCharArray().Reverse());\\n\\n        return left + middle + right;\\n        \\n    }\\n    \\n    private bool IsPalindrome(string s, int start, int end)\\n    {\\n        while (start < end)\\n        {\\n            if (s[start++] != s[end--])\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1761057,
                "title": "top-down-approach-119-120-test-cases-passed-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s) {\\n        if(s.length()==0 || s.length()==1){\\n            return s;\\n        }\\n        int n=s.length();\\n        vector<vector<bool>> dp(n, vector<bool> (n, false));\\n        for(int i=0; i<n; i++){\\n            dp[i][i]=true;\\n        }\\n        for(int i=0; i<n-1; i++){\\n            if(s[i]==s[i+1])\\n            dp[i][i+1]=true;\\n        }\\n        for(int i=s.length()-3; i>=0; i--){\\n            for(int j=i+2; j<n; j++){\\n                if(s[i]==s[j] && dp[i+1][j-1]){\\n                    dp[i][j]=true;\\n                }\\n            }\\n        }\\n        if(dp[0][n-1]){\\n            return s;\\n        }\\n        string ans;\\n        for(int j=n-2; j>=0; j--){\\n            if(dp[0][j]){\\n                string str=s.substr(j+1, n-1-j);\\n                reverse(str.begin(), str.end());\\n                ans=ans+str+s;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestPalindrome(string s) {\\n        if(s.length()==0 || s.length()==1){\\n            return s;\\n        }\\n        int n=s.length();\\n        vector<vector<bool>> dp(n, vector<bool> (n, false));\\n        for(int i=0; i<n; i++){\\n            dp[i][i]=true;\\n        }\\n        for(int i=0; i<n-1; i++){\\n            if(s[i]==s[i+1])\\n            dp[i][i+1]=true;\\n        }\\n        for(int i=s.length()-3; i>=0; i--){\\n            for(int j=i+2; j<n; j++){\\n                if(s[i]==s[j] && dp[i+1][j-1]){\\n                    dp[i][j]=true;\\n                }\\n            }\\n        }\\n        if(dp[0][n-1]){\\n            return s;\\n        }\\n        string ans;\\n        for(int j=n-2; j>=0; j--){\\n            if(dp[0][j]){\\n                string str=s.substr(j+1, n-1-j);\\n                reverse(str.begin(), str.end());\\n                ans=ans+str+s;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750638,
                "title": "c-kmp-lps-array-o-n",
                "content": "```\\nclass Solution {\\npublic:\\nstring shortestPalindrome(string s)\\n{\\n    int n = s.size();\\n    string rev(s);\\n    string str(s);\\n    reverse(rev.begin(),rev.end());\\n    s=s+\"#\"+rev;\\n    int lps[s.size()];\\n    lps[0] = 0;\\n    int i = 1, j = 0;\\n    while (i < s.size())\\n    {\\n        if (s[j] == s[i])\\n        {\\n            lps[i] = j + 1;\\n            i++;\\n            j++;\\n        }\\n        else\\n        {\\n            if (j != 0)\\n            {\\n                j = lps[j - 1];\\n            }\\n            else\\n            {\\n                lps[i] = 0;\\n                i++;\\n            }\\n        }\\n    }\\n\\n    int k=lps[s.size()-1];\\n    return rev.substr(0,n-k)+str;\\n    \\n}\\n    \\n    \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nstring shortestPalindrome(string s)\\n{\\n    int n = s.size();\\n    string rev(s);\\n    string str(s);\\n    reverse(rev.begin(),rev.end());\\n    s=s+\"#\"+rev;\\n    int lps[s.size()];\\n    lps[0] = 0;\\n    int i = 1, j = 0;\\n    while (i < s.size())\\n    {\\n        if (s[j] == s[i])\\n        {\\n            lps[i] = j + 1;\\n            i++;\\n            j++;\\n        }\\n        else\\n        {\\n            if (j != 0)\\n            {\\n                j = lps[j - 1];\\n            }\\n            else\\n            {\\n                lps[i] = 0;\\n                i++;\\n            }\\n        }\\n    }\\n\\n    int k=lps[s.size()-1];\\n    return rev.substr(0,n-k)+str;\\n    \\n}\\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1711491,
                "content": [
                    {
                        "username": "b06902111",
                        "content": "Why getting TLE with this...? I tested, my code works with s = \"\" empty string. But what is this? Can anyone help?\n![Imgur](https://imgur.com/pcHddiZ.jpg)"
                    },
                    {
                        "username": "at218808",
                        "content": "check if you are passing string by reference or not, second O(n^2) will fail"
                    },
                    {
                        "username": "q23175401",
                        "content": "Has anyone fixed this issue?"
                    },
                    {
                        "username": "user6007Dd",
                        "content": "I have the same problem. I didnt have it at first but now I get it for every submit. "
                    },
                    {
                        "username": "Conrad_123",
                        "content": "I\\'m having the same issue. When I try to use this as a test case, it prompts me to make my own. Not sure how to go about fixing this. "
                    },
                    {
                        "username": "Kaynex",
                        "content": "Time limit exceeded means you\\'ve exceeed the time limit.\\nNeed to speed up your algorithm."
                    },
                    {
                        "username": "dkvg_77",
                        "content": "Please someone give solution for this"
                    },
                    {
                        "username": "monderpet",
                        "content": "Same issue."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please donate stars\\n\\n![image](https://assets.leetcode.com/users/images/f8fbdf0e-77f7-4f68-a4e0-29236d2931ef_1636547465.0409968.png)\\n\\n![image](https://assets.leetcode.com/users/images/691dee61-ffd3-48b8-a8d3-5adf743a0d97_1636547470.6172163.png)\\n"
                    },
                    {
                        "username": "Rithsek",
                        "content": "why s = \"aabba\"\\nExpected = \"abbaabba\" and not \"abbabba\"?"
                    },
                    {
                        "username": "Alpha_690163",
                        "content": "[@unarov](/unarov) \\nInput: s = \"abcd\"\\nOutput: \"dcbabcd\"\\nhere, a is not appended."
                    },
                    {
                        "username": "Prabhaaa111",
                        "content": "you have to append characters only in front of string without removing characters from original string."
                    },
                    {
                        "username": "unarov",
                        "content": "To make \"abbabba\" from \"aabba\" you should remove one \"a\". But it is not allowed. You can only add chars in front of given string"
                    },
                    {
                        "username": "aastha985",
                        "content": "**Idea:**\\nThe **brute force** solution would be to check all possible strings starting from index 0 and check if they form a palindrome. This would be O(n^2) and gives TLE.\\n\\n**Optimized Approach**(Using KMP Algorithm)\\n1. How KMP Algorithm works: KMP is a pattern matching algorithm, where we are given a pattern and we need to check if the prefix of the pattern exists in a string.\\n2. How are we using KMP here: The trick here is to concatenate the string with its reverse with a # character in between. Now we apply KMP to this string to get the length of string starting from 0 which is a palindrome.\\n3. We have 2 pointers one to match the pattern which starts from index = 0 and other which starts from i = 1 and an array table initialized to the length of the string in point 2.\\n4. If character at index matches the character at i, we set table[i] = table[i-1]+1 and increment the index.\\n5. Else we set index to table[i-1] and continue setting it to table[index-1] till index>0 and the character at index is not equal to character at i.\\n6. If the character at index is equal to character at i, increment the index.\\n7. Set table[i] to index.\\n8.  In the end, the value at table[table.length-1] will be the length of the palindromic substring starting from 0.\\n\\n[Code can be found here](https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation)\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:**  O(n)"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "Can we solve this problem using hashing"
                    },
                    {
                        "username": "Anonymous2389",
                        "content": "It is mentioned that the approach is accepted but i am geting TLE even when i copied that code to test it"
                    },
                    {
                        "username": "_Dinu",
                        "content": "I am getting a wrong answer with \"abb\" case.\\n\\nMy code has this output \"abba\"\\nExpected is \"bbabb\"\\n\\n\"abba\" is shorter than \"bbabb\"\\n"
                    },
                    {
                        "username": "literalEval",
                        "content": "\\'abba\\' nahi maan rahe"
                    },
                    {
                        "username": "SxreaM",
                        "content": "you have to add characters in front of string not at the end"
                    },
                    {
                        "username": "Weskarini",
                        "content": "Bruh finally got a solution but they have to add a 42000 char testcase for me to get Time Limit\\'d"
                    },
                    {
                        "username": "payal94",
                        "content": "Hello LeetCode,\\n\\npreviously everything was working fine, suddenly I am not able to executed code on leetcode. Status is coming pending. So, I tried to submit already accepted answer. Even, status for that too is coming PENDING. Can anyone help me with this ?"
                    },
                    {
                        "username": "davidtan1890",
                        "content": "I stumbled upon [this implementation here][1]. \\n\\nIt is interesting and accepted by leetcode as of 2015-06-05. However, it is wrong. For test case like \"aabba\", it outputs \"aabba\", however, the correct output should be \"abbaabba\". More test cases needed so that the string s+reverse(s) will have p with length of p >= length of s (here p is the prefix of s + reverse(s), and also a suffix) \\n\\n\\n  [1]: https://leetcode.com/discuss/36987/python-solution-kmp"
                    },
                    {
                        "username": "nishant_suthar",
                        "content": "why this is giving TLE\n\n` class Solution {\n    public String shortestPalindrome(String s) {\n        String temp=s;\n        StringBuilder sb=new StringBuilder(s);\n\n        if(temp.equals(sb.reverse().toString())) return temp;\n\n        int i=0;\n        int j=s.length()-1;\n\n        while(j>0){\n            Character c=s.charAt(j);\n\n            temp=temp.substring(0,i)+c+temp.substring(i);\n\n            sb = new StringBuilder(temp); \n            if(temp.equals(sb.reverse().toString())){\n\n                return temp;\n            }\n            i++;\n            j--;\n\n        }\n        return \"\";\n    }\n}`\n"
                    }
                ]
            },
            {
                "id": 1575952,
                "content": [
                    {
                        "username": "b06902111",
                        "content": "Why getting TLE with this...? I tested, my code works with s = \"\" empty string. But what is this? Can anyone help?\n![Imgur](https://imgur.com/pcHddiZ.jpg)"
                    },
                    {
                        "username": "at218808",
                        "content": "check if you are passing string by reference or not, second O(n^2) will fail"
                    },
                    {
                        "username": "q23175401",
                        "content": "Has anyone fixed this issue?"
                    },
                    {
                        "username": "user6007Dd",
                        "content": "I have the same problem. I didnt have it at first but now I get it for every submit. "
                    },
                    {
                        "username": "Conrad_123",
                        "content": "I\\'m having the same issue. When I try to use this as a test case, it prompts me to make my own. Not sure how to go about fixing this. "
                    },
                    {
                        "username": "Kaynex",
                        "content": "Time limit exceeded means you\\'ve exceeed the time limit.\\nNeed to speed up your algorithm."
                    },
                    {
                        "username": "dkvg_77",
                        "content": "Please someone give solution for this"
                    },
                    {
                        "username": "monderpet",
                        "content": "Same issue."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please donate stars\\n\\n![image](https://assets.leetcode.com/users/images/f8fbdf0e-77f7-4f68-a4e0-29236d2931ef_1636547465.0409968.png)\\n\\n![image](https://assets.leetcode.com/users/images/691dee61-ffd3-48b8-a8d3-5adf743a0d97_1636547470.6172163.png)\\n"
                    },
                    {
                        "username": "Rithsek",
                        "content": "why s = \"aabba\"\\nExpected = \"abbaabba\" and not \"abbabba\"?"
                    },
                    {
                        "username": "Alpha_690163",
                        "content": "[@unarov](/unarov) \\nInput: s = \"abcd\"\\nOutput: \"dcbabcd\"\\nhere, a is not appended."
                    },
                    {
                        "username": "Prabhaaa111",
                        "content": "you have to append characters only in front of string without removing characters from original string."
                    },
                    {
                        "username": "unarov",
                        "content": "To make \"abbabba\" from \"aabba\" you should remove one \"a\". But it is not allowed. You can only add chars in front of given string"
                    },
                    {
                        "username": "aastha985",
                        "content": "**Idea:**\\nThe **brute force** solution would be to check all possible strings starting from index 0 and check if they form a palindrome. This would be O(n^2) and gives TLE.\\n\\n**Optimized Approach**(Using KMP Algorithm)\\n1. How KMP Algorithm works: KMP is a pattern matching algorithm, where we are given a pattern and we need to check if the prefix of the pattern exists in a string.\\n2. How are we using KMP here: The trick here is to concatenate the string with its reverse with a # character in between. Now we apply KMP to this string to get the length of string starting from 0 which is a palindrome.\\n3. We have 2 pointers one to match the pattern which starts from index = 0 and other which starts from i = 1 and an array table initialized to the length of the string in point 2.\\n4. If character at index matches the character at i, we set table[i] = table[i-1]+1 and increment the index.\\n5. Else we set index to table[i-1] and continue setting it to table[index-1] till index>0 and the character at index is not equal to character at i.\\n6. If the character at index is equal to character at i, increment the index.\\n7. Set table[i] to index.\\n8.  In the end, the value at table[table.length-1] will be the length of the palindromic substring starting from 0.\\n\\n[Code can be found here](https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation)\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:**  O(n)"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "Can we solve this problem using hashing"
                    },
                    {
                        "username": "Anonymous2389",
                        "content": "It is mentioned that the approach is accepted but i am geting TLE even when i copied that code to test it"
                    },
                    {
                        "username": "_Dinu",
                        "content": "I am getting a wrong answer with \"abb\" case.\\n\\nMy code has this output \"abba\"\\nExpected is \"bbabb\"\\n\\n\"abba\" is shorter than \"bbabb\"\\n"
                    },
                    {
                        "username": "literalEval",
                        "content": "\\'abba\\' nahi maan rahe"
                    },
                    {
                        "username": "SxreaM",
                        "content": "you have to add characters in front of string not at the end"
                    },
                    {
                        "username": "Weskarini",
                        "content": "Bruh finally got a solution but they have to add a 42000 char testcase for me to get Time Limit\\'d"
                    },
                    {
                        "username": "payal94",
                        "content": "Hello LeetCode,\\n\\npreviously everything was working fine, suddenly I am not able to executed code on leetcode. Status is coming pending. So, I tried to submit already accepted answer. Even, status for that too is coming PENDING. Can anyone help me with this ?"
                    },
                    {
                        "username": "davidtan1890",
                        "content": "I stumbled upon [this implementation here][1]. \\n\\nIt is interesting and accepted by leetcode as of 2015-06-05. However, it is wrong. For test case like \"aabba\", it outputs \"aabba\", however, the correct output should be \"abbaabba\". More test cases needed so that the string s+reverse(s) will have p with length of p >= length of s (here p is the prefix of s + reverse(s), and also a suffix) \\n\\n\\n  [1]: https://leetcode.com/discuss/36987/python-solution-kmp"
                    },
                    {
                        "username": "nishant_suthar",
                        "content": "why this is giving TLE\n\n` class Solution {\n    public String shortestPalindrome(String s) {\n        String temp=s;\n        StringBuilder sb=new StringBuilder(s);\n\n        if(temp.equals(sb.reverse().toString())) return temp;\n\n        int i=0;\n        int j=s.length()-1;\n\n        while(j>0){\n            Character c=s.charAt(j);\n\n            temp=temp.substring(0,i)+c+temp.substring(i);\n\n            sb = new StringBuilder(temp); \n            if(temp.equals(sb.reverse().toString())){\n\n                return temp;\n            }\n            i++;\n            j--;\n\n        }\n        return \"\";\n    }\n}`\n"
                    }
                ]
            },
            {
                "id": 1679522,
                "content": [
                    {
                        "username": "b06902111",
                        "content": "Why getting TLE with this...? I tested, my code works with s = \"\" empty string. But what is this? Can anyone help?\n![Imgur](https://imgur.com/pcHddiZ.jpg)"
                    },
                    {
                        "username": "at218808",
                        "content": "check if you are passing string by reference or not, second O(n^2) will fail"
                    },
                    {
                        "username": "q23175401",
                        "content": "Has anyone fixed this issue?"
                    },
                    {
                        "username": "user6007Dd",
                        "content": "I have the same problem. I didnt have it at first but now I get it for every submit. "
                    },
                    {
                        "username": "Conrad_123",
                        "content": "I\\'m having the same issue. When I try to use this as a test case, it prompts me to make my own. Not sure how to go about fixing this. "
                    },
                    {
                        "username": "Kaynex",
                        "content": "Time limit exceeded means you\\'ve exceeed the time limit.\\nNeed to speed up your algorithm."
                    },
                    {
                        "username": "dkvg_77",
                        "content": "Please someone give solution for this"
                    },
                    {
                        "username": "monderpet",
                        "content": "Same issue."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please donate stars\\n\\n![image](https://assets.leetcode.com/users/images/f8fbdf0e-77f7-4f68-a4e0-29236d2931ef_1636547465.0409968.png)\\n\\n![image](https://assets.leetcode.com/users/images/691dee61-ffd3-48b8-a8d3-5adf743a0d97_1636547470.6172163.png)\\n"
                    },
                    {
                        "username": "Rithsek",
                        "content": "why s = \"aabba\"\\nExpected = \"abbaabba\" and not \"abbabba\"?"
                    },
                    {
                        "username": "Alpha_690163",
                        "content": "[@unarov](/unarov) \\nInput: s = \"abcd\"\\nOutput: \"dcbabcd\"\\nhere, a is not appended."
                    },
                    {
                        "username": "Prabhaaa111",
                        "content": "you have to append characters only in front of string without removing characters from original string."
                    },
                    {
                        "username": "unarov",
                        "content": "To make \"abbabba\" from \"aabba\" you should remove one \"a\". But it is not allowed. You can only add chars in front of given string"
                    },
                    {
                        "username": "aastha985",
                        "content": "**Idea:**\\nThe **brute force** solution would be to check all possible strings starting from index 0 and check if they form a palindrome. This would be O(n^2) and gives TLE.\\n\\n**Optimized Approach**(Using KMP Algorithm)\\n1. How KMP Algorithm works: KMP is a pattern matching algorithm, where we are given a pattern and we need to check if the prefix of the pattern exists in a string.\\n2. How are we using KMP here: The trick here is to concatenate the string with its reverse with a # character in between. Now we apply KMP to this string to get the length of string starting from 0 which is a palindrome.\\n3. We have 2 pointers one to match the pattern which starts from index = 0 and other which starts from i = 1 and an array table initialized to the length of the string in point 2.\\n4. If character at index matches the character at i, we set table[i] = table[i-1]+1 and increment the index.\\n5. Else we set index to table[i-1] and continue setting it to table[index-1] till index>0 and the character at index is not equal to character at i.\\n6. If the character at index is equal to character at i, increment the index.\\n7. Set table[i] to index.\\n8.  In the end, the value at table[table.length-1] will be the length of the palindromic substring starting from 0.\\n\\n[Code can be found here](https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation)\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:**  O(n)"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "Can we solve this problem using hashing"
                    },
                    {
                        "username": "Anonymous2389",
                        "content": "It is mentioned that the approach is accepted but i am geting TLE even when i copied that code to test it"
                    },
                    {
                        "username": "_Dinu",
                        "content": "I am getting a wrong answer with \"abb\" case.\\n\\nMy code has this output \"abba\"\\nExpected is \"bbabb\"\\n\\n\"abba\" is shorter than \"bbabb\"\\n"
                    },
                    {
                        "username": "literalEval",
                        "content": "\\'abba\\' nahi maan rahe"
                    },
                    {
                        "username": "SxreaM",
                        "content": "you have to add characters in front of string not at the end"
                    },
                    {
                        "username": "Weskarini",
                        "content": "Bruh finally got a solution but they have to add a 42000 char testcase for me to get Time Limit\\'d"
                    },
                    {
                        "username": "payal94",
                        "content": "Hello LeetCode,\\n\\npreviously everything was working fine, suddenly I am not able to executed code on leetcode. Status is coming pending. So, I tried to submit already accepted answer. Even, status for that too is coming PENDING. Can anyone help me with this ?"
                    },
                    {
                        "username": "davidtan1890",
                        "content": "I stumbled upon [this implementation here][1]. \\n\\nIt is interesting and accepted by leetcode as of 2015-06-05. However, it is wrong. For test case like \"aabba\", it outputs \"aabba\", however, the correct output should be \"abbaabba\". More test cases needed so that the string s+reverse(s) will have p with length of p >= length of s (here p is the prefix of s + reverse(s), and also a suffix) \\n\\n\\n  [1]: https://leetcode.com/discuss/36987/python-solution-kmp"
                    },
                    {
                        "username": "nishant_suthar",
                        "content": "why this is giving TLE\n\n` class Solution {\n    public String shortestPalindrome(String s) {\n        String temp=s;\n        StringBuilder sb=new StringBuilder(s);\n\n        if(temp.equals(sb.reverse().toString())) return temp;\n\n        int i=0;\n        int j=s.length()-1;\n\n        while(j>0){\n            Character c=s.charAt(j);\n\n            temp=temp.substring(0,i)+c+temp.substring(i);\n\n            sb = new StringBuilder(temp); \n            if(temp.equals(sb.reverse().toString())){\n\n                return temp;\n            }\n            i++;\n            j--;\n\n        }\n        return \"\";\n    }\n}`\n"
                    }
                ]
            },
            {
                "id": 1575249,
                "content": [
                    {
                        "username": "b06902111",
                        "content": "Why getting TLE with this...? I tested, my code works with s = \"\" empty string. But what is this? Can anyone help?\n![Imgur](https://imgur.com/pcHddiZ.jpg)"
                    },
                    {
                        "username": "at218808",
                        "content": "check if you are passing string by reference or not, second O(n^2) will fail"
                    },
                    {
                        "username": "q23175401",
                        "content": "Has anyone fixed this issue?"
                    },
                    {
                        "username": "user6007Dd",
                        "content": "I have the same problem. I didnt have it at first but now I get it for every submit. "
                    },
                    {
                        "username": "Conrad_123",
                        "content": "I\\'m having the same issue. When I try to use this as a test case, it prompts me to make my own. Not sure how to go about fixing this. "
                    },
                    {
                        "username": "Kaynex",
                        "content": "Time limit exceeded means you\\'ve exceeed the time limit.\\nNeed to speed up your algorithm."
                    },
                    {
                        "username": "dkvg_77",
                        "content": "Please someone give solution for this"
                    },
                    {
                        "username": "monderpet",
                        "content": "Same issue."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please donate stars\\n\\n![image](https://assets.leetcode.com/users/images/f8fbdf0e-77f7-4f68-a4e0-29236d2931ef_1636547465.0409968.png)\\n\\n![image](https://assets.leetcode.com/users/images/691dee61-ffd3-48b8-a8d3-5adf743a0d97_1636547470.6172163.png)\\n"
                    },
                    {
                        "username": "Rithsek",
                        "content": "why s = \"aabba\"\\nExpected = \"abbaabba\" and not \"abbabba\"?"
                    },
                    {
                        "username": "Alpha_690163",
                        "content": "[@unarov](/unarov) \\nInput: s = \"abcd\"\\nOutput: \"dcbabcd\"\\nhere, a is not appended."
                    },
                    {
                        "username": "Prabhaaa111",
                        "content": "you have to append characters only in front of string without removing characters from original string."
                    },
                    {
                        "username": "unarov",
                        "content": "To make \"abbabba\" from \"aabba\" you should remove one \"a\". But it is not allowed. You can only add chars in front of given string"
                    },
                    {
                        "username": "aastha985",
                        "content": "**Idea:**\\nThe **brute force** solution would be to check all possible strings starting from index 0 and check if they form a palindrome. This would be O(n^2) and gives TLE.\\n\\n**Optimized Approach**(Using KMP Algorithm)\\n1. How KMP Algorithm works: KMP is a pattern matching algorithm, where we are given a pattern and we need to check if the prefix of the pattern exists in a string.\\n2. How are we using KMP here: The trick here is to concatenate the string with its reverse with a # character in between. Now we apply KMP to this string to get the length of string starting from 0 which is a palindrome.\\n3. We have 2 pointers one to match the pattern which starts from index = 0 and other which starts from i = 1 and an array table initialized to the length of the string in point 2.\\n4. If character at index matches the character at i, we set table[i] = table[i-1]+1 and increment the index.\\n5. Else we set index to table[i-1] and continue setting it to table[index-1] till index>0 and the character at index is not equal to character at i.\\n6. If the character at index is equal to character at i, increment the index.\\n7. Set table[i] to index.\\n8.  In the end, the value at table[table.length-1] will be the length of the palindromic substring starting from 0.\\n\\n[Code can be found here](https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation)\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:**  O(n)"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "Can we solve this problem using hashing"
                    },
                    {
                        "username": "Anonymous2389",
                        "content": "It is mentioned that the approach is accepted but i am geting TLE even when i copied that code to test it"
                    },
                    {
                        "username": "_Dinu",
                        "content": "I am getting a wrong answer with \"abb\" case.\\n\\nMy code has this output \"abba\"\\nExpected is \"bbabb\"\\n\\n\"abba\" is shorter than \"bbabb\"\\n"
                    },
                    {
                        "username": "literalEval",
                        "content": "\\'abba\\' nahi maan rahe"
                    },
                    {
                        "username": "SxreaM",
                        "content": "you have to add characters in front of string not at the end"
                    },
                    {
                        "username": "Weskarini",
                        "content": "Bruh finally got a solution but they have to add a 42000 char testcase for me to get Time Limit\\'d"
                    },
                    {
                        "username": "payal94",
                        "content": "Hello LeetCode,\\n\\npreviously everything was working fine, suddenly I am not able to executed code on leetcode. Status is coming pending. So, I tried to submit already accepted answer. Even, status for that too is coming PENDING. Can anyone help me with this ?"
                    },
                    {
                        "username": "davidtan1890",
                        "content": "I stumbled upon [this implementation here][1]. \\n\\nIt is interesting and accepted by leetcode as of 2015-06-05. However, it is wrong. For test case like \"aabba\", it outputs \"aabba\", however, the correct output should be \"abbaabba\". More test cases needed so that the string s+reverse(s) will have p with length of p >= length of s (here p is the prefix of s + reverse(s), and also a suffix) \\n\\n\\n  [1]: https://leetcode.com/discuss/36987/python-solution-kmp"
                    },
                    {
                        "username": "nishant_suthar",
                        "content": "why this is giving TLE\n\n` class Solution {\n    public String shortestPalindrome(String s) {\n        String temp=s;\n        StringBuilder sb=new StringBuilder(s);\n\n        if(temp.equals(sb.reverse().toString())) return temp;\n\n        int i=0;\n        int j=s.length()-1;\n\n        while(j>0){\n            Character c=s.charAt(j);\n\n            temp=temp.substring(0,i)+c+temp.substring(i);\n\n            sb = new StringBuilder(temp); \n            if(temp.equals(sb.reverse().toString())){\n\n                return temp;\n            }\n            i++;\n            j--;\n\n        }\n        return \"\";\n    }\n}`\n"
                    }
                ]
            },
            {
                "id": 1573865,
                "content": [
                    {
                        "username": "b06902111",
                        "content": "Why getting TLE with this...? I tested, my code works with s = \"\" empty string. But what is this? Can anyone help?\n![Imgur](https://imgur.com/pcHddiZ.jpg)"
                    },
                    {
                        "username": "at218808",
                        "content": "check if you are passing string by reference or not, second O(n^2) will fail"
                    },
                    {
                        "username": "q23175401",
                        "content": "Has anyone fixed this issue?"
                    },
                    {
                        "username": "user6007Dd",
                        "content": "I have the same problem. I didnt have it at first but now I get it for every submit. "
                    },
                    {
                        "username": "Conrad_123",
                        "content": "I\\'m having the same issue. When I try to use this as a test case, it prompts me to make my own. Not sure how to go about fixing this. "
                    },
                    {
                        "username": "Kaynex",
                        "content": "Time limit exceeded means you\\'ve exceeed the time limit.\\nNeed to speed up your algorithm."
                    },
                    {
                        "username": "dkvg_77",
                        "content": "Please someone give solution for this"
                    },
                    {
                        "username": "monderpet",
                        "content": "Same issue."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please donate stars\\n\\n![image](https://assets.leetcode.com/users/images/f8fbdf0e-77f7-4f68-a4e0-29236d2931ef_1636547465.0409968.png)\\n\\n![image](https://assets.leetcode.com/users/images/691dee61-ffd3-48b8-a8d3-5adf743a0d97_1636547470.6172163.png)\\n"
                    },
                    {
                        "username": "Rithsek",
                        "content": "why s = \"aabba\"\\nExpected = \"abbaabba\" and not \"abbabba\"?"
                    },
                    {
                        "username": "Alpha_690163",
                        "content": "[@unarov](/unarov) \\nInput: s = \"abcd\"\\nOutput: \"dcbabcd\"\\nhere, a is not appended."
                    },
                    {
                        "username": "Prabhaaa111",
                        "content": "you have to append characters only in front of string without removing characters from original string."
                    },
                    {
                        "username": "unarov",
                        "content": "To make \"abbabba\" from \"aabba\" you should remove one \"a\". But it is not allowed. You can only add chars in front of given string"
                    },
                    {
                        "username": "aastha985",
                        "content": "**Idea:**\\nThe **brute force** solution would be to check all possible strings starting from index 0 and check if they form a palindrome. This would be O(n^2) and gives TLE.\\n\\n**Optimized Approach**(Using KMP Algorithm)\\n1. How KMP Algorithm works: KMP is a pattern matching algorithm, where we are given a pattern and we need to check if the prefix of the pattern exists in a string.\\n2. How are we using KMP here: The trick here is to concatenate the string with its reverse with a # character in between. Now we apply KMP to this string to get the length of string starting from 0 which is a palindrome.\\n3. We have 2 pointers one to match the pattern which starts from index = 0 and other which starts from i = 1 and an array table initialized to the length of the string in point 2.\\n4. If character at index matches the character at i, we set table[i] = table[i-1]+1 and increment the index.\\n5. Else we set index to table[i-1] and continue setting it to table[index-1] till index>0 and the character at index is not equal to character at i.\\n6. If the character at index is equal to character at i, increment the index.\\n7. Set table[i] to index.\\n8.  In the end, the value at table[table.length-1] will be the length of the palindromic substring starting from 0.\\n\\n[Code can be found here](https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation)\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:**  O(n)"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "Can we solve this problem using hashing"
                    },
                    {
                        "username": "Anonymous2389",
                        "content": "It is mentioned that the approach is accepted but i am geting TLE even when i copied that code to test it"
                    },
                    {
                        "username": "_Dinu",
                        "content": "I am getting a wrong answer with \"abb\" case.\\n\\nMy code has this output \"abba\"\\nExpected is \"bbabb\"\\n\\n\"abba\" is shorter than \"bbabb\"\\n"
                    },
                    {
                        "username": "literalEval",
                        "content": "\\'abba\\' nahi maan rahe"
                    },
                    {
                        "username": "SxreaM",
                        "content": "you have to add characters in front of string not at the end"
                    },
                    {
                        "username": "Weskarini",
                        "content": "Bruh finally got a solution but they have to add a 42000 char testcase for me to get Time Limit\\'d"
                    },
                    {
                        "username": "payal94",
                        "content": "Hello LeetCode,\\n\\npreviously everything was working fine, suddenly I am not able to executed code on leetcode. Status is coming pending. So, I tried to submit already accepted answer. Even, status for that too is coming PENDING. Can anyone help me with this ?"
                    },
                    {
                        "username": "davidtan1890",
                        "content": "I stumbled upon [this implementation here][1]. \\n\\nIt is interesting and accepted by leetcode as of 2015-06-05. However, it is wrong. For test case like \"aabba\", it outputs \"aabba\", however, the correct output should be \"abbaabba\". More test cases needed so that the string s+reverse(s) will have p with length of p >= length of s (here p is the prefix of s + reverse(s), and also a suffix) \\n\\n\\n  [1]: https://leetcode.com/discuss/36987/python-solution-kmp"
                    },
                    {
                        "username": "nishant_suthar",
                        "content": "why this is giving TLE\n\n` class Solution {\n    public String shortestPalindrome(String s) {\n        String temp=s;\n        StringBuilder sb=new StringBuilder(s);\n\n        if(temp.equals(sb.reverse().toString())) return temp;\n\n        int i=0;\n        int j=s.length()-1;\n\n        while(j>0){\n            Character c=s.charAt(j);\n\n            temp=temp.substring(0,i)+c+temp.substring(i);\n\n            sb = new StringBuilder(temp); \n            if(temp.equals(sb.reverse().toString())){\n\n                return temp;\n            }\n            i++;\n            j--;\n\n        }\n        return \"\";\n    }\n}`\n"
                    }
                ]
            },
            {
                "id": 1931979,
                "content": [
                    {
                        "username": "b06902111",
                        "content": "Why getting TLE with this...? I tested, my code works with s = \"\" empty string. But what is this? Can anyone help?\n![Imgur](https://imgur.com/pcHddiZ.jpg)"
                    },
                    {
                        "username": "at218808",
                        "content": "check if you are passing string by reference or not, second O(n^2) will fail"
                    },
                    {
                        "username": "q23175401",
                        "content": "Has anyone fixed this issue?"
                    },
                    {
                        "username": "user6007Dd",
                        "content": "I have the same problem. I didnt have it at first but now I get it for every submit. "
                    },
                    {
                        "username": "Conrad_123",
                        "content": "I\\'m having the same issue. When I try to use this as a test case, it prompts me to make my own. Not sure how to go about fixing this. "
                    },
                    {
                        "username": "Kaynex",
                        "content": "Time limit exceeded means you\\'ve exceeed the time limit.\\nNeed to speed up your algorithm."
                    },
                    {
                        "username": "dkvg_77",
                        "content": "Please someone give solution for this"
                    },
                    {
                        "username": "monderpet",
                        "content": "Same issue."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please donate stars\\n\\n![image](https://assets.leetcode.com/users/images/f8fbdf0e-77f7-4f68-a4e0-29236d2931ef_1636547465.0409968.png)\\n\\n![image](https://assets.leetcode.com/users/images/691dee61-ffd3-48b8-a8d3-5adf743a0d97_1636547470.6172163.png)\\n"
                    },
                    {
                        "username": "Rithsek",
                        "content": "why s = \"aabba\"\\nExpected = \"abbaabba\" and not \"abbabba\"?"
                    },
                    {
                        "username": "Alpha_690163",
                        "content": "[@unarov](/unarov) \\nInput: s = \"abcd\"\\nOutput: \"dcbabcd\"\\nhere, a is not appended."
                    },
                    {
                        "username": "Prabhaaa111",
                        "content": "you have to append characters only in front of string without removing characters from original string."
                    },
                    {
                        "username": "unarov",
                        "content": "To make \"abbabba\" from \"aabba\" you should remove one \"a\". But it is not allowed. You can only add chars in front of given string"
                    },
                    {
                        "username": "aastha985",
                        "content": "**Idea:**\\nThe **brute force** solution would be to check all possible strings starting from index 0 and check if they form a palindrome. This would be O(n^2) and gives TLE.\\n\\n**Optimized Approach**(Using KMP Algorithm)\\n1. How KMP Algorithm works: KMP is a pattern matching algorithm, where we are given a pattern and we need to check if the prefix of the pattern exists in a string.\\n2. How are we using KMP here: The trick here is to concatenate the string with its reverse with a # character in between. Now we apply KMP to this string to get the length of string starting from 0 which is a palindrome.\\n3. We have 2 pointers one to match the pattern which starts from index = 0 and other which starts from i = 1 and an array table initialized to the length of the string in point 2.\\n4. If character at index matches the character at i, we set table[i] = table[i-1]+1 and increment the index.\\n5. Else we set index to table[i-1] and continue setting it to table[index-1] till index>0 and the character at index is not equal to character at i.\\n6. If the character at index is equal to character at i, increment the index.\\n7. Set table[i] to index.\\n8.  In the end, the value at table[table.length-1] will be the length of the palindromic substring starting from 0.\\n\\n[Code can be found here](https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation)\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:**  O(n)"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "Can we solve this problem using hashing"
                    },
                    {
                        "username": "Anonymous2389",
                        "content": "It is mentioned that the approach is accepted but i am geting TLE even when i copied that code to test it"
                    },
                    {
                        "username": "_Dinu",
                        "content": "I am getting a wrong answer with \"abb\" case.\\n\\nMy code has this output \"abba\"\\nExpected is \"bbabb\"\\n\\n\"abba\" is shorter than \"bbabb\"\\n"
                    },
                    {
                        "username": "literalEval",
                        "content": "\\'abba\\' nahi maan rahe"
                    },
                    {
                        "username": "SxreaM",
                        "content": "you have to add characters in front of string not at the end"
                    },
                    {
                        "username": "Weskarini",
                        "content": "Bruh finally got a solution but they have to add a 42000 char testcase for me to get Time Limit\\'d"
                    },
                    {
                        "username": "payal94",
                        "content": "Hello LeetCode,\\n\\npreviously everything was working fine, suddenly I am not able to executed code on leetcode. Status is coming pending. So, I tried to submit already accepted answer. Even, status for that too is coming PENDING. Can anyone help me with this ?"
                    },
                    {
                        "username": "davidtan1890",
                        "content": "I stumbled upon [this implementation here][1]. \\n\\nIt is interesting and accepted by leetcode as of 2015-06-05. However, it is wrong. For test case like \"aabba\", it outputs \"aabba\", however, the correct output should be \"abbaabba\". More test cases needed so that the string s+reverse(s) will have p with length of p >= length of s (here p is the prefix of s + reverse(s), and also a suffix) \\n\\n\\n  [1]: https://leetcode.com/discuss/36987/python-solution-kmp"
                    },
                    {
                        "username": "nishant_suthar",
                        "content": "why this is giving TLE\n\n` class Solution {\n    public String shortestPalindrome(String s) {\n        String temp=s;\n        StringBuilder sb=new StringBuilder(s);\n\n        if(temp.equals(sb.reverse().toString())) return temp;\n\n        int i=0;\n        int j=s.length()-1;\n\n        while(j>0){\n            Character c=s.charAt(j);\n\n            temp=temp.substring(0,i)+c+temp.substring(i);\n\n            sb = new StringBuilder(temp); \n            if(temp.equals(sb.reverse().toString())){\n\n                return temp;\n            }\n            i++;\n            j--;\n\n        }\n        return \"\";\n    }\n}`\n"
                    }
                ]
            },
            {
                "id": 2007326,
                "content": [
                    {
                        "username": "b06902111",
                        "content": "Why getting TLE with this...? I tested, my code works with s = \"\" empty string. But what is this? Can anyone help?\n![Imgur](https://imgur.com/pcHddiZ.jpg)"
                    },
                    {
                        "username": "at218808",
                        "content": "check if you are passing string by reference or not, second O(n^2) will fail"
                    },
                    {
                        "username": "q23175401",
                        "content": "Has anyone fixed this issue?"
                    },
                    {
                        "username": "user6007Dd",
                        "content": "I have the same problem. I didnt have it at first but now I get it for every submit. "
                    },
                    {
                        "username": "Conrad_123",
                        "content": "I\\'m having the same issue. When I try to use this as a test case, it prompts me to make my own. Not sure how to go about fixing this. "
                    },
                    {
                        "username": "Kaynex",
                        "content": "Time limit exceeded means you\\'ve exceeed the time limit.\\nNeed to speed up your algorithm."
                    },
                    {
                        "username": "dkvg_77",
                        "content": "Please someone give solution for this"
                    },
                    {
                        "username": "monderpet",
                        "content": "Same issue."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please donate stars\\n\\n![image](https://assets.leetcode.com/users/images/f8fbdf0e-77f7-4f68-a4e0-29236d2931ef_1636547465.0409968.png)\\n\\n![image](https://assets.leetcode.com/users/images/691dee61-ffd3-48b8-a8d3-5adf743a0d97_1636547470.6172163.png)\\n"
                    },
                    {
                        "username": "Rithsek",
                        "content": "why s = \"aabba\"\\nExpected = \"abbaabba\" and not \"abbabba\"?"
                    },
                    {
                        "username": "Alpha_690163",
                        "content": "[@unarov](/unarov) \\nInput: s = \"abcd\"\\nOutput: \"dcbabcd\"\\nhere, a is not appended."
                    },
                    {
                        "username": "Prabhaaa111",
                        "content": "you have to append characters only in front of string without removing characters from original string."
                    },
                    {
                        "username": "unarov",
                        "content": "To make \"abbabba\" from \"aabba\" you should remove one \"a\". But it is not allowed. You can only add chars in front of given string"
                    },
                    {
                        "username": "aastha985",
                        "content": "**Idea:**\\nThe **brute force** solution would be to check all possible strings starting from index 0 and check if they form a palindrome. This would be O(n^2) and gives TLE.\\n\\n**Optimized Approach**(Using KMP Algorithm)\\n1. How KMP Algorithm works: KMP is a pattern matching algorithm, where we are given a pattern and we need to check if the prefix of the pattern exists in a string.\\n2. How are we using KMP here: The trick here is to concatenate the string with its reverse with a # character in between. Now we apply KMP to this string to get the length of string starting from 0 which is a palindrome.\\n3. We have 2 pointers one to match the pattern which starts from index = 0 and other which starts from i = 1 and an array table initialized to the length of the string in point 2.\\n4. If character at index matches the character at i, we set table[i] = table[i-1]+1 and increment the index.\\n5. Else we set index to table[i-1] and continue setting it to table[index-1] till index>0 and the character at index is not equal to character at i.\\n6. If the character at index is equal to character at i, increment the index.\\n7. Set table[i] to index.\\n8.  In the end, the value at table[table.length-1] will be the length of the palindromic substring starting from 0.\\n\\n[Code can be found here](https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation)\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:**  O(n)"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "Can we solve this problem using hashing"
                    },
                    {
                        "username": "Anonymous2389",
                        "content": "It is mentioned that the approach is accepted but i am geting TLE even when i copied that code to test it"
                    },
                    {
                        "username": "_Dinu",
                        "content": "I am getting a wrong answer with \"abb\" case.\\n\\nMy code has this output \"abba\"\\nExpected is \"bbabb\"\\n\\n\"abba\" is shorter than \"bbabb\"\\n"
                    },
                    {
                        "username": "literalEval",
                        "content": "\\'abba\\' nahi maan rahe"
                    },
                    {
                        "username": "SxreaM",
                        "content": "you have to add characters in front of string not at the end"
                    },
                    {
                        "username": "Weskarini",
                        "content": "Bruh finally got a solution but they have to add a 42000 char testcase for me to get Time Limit\\'d"
                    },
                    {
                        "username": "payal94",
                        "content": "Hello LeetCode,\\n\\npreviously everything was working fine, suddenly I am not able to executed code on leetcode. Status is coming pending. So, I tried to submit already accepted answer. Even, status for that too is coming PENDING. Can anyone help me with this ?"
                    },
                    {
                        "username": "davidtan1890",
                        "content": "I stumbled upon [this implementation here][1]. \\n\\nIt is interesting and accepted by leetcode as of 2015-06-05. However, it is wrong. For test case like \"aabba\", it outputs \"aabba\", however, the correct output should be \"abbaabba\". More test cases needed so that the string s+reverse(s) will have p with length of p >= length of s (here p is the prefix of s + reverse(s), and also a suffix) \\n\\n\\n  [1]: https://leetcode.com/discuss/36987/python-solution-kmp"
                    },
                    {
                        "username": "nishant_suthar",
                        "content": "why this is giving TLE\n\n` class Solution {\n    public String shortestPalindrome(String s) {\n        String temp=s;\n        StringBuilder sb=new StringBuilder(s);\n\n        if(temp.equals(sb.reverse().toString())) return temp;\n\n        int i=0;\n        int j=s.length()-1;\n\n        while(j>0){\n            Character c=s.charAt(j);\n\n            temp=temp.substring(0,i)+c+temp.substring(i);\n\n            sb = new StringBuilder(temp); \n            if(temp.equals(sb.reverse().toString())){\n\n                return temp;\n            }\n            i++;\n            j--;\n\n        }\n        return \"\";\n    }\n}`\n"
                    }
                ]
            },
            {
                "id": 1571440,
                "content": [
                    {
                        "username": "b06902111",
                        "content": "Why getting TLE with this...? I tested, my code works with s = \"\" empty string. But what is this? Can anyone help?\n![Imgur](https://imgur.com/pcHddiZ.jpg)"
                    },
                    {
                        "username": "at218808",
                        "content": "check if you are passing string by reference or not, second O(n^2) will fail"
                    },
                    {
                        "username": "q23175401",
                        "content": "Has anyone fixed this issue?"
                    },
                    {
                        "username": "user6007Dd",
                        "content": "I have the same problem. I didnt have it at first but now I get it for every submit. "
                    },
                    {
                        "username": "Conrad_123",
                        "content": "I\\'m having the same issue. When I try to use this as a test case, it prompts me to make my own. Not sure how to go about fixing this. "
                    },
                    {
                        "username": "Kaynex",
                        "content": "Time limit exceeded means you\\'ve exceeed the time limit.\\nNeed to speed up your algorithm."
                    },
                    {
                        "username": "dkvg_77",
                        "content": "Please someone give solution for this"
                    },
                    {
                        "username": "monderpet",
                        "content": "Same issue."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please donate stars\\n\\n![image](https://assets.leetcode.com/users/images/f8fbdf0e-77f7-4f68-a4e0-29236d2931ef_1636547465.0409968.png)\\n\\n![image](https://assets.leetcode.com/users/images/691dee61-ffd3-48b8-a8d3-5adf743a0d97_1636547470.6172163.png)\\n"
                    },
                    {
                        "username": "Rithsek",
                        "content": "why s = \"aabba\"\\nExpected = \"abbaabba\" and not \"abbabba\"?"
                    },
                    {
                        "username": "Alpha_690163",
                        "content": "[@unarov](/unarov) \\nInput: s = \"abcd\"\\nOutput: \"dcbabcd\"\\nhere, a is not appended."
                    },
                    {
                        "username": "Prabhaaa111",
                        "content": "you have to append characters only in front of string without removing characters from original string."
                    },
                    {
                        "username": "unarov",
                        "content": "To make \"abbabba\" from \"aabba\" you should remove one \"a\". But it is not allowed. You can only add chars in front of given string"
                    },
                    {
                        "username": "aastha985",
                        "content": "**Idea:**\\nThe **brute force** solution would be to check all possible strings starting from index 0 and check if they form a palindrome. This would be O(n^2) and gives TLE.\\n\\n**Optimized Approach**(Using KMP Algorithm)\\n1. How KMP Algorithm works: KMP is a pattern matching algorithm, where we are given a pattern and we need to check if the prefix of the pattern exists in a string.\\n2. How are we using KMP here: The trick here is to concatenate the string with its reverse with a # character in between. Now we apply KMP to this string to get the length of string starting from 0 which is a palindrome.\\n3. We have 2 pointers one to match the pattern which starts from index = 0 and other which starts from i = 1 and an array table initialized to the length of the string in point 2.\\n4. If character at index matches the character at i, we set table[i] = table[i-1]+1 and increment the index.\\n5. Else we set index to table[i-1] and continue setting it to table[index-1] till index>0 and the character at index is not equal to character at i.\\n6. If the character at index is equal to character at i, increment the index.\\n7. Set table[i] to index.\\n8.  In the end, the value at table[table.length-1] will be the length of the palindromic substring starting from 0.\\n\\n[Code can be found here](https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation)\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:**  O(n)"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "Can we solve this problem using hashing"
                    },
                    {
                        "username": "Anonymous2389",
                        "content": "It is mentioned that the approach is accepted but i am geting TLE even when i copied that code to test it"
                    },
                    {
                        "username": "_Dinu",
                        "content": "I am getting a wrong answer with \"abb\" case.\\n\\nMy code has this output \"abba\"\\nExpected is \"bbabb\"\\n\\n\"abba\" is shorter than \"bbabb\"\\n"
                    },
                    {
                        "username": "literalEval",
                        "content": "\\'abba\\' nahi maan rahe"
                    },
                    {
                        "username": "SxreaM",
                        "content": "you have to add characters in front of string not at the end"
                    },
                    {
                        "username": "Weskarini",
                        "content": "Bruh finally got a solution but they have to add a 42000 char testcase for me to get Time Limit\\'d"
                    },
                    {
                        "username": "payal94",
                        "content": "Hello LeetCode,\\n\\npreviously everything was working fine, suddenly I am not able to executed code on leetcode. Status is coming pending. So, I tried to submit already accepted answer. Even, status for that too is coming PENDING. Can anyone help me with this ?"
                    },
                    {
                        "username": "davidtan1890",
                        "content": "I stumbled upon [this implementation here][1]. \\n\\nIt is interesting and accepted by leetcode as of 2015-06-05. However, it is wrong. For test case like \"aabba\", it outputs \"aabba\", however, the correct output should be \"abbaabba\". More test cases needed so that the string s+reverse(s) will have p with length of p >= length of s (here p is the prefix of s + reverse(s), and also a suffix) \\n\\n\\n  [1]: https://leetcode.com/discuss/36987/python-solution-kmp"
                    },
                    {
                        "username": "nishant_suthar",
                        "content": "why this is giving TLE\n\n` class Solution {\n    public String shortestPalindrome(String s) {\n        String temp=s;\n        StringBuilder sb=new StringBuilder(s);\n\n        if(temp.equals(sb.reverse().toString())) return temp;\n\n        int i=0;\n        int j=s.length()-1;\n\n        while(j>0){\n            Character c=s.charAt(j);\n\n            temp=temp.substring(0,i)+c+temp.substring(i);\n\n            sb = new StringBuilder(temp); \n            if(temp.equals(sb.reverse().toString())){\n\n                return temp;\n            }\n            i++;\n            j--;\n\n        }\n        return \"\";\n    }\n}`\n"
                    }
                ]
            },
            {
                "id": 1571442,
                "content": [
                    {
                        "username": "b06902111",
                        "content": "Why getting TLE with this...? I tested, my code works with s = \"\" empty string. But what is this? Can anyone help?\n![Imgur](https://imgur.com/pcHddiZ.jpg)"
                    },
                    {
                        "username": "at218808",
                        "content": "check if you are passing string by reference or not, second O(n^2) will fail"
                    },
                    {
                        "username": "q23175401",
                        "content": "Has anyone fixed this issue?"
                    },
                    {
                        "username": "user6007Dd",
                        "content": "I have the same problem. I didnt have it at first but now I get it for every submit. "
                    },
                    {
                        "username": "Conrad_123",
                        "content": "I\\'m having the same issue. When I try to use this as a test case, it prompts me to make my own. Not sure how to go about fixing this. "
                    },
                    {
                        "username": "Kaynex",
                        "content": "Time limit exceeded means you\\'ve exceeed the time limit.\\nNeed to speed up your algorithm."
                    },
                    {
                        "username": "dkvg_77",
                        "content": "Please someone give solution for this"
                    },
                    {
                        "username": "monderpet",
                        "content": "Same issue."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please donate stars\\n\\n![image](https://assets.leetcode.com/users/images/f8fbdf0e-77f7-4f68-a4e0-29236d2931ef_1636547465.0409968.png)\\n\\n![image](https://assets.leetcode.com/users/images/691dee61-ffd3-48b8-a8d3-5adf743a0d97_1636547470.6172163.png)\\n"
                    },
                    {
                        "username": "Rithsek",
                        "content": "why s = \"aabba\"\\nExpected = \"abbaabba\" and not \"abbabba\"?"
                    },
                    {
                        "username": "Alpha_690163",
                        "content": "[@unarov](/unarov) \\nInput: s = \"abcd\"\\nOutput: \"dcbabcd\"\\nhere, a is not appended."
                    },
                    {
                        "username": "Prabhaaa111",
                        "content": "you have to append characters only in front of string without removing characters from original string."
                    },
                    {
                        "username": "unarov",
                        "content": "To make \"abbabba\" from \"aabba\" you should remove one \"a\". But it is not allowed. You can only add chars in front of given string"
                    },
                    {
                        "username": "aastha985",
                        "content": "**Idea:**\\nThe **brute force** solution would be to check all possible strings starting from index 0 and check if they form a palindrome. This would be O(n^2) and gives TLE.\\n\\n**Optimized Approach**(Using KMP Algorithm)\\n1. How KMP Algorithm works: KMP is a pattern matching algorithm, where we are given a pattern and we need to check if the prefix of the pattern exists in a string.\\n2. How are we using KMP here: The trick here is to concatenate the string with its reverse with a # character in between. Now we apply KMP to this string to get the length of string starting from 0 which is a palindrome.\\n3. We have 2 pointers one to match the pattern which starts from index = 0 and other which starts from i = 1 and an array table initialized to the length of the string in point 2.\\n4. If character at index matches the character at i, we set table[i] = table[i-1]+1 and increment the index.\\n5. Else we set index to table[i-1] and continue setting it to table[index-1] till index>0 and the character at index is not equal to character at i.\\n6. If the character at index is equal to character at i, increment the index.\\n7. Set table[i] to index.\\n8.  In the end, the value at table[table.length-1] will be the length of the palindromic substring starting from 0.\\n\\n[Code can be found here](https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation)\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:**  O(n)"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "Can we solve this problem using hashing"
                    },
                    {
                        "username": "Anonymous2389",
                        "content": "It is mentioned that the approach is accepted but i am geting TLE even when i copied that code to test it"
                    },
                    {
                        "username": "_Dinu",
                        "content": "I am getting a wrong answer with \"abb\" case.\\n\\nMy code has this output \"abba\"\\nExpected is \"bbabb\"\\n\\n\"abba\" is shorter than \"bbabb\"\\n"
                    },
                    {
                        "username": "literalEval",
                        "content": "\\'abba\\' nahi maan rahe"
                    },
                    {
                        "username": "SxreaM",
                        "content": "you have to add characters in front of string not at the end"
                    },
                    {
                        "username": "Weskarini",
                        "content": "Bruh finally got a solution but they have to add a 42000 char testcase for me to get Time Limit\\'d"
                    },
                    {
                        "username": "payal94",
                        "content": "Hello LeetCode,\\n\\npreviously everything was working fine, suddenly I am not able to executed code on leetcode. Status is coming pending. So, I tried to submit already accepted answer. Even, status for that too is coming PENDING. Can anyone help me with this ?"
                    },
                    {
                        "username": "davidtan1890",
                        "content": "I stumbled upon [this implementation here][1]. \\n\\nIt is interesting and accepted by leetcode as of 2015-06-05. However, it is wrong. For test case like \"aabba\", it outputs \"aabba\", however, the correct output should be \"abbaabba\". More test cases needed so that the string s+reverse(s) will have p with length of p >= length of s (here p is the prefix of s + reverse(s), and also a suffix) \\n\\n\\n  [1]: https://leetcode.com/discuss/36987/python-solution-kmp"
                    },
                    {
                        "username": "nishant_suthar",
                        "content": "why this is giving TLE\n\n` class Solution {\n    public String shortestPalindrome(String s) {\n        String temp=s;\n        StringBuilder sb=new StringBuilder(s);\n\n        if(temp.equals(sb.reverse().toString())) return temp;\n\n        int i=0;\n        int j=s.length()-1;\n\n        while(j>0){\n            Character c=s.charAt(j);\n\n            temp=temp.substring(0,i)+c+temp.substring(i);\n\n            sb = new StringBuilder(temp); \n            if(temp.equals(sb.reverse().toString())){\n\n                return temp;\n            }\n            i++;\n            j--;\n\n        }\n        return \"\";\n    }\n}`\n"
                    }
                ]
            },
            {
                "id": 2071002,
                "content": [
                    {
                        "username": "b06902111",
                        "content": "Why getting TLE with this...? I tested, my code works with s = \"\" empty string. But what is this? Can anyone help?\n![Imgur](https://imgur.com/pcHddiZ.jpg)"
                    },
                    {
                        "username": "at218808",
                        "content": "check if you are passing string by reference or not, second O(n^2) will fail"
                    },
                    {
                        "username": "q23175401",
                        "content": "Has anyone fixed this issue?"
                    },
                    {
                        "username": "user6007Dd",
                        "content": "I have the same problem. I didnt have it at first but now I get it for every submit. "
                    },
                    {
                        "username": "Conrad_123",
                        "content": "I\\'m having the same issue. When I try to use this as a test case, it prompts me to make my own. Not sure how to go about fixing this. "
                    },
                    {
                        "username": "Kaynex",
                        "content": "Time limit exceeded means you\\'ve exceeed the time limit.\\nNeed to speed up your algorithm."
                    },
                    {
                        "username": "dkvg_77",
                        "content": "Please someone give solution for this"
                    },
                    {
                        "username": "monderpet",
                        "content": "Same issue."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please donate stars\\n\\n![image](https://assets.leetcode.com/users/images/f8fbdf0e-77f7-4f68-a4e0-29236d2931ef_1636547465.0409968.png)\\n\\n![image](https://assets.leetcode.com/users/images/691dee61-ffd3-48b8-a8d3-5adf743a0d97_1636547470.6172163.png)\\n"
                    },
                    {
                        "username": "Rithsek",
                        "content": "why s = \"aabba\"\\nExpected = \"abbaabba\" and not \"abbabba\"?"
                    },
                    {
                        "username": "Alpha_690163",
                        "content": "[@unarov](/unarov) \\nInput: s = \"abcd\"\\nOutput: \"dcbabcd\"\\nhere, a is not appended."
                    },
                    {
                        "username": "Prabhaaa111",
                        "content": "you have to append characters only in front of string without removing characters from original string."
                    },
                    {
                        "username": "unarov",
                        "content": "To make \"abbabba\" from \"aabba\" you should remove one \"a\". But it is not allowed. You can only add chars in front of given string"
                    },
                    {
                        "username": "aastha985",
                        "content": "**Idea:**\\nThe **brute force** solution would be to check all possible strings starting from index 0 and check if they form a palindrome. This would be O(n^2) and gives TLE.\\n\\n**Optimized Approach**(Using KMP Algorithm)\\n1. How KMP Algorithm works: KMP is a pattern matching algorithm, where we are given a pattern and we need to check if the prefix of the pattern exists in a string.\\n2. How are we using KMP here: The trick here is to concatenate the string with its reverse with a # character in between. Now we apply KMP to this string to get the length of string starting from 0 which is a palindrome.\\n3. We have 2 pointers one to match the pattern which starts from index = 0 and other which starts from i = 1 and an array table initialized to the length of the string in point 2.\\n4. If character at index matches the character at i, we set table[i] = table[i-1]+1 and increment the index.\\n5. Else we set index to table[i-1] and continue setting it to table[index-1] till index>0 and the character at index is not equal to character at i.\\n6. If the character at index is equal to character at i, increment the index.\\n7. Set table[i] to index.\\n8.  In the end, the value at table[table.length-1] will be the length of the palindromic substring starting from 0.\\n\\n[Code can be found here](https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation)\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:**  O(n)"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "Can we solve this problem using hashing"
                    },
                    {
                        "username": "Anonymous2389",
                        "content": "It is mentioned that the approach is accepted but i am geting TLE even when i copied that code to test it"
                    },
                    {
                        "username": "_Dinu",
                        "content": "I am getting a wrong answer with \"abb\" case.\\n\\nMy code has this output \"abba\"\\nExpected is \"bbabb\"\\n\\n\"abba\" is shorter than \"bbabb\"\\n"
                    },
                    {
                        "username": "literalEval",
                        "content": "\\'abba\\' nahi maan rahe"
                    },
                    {
                        "username": "SxreaM",
                        "content": "you have to add characters in front of string not at the end"
                    },
                    {
                        "username": "Weskarini",
                        "content": "Bruh finally got a solution but they have to add a 42000 char testcase for me to get Time Limit\\'d"
                    },
                    {
                        "username": "payal94",
                        "content": "Hello LeetCode,\\n\\npreviously everything was working fine, suddenly I am not able to executed code on leetcode. Status is coming pending. So, I tried to submit already accepted answer. Even, status for that too is coming PENDING. Can anyone help me with this ?"
                    },
                    {
                        "username": "davidtan1890",
                        "content": "I stumbled upon [this implementation here][1]. \\n\\nIt is interesting and accepted by leetcode as of 2015-06-05. However, it is wrong. For test case like \"aabba\", it outputs \"aabba\", however, the correct output should be \"abbaabba\". More test cases needed so that the string s+reverse(s) will have p with length of p >= length of s (here p is the prefix of s + reverse(s), and also a suffix) \\n\\n\\n  [1]: https://leetcode.com/discuss/36987/python-solution-kmp"
                    },
                    {
                        "username": "nishant_suthar",
                        "content": "why this is giving TLE\n\n` class Solution {\n    public String shortestPalindrome(String s) {\n        String temp=s;\n        StringBuilder sb=new StringBuilder(s);\n\n        if(temp.equals(sb.reverse().toString())) return temp;\n\n        int i=0;\n        int j=s.length()-1;\n\n        while(j>0){\n            Character c=s.charAt(j);\n\n            temp=temp.substring(0,i)+c+temp.substring(i);\n\n            sb = new StringBuilder(temp); \n            if(temp.equals(sb.reverse().toString())){\n\n                return temp;\n            }\n            i++;\n            j--;\n\n        }\n        return \"\";\n    }\n}`\n"
                    }
                ]
            },
            {
                "id": 1711491,
                "content": [
                    {
                        "username": "b06902111",
                        "content": "Why getting TLE with this...? I tested, my code works with s = \"\" empty string. But what is this? Can anyone help?\n![Imgur](https://imgur.com/pcHddiZ.jpg)"
                    },
                    {
                        "username": "at218808",
                        "content": "check if you are passing string by reference or not, second O(n^2) will fail"
                    },
                    {
                        "username": "q23175401",
                        "content": "Has anyone fixed this issue?"
                    },
                    {
                        "username": "user6007Dd",
                        "content": "I have the same problem. I didnt have it at first but now I get it for every submit. "
                    },
                    {
                        "username": "Conrad_123",
                        "content": "I\\'m having the same issue. When I try to use this as a test case, it prompts me to make my own. Not sure how to go about fixing this. "
                    },
                    {
                        "username": "Kaynex",
                        "content": "Time limit exceeded means you\\'ve exceeed the time limit.\\nNeed to speed up your algorithm."
                    },
                    {
                        "username": "dkvg_77",
                        "content": "Please someone give solution for this"
                    },
                    {
                        "username": "monderpet",
                        "content": "Same issue."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please donate stars\\n\\n![image](https://assets.leetcode.com/users/images/f8fbdf0e-77f7-4f68-a4e0-29236d2931ef_1636547465.0409968.png)\\n\\n![image](https://assets.leetcode.com/users/images/691dee61-ffd3-48b8-a8d3-5adf743a0d97_1636547470.6172163.png)\\n"
                    },
                    {
                        "username": "Rithsek",
                        "content": "why s = \"aabba\"\\nExpected = \"abbaabba\" and not \"abbabba\"?"
                    },
                    {
                        "username": "Alpha_690163",
                        "content": "[@unarov](/unarov) \\nInput: s = \"abcd\"\\nOutput: \"dcbabcd\"\\nhere, a is not appended."
                    },
                    {
                        "username": "Prabhaaa111",
                        "content": "you have to append characters only in front of string without removing characters from original string."
                    },
                    {
                        "username": "unarov",
                        "content": "To make \"abbabba\" from \"aabba\" you should remove one \"a\". But it is not allowed. You can only add chars in front of given string"
                    },
                    {
                        "username": "aastha985",
                        "content": "**Idea:**\\nThe **brute force** solution would be to check all possible strings starting from index 0 and check if they form a palindrome. This would be O(n^2) and gives TLE.\\n\\n**Optimized Approach**(Using KMP Algorithm)\\n1. How KMP Algorithm works: KMP is a pattern matching algorithm, where we are given a pattern and we need to check if the prefix of the pattern exists in a string.\\n2. How are we using KMP here: The trick here is to concatenate the string with its reverse with a # character in between. Now we apply KMP to this string to get the length of string starting from 0 which is a palindrome.\\n3. We have 2 pointers one to match the pattern which starts from index = 0 and other which starts from i = 1 and an array table initialized to the length of the string in point 2.\\n4. If character at index matches the character at i, we set table[i] = table[i-1]+1 and increment the index.\\n5. Else we set index to table[i-1] and continue setting it to table[index-1] till index>0 and the character at index is not equal to character at i.\\n6. If the character at index is equal to character at i, increment the index.\\n7. Set table[i] to index.\\n8.  In the end, the value at table[table.length-1] will be the length of the palindromic substring starting from 0.\\n\\n[Code can be found here](https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation)\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:**  O(n)"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "Can we solve this problem using hashing"
                    },
                    {
                        "username": "Anonymous2389",
                        "content": "It is mentioned that the approach is accepted but i am geting TLE even when i copied that code to test it"
                    },
                    {
                        "username": "_Dinu",
                        "content": "I am getting a wrong answer with \"abb\" case.\\n\\nMy code has this output \"abba\"\\nExpected is \"bbabb\"\\n\\n\"abba\" is shorter than \"bbabb\"\\n"
                    },
                    {
                        "username": "literalEval",
                        "content": "\\'abba\\' nahi maan rahe"
                    },
                    {
                        "username": "SxreaM",
                        "content": "you have to add characters in front of string not at the end"
                    },
                    {
                        "username": "Weskarini",
                        "content": "Bruh finally got a solution but they have to add a 42000 char testcase for me to get Time Limit\\'d"
                    },
                    {
                        "username": "payal94",
                        "content": "Hello LeetCode,\\n\\npreviously everything was working fine, suddenly I am not able to executed code on leetcode. Status is coming pending. So, I tried to submit already accepted answer. Even, status for that too is coming PENDING. Can anyone help me with this ?"
                    },
                    {
                        "username": "davidtan1890",
                        "content": "I stumbled upon [this implementation here][1]. \\n\\nIt is interesting and accepted by leetcode as of 2015-06-05. However, it is wrong. For test case like \"aabba\", it outputs \"aabba\", however, the correct output should be \"abbaabba\". More test cases needed so that the string s+reverse(s) will have p with length of p >= length of s (here p is the prefix of s + reverse(s), and also a suffix) \\n\\n\\n  [1]: https://leetcode.com/discuss/36987/python-solution-kmp"
                    },
                    {
                        "username": "nishant_suthar",
                        "content": "why this is giving TLE\n\n` class Solution {\n    public String shortestPalindrome(String s) {\n        String temp=s;\n        StringBuilder sb=new StringBuilder(s);\n\n        if(temp.equals(sb.reverse().toString())) return temp;\n\n        int i=0;\n        int j=s.length()-1;\n\n        while(j>0){\n            Character c=s.charAt(j);\n\n            temp=temp.substring(0,i)+c+temp.substring(i);\n\n            sb = new StringBuilder(temp); \n            if(temp.equals(sb.reverse().toString())){\n\n                return temp;\n            }\n            i++;\n            j--;\n\n        }\n        return \"\";\n    }\n}`\n"
                    }
                ]
            },
            {
                "id": 1575952,
                "content": [
                    {
                        "username": "b06902111",
                        "content": "Why getting TLE with this...? I tested, my code works with s = \"\" empty string. But what is this? Can anyone help?\n![Imgur](https://imgur.com/pcHddiZ.jpg)"
                    },
                    {
                        "username": "at218808",
                        "content": "check if you are passing string by reference or not, second O(n^2) will fail"
                    },
                    {
                        "username": "q23175401",
                        "content": "Has anyone fixed this issue?"
                    },
                    {
                        "username": "user6007Dd",
                        "content": "I have the same problem. I didnt have it at first but now I get it for every submit. "
                    },
                    {
                        "username": "Conrad_123",
                        "content": "I\\'m having the same issue. When I try to use this as a test case, it prompts me to make my own. Not sure how to go about fixing this. "
                    },
                    {
                        "username": "Kaynex",
                        "content": "Time limit exceeded means you\\'ve exceeed the time limit.\\nNeed to speed up your algorithm."
                    },
                    {
                        "username": "dkvg_77",
                        "content": "Please someone give solution for this"
                    },
                    {
                        "username": "monderpet",
                        "content": "Same issue."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please donate stars\\n\\n![image](https://assets.leetcode.com/users/images/f8fbdf0e-77f7-4f68-a4e0-29236d2931ef_1636547465.0409968.png)\\n\\n![image](https://assets.leetcode.com/users/images/691dee61-ffd3-48b8-a8d3-5adf743a0d97_1636547470.6172163.png)\\n"
                    },
                    {
                        "username": "Rithsek",
                        "content": "why s = \"aabba\"\\nExpected = \"abbaabba\" and not \"abbabba\"?"
                    },
                    {
                        "username": "Alpha_690163",
                        "content": "[@unarov](/unarov) \\nInput: s = \"abcd\"\\nOutput: \"dcbabcd\"\\nhere, a is not appended."
                    },
                    {
                        "username": "Prabhaaa111",
                        "content": "you have to append characters only in front of string without removing characters from original string."
                    },
                    {
                        "username": "unarov",
                        "content": "To make \"abbabba\" from \"aabba\" you should remove one \"a\". But it is not allowed. You can only add chars in front of given string"
                    },
                    {
                        "username": "aastha985",
                        "content": "**Idea:**\\nThe **brute force** solution would be to check all possible strings starting from index 0 and check if they form a palindrome. This would be O(n^2) and gives TLE.\\n\\n**Optimized Approach**(Using KMP Algorithm)\\n1. How KMP Algorithm works: KMP is a pattern matching algorithm, where we are given a pattern and we need to check if the prefix of the pattern exists in a string.\\n2. How are we using KMP here: The trick here is to concatenate the string with its reverse with a # character in between. Now we apply KMP to this string to get the length of string starting from 0 which is a palindrome.\\n3. We have 2 pointers one to match the pattern which starts from index = 0 and other which starts from i = 1 and an array table initialized to the length of the string in point 2.\\n4. If character at index matches the character at i, we set table[i] = table[i-1]+1 and increment the index.\\n5. Else we set index to table[i-1] and continue setting it to table[index-1] till index>0 and the character at index is not equal to character at i.\\n6. If the character at index is equal to character at i, increment the index.\\n7. Set table[i] to index.\\n8.  In the end, the value at table[table.length-1] will be the length of the palindromic substring starting from 0.\\n\\n[Code can be found here](https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation)\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:**  O(n)"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "Can we solve this problem using hashing"
                    },
                    {
                        "username": "Anonymous2389",
                        "content": "It is mentioned that the approach is accepted but i am geting TLE even when i copied that code to test it"
                    },
                    {
                        "username": "_Dinu",
                        "content": "I am getting a wrong answer with \"abb\" case.\\n\\nMy code has this output \"abba\"\\nExpected is \"bbabb\"\\n\\n\"abba\" is shorter than \"bbabb\"\\n"
                    },
                    {
                        "username": "literalEval",
                        "content": "\\'abba\\' nahi maan rahe"
                    },
                    {
                        "username": "SxreaM",
                        "content": "you have to add characters in front of string not at the end"
                    },
                    {
                        "username": "Weskarini",
                        "content": "Bruh finally got a solution but they have to add a 42000 char testcase for me to get Time Limit\\'d"
                    },
                    {
                        "username": "payal94",
                        "content": "Hello LeetCode,\\n\\npreviously everything was working fine, suddenly I am not able to executed code on leetcode. Status is coming pending. So, I tried to submit already accepted answer. Even, status for that too is coming PENDING. Can anyone help me with this ?"
                    },
                    {
                        "username": "davidtan1890",
                        "content": "I stumbled upon [this implementation here][1]. \\n\\nIt is interesting and accepted by leetcode as of 2015-06-05. However, it is wrong. For test case like \"aabba\", it outputs \"aabba\", however, the correct output should be \"abbaabba\". More test cases needed so that the string s+reverse(s) will have p with length of p >= length of s (here p is the prefix of s + reverse(s), and also a suffix) \\n\\n\\n  [1]: https://leetcode.com/discuss/36987/python-solution-kmp"
                    },
                    {
                        "username": "nishant_suthar",
                        "content": "why this is giving TLE\n\n` class Solution {\n    public String shortestPalindrome(String s) {\n        String temp=s;\n        StringBuilder sb=new StringBuilder(s);\n\n        if(temp.equals(sb.reverse().toString())) return temp;\n\n        int i=0;\n        int j=s.length()-1;\n\n        while(j>0){\n            Character c=s.charAt(j);\n\n            temp=temp.substring(0,i)+c+temp.substring(i);\n\n            sb = new StringBuilder(temp); \n            if(temp.equals(sb.reverse().toString())){\n\n                return temp;\n            }\n            i++;\n            j--;\n\n        }\n        return \"\";\n    }\n}`\n"
                    }
                ]
            },
            {
                "id": 1679522,
                "content": [
                    {
                        "username": "b06902111",
                        "content": "Why getting TLE with this...? I tested, my code works with s = \"\" empty string. But what is this? Can anyone help?\n![Imgur](https://imgur.com/pcHddiZ.jpg)"
                    },
                    {
                        "username": "at218808",
                        "content": "check if you are passing string by reference or not, second O(n^2) will fail"
                    },
                    {
                        "username": "q23175401",
                        "content": "Has anyone fixed this issue?"
                    },
                    {
                        "username": "user6007Dd",
                        "content": "I have the same problem. I didnt have it at first but now I get it for every submit. "
                    },
                    {
                        "username": "Conrad_123",
                        "content": "I\\'m having the same issue. When I try to use this as a test case, it prompts me to make my own. Not sure how to go about fixing this. "
                    },
                    {
                        "username": "Kaynex",
                        "content": "Time limit exceeded means you\\'ve exceeed the time limit.\\nNeed to speed up your algorithm."
                    },
                    {
                        "username": "dkvg_77",
                        "content": "Please someone give solution for this"
                    },
                    {
                        "username": "monderpet",
                        "content": "Same issue."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please donate stars\\n\\n![image](https://assets.leetcode.com/users/images/f8fbdf0e-77f7-4f68-a4e0-29236d2931ef_1636547465.0409968.png)\\n\\n![image](https://assets.leetcode.com/users/images/691dee61-ffd3-48b8-a8d3-5adf743a0d97_1636547470.6172163.png)\\n"
                    },
                    {
                        "username": "Rithsek",
                        "content": "why s = \"aabba\"\\nExpected = \"abbaabba\" and not \"abbabba\"?"
                    },
                    {
                        "username": "Alpha_690163",
                        "content": "[@unarov](/unarov) \\nInput: s = \"abcd\"\\nOutput: \"dcbabcd\"\\nhere, a is not appended."
                    },
                    {
                        "username": "Prabhaaa111",
                        "content": "you have to append characters only in front of string without removing characters from original string."
                    },
                    {
                        "username": "unarov",
                        "content": "To make \"abbabba\" from \"aabba\" you should remove one \"a\". But it is not allowed. You can only add chars in front of given string"
                    },
                    {
                        "username": "aastha985",
                        "content": "**Idea:**\\nThe **brute force** solution would be to check all possible strings starting from index 0 and check if they form a palindrome. This would be O(n^2) and gives TLE.\\n\\n**Optimized Approach**(Using KMP Algorithm)\\n1. How KMP Algorithm works: KMP is a pattern matching algorithm, where we are given a pattern and we need to check if the prefix of the pattern exists in a string.\\n2. How are we using KMP here: The trick here is to concatenate the string with its reverse with a # character in between. Now we apply KMP to this string to get the length of string starting from 0 which is a palindrome.\\n3. We have 2 pointers one to match the pattern which starts from index = 0 and other which starts from i = 1 and an array table initialized to the length of the string in point 2.\\n4. If character at index matches the character at i, we set table[i] = table[i-1]+1 and increment the index.\\n5. Else we set index to table[i-1] and continue setting it to table[index-1] till index>0 and the character at index is not equal to character at i.\\n6. If the character at index is equal to character at i, increment the index.\\n7. Set table[i] to index.\\n8.  In the end, the value at table[table.length-1] will be the length of the palindromic substring starting from 0.\\n\\n[Code can be found here](https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation)\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:**  O(n)"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "Can we solve this problem using hashing"
                    },
                    {
                        "username": "Anonymous2389",
                        "content": "It is mentioned that the approach is accepted but i am geting TLE even when i copied that code to test it"
                    },
                    {
                        "username": "_Dinu",
                        "content": "I am getting a wrong answer with \"abb\" case.\\n\\nMy code has this output \"abba\"\\nExpected is \"bbabb\"\\n\\n\"abba\" is shorter than \"bbabb\"\\n"
                    },
                    {
                        "username": "literalEval",
                        "content": "\\'abba\\' nahi maan rahe"
                    },
                    {
                        "username": "SxreaM",
                        "content": "you have to add characters in front of string not at the end"
                    },
                    {
                        "username": "Weskarini",
                        "content": "Bruh finally got a solution but they have to add a 42000 char testcase for me to get Time Limit\\'d"
                    },
                    {
                        "username": "payal94",
                        "content": "Hello LeetCode,\\n\\npreviously everything was working fine, suddenly I am not able to executed code on leetcode. Status is coming pending. So, I tried to submit already accepted answer. Even, status for that too is coming PENDING. Can anyone help me with this ?"
                    },
                    {
                        "username": "davidtan1890",
                        "content": "I stumbled upon [this implementation here][1]. \\n\\nIt is interesting and accepted by leetcode as of 2015-06-05. However, it is wrong. For test case like \"aabba\", it outputs \"aabba\", however, the correct output should be \"abbaabba\". More test cases needed so that the string s+reverse(s) will have p with length of p >= length of s (here p is the prefix of s + reverse(s), and also a suffix) \\n\\n\\n  [1]: https://leetcode.com/discuss/36987/python-solution-kmp"
                    },
                    {
                        "username": "nishant_suthar",
                        "content": "why this is giving TLE\n\n` class Solution {\n    public String shortestPalindrome(String s) {\n        String temp=s;\n        StringBuilder sb=new StringBuilder(s);\n\n        if(temp.equals(sb.reverse().toString())) return temp;\n\n        int i=0;\n        int j=s.length()-1;\n\n        while(j>0){\n            Character c=s.charAt(j);\n\n            temp=temp.substring(0,i)+c+temp.substring(i);\n\n            sb = new StringBuilder(temp); \n            if(temp.equals(sb.reverse().toString())){\n\n                return temp;\n            }\n            i++;\n            j--;\n\n        }\n        return \"\";\n    }\n}`\n"
                    }
                ]
            },
            {
                "id": 1575249,
                "content": [
                    {
                        "username": "b06902111",
                        "content": "Why getting TLE with this...? I tested, my code works with s = \"\" empty string. But what is this? Can anyone help?\n![Imgur](https://imgur.com/pcHddiZ.jpg)"
                    },
                    {
                        "username": "at218808",
                        "content": "check if you are passing string by reference or not, second O(n^2) will fail"
                    },
                    {
                        "username": "q23175401",
                        "content": "Has anyone fixed this issue?"
                    },
                    {
                        "username": "user6007Dd",
                        "content": "I have the same problem. I didnt have it at first but now I get it for every submit. "
                    },
                    {
                        "username": "Conrad_123",
                        "content": "I\\'m having the same issue. When I try to use this as a test case, it prompts me to make my own. Not sure how to go about fixing this. "
                    },
                    {
                        "username": "Kaynex",
                        "content": "Time limit exceeded means you\\'ve exceeed the time limit.\\nNeed to speed up your algorithm."
                    },
                    {
                        "username": "dkvg_77",
                        "content": "Please someone give solution for this"
                    },
                    {
                        "username": "monderpet",
                        "content": "Same issue."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please donate stars\\n\\n![image](https://assets.leetcode.com/users/images/f8fbdf0e-77f7-4f68-a4e0-29236d2931ef_1636547465.0409968.png)\\n\\n![image](https://assets.leetcode.com/users/images/691dee61-ffd3-48b8-a8d3-5adf743a0d97_1636547470.6172163.png)\\n"
                    },
                    {
                        "username": "Rithsek",
                        "content": "why s = \"aabba\"\\nExpected = \"abbaabba\" and not \"abbabba\"?"
                    },
                    {
                        "username": "Alpha_690163",
                        "content": "[@unarov](/unarov) \\nInput: s = \"abcd\"\\nOutput: \"dcbabcd\"\\nhere, a is not appended."
                    },
                    {
                        "username": "Prabhaaa111",
                        "content": "you have to append characters only in front of string without removing characters from original string."
                    },
                    {
                        "username": "unarov",
                        "content": "To make \"abbabba\" from \"aabba\" you should remove one \"a\". But it is not allowed. You can only add chars in front of given string"
                    },
                    {
                        "username": "aastha985",
                        "content": "**Idea:**\\nThe **brute force** solution would be to check all possible strings starting from index 0 and check if they form a palindrome. This would be O(n^2) and gives TLE.\\n\\n**Optimized Approach**(Using KMP Algorithm)\\n1. How KMP Algorithm works: KMP is a pattern matching algorithm, where we are given a pattern and we need to check if the prefix of the pattern exists in a string.\\n2. How are we using KMP here: The trick here is to concatenate the string with its reverse with a # character in between. Now we apply KMP to this string to get the length of string starting from 0 which is a palindrome.\\n3. We have 2 pointers one to match the pattern which starts from index = 0 and other which starts from i = 1 and an array table initialized to the length of the string in point 2.\\n4. If character at index matches the character at i, we set table[i] = table[i-1]+1 and increment the index.\\n5. Else we set index to table[i-1] and continue setting it to table[index-1] till index>0 and the character at index is not equal to character at i.\\n6. If the character at index is equal to character at i, increment the index.\\n7. Set table[i] to index.\\n8.  In the end, the value at table[table.length-1] will be the length of the palindromic substring starting from 0.\\n\\n[Code can be found here](https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation)\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:**  O(n)"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "Can we solve this problem using hashing"
                    },
                    {
                        "username": "Anonymous2389",
                        "content": "It is mentioned that the approach is accepted but i am geting TLE even when i copied that code to test it"
                    },
                    {
                        "username": "_Dinu",
                        "content": "I am getting a wrong answer with \"abb\" case.\\n\\nMy code has this output \"abba\"\\nExpected is \"bbabb\"\\n\\n\"abba\" is shorter than \"bbabb\"\\n"
                    },
                    {
                        "username": "literalEval",
                        "content": "\\'abba\\' nahi maan rahe"
                    },
                    {
                        "username": "SxreaM",
                        "content": "you have to add characters in front of string not at the end"
                    },
                    {
                        "username": "Weskarini",
                        "content": "Bruh finally got a solution but they have to add a 42000 char testcase for me to get Time Limit\\'d"
                    },
                    {
                        "username": "payal94",
                        "content": "Hello LeetCode,\\n\\npreviously everything was working fine, suddenly I am not able to executed code on leetcode. Status is coming pending. So, I tried to submit already accepted answer. Even, status for that too is coming PENDING. Can anyone help me with this ?"
                    },
                    {
                        "username": "davidtan1890",
                        "content": "I stumbled upon [this implementation here][1]. \\n\\nIt is interesting and accepted by leetcode as of 2015-06-05. However, it is wrong. For test case like \"aabba\", it outputs \"aabba\", however, the correct output should be \"abbaabba\". More test cases needed so that the string s+reverse(s) will have p with length of p >= length of s (here p is the prefix of s + reverse(s), and also a suffix) \\n\\n\\n  [1]: https://leetcode.com/discuss/36987/python-solution-kmp"
                    },
                    {
                        "username": "nishant_suthar",
                        "content": "why this is giving TLE\n\n` class Solution {\n    public String shortestPalindrome(String s) {\n        String temp=s;\n        StringBuilder sb=new StringBuilder(s);\n\n        if(temp.equals(sb.reverse().toString())) return temp;\n\n        int i=0;\n        int j=s.length()-1;\n\n        while(j>0){\n            Character c=s.charAt(j);\n\n            temp=temp.substring(0,i)+c+temp.substring(i);\n\n            sb = new StringBuilder(temp); \n            if(temp.equals(sb.reverse().toString())){\n\n                return temp;\n            }\n            i++;\n            j--;\n\n        }\n        return \"\";\n    }\n}`\n"
                    }
                ]
            },
            {
                "id": 1573865,
                "content": [
                    {
                        "username": "b06902111",
                        "content": "Why getting TLE with this...? I tested, my code works with s = \"\" empty string. But what is this? Can anyone help?\n![Imgur](https://imgur.com/pcHddiZ.jpg)"
                    },
                    {
                        "username": "at218808",
                        "content": "check if you are passing string by reference or not, second O(n^2) will fail"
                    },
                    {
                        "username": "q23175401",
                        "content": "Has anyone fixed this issue?"
                    },
                    {
                        "username": "user6007Dd",
                        "content": "I have the same problem. I didnt have it at first but now I get it for every submit. "
                    },
                    {
                        "username": "Conrad_123",
                        "content": "I\\'m having the same issue. When I try to use this as a test case, it prompts me to make my own. Not sure how to go about fixing this. "
                    },
                    {
                        "username": "Kaynex",
                        "content": "Time limit exceeded means you\\'ve exceeed the time limit.\\nNeed to speed up your algorithm."
                    },
                    {
                        "username": "dkvg_77",
                        "content": "Please someone give solution for this"
                    },
                    {
                        "username": "monderpet",
                        "content": "Same issue."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please donate stars\\n\\n![image](https://assets.leetcode.com/users/images/f8fbdf0e-77f7-4f68-a4e0-29236d2931ef_1636547465.0409968.png)\\n\\n![image](https://assets.leetcode.com/users/images/691dee61-ffd3-48b8-a8d3-5adf743a0d97_1636547470.6172163.png)\\n"
                    },
                    {
                        "username": "Rithsek",
                        "content": "why s = \"aabba\"\\nExpected = \"abbaabba\" and not \"abbabba\"?"
                    },
                    {
                        "username": "Alpha_690163",
                        "content": "[@unarov](/unarov) \\nInput: s = \"abcd\"\\nOutput: \"dcbabcd\"\\nhere, a is not appended."
                    },
                    {
                        "username": "Prabhaaa111",
                        "content": "you have to append characters only in front of string without removing characters from original string."
                    },
                    {
                        "username": "unarov",
                        "content": "To make \"abbabba\" from \"aabba\" you should remove one \"a\". But it is not allowed. You can only add chars in front of given string"
                    },
                    {
                        "username": "aastha985",
                        "content": "**Idea:**\\nThe **brute force** solution would be to check all possible strings starting from index 0 and check if they form a palindrome. This would be O(n^2) and gives TLE.\\n\\n**Optimized Approach**(Using KMP Algorithm)\\n1. How KMP Algorithm works: KMP is a pattern matching algorithm, where we are given a pattern and we need to check if the prefix of the pattern exists in a string.\\n2. How are we using KMP here: The trick here is to concatenate the string with its reverse with a # character in between. Now we apply KMP to this string to get the length of string starting from 0 which is a palindrome.\\n3. We have 2 pointers one to match the pattern which starts from index = 0 and other which starts from i = 1 and an array table initialized to the length of the string in point 2.\\n4. If character at index matches the character at i, we set table[i] = table[i-1]+1 and increment the index.\\n5. Else we set index to table[i-1] and continue setting it to table[index-1] till index>0 and the character at index is not equal to character at i.\\n6. If the character at index is equal to character at i, increment the index.\\n7. Set table[i] to index.\\n8.  In the end, the value at table[table.length-1] will be the length of the palindromic substring starting from 0.\\n\\n[Code can be found here](https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation)\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:**  O(n)"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "Can we solve this problem using hashing"
                    },
                    {
                        "username": "Anonymous2389",
                        "content": "It is mentioned that the approach is accepted but i am geting TLE even when i copied that code to test it"
                    },
                    {
                        "username": "_Dinu",
                        "content": "I am getting a wrong answer with \"abb\" case.\\n\\nMy code has this output \"abba\"\\nExpected is \"bbabb\"\\n\\n\"abba\" is shorter than \"bbabb\"\\n"
                    },
                    {
                        "username": "literalEval",
                        "content": "\\'abba\\' nahi maan rahe"
                    },
                    {
                        "username": "SxreaM",
                        "content": "you have to add characters in front of string not at the end"
                    },
                    {
                        "username": "Weskarini",
                        "content": "Bruh finally got a solution but they have to add a 42000 char testcase for me to get Time Limit\\'d"
                    },
                    {
                        "username": "payal94",
                        "content": "Hello LeetCode,\\n\\npreviously everything was working fine, suddenly I am not able to executed code on leetcode. Status is coming pending. So, I tried to submit already accepted answer. Even, status for that too is coming PENDING. Can anyone help me with this ?"
                    },
                    {
                        "username": "davidtan1890",
                        "content": "I stumbled upon [this implementation here][1]. \\n\\nIt is interesting and accepted by leetcode as of 2015-06-05. However, it is wrong. For test case like \"aabba\", it outputs \"aabba\", however, the correct output should be \"abbaabba\". More test cases needed so that the string s+reverse(s) will have p with length of p >= length of s (here p is the prefix of s + reverse(s), and also a suffix) \\n\\n\\n  [1]: https://leetcode.com/discuss/36987/python-solution-kmp"
                    },
                    {
                        "username": "nishant_suthar",
                        "content": "why this is giving TLE\n\n` class Solution {\n    public String shortestPalindrome(String s) {\n        String temp=s;\n        StringBuilder sb=new StringBuilder(s);\n\n        if(temp.equals(sb.reverse().toString())) return temp;\n\n        int i=0;\n        int j=s.length()-1;\n\n        while(j>0){\n            Character c=s.charAt(j);\n\n            temp=temp.substring(0,i)+c+temp.substring(i);\n\n            sb = new StringBuilder(temp); \n            if(temp.equals(sb.reverse().toString())){\n\n                return temp;\n            }\n            i++;\n            j--;\n\n        }\n        return \"\";\n    }\n}`\n"
                    }
                ]
            },
            {
                "id": 1931979,
                "content": [
                    {
                        "username": "b06902111",
                        "content": "Why getting TLE with this...? I tested, my code works with s = \"\" empty string. But what is this? Can anyone help?\n![Imgur](https://imgur.com/pcHddiZ.jpg)"
                    },
                    {
                        "username": "at218808",
                        "content": "check if you are passing string by reference or not, second O(n^2) will fail"
                    },
                    {
                        "username": "q23175401",
                        "content": "Has anyone fixed this issue?"
                    },
                    {
                        "username": "user6007Dd",
                        "content": "I have the same problem. I didnt have it at first but now I get it for every submit. "
                    },
                    {
                        "username": "Conrad_123",
                        "content": "I\\'m having the same issue. When I try to use this as a test case, it prompts me to make my own. Not sure how to go about fixing this. "
                    },
                    {
                        "username": "Kaynex",
                        "content": "Time limit exceeded means you\\'ve exceeed the time limit.\\nNeed to speed up your algorithm."
                    },
                    {
                        "username": "dkvg_77",
                        "content": "Please someone give solution for this"
                    },
                    {
                        "username": "monderpet",
                        "content": "Same issue."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please donate stars\\n\\n![image](https://assets.leetcode.com/users/images/f8fbdf0e-77f7-4f68-a4e0-29236d2931ef_1636547465.0409968.png)\\n\\n![image](https://assets.leetcode.com/users/images/691dee61-ffd3-48b8-a8d3-5adf743a0d97_1636547470.6172163.png)\\n"
                    },
                    {
                        "username": "Rithsek",
                        "content": "why s = \"aabba\"\\nExpected = \"abbaabba\" and not \"abbabba\"?"
                    },
                    {
                        "username": "Alpha_690163",
                        "content": "[@unarov](/unarov) \\nInput: s = \"abcd\"\\nOutput: \"dcbabcd\"\\nhere, a is not appended."
                    },
                    {
                        "username": "Prabhaaa111",
                        "content": "you have to append characters only in front of string without removing characters from original string."
                    },
                    {
                        "username": "unarov",
                        "content": "To make \"abbabba\" from \"aabba\" you should remove one \"a\". But it is not allowed. You can only add chars in front of given string"
                    },
                    {
                        "username": "aastha985",
                        "content": "**Idea:**\\nThe **brute force** solution would be to check all possible strings starting from index 0 and check if they form a palindrome. This would be O(n^2) and gives TLE.\\n\\n**Optimized Approach**(Using KMP Algorithm)\\n1. How KMP Algorithm works: KMP is a pattern matching algorithm, where we are given a pattern and we need to check if the prefix of the pattern exists in a string.\\n2. How are we using KMP here: The trick here is to concatenate the string with its reverse with a # character in between. Now we apply KMP to this string to get the length of string starting from 0 which is a palindrome.\\n3. We have 2 pointers one to match the pattern which starts from index = 0 and other which starts from i = 1 and an array table initialized to the length of the string in point 2.\\n4. If character at index matches the character at i, we set table[i] = table[i-1]+1 and increment the index.\\n5. Else we set index to table[i-1] and continue setting it to table[index-1] till index>0 and the character at index is not equal to character at i.\\n6. If the character at index is equal to character at i, increment the index.\\n7. Set table[i] to index.\\n8.  In the end, the value at table[table.length-1] will be the length of the palindromic substring starting from 0.\\n\\n[Code can be found here](https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation)\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:**  O(n)"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "Can we solve this problem using hashing"
                    },
                    {
                        "username": "Anonymous2389",
                        "content": "It is mentioned that the approach is accepted but i am geting TLE even when i copied that code to test it"
                    },
                    {
                        "username": "_Dinu",
                        "content": "I am getting a wrong answer with \"abb\" case.\\n\\nMy code has this output \"abba\"\\nExpected is \"bbabb\"\\n\\n\"abba\" is shorter than \"bbabb\"\\n"
                    },
                    {
                        "username": "literalEval",
                        "content": "\\'abba\\' nahi maan rahe"
                    },
                    {
                        "username": "SxreaM",
                        "content": "you have to add characters in front of string not at the end"
                    },
                    {
                        "username": "Weskarini",
                        "content": "Bruh finally got a solution but they have to add a 42000 char testcase for me to get Time Limit\\'d"
                    },
                    {
                        "username": "payal94",
                        "content": "Hello LeetCode,\\n\\npreviously everything was working fine, suddenly I am not able to executed code on leetcode. Status is coming pending. So, I tried to submit already accepted answer. Even, status for that too is coming PENDING. Can anyone help me with this ?"
                    },
                    {
                        "username": "davidtan1890",
                        "content": "I stumbled upon [this implementation here][1]. \\n\\nIt is interesting and accepted by leetcode as of 2015-06-05. However, it is wrong. For test case like \"aabba\", it outputs \"aabba\", however, the correct output should be \"abbaabba\". More test cases needed so that the string s+reverse(s) will have p with length of p >= length of s (here p is the prefix of s + reverse(s), and also a suffix) \\n\\n\\n  [1]: https://leetcode.com/discuss/36987/python-solution-kmp"
                    },
                    {
                        "username": "nishant_suthar",
                        "content": "why this is giving TLE\n\n` class Solution {\n    public String shortestPalindrome(String s) {\n        String temp=s;\n        StringBuilder sb=new StringBuilder(s);\n\n        if(temp.equals(sb.reverse().toString())) return temp;\n\n        int i=0;\n        int j=s.length()-1;\n\n        while(j>0){\n            Character c=s.charAt(j);\n\n            temp=temp.substring(0,i)+c+temp.substring(i);\n\n            sb = new StringBuilder(temp); \n            if(temp.equals(sb.reverse().toString())){\n\n                return temp;\n            }\n            i++;\n            j--;\n\n        }\n        return \"\";\n    }\n}`\n"
                    }
                ]
            },
            {
                "id": 2007326,
                "content": [
                    {
                        "username": "b06902111",
                        "content": "Why getting TLE with this...? I tested, my code works with s = \"\" empty string. But what is this? Can anyone help?\n![Imgur](https://imgur.com/pcHddiZ.jpg)"
                    },
                    {
                        "username": "at218808",
                        "content": "check if you are passing string by reference or not, second O(n^2) will fail"
                    },
                    {
                        "username": "q23175401",
                        "content": "Has anyone fixed this issue?"
                    },
                    {
                        "username": "user6007Dd",
                        "content": "I have the same problem. I didnt have it at first but now I get it for every submit. "
                    },
                    {
                        "username": "Conrad_123",
                        "content": "I\\'m having the same issue. When I try to use this as a test case, it prompts me to make my own. Not sure how to go about fixing this. "
                    },
                    {
                        "username": "Kaynex",
                        "content": "Time limit exceeded means you\\'ve exceeed the time limit.\\nNeed to speed up your algorithm."
                    },
                    {
                        "username": "dkvg_77",
                        "content": "Please someone give solution for this"
                    },
                    {
                        "username": "monderpet",
                        "content": "Same issue."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please donate stars\\n\\n![image](https://assets.leetcode.com/users/images/f8fbdf0e-77f7-4f68-a4e0-29236d2931ef_1636547465.0409968.png)\\n\\n![image](https://assets.leetcode.com/users/images/691dee61-ffd3-48b8-a8d3-5adf743a0d97_1636547470.6172163.png)\\n"
                    },
                    {
                        "username": "Rithsek",
                        "content": "why s = \"aabba\"\\nExpected = \"abbaabba\" and not \"abbabba\"?"
                    },
                    {
                        "username": "Alpha_690163",
                        "content": "[@unarov](/unarov) \\nInput: s = \"abcd\"\\nOutput: \"dcbabcd\"\\nhere, a is not appended."
                    },
                    {
                        "username": "Prabhaaa111",
                        "content": "you have to append characters only in front of string without removing characters from original string."
                    },
                    {
                        "username": "unarov",
                        "content": "To make \"abbabba\" from \"aabba\" you should remove one \"a\". But it is not allowed. You can only add chars in front of given string"
                    },
                    {
                        "username": "aastha985",
                        "content": "**Idea:**\\nThe **brute force** solution would be to check all possible strings starting from index 0 and check if they form a palindrome. This would be O(n^2) and gives TLE.\\n\\n**Optimized Approach**(Using KMP Algorithm)\\n1. How KMP Algorithm works: KMP is a pattern matching algorithm, where we are given a pattern and we need to check if the prefix of the pattern exists in a string.\\n2. How are we using KMP here: The trick here is to concatenate the string with its reverse with a # character in between. Now we apply KMP to this string to get the length of string starting from 0 which is a palindrome.\\n3. We have 2 pointers one to match the pattern which starts from index = 0 and other which starts from i = 1 and an array table initialized to the length of the string in point 2.\\n4. If character at index matches the character at i, we set table[i] = table[i-1]+1 and increment the index.\\n5. Else we set index to table[i-1] and continue setting it to table[index-1] till index>0 and the character at index is not equal to character at i.\\n6. If the character at index is equal to character at i, increment the index.\\n7. Set table[i] to index.\\n8.  In the end, the value at table[table.length-1] will be the length of the palindromic substring starting from 0.\\n\\n[Code can be found here](https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation)\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:**  O(n)"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "Can we solve this problem using hashing"
                    },
                    {
                        "username": "Anonymous2389",
                        "content": "It is mentioned that the approach is accepted but i am geting TLE even when i copied that code to test it"
                    },
                    {
                        "username": "_Dinu",
                        "content": "I am getting a wrong answer with \"abb\" case.\\n\\nMy code has this output \"abba\"\\nExpected is \"bbabb\"\\n\\n\"abba\" is shorter than \"bbabb\"\\n"
                    },
                    {
                        "username": "literalEval",
                        "content": "\\'abba\\' nahi maan rahe"
                    },
                    {
                        "username": "SxreaM",
                        "content": "you have to add characters in front of string not at the end"
                    },
                    {
                        "username": "Weskarini",
                        "content": "Bruh finally got a solution but they have to add a 42000 char testcase for me to get Time Limit\\'d"
                    },
                    {
                        "username": "payal94",
                        "content": "Hello LeetCode,\\n\\npreviously everything was working fine, suddenly I am not able to executed code on leetcode. Status is coming pending. So, I tried to submit already accepted answer. Even, status for that too is coming PENDING. Can anyone help me with this ?"
                    },
                    {
                        "username": "davidtan1890",
                        "content": "I stumbled upon [this implementation here][1]. \\n\\nIt is interesting and accepted by leetcode as of 2015-06-05. However, it is wrong. For test case like \"aabba\", it outputs \"aabba\", however, the correct output should be \"abbaabba\". More test cases needed so that the string s+reverse(s) will have p with length of p >= length of s (here p is the prefix of s + reverse(s), and also a suffix) \\n\\n\\n  [1]: https://leetcode.com/discuss/36987/python-solution-kmp"
                    },
                    {
                        "username": "nishant_suthar",
                        "content": "why this is giving TLE\n\n` class Solution {\n    public String shortestPalindrome(String s) {\n        String temp=s;\n        StringBuilder sb=new StringBuilder(s);\n\n        if(temp.equals(sb.reverse().toString())) return temp;\n\n        int i=0;\n        int j=s.length()-1;\n\n        while(j>0){\n            Character c=s.charAt(j);\n\n            temp=temp.substring(0,i)+c+temp.substring(i);\n\n            sb = new StringBuilder(temp); \n            if(temp.equals(sb.reverse().toString())){\n\n                return temp;\n            }\n            i++;\n            j--;\n\n        }\n        return \"\";\n    }\n}`\n"
                    }
                ]
            },
            {
                "id": 1571440,
                "content": [
                    {
                        "username": "b06902111",
                        "content": "Why getting TLE with this...? I tested, my code works with s = \"\" empty string. But what is this? Can anyone help?\n![Imgur](https://imgur.com/pcHddiZ.jpg)"
                    },
                    {
                        "username": "at218808",
                        "content": "check if you are passing string by reference or not, second O(n^2) will fail"
                    },
                    {
                        "username": "q23175401",
                        "content": "Has anyone fixed this issue?"
                    },
                    {
                        "username": "user6007Dd",
                        "content": "I have the same problem. I didnt have it at first but now I get it for every submit. "
                    },
                    {
                        "username": "Conrad_123",
                        "content": "I\\'m having the same issue. When I try to use this as a test case, it prompts me to make my own. Not sure how to go about fixing this. "
                    },
                    {
                        "username": "Kaynex",
                        "content": "Time limit exceeded means you\\'ve exceeed the time limit.\\nNeed to speed up your algorithm."
                    },
                    {
                        "username": "dkvg_77",
                        "content": "Please someone give solution for this"
                    },
                    {
                        "username": "monderpet",
                        "content": "Same issue."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please donate stars\\n\\n![image](https://assets.leetcode.com/users/images/f8fbdf0e-77f7-4f68-a4e0-29236d2931ef_1636547465.0409968.png)\\n\\n![image](https://assets.leetcode.com/users/images/691dee61-ffd3-48b8-a8d3-5adf743a0d97_1636547470.6172163.png)\\n"
                    },
                    {
                        "username": "Rithsek",
                        "content": "why s = \"aabba\"\\nExpected = \"abbaabba\" and not \"abbabba\"?"
                    },
                    {
                        "username": "Alpha_690163",
                        "content": "[@unarov](/unarov) \\nInput: s = \"abcd\"\\nOutput: \"dcbabcd\"\\nhere, a is not appended."
                    },
                    {
                        "username": "Prabhaaa111",
                        "content": "you have to append characters only in front of string without removing characters from original string."
                    },
                    {
                        "username": "unarov",
                        "content": "To make \"abbabba\" from \"aabba\" you should remove one \"a\". But it is not allowed. You can only add chars in front of given string"
                    },
                    {
                        "username": "aastha985",
                        "content": "**Idea:**\\nThe **brute force** solution would be to check all possible strings starting from index 0 and check if they form a palindrome. This would be O(n^2) and gives TLE.\\n\\n**Optimized Approach**(Using KMP Algorithm)\\n1. How KMP Algorithm works: KMP is a pattern matching algorithm, where we are given a pattern and we need to check if the prefix of the pattern exists in a string.\\n2. How are we using KMP here: The trick here is to concatenate the string with its reverse with a # character in between. Now we apply KMP to this string to get the length of string starting from 0 which is a palindrome.\\n3. We have 2 pointers one to match the pattern which starts from index = 0 and other which starts from i = 1 and an array table initialized to the length of the string in point 2.\\n4. If character at index matches the character at i, we set table[i] = table[i-1]+1 and increment the index.\\n5. Else we set index to table[i-1] and continue setting it to table[index-1] till index>0 and the character at index is not equal to character at i.\\n6. If the character at index is equal to character at i, increment the index.\\n7. Set table[i] to index.\\n8.  In the end, the value at table[table.length-1] will be the length of the palindromic substring starting from 0.\\n\\n[Code can be found here](https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation)\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:**  O(n)"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "Can we solve this problem using hashing"
                    },
                    {
                        "username": "Anonymous2389",
                        "content": "It is mentioned that the approach is accepted but i am geting TLE even when i copied that code to test it"
                    },
                    {
                        "username": "_Dinu",
                        "content": "I am getting a wrong answer with \"abb\" case.\\n\\nMy code has this output \"abba\"\\nExpected is \"bbabb\"\\n\\n\"abba\" is shorter than \"bbabb\"\\n"
                    },
                    {
                        "username": "literalEval",
                        "content": "\\'abba\\' nahi maan rahe"
                    },
                    {
                        "username": "SxreaM",
                        "content": "you have to add characters in front of string not at the end"
                    },
                    {
                        "username": "Weskarini",
                        "content": "Bruh finally got a solution but they have to add a 42000 char testcase for me to get Time Limit\\'d"
                    },
                    {
                        "username": "payal94",
                        "content": "Hello LeetCode,\\n\\npreviously everything was working fine, suddenly I am not able to executed code on leetcode. Status is coming pending. So, I tried to submit already accepted answer. Even, status for that too is coming PENDING. Can anyone help me with this ?"
                    },
                    {
                        "username": "davidtan1890",
                        "content": "I stumbled upon [this implementation here][1]. \\n\\nIt is interesting and accepted by leetcode as of 2015-06-05. However, it is wrong. For test case like \"aabba\", it outputs \"aabba\", however, the correct output should be \"abbaabba\". More test cases needed so that the string s+reverse(s) will have p with length of p >= length of s (here p is the prefix of s + reverse(s), and also a suffix) \\n\\n\\n  [1]: https://leetcode.com/discuss/36987/python-solution-kmp"
                    },
                    {
                        "username": "nishant_suthar",
                        "content": "why this is giving TLE\n\n` class Solution {\n    public String shortestPalindrome(String s) {\n        String temp=s;\n        StringBuilder sb=new StringBuilder(s);\n\n        if(temp.equals(sb.reverse().toString())) return temp;\n\n        int i=0;\n        int j=s.length()-1;\n\n        while(j>0){\n            Character c=s.charAt(j);\n\n            temp=temp.substring(0,i)+c+temp.substring(i);\n\n            sb = new StringBuilder(temp); \n            if(temp.equals(sb.reverse().toString())){\n\n                return temp;\n            }\n            i++;\n            j--;\n\n        }\n        return \"\";\n    }\n}`\n"
                    }
                ]
            },
            {
                "id": 1571442,
                "content": [
                    {
                        "username": "b06902111",
                        "content": "Why getting TLE with this...? I tested, my code works with s = \"\" empty string. But what is this? Can anyone help?\n![Imgur](https://imgur.com/pcHddiZ.jpg)"
                    },
                    {
                        "username": "at218808",
                        "content": "check if you are passing string by reference or not, second O(n^2) will fail"
                    },
                    {
                        "username": "q23175401",
                        "content": "Has anyone fixed this issue?"
                    },
                    {
                        "username": "user6007Dd",
                        "content": "I have the same problem. I didnt have it at first but now I get it for every submit. "
                    },
                    {
                        "username": "Conrad_123",
                        "content": "I\\'m having the same issue. When I try to use this as a test case, it prompts me to make my own. Not sure how to go about fixing this. "
                    },
                    {
                        "username": "Kaynex",
                        "content": "Time limit exceeded means you\\'ve exceeed the time limit.\\nNeed to speed up your algorithm."
                    },
                    {
                        "username": "dkvg_77",
                        "content": "Please someone give solution for this"
                    },
                    {
                        "username": "monderpet",
                        "content": "Same issue."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please donate stars\\n\\n![image](https://assets.leetcode.com/users/images/f8fbdf0e-77f7-4f68-a4e0-29236d2931ef_1636547465.0409968.png)\\n\\n![image](https://assets.leetcode.com/users/images/691dee61-ffd3-48b8-a8d3-5adf743a0d97_1636547470.6172163.png)\\n"
                    },
                    {
                        "username": "Rithsek",
                        "content": "why s = \"aabba\"\\nExpected = \"abbaabba\" and not \"abbabba\"?"
                    },
                    {
                        "username": "Alpha_690163",
                        "content": "[@unarov](/unarov) \\nInput: s = \"abcd\"\\nOutput: \"dcbabcd\"\\nhere, a is not appended."
                    },
                    {
                        "username": "Prabhaaa111",
                        "content": "you have to append characters only in front of string without removing characters from original string."
                    },
                    {
                        "username": "unarov",
                        "content": "To make \"abbabba\" from \"aabba\" you should remove one \"a\". But it is not allowed. You can only add chars in front of given string"
                    },
                    {
                        "username": "aastha985",
                        "content": "**Idea:**\\nThe **brute force** solution would be to check all possible strings starting from index 0 and check if they form a palindrome. This would be O(n^2) and gives TLE.\\n\\n**Optimized Approach**(Using KMP Algorithm)\\n1. How KMP Algorithm works: KMP is a pattern matching algorithm, where we are given a pattern and we need to check if the prefix of the pattern exists in a string.\\n2. How are we using KMP here: The trick here is to concatenate the string with its reverse with a # character in between. Now we apply KMP to this string to get the length of string starting from 0 which is a palindrome.\\n3. We have 2 pointers one to match the pattern which starts from index = 0 and other which starts from i = 1 and an array table initialized to the length of the string in point 2.\\n4. If character at index matches the character at i, we set table[i] = table[i-1]+1 and increment the index.\\n5. Else we set index to table[i-1] and continue setting it to table[index-1] till index>0 and the character at index is not equal to character at i.\\n6. If the character at index is equal to character at i, increment the index.\\n7. Set table[i] to index.\\n8.  In the end, the value at table[table.length-1] will be the length of the palindromic substring starting from 0.\\n\\n[Code can be found here](https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation)\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:**  O(n)"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "Can we solve this problem using hashing"
                    },
                    {
                        "username": "Anonymous2389",
                        "content": "It is mentioned that the approach is accepted but i am geting TLE even when i copied that code to test it"
                    },
                    {
                        "username": "_Dinu",
                        "content": "I am getting a wrong answer with \"abb\" case.\\n\\nMy code has this output \"abba\"\\nExpected is \"bbabb\"\\n\\n\"abba\" is shorter than \"bbabb\"\\n"
                    },
                    {
                        "username": "literalEval",
                        "content": "\\'abba\\' nahi maan rahe"
                    },
                    {
                        "username": "SxreaM",
                        "content": "you have to add characters in front of string not at the end"
                    },
                    {
                        "username": "Weskarini",
                        "content": "Bruh finally got a solution but they have to add a 42000 char testcase for me to get Time Limit\\'d"
                    },
                    {
                        "username": "payal94",
                        "content": "Hello LeetCode,\\n\\npreviously everything was working fine, suddenly I am not able to executed code on leetcode. Status is coming pending. So, I tried to submit already accepted answer. Even, status for that too is coming PENDING. Can anyone help me with this ?"
                    },
                    {
                        "username": "davidtan1890",
                        "content": "I stumbled upon [this implementation here][1]. \\n\\nIt is interesting and accepted by leetcode as of 2015-06-05. However, it is wrong. For test case like \"aabba\", it outputs \"aabba\", however, the correct output should be \"abbaabba\". More test cases needed so that the string s+reverse(s) will have p with length of p >= length of s (here p is the prefix of s + reverse(s), and also a suffix) \\n\\n\\n  [1]: https://leetcode.com/discuss/36987/python-solution-kmp"
                    },
                    {
                        "username": "nishant_suthar",
                        "content": "why this is giving TLE\n\n` class Solution {\n    public String shortestPalindrome(String s) {\n        String temp=s;\n        StringBuilder sb=new StringBuilder(s);\n\n        if(temp.equals(sb.reverse().toString())) return temp;\n\n        int i=0;\n        int j=s.length()-1;\n\n        while(j>0){\n            Character c=s.charAt(j);\n\n            temp=temp.substring(0,i)+c+temp.substring(i);\n\n            sb = new StringBuilder(temp); \n            if(temp.equals(sb.reverse().toString())){\n\n                return temp;\n            }\n            i++;\n            j--;\n\n        }\n        return \"\";\n    }\n}`\n"
                    }
                ]
            },
            {
                "id": 2071002,
                "content": [
                    {
                        "username": "b06902111",
                        "content": "Why getting TLE with this...? I tested, my code works with s = \"\" empty string. But what is this? Can anyone help?\n![Imgur](https://imgur.com/pcHddiZ.jpg)"
                    },
                    {
                        "username": "at218808",
                        "content": "check if you are passing string by reference or not, second O(n^2) will fail"
                    },
                    {
                        "username": "q23175401",
                        "content": "Has anyone fixed this issue?"
                    },
                    {
                        "username": "user6007Dd",
                        "content": "I have the same problem. I didnt have it at first but now I get it for every submit. "
                    },
                    {
                        "username": "Conrad_123",
                        "content": "I\\'m having the same issue. When I try to use this as a test case, it prompts me to make my own. Not sure how to go about fixing this. "
                    },
                    {
                        "username": "Kaynex",
                        "content": "Time limit exceeded means you\\'ve exceeed the time limit.\\nNeed to speed up your algorithm."
                    },
                    {
                        "username": "dkvg_77",
                        "content": "Please someone give solution for this"
                    },
                    {
                        "username": "monderpet",
                        "content": "Same issue."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please donate stars\\n\\n![image](https://assets.leetcode.com/users/images/f8fbdf0e-77f7-4f68-a4e0-29236d2931ef_1636547465.0409968.png)\\n\\n![image](https://assets.leetcode.com/users/images/691dee61-ffd3-48b8-a8d3-5adf743a0d97_1636547470.6172163.png)\\n"
                    },
                    {
                        "username": "Rithsek",
                        "content": "why s = \"aabba\"\\nExpected = \"abbaabba\" and not \"abbabba\"?"
                    },
                    {
                        "username": "Alpha_690163",
                        "content": "[@unarov](/unarov) \\nInput: s = \"abcd\"\\nOutput: \"dcbabcd\"\\nhere, a is not appended."
                    },
                    {
                        "username": "Prabhaaa111",
                        "content": "you have to append characters only in front of string without removing characters from original string."
                    },
                    {
                        "username": "unarov",
                        "content": "To make \"abbabba\" from \"aabba\" you should remove one \"a\". But it is not allowed. You can only add chars in front of given string"
                    },
                    {
                        "username": "aastha985",
                        "content": "**Idea:**\\nThe **brute force** solution would be to check all possible strings starting from index 0 and check if they form a palindrome. This would be O(n^2) and gives TLE.\\n\\n**Optimized Approach**(Using KMP Algorithm)\\n1. How KMP Algorithm works: KMP is a pattern matching algorithm, where we are given a pattern and we need to check if the prefix of the pattern exists in a string.\\n2. How are we using KMP here: The trick here is to concatenate the string with its reverse with a # character in between. Now we apply KMP to this string to get the length of string starting from 0 which is a palindrome.\\n3. We have 2 pointers one to match the pattern which starts from index = 0 and other which starts from i = 1 and an array table initialized to the length of the string in point 2.\\n4. If character at index matches the character at i, we set table[i] = table[i-1]+1 and increment the index.\\n5. Else we set index to table[i-1] and continue setting it to table[index-1] till index>0 and the character at index is not equal to character at i.\\n6. If the character at index is equal to character at i, increment the index.\\n7. Set table[i] to index.\\n8.  In the end, the value at table[table.length-1] will be the length of the palindromic substring starting from 0.\\n\\n[Code can be found here](https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation)\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:**  O(n)"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "Can we solve this problem using hashing"
                    },
                    {
                        "username": "Anonymous2389",
                        "content": "It is mentioned that the approach is accepted but i am geting TLE even when i copied that code to test it"
                    },
                    {
                        "username": "_Dinu",
                        "content": "I am getting a wrong answer with \"abb\" case.\\n\\nMy code has this output \"abba\"\\nExpected is \"bbabb\"\\n\\n\"abba\" is shorter than \"bbabb\"\\n"
                    },
                    {
                        "username": "literalEval",
                        "content": "\\'abba\\' nahi maan rahe"
                    },
                    {
                        "username": "SxreaM",
                        "content": "you have to add characters in front of string not at the end"
                    },
                    {
                        "username": "Weskarini",
                        "content": "Bruh finally got a solution but they have to add a 42000 char testcase for me to get Time Limit\\'d"
                    },
                    {
                        "username": "payal94",
                        "content": "Hello LeetCode,\\n\\npreviously everything was working fine, suddenly I am not able to executed code on leetcode. Status is coming pending. So, I tried to submit already accepted answer. Even, status for that too is coming PENDING. Can anyone help me with this ?"
                    },
                    {
                        "username": "davidtan1890",
                        "content": "I stumbled upon [this implementation here][1]. \\n\\nIt is interesting and accepted by leetcode as of 2015-06-05. However, it is wrong. For test case like \"aabba\", it outputs \"aabba\", however, the correct output should be \"abbaabba\". More test cases needed so that the string s+reverse(s) will have p with length of p >= length of s (here p is the prefix of s + reverse(s), and also a suffix) \\n\\n\\n  [1]: https://leetcode.com/discuss/36987/python-solution-kmp"
                    },
                    {
                        "username": "nishant_suthar",
                        "content": "why this is giving TLE\n\n` class Solution {\n    public String shortestPalindrome(String s) {\n        String temp=s;\n        StringBuilder sb=new StringBuilder(s);\n\n        if(temp.equals(sb.reverse().toString())) return temp;\n\n        int i=0;\n        int j=s.length()-1;\n\n        while(j>0){\n            Character c=s.charAt(j);\n\n            temp=temp.substring(0,i)+c+temp.substring(i);\n\n            sb = new StringBuilder(temp); \n            if(temp.equals(sb.reverse().toString())){\n\n                return temp;\n            }\n            i++;\n            j--;\n\n        }\n        return \"\";\n    }\n}`\n"
                    }
                ]
            },
            {
                "id": 2052163,
                "content": [
                    {
                        "username": "infinityboy",
                        "content": "s =\\n\"aabba\"\\nStdout\\nabba\\nOutput\\n\"abbabba\"\\nExpected\\n\"abbaabba\"\\n\\nwhy my ans is wrong i have given minimum operation"
                    },
                    {
                        "username": "MTS99",
                        "content": "Output\\n\"abbabba\"\\n\\nyour output is wrong\\n"
                    },
                    {
                        "username": "LivingHell",
                        "content": "Can anyone help me? Why am I facing this issue? \\n\\nhttps://shorturl.at/aosNX\\n\\nThe expected output and my output are both the same, but I am still getting the wrong answer!"
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1> Its over an hour and still not able to find the solution ahhhhhh!!!! \\uD83E\\uDDE0 \\uD83C\\uDF7D\\uFE0F \\uD83E\\uDDE0</h1>"
                    },
                    {
                        "username": "aditya273001",
                        "content": "In the case of input \"aabba\"\\n\\nthe output should be \"abbabba\"\\n\\nnot \"abbaabba\""
                    },
                    {
                        "username": "aditya273001",
                        "content": "[@at218808](/at218808) I inserted b at index 1, the existing a shifted to 2nd index"
                    },
                    {
                        "username": "at218808",
                        "content": "you deleted first \\'a\\' from \\'aabba\\' , answer is \\'abbaabba\\'"
                    },
                    {
                        "username": "riturajpaul18",
                        "content": "For the following test case:\\ns=\"aabba\"\\n\\nMy output is: \"abbabba\"\\nAnd the expected output is: \"abbaabba\"\\n\\nMy output\\'s length is shorter than the expected output length\\nSo, why am I getting Wrong Answer?"
                    },
                    {
                        "username": "shubhra_riki",
                        "content": "because u need to insert at the first in each iteration"
                    },
                    {
                        "username": "NamanVer02",
                        "content": "Why ? :\\'(\\n\\n![image](https://i.ibb.co/wpHCrBG/Screenshot-179.png)\\n\\nMy solution is O(n^2) but slightly optimized.\\n```\\nclass Solution {\\npublic:\\n    int checkPalindrome(string s, int start, int end){\\n        while(start < end){\\n            if(s[start] != s[end]) return 0;\\n            start++;\\n            end--;\\n        }\\n        return 1;\\n    }\\n\\n    string shortestPalindrome(string s) {\\n        string maxS = \"\";\\n        for(int i = s.length(); i >= 0; i--){\\n            if(checkPalindrome(s, 0, i)){\\n                maxS = s.substr(0, i+1);\\n                break;\\n            }\\n        }\\n\\n        cout << maxS;\\n\\n        string toAdd = s.substr(maxS.length(), s.length());\\n        reverse(toAdd.begin(), toAdd.end());\\n\\n        return toAdd + s;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "m-ymn",
                        "content": "i\\'m getting TLE on the last testcase \"aaaaaaaa\", how to deal with it, i\\'m just checking that using the simple palindrome function but still it is giving TLE"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Tip: If you are stubborn like me and trying to find a solution, thinking to yourself \"surely they didn't make a problem that is supposed to be solved only via KMP, that would be silly\", well think again. They did.\nIf you're feeling lazy to implement KMP today, you can cheese the only constraining test case because they built it using a single repeated characters instead of using periodic patterns. you can work out a simpler implementation that deals with the case where you have a buttload of \"a\".\nOf course not a viable interview solution, but I don't think you will commonly find interviewers actually expecting you to implement a custom KMP in an interview"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "definitely not so easy to digest the solution ."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "string a=s;\\n        reverse(a.begin(),a.end());\\n        int ans=0;\\n        int n=s.length();\\n        for(int i=n-1;i>=0;i--){\\n            if(a.substr(n-i-1)==s.substr(0,i+1)){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        if(ans+1==n){return s;}\\n        a=a.substr(0,n-ans-1)+s;\\n        return a;\\n\\ncan anyone tell ,how it can optimize even i am using longest pallin with prefix suffix concept"
                    }
                ]
            },
            {
                "id": 2039545,
                "content": [
                    {
                        "username": "infinityboy",
                        "content": "s =\\n\"aabba\"\\nStdout\\nabba\\nOutput\\n\"abbabba\"\\nExpected\\n\"abbaabba\"\\n\\nwhy my ans is wrong i have given minimum operation"
                    },
                    {
                        "username": "MTS99",
                        "content": "Output\\n\"abbabba\"\\n\\nyour output is wrong\\n"
                    },
                    {
                        "username": "LivingHell",
                        "content": "Can anyone help me? Why am I facing this issue? \\n\\nhttps://shorturl.at/aosNX\\n\\nThe expected output and my output are both the same, but I am still getting the wrong answer!"
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1> Its over an hour and still not able to find the solution ahhhhhh!!!! \\uD83E\\uDDE0 \\uD83C\\uDF7D\\uFE0F \\uD83E\\uDDE0</h1>"
                    },
                    {
                        "username": "aditya273001",
                        "content": "In the case of input \"aabba\"\\n\\nthe output should be \"abbabba\"\\n\\nnot \"abbaabba\""
                    },
                    {
                        "username": "aditya273001",
                        "content": "[@at218808](/at218808) I inserted b at index 1, the existing a shifted to 2nd index"
                    },
                    {
                        "username": "at218808",
                        "content": "you deleted first \\'a\\' from \\'aabba\\' , answer is \\'abbaabba\\'"
                    },
                    {
                        "username": "riturajpaul18",
                        "content": "For the following test case:\\ns=\"aabba\"\\n\\nMy output is: \"abbabba\"\\nAnd the expected output is: \"abbaabba\"\\n\\nMy output\\'s length is shorter than the expected output length\\nSo, why am I getting Wrong Answer?"
                    },
                    {
                        "username": "shubhra_riki",
                        "content": "because u need to insert at the first in each iteration"
                    },
                    {
                        "username": "NamanVer02",
                        "content": "Why ? :\\'(\\n\\n![image](https://i.ibb.co/wpHCrBG/Screenshot-179.png)\\n\\nMy solution is O(n^2) but slightly optimized.\\n```\\nclass Solution {\\npublic:\\n    int checkPalindrome(string s, int start, int end){\\n        while(start < end){\\n            if(s[start] != s[end]) return 0;\\n            start++;\\n            end--;\\n        }\\n        return 1;\\n    }\\n\\n    string shortestPalindrome(string s) {\\n        string maxS = \"\";\\n        for(int i = s.length(); i >= 0; i--){\\n            if(checkPalindrome(s, 0, i)){\\n                maxS = s.substr(0, i+1);\\n                break;\\n            }\\n        }\\n\\n        cout << maxS;\\n\\n        string toAdd = s.substr(maxS.length(), s.length());\\n        reverse(toAdd.begin(), toAdd.end());\\n\\n        return toAdd + s;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "m-ymn",
                        "content": "i\\'m getting TLE on the last testcase \"aaaaaaaa\", how to deal with it, i\\'m just checking that using the simple palindrome function but still it is giving TLE"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Tip: If you are stubborn like me and trying to find a solution, thinking to yourself \"surely they didn't make a problem that is supposed to be solved only via KMP, that would be silly\", well think again. They did.\nIf you're feeling lazy to implement KMP today, you can cheese the only constraining test case because they built it using a single repeated characters instead of using periodic patterns. you can work out a simpler implementation that deals with the case where you have a buttload of \"a\".\nOf course not a viable interview solution, but I don't think you will commonly find interviewers actually expecting you to implement a custom KMP in an interview"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "definitely not so easy to digest the solution ."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "string a=s;\\n        reverse(a.begin(),a.end());\\n        int ans=0;\\n        int n=s.length();\\n        for(int i=n-1;i>=0;i--){\\n            if(a.substr(n-i-1)==s.substr(0,i+1)){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        if(ans+1==n){return s;}\\n        a=a.substr(0,n-ans-1)+s;\\n        return a;\\n\\ncan anyone tell ,how it can optimize even i am using longest pallin with prefix suffix concept"
                    }
                ]
            },
            {
                "id": 2031738,
                "content": [
                    {
                        "username": "infinityboy",
                        "content": "s =\\n\"aabba\"\\nStdout\\nabba\\nOutput\\n\"abbabba\"\\nExpected\\n\"abbaabba\"\\n\\nwhy my ans is wrong i have given minimum operation"
                    },
                    {
                        "username": "MTS99",
                        "content": "Output\\n\"abbabba\"\\n\\nyour output is wrong\\n"
                    },
                    {
                        "username": "LivingHell",
                        "content": "Can anyone help me? Why am I facing this issue? \\n\\nhttps://shorturl.at/aosNX\\n\\nThe expected output and my output are both the same, but I am still getting the wrong answer!"
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1> Its over an hour and still not able to find the solution ahhhhhh!!!! \\uD83E\\uDDE0 \\uD83C\\uDF7D\\uFE0F \\uD83E\\uDDE0</h1>"
                    },
                    {
                        "username": "aditya273001",
                        "content": "In the case of input \"aabba\"\\n\\nthe output should be \"abbabba\"\\n\\nnot \"abbaabba\""
                    },
                    {
                        "username": "aditya273001",
                        "content": "[@at218808](/at218808) I inserted b at index 1, the existing a shifted to 2nd index"
                    },
                    {
                        "username": "at218808",
                        "content": "you deleted first \\'a\\' from \\'aabba\\' , answer is \\'abbaabba\\'"
                    },
                    {
                        "username": "riturajpaul18",
                        "content": "For the following test case:\\ns=\"aabba\"\\n\\nMy output is: \"abbabba\"\\nAnd the expected output is: \"abbaabba\"\\n\\nMy output\\'s length is shorter than the expected output length\\nSo, why am I getting Wrong Answer?"
                    },
                    {
                        "username": "shubhra_riki",
                        "content": "because u need to insert at the first in each iteration"
                    },
                    {
                        "username": "NamanVer02",
                        "content": "Why ? :\\'(\\n\\n![image](https://i.ibb.co/wpHCrBG/Screenshot-179.png)\\n\\nMy solution is O(n^2) but slightly optimized.\\n```\\nclass Solution {\\npublic:\\n    int checkPalindrome(string s, int start, int end){\\n        while(start < end){\\n            if(s[start] != s[end]) return 0;\\n            start++;\\n            end--;\\n        }\\n        return 1;\\n    }\\n\\n    string shortestPalindrome(string s) {\\n        string maxS = \"\";\\n        for(int i = s.length(); i >= 0; i--){\\n            if(checkPalindrome(s, 0, i)){\\n                maxS = s.substr(0, i+1);\\n                break;\\n            }\\n        }\\n\\n        cout << maxS;\\n\\n        string toAdd = s.substr(maxS.length(), s.length());\\n        reverse(toAdd.begin(), toAdd.end());\\n\\n        return toAdd + s;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "m-ymn",
                        "content": "i\\'m getting TLE on the last testcase \"aaaaaaaa\", how to deal with it, i\\'m just checking that using the simple palindrome function but still it is giving TLE"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Tip: If you are stubborn like me and trying to find a solution, thinking to yourself \"surely they didn't make a problem that is supposed to be solved only via KMP, that would be silly\", well think again. They did.\nIf you're feeling lazy to implement KMP today, you can cheese the only constraining test case because they built it using a single repeated characters instead of using periodic patterns. you can work out a simpler implementation that deals with the case where you have a buttload of \"a\".\nOf course not a viable interview solution, but I don't think you will commonly find interviewers actually expecting you to implement a custom KMP in an interview"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "definitely not so easy to digest the solution ."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "string a=s;\\n        reverse(a.begin(),a.end());\\n        int ans=0;\\n        int n=s.length();\\n        for(int i=n-1;i>=0;i--){\\n            if(a.substr(n-i-1)==s.substr(0,i+1)){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        if(ans+1==n){return s;}\\n        a=a.substr(0,n-ans-1)+s;\\n        return a;\\n\\ncan anyone tell ,how it can optimize even i am using longest pallin with prefix suffix concept"
                    }
                ]
            },
            {
                "id": 2017887,
                "content": [
                    {
                        "username": "infinityboy",
                        "content": "s =\\n\"aabba\"\\nStdout\\nabba\\nOutput\\n\"abbabba\"\\nExpected\\n\"abbaabba\"\\n\\nwhy my ans is wrong i have given minimum operation"
                    },
                    {
                        "username": "MTS99",
                        "content": "Output\\n\"abbabba\"\\n\\nyour output is wrong\\n"
                    },
                    {
                        "username": "LivingHell",
                        "content": "Can anyone help me? Why am I facing this issue? \\n\\nhttps://shorturl.at/aosNX\\n\\nThe expected output and my output are both the same, but I am still getting the wrong answer!"
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1> Its over an hour and still not able to find the solution ahhhhhh!!!! \\uD83E\\uDDE0 \\uD83C\\uDF7D\\uFE0F \\uD83E\\uDDE0</h1>"
                    },
                    {
                        "username": "aditya273001",
                        "content": "In the case of input \"aabba\"\\n\\nthe output should be \"abbabba\"\\n\\nnot \"abbaabba\""
                    },
                    {
                        "username": "aditya273001",
                        "content": "[@at218808](/at218808) I inserted b at index 1, the existing a shifted to 2nd index"
                    },
                    {
                        "username": "at218808",
                        "content": "you deleted first \\'a\\' from \\'aabba\\' , answer is \\'abbaabba\\'"
                    },
                    {
                        "username": "riturajpaul18",
                        "content": "For the following test case:\\ns=\"aabba\"\\n\\nMy output is: \"abbabba\"\\nAnd the expected output is: \"abbaabba\"\\n\\nMy output\\'s length is shorter than the expected output length\\nSo, why am I getting Wrong Answer?"
                    },
                    {
                        "username": "shubhra_riki",
                        "content": "because u need to insert at the first in each iteration"
                    },
                    {
                        "username": "NamanVer02",
                        "content": "Why ? :\\'(\\n\\n![image](https://i.ibb.co/wpHCrBG/Screenshot-179.png)\\n\\nMy solution is O(n^2) but slightly optimized.\\n```\\nclass Solution {\\npublic:\\n    int checkPalindrome(string s, int start, int end){\\n        while(start < end){\\n            if(s[start] != s[end]) return 0;\\n            start++;\\n            end--;\\n        }\\n        return 1;\\n    }\\n\\n    string shortestPalindrome(string s) {\\n        string maxS = \"\";\\n        for(int i = s.length(); i >= 0; i--){\\n            if(checkPalindrome(s, 0, i)){\\n                maxS = s.substr(0, i+1);\\n                break;\\n            }\\n        }\\n\\n        cout << maxS;\\n\\n        string toAdd = s.substr(maxS.length(), s.length());\\n        reverse(toAdd.begin(), toAdd.end());\\n\\n        return toAdd + s;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "m-ymn",
                        "content": "i\\'m getting TLE on the last testcase \"aaaaaaaa\", how to deal with it, i\\'m just checking that using the simple palindrome function but still it is giving TLE"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Tip: If you are stubborn like me and trying to find a solution, thinking to yourself \"surely they didn't make a problem that is supposed to be solved only via KMP, that would be silly\", well think again. They did.\nIf you're feeling lazy to implement KMP today, you can cheese the only constraining test case because they built it using a single repeated characters instead of using periodic patterns. you can work out a simpler implementation that deals with the case where you have a buttload of \"a\".\nOf course not a viable interview solution, but I don't think you will commonly find interviewers actually expecting you to implement a custom KMP in an interview"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "definitely not so easy to digest the solution ."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "string a=s;\\n        reverse(a.begin(),a.end());\\n        int ans=0;\\n        int n=s.length();\\n        for(int i=n-1;i>=0;i--){\\n            if(a.substr(n-i-1)==s.substr(0,i+1)){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        if(ans+1==n){return s;}\\n        a=a.substr(0,n-ans-1)+s;\\n        return a;\\n\\ncan anyone tell ,how it can optimize even i am using longest pallin with prefix suffix concept"
                    }
                ]
            },
            {
                "id": 1998930,
                "content": [
                    {
                        "username": "infinityboy",
                        "content": "s =\\n\"aabba\"\\nStdout\\nabba\\nOutput\\n\"abbabba\"\\nExpected\\n\"abbaabba\"\\n\\nwhy my ans is wrong i have given minimum operation"
                    },
                    {
                        "username": "MTS99",
                        "content": "Output\\n\"abbabba\"\\n\\nyour output is wrong\\n"
                    },
                    {
                        "username": "LivingHell",
                        "content": "Can anyone help me? Why am I facing this issue? \\n\\nhttps://shorturl.at/aosNX\\n\\nThe expected output and my output are both the same, but I am still getting the wrong answer!"
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1> Its over an hour and still not able to find the solution ahhhhhh!!!! \\uD83E\\uDDE0 \\uD83C\\uDF7D\\uFE0F \\uD83E\\uDDE0</h1>"
                    },
                    {
                        "username": "aditya273001",
                        "content": "In the case of input \"aabba\"\\n\\nthe output should be \"abbabba\"\\n\\nnot \"abbaabba\""
                    },
                    {
                        "username": "aditya273001",
                        "content": "[@at218808](/at218808) I inserted b at index 1, the existing a shifted to 2nd index"
                    },
                    {
                        "username": "at218808",
                        "content": "you deleted first \\'a\\' from \\'aabba\\' , answer is \\'abbaabba\\'"
                    },
                    {
                        "username": "riturajpaul18",
                        "content": "For the following test case:\\ns=\"aabba\"\\n\\nMy output is: \"abbabba\"\\nAnd the expected output is: \"abbaabba\"\\n\\nMy output\\'s length is shorter than the expected output length\\nSo, why am I getting Wrong Answer?"
                    },
                    {
                        "username": "shubhra_riki",
                        "content": "because u need to insert at the first in each iteration"
                    },
                    {
                        "username": "NamanVer02",
                        "content": "Why ? :\\'(\\n\\n![image](https://i.ibb.co/wpHCrBG/Screenshot-179.png)\\n\\nMy solution is O(n^2) but slightly optimized.\\n```\\nclass Solution {\\npublic:\\n    int checkPalindrome(string s, int start, int end){\\n        while(start < end){\\n            if(s[start] != s[end]) return 0;\\n            start++;\\n            end--;\\n        }\\n        return 1;\\n    }\\n\\n    string shortestPalindrome(string s) {\\n        string maxS = \"\";\\n        for(int i = s.length(); i >= 0; i--){\\n            if(checkPalindrome(s, 0, i)){\\n                maxS = s.substr(0, i+1);\\n                break;\\n            }\\n        }\\n\\n        cout << maxS;\\n\\n        string toAdd = s.substr(maxS.length(), s.length());\\n        reverse(toAdd.begin(), toAdd.end());\\n\\n        return toAdd + s;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "m-ymn",
                        "content": "i\\'m getting TLE on the last testcase \"aaaaaaaa\", how to deal with it, i\\'m just checking that using the simple palindrome function but still it is giving TLE"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Tip: If you are stubborn like me and trying to find a solution, thinking to yourself \"surely they didn't make a problem that is supposed to be solved only via KMP, that would be silly\", well think again. They did.\nIf you're feeling lazy to implement KMP today, you can cheese the only constraining test case because they built it using a single repeated characters instead of using periodic patterns. you can work out a simpler implementation that deals with the case where you have a buttload of \"a\".\nOf course not a viable interview solution, but I don't think you will commonly find interviewers actually expecting you to implement a custom KMP in an interview"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "definitely not so easy to digest the solution ."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "string a=s;\\n        reverse(a.begin(),a.end());\\n        int ans=0;\\n        int n=s.length();\\n        for(int i=n-1;i>=0;i--){\\n            if(a.substr(n-i-1)==s.substr(0,i+1)){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        if(ans+1==n){return s;}\\n        a=a.substr(0,n-ans-1)+s;\\n        return a;\\n\\ncan anyone tell ,how it can optimize even i am using longest pallin with prefix suffix concept"
                    }
                ]
            },
            {
                "id": 1965821,
                "content": [
                    {
                        "username": "infinityboy",
                        "content": "s =\\n\"aabba\"\\nStdout\\nabba\\nOutput\\n\"abbabba\"\\nExpected\\n\"abbaabba\"\\n\\nwhy my ans is wrong i have given minimum operation"
                    },
                    {
                        "username": "MTS99",
                        "content": "Output\\n\"abbabba\"\\n\\nyour output is wrong\\n"
                    },
                    {
                        "username": "LivingHell",
                        "content": "Can anyone help me? Why am I facing this issue? \\n\\nhttps://shorturl.at/aosNX\\n\\nThe expected output and my output are both the same, but I am still getting the wrong answer!"
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1> Its over an hour and still not able to find the solution ahhhhhh!!!! \\uD83E\\uDDE0 \\uD83C\\uDF7D\\uFE0F \\uD83E\\uDDE0</h1>"
                    },
                    {
                        "username": "aditya273001",
                        "content": "In the case of input \"aabba\"\\n\\nthe output should be \"abbabba\"\\n\\nnot \"abbaabba\""
                    },
                    {
                        "username": "aditya273001",
                        "content": "[@at218808](/at218808) I inserted b at index 1, the existing a shifted to 2nd index"
                    },
                    {
                        "username": "at218808",
                        "content": "you deleted first \\'a\\' from \\'aabba\\' , answer is \\'abbaabba\\'"
                    },
                    {
                        "username": "riturajpaul18",
                        "content": "For the following test case:\\ns=\"aabba\"\\n\\nMy output is: \"abbabba\"\\nAnd the expected output is: \"abbaabba\"\\n\\nMy output\\'s length is shorter than the expected output length\\nSo, why am I getting Wrong Answer?"
                    },
                    {
                        "username": "shubhra_riki",
                        "content": "because u need to insert at the first in each iteration"
                    },
                    {
                        "username": "NamanVer02",
                        "content": "Why ? :\\'(\\n\\n![image](https://i.ibb.co/wpHCrBG/Screenshot-179.png)\\n\\nMy solution is O(n^2) but slightly optimized.\\n```\\nclass Solution {\\npublic:\\n    int checkPalindrome(string s, int start, int end){\\n        while(start < end){\\n            if(s[start] != s[end]) return 0;\\n            start++;\\n            end--;\\n        }\\n        return 1;\\n    }\\n\\n    string shortestPalindrome(string s) {\\n        string maxS = \"\";\\n        for(int i = s.length(); i >= 0; i--){\\n            if(checkPalindrome(s, 0, i)){\\n                maxS = s.substr(0, i+1);\\n                break;\\n            }\\n        }\\n\\n        cout << maxS;\\n\\n        string toAdd = s.substr(maxS.length(), s.length());\\n        reverse(toAdd.begin(), toAdd.end());\\n\\n        return toAdd + s;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "m-ymn",
                        "content": "i\\'m getting TLE on the last testcase \"aaaaaaaa\", how to deal with it, i\\'m just checking that using the simple palindrome function but still it is giving TLE"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Tip: If you are stubborn like me and trying to find a solution, thinking to yourself \"surely they didn't make a problem that is supposed to be solved only via KMP, that would be silly\", well think again. They did.\nIf you're feeling lazy to implement KMP today, you can cheese the only constraining test case because they built it using a single repeated characters instead of using periodic patterns. you can work out a simpler implementation that deals with the case where you have a buttload of \"a\".\nOf course not a viable interview solution, but I don't think you will commonly find interviewers actually expecting you to implement a custom KMP in an interview"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "definitely not so easy to digest the solution ."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "string a=s;\\n        reverse(a.begin(),a.end());\\n        int ans=0;\\n        int n=s.length();\\n        for(int i=n-1;i>=0;i--){\\n            if(a.substr(n-i-1)==s.substr(0,i+1)){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        if(ans+1==n){return s;}\\n        a=a.substr(0,n-ans-1)+s;\\n        return a;\\n\\ncan anyone tell ,how it can optimize even i am using longest pallin with prefix suffix concept"
                    }
                ]
            },
            {
                "id": 1917550,
                "content": [
                    {
                        "username": "infinityboy",
                        "content": "s =\\n\"aabba\"\\nStdout\\nabba\\nOutput\\n\"abbabba\"\\nExpected\\n\"abbaabba\"\\n\\nwhy my ans is wrong i have given minimum operation"
                    },
                    {
                        "username": "MTS99",
                        "content": "Output\\n\"abbabba\"\\n\\nyour output is wrong\\n"
                    },
                    {
                        "username": "LivingHell",
                        "content": "Can anyone help me? Why am I facing this issue? \\n\\nhttps://shorturl.at/aosNX\\n\\nThe expected output and my output are both the same, but I am still getting the wrong answer!"
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1> Its over an hour and still not able to find the solution ahhhhhh!!!! \\uD83E\\uDDE0 \\uD83C\\uDF7D\\uFE0F \\uD83E\\uDDE0</h1>"
                    },
                    {
                        "username": "aditya273001",
                        "content": "In the case of input \"aabba\"\\n\\nthe output should be \"abbabba\"\\n\\nnot \"abbaabba\""
                    },
                    {
                        "username": "aditya273001",
                        "content": "[@at218808](/at218808) I inserted b at index 1, the existing a shifted to 2nd index"
                    },
                    {
                        "username": "at218808",
                        "content": "you deleted first \\'a\\' from \\'aabba\\' , answer is \\'abbaabba\\'"
                    },
                    {
                        "username": "riturajpaul18",
                        "content": "For the following test case:\\ns=\"aabba\"\\n\\nMy output is: \"abbabba\"\\nAnd the expected output is: \"abbaabba\"\\n\\nMy output\\'s length is shorter than the expected output length\\nSo, why am I getting Wrong Answer?"
                    },
                    {
                        "username": "shubhra_riki",
                        "content": "because u need to insert at the first in each iteration"
                    },
                    {
                        "username": "NamanVer02",
                        "content": "Why ? :\\'(\\n\\n![image](https://i.ibb.co/wpHCrBG/Screenshot-179.png)\\n\\nMy solution is O(n^2) but slightly optimized.\\n```\\nclass Solution {\\npublic:\\n    int checkPalindrome(string s, int start, int end){\\n        while(start < end){\\n            if(s[start] != s[end]) return 0;\\n            start++;\\n            end--;\\n        }\\n        return 1;\\n    }\\n\\n    string shortestPalindrome(string s) {\\n        string maxS = \"\";\\n        for(int i = s.length(); i >= 0; i--){\\n            if(checkPalindrome(s, 0, i)){\\n                maxS = s.substr(0, i+1);\\n                break;\\n            }\\n        }\\n\\n        cout << maxS;\\n\\n        string toAdd = s.substr(maxS.length(), s.length());\\n        reverse(toAdd.begin(), toAdd.end());\\n\\n        return toAdd + s;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "m-ymn",
                        "content": "i\\'m getting TLE on the last testcase \"aaaaaaaa\", how to deal with it, i\\'m just checking that using the simple palindrome function but still it is giving TLE"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Tip: If you are stubborn like me and trying to find a solution, thinking to yourself \"surely they didn't make a problem that is supposed to be solved only via KMP, that would be silly\", well think again. They did.\nIf you're feeling lazy to implement KMP today, you can cheese the only constraining test case because they built it using a single repeated characters instead of using periodic patterns. you can work out a simpler implementation that deals with the case where you have a buttload of \"a\".\nOf course not a viable interview solution, but I don't think you will commonly find interviewers actually expecting you to implement a custom KMP in an interview"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "definitely not so easy to digest the solution ."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "string a=s;\\n        reverse(a.begin(),a.end());\\n        int ans=0;\\n        int n=s.length();\\n        for(int i=n-1;i>=0;i--){\\n            if(a.substr(n-i-1)==s.substr(0,i+1)){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        if(ans+1==n){return s;}\\n        a=a.substr(0,n-ans-1)+s;\\n        return a;\\n\\ncan anyone tell ,how it can optimize even i am using longest pallin with prefix suffix concept"
                    }
                ]
            },
            {
                "id": 1862898,
                "content": [
                    {
                        "username": "infinityboy",
                        "content": "s =\\n\"aabba\"\\nStdout\\nabba\\nOutput\\n\"abbabba\"\\nExpected\\n\"abbaabba\"\\n\\nwhy my ans is wrong i have given minimum operation"
                    },
                    {
                        "username": "MTS99",
                        "content": "Output\\n\"abbabba\"\\n\\nyour output is wrong\\n"
                    },
                    {
                        "username": "LivingHell",
                        "content": "Can anyone help me? Why am I facing this issue? \\n\\nhttps://shorturl.at/aosNX\\n\\nThe expected output and my output are both the same, but I am still getting the wrong answer!"
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1> Its over an hour and still not able to find the solution ahhhhhh!!!! \\uD83E\\uDDE0 \\uD83C\\uDF7D\\uFE0F \\uD83E\\uDDE0</h1>"
                    },
                    {
                        "username": "aditya273001",
                        "content": "In the case of input \"aabba\"\\n\\nthe output should be \"abbabba\"\\n\\nnot \"abbaabba\""
                    },
                    {
                        "username": "aditya273001",
                        "content": "[@at218808](/at218808) I inserted b at index 1, the existing a shifted to 2nd index"
                    },
                    {
                        "username": "at218808",
                        "content": "you deleted first \\'a\\' from \\'aabba\\' , answer is \\'abbaabba\\'"
                    },
                    {
                        "username": "riturajpaul18",
                        "content": "For the following test case:\\ns=\"aabba\"\\n\\nMy output is: \"abbabba\"\\nAnd the expected output is: \"abbaabba\"\\n\\nMy output\\'s length is shorter than the expected output length\\nSo, why am I getting Wrong Answer?"
                    },
                    {
                        "username": "shubhra_riki",
                        "content": "because u need to insert at the first in each iteration"
                    },
                    {
                        "username": "NamanVer02",
                        "content": "Why ? :\\'(\\n\\n![image](https://i.ibb.co/wpHCrBG/Screenshot-179.png)\\n\\nMy solution is O(n^2) but slightly optimized.\\n```\\nclass Solution {\\npublic:\\n    int checkPalindrome(string s, int start, int end){\\n        while(start < end){\\n            if(s[start] != s[end]) return 0;\\n            start++;\\n            end--;\\n        }\\n        return 1;\\n    }\\n\\n    string shortestPalindrome(string s) {\\n        string maxS = \"\";\\n        for(int i = s.length(); i >= 0; i--){\\n            if(checkPalindrome(s, 0, i)){\\n                maxS = s.substr(0, i+1);\\n                break;\\n            }\\n        }\\n\\n        cout << maxS;\\n\\n        string toAdd = s.substr(maxS.length(), s.length());\\n        reverse(toAdd.begin(), toAdd.end());\\n\\n        return toAdd + s;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "m-ymn",
                        "content": "i\\'m getting TLE on the last testcase \"aaaaaaaa\", how to deal with it, i\\'m just checking that using the simple palindrome function but still it is giving TLE"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Tip: If you are stubborn like me and trying to find a solution, thinking to yourself \"surely they didn't make a problem that is supposed to be solved only via KMP, that would be silly\", well think again. They did.\nIf you're feeling lazy to implement KMP today, you can cheese the only constraining test case because they built it using a single repeated characters instead of using periodic patterns. you can work out a simpler implementation that deals with the case where you have a buttload of \"a\".\nOf course not a viable interview solution, but I don't think you will commonly find interviewers actually expecting you to implement a custom KMP in an interview"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "definitely not so easy to digest the solution ."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "string a=s;\\n        reverse(a.begin(),a.end());\\n        int ans=0;\\n        int n=s.length();\\n        for(int i=n-1;i>=0;i--){\\n            if(a.substr(n-i-1)==s.substr(0,i+1)){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        if(ans+1==n){return s;}\\n        a=a.substr(0,n-ans-1)+s;\\n        return a;\\n\\ncan anyone tell ,how it can optimize even i am using longest pallin with prefix suffix concept"
                    }
                ]
            },
            {
                "id": 1847177,
                "content": [
                    {
                        "username": "infinityboy",
                        "content": "s =\\n\"aabba\"\\nStdout\\nabba\\nOutput\\n\"abbabba\"\\nExpected\\n\"abbaabba\"\\n\\nwhy my ans is wrong i have given minimum operation"
                    },
                    {
                        "username": "MTS99",
                        "content": "Output\\n\"abbabba\"\\n\\nyour output is wrong\\n"
                    },
                    {
                        "username": "LivingHell",
                        "content": "Can anyone help me? Why am I facing this issue? \\n\\nhttps://shorturl.at/aosNX\\n\\nThe expected output and my output are both the same, but I am still getting the wrong answer!"
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1> Its over an hour and still not able to find the solution ahhhhhh!!!! \\uD83E\\uDDE0 \\uD83C\\uDF7D\\uFE0F \\uD83E\\uDDE0</h1>"
                    },
                    {
                        "username": "aditya273001",
                        "content": "In the case of input \"aabba\"\\n\\nthe output should be \"abbabba\"\\n\\nnot \"abbaabba\""
                    },
                    {
                        "username": "aditya273001",
                        "content": "[@at218808](/at218808) I inserted b at index 1, the existing a shifted to 2nd index"
                    },
                    {
                        "username": "at218808",
                        "content": "you deleted first \\'a\\' from \\'aabba\\' , answer is \\'abbaabba\\'"
                    },
                    {
                        "username": "riturajpaul18",
                        "content": "For the following test case:\\ns=\"aabba\"\\n\\nMy output is: \"abbabba\"\\nAnd the expected output is: \"abbaabba\"\\n\\nMy output\\'s length is shorter than the expected output length\\nSo, why am I getting Wrong Answer?"
                    },
                    {
                        "username": "shubhra_riki",
                        "content": "because u need to insert at the first in each iteration"
                    },
                    {
                        "username": "NamanVer02",
                        "content": "Why ? :\\'(\\n\\n![image](https://i.ibb.co/wpHCrBG/Screenshot-179.png)\\n\\nMy solution is O(n^2) but slightly optimized.\\n```\\nclass Solution {\\npublic:\\n    int checkPalindrome(string s, int start, int end){\\n        while(start < end){\\n            if(s[start] != s[end]) return 0;\\n            start++;\\n            end--;\\n        }\\n        return 1;\\n    }\\n\\n    string shortestPalindrome(string s) {\\n        string maxS = \"\";\\n        for(int i = s.length(); i >= 0; i--){\\n            if(checkPalindrome(s, 0, i)){\\n                maxS = s.substr(0, i+1);\\n                break;\\n            }\\n        }\\n\\n        cout << maxS;\\n\\n        string toAdd = s.substr(maxS.length(), s.length());\\n        reverse(toAdd.begin(), toAdd.end());\\n\\n        return toAdd + s;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "m-ymn",
                        "content": "i\\'m getting TLE on the last testcase \"aaaaaaaa\", how to deal with it, i\\'m just checking that using the simple palindrome function but still it is giving TLE"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Tip: If you are stubborn like me and trying to find a solution, thinking to yourself \"surely they didn't make a problem that is supposed to be solved only via KMP, that would be silly\", well think again. They did.\nIf you're feeling lazy to implement KMP today, you can cheese the only constraining test case because they built it using a single repeated characters instead of using periodic patterns. you can work out a simpler implementation that deals with the case where you have a buttload of \"a\".\nOf course not a viable interview solution, but I don't think you will commonly find interviewers actually expecting you to implement a custom KMP in an interview"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "definitely not so easy to digest the solution ."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "string a=s;\\n        reverse(a.begin(),a.end());\\n        int ans=0;\\n        int n=s.length();\\n        for(int i=n-1;i>=0;i--){\\n            if(a.substr(n-i-1)==s.substr(0,i+1)){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        if(ans+1==n){return s;}\\n        a=a.substr(0,n-ans-1)+s;\\n        return a;\\n\\ncan anyone tell ,how it can optimize even i am using longest pallin with prefix suffix concept"
                    }
                ]
            },
            {
                "id": 1791910,
                "content": [
                    {
                        "username": "infinityboy",
                        "content": "s =\\n\"aabba\"\\nStdout\\nabba\\nOutput\\n\"abbabba\"\\nExpected\\n\"abbaabba\"\\n\\nwhy my ans is wrong i have given minimum operation"
                    },
                    {
                        "username": "MTS99",
                        "content": "Output\\n\"abbabba\"\\n\\nyour output is wrong\\n"
                    },
                    {
                        "username": "LivingHell",
                        "content": "Can anyone help me? Why am I facing this issue? \\n\\nhttps://shorturl.at/aosNX\\n\\nThe expected output and my output are both the same, but I am still getting the wrong answer!"
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1> Its over an hour and still not able to find the solution ahhhhhh!!!! \\uD83E\\uDDE0 \\uD83C\\uDF7D\\uFE0F \\uD83E\\uDDE0</h1>"
                    },
                    {
                        "username": "aditya273001",
                        "content": "In the case of input \"aabba\"\\n\\nthe output should be \"abbabba\"\\n\\nnot \"abbaabba\""
                    },
                    {
                        "username": "aditya273001",
                        "content": "[@at218808](/at218808) I inserted b at index 1, the existing a shifted to 2nd index"
                    },
                    {
                        "username": "at218808",
                        "content": "you deleted first \\'a\\' from \\'aabba\\' , answer is \\'abbaabba\\'"
                    },
                    {
                        "username": "riturajpaul18",
                        "content": "For the following test case:\\ns=\"aabba\"\\n\\nMy output is: \"abbabba\"\\nAnd the expected output is: \"abbaabba\"\\n\\nMy output\\'s length is shorter than the expected output length\\nSo, why am I getting Wrong Answer?"
                    },
                    {
                        "username": "shubhra_riki",
                        "content": "because u need to insert at the first in each iteration"
                    },
                    {
                        "username": "NamanVer02",
                        "content": "Why ? :\\'(\\n\\n![image](https://i.ibb.co/wpHCrBG/Screenshot-179.png)\\n\\nMy solution is O(n^2) but slightly optimized.\\n```\\nclass Solution {\\npublic:\\n    int checkPalindrome(string s, int start, int end){\\n        while(start < end){\\n            if(s[start] != s[end]) return 0;\\n            start++;\\n            end--;\\n        }\\n        return 1;\\n    }\\n\\n    string shortestPalindrome(string s) {\\n        string maxS = \"\";\\n        for(int i = s.length(); i >= 0; i--){\\n            if(checkPalindrome(s, 0, i)){\\n                maxS = s.substr(0, i+1);\\n                break;\\n            }\\n        }\\n\\n        cout << maxS;\\n\\n        string toAdd = s.substr(maxS.length(), s.length());\\n        reverse(toAdd.begin(), toAdd.end());\\n\\n        return toAdd + s;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "m-ymn",
                        "content": "i\\'m getting TLE on the last testcase \"aaaaaaaa\", how to deal with it, i\\'m just checking that using the simple palindrome function but still it is giving TLE"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Tip: If you are stubborn like me and trying to find a solution, thinking to yourself \"surely they didn't make a problem that is supposed to be solved only via KMP, that would be silly\", well think again. They did.\nIf you're feeling lazy to implement KMP today, you can cheese the only constraining test case because they built it using a single repeated characters instead of using periodic patterns. you can work out a simpler implementation that deals with the case where you have a buttload of \"a\".\nOf course not a viable interview solution, but I don't think you will commonly find interviewers actually expecting you to implement a custom KMP in an interview"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "definitely not so easy to digest the solution ."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "string a=s;\\n        reverse(a.begin(),a.end());\\n        int ans=0;\\n        int n=s.length();\\n        for(int i=n-1;i>=0;i--){\\n            if(a.substr(n-i-1)==s.substr(0,i+1)){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        if(ans+1==n){return s;}\\n        a=a.substr(0,n-ans-1)+s;\\n        return a;\\n\\ncan anyone tell ,how it can optimize even i am using longest pallin with prefix suffix concept"
                    }
                ]
            }
        ]
    },
    {
        "title": "Binary Tree Vertical Order Traversal",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1572528,
                "content": [
                    {
                        "username": "mazyla",
                        "content": "Input:\\n[3,9,8,4,0,1,7,null,null,null,2,5]\\nExpected answer: [ [4], [9,5], [3,0,1], [8,2], [7] ]\\n\\nBut the question says if 2 nodes have the same horizontal distance, then order should be left to right, while the expected answer is right node first, in the case of 8 and 2.\\n\\nIsn\\'t the right answer actually: [ [4], [9,5], [3,0,1], [2,8], [7] ]"
                    },
                    {
                        "username": "heavenfish",
                        "content": "It asked to travel from top to bottom and left to right. Therefore, 8 should come first as it is on top of 2."
                    },
                    {
                        "username": "fyh8238865",
                        "content": "In the problem, they asked us to do vertical order traversal, but what does the \"vertical order\" mean? I think the problem do not state it well.\\n\\nFor example, in the following case: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\\n\\nShould the 1,11,12 be on the same horizontal position?\\n\\nBased on my intuition, the position of the node in a tree will changed based on their deep and number of nodes in each layer. Because I think the position is not absolute value. So the upper case, I said yes. But for the real test case, they said no. \\n\\nTherefore, I think the problem should clarify what is their definition of the position or vertical order.\\n\\nIf anyone think what I said has something wrong, please correct me."
                    },
                    {
                        "username": "mlblount45",
                        "content": "What would the output look like for a tree of height 4?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Vertical Order traversal variations:\\n- If question was just to find nodes in the same column (where nodes in a column could be from top to bottom OR bottom to top or random): dfs would be enough. But that is not really a vertical order traversal. I mistakenly used dfs first to find out later in my answer the nodes in the same column were not arranged from top to bottom.\\n- LC 314: Vertical order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be from left to right. TreeMap with horizontalDistance as key helped solving this.\\n- LC 987: Vertival Order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be smaller value should come in first. TreeMap with horizontalDistance as key and value being \\'TreeMap with height as key and value being TreeSet for sorting by node value\\' helped solving this \\n\\nI came up with the solutions on my own. Go through my 1st accpeted submission for each question. There might be optimizations in LC solutions. I didnt look at it yet. Have a look some day when you get time.\\n\\n**Note: This is an application of Level Order Traversal**"
                    },
                    {
                        "username": "Lakpro",
                        "content": "**SIMILAR QUESTIONS**\\n\\n**[314. Binary Tree Vertical Order Traversal: ](https://leetcode.com/problems/binary-tree-vertical-order-traversal/description/)** (Here, we have to return nodes in the same column as left to right)\\n\\n**[987. Vertical Order Traversal of a Binary Tree: ](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/987)** (Here, we have to return nodes in the same column in  sorted order.)"
                    },
                    {
                        "username": "huangguoqiang",
                        "content": "Input:\\n[3,9,8,4,0,1,7]\\nOutput:\\n[[4],[9],[0,3,1],[8],[7]]\\nExpected:\\n[[4],[9],[3,0,1],[8],[7]] \\n\\nThe condition is that If two nodes are in the same row and column, the order should be from left to right.\\n\\nFor the example above, only 0 and 1 are in the same row and column, but 3 is not.  So both [[4],[9],[0,3,1],[8],[7]] and [[4],[9],[3,0,1],[8],[7]] should be correct answers."
                    },
                    {
                        "username": "elwerro",
                        "content": "https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/"
                    },
                    {
                        "username": "uzia35",
                        "content": "The priority for the answer is left to right for columns and top to bottom for the rows. The rows should be mentioned just in case. "
                    },
                    {
                        "username": "joxamo",
                        "content": "So I tried solving this problem using the following recursive function and it came out wrong.\n\nvar verticalOrder = function(root) {\n    if (!root) {\n        return [];\n    }\n\n    const columnMap = new Map(); // Map to store nodes in each column\n\n    // Helper function for recursive traversal\n    function dfs(node, col) {\n        if (!node) {\n            return;\n        }\n\n        if (!columnMap.has(col)) {\n            columnMap.set(col, []);\n        }\n\n\n        columnMap.get(col).push(node.val);\n\n        dfs(node.left, col - 1);\n        dfs(node.right, col + 1);\n    }\n\n    // Start the recursive traversal with the root at column 0\n    dfs(root, 0);\n\n    // Sort the columns in ascending order\n    const sortedColumns = [...columnMap.keys()].sort((a, b) => a - b);\n\n    // Create the result array\n    const result = sortedColumns.map(col => columnMap.get(col));\n\n    return result;\n};\n\nIt claimed my output was incorrect compared to the test case:\nexpected:\n[[4],[9,5],[3,0,1],[8,2],[7]]\noutput:\n[[4],[9,5],[3,0,1],[2,8],[7]]\n\nI was skeptical of this test result, so I decided to create the tree on my own in codepen\n\n\nlet root = new TreeNode();\nroot.val = 3\nroot.left = new TreeNode(9);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(0);\nroot.left.right.left = new TreeNode(5);\nroot.right = new TreeNode(8);\nroot.right.left = new TreeNode(1);\nroot.right.left.right = new TreeNode(2);\nroot.right.right = new TreeNode(7);\n\nAfter doing this, my output came back correct as expected. Is there something wrong with that test case?"
                    },
                    {
                        "username": "brett_davis",
                        "content": "Am I misunderstanding or is the third example not set up correctly?\n\n[3,9,8,4,0,1,7,null,null,null,2,5]\n\n3 - > 9, 8\n9 -> 4, 0\n8 -> 1, 7\n4 -> null, null\n0 -> null, 2\n1 -> 5\n\n2 is supposed to be the right child of 1\n\nI would think the input  has to be: [3,9,8,4,0,1,7,null,null,5, null, null, 2]\n"
                    }
                ]
            },
            {
                "id": 1566777,
                "content": [
                    {
                        "username": "mazyla",
                        "content": "Input:\\n[3,9,8,4,0,1,7,null,null,null,2,5]\\nExpected answer: [ [4], [9,5], [3,0,1], [8,2], [7] ]\\n\\nBut the question says if 2 nodes have the same horizontal distance, then order should be left to right, while the expected answer is right node first, in the case of 8 and 2.\\n\\nIsn\\'t the right answer actually: [ [4], [9,5], [3,0,1], [2,8], [7] ]"
                    },
                    {
                        "username": "heavenfish",
                        "content": "It asked to travel from top to bottom and left to right. Therefore, 8 should come first as it is on top of 2."
                    },
                    {
                        "username": "fyh8238865",
                        "content": "In the problem, they asked us to do vertical order traversal, but what does the \"vertical order\" mean? I think the problem do not state it well.\\n\\nFor example, in the following case: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\\n\\nShould the 1,11,12 be on the same horizontal position?\\n\\nBased on my intuition, the position of the node in a tree will changed based on their deep and number of nodes in each layer. Because I think the position is not absolute value. So the upper case, I said yes. But for the real test case, they said no. \\n\\nTherefore, I think the problem should clarify what is their definition of the position or vertical order.\\n\\nIf anyone think what I said has something wrong, please correct me."
                    },
                    {
                        "username": "mlblount45",
                        "content": "What would the output look like for a tree of height 4?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Vertical Order traversal variations:\\n- If question was just to find nodes in the same column (where nodes in a column could be from top to bottom OR bottom to top or random): dfs would be enough. But that is not really a vertical order traversal. I mistakenly used dfs first to find out later in my answer the nodes in the same column were not arranged from top to bottom.\\n- LC 314: Vertical order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be from left to right. TreeMap with horizontalDistance as key helped solving this.\\n- LC 987: Vertival Order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be smaller value should come in first. TreeMap with horizontalDistance as key and value being \\'TreeMap with height as key and value being TreeSet for sorting by node value\\' helped solving this \\n\\nI came up with the solutions on my own. Go through my 1st accpeted submission for each question. There might be optimizations in LC solutions. I didnt look at it yet. Have a look some day when you get time.\\n\\n**Note: This is an application of Level Order Traversal**"
                    },
                    {
                        "username": "Lakpro",
                        "content": "**SIMILAR QUESTIONS**\\n\\n**[314. Binary Tree Vertical Order Traversal: ](https://leetcode.com/problems/binary-tree-vertical-order-traversal/description/)** (Here, we have to return nodes in the same column as left to right)\\n\\n**[987. Vertical Order Traversal of a Binary Tree: ](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/987)** (Here, we have to return nodes in the same column in  sorted order.)"
                    },
                    {
                        "username": "huangguoqiang",
                        "content": "Input:\\n[3,9,8,4,0,1,7]\\nOutput:\\n[[4],[9],[0,3,1],[8],[7]]\\nExpected:\\n[[4],[9],[3,0,1],[8],[7]] \\n\\nThe condition is that If two nodes are in the same row and column, the order should be from left to right.\\n\\nFor the example above, only 0 and 1 are in the same row and column, but 3 is not.  So both [[4],[9],[0,3,1],[8],[7]] and [[4],[9],[3,0,1],[8],[7]] should be correct answers."
                    },
                    {
                        "username": "elwerro",
                        "content": "https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/"
                    },
                    {
                        "username": "uzia35",
                        "content": "The priority for the answer is left to right for columns and top to bottom for the rows. The rows should be mentioned just in case. "
                    },
                    {
                        "username": "joxamo",
                        "content": "So I tried solving this problem using the following recursive function and it came out wrong.\n\nvar verticalOrder = function(root) {\n    if (!root) {\n        return [];\n    }\n\n    const columnMap = new Map(); // Map to store nodes in each column\n\n    // Helper function for recursive traversal\n    function dfs(node, col) {\n        if (!node) {\n            return;\n        }\n\n        if (!columnMap.has(col)) {\n            columnMap.set(col, []);\n        }\n\n\n        columnMap.get(col).push(node.val);\n\n        dfs(node.left, col - 1);\n        dfs(node.right, col + 1);\n    }\n\n    // Start the recursive traversal with the root at column 0\n    dfs(root, 0);\n\n    // Sort the columns in ascending order\n    const sortedColumns = [...columnMap.keys()].sort((a, b) => a - b);\n\n    // Create the result array\n    const result = sortedColumns.map(col => columnMap.get(col));\n\n    return result;\n};\n\nIt claimed my output was incorrect compared to the test case:\nexpected:\n[[4],[9,5],[3,0,1],[8,2],[7]]\noutput:\n[[4],[9,5],[3,0,1],[2,8],[7]]\n\nI was skeptical of this test result, so I decided to create the tree on my own in codepen\n\n\nlet root = new TreeNode();\nroot.val = 3\nroot.left = new TreeNode(9);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(0);\nroot.left.right.left = new TreeNode(5);\nroot.right = new TreeNode(8);\nroot.right.left = new TreeNode(1);\nroot.right.left.right = new TreeNode(2);\nroot.right.right = new TreeNode(7);\n\nAfter doing this, my output came back correct as expected. Is there something wrong with that test case?"
                    },
                    {
                        "username": "brett_davis",
                        "content": "Am I misunderstanding or is the third example not set up correctly?\n\n[3,9,8,4,0,1,7,null,null,null,2,5]\n\n3 - > 9, 8\n9 -> 4, 0\n8 -> 1, 7\n4 -> null, null\n0 -> null, 2\n1 -> 5\n\n2 is supposed to be the right child of 1\n\nI would think the input  has to be: [3,9,8,4,0,1,7,null,null,5, null, null, 2]\n"
                    }
                ]
            },
            {
                "id": 1571565,
                "content": [
                    {
                        "username": "mazyla",
                        "content": "Input:\\n[3,9,8,4,0,1,7,null,null,null,2,5]\\nExpected answer: [ [4], [9,5], [3,0,1], [8,2], [7] ]\\n\\nBut the question says if 2 nodes have the same horizontal distance, then order should be left to right, while the expected answer is right node first, in the case of 8 and 2.\\n\\nIsn\\'t the right answer actually: [ [4], [9,5], [3,0,1], [2,8], [7] ]"
                    },
                    {
                        "username": "heavenfish",
                        "content": "It asked to travel from top to bottom and left to right. Therefore, 8 should come first as it is on top of 2."
                    },
                    {
                        "username": "fyh8238865",
                        "content": "In the problem, they asked us to do vertical order traversal, but what does the \"vertical order\" mean? I think the problem do not state it well.\\n\\nFor example, in the following case: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\\n\\nShould the 1,11,12 be on the same horizontal position?\\n\\nBased on my intuition, the position of the node in a tree will changed based on their deep and number of nodes in each layer. Because I think the position is not absolute value. So the upper case, I said yes. But for the real test case, they said no. \\n\\nTherefore, I think the problem should clarify what is their definition of the position or vertical order.\\n\\nIf anyone think what I said has something wrong, please correct me."
                    },
                    {
                        "username": "mlblount45",
                        "content": "What would the output look like for a tree of height 4?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Vertical Order traversal variations:\\n- If question was just to find nodes in the same column (where nodes in a column could be from top to bottom OR bottom to top or random): dfs would be enough. But that is not really a vertical order traversal. I mistakenly used dfs first to find out later in my answer the nodes in the same column were not arranged from top to bottom.\\n- LC 314: Vertical order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be from left to right. TreeMap with horizontalDistance as key helped solving this.\\n- LC 987: Vertival Order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be smaller value should come in first. TreeMap with horizontalDistance as key and value being \\'TreeMap with height as key and value being TreeSet for sorting by node value\\' helped solving this \\n\\nI came up with the solutions on my own. Go through my 1st accpeted submission for each question. There might be optimizations in LC solutions. I didnt look at it yet. Have a look some day when you get time.\\n\\n**Note: This is an application of Level Order Traversal**"
                    },
                    {
                        "username": "Lakpro",
                        "content": "**SIMILAR QUESTIONS**\\n\\n**[314. Binary Tree Vertical Order Traversal: ](https://leetcode.com/problems/binary-tree-vertical-order-traversal/description/)** (Here, we have to return nodes in the same column as left to right)\\n\\n**[987. Vertical Order Traversal of a Binary Tree: ](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/987)** (Here, we have to return nodes in the same column in  sorted order.)"
                    },
                    {
                        "username": "huangguoqiang",
                        "content": "Input:\\n[3,9,8,4,0,1,7]\\nOutput:\\n[[4],[9],[0,3,1],[8],[7]]\\nExpected:\\n[[4],[9],[3,0,1],[8],[7]] \\n\\nThe condition is that If two nodes are in the same row and column, the order should be from left to right.\\n\\nFor the example above, only 0 and 1 are in the same row and column, but 3 is not.  So both [[4],[9],[0,3,1],[8],[7]] and [[4],[9],[3,0,1],[8],[7]] should be correct answers."
                    },
                    {
                        "username": "elwerro",
                        "content": "https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/"
                    },
                    {
                        "username": "uzia35",
                        "content": "The priority for the answer is left to right for columns and top to bottom for the rows. The rows should be mentioned just in case. "
                    },
                    {
                        "username": "joxamo",
                        "content": "So I tried solving this problem using the following recursive function and it came out wrong.\n\nvar verticalOrder = function(root) {\n    if (!root) {\n        return [];\n    }\n\n    const columnMap = new Map(); // Map to store nodes in each column\n\n    // Helper function for recursive traversal\n    function dfs(node, col) {\n        if (!node) {\n            return;\n        }\n\n        if (!columnMap.has(col)) {\n            columnMap.set(col, []);\n        }\n\n\n        columnMap.get(col).push(node.val);\n\n        dfs(node.left, col - 1);\n        dfs(node.right, col + 1);\n    }\n\n    // Start the recursive traversal with the root at column 0\n    dfs(root, 0);\n\n    // Sort the columns in ascending order\n    const sortedColumns = [...columnMap.keys()].sort((a, b) => a - b);\n\n    // Create the result array\n    const result = sortedColumns.map(col => columnMap.get(col));\n\n    return result;\n};\n\nIt claimed my output was incorrect compared to the test case:\nexpected:\n[[4],[9,5],[3,0,1],[8,2],[7]]\noutput:\n[[4],[9,5],[3,0,1],[2,8],[7]]\n\nI was skeptical of this test result, so I decided to create the tree on my own in codepen\n\n\nlet root = new TreeNode();\nroot.val = 3\nroot.left = new TreeNode(9);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(0);\nroot.left.right.left = new TreeNode(5);\nroot.right = new TreeNode(8);\nroot.right.left = new TreeNode(1);\nroot.right.left.right = new TreeNode(2);\nroot.right.right = new TreeNode(7);\n\nAfter doing this, my output came back correct as expected. Is there something wrong with that test case?"
                    },
                    {
                        "username": "brett_davis",
                        "content": "Am I misunderstanding or is the third example not set up correctly?\n\n[3,9,8,4,0,1,7,null,null,null,2,5]\n\n3 - > 9, 8\n9 -> 4, 0\n8 -> 1, 7\n4 -> null, null\n0 -> null, 2\n1 -> 5\n\n2 is supposed to be the right child of 1\n\nI would think the input  has to be: [3,9,8,4,0,1,7,null,null,5, null, null, 2]\n"
                    }
                ]
            },
            {
                "id": 1574633,
                "content": [
                    {
                        "username": "mazyla",
                        "content": "Input:\\n[3,9,8,4,0,1,7,null,null,null,2,5]\\nExpected answer: [ [4], [9,5], [3,0,1], [8,2], [7] ]\\n\\nBut the question says if 2 nodes have the same horizontal distance, then order should be left to right, while the expected answer is right node first, in the case of 8 and 2.\\n\\nIsn\\'t the right answer actually: [ [4], [9,5], [3,0,1], [2,8], [7] ]"
                    },
                    {
                        "username": "heavenfish",
                        "content": "It asked to travel from top to bottom and left to right. Therefore, 8 should come first as it is on top of 2."
                    },
                    {
                        "username": "fyh8238865",
                        "content": "In the problem, they asked us to do vertical order traversal, but what does the \"vertical order\" mean? I think the problem do not state it well.\\n\\nFor example, in the following case: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\\n\\nShould the 1,11,12 be on the same horizontal position?\\n\\nBased on my intuition, the position of the node in a tree will changed based on their deep and number of nodes in each layer. Because I think the position is not absolute value. So the upper case, I said yes. But for the real test case, they said no. \\n\\nTherefore, I think the problem should clarify what is their definition of the position or vertical order.\\n\\nIf anyone think what I said has something wrong, please correct me."
                    },
                    {
                        "username": "mlblount45",
                        "content": "What would the output look like for a tree of height 4?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Vertical Order traversal variations:\\n- If question was just to find nodes in the same column (where nodes in a column could be from top to bottom OR bottom to top or random): dfs would be enough. But that is not really a vertical order traversal. I mistakenly used dfs first to find out later in my answer the nodes in the same column were not arranged from top to bottom.\\n- LC 314: Vertical order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be from left to right. TreeMap with horizontalDistance as key helped solving this.\\n- LC 987: Vertival Order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be smaller value should come in first. TreeMap with horizontalDistance as key and value being \\'TreeMap with height as key and value being TreeSet for sorting by node value\\' helped solving this \\n\\nI came up with the solutions on my own. Go through my 1st accpeted submission for each question. There might be optimizations in LC solutions. I didnt look at it yet. Have a look some day when you get time.\\n\\n**Note: This is an application of Level Order Traversal**"
                    },
                    {
                        "username": "Lakpro",
                        "content": "**SIMILAR QUESTIONS**\\n\\n**[314. Binary Tree Vertical Order Traversal: ](https://leetcode.com/problems/binary-tree-vertical-order-traversal/description/)** (Here, we have to return nodes in the same column as left to right)\\n\\n**[987. Vertical Order Traversal of a Binary Tree: ](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/987)** (Here, we have to return nodes in the same column in  sorted order.)"
                    },
                    {
                        "username": "huangguoqiang",
                        "content": "Input:\\n[3,9,8,4,0,1,7]\\nOutput:\\n[[4],[9],[0,3,1],[8],[7]]\\nExpected:\\n[[4],[9],[3,0,1],[8],[7]] \\n\\nThe condition is that If two nodes are in the same row and column, the order should be from left to right.\\n\\nFor the example above, only 0 and 1 are in the same row and column, but 3 is not.  So both [[4],[9],[0,3,1],[8],[7]] and [[4],[9],[3,0,1],[8],[7]] should be correct answers."
                    },
                    {
                        "username": "elwerro",
                        "content": "https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/"
                    },
                    {
                        "username": "uzia35",
                        "content": "The priority for the answer is left to right for columns and top to bottom for the rows. The rows should be mentioned just in case. "
                    },
                    {
                        "username": "joxamo",
                        "content": "So I tried solving this problem using the following recursive function and it came out wrong.\n\nvar verticalOrder = function(root) {\n    if (!root) {\n        return [];\n    }\n\n    const columnMap = new Map(); // Map to store nodes in each column\n\n    // Helper function for recursive traversal\n    function dfs(node, col) {\n        if (!node) {\n            return;\n        }\n\n        if (!columnMap.has(col)) {\n            columnMap.set(col, []);\n        }\n\n\n        columnMap.get(col).push(node.val);\n\n        dfs(node.left, col - 1);\n        dfs(node.right, col + 1);\n    }\n\n    // Start the recursive traversal with the root at column 0\n    dfs(root, 0);\n\n    // Sort the columns in ascending order\n    const sortedColumns = [...columnMap.keys()].sort((a, b) => a - b);\n\n    // Create the result array\n    const result = sortedColumns.map(col => columnMap.get(col));\n\n    return result;\n};\n\nIt claimed my output was incorrect compared to the test case:\nexpected:\n[[4],[9,5],[3,0,1],[8,2],[7]]\noutput:\n[[4],[9,5],[3,0,1],[2,8],[7]]\n\nI was skeptical of this test result, so I decided to create the tree on my own in codepen\n\n\nlet root = new TreeNode();\nroot.val = 3\nroot.left = new TreeNode(9);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(0);\nroot.left.right.left = new TreeNode(5);\nroot.right = new TreeNode(8);\nroot.right.left = new TreeNode(1);\nroot.right.left.right = new TreeNode(2);\nroot.right.right = new TreeNode(7);\n\nAfter doing this, my output came back correct as expected. Is there something wrong with that test case?"
                    },
                    {
                        "username": "brett_davis",
                        "content": "Am I misunderstanding or is the third example not set up correctly?\n\n[3,9,8,4,0,1,7,null,null,null,2,5]\n\n3 - > 9, 8\n9 -> 4, 0\n8 -> 1, 7\n4 -> null, null\n0 -> null, 2\n1 -> 5\n\n2 is supposed to be the right child of 1\n\nI would think the input  has to be: [3,9,8,4,0,1,7,null,null,5, null, null, 2]\n"
                    }
                ]
            },
            {
                "id": 1833565,
                "content": [
                    {
                        "username": "mazyla",
                        "content": "Input:\\n[3,9,8,4,0,1,7,null,null,null,2,5]\\nExpected answer: [ [4], [9,5], [3,0,1], [8,2], [7] ]\\n\\nBut the question says if 2 nodes have the same horizontal distance, then order should be left to right, while the expected answer is right node first, in the case of 8 and 2.\\n\\nIsn\\'t the right answer actually: [ [4], [9,5], [3,0,1], [2,8], [7] ]"
                    },
                    {
                        "username": "heavenfish",
                        "content": "It asked to travel from top to bottom and left to right. Therefore, 8 should come first as it is on top of 2."
                    },
                    {
                        "username": "fyh8238865",
                        "content": "In the problem, they asked us to do vertical order traversal, but what does the \"vertical order\" mean? I think the problem do not state it well.\\n\\nFor example, in the following case: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\\n\\nShould the 1,11,12 be on the same horizontal position?\\n\\nBased on my intuition, the position of the node in a tree will changed based on their deep and number of nodes in each layer. Because I think the position is not absolute value. So the upper case, I said yes. But for the real test case, they said no. \\n\\nTherefore, I think the problem should clarify what is their definition of the position or vertical order.\\n\\nIf anyone think what I said has something wrong, please correct me."
                    },
                    {
                        "username": "mlblount45",
                        "content": "What would the output look like for a tree of height 4?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Vertical Order traversal variations:\\n- If question was just to find nodes in the same column (where nodes in a column could be from top to bottom OR bottom to top or random): dfs would be enough. But that is not really a vertical order traversal. I mistakenly used dfs first to find out later in my answer the nodes in the same column were not arranged from top to bottom.\\n- LC 314: Vertical order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be from left to right. TreeMap with horizontalDistance as key helped solving this.\\n- LC 987: Vertival Order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be smaller value should come in first. TreeMap with horizontalDistance as key and value being \\'TreeMap with height as key and value being TreeSet for sorting by node value\\' helped solving this \\n\\nI came up with the solutions on my own. Go through my 1st accpeted submission for each question. There might be optimizations in LC solutions. I didnt look at it yet. Have a look some day when you get time.\\n\\n**Note: This is an application of Level Order Traversal**"
                    },
                    {
                        "username": "Lakpro",
                        "content": "**SIMILAR QUESTIONS**\\n\\n**[314. Binary Tree Vertical Order Traversal: ](https://leetcode.com/problems/binary-tree-vertical-order-traversal/description/)** (Here, we have to return nodes in the same column as left to right)\\n\\n**[987. Vertical Order Traversal of a Binary Tree: ](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/987)** (Here, we have to return nodes in the same column in  sorted order.)"
                    },
                    {
                        "username": "huangguoqiang",
                        "content": "Input:\\n[3,9,8,4,0,1,7]\\nOutput:\\n[[4],[9],[0,3,1],[8],[7]]\\nExpected:\\n[[4],[9],[3,0,1],[8],[7]] \\n\\nThe condition is that If two nodes are in the same row and column, the order should be from left to right.\\n\\nFor the example above, only 0 and 1 are in the same row and column, but 3 is not.  So both [[4],[9],[0,3,1],[8],[7]] and [[4],[9],[3,0,1],[8],[7]] should be correct answers."
                    },
                    {
                        "username": "elwerro",
                        "content": "https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/"
                    },
                    {
                        "username": "uzia35",
                        "content": "The priority for the answer is left to right for columns and top to bottom for the rows. The rows should be mentioned just in case. "
                    },
                    {
                        "username": "joxamo",
                        "content": "So I tried solving this problem using the following recursive function and it came out wrong.\n\nvar verticalOrder = function(root) {\n    if (!root) {\n        return [];\n    }\n\n    const columnMap = new Map(); // Map to store nodes in each column\n\n    // Helper function for recursive traversal\n    function dfs(node, col) {\n        if (!node) {\n            return;\n        }\n\n        if (!columnMap.has(col)) {\n            columnMap.set(col, []);\n        }\n\n\n        columnMap.get(col).push(node.val);\n\n        dfs(node.left, col - 1);\n        dfs(node.right, col + 1);\n    }\n\n    // Start the recursive traversal with the root at column 0\n    dfs(root, 0);\n\n    // Sort the columns in ascending order\n    const sortedColumns = [...columnMap.keys()].sort((a, b) => a - b);\n\n    // Create the result array\n    const result = sortedColumns.map(col => columnMap.get(col));\n\n    return result;\n};\n\nIt claimed my output was incorrect compared to the test case:\nexpected:\n[[4],[9,5],[3,0,1],[8,2],[7]]\noutput:\n[[4],[9,5],[3,0,1],[2,8],[7]]\n\nI was skeptical of this test result, so I decided to create the tree on my own in codepen\n\n\nlet root = new TreeNode();\nroot.val = 3\nroot.left = new TreeNode(9);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(0);\nroot.left.right.left = new TreeNode(5);\nroot.right = new TreeNode(8);\nroot.right.left = new TreeNode(1);\nroot.right.left.right = new TreeNode(2);\nroot.right.right = new TreeNode(7);\n\nAfter doing this, my output came back correct as expected. Is there something wrong with that test case?"
                    },
                    {
                        "username": "brett_davis",
                        "content": "Am I misunderstanding or is the third example not set up correctly?\n\n[3,9,8,4,0,1,7,null,null,null,2,5]\n\n3 - > 9, 8\n9 -> 4, 0\n8 -> 1, 7\n4 -> null, null\n0 -> null, 2\n1 -> 5\n\n2 is supposed to be the right child of 1\n\nI would think the input  has to be: [3,9,8,4,0,1,7,null,null,5, null, null, 2]\n"
                    }
                ]
            },
            {
                "id": 1572320,
                "content": [
                    {
                        "username": "mazyla",
                        "content": "Input:\\n[3,9,8,4,0,1,7,null,null,null,2,5]\\nExpected answer: [ [4], [9,5], [3,0,1], [8,2], [7] ]\\n\\nBut the question says if 2 nodes have the same horizontal distance, then order should be left to right, while the expected answer is right node first, in the case of 8 and 2.\\n\\nIsn\\'t the right answer actually: [ [4], [9,5], [3,0,1], [2,8], [7] ]"
                    },
                    {
                        "username": "heavenfish",
                        "content": "It asked to travel from top to bottom and left to right. Therefore, 8 should come first as it is on top of 2."
                    },
                    {
                        "username": "fyh8238865",
                        "content": "In the problem, they asked us to do vertical order traversal, but what does the \"vertical order\" mean? I think the problem do not state it well.\\n\\nFor example, in the following case: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\\n\\nShould the 1,11,12 be on the same horizontal position?\\n\\nBased on my intuition, the position of the node in a tree will changed based on their deep and number of nodes in each layer. Because I think the position is not absolute value. So the upper case, I said yes. But for the real test case, they said no. \\n\\nTherefore, I think the problem should clarify what is their definition of the position or vertical order.\\n\\nIf anyone think what I said has something wrong, please correct me."
                    },
                    {
                        "username": "mlblount45",
                        "content": "What would the output look like for a tree of height 4?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Vertical Order traversal variations:\\n- If question was just to find nodes in the same column (where nodes in a column could be from top to bottom OR bottom to top or random): dfs would be enough. But that is not really a vertical order traversal. I mistakenly used dfs first to find out later in my answer the nodes in the same column were not arranged from top to bottom.\\n- LC 314: Vertical order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be from left to right. TreeMap with horizontalDistance as key helped solving this.\\n- LC 987: Vertival Order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be smaller value should come in first. TreeMap with horizontalDistance as key and value being \\'TreeMap with height as key and value being TreeSet for sorting by node value\\' helped solving this \\n\\nI came up with the solutions on my own. Go through my 1st accpeted submission for each question. There might be optimizations in LC solutions. I didnt look at it yet. Have a look some day when you get time.\\n\\n**Note: This is an application of Level Order Traversal**"
                    },
                    {
                        "username": "Lakpro",
                        "content": "**SIMILAR QUESTIONS**\\n\\n**[314. Binary Tree Vertical Order Traversal: ](https://leetcode.com/problems/binary-tree-vertical-order-traversal/description/)** (Here, we have to return nodes in the same column as left to right)\\n\\n**[987. Vertical Order Traversal of a Binary Tree: ](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/987)** (Here, we have to return nodes in the same column in  sorted order.)"
                    },
                    {
                        "username": "huangguoqiang",
                        "content": "Input:\\n[3,9,8,4,0,1,7]\\nOutput:\\n[[4],[9],[0,3,1],[8],[7]]\\nExpected:\\n[[4],[9],[3,0,1],[8],[7]] \\n\\nThe condition is that If two nodes are in the same row and column, the order should be from left to right.\\n\\nFor the example above, only 0 and 1 are in the same row and column, but 3 is not.  So both [[4],[9],[0,3,1],[8],[7]] and [[4],[9],[3,0,1],[8],[7]] should be correct answers."
                    },
                    {
                        "username": "elwerro",
                        "content": "https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/"
                    },
                    {
                        "username": "uzia35",
                        "content": "The priority for the answer is left to right for columns and top to bottom for the rows. The rows should be mentioned just in case. "
                    },
                    {
                        "username": "joxamo",
                        "content": "So I tried solving this problem using the following recursive function and it came out wrong.\n\nvar verticalOrder = function(root) {\n    if (!root) {\n        return [];\n    }\n\n    const columnMap = new Map(); // Map to store nodes in each column\n\n    // Helper function for recursive traversal\n    function dfs(node, col) {\n        if (!node) {\n            return;\n        }\n\n        if (!columnMap.has(col)) {\n            columnMap.set(col, []);\n        }\n\n\n        columnMap.get(col).push(node.val);\n\n        dfs(node.left, col - 1);\n        dfs(node.right, col + 1);\n    }\n\n    // Start the recursive traversal with the root at column 0\n    dfs(root, 0);\n\n    // Sort the columns in ascending order\n    const sortedColumns = [...columnMap.keys()].sort((a, b) => a - b);\n\n    // Create the result array\n    const result = sortedColumns.map(col => columnMap.get(col));\n\n    return result;\n};\n\nIt claimed my output was incorrect compared to the test case:\nexpected:\n[[4],[9,5],[3,0,1],[8,2],[7]]\noutput:\n[[4],[9,5],[3,0,1],[2,8],[7]]\n\nI was skeptical of this test result, so I decided to create the tree on my own in codepen\n\n\nlet root = new TreeNode();\nroot.val = 3\nroot.left = new TreeNode(9);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(0);\nroot.left.right.left = new TreeNode(5);\nroot.right = new TreeNode(8);\nroot.right.left = new TreeNode(1);\nroot.right.left.right = new TreeNode(2);\nroot.right.right = new TreeNode(7);\n\nAfter doing this, my output came back correct as expected. Is there something wrong with that test case?"
                    },
                    {
                        "username": "brett_davis",
                        "content": "Am I misunderstanding or is the third example not set up correctly?\n\n[3,9,8,4,0,1,7,null,null,null,2,5]\n\n3 - > 9, 8\n9 -> 4, 0\n8 -> 1, 7\n4 -> null, null\n0 -> null, 2\n1 -> 5\n\n2 is supposed to be the right child of 1\n\nI would think the input  has to be: [3,9,8,4,0,1,7,null,null,5, null, null, 2]\n"
                    }
                ]
            },
            {
                "id": 2076154,
                "content": [
                    {
                        "username": "mazyla",
                        "content": "Input:\\n[3,9,8,4,0,1,7,null,null,null,2,5]\\nExpected answer: [ [4], [9,5], [3,0,1], [8,2], [7] ]\\n\\nBut the question says if 2 nodes have the same horizontal distance, then order should be left to right, while the expected answer is right node first, in the case of 8 and 2.\\n\\nIsn\\'t the right answer actually: [ [4], [9,5], [3,0,1], [2,8], [7] ]"
                    },
                    {
                        "username": "heavenfish",
                        "content": "It asked to travel from top to bottom and left to right. Therefore, 8 should come first as it is on top of 2."
                    },
                    {
                        "username": "fyh8238865",
                        "content": "In the problem, they asked us to do vertical order traversal, but what does the \"vertical order\" mean? I think the problem do not state it well.\\n\\nFor example, in the following case: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\\n\\nShould the 1,11,12 be on the same horizontal position?\\n\\nBased on my intuition, the position of the node in a tree will changed based on their deep and number of nodes in each layer. Because I think the position is not absolute value. So the upper case, I said yes. But for the real test case, they said no. \\n\\nTherefore, I think the problem should clarify what is their definition of the position or vertical order.\\n\\nIf anyone think what I said has something wrong, please correct me."
                    },
                    {
                        "username": "mlblount45",
                        "content": "What would the output look like for a tree of height 4?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Vertical Order traversal variations:\\n- If question was just to find nodes in the same column (where nodes in a column could be from top to bottom OR bottom to top or random): dfs would be enough. But that is not really a vertical order traversal. I mistakenly used dfs first to find out later in my answer the nodes in the same column were not arranged from top to bottom.\\n- LC 314: Vertical order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be from left to right. TreeMap with horizontalDistance as key helped solving this.\\n- LC 987: Vertival Order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be smaller value should come in first. TreeMap with horizontalDistance as key and value being \\'TreeMap with height as key and value being TreeSet for sorting by node value\\' helped solving this \\n\\nI came up with the solutions on my own. Go through my 1st accpeted submission for each question. There might be optimizations in LC solutions. I didnt look at it yet. Have a look some day when you get time.\\n\\n**Note: This is an application of Level Order Traversal**"
                    },
                    {
                        "username": "Lakpro",
                        "content": "**SIMILAR QUESTIONS**\\n\\n**[314. Binary Tree Vertical Order Traversal: ](https://leetcode.com/problems/binary-tree-vertical-order-traversal/description/)** (Here, we have to return nodes in the same column as left to right)\\n\\n**[987. Vertical Order Traversal of a Binary Tree: ](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/987)** (Here, we have to return nodes in the same column in  sorted order.)"
                    },
                    {
                        "username": "huangguoqiang",
                        "content": "Input:\\n[3,9,8,4,0,1,7]\\nOutput:\\n[[4],[9],[0,3,1],[8],[7]]\\nExpected:\\n[[4],[9],[3,0,1],[8],[7]] \\n\\nThe condition is that If two nodes are in the same row and column, the order should be from left to right.\\n\\nFor the example above, only 0 and 1 are in the same row and column, but 3 is not.  So both [[4],[9],[0,3,1],[8],[7]] and [[4],[9],[3,0,1],[8],[7]] should be correct answers."
                    },
                    {
                        "username": "elwerro",
                        "content": "https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/"
                    },
                    {
                        "username": "uzia35",
                        "content": "The priority for the answer is left to right for columns and top to bottom for the rows. The rows should be mentioned just in case. "
                    },
                    {
                        "username": "joxamo",
                        "content": "So I tried solving this problem using the following recursive function and it came out wrong.\n\nvar verticalOrder = function(root) {\n    if (!root) {\n        return [];\n    }\n\n    const columnMap = new Map(); // Map to store nodes in each column\n\n    // Helper function for recursive traversal\n    function dfs(node, col) {\n        if (!node) {\n            return;\n        }\n\n        if (!columnMap.has(col)) {\n            columnMap.set(col, []);\n        }\n\n\n        columnMap.get(col).push(node.val);\n\n        dfs(node.left, col - 1);\n        dfs(node.right, col + 1);\n    }\n\n    // Start the recursive traversal with the root at column 0\n    dfs(root, 0);\n\n    // Sort the columns in ascending order\n    const sortedColumns = [...columnMap.keys()].sort((a, b) => a - b);\n\n    // Create the result array\n    const result = sortedColumns.map(col => columnMap.get(col));\n\n    return result;\n};\n\nIt claimed my output was incorrect compared to the test case:\nexpected:\n[[4],[9,5],[3,0,1],[8,2],[7]]\noutput:\n[[4],[9,5],[3,0,1],[2,8],[7]]\n\nI was skeptical of this test result, so I decided to create the tree on my own in codepen\n\n\nlet root = new TreeNode();\nroot.val = 3\nroot.left = new TreeNode(9);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(0);\nroot.left.right.left = new TreeNode(5);\nroot.right = new TreeNode(8);\nroot.right.left = new TreeNode(1);\nroot.right.left.right = new TreeNode(2);\nroot.right.right = new TreeNode(7);\n\nAfter doing this, my output came back correct as expected. Is there something wrong with that test case?"
                    },
                    {
                        "username": "brett_davis",
                        "content": "Am I misunderstanding or is the third example not set up correctly?\n\n[3,9,8,4,0,1,7,null,null,null,2,5]\n\n3 - > 9, 8\n9 -> 4, 0\n8 -> 1, 7\n4 -> null, null\n0 -> null, 2\n1 -> 5\n\n2 is supposed to be the right child of 1\n\nI would think the input  has to be: [3,9,8,4,0,1,7,null,null,5, null, null, 2]\n"
                    }
                ]
            },
            {
                "id": 2065098,
                "content": [
                    {
                        "username": "mazyla",
                        "content": "Input:\\n[3,9,8,4,0,1,7,null,null,null,2,5]\\nExpected answer: [ [4], [9,5], [3,0,1], [8,2], [7] ]\\n\\nBut the question says if 2 nodes have the same horizontal distance, then order should be left to right, while the expected answer is right node first, in the case of 8 and 2.\\n\\nIsn\\'t the right answer actually: [ [4], [9,5], [3,0,1], [2,8], [7] ]"
                    },
                    {
                        "username": "heavenfish",
                        "content": "It asked to travel from top to bottom and left to right. Therefore, 8 should come first as it is on top of 2."
                    },
                    {
                        "username": "fyh8238865",
                        "content": "In the problem, they asked us to do vertical order traversal, but what does the \"vertical order\" mean? I think the problem do not state it well.\\n\\nFor example, in the following case: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\\n\\nShould the 1,11,12 be on the same horizontal position?\\n\\nBased on my intuition, the position of the node in a tree will changed based on their deep and number of nodes in each layer. Because I think the position is not absolute value. So the upper case, I said yes. But for the real test case, they said no. \\n\\nTherefore, I think the problem should clarify what is their definition of the position or vertical order.\\n\\nIf anyone think what I said has something wrong, please correct me."
                    },
                    {
                        "username": "mlblount45",
                        "content": "What would the output look like for a tree of height 4?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Vertical Order traversal variations:\\n- If question was just to find nodes in the same column (where nodes in a column could be from top to bottom OR bottom to top or random): dfs would be enough. But that is not really a vertical order traversal. I mistakenly used dfs first to find out later in my answer the nodes in the same column were not arranged from top to bottom.\\n- LC 314: Vertical order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be from left to right. TreeMap with horizontalDistance as key helped solving this.\\n- LC 987: Vertival Order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be smaller value should come in first. TreeMap with horizontalDistance as key and value being \\'TreeMap with height as key and value being TreeSet for sorting by node value\\' helped solving this \\n\\nI came up with the solutions on my own. Go through my 1st accpeted submission for each question. There might be optimizations in LC solutions. I didnt look at it yet. Have a look some day when you get time.\\n\\n**Note: This is an application of Level Order Traversal**"
                    },
                    {
                        "username": "Lakpro",
                        "content": "**SIMILAR QUESTIONS**\\n\\n**[314. Binary Tree Vertical Order Traversal: ](https://leetcode.com/problems/binary-tree-vertical-order-traversal/description/)** (Here, we have to return nodes in the same column as left to right)\\n\\n**[987. Vertical Order Traversal of a Binary Tree: ](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/987)** (Here, we have to return nodes in the same column in  sorted order.)"
                    },
                    {
                        "username": "huangguoqiang",
                        "content": "Input:\\n[3,9,8,4,0,1,7]\\nOutput:\\n[[4],[9],[0,3,1],[8],[7]]\\nExpected:\\n[[4],[9],[3,0,1],[8],[7]] \\n\\nThe condition is that If two nodes are in the same row and column, the order should be from left to right.\\n\\nFor the example above, only 0 and 1 are in the same row and column, but 3 is not.  So both [[4],[9],[0,3,1],[8],[7]] and [[4],[9],[3,0,1],[8],[7]] should be correct answers."
                    },
                    {
                        "username": "elwerro",
                        "content": "https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/"
                    },
                    {
                        "username": "uzia35",
                        "content": "The priority for the answer is left to right for columns and top to bottom for the rows. The rows should be mentioned just in case. "
                    },
                    {
                        "username": "joxamo",
                        "content": "So I tried solving this problem using the following recursive function and it came out wrong.\n\nvar verticalOrder = function(root) {\n    if (!root) {\n        return [];\n    }\n\n    const columnMap = new Map(); // Map to store nodes in each column\n\n    // Helper function for recursive traversal\n    function dfs(node, col) {\n        if (!node) {\n            return;\n        }\n\n        if (!columnMap.has(col)) {\n            columnMap.set(col, []);\n        }\n\n\n        columnMap.get(col).push(node.val);\n\n        dfs(node.left, col - 1);\n        dfs(node.right, col + 1);\n    }\n\n    // Start the recursive traversal with the root at column 0\n    dfs(root, 0);\n\n    // Sort the columns in ascending order\n    const sortedColumns = [...columnMap.keys()].sort((a, b) => a - b);\n\n    // Create the result array\n    const result = sortedColumns.map(col => columnMap.get(col));\n\n    return result;\n};\n\nIt claimed my output was incorrect compared to the test case:\nexpected:\n[[4],[9,5],[3,0,1],[8,2],[7]]\noutput:\n[[4],[9,5],[3,0,1],[2,8],[7]]\n\nI was skeptical of this test result, so I decided to create the tree on my own in codepen\n\n\nlet root = new TreeNode();\nroot.val = 3\nroot.left = new TreeNode(9);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(0);\nroot.left.right.left = new TreeNode(5);\nroot.right = new TreeNode(8);\nroot.right.left = new TreeNode(1);\nroot.right.left.right = new TreeNode(2);\nroot.right.right = new TreeNode(7);\n\nAfter doing this, my output came back correct as expected. Is there something wrong with that test case?"
                    },
                    {
                        "username": "brett_davis",
                        "content": "Am I misunderstanding or is the third example not set up correctly?\n\n[3,9,8,4,0,1,7,null,null,null,2,5]\n\n3 - > 9, 8\n9 -> 4, 0\n8 -> 1, 7\n4 -> null, null\n0 -> null, 2\n1 -> 5\n\n2 is supposed to be the right child of 1\n\nI would think the input  has to be: [3,9,8,4,0,1,7,null,null,5, null, null, 2]\n"
                    }
                ]
            },
            {
                "id": 2059448,
                "content": [
                    {
                        "username": "mazyla",
                        "content": "Input:\\n[3,9,8,4,0,1,7,null,null,null,2,5]\\nExpected answer: [ [4], [9,5], [3,0,1], [8,2], [7] ]\\n\\nBut the question says if 2 nodes have the same horizontal distance, then order should be left to right, while the expected answer is right node first, in the case of 8 and 2.\\n\\nIsn\\'t the right answer actually: [ [4], [9,5], [3,0,1], [2,8], [7] ]"
                    },
                    {
                        "username": "heavenfish",
                        "content": "It asked to travel from top to bottom and left to right. Therefore, 8 should come first as it is on top of 2."
                    },
                    {
                        "username": "fyh8238865",
                        "content": "In the problem, they asked us to do vertical order traversal, but what does the \"vertical order\" mean? I think the problem do not state it well.\\n\\nFor example, in the following case: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\\n\\nShould the 1,11,12 be on the same horizontal position?\\n\\nBased on my intuition, the position of the node in a tree will changed based on their deep and number of nodes in each layer. Because I think the position is not absolute value. So the upper case, I said yes. But for the real test case, they said no. \\n\\nTherefore, I think the problem should clarify what is their definition of the position or vertical order.\\n\\nIf anyone think what I said has something wrong, please correct me."
                    },
                    {
                        "username": "mlblount45",
                        "content": "What would the output look like for a tree of height 4?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Vertical Order traversal variations:\\n- If question was just to find nodes in the same column (where nodes in a column could be from top to bottom OR bottom to top or random): dfs would be enough. But that is not really a vertical order traversal. I mistakenly used dfs first to find out later in my answer the nodes in the same column were not arranged from top to bottom.\\n- LC 314: Vertical order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be from left to right. TreeMap with horizontalDistance as key helped solving this.\\n- LC 987: Vertival Order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be smaller value should come in first. TreeMap with horizontalDistance as key and value being \\'TreeMap with height as key and value being TreeSet for sorting by node value\\' helped solving this \\n\\nI came up with the solutions on my own. Go through my 1st accpeted submission for each question. There might be optimizations in LC solutions. I didnt look at it yet. Have a look some day when you get time.\\n\\n**Note: This is an application of Level Order Traversal**"
                    },
                    {
                        "username": "Lakpro",
                        "content": "**SIMILAR QUESTIONS**\\n\\n**[314. Binary Tree Vertical Order Traversal: ](https://leetcode.com/problems/binary-tree-vertical-order-traversal/description/)** (Here, we have to return nodes in the same column as left to right)\\n\\n**[987. Vertical Order Traversal of a Binary Tree: ](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/987)** (Here, we have to return nodes in the same column in  sorted order.)"
                    },
                    {
                        "username": "huangguoqiang",
                        "content": "Input:\\n[3,9,8,4,0,1,7]\\nOutput:\\n[[4],[9],[0,3,1],[8],[7]]\\nExpected:\\n[[4],[9],[3,0,1],[8],[7]] \\n\\nThe condition is that If two nodes are in the same row and column, the order should be from left to right.\\n\\nFor the example above, only 0 and 1 are in the same row and column, but 3 is not.  So both [[4],[9],[0,3,1],[8],[7]] and [[4],[9],[3,0,1],[8],[7]] should be correct answers."
                    },
                    {
                        "username": "elwerro",
                        "content": "https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/"
                    },
                    {
                        "username": "uzia35",
                        "content": "The priority for the answer is left to right for columns and top to bottom for the rows. The rows should be mentioned just in case. "
                    },
                    {
                        "username": "joxamo",
                        "content": "So I tried solving this problem using the following recursive function and it came out wrong.\n\nvar verticalOrder = function(root) {\n    if (!root) {\n        return [];\n    }\n\n    const columnMap = new Map(); // Map to store nodes in each column\n\n    // Helper function for recursive traversal\n    function dfs(node, col) {\n        if (!node) {\n            return;\n        }\n\n        if (!columnMap.has(col)) {\n            columnMap.set(col, []);\n        }\n\n\n        columnMap.get(col).push(node.val);\n\n        dfs(node.left, col - 1);\n        dfs(node.right, col + 1);\n    }\n\n    // Start the recursive traversal with the root at column 0\n    dfs(root, 0);\n\n    // Sort the columns in ascending order\n    const sortedColumns = [...columnMap.keys()].sort((a, b) => a - b);\n\n    // Create the result array\n    const result = sortedColumns.map(col => columnMap.get(col));\n\n    return result;\n};\n\nIt claimed my output was incorrect compared to the test case:\nexpected:\n[[4],[9,5],[3,0,1],[8,2],[7]]\noutput:\n[[4],[9,5],[3,0,1],[2,8],[7]]\n\nI was skeptical of this test result, so I decided to create the tree on my own in codepen\n\n\nlet root = new TreeNode();\nroot.val = 3\nroot.left = new TreeNode(9);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(0);\nroot.left.right.left = new TreeNode(5);\nroot.right = new TreeNode(8);\nroot.right.left = new TreeNode(1);\nroot.right.left.right = new TreeNode(2);\nroot.right.right = new TreeNode(7);\n\nAfter doing this, my output came back correct as expected. Is there something wrong with that test case?"
                    },
                    {
                        "username": "brett_davis",
                        "content": "Am I misunderstanding or is the third example not set up correctly?\n\n[3,9,8,4,0,1,7,null,null,null,2,5]\n\n3 - > 9, 8\n9 -> 4, 0\n8 -> 1, 7\n4 -> null, null\n0 -> null, 2\n1 -> 5\n\n2 is supposed to be the right child of 1\n\nI would think the input  has to be: [3,9,8,4,0,1,7,null,null,5, null, null, 2]\n"
                    }
                ]
            },
            {
                "id": 2037194,
                "content": [
                    {
                        "username": "mazyla",
                        "content": "Input:\\n[3,9,8,4,0,1,7,null,null,null,2,5]\\nExpected answer: [ [4], [9,5], [3,0,1], [8,2], [7] ]\\n\\nBut the question says if 2 nodes have the same horizontal distance, then order should be left to right, while the expected answer is right node first, in the case of 8 and 2.\\n\\nIsn\\'t the right answer actually: [ [4], [9,5], [3,0,1], [2,8], [7] ]"
                    },
                    {
                        "username": "heavenfish",
                        "content": "It asked to travel from top to bottom and left to right. Therefore, 8 should come first as it is on top of 2."
                    },
                    {
                        "username": "fyh8238865",
                        "content": "In the problem, they asked us to do vertical order traversal, but what does the \"vertical order\" mean? I think the problem do not state it well.\\n\\nFor example, in the following case: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\\n\\nShould the 1,11,12 be on the same horizontal position?\\n\\nBased on my intuition, the position of the node in a tree will changed based on their deep and number of nodes in each layer. Because I think the position is not absolute value. So the upper case, I said yes. But for the real test case, they said no. \\n\\nTherefore, I think the problem should clarify what is their definition of the position or vertical order.\\n\\nIf anyone think what I said has something wrong, please correct me."
                    },
                    {
                        "username": "mlblount45",
                        "content": "What would the output look like for a tree of height 4?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Vertical Order traversal variations:\\n- If question was just to find nodes in the same column (where nodes in a column could be from top to bottom OR bottom to top or random): dfs would be enough. But that is not really a vertical order traversal. I mistakenly used dfs first to find out later in my answer the nodes in the same column were not arranged from top to bottom.\\n- LC 314: Vertical order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be from left to right. TreeMap with horizontalDistance as key helped solving this.\\n- LC 987: Vertival Order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be smaller value should come in first. TreeMap with horizontalDistance as key and value being \\'TreeMap with height as key and value being TreeSet for sorting by node value\\' helped solving this \\n\\nI came up with the solutions on my own. Go through my 1st accpeted submission for each question. There might be optimizations in LC solutions. I didnt look at it yet. Have a look some day when you get time.\\n\\n**Note: This is an application of Level Order Traversal**"
                    },
                    {
                        "username": "Lakpro",
                        "content": "**SIMILAR QUESTIONS**\\n\\n**[314. Binary Tree Vertical Order Traversal: ](https://leetcode.com/problems/binary-tree-vertical-order-traversal/description/)** (Here, we have to return nodes in the same column as left to right)\\n\\n**[987. Vertical Order Traversal of a Binary Tree: ](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/987)** (Here, we have to return nodes in the same column in  sorted order.)"
                    },
                    {
                        "username": "huangguoqiang",
                        "content": "Input:\\n[3,9,8,4,0,1,7]\\nOutput:\\n[[4],[9],[0,3,1],[8],[7]]\\nExpected:\\n[[4],[9],[3,0,1],[8],[7]] \\n\\nThe condition is that If two nodes are in the same row and column, the order should be from left to right.\\n\\nFor the example above, only 0 and 1 are in the same row and column, but 3 is not.  So both [[4],[9],[0,3,1],[8],[7]] and [[4],[9],[3,0,1],[8],[7]] should be correct answers."
                    },
                    {
                        "username": "elwerro",
                        "content": "https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/"
                    },
                    {
                        "username": "uzia35",
                        "content": "The priority for the answer is left to right for columns and top to bottom for the rows. The rows should be mentioned just in case. "
                    },
                    {
                        "username": "joxamo",
                        "content": "So I tried solving this problem using the following recursive function and it came out wrong.\n\nvar verticalOrder = function(root) {\n    if (!root) {\n        return [];\n    }\n\n    const columnMap = new Map(); // Map to store nodes in each column\n\n    // Helper function for recursive traversal\n    function dfs(node, col) {\n        if (!node) {\n            return;\n        }\n\n        if (!columnMap.has(col)) {\n            columnMap.set(col, []);\n        }\n\n\n        columnMap.get(col).push(node.val);\n\n        dfs(node.left, col - 1);\n        dfs(node.right, col + 1);\n    }\n\n    // Start the recursive traversal with the root at column 0\n    dfs(root, 0);\n\n    // Sort the columns in ascending order\n    const sortedColumns = [...columnMap.keys()].sort((a, b) => a - b);\n\n    // Create the result array\n    const result = sortedColumns.map(col => columnMap.get(col));\n\n    return result;\n};\n\nIt claimed my output was incorrect compared to the test case:\nexpected:\n[[4],[9,5],[3,0,1],[8,2],[7]]\noutput:\n[[4],[9,5],[3,0,1],[2,8],[7]]\n\nI was skeptical of this test result, so I decided to create the tree on my own in codepen\n\n\nlet root = new TreeNode();\nroot.val = 3\nroot.left = new TreeNode(9);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(0);\nroot.left.right.left = new TreeNode(5);\nroot.right = new TreeNode(8);\nroot.right.left = new TreeNode(1);\nroot.right.left.right = new TreeNode(2);\nroot.right.right = new TreeNode(7);\n\nAfter doing this, my output came back correct as expected. Is there something wrong with that test case?"
                    },
                    {
                        "username": "brett_davis",
                        "content": "Am I misunderstanding or is the third example not set up correctly?\n\n[3,9,8,4,0,1,7,null,null,null,2,5]\n\n3 - > 9, 8\n9 -> 4, 0\n8 -> 1, 7\n4 -> null, null\n0 -> null, 2\n1 -> 5\n\n2 is supposed to be the right child of 1\n\nI would think the input  has to be: [3,9,8,4,0,1,7,null,null,5, null, null, 2]\n"
                    }
                ]
            },
            {
                "id": 1572528,
                "content": [
                    {
                        "username": "mazyla",
                        "content": "Input:\\n[3,9,8,4,0,1,7,null,null,null,2,5]\\nExpected answer: [ [4], [9,5], [3,0,1], [8,2], [7] ]\\n\\nBut the question says if 2 nodes have the same horizontal distance, then order should be left to right, while the expected answer is right node first, in the case of 8 and 2.\\n\\nIsn\\'t the right answer actually: [ [4], [9,5], [3,0,1], [2,8], [7] ]"
                    },
                    {
                        "username": "heavenfish",
                        "content": "It asked to travel from top to bottom and left to right. Therefore, 8 should come first as it is on top of 2."
                    },
                    {
                        "username": "fyh8238865",
                        "content": "In the problem, they asked us to do vertical order traversal, but what does the \"vertical order\" mean? I think the problem do not state it well.\\n\\nFor example, in the following case: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\\n\\nShould the 1,11,12 be on the same horizontal position?\\n\\nBased on my intuition, the position of the node in a tree will changed based on their deep and number of nodes in each layer. Because I think the position is not absolute value. So the upper case, I said yes. But for the real test case, they said no. \\n\\nTherefore, I think the problem should clarify what is their definition of the position or vertical order.\\n\\nIf anyone think what I said has something wrong, please correct me."
                    },
                    {
                        "username": "mlblount45",
                        "content": "What would the output look like for a tree of height 4?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Vertical Order traversal variations:\\n- If question was just to find nodes in the same column (where nodes in a column could be from top to bottom OR bottom to top or random): dfs would be enough. But that is not really a vertical order traversal. I mistakenly used dfs first to find out later in my answer the nodes in the same column were not arranged from top to bottom.\\n- LC 314: Vertical order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be from left to right. TreeMap with horizontalDistance as key helped solving this.\\n- LC 987: Vertival Order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be smaller value should come in first. TreeMap with horizontalDistance as key and value being \\'TreeMap with height as key and value being TreeSet for sorting by node value\\' helped solving this \\n\\nI came up with the solutions on my own. Go through my 1st accpeted submission for each question. There might be optimizations in LC solutions. I didnt look at it yet. Have a look some day when you get time.\\n\\n**Note: This is an application of Level Order Traversal**"
                    },
                    {
                        "username": "Lakpro",
                        "content": "**SIMILAR QUESTIONS**\\n\\n**[314. Binary Tree Vertical Order Traversal: ](https://leetcode.com/problems/binary-tree-vertical-order-traversal/description/)** (Here, we have to return nodes in the same column as left to right)\\n\\n**[987. Vertical Order Traversal of a Binary Tree: ](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/987)** (Here, we have to return nodes in the same column in  sorted order.)"
                    },
                    {
                        "username": "huangguoqiang",
                        "content": "Input:\\n[3,9,8,4,0,1,7]\\nOutput:\\n[[4],[9],[0,3,1],[8],[7]]\\nExpected:\\n[[4],[9],[3,0,1],[8],[7]] \\n\\nThe condition is that If two nodes are in the same row and column, the order should be from left to right.\\n\\nFor the example above, only 0 and 1 are in the same row and column, but 3 is not.  So both [[4],[9],[0,3,1],[8],[7]] and [[4],[9],[3,0,1],[8],[7]] should be correct answers."
                    },
                    {
                        "username": "elwerro",
                        "content": "https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/"
                    },
                    {
                        "username": "uzia35",
                        "content": "The priority for the answer is left to right for columns and top to bottom for the rows. The rows should be mentioned just in case. "
                    },
                    {
                        "username": "joxamo",
                        "content": "So I tried solving this problem using the following recursive function and it came out wrong.\n\nvar verticalOrder = function(root) {\n    if (!root) {\n        return [];\n    }\n\n    const columnMap = new Map(); // Map to store nodes in each column\n\n    // Helper function for recursive traversal\n    function dfs(node, col) {\n        if (!node) {\n            return;\n        }\n\n        if (!columnMap.has(col)) {\n            columnMap.set(col, []);\n        }\n\n\n        columnMap.get(col).push(node.val);\n\n        dfs(node.left, col - 1);\n        dfs(node.right, col + 1);\n    }\n\n    // Start the recursive traversal with the root at column 0\n    dfs(root, 0);\n\n    // Sort the columns in ascending order\n    const sortedColumns = [...columnMap.keys()].sort((a, b) => a - b);\n\n    // Create the result array\n    const result = sortedColumns.map(col => columnMap.get(col));\n\n    return result;\n};\n\nIt claimed my output was incorrect compared to the test case:\nexpected:\n[[4],[9,5],[3,0,1],[8,2],[7]]\noutput:\n[[4],[9,5],[3,0,1],[2,8],[7]]\n\nI was skeptical of this test result, so I decided to create the tree on my own in codepen\n\n\nlet root = new TreeNode();\nroot.val = 3\nroot.left = new TreeNode(9);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(0);\nroot.left.right.left = new TreeNode(5);\nroot.right = new TreeNode(8);\nroot.right.left = new TreeNode(1);\nroot.right.left.right = new TreeNode(2);\nroot.right.right = new TreeNode(7);\n\nAfter doing this, my output came back correct as expected. Is there something wrong with that test case?"
                    },
                    {
                        "username": "brett_davis",
                        "content": "Am I misunderstanding or is the third example not set up correctly?\n\n[3,9,8,4,0,1,7,null,null,null,2,5]\n\n3 - > 9, 8\n9 -> 4, 0\n8 -> 1, 7\n4 -> null, null\n0 -> null, 2\n1 -> 5\n\n2 is supposed to be the right child of 1\n\nI would think the input  has to be: [3,9,8,4,0,1,7,null,null,5, null, null, 2]\n"
                    }
                ]
            },
            {
                "id": 1566777,
                "content": [
                    {
                        "username": "mazyla",
                        "content": "Input:\\n[3,9,8,4,0,1,7,null,null,null,2,5]\\nExpected answer: [ [4], [9,5], [3,0,1], [8,2], [7] ]\\n\\nBut the question says if 2 nodes have the same horizontal distance, then order should be left to right, while the expected answer is right node first, in the case of 8 and 2.\\n\\nIsn\\'t the right answer actually: [ [4], [9,5], [3,0,1], [2,8], [7] ]"
                    },
                    {
                        "username": "heavenfish",
                        "content": "It asked to travel from top to bottom and left to right. Therefore, 8 should come first as it is on top of 2."
                    },
                    {
                        "username": "fyh8238865",
                        "content": "In the problem, they asked us to do vertical order traversal, but what does the \"vertical order\" mean? I think the problem do not state it well.\\n\\nFor example, in the following case: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\\n\\nShould the 1,11,12 be on the same horizontal position?\\n\\nBased on my intuition, the position of the node in a tree will changed based on their deep and number of nodes in each layer. Because I think the position is not absolute value. So the upper case, I said yes. But for the real test case, they said no. \\n\\nTherefore, I think the problem should clarify what is their definition of the position or vertical order.\\n\\nIf anyone think what I said has something wrong, please correct me."
                    },
                    {
                        "username": "mlblount45",
                        "content": "What would the output look like for a tree of height 4?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Vertical Order traversal variations:\\n- If question was just to find nodes in the same column (where nodes in a column could be from top to bottom OR bottom to top or random): dfs would be enough. But that is not really a vertical order traversal. I mistakenly used dfs first to find out later in my answer the nodes in the same column were not arranged from top to bottom.\\n- LC 314: Vertical order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be from left to right. TreeMap with horizontalDistance as key helped solving this.\\n- LC 987: Vertival Order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be smaller value should come in first. TreeMap with horizontalDistance as key and value being \\'TreeMap with height as key and value being TreeSet for sorting by node value\\' helped solving this \\n\\nI came up with the solutions on my own. Go through my 1st accpeted submission for each question. There might be optimizations in LC solutions. I didnt look at it yet. Have a look some day when you get time.\\n\\n**Note: This is an application of Level Order Traversal**"
                    },
                    {
                        "username": "Lakpro",
                        "content": "**SIMILAR QUESTIONS**\\n\\n**[314. Binary Tree Vertical Order Traversal: ](https://leetcode.com/problems/binary-tree-vertical-order-traversal/description/)** (Here, we have to return nodes in the same column as left to right)\\n\\n**[987. Vertical Order Traversal of a Binary Tree: ](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/987)** (Here, we have to return nodes in the same column in  sorted order.)"
                    },
                    {
                        "username": "huangguoqiang",
                        "content": "Input:\\n[3,9,8,4,0,1,7]\\nOutput:\\n[[4],[9],[0,3,1],[8],[7]]\\nExpected:\\n[[4],[9],[3,0,1],[8],[7]] \\n\\nThe condition is that If two nodes are in the same row and column, the order should be from left to right.\\n\\nFor the example above, only 0 and 1 are in the same row and column, but 3 is not.  So both [[4],[9],[0,3,1],[8],[7]] and [[4],[9],[3,0,1],[8],[7]] should be correct answers."
                    },
                    {
                        "username": "elwerro",
                        "content": "https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/"
                    },
                    {
                        "username": "uzia35",
                        "content": "The priority for the answer is left to right for columns and top to bottom for the rows. The rows should be mentioned just in case. "
                    },
                    {
                        "username": "joxamo",
                        "content": "So I tried solving this problem using the following recursive function and it came out wrong.\n\nvar verticalOrder = function(root) {\n    if (!root) {\n        return [];\n    }\n\n    const columnMap = new Map(); // Map to store nodes in each column\n\n    // Helper function for recursive traversal\n    function dfs(node, col) {\n        if (!node) {\n            return;\n        }\n\n        if (!columnMap.has(col)) {\n            columnMap.set(col, []);\n        }\n\n\n        columnMap.get(col).push(node.val);\n\n        dfs(node.left, col - 1);\n        dfs(node.right, col + 1);\n    }\n\n    // Start the recursive traversal with the root at column 0\n    dfs(root, 0);\n\n    // Sort the columns in ascending order\n    const sortedColumns = [...columnMap.keys()].sort((a, b) => a - b);\n\n    // Create the result array\n    const result = sortedColumns.map(col => columnMap.get(col));\n\n    return result;\n};\n\nIt claimed my output was incorrect compared to the test case:\nexpected:\n[[4],[9,5],[3,0,1],[8,2],[7]]\noutput:\n[[4],[9,5],[3,0,1],[2,8],[7]]\n\nI was skeptical of this test result, so I decided to create the tree on my own in codepen\n\n\nlet root = new TreeNode();\nroot.val = 3\nroot.left = new TreeNode(9);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(0);\nroot.left.right.left = new TreeNode(5);\nroot.right = new TreeNode(8);\nroot.right.left = new TreeNode(1);\nroot.right.left.right = new TreeNode(2);\nroot.right.right = new TreeNode(7);\n\nAfter doing this, my output came back correct as expected. Is there something wrong with that test case?"
                    },
                    {
                        "username": "brett_davis",
                        "content": "Am I misunderstanding or is the third example not set up correctly?\n\n[3,9,8,4,0,1,7,null,null,null,2,5]\n\n3 - > 9, 8\n9 -> 4, 0\n8 -> 1, 7\n4 -> null, null\n0 -> null, 2\n1 -> 5\n\n2 is supposed to be the right child of 1\n\nI would think the input  has to be: [3,9,8,4,0,1,7,null,null,5, null, null, 2]\n"
                    }
                ]
            },
            {
                "id": 1571565,
                "content": [
                    {
                        "username": "mazyla",
                        "content": "Input:\\n[3,9,8,4,0,1,7,null,null,null,2,5]\\nExpected answer: [ [4], [9,5], [3,0,1], [8,2], [7] ]\\n\\nBut the question says if 2 nodes have the same horizontal distance, then order should be left to right, while the expected answer is right node first, in the case of 8 and 2.\\n\\nIsn\\'t the right answer actually: [ [4], [9,5], [3,0,1], [2,8], [7] ]"
                    },
                    {
                        "username": "heavenfish",
                        "content": "It asked to travel from top to bottom and left to right. Therefore, 8 should come first as it is on top of 2."
                    },
                    {
                        "username": "fyh8238865",
                        "content": "In the problem, they asked us to do vertical order traversal, but what does the \"vertical order\" mean? I think the problem do not state it well.\\n\\nFor example, in the following case: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\\n\\nShould the 1,11,12 be on the same horizontal position?\\n\\nBased on my intuition, the position of the node in a tree will changed based on their deep and number of nodes in each layer. Because I think the position is not absolute value. So the upper case, I said yes. But for the real test case, they said no. \\n\\nTherefore, I think the problem should clarify what is their definition of the position or vertical order.\\n\\nIf anyone think what I said has something wrong, please correct me."
                    },
                    {
                        "username": "mlblount45",
                        "content": "What would the output look like for a tree of height 4?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Vertical Order traversal variations:\\n- If question was just to find nodes in the same column (where nodes in a column could be from top to bottom OR bottom to top or random): dfs would be enough. But that is not really a vertical order traversal. I mistakenly used dfs first to find out later in my answer the nodes in the same column were not arranged from top to bottom.\\n- LC 314: Vertical order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be from left to right. TreeMap with horizontalDistance as key helped solving this.\\n- LC 987: Vertival Order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be smaller value should come in first. TreeMap with horizontalDistance as key and value being \\'TreeMap with height as key and value being TreeSet for sorting by node value\\' helped solving this \\n\\nI came up with the solutions on my own. Go through my 1st accpeted submission for each question. There might be optimizations in LC solutions. I didnt look at it yet. Have a look some day when you get time.\\n\\n**Note: This is an application of Level Order Traversal**"
                    },
                    {
                        "username": "Lakpro",
                        "content": "**SIMILAR QUESTIONS**\\n\\n**[314. Binary Tree Vertical Order Traversal: ](https://leetcode.com/problems/binary-tree-vertical-order-traversal/description/)** (Here, we have to return nodes in the same column as left to right)\\n\\n**[987. Vertical Order Traversal of a Binary Tree: ](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/987)** (Here, we have to return nodes in the same column in  sorted order.)"
                    },
                    {
                        "username": "huangguoqiang",
                        "content": "Input:\\n[3,9,8,4,0,1,7]\\nOutput:\\n[[4],[9],[0,3,1],[8],[7]]\\nExpected:\\n[[4],[9],[3,0,1],[8],[7]] \\n\\nThe condition is that If two nodes are in the same row and column, the order should be from left to right.\\n\\nFor the example above, only 0 and 1 are in the same row and column, but 3 is not.  So both [[4],[9],[0,3,1],[8],[7]] and [[4],[9],[3,0,1],[8],[7]] should be correct answers."
                    },
                    {
                        "username": "elwerro",
                        "content": "https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/"
                    },
                    {
                        "username": "uzia35",
                        "content": "The priority for the answer is left to right for columns and top to bottom for the rows. The rows should be mentioned just in case. "
                    },
                    {
                        "username": "joxamo",
                        "content": "So I tried solving this problem using the following recursive function and it came out wrong.\n\nvar verticalOrder = function(root) {\n    if (!root) {\n        return [];\n    }\n\n    const columnMap = new Map(); // Map to store nodes in each column\n\n    // Helper function for recursive traversal\n    function dfs(node, col) {\n        if (!node) {\n            return;\n        }\n\n        if (!columnMap.has(col)) {\n            columnMap.set(col, []);\n        }\n\n\n        columnMap.get(col).push(node.val);\n\n        dfs(node.left, col - 1);\n        dfs(node.right, col + 1);\n    }\n\n    // Start the recursive traversal with the root at column 0\n    dfs(root, 0);\n\n    // Sort the columns in ascending order\n    const sortedColumns = [...columnMap.keys()].sort((a, b) => a - b);\n\n    // Create the result array\n    const result = sortedColumns.map(col => columnMap.get(col));\n\n    return result;\n};\n\nIt claimed my output was incorrect compared to the test case:\nexpected:\n[[4],[9,5],[3,0,1],[8,2],[7]]\noutput:\n[[4],[9,5],[3,0,1],[2,8],[7]]\n\nI was skeptical of this test result, so I decided to create the tree on my own in codepen\n\n\nlet root = new TreeNode();\nroot.val = 3\nroot.left = new TreeNode(9);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(0);\nroot.left.right.left = new TreeNode(5);\nroot.right = new TreeNode(8);\nroot.right.left = new TreeNode(1);\nroot.right.left.right = new TreeNode(2);\nroot.right.right = new TreeNode(7);\n\nAfter doing this, my output came back correct as expected. Is there something wrong with that test case?"
                    },
                    {
                        "username": "brett_davis",
                        "content": "Am I misunderstanding or is the third example not set up correctly?\n\n[3,9,8,4,0,1,7,null,null,null,2,5]\n\n3 - > 9, 8\n9 -> 4, 0\n8 -> 1, 7\n4 -> null, null\n0 -> null, 2\n1 -> 5\n\n2 is supposed to be the right child of 1\n\nI would think the input  has to be: [3,9,8,4,0,1,7,null,null,5, null, null, 2]\n"
                    }
                ]
            },
            {
                "id": 1574633,
                "content": [
                    {
                        "username": "mazyla",
                        "content": "Input:\\n[3,9,8,4,0,1,7,null,null,null,2,5]\\nExpected answer: [ [4], [9,5], [3,0,1], [8,2], [7] ]\\n\\nBut the question says if 2 nodes have the same horizontal distance, then order should be left to right, while the expected answer is right node first, in the case of 8 and 2.\\n\\nIsn\\'t the right answer actually: [ [4], [9,5], [3,0,1], [2,8], [7] ]"
                    },
                    {
                        "username": "heavenfish",
                        "content": "It asked to travel from top to bottom and left to right. Therefore, 8 should come first as it is on top of 2."
                    },
                    {
                        "username": "fyh8238865",
                        "content": "In the problem, they asked us to do vertical order traversal, but what does the \"vertical order\" mean? I think the problem do not state it well.\\n\\nFor example, in the following case: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\\n\\nShould the 1,11,12 be on the same horizontal position?\\n\\nBased on my intuition, the position of the node in a tree will changed based on their deep and number of nodes in each layer. Because I think the position is not absolute value. So the upper case, I said yes. But for the real test case, they said no. \\n\\nTherefore, I think the problem should clarify what is their definition of the position or vertical order.\\n\\nIf anyone think what I said has something wrong, please correct me."
                    },
                    {
                        "username": "mlblount45",
                        "content": "What would the output look like for a tree of height 4?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Vertical Order traversal variations:\\n- If question was just to find nodes in the same column (where nodes in a column could be from top to bottom OR bottom to top or random): dfs would be enough. But that is not really a vertical order traversal. I mistakenly used dfs first to find out later in my answer the nodes in the same column were not arranged from top to bottom.\\n- LC 314: Vertical order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be from left to right. TreeMap with horizontalDistance as key helped solving this.\\n- LC 987: Vertival Order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be smaller value should come in first. TreeMap with horizontalDistance as key and value being \\'TreeMap with height as key and value being TreeSet for sorting by node value\\' helped solving this \\n\\nI came up with the solutions on my own. Go through my 1st accpeted submission for each question. There might be optimizations in LC solutions. I didnt look at it yet. Have a look some day when you get time.\\n\\n**Note: This is an application of Level Order Traversal**"
                    },
                    {
                        "username": "Lakpro",
                        "content": "**SIMILAR QUESTIONS**\\n\\n**[314. Binary Tree Vertical Order Traversal: ](https://leetcode.com/problems/binary-tree-vertical-order-traversal/description/)** (Here, we have to return nodes in the same column as left to right)\\n\\n**[987. Vertical Order Traversal of a Binary Tree: ](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/987)** (Here, we have to return nodes in the same column in  sorted order.)"
                    },
                    {
                        "username": "huangguoqiang",
                        "content": "Input:\\n[3,9,8,4,0,1,7]\\nOutput:\\n[[4],[9],[0,3,1],[8],[7]]\\nExpected:\\n[[4],[9],[3,0,1],[8],[7]] \\n\\nThe condition is that If two nodes are in the same row and column, the order should be from left to right.\\n\\nFor the example above, only 0 and 1 are in the same row and column, but 3 is not.  So both [[4],[9],[0,3,1],[8],[7]] and [[4],[9],[3,0,1],[8],[7]] should be correct answers."
                    },
                    {
                        "username": "elwerro",
                        "content": "https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/"
                    },
                    {
                        "username": "uzia35",
                        "content": "The priority for the answer is left to right for columns and top to bottom for the rows. The rows should be mentioned just in case. "
                    },
                    {
                        "username": "joxamo",
                        "content": "So I tried solving this problem using the following recursive function and it came out wrong.\n\nvar verticalOrder = function(root) {\n    if (!root) {\n        return [];\n    }\n\n    const columnMap = new Map(); // Map to store nodes in each column\n\n    // Helper function for recursive traversal\n    function dfs(node, col) {\n        if (!node) {\n            return;\n        }\n\n        if (!columnMap.has(col)) {\n            columnMap.set(col, []);\n        }\n\n\n        columnMap.get(col).push(node.val);\n\n        dfs(node.left, col - 1);\n        dfs(node.right, col + 1);\n    }\n\n    // Start the recursive traversal with the root at column 0\n    dfs(root, 0);\n\n    // Sort the columns in ascending order\n    const sortedColumns = [...columnMap.keys()].sort((a, b) => a - b);\n\n    // Create the result array\n    const result = sortedColumns.map(col => columnMap.get(col));\n\n    return result;\n};\n\nIt claimed my output was incorrect compared to the test case:\nexpected:\n[[4],[9,5],[3,0,1],[8,2],[7]]\noutput:\n[[4],[9,5],[3,0,1],[2,8],[7]]\n\nI was skeptical of this test result, so I decided to create the tree on my own in codepen\n\n\nlet root = new TreeNode();\nroot.val = 3\nroot.left = new TreeNode(9);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(0);\nroot.left.right.left = new TreeNode(5);\nroot.right = new TreeNode(8);\nroot.right.left = new TreeNode(1);\nroot.right.left.right = new TreeNode(2);\nroot.right.right = new TreeNode(7);\n\nAfter doing this, my output came back correct as expected. Is there something wrong with that test case?"
                    },
                    {
                        "username": "brett_davis",
                        "content": "Am I misunderstanding or is the third example not set up correctly?\n\n[3,9,8,4,0,1,7,null,null,null,2,5]\n\n3 - > 9, 8\n9 -> 4, 0\n8 -> 1, 7\n4 -> null, null\n0 -> null, 2\n1 -> 5\n\n2 is supposed to be the right child of 1\n\nI would think the input  has to be: [3,9,8,4,0,1,7,null,null,5, null, null, 2]\n"
                    }
                ]
            },
            {
                "id": 1833565,
                "content": [
                    {
                        "username": "mazyla",
                        "content": "Input:\\n[3,9,8,4,0,1,7,null,null,null,2,5]\\nExpected answer: [ [4], [9,5], [3,0,1], [8,2], [7] ]\\n\\nBut the question says if 2 nodes have the same horizontal distance, then order should be left to right, while the expected answer is right node first, in the case of 8 and 2.\\n\\nIsn\\'t the right answer actually: [ [4], [9,5], [3,0,1], [2,8], [7] ]"
                    },
                    {
                        "username": "heavenfish",
                        "content": "It asked to travel from top to bottom and left to right. Therefore, 8 should come first as it is on top of 2."
                    },
                    {
                        "username": "fyh8238865",
                        "content": "In the problem, they asked us to do vertical order traversal, but what does the \"vertical order\" mean? I think the problem do not state it well.\\n\\nFor example, in the following case: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\\n\\nShould the 1,11,12 be on the same horizontal position?\\n\\nBased on my intuition, the position of the node in a tree will changed based on their deep and number of nodes in each layer. Because I think the position is not absolute value. So the upper case, I said yes. But for the real test case, they said no. \\n\\nTherefore, I think the problem should clarify what is their definition of the position or vertical order.\\n\\nIf anyone think what I said has something wrong, please correct me."
                    },
                    {
                        "username": "mlblount45",
                        "content": "What would the output look like for a tree of height 4?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Vertical Order traversal variations:\\n- If question was just to find nodes in the same column (where nodes in a column could be from top to bottom OR bottom to top or random): dfs would be enough. But that is not really a vertical order traversal. I mistakenly used dfs first to find out later in my answer the nodes in the same column were not arranged from top to bottom.\\n- LC 314: Vertical order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be from left to right. TreeMap with horizontalDistance as key helped solving this.\\n- LC 987: Vertival Order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be smaller value should come in first. TreeMap with horizontalDistance as key and value being \\'TreeMap with height as key and value being TreeSet for sorting by node value\\' helped solving this \\n\\nI came up with the solutions on my own. Go through my 1st accpeted submission for each question. There might be optimizations in LC solutions. I didnt look at it yet. Have a look some day when you get time.\\n\\n**Note: This is an application of Level Order Traversal**"
                    },
                    {
                        "username": "Lakpro",
                        "content": "**SIMILAR QUESTIONS**\\n\\n**[314. Binary Tree Vertical Order Traversal: ](https://leetcode.com/problems/binary-tree-vertical-order-traversal/description/)** (Here, we have to return nodes in the same column as left to right)\\n\\n**[987. Vertical Order Traversal of a Binary Tree: ](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/987)** (Here, we have to return nodes in the same column in  sorted order.)"
                    },
                    {
                        "username": "huangguoqiang",
                        "content": "Input:\\n[3,9,8,4,0,1,7]\\nOutput:\\n[[4],[9],[0,3,1],[8],[7]]\\nExpected:\\n[[4],[9],[3,0,1],[8],[7]] \\n\\nThe condition is that If two nodes are in the same row and column, the order should be from left to right.\\n\\nFor the example above, only 0 and 1 are in the same row and column, but 3 is not.  So both [[4],[9],[0,3,1],[8],[7]] and [[4],[9],[3,0,1],[8],[7]] should be correct answers."
                    },
                    {
                        "username": "elwerro",
                        "content": "https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/"
                    },
                    {
                        "username": "uzia35",
                        "content": "The priority for the answer is left to right for columns and top to bottom for the rows. The rows should be mentioned just in case. "
                    },
                    {
                        "username": "joxamo",
                        "content": "So I tried solving this problem using the following recursive function and it came out wrong.\n\nvar verticalOrder = function(root) {\n    if (!root) {\n        return [];\n    }\n\n    const columnMap = new Map(); // Map to store nodes in each column\n\n    // Helper function for recursive traversal\n    function dfs(node, col) {\n        if (!node) {\n            return;\n        }\n\n        if (!columnMap.has(col)) {\n            columnMap.set(col, []);\n        }\n\n\n        columnMap.get(col).push(node.val);\n\n        dfs(node.left, col - 1);\n        dfs(node.right, col + 1);\n    }\n\n    // Start the recursive traversal with the root at column 0\n    dfs(root, 0);\n\n    // Sort the columns in ascending order\n    const sortedColumns = [...columnMap.keys()].sort((a, b) => a - b);\n\n    // Create the result array\n    const result = sortedColumns.map(col => columnMap.get(col));\n\n    return result;\n};\n\nIt claimed my output was incorrect compared to the test case:\nexpected:\n[[4],[9,5],[3,0,1],[8,2],[7]]\noutput:\n[[4],[9,5],[3,0,1],[2,8],[7]]\n\nI was skeptical of this test result, so I decided to create the tree on my own in codepen\n\n\nlet root = new TreeNode();\nroot.val = 3\nroot.left = new TreeNode(9);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(0);\nroot.left.right.left = new TreeNode(5);\nroot.right = new TreeNode(8);\nroot.right.left = new TreeNode(1);\nroot.right.left.right = new TreeNode(2);\nroot.right.right = new TreeNode(7);\n\nAfter doing this, my output came back correct as expected. Is there something wrong with that test case?"
                    },
                    {
                        "username": "brett_davis",
                        "content": "Am I misunderstanding or is the third example not set up correctly?\n\n[3,9,8,4,0,1,7,null,null,null,2,5]\n\n3 - > 9, 8\n9 -> 4, 0\n8 -> 1, 7\n4 -> null, null\n0 -> null, 2\n1 -> 5\n\n2 is supposed to be the right child of 1\n\nI would think the input  has to be: [3,9,8,4,0,1,7,null,null,5, null, null, 2]\n"
                    }
                ]
            },
            {
                "id": 1572320,
                "content": [
                    {
                        "username": "mazyla",
                        "content": "Input:\\n[3,9,8,4,0,1,7,null,null,null,2,5]\\nExpected answer: [ [4], [9,5], [3,0,1], [8,2], [7] ]\\n\\nBut the question says if 2 nodes have the same horizontal distance, then order should be left to right, while the expected answer is right node first, in the case of 8 and 2.\\n\\nIsn\\'t the right answer actually: [ [4], [9,5], [3,0,1], [2,8], [7] ]"
                    },
                    {
                        "username": "heavenfish",
                        "content": "It asked to travel from top to bottom and left to right. Therefore, 8 should come first as it is on top of 2."
                    },
                    {
                        "username": "fyh8238865",
                        "content": "In the problem, they asked us to do vertical order traversal, but what does the \"vertical order\" mean? I think the problem do not state it well.\\n\\nFor example, in the following case: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\\n\\nShould the 1,11,12 be on the same horizontal position?\\n\\nBased on my intuition, the position of the node in a tree will changed based on their deep and number of nodes in each layer. Because I think the position is not absolute value. So the upper case, I said yes. But for the real test case, they said no. \\n\\nTherefore, I think the problem should clarify what is their definition of the position or vertical order.\\n\\nIf anyone think what I said has something wrong, please correct me."
                    },
                    {
                        "username": "mlblount45",
                        "content": "What would the output look like for a tree of height 4?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Vertical Order traversal variations:\\n- If question was just to find nodes in the same column (where nodes in a column could be from top to bottom OR bottom to top or random): dfs would be enough. But that is not really a vertical order traversal. I mistakenly used dfs first to find out later in my answer the nodes in the same column were not arranged from top to bottom.\\n- LC 314: Vertical order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be from left to right. TreeMap with horizontalDistance as key helped solving this.\\n- LC 987: Vertival Order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be smaller value should come in first. TreeMap with horizontalDistance as key and value being \\'TreeMap with height as key and value being TreeSet for sorting by node value\\' helped solving this \\n\\nI came up with the solutions on my own. Go through my 1st accpeted submission for each question. There might be optimizations in LC solutions. I didnt look at it yet. Have a look some day when you get time.\\n\\n**Note: This is an application of Level Order Traversal**"
                    },
                    {
                        "username": "Lakpro",
                        "content": "**SIMILAR QUESTIONS**\\n\\n**[314. Binary Tree Vertical Order Traversal: ](https://leetcode.com/problems/binary-tree-vertical-order-traversal/description/)** (Here, we have to return nodes in the same column as left to right)\\n\\n**[987. Vertical Order Traversal of a Binary Tree: ](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/987)** (Here, we have to return nodes in the same column in  sorted order.)"
                    },
                    {
                        "username": "huangguoqiang",
                        "content": "Input:\\n[3,9,8,4,0,1,7]\\nOutput:\\n[[4],[9],[0,3,1],[8],[7]]\\nExpected:\\n[[4],[9],[3,0,1],[8],[7]] \\n\\nThe condition is that If two nodes are in the same row and column, the order should be from left to right.\\n\\nFor the example above, only 0 and 1 are in the same row and column, but 3 is not.  So both [[4],[9],[0,3,1],[8],[7]] and [[4],[9],[3,0,1],[8],[7]] should be correct answers."
                    },
                    {
                        "username": "elwerro",
                        "content": "https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/"
                    },
                    {
                        "username": "uzia35",
                        "content": "The priority for the answer is left to right for columns and top to bottom for the rows. The rows should be mentioned just in case. "
                    },
                    {
                        "username": "joxamo",
                        "content": "So I tried solving this problem using the following recursive function and it came out wrong.\n\nvar verticalOrder = function(root) {\n    if (!root) {\n        return [];\n    }\n\n    const columnMap = new Map(); // Map to store nodes in each column\n\n    // Helper function for recursive traversal\n    function dfs(node, col) {\n        if (!node) {\n            return;\n        }\n\n        if (!columnMap.has(col)) {\n            columnMap.set(col, []);\n        }\n\n\n        columnMap.get(col).push(node.val);\n\n        dfs(node.left, col - 1);\n        dfs(node.right, col + 1);\n    }\n\n    // Start the recursive traversal with the root at column 0\n    dfs(root, 0);\n\n    // Sort the columns in ascending order\n    const sortedColumns = [...columnMap.keys()].sort((a, b) => a - b);\n\n    // Create the result array\n    const result = sortedColumns.map(col => columnMap.get(col));\n\n    return result;\n};\n\nIt claimed my output was incorrect compared to the test case:\nexpected:\n[[4],[9,5],[3,0,1],[8,2],[7]]\noutput:\n[[4],[9,5],[3,0,1],[2,8],[7]]\n\nI was skeptical of this test result, so I decided to create the tree on my own in codepen\n\n\nlet root = new TreeNode();\nroot.val = 3\nroot.left = new TreeNode(9);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(0);\nroot.left.right.left = new TreeNode(5);\nroot.right = new TreeNode(8);\nroot.right.left = new TreeNode(1);\nroot.right.left.right = new TreeNode(2);\nroot.right.right = new TreeNode(7);\n\nAfter doing this, my output came back correct as expected. Is there something wrong with that test case?"
                    },
                    {
                        "username": "brett_davis",
                        "content": "Am I misunderstanding or is the third example not set up correctly?\n\n[3,9,8,4,0,1,7,null,null,null,2,5]\n\n3 - > 9, 8\n9 -> 4, 0\n8 -> 1, 7\n4 -> null, null\n0 -> null, 2\n1 -> 5\n\n2 is supposed to be the right child of 1\n\nI would think the input  has to be: [3,9,8,4,0,1,7,null,null,5, null, null, 2]\n"
                    }
                ]
            },
            {
                "id": 2076154,
                "content": [
                    {
                        "username": "mazyla",
                        "content": "Input:\\n[3,9,8,4,0,1,7,null,null,null,2,5]\\nExpected answer: [ [4], [9,5], [3,0,1], [8,2], [7] ]\\n\\nBut the question says if 2 nodes have the same horizontal distance, then order should be left to right, while the expected answer is right node first, in the case of 8 and 2.\\n\\nIsn\\'t the right answer actually: [ [4], [9,5], [3,0,1], [2,8], [7] ]"
                    },
                    {
                        "username": "heavenfish",
                        "content": "It asked to travel from top to bottom and left to right. Therefore, 8 should come first as it is on top of 2."
                    },
                    {
                        "username": "fyh8238865",
                        "content": "In the problem, they asked us to do vertical order traversal, but what does the \"vertical order\" mean? I think the problem do not state it well.\\n\\nFor example, in the following case: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\\n\\nShould the 1,11,12 be on the same horizontal position?\\n\\nBased on my intuition, the position of the node in a tree will changed based on their deep and number of nodes in each layer. Because I think the position is not absolute value. So the upper case, I said yes. But for the real test case, they said no. \\n\\nTherefore, I think the problem should clarify what is their definition of the position or vertical order.\\n\\nIf anyone think what I said has something wrong, please correct me."
                    },
                    {
                        "username": "mlblount45",
                        "content": "What would the output look like for a tree of height 4?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Vertical Order traversal variations:\\n- If question was just to find nodes in the same column (where nodes in a column could be from top to bottom OR bottom to top or random): dfs would be enough. But that is not really a vertical order traversal. I mistakenly used dfs first to find out later in my answer the nodes in the same column were not arranged from top to bottom.\\n- LC 314: Vertical order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be from left to right. TreeMap with horizontalDistance as key helped solving this.\\n- LC 987: Vertival Order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be smaller value should come in first. TreeMap with horizontalDistance as key and value being \\'TreeMap with height as key and value being TreeSet for sorting by node value\\' helped solving this \\n\\nI came up with the solutions on my own. Go through my 1st accpeted submission for each question. There might be optimizations in LC solutions. I didnt look at it yet. Have a look some day when you get time.\\n\\n**Note: This is an application of Level Order Traversal**"
                    },
                    {
                        "username": "Lakpro",
                        "content": "**SIMILAR QUESTIONS**\\n\\n**[314. Binary Tree Vertical Order Traversal: ](https://leetcode.com/problems/binary-tree-vertical-order-traversal/description/)** (Here, we have to return nodes in the same column as left to right)\\n\\n**[987. Vertical Order Traversal of a Binary Tree: ](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/987)** (Here, we have to return nodes in the same column in  sorted order.)"
                    },
                    {
                        "username": "huangguoqiang",
                        "content": "Input:\\n[3,9,8,4,0,1,7]\\nOutput:\\n[[4],[9],[0,3,1],[8],[7]]\\nExpected:\\n[[4],[9],[3,0,1],[8],[7]] \\n\\nThe condition is that If two nodes are in the same row and column, the order should be from left to right.\\n\\nFor the example above, only 0 and 1 are in the same row and column, but 3 is not.  So both [[4],[9],[0,3,1],[8],[7]] and [[4],[9],[3,0,1],[8],[7]] should be correct answers."
                    },
                    {
                        "username": "elwerro",
                        "content": "https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/"
                    },
                    {
                        "username": "uzia35",
                        "content": "The priority for the answer is left to right for columns and top to bottom for the rows. The rows should be mentioned just in case. "
                    },
                    {
                        "username": "joxamo",
                        "content": "So I tried solving this problem using the following recursive function and it came out wrong.\n\nvar verticalOrder = function(root) {\n    if (!root) {\n        return [];\n    }\n\n    const columnMap = new Map(); // Map to store nodes in each column\n\n    // Helper function for recursive traversal\n    function dfs(node, col) {\n        if (!node) {\n            return;\n        }\n\n        if (!columnMap.has(col)) {\n            columnMap.set(col, []);\n        }\n\n\n        columnMap.get(col).push(node.val);\n\n        dfs(node.left, col - 1);\n        dfs(node.right, col + 1);\n    }\n\n    // Start the recursive traversal with the root at column 0\n    dfs(root, 0);\n\n    // Sort the columns in ascending order\n    const sortedColumns = [...columnMap.keys()].sort((a, b) => a - b);\n\n    // Create the result array\n    const result = sortedColumns.map(col => columnMap.get(col));\n\n    return result;\n};\n\nIt claimed my output was incorrect compared to the test case:\nexpected:\n[[4],[9,5],[3,0,1],[8,2],[7]]\noutput:\n[[4],[9,5],[3,0,1],[2,8],[7]]\n\nI was skeptical of this test result, so I decided to create the tree on my own in codepen\n\n\nlet root = new TreeNode();\nroot.val = 3\nroot.left = new TreeNode(9);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(0);\nroot.left.right.left = new TreeNode(5);\nroot.right = new TreeNode(8);\nroot.right.left = new TreeNode(1);\nroot.right.left.right = new TreeNode(2);\nroot.right.right = new TreeNode(7);\n\nAfter doing this, my output came back correct as expected. Is there something wrong with that test case?"
                    },
                    {
                        "username": "brett_davis",
                        "content": "Am I misunderstanding or is the third example not set up correctly?\n\n[3,9,8,4,0,1,7,null,null,null,2,5]\n\n3 - > 9, 8\n9 -> 4, 0\n8 -> 1, 7\n4 -> null, null\n0 -> null, 2\n1 -> 5\n\n2 is supposed to be the right child of 1\n\nI would think the input  has to be: [3,9,8,4,0,1,7,null,null,5, null, null, 2]\n"
                    }
                ]
            },
            {
                "id": 2065098,
                "content": [
                    {
                        "username": "mazyla",
                        "content": "Input:\\n[3,9,8,4,0,1,7,null,null,null,2,5]\\nExpected answer: [ [4], [9,5], [3,0,1], [8,2], [7] ]\\n\\nBut the question says if 2 nodes have the same horizontal distance, then order should be left to right, while the expected answer is right node first, in the case of 8 and 2.\\n\\nIsn\\'t the right answer actually: [ [4], [9,5], [3,0,1], [2,8], [7] ]"
                    },
                    {
                        "username": "heavenfish",
                        "content": "It asked to travel from top to bottom and left to right. Therefore, 8 should come first as it is on top of 2."
                    },
                    {
                        "username": "fyh8238865",
                        "content": "In the problem, they asked us to do vertical order traversal, but what does the \"vertical order\" mean? I think the problem do not state it well.\\n\\nFor example, in the following case: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\\n\\nShould the 1,11,12 be on the same horizontal position?\\n\\nBased on my intuition, the position of the node in a tree will changed based on their deep and number of nodes in each layer. Because I think the position is not absolute value. So the upper case, I said yes. But for the real test case, they said no. \\n\\nTherefore, I think the problem should clarify what is their definition of the position or vertical order.\\n\\nIf anyone think what I said has something wrong, please correct me."
                    },
                    {
                        "username": "mlblount45",
                        "content": "What would the output look like for a tree of height 4?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Vertical Order traversal variations:\\n- If question was just to find nodes in the same column (where nodes in a column could be from top to bottom OR bottom to top or random): dfs would be enough. But that is not really a vertical order traversal. I mistakenly used dfs first to find out later in my answer the nodes in the same column were not arranged from top to bottom.\\n- LC 314: Vertical order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be from left to right. TreeMap with horizontalDistance as key helped solving this.\\n- LC 987: Vertival Order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be smaller value should come in first. TreeMap with horizontalDistance as key and value being \\'TreeMap with height as key and value being TreeSet for sorting by node value\\' helped solving this \\n\\nI came up with the solutions on my own. Go through my 1st accpeted submission for each question. There might be optimizations in LC solutions. I didnt look at it yet. Have a look some day when you get time.\\n\\n**Note: This is an application of Level Order Traversal**"
                    },
                    {
                        "username": "Lakpro",
                        "content": "**SIMILAR QUESTIONS**\\n\\n**[314. Binary Tree Vertical Order Traversal: ](https://leetcode.com/problems/binary-tree-vertical-order-traversal/description/)** (Here, we have to return nodes in the same column as left to right)\\n\\n**[987. Vertical Order Traversal of a Binary Tree: ](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/987)** (Here, we have to return nodes in the same column in  sorted order.)"
                    },
                    {
                        "username": "huangguoqiang",
                        "content": "Input:\\n[3,9,8,4,0,1,7]\\nOutput:\\n[[4],[9],[0,3,1],[8],[7]]\\nExpected:\\n[[4],[9],[3,0,1],[8],[7]] \\n\\nThe condition is that If two nodes are in the same row and column, the order should be from left to right.\\n\\nFor the example above, only 0 and 1 are in the same row and column, but 3 is not.  So both [[4],[9],[0,3,1],[8],[7]] and [[4],[9],[3,0,1],[8],[7]] should be correct answers."
                    },
                    {
                        "username": "elwerro",
                        "content": "https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/"
                    },
                    {
                        "username": "uzia35",
                        "content": "The priority for the answer is left to right for columns and top to bottom for the rows. The rows should be mentioned just in case. "
                    },
                    {
                        "username": "joxamo",
                        "content": "So I tried solving this problem using the following recursive function and it came out wrong.\n\nvar verticalOrder = function(root) {\n    if (!root) {\n        return [];\n    }\n\n    const columnMap = new Map(); // Map to store nodes in each column\n\n    // Helper function for recursive traversal\n    function dfs(node, col) {\n        if (!node) {\n            return;\n        }\n\n        if (!columnMap.has(col)) {\n            columnMap.set(col, []);\n        }\n\n\n        columnMap.get(col).push(node.val);\n\n        dfs(node.left, col - 1);\n        dfs(node.right, col + 1);\n    }\n\n    // Start the recursive traversal with the root at column 0\n    dfs(root, 0);\n\n    // Sort the columns in ascending order\n    const sortedColumns = [...columnMap.keys()].sort((a, b) => a - b);\n\n    // Create the result array\n    const result = sortedColumns.map(col => columnMap.get(col));\n\n    return result;\n};\n\nIt claimed my output was incorrect compared to the test case:\nexpected:\n[[4],[9,5],[3,0,1],[8,2],[7]]\noutput:\n[[4],[9,5],[3,0,1],[2,8],[7]]\n\nI was skeptical of this test result, so I decided to create the tree on my own in codepen\n\n\nlet root = new TreeNode();\nroot.val = 3\nroot.left = new TreeNode(9);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(0);\nroot.left.right.left = new TreeNode(5);\nroot.right = new TreeNode(8);\nroot.right.left = new TreeNode(1);\nroot.right.left.right = new TreeNode(2);\nroot.right.right = new TreeNode(7);\n\nAfter doing this, my output came back correct as expected. Is there something wrong with that test case?"
                    },
                    {
                        "username": "brett_davis",
                        "content": "Am I misunderstanding or is the third example not set up correctly?\n\n[3,9,8,4,0,1,7,null,null,null,2,5]\n\n3 - > 9, 8\n9 -> 4, 0\n8 -> 1, 7\n4 -> null, null\n0 -> null, 2\n1 -> 5\n\n2 is supposed to be the right child of 1\n\nI would think the input  has to be: [3,9,8,4,0,1,7,null,null,5, null, null, 2]\n"
                    }
                ]
            },
            {
                "id": 2059448,
                "content": [
                    {
                        "username": "mazyla",
                        "content": "Input:\\n[3,9,8,4,0,1,7,null,null,null,2,5]\\nExpected answer: [ [4], [9,5], [3,0,1], [8,2], [7] ]\\n\\nBut the question says if 2 nodes have the same horizontal distance, then order should be left to right, while the expected answer is right node first, in the case of 8 and 2.\\n\\nIsn\\'t the right answer actually: [ [4], [9,5], [3,0,1], [2,8], [7] ]"
                    },
                    {
                        "username": "heavenfish",
                        "content": "It asked to travel from top to bottom and left to right. Therefore, 8 should come first as it is on top of 2."
                    },
                    {
                        "username": "fyh8238865",
                        "content": "In the problem, they asked us to do vertical order traversal, but what does the \"vertical order\" mean? I think the problem do not state it well.\\n\\nFor example, in the following case: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\\n\\nShould the 1,11,12 be on the same horizontal position?\\n\\nBased on my intuition, the position of the node in a tree will changed based on their deep and number of nodes in each layer. Because I think the position is not absolute value. So the upper case, I said yes. But for the real test case, they said no. \\n\\nTherefore, I think the problem should clarify what is their definition of the position or vertical order.\\n\\nIf anyone think what I said has something wrong, please correct me."
                    },
                    {
                        "username": "mlblount45",
                        "content": "What would the output look like for a tree of height 4?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Vertical Order traversal variations:\\n- If question was just to find nodes in the same column (where nodes in a column could be from top to bottom OR bottom to top or random): dfs would be enough. But that is not really a vertical order traversal. I mistakenly used dfs first to find out later in my answer the nodes in the same column were not arranged from top to bottom.\\n- LC 314: Vertical order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be from left to right. TreeMap with horizontalDistance as key helped solving this.\\n- LC 987: Vertival Order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be smaller value should come in first. TreeMap with horizontalDistance as key and value being \\'TreeMap with height as key and value being TreeSet for sorting by node value\\' helped solving this \\n\\nI came up with the solutions on my own. Go through my 1st accpeted submission for each question. There might be optimizations in LC solutions. I didnt look at it yet. Have a look some day when you get time.\\n\\n**Note: This is an application of Level Order Traversal**"
                    },
                    {
                        "username": "Lakpro",
                        "content": "**SIMILAR QUESTIONS**\\n\\n**[314. Binary Tree Vertical Order Traversal: ](https://leetcode.com/problems/binary-tree-vertical-order-traversal/description/)** (Here, we have to return nodes in the same column as left to right)\\n\\n**[987. Vertical Order Traversal of a Binary Tree: ](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/987)** (Here, we have to return nodes in the same column in  sorted order.)"
                    },
                    {
                        "username": "huangguoqiang",
                        "content": "Input:\\n[3,9,8,4,0,1,7]\\nOutput:\\n[[4],[9],[0,3,1],[8],[7]]\\nExpected:\\n[[4],[9],[3,0,1],[8],[7]] \\n\\nThe condition is that If two nodes are in the same row and column, the order should be from left to right.\\n\\nFor the example above, only 0 and 1 are in the same row and column, but 3 is not.  So both [[4],[9],[0,3,1],[8],[7]] and [[4],[9],[3,0,1],[8],[7]] should be correct answers."
                    },
                    {
                        "username": "elwerro",
                        "content": "https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/"
                    },
                    {
                        "username": "uzia35",
                        "content": "The priority for the answer is left to right for columns and top to bottom for the rows. The rows should be mentioned just in case. "
                    },
                    {
                        "username": "joxamo",
                        "content": "So I tried solving this problem using the following recursive function and it came out wrong.\n\nvar verticalOrder = function(root) {\n    if (!root) {\n        return [];\n    }\n\n    const columnMap = new Map(); // Map to store nodes in each column\n\n    // Helper function for recursive traversal\n    function dfs(node, col) {\n        if (!node) {\n            return;\n        }\n\n        if (!columnMap.has(col)) {\n            columnMap.set(col, []);\n        }\n\n\n        columnMap.get(col).push(node.val);\n\n        dfs(node.left, col - 1);\n        dfs(node.right, col + 1);\n    }\n\n    // Start the recursive traversal with the root at column 0\n    dfs(root, 0);\n\n    // Sort the columns in ascending order\n    const sortedColumns = [...columnMap.keys()].sort((a, b) => a - b);\n\n    // Create the result array\n    const result = sortedColumns.map(col => columnMap.get(col));\n\n    return result;\n};\n\nIt claimed my output was incorrect compared to the test case:\nexpected:\n[[4],[9,5],[3,0,1],[8,2],[7]]\noutput:\n[[4],[9,5],[3,0,1],[2,8],[7]]\n\nI was skeptical of this test result, so I decided to create the tree on my own in codepen\n\n\nlet root = new TreeNode();\nroot.val = 3\nroot.left = new TreeNode(9);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(0);\nroot.left.right.left = new TreeNode(5);\nroot.right = new TreeNode(8);\nroot.right.left = new TreeNode(1);\nroot.right.left.right = new TreeNode(2);\nroot.right.right = new TreeNode(7);\n\nAfter doing this, my output came back correct as expected. Is there something wrong with that test case?"
                    },
                    {
                        "username": "brett_davis",
                        "content": "Am I misunderstanding or is the third example not set up correctly?\n\n[3,9,8,4,0,1,7,null,null,null,2,5]\n\n3 - > 9, 8\n9 -> 4, 0\n8 -> 1, 7\n4 -> null, null\n0 -> null, 2\n1 -> 5\n\n2 is supposed to be the right child of 1\n\nI would think the input  has to be: [3,9,8,4,0,1,7,null,null,5, null, null, 2]\n"
                    }
                ]
            },
            {
                "id": 2037194,
                "content": [
                    {
                        "username": "mazyla",
                        "content": "Input:\\n[3,9,8,4,0,1,7,null,null,null,2,5]\\nExpected answer: [ [4], [9,5], [3,0,1], [8,2], [7] ]\\n\\nBut the question says if 2 nodes have the same horizontal distance, then order should be left to right, while the expected answer is right node first, in the case of 8 and 2.\\n\\nIsn\\'t the right answer actually: [ [4], [9,5], [3,0,1], [2,8], [7] ]"
                    },
                    {
                        "username": "heavenfish",
                        "content": "It asked to travel from top to bottom and left to right. Therefore, 8 should come first as it is on top of 2."
                    },
                    {
                        "username": "fyh8238865",
                        "content": "In the problem, they asked us to do vertical order traversal, but what does the \"vertical order\" mean? I think the problem do not state it well.\\n\\nFor example, in the following case: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\\n\\nShould the 1,11,12 be on the same horizontal position?\\n\\nBased on my intuition, the position of the node in a tree will changed based on their deep and number of nodes in each layer. Because I think the position is not absolute value. So the upper case, I said yes. But for the real test case, they said no. \\n\\nTherefore, I think the problem should clarify what is their definition of the position or vertical order.\\n\\nIf anyone think what I said has something wrong, please correct me."
                    },
                    {
                        "username": "mlblount45",
                        "content": "What would the output look like for a tree of height 4?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Vertical Order traversal variations:\\n- If question was just to find nodes in the same column (where nodes in a column could be from top to bottom OR bottom to top or random): dfs would be enough. But that is not really a vertical order traversal. I mistakenly used dfs first to find out later in my answer the nodes in the same column were not arranged from top to bottom.\\n- LC 314: Vertical order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be from left to right. TreeMap with horizontalDistance as key helped solving this.\\n- LC 987: Vertival Order traversal: from top to bottom in a column + If two nodes are in the same row and column, the order should be smaller value should come in first. TreeMap with horizontalDistance as key and value being \\'TreeMap with height as key and value being TreeSet for sorting by node value\\' helped solving this \\n\\nI came up with the solutions on my own. Go through my 1st accpeted submission for each question. There might be optimizations in LC solutions. I didnt look at it yet. Have a look some day when you get time.\\n\\n**Note: This is an application of Level Order Traversal**"
                    },
                    {
                        "username": "Lakpro",
                        "content": "**SIMILAR QUESTIONS**\\n\\n**[314. Binary Tree Vertical Order Traversal: ](https://leetcode.com/problems/binary-tree-vertical-order-traversal/description/)** (Here, we have to return nodes in the same column as left to right)\\n\\n**[987. Vertical Order Traversal of a Binary Tree: ](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/987)** (Here, we have to return nodes in the same column in  sorted order.)"
                    },
                    {
                        "username": "huangguoqiang",
                        "content": "Input:\\n[3,9,8,4,0,1,7]\\nOutput:\\n[[4],[9],[0,3,1],[8],[7]]\\nExpected:\\n[[4],[9],[3,0,1],[8],[7]] \\n\\nThe condition is that If two nodes are in the same row and column, the order should be from left to right.\\n\\nFor the example above, only 0 and 1 are in the same row and column, but 3 is not.  So both [[4],[9],[0,3,1],[8],[7]] and [[4],[9],[3,0,1],[8],[7]] should be correct answers."
                    },
                    {
                        "username": "elwerro",
                        "content": "https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/"
                    },
                    {
                        "username": "uzia35",
                        "content": "The priority for the answer is left to right for columns and top to bottom for the rows. The rows should be mentioned just in case. "
                    },
                    {
                        "username": "joxamo",
                        "content": "So I tried solving this problem using the following recursive function and it came out wrong.\n\nvar verticalOrder = function(root) {\n    if (!root) {\n        return [];\n    }\n\n    const columnMap = new Map(); // Map to store nodes in each column\n\n    // Helper function for recursive traversal\n    function dfs(node, col) {\n        if (!node) {\n            return;\n        }\n\n        if (!columnMap.has(col)) {\n            columnMap.set(col, []);\n        }\n\n\n        columnMap.get(col).push(node.val);\n\n        dfs(node.left, col - 1);\n        dfs(node.right, col + 1);\n    }\n\n    // Start the recursive traversal with the root at column 0\n    dfs(root, 0);\n\n    // Sort the columns in ascending order\n    const sortedColumns = [...columnMap.keys()].sort((a, b) => a - b);\n\n    // Create the result array\n    const result = sortedColumns.map(col => columnMap.get(col));\n\n    return result;\n};\n\nIt claimed my output was incorrect compared to the test case:\nexpected:\n[[4],[9,5],[3,0,1],[8,2],[7]]\noutput:\n[[4],[9,5],[3,0,1],[2,8],[7]]\n\nI was skeptical of this test result, so I decided to create the tree on my own in codepen\n\n\nlet root = new TreeNode();\nroot.val = 3\nroot.left = new TreeNode(9);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(0);\nroot.left.right.left = new TreeNode(5);\nroot.right = new TreeNode(8);\nroot.right.left = new TreeNode(1);\nroot.right.left.right = new TreeNode(2);\nroot.right.right = new TreeNode(7);\n\nAfter doing this, my output came back correct as expected. Is there something wrong with that test case?"
                    },
                    {
                        "username": "brett_davis",
                        "content": "Am I misunderstanding or is the third example not set up correctly?\n\n[3,9,8,4,0,1,7,null,null,null,2,5]\n\n3 - > 9, 8\n9 -> 4, 0\n8 -> 1, 7\n4 -> null, null\n0 -> null, 2\n1 -> 5\n\n2 is supposed to be the right child of 1\n\nI would think the input  has to be: [3,9,8,4,0,1,7,null,null,5, null, null, 2]\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Third Maximum Number",
        "question_content": "<p>Given an integer array <code>nums</code>, return <em>the <strong>third distinct maximum</strong> number in this array. If the third maximum does not exist, return the <strong>maximum</strong> number</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,1]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong>\nThe first distinct maximum is 3.\nThe second distinct maximum is 2.\nThe third distinct maximum is 1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong>\nThe first distinct maximum is 2.\nThe second distinct maximum is 1.\nThe third distinct maximum does not exist, so the maximum (2) is returned instead.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,2,3,1]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong>\nThe first distinct maximum is 3.\nThe second distinct maximum is 2 (both 2&#39;s are counted together since they have the same value).\nThe third distinct maximum is 1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Can you find an <code>O(n)</code> solution?",
        "solutions": [
            {
                "id": 90202,
                "title": "java-neat-and-easy-understand-solution-o-n-time-o-1-space",
                "content": "```\\n    public int thirdMax(int[] nums) {\\n        Integer max1 = null;\\n        Integer max2 = null;\\n        Integer max3 = null;\\n        for (Integer n : nums) {\\n            if (n.equals(max1) || n.equals(max2) || n.equals(max3)) continue;\\n            if (max1 == null || n > max1) {\\n                max3 = max2;\\n                max2 = max1;\\n                max1 = n;\\n            } else if (max2 == null || n > max2) {\\n                max3 = max2;\\n                max2 = n;\\n            } else if (max3 == null || n > max3) {\\n                max3 = n;\\n            }\\n        }\\n        return max3 == null ? max1 : max3;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int thirdMax(int[] nums) {\\n        Integer max1 = null;\\n        Integer max2 = null;\\n        Integer max3 = null;\\n        for (Integer n : nums) {\\n            if (n.equals(max1) || n.equals(max2) || n.equals(max3)) continue;\\n            if (max1 == null || n > max1) {\\n                max3 = max2;\\n                max2 = max1;\\n                max1 = n;\\n            } else if (max2 == null || n > max2) {\\n                max3 = max2;\\n                max2 = n;\\n            } else if (max3 == null || n > max3) {\\n                max3 = n;\\n            }\\n        }\\n        return max3 == null ? max1 : max3;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 90207,
                "title": "intuitive-and-short-python-solution",
                "content": "```\\nclass Solution(object):\\n    def thirdMax(self, nums):\\n        v = [float('-inf'), float('-inf'), float('-inf')]\\n        for num in nums:\\n            if num not in v:\\n                if num > v[0]:   v = [num, v[0], v[1]]\\n                elif num > v[1]: v = [v[0], num, v[1]]\\n                elif num > v[2]: v = [v[0], v[1], num]\\n        return max(nums) if float('-inf') in v else v[2]\\n```\\nTime complexity is O(n), space complexity is O(1).",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def thirdMax(self, nums):\\n        v = [float('-inf'), float('-inf'), float('-inf')]\\n        for num in nums:\\n            if num not in v:\\n                if num > v[0]:   v = [num, v[0], v[1]]\\n                elif num > v[1]: v = [v[0], num, v[1]]\\n                elif num > v[2]: v = [v[0], v[1], num]\\n        return max(nums) if float('-inf') in v else v[2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 90209,
                "title": "short-easy-c-using-set",
                "content": "Track the largest three values in a set.\\n\\n    int thirdMax(vector<int>& nums) {\\n        set<int> top3;\\n        for (int num : nums) {\\n            top3.insert(num);\\n            if (top3.size() > 3)\\n                top3.erase(top3.begin());\\n        }\\n        return top3.size() == 3 ? *top3.begin() : *top3.rbegin();\\n    }\\n\\nAlternatively (not sure which one I like better):\\n\\n    int thirdMax(vector<int>& nums) {\\n        set<int> top3;\\n        for (int num : nums)\\n            if (top3.insert(num).second && top3.size() > 3)\\n                top3.erase(top3.begin());\\n        return top3.size() == 3 ? *top3.begin() : *top3.rbegin();\\n    }",
                "solutionTags": [],
                "code": "Track the largest three values in a set.\\n\\n    int thirdMax(vector<int>& nums) {\\n        set<int> top3;\\n        for (int num : nums) {\\n            top3.insert(num);\\n            if (top3.size() > 3)\\n                top3.erase(top3.begin());\\n        }\\n        return top3.size() == 3 ? *top3.begin() : *top3.rbegin();\\n    }\\n\\nAlternatively (not sure which one I like better):\\n\\n    int thirdMax(vector<int>& nums) {\\n        set<int> top3;\\n        for (int num : nums)\\n            if (top3.insert(num).second && top3.size() > 3)\\n                top3.erase(top3.begin());\\n        return top3.size() == 3 ? *top3.begin() : *top3.rbegin();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 90201,
                "title": "a-python-amusing-solution-which-actually-beats-98",
                "content": "```\\ndef thirdMax(self, nums):\\n        nums = set(nums)\\n        if len(nums) < 3:\\n            return max(nums)\\n        nums.remove(max(nums))\\n        nums.remove(max(nums))\\n        return max(nums)\\n```",
                "solutionTags": [],
                "code": "```\\ndef thirdMax(self, nums):\\n        nums = set(nums)\\n        if len(nums) < 3:\\n            return max(nums)\\n        nums.remove(max(nums))\\n        nums.remove(max(nums))\\n        return max(nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 90190,
                "title": "java-priorityqueue-o-n-o-1",
                "content": "```\\npublic class Solution {\\n    public int thirdMax(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        Set<Integer> set = new HashSet<>();\\n        for (int i : nums) {\\n            if (!set.contains(i)) {\\n                pq.offer(i);\\n                set.add(i);\\n                if (pq.size() > 3) {\\n                    set.remove(pq.poll());\\n                }\\n            }\\n        }\\n        if (pq.size() < 3) {\\n            while (pq.size() > 1) {\\n                pq.poll();\\n            }\\n        }\\n        return pq.peek();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int thirdMax(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        Set<Integer> set = new HashSet<>();\\n        for (int i : nums) {\\n            if (!set.contains(i)) {\\n                pq.offer(i);\\n                set.add(i);\\n                if (pq.size() > 3) {\\n                    set.remove(pq.poll());\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 90240,
                "title": "short-clear-c-solution-no-set-or-pq",
                "content": "```\\nint thirdMax(vector<int>& nums) {\\n    long long a, b, c;\\n    a = b = c = LLONG_MIN;\\n    for (auto num : nums) {\\n        if (num <= c || num == b || num == a) continue;\\n        c = num;\\n        if (c > b) swap(b, c);\\n        if (b > a) swap(a, b);\\n    }\\n    return c == LLONG_MIN ? a : c;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint thirdMax(vector<int>& nums) {\\n    long long a, b, c;\\n    a = b = c = LLONG_MIN;\\n    for (auto num : nums) {\\n        if (num <= c || num == b || num == a) continue;\\n        c = num;\\n        if (c > b) swap(b, c);\\n        if (b > a) swap(a, b);\\n    }\\n    return c == LLONG_MIN ? a : c;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 197969,
                "title": "c-accepted-solution-o-1-space-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        \\n        long one = LONG_MIN, two = LONG_MIN, three = LONG_MIN;\\n        for (int num : nums) {\\n            if (num == one || num == two || num == three)\\n                continue;\\n            \\n            if (num > one) {\\n                three = two;\\n                two = one;\\n                one = num;\\n            } else if (num > two) {\\n                three = two;\\n                two = num;\\n            } else if (num > three) {\\n                three = num;\\n            }\\n        }\\n        \\n        return three == LONG_MIN ? one : three;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        \\n        long one = LONG_MIN, two = LONG_MIN, three = LONG_MIN;\\n        for (int num : nums) {\\n            if (num == one || num == two || num == three)\\n                continue;\\n            \\n            if (num > one) {\\n                three = two;\\n                two = one;\\n                one = num;\\n            } else if (num > two) {\\n                three = two;\\n                two = num;\\n            } else if (num > three) {\\n                three = num;\\n            }\\n        }\\n        \\n        return three == LONG_MIN ? one : three;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343654,
                "title": "c-4-different-approach-solution-in-place-algorithm-max-heap-set-sorting",
                "content": "//---------------> \\uD83D\\uDC7B Pls Upvote if it is helpful for You \\uD83D\\uDC7B <-----------------//  \\n # Intuition\\n- We can solve this Question Using Multiple Approach(Here I have Explained **4** Appraoch)\\n1. Sorting \\n2. Ordered Set\\n3. Max heap\\n4. In Place \\n \\n - **Pls see All the method for Clarity and the Last method is the**   **Best Optimal Solution** \\n - Time complexity O(n) \\n - Space Complexity O(1)\\n\\n #   Using Sorting \\n  **Time Complexity --> Nlog(N)**\\n   **Space Complexity --> O(1)**\\n# Code\\n``` \\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int count=0;\\n        int third_maximun=0;\\n        for(int i=nums.size()-1 ;i>0;i--){\\n            if(nums[i]!=nums[i-1]){\\n                count++;\\n                third_maximum=nums[i];\\n            }\\n           else if(i==1 && nums[i]==nums[i-1]){\\n                count++;\\n                third_maximum=nums[i];\\n            }\\n            if(count>2){\\n                 return third_maximum;\\n           }\\n        }\\n        if(count+1==3 && nums[0]!=nums[1]){\\n           return nums[0]; //if first and second index element not same [1,2,2,3]\\n        }\\n        return nums[nums.size()-1];  // if 3rd maximum not exist return maximum\\n    }\\n};\\n```\\n   #   Using set  \\n  **Time Complexity --> O(N)**\\n  **Space Complexity --> O(N)**\\n# Code\\n``` \\nclass Solution {\\npublic:\\n int thirdMax(vector<int>& nums) {\\n           set<int>s;\\n        for(int i=0;i<nums.size();i++){\\n            s.insert(nums[i]);\\n        }\\n        if(s.size()>=3){   // when set size >=3 means 3rd Maximum exist(because set does not contain duplicate element)\\n            int Third_index_from_last=s.size()-3;\\n            auto third_maximum=next(s.begin(),Third_index_from_last);\\n            return *third_maximum;\\n        }\\n            return *--s.end(); // return maximum if 3rd maximum not exist\\n    }\\n};\\n```\\n\\n\\n #   Using maxheap \\n# Code\\n``` \\nclass Solution {\\npublic:\\n // build max heap \\n    void maxhipify(vector<int>&nums,int n ,int i){\\n    int left=2*i+1;\\n    int right=2*i+2;\\n    int maximum=i;\\n    if(left<n && nums[left]>nums[i]){\\n        maximum=left;\\n    }\\n    if(right<n && nums[right]>nums[maximum] ){\\n        maximum=right;\\n    }\\n    if(maximum!=i){\\n        swap(nums[i],nums[maximum]);\\n        maxhipify(nums,n,maximum);\\n    }\\n}\\n// extract root element each time ( root is maximum element in maxheap  )\\n    void deleteRoot(vector<int>&nums,set<int>&s,int &n){\\n        int lastElement=nums[n-1];\\n        s.insert(nums[0]);\\n        nums[0]=lastElement;\\n        n=n-1;\\n        maxhipify(nums,n,0);\\n    }\\n\\n int thirdMax(vector<int>& nums) {\\n        if(nums.size()==1){            // when array size is 1\\n         return nums[0];   \\n        }\\n        if(nums.size()==2){               // when array size is 2\\n            return max(nums[0],nums[1]);\\n        }\\n        int n=nums.size();\\n\\n        for(int i=nums.size()/2;i>=0;i--){    // build max heap \\n            maxhipify(nums,n,i);\\n        }\\n        set<int>s;\\n        for(int i=0;i<nums.size();i++){   // extract root( maximum element each time )\\n            deleteRoot(nums,s,n);\\n        }\\n        if(s.size()<3){         //  3rd largest element does not exist \\n            return *--s.end();\\n        }else{                 // set s size >=3 3rd largest element exist\\n                int index=s.size()-3; // 3rd maximum index (index start with 0 )\\n                // using next() function\\n                auto it = next(s.begin(), index);   \\n                return   *it;\\n        }\\n    }\\n};\\n```\\n\\n# Best Solution In Place Algorithm\\n**Time Complexity O(n)\\nSpace Complexity O(1)**\\n# Code\\n``` \\nclass Solution {\\npublic:\\n int thirdMax(vector<int>& nums) {\\n        if(nums.size()==1){           // when size of Array is 1\\n         return nums[0];   \\n        }\\n        if(nums.size()==2){           // When size of array is 2\\n            return max(nums[0],nums[1]);\\n        }\\n // find First maximum element using *max_element() function\\n        int First_max=*max_element(nums.begin(),nums.end());   \\n\\t    int Second_max=INT_MIN;\\n        int Third_max=INT_MIN;\\n        int count1=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(Second_max<nums[i] && nums[i]!=First_max){\\n                Second_max=nums[i];\\n                count1++;\\n            }\\n        }\\n// if Second maximum element does not exist return First maximum element\\n        if(count1==0) return First_max; \\n        int count2=0;\\n        for(int i=0;i<nums.size();i++){\\n            if((Third_max<nums[i] || nums[i]==INT_MIN) && ( nums[i]!=First_max &&  nums[i]!=Second_max)){\\n                Third_max=nums[i];\\n                count2++;\\n            }\\n        }\\n        if(count2>0){\\n            return Third_max;\\n        }else{\\n            return First_max;\\n        }\\n    }\\n};\\n```\\n---\\n\\n\\uD83D\\uDC7B IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION\\uD83D\\uDC7B*\\n![image.png](https://assets.leetcode.com/users/images/14a3ceaa-fd34-46b0-a334-3b2395d99d77_1679831064.7105706.png)\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` \\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int count=0;\\n        int third_maximun=0;\\n        for(int i=nums.size()-1 ;i>0;i--){\\n            if(nums[i]!=nums[i-1]){\\n                count++;\\n                third_maximum=nums[i];\\n            }\\n           else if(i==1 && nums[i]==nums[i-1]){\\n                count++;\\n                third_maximum=nums[i];\\n            }\\n            if(count>2){\\n                 return third_maximum;\\n           }\\n        }\\n        if(count+1==3 && nums[0]!=nums[1]){\\n           return nums[0]; //if first and second index element not same [1,2,2,3]\\n        }\\n        return nums[nums.size()-1];  // if 3rd maximum not exist return maximum\\n    }\\n};\\n```\n``` \\nclass Solution {\\npublic:\\n int thirdMax(vector<int>& nums) {\\n           set<int>s;\\n        for(int i=0;i<nums.size();i++){\\n            s.insert(nums[i]);\\n        }\\n        if(s.size()>=3){   // when set size >=3 means 3rd Maximum exist(because set does not contain duplicate element)\\n            int Third_index_from_last=s.size()-3;\\n            auto third_maximum=next(s.begin(),Third_index_from_last);\\n            return *third_maximum;\\n        }\\n            return *--s.end(); // return maximum if 3rd maximum not exist\\n    }\\n};\\n```\n``` \\nclass Solution {\\npublic:\\n // build max heap \\n    void maxhipify(vector<int>&nums,int n ,int i){\\n    int left=2*i+1;\\n    int right=2*i+2;\\n    int maximum=i;\\n    if(left<n && nums[left]>nums[i]){\\n        maximum=left;\\n    }\\n    if(right<n && nums[right]>nums[maximum] ){\\n        maximum=right;\\n    }\\n    if(maximum!=i){\\n        swap(nums[i],nums[maximum]);\\n        maxhipify(nums,n,maximum);\\n    }\\n}\\n// extract root element each time ( root is maximum element in maxheap  )\\n    void deleteRoot(vector<int>&nums,set<int>&s,int &n){\\n        int lastElement=nums[n-1];\\n        s.insert(nums[0]);\\n        nums[0]=lastElement;\\n        n=n-1;\\n        maxhipify(nums,n,0);\\n    }\\n\\n int thirdMax(vector<int>& nums) {\\n        if(nums.size()==1){            // when array size is 1\\n         return nums[0];   \\n        }\\n        if(nums.size()==2){               // when array size is 2\\n            return max(nums[0],nums[1]);\\n        }\\n        int n=nums.size();\\n\\n        for(int i=nums.size()/2;i>=0;i--){    // build max heap \\n            maxhipify(nums,n,i);\\n        }\\n        set<int>s;\\n        for(int i=0;i<nums.size();i++){   // extract root( maximum element each time )\\n            deleteRoot(nums,s,n);\\n        }\\n        if(s.size()<3){         //  3rd largest element does not exist \\n            return *--s.end();\\n        }else{                 // set s size >=3 3rd largest element exist\\n                int index=s.size()-3; // 3rd maximum index (index start with 0 )\\n                // using next() function\\n                auto it = next(s.begin(), index);   \\n                return   *it;\\n        }\\n    }\\n};\\n```\n``` \\nclass Solution {\\npublic:\\n int thirdMax(vector<int>& nums) {\\n        if(nums.size()==1){           // when size of Array is 1\\n         return nums[0];   \\n        }\\n        if(nums.size()==2){           // When size of array is 2\\n            return max(nums[0],nums[1]);\\n        }\\n // find First maximum element using *max_element() function\\n        int First_max=*max_element(nums.begin(),nums.end());   \\n\\t    int Second_max=INT_MIN;\\n        int Third_max=INT_MIN;\\n        int count1=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(Second_max<nums[i] && nums[i]!=First_max){\\n                Second_max=nums[i];\\n                count1++;\\n            }\\n        }\\n// if Second maximum element does not exist return First maximum element\\n        if(count1==0) return First_max; \\n        int count2=0;\\n        for(int i=0;i<nums.size();i++){\\n            if((Third_max<nums[i] || nums[i]==INT_MIN) && ( nums[i]!=First_max &&  nums[i]!=Second_max)){\\n                Third_max=nums[i];\\n                count2++;\\n            }\\n        }\\n        if(count2>0){\\n            return Third_max;\\n        }else{\\n            return First_max;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 494431,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar thirdMax = function(nums) {\\n  let first = -Infinity;\\n  let second = -Infinity;\\n  let third = -Infinity;\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] === first || nums[i] === second || nums[i] === third) continue;\\n    if (nums[i] > first) {\\n      [first, second, third] = [nums[i], first, second];\\n    } else if (nums[i] > second) {\\n      [second, third] = [nums[i], second];\\n    } else if (nums[i] > third) {\\n      third = nums[i];\\n    }\\n  }\\n  return third === -Infinity ? first : third;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar thirdMax = function(nums) {\\n  let first = -Infinity;\\n  let second = -Infinity;\\n  let third = -Infinity;\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] === first || nums[i] === second || nums[i] === third) continue;\\n    if (nums[i] > first) {\\n      [first, second, third] = [nums[i], first, second];\\n    } else if (nums[i] > second) {\\n      [second, third] = [nums[i], second];\\n    } else if (nums[i] > third) {\\n      third = nums[i];\\n    }\\n  }\\n  return third === -Infinity ? first : third;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 90417,
                "title": "python-o-n-time-o-1-space",
                "content": "```\\nimport sys\\nclass Solution(object):\\n    def thirdMax(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        one = two = three = -sys.maxint\\n        for i in nums:\\n            if i > one:\\n                one, two, three = i, one, two\\n            elif i > two and i < one:\\n                two, three = i, two\\n            elif i > three and i < two:\\n                three = i\\n        return three if three != -sys.maxint else one",
                "solutionTags": [],
                "code": "```\\nimport sys\\nclass Solution(object):\\n    def thirdMax(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        one = two = three = -sys.maxint\\n        for i in nums:\\n            if i > one:\\n                one, two, three = i, one, two\\n            elif i > two and i < one:\\n                two, three = i, two\\n            elif i > three and i < two:\\n                three = i\\n        return three if three != -sys.maxint else one",
                "codeTag": "Java"
            },
            {
                "id": 1076170,
                "title": "java-100-faster-and-simple",
                "content": "```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n\\t\\n\\t\\t// taking long data type since array can contain Integer.MIN_VALUE\\n        long max = Long.MIN_VALUE, sMax = Long.MIN_VALUE, tMax = Long.MIN_VALUE;\\n        for (int i : nums) {\\n            if (i > max) {\\n                tMax = sMax;\\n                sMax = max;\\n                max = i;\\n            } else if (i > sMax && i != max) {\\n                tMax = sMax;\\n                sMax = i;\\n            } else if (i > tMax && i != sMax && i != max) {\\n                tMax = i;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// if thirdMax was not updated, return the first Max\\n\\t\\t\\n        return tMax == Long.MIN_VALUE ? (int) max : (int) tMax;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n\\t\\n\\t\\t// taking long data type since array can contain Integer.MIN_VALUE\\n        long max = Long.MIN_VALUE, sMax = Long.MIN_VALUE, tMax = Long.MIN_VALUE;\\n        for (int i : nums) {\\n            if (i > max) {\\n                tMax = sMax;\\n                sMax = max;\\n                max = i;\\n            } else if (i > sMax && i != max) {\\n                tMax = sMax;\\n                sMax = i;\\n            } else if (i > tMax && i != sMax && i != max) {\\n                tMax = i;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// if thirdMax was not updated, return the first Max\\n\\t\\t\\n        return tMax == Long.MIN_VALUE ? (int) max : (int) tMax;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857655,
                "title": "java-simple-solution-easy-beginner-friendly",
                "content": "class Solution {\\n    public int thirdMax(int[] nums) {\\n       Arrays.sort(nums);\\n        int n = nums.length;\\n        int count = 1;\\n        int flag = 0;\\n        for(int i=n-1;i>0;i--){\\n            if(nums[i] == nums[i-1]){\\n                flag = flag + 1; // for checking how many times max or second max value repeating\\n            }\\n            else{\\n                count = count + 1; // for getting distinct max value count (until 3rd max value)\\n            }\\n            if(count == 3){\\n                return nums[n-count-flag]; // n=total value , count = 3, flag = how many times max or second max repeating\\n            }\\n        }\\n        return nums[n-1];\\n\\n    }\\n}\\n\\n\\n// if you like my solution please upvote my solution\\n// Thank you for watching my solution",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int thirdMax(int[] nums) {\\n       Arrays.sort(nums);\\n        int n = nums.length;\\n        int count = 1;\\n        int flag = 0;\\n        for(int i=n-1;i>0;i--){\\n            if(nums[i] == nums[i-1]){\\n                flag = flag + 1; // for checking how many times max or second max value repeating\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1176643,
                "title": "neat-solution-java-c",
                "content": "**Java**\\n```\\nlong f = Long.MIN_VALUE;\\nlong s = Long.MIN_VALUE;\\nlong t = Long.MIN_VALUE;\\nfor (int n: nums) {\\n\\tif (n == f || n == s || n == t)\\n\\t\\tcontinue;\\n\\tif (n >= f) {\\n\\t\\tt = s;\\n\\t\\ts = f;\\n\\t\\tf = n;\\n\\t} else if (n >= s) {\\n\\t\\tt = s;\\n\\t\\ts = n;\\n\\t} else if (n >= t) {\\n\\t\\tt = n;\\n\\t}\\n}\\nif (t != Long.MIN_VALUE)\\n\\treturn (int)t;\\nelse if (f != Long.MIN_VALUE)\\n\\treturn (int)f;\\nelse\\n\\treturn (int)s;\\n```\\n**C++**\\n```\\nlong f = LONG_MIN;\\nlong s = LONG_MIN;\\nlong t = LONG_MIN;\\nfor (int n: nums) {\\n\\tif (n == f || n == s || n == t)\\n\\t\\tcontinue;\\n\\tif (n >= f) {\\n\\t\\tt = s;\\n\\t\\ts = f;\\n\\t\\tf = n;\\n\\t} else if (n >= s) {\\n\\t\\tt = s;\\n\\t\\ts = n;\\n\\t} else if (n >= t) {\\n\\t\\tt = n;\\n\\t}\\n}\\nif (t != LONG_MIN)\\n\\treturn (int)t;\\nelse if (f != LONG_MIN)\\n\\treturn (int)f;\\nelse\\n\\treturn (int)s;\\n}\\n```\\n**If you liked it, even a little bit then pls consider giving this solution a Upvote\\nThank You :)**",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nlong f = Long.MIN_VALUE;\\nlong s = Long.MIN_VALUE;\\nlong t = Long.MIN_VALUE;\\nfor (int n: nums) {\\n\\tif (n == f || n == s || n == t)\\n\\t\\tcontinue;\\n\\tif (n >= f) {\\n\\t\\tt = s;\\n\\t\\ts = f;\\n\\t\\tf = n;\\n\\t} else if (n >= s) {\\n\\t\\tt = s;\\n\\t\\ts = n;\\n\\t} else if (n >= t) {\\n\\t\\tt = n;\\n\\t}\\n}\\nif (t != Long.MIN_VALUE)\\n\\treturn (int)t;\\nelse if (f != Long.MIN_VALUE)\\n\\treturn (int)f;\\nelse\\n\\treturn (int)s;\\n```\n```\\nlong f = LONG_MIN;\\nlong s = LONG_MIN;\\nlong t = LONG_MIN;\\nfor (int n: nums) {\\n\\tif (n == f || n == s || n == t)\\n\\t\\tcontinue;\\n\\tif (n >= f) {\\n\\t\\tt = s;\\n\\t\\ts = f;\\n\\t\\tf = n;\\n\\t} else if (n >= s) {\\n\\t\\tt = s;\\n\\t\\ts = n;\\n\\t} else if (n >= t) {\\n\\t\\tt = n;\\n\\t}\\n}\\nif (t != LONG_MIN)\\n\\treturn (int)t;\\nelse if (f != LONG_MIN)\\n\\treturn (int)f;\\nelse\\n\\treturn (int)s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1090654,
                "title": "simple-java-solution-using-hashset-collections",
                "content": "```\\nimport java.util.Collections;\\nimport java.util.HashSet;\\nimport java.util.Set;\\n\\npublic static int thirdMax(int[] nums) {\\n        Set<Integer> hashSet = new HashSet<>();\\n        for (int num : nums) {\\n            hashSet.add(num);\\n        }\\n        if (hashSet.size() >= 3) {\\n            hashSet.remove(Collections.max(hashSet));\\n            hashSet.remove(Collections.max(hashSet));\\n        }\\n        return Collections.max(hashSet);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Collections;\\nimport java.util.HashSet;\\nimport java.util.Set;\\n\\npublic static int thirdMax(int[] nums) {\\n        Set<Integer> hashSet = new HashSet<>();\\n        for (int num : nums) {\\n            hashSet.add(num);\\n        }\\n        if (hashSet.size() >= 3) {\\n            hashSet.remove(Collections.max(hashSet));\\n            hashSet.remove(Collections.max(hashSet));\\n        }\\n        return Collections.max(hashSet);\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 352011,
                "title": "solution-in-python-3-beats-99-o-n",
                "content": "```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n    \\tn, T = list(set(nums)), [float(\\'-inf\\')]*3\\n    \\tfor i in n:\\n    \\t\\tif i > T[0]:\\n    \\t\\t\\tT = [i,T[0],T[1]]\\n    \\t\\t\\tcontinue\\n    \\t\\tif i > T[1]:\\n    \\t\\t\\tT = [T[0],i,T[1]]\\n    \\t\\t\\tcontinue\\n    \\t\\tif i > T[2]:\\n    \\t\\t\\tT = [T[0],T[1],i]\\n    \\treturn T[2] if T[2] != float(\\'-inf\\') else T[0]\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n    \\tn, T = list(set(nums)), [float(\\'-inf\\')]*3\\n    \\tfor i in n:\\n    \\t\\tif i > T[0]:\\n    \\t\\t\\tT = [i,T[0],T[1]]\\n    \\t\\t\\tcontinue\\n    \\t\\tif i > T[1]:\\n    \\t\\t\\tT = [T[0],i,T[1]]\\n    \\t\\t\\tcontinue\\n    \\t\\tif i > T[2]:\\n    \\t\\t\\tT = [T[0],T[1],i]\\n    \\treturn T[2] if T[2] != float(\\'-inf\\') else T[0]\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri",
                "codeTag": "Java"
            },
            {
                "id": 90396,
                "title": "o-n-time-o-1-space-java-short-solution",
                "content": "```\\n\\npublic class Solution {\\n    public int thirdMax(int[] nums) {\\n        long first=Long.MIN_VALUE;\\n        long second=Long.MIN_VALUE;\\n        long third=Long.MIN_VALUE;\\n        for(int i:nums){\\n            if(i>first){\\n                third=second;\\n                second=first;\\n                first=i;\\n            }else if(i==first)\\n                continue;\\n            else if(i>second){\\n                third=second;\\n                second=i;\\n            }else if(i==second)\\n                continue;\\n            else if(i>third){\\n                third=i;\\n            }\\n        }\\n        return third==Long.MIN_VALUE?(int)first:(int)third;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\npublic class Solution {\\n    public int thirdMax(int[] nums) {\\n        long first=Long.MIN_VALUE;\\n        long second=Long.MIN_VALUE;\\n        long third=Long.MIN_VALUE;\\n        for(int i:nums){\\n            if(i>first){\\n                third=second;\\n                second=first;\\n                first=i;\\n            }else if(i==first)\\n                continue;\\n            else if(i>second){\\n                third=second;\\n                second=i;\\n            }else if(i==second)\\n                continue;\\n            else if(i>third){\\n                third=i;\\n            }\\n        }\\n        return third==Long.MIN_VALUE?(int)first:(int)third;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 537295,
                "title": "javascript-97-5-faster",
                "content": "```\\nvar thirdMax = function(nums) {\\n    if(nums.length<3) return Math.max(...nums);\\n    let u = new Set(nums)\\n    if(u.size<3) return Math.max(...u);\\n    \\n    for(let i=0;i<2;i++){\\n        u.delete(Math.max(...u))\\n    }\\n    \\n    return Math.max(...u);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar thirdMax = function(nums) {\\n    if(nums.length<3) return Math.max(...nums);\\n    let u = new Set(nums)\\n    if(u.size<3) return Math.max(...u);\\n    \\n    for(let i=0;i<2;i++){\\n        u.delete(Math.max(...u))\\n    }\\n    \\n    return Math.max(...u);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 723937,
                "title": "c-naive-solution",
                "content": "***Runtime: 8 ms, faster than 97.58% of C++ online submissions for Third Maximum Number.\\nMemory Usage: 9 MB, less than 95.19% of C++ online submissions for Third Maximum Number.***\\n```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        long max1 = LONG_MIN;\\n        long max2 = LONG_MIN;\\n        long max3 = LONG_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == max1 | nums[i] == max2 | nums[i] ==max3)  continue;\\n            if(nums[i] > max1){\\n                max3 = max2;\\n                max2 = max1;\\n                max1 = nums[i];\\n            }else if(nums[i] > max2){\\n                max3 = max2;\\n                max2 = nums[i];\\n            }else if(nums[i] >= max3){\\n                max3 = nums[i];\\n            }\\n        }\\n        return max3 == LONG_MIN ? max1 : max3;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        long max1 = LONG_MIN;\\n        long max2 = LONG_MIN;\\n        long max3 = LONG_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == max1 | nums[i] == max2 | nums[i] ==max3)  continue;\\n            if(nums[i] > max1){\\n                max3 = max2;\\n                max2 = max1;\\n                max1 = nums[i];\\n            }else if(nums[i] > max2){\\n                max3 = max2;\\n                max2 = nums[i];\\n            }else if(nums[i] >= max3){\\n                max3 = nums[i];\\n            }\\n        }\\n        return max3 == LONG_MIN ? max1 : max3;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1024347,
                "title": "2-line-simple-and-intuitive-javascript-solution",
                "content": "Intuitive thinking process:\\n1. Remove all duplicates in the array\\n2. Sort the array in descending order\\n3. Get the element at the 2nd index (the third max) if the length of the processed array  > 2 (meaning that a third max exists), else returns the maximum of the array if its length <= 2 (meaning that a third max does not exist, and thus returns the max as instructed)\\n\\n```\\n [...new Set(nums)] // this part of code removes the duplicates in the array\\n ```\\n \\n ```\\n .sort((a,b) => b-a); // this part of code sorts the array in descending order (from largest to smallest)\\n ```\\n \\n```\\nvar thirdMax = function(nums) {\\n    nums = [...new Set(nums)].sort((a,b) => b-a);\\n    \\n    return (nums.length <= 2)? nums[0] : nums[2];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n [...new Set(nums)] // this part of code removes the duplicates in the array\\n ```\n```\\n .sort((a,b) => b-a); // this part of code sorts the array in descending order (from largest to smallest)\\n ```\n```\\nvar thirdMax = function(nums) {\\n    nums = [...new Set(nums)].sort((a,b) => b-a);\\n    \\n    return (nums.length <= 2)? nums[0] : nums[2];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2540738,
                "title": "python-99-faster-easy-solution",
                "content": "```\\ndef thirdMax(self, nums: List[int]) -> int:\\n        nums = sorted(list(set(nums)))\\n        if len(nums) > 2:\\n            return nums[-3]\\n        return nums[-1]\\n```\\n![image](https://assets.leetcode.com/users/images/c29a0e80-d2dd-4839-8057-b1e12d172a49_1662478635.7450721.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef thirdMax(self, nums: List[int]) -> int:\\n        nums = sorted(list(set(nums)))\\n        if len(nums) > 2:\\n            return nums[-3]\\n        return nums[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 90290,
                "title": "java-solution-in-0ms-run-time-o-n-and-space-o-1",
                "content": "```\\npublic int thirdMax(int[] nums) {\\n        int max, mid, small, count;\\n        max = mid = small = Integer.MIN_VALUE;\\n        count = 0;  //Count how many top elements have been found.\\n\\n        for( int x: nums) {\\n            //Skip loop if max or mid elements are duplicate. The purpose is for avoiding right shift.\\n            if( x == max || x == mid ) {\\n                continue;\\n            }\\n\\n            if (x > max) {\\n                //right shift\\n                small = mid;\\n                mid = max;\\n\\n                max = x;\\n                count++;\\n            } else if( x > mid) {\\n                //right shift\\n                small = mid;\\n\\n                mid = x;\\n                count++;\\n            } else if ( x >= small) { //if small duplicated, that's find, there's no shift and need to increase count.\\n                small = x;\\n                count++;\\n            }\\n        }\\n\\n        //\"count\" is used for checking whether found top 3 maximum elements.\\n        if( count >= 3) { \\n            return small;\\n        } else {\\n            return max;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int thirdMax(int[] nums) {\\n        int max, mid, small, count;\\n        max = mid = small = Integer.MIN_VALUE;\\n        count = 0;  //Count how many top elements have been found.\\n\\n        for( int x: nums) {\\n            //Skip loop if max or mid elements are duplicate. The purpose is for avoiding right shift.\\n            if( x == max || x == mid ) {\\n                continue;\\n            }\\n\\n            if (x > max) {\\n                //right shift\\n                small = mid;\\n                mid = max;\\n\\n                max = x;\\n                count++;\\n            } else if( x > mid) {\\n                //right shift\\n                small = mid;\\n\\n                mid = x;\\n                count++;\\n            } else if ( x >= small) { //if small duplicated, that's find, there's no shift and need to increase count.\\n                small = x;\\n                count++;\\n            }\\n        }\\n\\n        //\"count\" is used for checking whether found top 3 maximum elements.\\n        if( count >= 3) { \\n            return small;\\n        } else {\\n            return max;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1309868,
                "title": "python-o-n-time-o-1-space-easy-to-understand-solution",
                "content": "#### **Read the Comments carefully to understand the Solution!**\\n\\n```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        \\n        max1 = nums[0]  #Initialised the max with first index\\n        secmax = float(\\'-inf\\') \\n        thirmax = float(\\'-inf\\')\\n        #assuming second and third to be -infinity\\n        \\n        if len(nums)<3:\\n                return max(nums)\\n        #this won\\'t run more than 2 times and hence we can consider this in our O(n) solution!\\n        # It isn\\'t worth writing the Whole Loop logic here\\n        \\n        for i in range(len(nums)):\\n                num = nums[i]\\n                \\n\\t\\t\\t\\t#Read the below if conditions to get the approach of updating First, second and third max respectively\\n\\t\\t\\t\\t\\n                if (num>max1):\\n                        thirmax = secmax \\n                        secmax = max1\\n                        max1 = nums[i]\\n                        \\n                elif(num>secmax and num<max1):\\n                        thirmax = secmax\\n                        secmax = num\\n                        \\n                elif(num>thirmax and num<secmax):\\n                        thirmax = num\\n                        \\n        return thirmax if thirmax != float(\\'-inf\\') else max1\\n\\t\\t#if condition when the elements get repeated such that thirdmax remains -infinity\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        \\n        max1 = nums[0]  #Initialised the max with first index\\n        secmax = float(\\'-inf\\') \\n        thirmax = float(\\'-inf\\')\\n        #assuming second and third to be -infinity\\n        \\n        if len(nums)<3:\\n                return max(nums)\\n        #this won\\'t run more than 2 times and hence we can consider this in our O(n) solution!\\n        # It isn\\'t worth writing the Whole Loop logic here\\n        \\n        for i in range(len(nums)):\\n                num = nums[i]\\n                \\n\\t\\t\\t\\t#Read the below if conditions to get the approach of updating First, second and third max respectively\\n\\t\\t\\t\\t\\n                if (num>max1):\\n                        thirmax = secmax \\n                        secmax = max1\\n                        max1 = nums[i]\\n                        \\n                elif(num>secmax and num<max1):\\n                        thirmax = secmax\\n                        secmax = num\\n                        \\n                elif(num>thirmax and num<secmax):\\n                        thirmax = num\\n                        \\n        return thirmax if thirmax != float(\\'-inf\\') else max1\\n\\t\\t#if condition when the elements get repeated such that thirdmax remains -infinity\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1142691,
                "title": "using-set-c-faster-than-93",
                "content": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        int size=nums.size();\\n        set<int> s1;\\n        sort(nums.begin(),nums.end());\\n        for(int i=size-1;i>=0;i--)\\n        {\\n            s1.insert(nums[i]);\\n            if(s1.size()==3)\\n                break;\\n        }\\n        if(s1.size()<3)\\n            return *max_element (nums.begin(),nums.end());\\n        else \\n            return (*(s1.begin()));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        int size=nums.size();\\n        set<int> s1;\\n        sort(nums.begin(),nums.end());\\n        for(int i=size-1;i>=0;i--)\\n        {\\n            s1.insert(nums[i]);\\n            if(s1.size()==3)\\n                break;\\n        }\\n        if(s1.size()<3)\\n            return *max_element (nums.begin(),nums.end());\\n        else \\n            return (*(s1.begin()));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1051773,
                "title": "java-super-simple-treeset-solution",
                "content": "```\\n    public int thirdMax(int[] nums) {\\n        //init  treeSet\\n        //populate set\\n        //if the set size >= 3 pop off first 2 maxes\\n        //then return last element\\n        \\n        TreeSet<Integer> set = new TreeSet<>();\\n    \\n        for(int i : nums)\\n        {\\n            set.add(i);\\n        }\\n        \\n        if(set.size() >= 3)\\n        {\\n            set.pollLast();\\n            set.pollLast();\\n        }\\n        \\n        return set.last();\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\n    public int thirdMax(int[] nums) {\\n        //init  treeSet\\n        //populate set\\n        //if the set size >= 3 pop off first 2 maxes\\n        //then return last element\\n        \\n        TreeSet<Integer> set = new TreeSet<>();\\n    \\n        for(int i : nums)\\n        {\\n            set.add(i);\\n        }\\n        \\n        if(set.size() >= 3)\\n        {\\n            set.pollLast();\\n            set.pollLast();\\n        }\\n        \\n        return set.last();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 90232,
                "title": "java-solution-priorityqueue-o-1-space",
                "content": "We maintain a `PriorityQueue` whose size is always less than 3. In this way, the actual space complexity is O(1).\\n\\n```java\\npublic class Solution {\\n    public int thirdMax(int[] nums) {\\n        if (nums.length==1) return nums[0];\\n        else if(nums.length==2) return Math.max(nums[0], nums[1]);\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for (int num : nums) {\\n            if (pq.size() < 3 && !pq.contains(num)) {\\n                pq.add(num);\\n                continue;\\n            } else if (num > pq.peek() && !pq.contains(num)) {\\n                pq.poll();\\n                pq.add(num);\\n            }\\n        }\\n        \\n        if(pq.size() < 3) {\\n            while(pq.size() != 1) pq.poll();\\n        }\\n        \\n        return pq.peek();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic class Solution {\\n    public int thirdMax(int[] nums) {\\n        if (nums.length==1) return nums[0];\\n        else if(nums.length==2) return Math.max(nums[0], nums[1]);\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for (int num : nums) {\\n            if (pq.size() < 3 && !pq.contains(num)) {\\n                pq.add(num);\\n                continue;\\n            } else if (num > pq.peek() && !pq.contains(num)) {\\n                pq.poll();\\n                pq.add(num);\\n            }\\n        }\\n        \\n        if(pq.size() < 3) {\\n            while(pq.size() != 1) pq.poll();\\n        }\\n        \\n        return pq.peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 90351,
                "title": "java-solution-using-treeset",
                "content": "```\\npublic class Solution {\\n    public final int N = 3;\\n    public int thirdMax(int[] nums) {\\n        if (nums.length == 0) return 0;\\n\\n        TreeSet<Integer> set = new TreeSet<Integer>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (set.contains(nums[i])) continue;\\n            if (set.size() < N || nums[i] > set.first()) {\\n                if (set.size() == N) set.remove(set.first());\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.size() == N ? set.first() : set.last();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public final int N = 3;\\n    public int thirdMax(int[] nums) {\\n        if (nums.length == 0) return 0;\\n\\n        TreeSet<Integer> set = new TreeSet<Integer>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (set.contains(nums[i])) continue;\\n            if (set.size() < N || nums[i] > set.first()) {\\n                if (set.size() == N) set.remove(set.first());\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.size() == N ? set.first() : set.last();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3491404,
                "title": "java-hashset-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        Arrays.sort(nums);\\n        // if(nums.length<3) return nums[nums.length-1];\\n\\n        HashSet<Integer> s = new HashSet<>();\\n        \\n        for(int i=nums.length-1;i>=0;i--){\\n            s.add(nums[i]);\\n            if(s.size()==3) return nums[i];\\n\\n        }\\n        return nums[nums.length-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        Arrays.sort(nums);\\n        // if(nums.length<3) return nums[nums.length-1];\\n\\n        HashSet<Integer> s = new HashSet<>();\\n        \\n        for(int i=nums.length-1;i>=0;i--){\\n            s.add(nums[i]);\\n            if(s.size()==3) return nums[i];\\n\\n        }\\n        return nums[nums.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1861299,
                "title": "java-easy-understandable-o-n",
                "content": "## **Please Upvote if you understood this** (\\uFF5E\\uFFE3\\u25BD\\uFFE3)\\uFF5E\\n```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        if(nums.length == 1) return nums[0];\\n        if(nums.length == 2) return nums[1];\\n        \\n        long fMax=Long.MIN_VALUE, sMax=Long.MIN_VALUE, tMax=Long.MIN_VALUE;\\n        \\n        for(int i=0;i<nums.length;i++) if(fMax<nums[i]) fMax = nums[i];\\n        for(int i=0;i<nums.length;i++) if(nums[i]<fMax && sMax<nums[i]) sMax = nums[i];\\n        for(int i=0;i<nums.length;i++) if(nums[i]<sMax && tMax<nums[i]) tMax = nums[i];  \\n        \\n        return (int)( tMax!=Long.MIN_VALUE ? tMax : fMax);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        if(nums.length == 1) return nums[0];\\n        if(nums.length == 2) return nums[1];\\n        \\n        long fMax=Long.MIN_VALUE, sMax=Long.MIN_VALUE, tMax=Long.MIN_VALUE;\\n        \\n        for(int i=0;i<nums.length;i++) if(fMax<nums[i]) fMax = nums[i];\\n        for(int i=0;i<nums.length;i++) if(nums[i]<fMax && sMax<nums[i]) sMax = nums[i];\\n        for(int i=0;i<nums.length;i++) if(nums[i]<sMax && tMax<nums[i]) tMax = nums[i];  \\n        \\n        return (int)( tMax!=Long.MIN_VALUE ? tMax : fMax);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1687389,
                "title": "map-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        \\n        vector<int> ans;\\n        map<int,int>u;\\n        \\n        for(auto x : nums)\\n        {\\n            u[x]++;\\n        }\\n        \\n        for(auto x : u)\\n        {\\n            ans.push_back(x.first);\\n        }\\n        \\n        int n = ans.size();\\n        \\n       return (n<3)? ans[n-1] : ans[n-3];\\n        \\n        \\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        \\n        vector<int> ans;\\n        map<int,int>u;\\n        \\n        for(auto x : nums)\\n        {\\n            u[x]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1423354,
                "title": "2-simple-o-n-solutions",
                "content": "```\\n// Swap\\n// O(1) space\\nvar thirdMax = function (nums) {\\n  let first = Number.MIN_SAFE_INTEGER;\\n  let second = Number.MIN_SAFE_INTEGER;\\n  let third = Number.MIN_SAFE_INTEGER;\\n\\n  for (const num of nums) {\\n    if (num === first || num === second || num === third) continue;\\n\\n    if (num > first) {\\n      [third, second, first] = [second, first, num];\\n    } else if (num > second) {\\n      [third, second] = [second, num];\\n    } else if (num > third) {\\n      third = num;\\n    }\\n  }\\n\\n  return third === Number.MIN_SAFE_INTEGER ? first : third;\\n};\\n```\\n\\n```\\n// Javascript Set\\n// O(n) space\\nvar thirdMax = function (nums) {\\n  const set = new Set(nums);\\n  const first = Math.max(...set);\\n  if (set.size < 3) return first;\\n  set.delete(first);\\n  const second = Math.max(...set);\\n  set.delete(second);\\n  return Math.max(...set);\\n};\\n```\\n\\n\\nMore leetcode TypeScript solutions at https://github.com/eddyhdzg/leetcode-typescript-solutions\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n// Swap\\n// O(1) space\\nvar thirdMax = function (nums) {\\n  let first = Number.MIN_SAFE_INTEGER;\\n  let second = Number.MIN_SAFE_INTEGER;\\n  let third = Number.MIN_SAFE_INTEGER;\\n\\n  for (const num of nums) {\\n    if (num === first || num === second || num === third) continue;\\n\\n    if (num > first) {\\n      [third, second, first] = [second, first, num];\\n    } else if (num > second) {\\n      [third, second] = [second, num];\\n    } else if (num > third) {\\n      third = num;\\n    }\\n  }\\n\\n  return third === Number.MIN_SAFE_INTEGER ? first : third;\\n};\\n```\n```\\n// Javascript Set\\n// O(n) space\\nvar thirdMax = function (nums) {\\n  const set = new Set(nums);\\n  const first = Math.max(...set);\\n  if (set.size < 3) return first;\\n  set.delete(first);\\n  const second = Math.max(...set);\\n  set.delete(second);\\n  return Math.max(...set);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 986503,
                "title": "time-o-n-space-o-1-runtime-4-ms",
                "content": "```\\n#include <limits.h>\\n\\nint thirdMax(int* nums, int numsSize){\\n    \\n    int max_1 = nums[0];\\n    long max_2 = LONG_MIN;\\n    long max_3 = LONG_MIN;\\n    \\n    for (int i = 1; i < numsSize; i++){\\n        if (nums[i] > max_1){\\n            max_3 = max_2;\\n            max_2 = max_1;\\n            max_1 = nums[i];\\n        } else if (nums[i] > max_2 && nums[i] < max_1){\\n            max_3 = max_2;\\n            max_2 = nums[i];\\n        } else if (nums[i] > max_3 && nums[i] < max_2){\\n            max_3 = nums[i];\\n        }\\n    }\\n    return (max_3 == LONG_MIN) ? max_1 : max_3;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include <limits.h>\\n\\nint thirdMax(int* nums, int numsSize){\\n    \\n    int max_1 = nums[0];\\n    long max_2 = LONG_MIN;\\n    long max_3 = LONG_MIN;\\n    \\n    for (int i = 1; i < numsSize; i++){\\n        if (nums[i] > max_1){\\n            max_3 = max_2;\\n            max_2 = max_1;\\n            max_1 = nums[i];\\n        } else if (nums[i] > max_2 && nums[i] < max_1){\\n            max_3 = max_2;\\n            max_2 = nums[i];\\n        } else if (nums[i] > max_3 && nums[i] < max_2){\\n            max_3 = nums[i];\\n        }\\n    }\\n    return (max_3 == LONG_MIN) ? max_1 : max_3;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 284138,
                "title": "3-lines-python-o-n",
                "content": "```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        nums = set(nums)\\n        for _ in range((2, 0)[len(nums) < 3]): nums.remove(max(nums))\\n        return max(nums)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        nums = set(nums)\\n        for _ in range((2, 0)[len(nums) < 3]): nums.remove(max(nums))\\n        return max(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 90237,
                "title": "javascript-solution",
                "content": "```js\\nvar thirdMax = function(nums) {\\n    nums = Array.from(new Set(nums));\\n    var len = nums.length;\\n    if(len<=2){\\n    \\treturn Math.max(...nums);\\n    }\\n    if(len===3){\\n    \\treturn Math.min(...nums);\\n    }\\n    nums = nums.sort((a,b)=>{return b-a;})\\n    return nums[2];\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar thirdMax = function(nums) {\\n    nums = Array.from(new Set(nums));\\n    var len = nums.length;\\n    if(len<=2){\\n    \\treturn Math.max(...nums);\\n    }\\n    if(len===3){\\n    \\treturn Math.min(...nums);\\n    }\\n    nums = nums.sort((a,b)=>{return b-a;})\\n    return nums[2];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3172026,
                "title": "simple-c-solution-o-n-explained",
                "content": "\\n\\n# Approach\\nRun 3 for loops in the next loop just take the case that max doesn\\'t get count in iteration\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=INT_MIN,b=INT_MIN,c=INT_MIN;\\n        bool flg=0;\\n        for(int i=0;i<n;i++){\\n            a=max(a,nums[i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=a){\\n                b=max(b,nums[i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=a&&nums[i]!=b){\\n                c=max(c,nums[i]);\\n                flg=1;\\n            }\\n        }\\n        if(flg){\\n            return c;\\n        }\\n        else{\\n            return a;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=INT_MIN,b=INT_MIN,c=INT_MIN;\\n        bool flg=0;\\n        for(int i=0;i<n;i++){\\n            a=max(a,nums[i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=a){\\n                b=max(b,nums[i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=a&&nums[i]!=b){\\n                c=max(c,nums[i]);\\n                flg=1;\\n            }\\n        }\\n        if(flg){\\n            return c;\\n        }\\n        else{\\n            return a;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984327,
                "title": "java-simple-o-n-time-o-1-space-solution",
                "content": "```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        \\n        Integer max1 = null, max2 = null , max3 = null;\\n\\n        for (Integer num : nums){\\n            if(num.equals(max1) || num.equals(max2) || num.equals(max3)) continue;\\n            if(max1 == null || num > max1){\\n                max3=max2;\\n                max2=max1;\\n                max1=num;\\n            } else if(max2 == null || num > max2){\\n                max3=max2;\\n                max2=num;    \\n            } else if(max3 == null || num > max3){\\n                max3=num;\\n            }\\n        }\\n        return max3 == null ? max1 : max3;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        \\n        Integer max1 = null, max2 = null , max3 = null;\\n\\n        for (Integer num : nums){\\n            if(num.equals(max1) || num.equals(max2) || num.equals(max3)) continue;\\n            if(max1 == null || num > max1){\\n                max3=max2;\\n                max2=max1;\\n                max1=num;\\n            } else if(max2 == null || num > max2){\\n                max3=max2;\\n                max2=num;    \\n            } else if(max3 == null || num > max3){\\n                max3=num;\\n            }\\n        }\\n        return max3 == null ? max1 : max3;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 753661,
                "title": "o-1-space-golang-go",
                "content": "Runtime: 4 ms, faster than 93.78% of Go online submissions for Third Maximum Number.\\nMemory Usage: 3 MB, less than 100.00% of Go online submissions for Third Maximum Number.\\n```\\nimport \"math\"\\n\\n\\nfunc thirdMax(nums []int) int {\\n\\tmax, second, third := math.MinInt64, math.MinInt64, math.MinInt64\\n    \\n    for _, v := range nums {        \\n\\t\\tif v == max || v == second || v == third {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n        \\n        switch {\\n        case v > max:\\n            max, second, third = v, max, second\\n        case v > second:\\n            second, third = v, second\\n        case v > third:\\n            third = v\\n        }\\n\\t}\\n    \\n\\tif third == math.MinInt64 {\\n\\t\\treturn max\\n\\t}\\n    \\n\\treturn third\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nimport \"math\"\\n\\n\\nfunc thirdMax(nums []int) int {\\n\\tmax, second, third := math.MinInt64, math.MinInt64, math.MinInt64\\n    \\n    for _, v := range nums {        \\n\\t\\tif v == max || v == second || v == third {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n        \\n        switch {\\n        case v > max:\\n            max, second, third = v, max, second\\n        case v > second:\\n            second, third = v, second\\n        case v > third:\\n            third = v\\n        }\\n\\t}\\n    \\n\\tif third == math.MinInt64 {\\n\\t\\treturn max\\n\\t}\\n    \\n\\treturn third\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 656984,
                "title": "easy-c-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        long long int max1=LONG_MIN;\\n        long long int max2=LONG_MIN;\\n        long long int max3=LONG_MIN;\\n        bool fk=false;\\n        int sz=nums.size();\\n        for(int i=0;i<sz;i++)\\n        {\\n            if(nums[i]==INT_MIN)\\n            {\\n                fk=true;\\n            }\\n            if(nums[i]>max1)\\n            {\\n                max3=max2;\\n                max2=max1;\\n                max1=nums[i];\\n            }\\n            else if(nums[i]>max2 && nums[i]!=max1)\\n            {\\n                max3=max2;\\n                max2=nums[i];\\n            }\\n            else if(nums[i]>max3 && nums[i]!=max1 && nums[i]!=max2)\\n            {\\n                max3=nums[i];\\n            }\\n        }\\n       \\n        return max3==LONG_MIN ? max1 : max3;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        long long int max1=LONG_MIN;\\n        long long int max2=LONG_MIN;\\n        long long int max3=LONG_MIN;\\n        bool fk=false;\\n        int sz=nums.size();\\n        for(int i=0;i<sz;i++)\\n        {\\n            if(nums[i]==INT_MIN)\\n            {\\n                fk=true;\\n            }\\n            if(nums[i]>max1)\\n            {\\n                max3=max2;\\n                max2=max1;\\n                max1=nums[i];\\n            }\\n            else if(nums[i]>max2 && nums[i]!=max1)\\n            {\\n                max3=max2;\\n                max2=nums[i];\\n            }\\n            else if(nums[i]>max3 && nums[i]!=max1 && nums[i]!=max2)\\n            {\\n                max3=nums[i];\\n            }\\n        }\\n       \\n        return max3==LONG_MIN ? max1 : max3;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2236725,
                "title": "c-solution-3ms-7-lines-code-better-than-97-37",
                "content": "```\\nint thirdMax(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int count=1;\\n        for(int i=nums.size()-2; i>=0; i--){\\n            if(nums[i]<nums[i+1])                count++;\\n            if(count==3)    return nums[i];\\n        }\\n        return nums[nums.size()-1];\\n    }\\n```\\n![image](https://assets.leetcode.com/users/images/fd11f8d4-70da-42a4-b975-91aaee5dcdc1_1656938137.0121858.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nint thirdMax(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int count=1;\\n        for(int i=nums.size()-2; i>=0; i--){\\n            if(nums[i]<nums[i+1])                count++;\\n            if(count==3)    return nums[i];\\n        }\\n        return nums[nums.size()-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1244630,
                "title": "no-bullshit-c-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        int m1=INT_MIN;\\n        int m2=INT_MIN;\\n        int m3=INT_MIN;\\n        int flag=0;\\n        for(int n:nums)\\n        {\\n            if(n==INT_MIN)\\n                flag=1;\\n            if(n>m1)\\n            {\\n                m3=m2;\\n                m2=m1;\\n                m1=n;\\n            }\\n            else if(n>m2 && n<m1)\\n            {\\n                m3=m2;\\n                m2=n;\\n            }\\n            else if(n>m3 && n<m2)\\n            {\\n                m3=n;\\n            }\\n                \\n        }\\n        if(m1==m2 || m2==m3 || m3==m1)return m1;\\n        if(nums.size()==1)return m1;\\n        if(nums.size()==2)return m1;\\n        if(m3==INT_MIN && flag==0)return m1;\\n        return m3;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        int m1=INT_MIN;\\n        int m2=INT_MIN;\\n        int m3=INT_MIN;\\n        int flag=0;\\n        for(int n:nums)\\n        {\\n            if(n==INT_MIN)\\n                flag=1;\\n            if(n>m1)\\n            {\\n                m3=m2;\\n                m2=m1;\\n                m1=n;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 898518,
                "title": "cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        vector<int> v;\\n        v.push_back(nums[0]);\\n       \\n       \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]!=nums[i-1])\\n                v.push_back(nums[i]);\\n        }\\n       \\n        \\n        if(v.size()<3)\\n            return v[0];\\n        \\n            return v[2];\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        vector<int> v;\\n        v.push_back(nums[0]);\\n       \\n       \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]!=nums[i-1])\\n                v.push_back(nums[i]);\\n        }\\n       \\n        \\n        if(v.size()<3)\\n            return v[0];\\n        \\n            return v[2];\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 90350,
                "title": "python-2-5-lines-o-n-time-o-1-space",
                "content": "```\\ndef thirdMax(self, nums):\\n    l = [float('-inf')] * 3\\n    for n in nums:\\n        if n > l[0] and n not in l:\\n            heapq.heappushpop(l, n)\\n    return l[0] if l[0] != float('-inf') else max(l)\\n```\\n\\nA slightly shorter but uglier version based on the same concept is:\\n```\\ndef thirdMax(self, nums):\\n    l = [float('-inf')] * 3\\n    [heapq.heappushpop(l, n) for n in nums if n > l[0] and n not in l]\\n    return l[0] if l[0] != float('-inf') else max(l)\\n```\\nAlthough I'm not sure whether the second version is still O(1) space. Does anyone know whether the Python interpreter will create the whole list comprehension in memory even though it is not being assigned anywhere?\\n\\nUpdate: two line solution by @StefanPochmann [below](https://discuss.leetcode.com/topic/63962/python-3-5-lines-o-n-time-o-1-space/6).",
                "solutionTags": [],
                "code": "```\\ndef thirdMax(self, nums):\\n    l = [float('-inf')] * 3\\n    for n in nums:\\n        if n > l[0] and n not in l:\\n            heapq.heappushpop(l, n)\\n    return l[0] if l[0] != float('-inf') else max(l)\\n```\n```\\ndef thirdMax(self, nums):\\n    l = [float('-inf')] * 3\\n    [heapq.heappushpop(l, n) for n in nums if n > l[0] and n not in l]\\n    return l[0] if l[0] != float('-inf') else max(l)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3734522,
                "title": "one-liner-easy-to-understand-beginner-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        return max(list(set(nums))) if len(list(set(nums)))<3 else sorted(list(set(nums)))[-3]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        return max(list(set(nums))) if len(list(set(nums)))<3 else sorted(list(set(nums)))[-3]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123528,
                "title": "most-optimal-solution-o-n-o-1-space",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n- Testcase: [1, 2, -2147483648], [1, -2147483648, 2], [-2147483648, 1, 1]\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        int n = nums.size();\\n        bool flag = false;\\n        int first, second, third;\\n        first = second = third = INT_MIN;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] == INT_MIN){\\n                flag = true;\\n                continue;\\n            }\\n            if(nums[i] > first){\\n                third = second;\\n                second = first;\\n                first = nums[i];\\n            }\\n            else if(nums[i] > second && first != nums[i]){\\n                third = second;\\n                second = nums[i];\\n            }\\n            else if(nums[i] > third && first != nums[i] && second != nums[i]){\\n                third = nums[i];\\n            }\\n        }\\n        if(flag && third == INT_MIN && second != INT_MIN) return third;\\n        return (third != INT_MIN) ? third : first;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        int n = nums.size();\\n        bool flag = false;\\n        int first, second, third;\\n        first = second = third = INT_MIN;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] == INT_MIN){\\n                flag = true;\\n                continue;\\n            }\\n            if(nums[i] > first){\\n                third = second;\\n                second = first;\\n                first = nums[i];\\n            }\\n            else if(nums[i] > second && first != nums[i]){\\n                third = second;\\n                second = nums[i];\\n            }\\n            else if(nums[i] > third && first != nums[i] && second != nums[i]){\\n                third = nums[i];\\n            }\\n        }\\n        if(flag && third == INT_MIN && second != INT_MIN) return third;\\n        return (third != INT_MIN) ? third : first;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629480,
                "title": "easy-to-understand-c",
                "content": "class Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        set<int> a;\\n        vector<int> ans;\\n        \\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            a.insert(nums[i]);\\n        }\\n        \\n        \\n        for(auto x : a)\\n        {\\n            ans.push_back(x);\\n        }\\n        \\n        \\n        if(ans.size()==1)\\n        {\\n            return ans[0];\\n        }\\n        if(ans.size()==2)\\n        {\\n            sort(ans.begin(),ans.end());\\n            return ans[1];\\n        }\\n        \\n        if(ans.size()>=3)\\n            return ans[ans.size()-3];\\n        \\n        return ans[ans.size()]; }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        set<int> a;\\n        vector<int> ans;\\n        \\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            a.insert(nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1628730,
                "title": "javascript-solution",
                "content": "Javascript: sort & loop\\n```\\nvar thirdMax = function(nums) {\\n  let len = nums.length;\\n  \\n  nums.sort((a, b) => b - a);\\n  \\n  let count = 0;\\n  for (let i = 0; i < len; i++) {\\n    if (!nums[i+1] || nums[i] !== nums[i+1]) {\\n      count++;\\n      if (count === 3) return nums[i];\\n    }\\n  }\\n\\n  return nums[0];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar thirdMax = function(nums) {\\n  let len = nums.length;\\n  \\n  nums.sort((a, b) => b - a);\\n  \\n  let count = 0;\\n  for (let i = 0; i < len; i++) {\\n    if (!nums[i+1] || nums[i] !== nums[i+1]) {\\n      count++;\\n      if (count === 3) return nums[i];\\n    }\\n  }\\n\\n  return nums[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1374253,
                "title": "c-very-easy-solution",
                "content": "```class Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        int count=1;\\n        if(nums.size()<3)\\n            return nums[nums.size()-1];\\n        sort(nums.begin(),nums.end(),greater< int >());\\n        for(int i=1; i< nums.size(); i++){\\n            if(nums[i]!=nums[i-1])\\n                count++;\\n            if(count==3)\\n                return nums[i];\\n        }\\n           return nums[0];\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        int count=1;\\n        if(nums.size()<3)\\n            return nums[nums.size()-1];\\n        sort(nums.begin(),nums.end(),greater< int >());\\n        for(int i=1; i< nums.size(); i++){\\n            if(nums[i]!=nums[i-1])\\n                count++;\\n            if(count==3)\\n                return nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 405673,
                "title": "linkedlist-runtime-80-ms-100-mu-24-6-mb-100-00",
                "content": "***O(n) time, O(1) space.***\\nIt this solution doesn\\'t matter how many Maximum Number will you have.\\nI\\'m using Linked List for copying, moving and deleting nodes\\n\\n\\t\\tpublic int ThirdMax(int[] nums)\\n        {\\n            if (nums.Length == 0) return 0;\\n\\n            var list = new LinkedList<int>();\\n            list.AddFirst(nums[0]);\\n\\n            foreach (var num in nums)\\n            {\\n                if (list.First.Value == num ||\\n                    list.First.Next?.Value == num ||\\n                    list.Last.Value == num) continue;\\n                \\n                if (num > list.First.Value)\\n                    list.AddFirst(num);\\n                else if (num > list.First.Next?.Value)\\n                    list.AddAfter(list.First, num);\\n                else if (num > list.Last.Value)\\n                    list.Last.Value = num;\\n                else list.AddLast(num);\\n\\n                if (list.Count > 3)\\n                    list.RemoveLast();\\n            }\\n\\n            return list.Count != 3 ? list.First.Value : list.Last.Value;\\n        }",
                "solutionTags": [],
                "code": "***O(n) time, O(1) space.***\\nIt this solution doesn\\'t matter how many Maximum Number will you have.\\nI\\'m using Linked List for copying, moving and deleting nodes\\n\\n\\t\\tpublic int ThirdMax(int[] nums)\\n        {\\n            if (nums.Length == 0) return 0;\\n\\n            var list = new LinkedList<int>();\\n            list.AddFirst(nums[0]);\\n\\n            foreach (var num in nums)\\n            {\\n                if (list.First.Value == num ||\\n                    list.First.Next?.Value == num ||\\n                    list.Last.Value == num) continue;\\n                \\n                if (num > list.First.Value)\\n                    list.AddFirst(num);\\n                else if (num > list.First.Next?.Value)\\n                    list.AddAfter(list.First, num);\\n                else if (num > list.Last.Value)\\n                    list.Last.Value = num;\\n                else list.AddLast(num);\\n\\n                if (list.Count > 3)\\n                    list.RemoveLast();\\n            }\\n\\n            return list.Count != 3 ? list.First.Value : list.Last.Value;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 360118,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        set<int>S(nums.begin(),nums.end());\\n        priority_queue<int> pq(S.begin(),S.end());\\n        if(pq.size() == 1 || pq.size() == 2) return pq.top();\\n        pq.pop();\\n        pq.pop();\\n        return pq.top();\\n    }\\n };\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        set<int>S(nums.begin(),nums.end());\\n        priority_queue<int> pq(S.begin(),S.end());\\n        if(pq.size() == 1 || pq.size() == 2) return pq.top();\\n        pq.pop();\\n        pq.pop();\\n        return pq.top();\\n    }\\n };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 218937,
                "title": "rust-solution",
                "content": "```Rust\\nimpl Solution {\\n    pub fn third_max(nums: Vec<i32>) -> i32 {\\n        let mut first = None;\\n        let mut second = None;\\n        let mut third = None;\\n        let mut tmp;\\n        \\n        for n in nums {\\n            let n = Some(n);\\n            if n > first {\\n                tmp = second;\\n                second = first;\\n                first = n;\\n                third = tmp;\\n            } else if n < first && n > second {\\n                tmp = second;\\n                second = n;\\n                third = tmp;\\n            } else if n < second && n >= third {\\n                third = n;\\n            }\\n        }\\n        return third.unwrap_or(first.unwrap());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```Rust\\nimpl Solution {\\n    pub fn third_max(nums: Vec<i32>) -> i32 {\\n        let mut first = None;\\n        let mut second = None;\\n        let mut third = None;\\n        let mut tmp;\\n        \\n        for n in nums {\\n            let n = Some(n);\\n            if n > first {\\n                tmp = second;\\n                second = first;\\n                first = n;\\n                third = tmp;\\n            } else if n < first && n > second {\\n                tmp = second;\\n                second = n;\\n                third = tmp;\\n            } else if n < second && n >= third {\\n                third = n;\\n            }\\n        }\\n        return third.unwrap_or(first.unwrap());\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 181123,
                "title": "python3-46ms-beats-100",
                "content": "```\\nclass Solution:\\n    def thirdMax(self, nums):\\n\\n        s = set(nums)\\n        \\n        if len(s)<3:\\n            return max(s)\\n        \\n        s.remove(max(s))\\n        s.remove(max(s))\\n        return(max(s))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def thirdMax(self, nums):\\n\\n        s = set(nums)\\n        \\n        if len(s)<3:\\n            return max(s)\\n        \\n        s.remove(max(s))\\n        s.remove(max(s))\\n        return(max(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404119,
                "title": "third-maximum-number-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        \\n        unordered_set<int> set(nums.begin(), nums.end());\\n        vector<int> n(set.begin(), set.end());\\n        sort(n.begin(), n.end());\\n\\n        if(n.size()<3)\\n        {\\n            return n[n.size()-1];\\n        }\\n        return n[n.size()-3];\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        \\n        unordered_set<int> set(nums.begin(), nums.end());\\n        vector<int> n(set.begin(), set.end());\\n        sort(n.begin(), n.end());\\n\\n        if(n.size()<3)\\n        {\\n            return n[n.size()-1];\\n        }\\n        return n[n.size()-3];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257259,
                "title": "o-n-time-complexity-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        nums=set(nums)\\n        if len(nums)<3:\\n            return max(nums)\\n        else:\\n            nums.remove(max(nums))\\n            nums.remove(max(nums))\\n            return max(nums)\\n\\n\\n            \\n\\n           \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        nums=set(nums)\\n        if len(nums)<3:\\n            return max(nums)\\n        else:\\n            nums.remove(max(nums))\\n            nums.remove(max(nums))\\n            return max(nums)\\n\\n\\n            \\n\\n           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257218,
                "title": "awesome-code-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        if len(set(nums))<3:\\n            return max(nums)\\n        return sorted((set(nums)),reverse=True)[2]\\n#please upvote me it would encourage me alot\\n            \\n\\n           \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        if len(set(nums))<3:\\n            return max(nums)\\n        return sorted((set(nums)),reverse=True)[2]\\n#please upvote me it would encourage me alot\\n            \\n\\n           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228924,
                "title": "javascript-easiest-logic-ever",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar thirdMax = function (nums) {\\n    const arr = Array.from(new Set(nums)).sort((a, b) => b - a);\\n    return arr[2] === undefined ? arr[0] : arr[2];\\n}\\n```\\n```\\nvar thirdMax = function(nums) {\\n    let sorted=[...new Set(nums)].sort((a,b)=>b-a)\\n    if(sorted.length>=3) return sorted[2]\\n    else return sorted[0]\\n};\\n````",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar thirdMax = function (nums) {\\n    const arr = Array.from(new Set(nums)).sort((a, b) => b - a);\\n    return arr[2] === undefined ? arr[0] : arr[2];\\n}\\n```\n```\\nvar thirdMax = function(nums) {\\n    let sorted=[...new Set(nums)].sort((a,b)=>b-a)\\n    if(sorted.length>=3) return sorted[2]\\n    else return sorted[0]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3137594,
                "title": "c-beats-98-submissions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- MAX HEAP\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- This code implements a solution to find the third maximum number in a given vector of integers. It uses a combination of a priority queue and an unordered set to accomplish this.\\n\\n- The unordered set \\'us\\' is created from the input vector of integers (nums), and its purpose is to remove duplicates from the input.\\n\\n- The priority queue \\'pq\\' is then filled with the unique elements from the unordered set.\\n\\n- If the size of the priority queue is less than 3, the top (maximum) element is returned as the answer, as there are not enough elements in the priority queue to find the third maximum.\\n\\n- If the priority queue size is greater than or equal to 3, the code repeatedly pops the top (maximum) element from the priority queue until only 2 elements remain. The final top (maximum) element of the priority queue after 2 pops is then returned as the answer, which is the third maximum number.\\n\\n# Complexity\\n--> Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- The time complexity of this solution is O(nlog(n)), where n is the number of elements in the input vector nums. \\n\\n- This is because of the use of a priority queue, which takes O(log(n)) time for each insertion and O(1) time for each pop, and the unordered set, which takes O(n) time to create and O(1) time for each lookup.\\n \\n- The overall time complexity becomes O(nlog(n)) as each element is inserted into the priority queue and removed from the unordered set.\\n\\n\\n--> Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- The space complexity of this solution is O(n), where n is the number of elements in the input vector nums. This is because the unordered set and priority queue both store all of the unique elements from the input vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) \\n    {\\n        priority_queue <int> pq;\\n\\n        unordered_set <int> us(nums.begin(), nums.end());\\n\\n        for(auto x: us)\\n            pq.push(x);\\n\\n        if(pq.size() < 3)\\n          return pq.top();\\n\\n        int count = 0;\\n        while(pq.size() && count != 2)\\n        {\\n            count++;\\n            pq.pop();\\n        }\\n\\n        return pq.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) \\n    {\\n        priority_queue <int> pq;\\n\\n        unordered_set <int> us(nums.begin(), nums.end());\\n\\n        for(auto x: us)\\n            pq.push(x);\\n\\n        if(pq.size() < 3)\\n          return pq.top();\\n\\n        int count = 0;\\n        while(pq.size() && count != 2)\\n        {\\n            count++;\\n            pq.pop();\\n        }\\n\\n        return pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788181,
                "title": "c-easy-0ms-fast-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        // first sort the array in increasing order \\n        sort(nums.begin(),nums.end());\\n        // Now we have remove the duplicate elements from the vector \\n        // by using STL\\n        nums.erase(unique(nums.begin(),nums.end()),nums.end());\\n        // reverse the array\\n        reverse(nums.begin(),nums.end());\\n        //  if size of the array <3 then we can return the maximum element in an array\\n        if(nums.size()<3)return nums[0];\\n        // otherwise we can  return the  num[3-1];\\n        return nums[2];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        // first sort the array in increasing order \\n        sort(nums.begin(),nums.end());\\n        // Now we have remove the duplicate elements from the vector \\n        // by using STL\\n        nums.erase(unique(nums.begin(),nums.end()),nums.end());\\n        // reverse the array\\n        reverse(nums.begin(),nums.end());\\n        //  if size of the array <3 then we can return the maximum element in an array\\n        if(nums.size()<3)return nums[0];\\n        // otherwise we can  return the  num[3-1];\\n        return nums[2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709172,
                "title": "java-hashset",
                "content": "# Code\\n```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            set.add(nums[i]);\\n        }\\n\\n        List<Integer> list=new ArrayList<>(set);\\n        Collections.sort(list);\\n        if(list.size()<3){\\n            return list.get(list.size()-1);\\n        }\\n            return list.get(list.size()-3);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            set.add(nums[i]);\\n        }\\n\\n        List<Integer> list=new ArrayList<>(set);\\n        Collections.sort(list);\\n        if(list.size()<3){\\n            return list.get(list.size()-1);\\n        }\\n            return list.get(list.size()-3);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2659061,
                "title": "java-no-heap-or-set",
                "content": "### Please Upvote !!!\\n```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        Integer max = null, max2nd = null, max3rd = null;\\n\\n        for (Integer n : nums) {\\n            if (n.equals(max) || n.equals(max2nd) || n.equals(max3rd)) {\\n                continue;\\n            }\\n\\n            if (max == null || n > max) {\\n                max3rd = max2nd;\\n                max2nd = max;\\n                max = n;\\n            }\\n            else if (max2nd == null || n > max2nd) {\\n                max3rd = max2nd;\\n                max2nd = n;\\n            }\\n            else if (max3rd == null || n > max3rd) {\\n                max3rd = n;\\n            }\\n        }\\n\\n        return (max3rd == null) ? max : max3rd;\\n    }\\n}\\n\\n// TC: O(n)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        Integer max = null, max2nd = null, max3rd = null;\\n\\n        for (Integer n : nums) {\\n            if (n.equals(max) || n.equals(max2nd) || n.equals(max3rd)) {\\n                continue;\\n            }\\n\\n            if (max == null || n > max) {\\n                max3rd = max2nd;\\n                max2nd = max;\\n                max = n;\\n            }\\n            else if (max2nd == null || n > max2nd) {\\n                max3rd = max2nd;\\n                max2nd = n;\\n            }\\n            else if (max3rd == null || n > max3rd) {\\n                max3rd = n;\\n            }\\n        }\\n\\n        return (max3rd == null) ? max : max3rd;\\n    }\\n}\\n\\n// TC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263224,
                "title": "java-solution-o-n-1ms-97",
                "content": "Only use one loop. Please upvote if you like it :)\\n\\n```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        int max = Integer.MIN_VALUE, min = Integer.MAX_VALUE;\\n        int second = Integer.MIN_VALUE;\\n        int third  = Integer.MIN_VALUE;\\n\\n        for (int i=0;i<nums.length;i++) {\\n            \\n            if (max<nums[i]) {\\n                third = second;\\n                second = max;\\n                max = nums[i];\\n            }\\n            \\n            if (nums[i]<max && nums[i]> second) {\\n                third = second;\\n                second = nums[i];\\n            }\\n            \\n            if (nums[i]<second && nums[i]>third)\\n                third = nums[i];\\n           \\n            min = Math.min(min,nums[i]);\\n        }\\n        \\n        \\n        \\n        if ( third>=min && third<second && second < max)\\n            return third;\\n        else\\n            return max;\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        int max = Integer.MIN_VALUE, min = Integer.MAX_VALUE;\\n        int second = Integer.MIN_VALUE;\\n        int third  = Integer.MIN_VALUE;\\n\\n        for (int i=0;i<nums.length;i++) {\\n            \\n            if (max<nums[i]) {\\n                third = second;\\n                second = max;\\n                max = nums[i];\\n            }\\n            \\n            if (nums[i]<max && nums[i]> second) {\\n                third = second;\\n                second = nums[i];\\n            }\\n            \\n            if (nums[i]<second && nums[i]>third)\\n                third = nums[i];\\n           \\n            min = Math.min(min,nums[i]);\\n        }\\n        \\n        \\n        \\n        if ( third>=min && third<second && second < max)\\n            return third;\\n        else\\n            return max;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2182292,
                "title": "java-simple-solution-0ms-easy-understanding-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        int n=nums.length;\\n        long firstmax=Long.MIN_VALUE;   \\n        long secondmax=Long.MIN_VALUE;   \\n        long thirdmax=Long.MIN_VALUE;   \\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]>firstmax)\\n            {\\n                thirdmax=secondmax;\\n                secondmax=firstmax;\\n                firstmax=nums[i];\\n            }\\n            else if(nums[i]>secondmax &&nums[i]<firstmax)\\n            {\\n                thirdmax=secondmax;\\n                secondmax=nums[i];\\n            }\\n            else if(nums[i]>thirdmax && nums[i]<secondmax)\\n            {\\n                thirdmax=nums[i];\\n            }\\n        }\\n        return (int)(thirdmax==Long.MIN_VALUE ? firstmax : thirdmax);\\n        \\n    }\\n}\\n```\\nIf you do like the code\\n please upvote \\uD83D\\uDE42",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        int n=nums.length;\\n        long firstmax=Long.MIN_VALUE;   \\n        long secondmax=Long.MIN_VALUE;   \\n        long thirdmax=Long.MIN_VALUE;   \\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]>firstmax)\\n            {\\n                thirdmax=secondmax;\\n                secondmax=firstmax;\\n                firstmax=nums[i];\\n            }\\n            else if(nums[i]>secondmax &&nums[i]<firstmax)\\n            {\\n                thirdmax=secondmax;\\n                secondmax=nums[i];\\n            }\\n            else if(nums[i]>thirdmax && nums[i]<secondmax)\\n            {\\n                thirdmax=nums[i];\\n            }\\n        }\\n        return (int)(thirdmax==Long.MIN_VALUE ? firstmax : thirdmax);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1719597,
                "title": "javascript-o-n",
                "content": "```\\nvar thirdMax = function(nums) {\\n  let firstMax = -Infinity\\n  let secondMax = -Infinity\\n  let thirdMax = -Infinity\\n  \\n  for(let n of nums){\\n    if(n === firstMax || n === secondMax || n === thirdMax) continue\\n    \\n    if(firstMax < n){     \\n      thirdMax = secondMax\\n      secondMax = firstMax \\n      firstMax = n\\n    }else if(secondMax < n){\\n      thirdMax = secondMax       \\n      secondMax = n\\n    }else if(thirdMax < n){\\n      thirdMax = n\\n    }\\n  }\\n  if(thirdMax === -Infinity){\\n    return firstMax\\n  }else{\\n    return thirdMax\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar thirdMax = function(nums) {\\n  let firstMax = -Infinity\\n  let secondMax = -Infinity\\n  let thirdMax = -Infinity\\n  \\n  for(let n of nums){\\n    if(n === firstMax || n === secondMax || n === thirdMax) continue\\n    \\n    if(firstMax < n){     \\n      thirdMax = secondMax\\n      secondMax = firstMax \\n      firstMax = n\\n    }else if(secondMax < n){\\n      thirdMax = secondMax       \\n      secondMax = n\\n    }else if(thirdMax < n){\\n      thirdMax = n\\n    }\\n  }\\n  if(thirdMax === -Infinity){\\n    return firstMax\\n  }else{\\n    return thirdMax\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1657056,
                "title": "java-solution-with-explanation",
                "content": "```\\n/*The intitution is very simple first just sort the array and then\\ncheck from the last of the array for the third Maximum number */\\n\\n\\n\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        \\n        //first sort the array\\n        Arrays.sort(nums);\\n        \\n        //if the array has less then two element then just return the maximum vlaue\\n        //that is the last index value of the array\\n                if(nums.length<=2){\\n            return nums[nums.length-1];\\n        }\\n        \\n        \\n        //create a variable to store the previos value of the array\\n        int previous = Integer.MAX_VALUE;\\n        int count = 0;\\n        for(int p = nums.length -1; p>=0;p--){\\n            \\n            //if the previous element is not equal to the current element \\n            //that means distinct(not duplicate) then\\n            //store it in the previous variable and just increase the count value by one\\n            if(nums[p]!=previous){\\n                previous = nums[p];\\n                count++;\\n            }\\n            \\n            //when the count will be at 3 that means we are now at \\n            //third distinct maximum no so return it \\n            if(count ==3){\\n                return previous;\\n            }\\n        }\\n        \\n        \\n        //it is for the case like[1,6,6,6,6,6] for this case the return condition \\n        //of the above loop will never hit so below is the check for this condition\\n        //if the array contain duplicate largest value\\n        if(count >0){\\n            return nums[nums.length-1];\\n        }\\n        \\n        return previous;\\n        \\n    }\\n}\\n```\\nif you find the solution helpful, please upvote it",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*The intitution is very simple first just sort the array and then\\ncheck from the last of the array for the third Maximum number */\\n\\n\\n\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        \\n        //first sort the array\\n        Arrays.sort(nums);\\n        \\n        //if the array has less then two element then just return the maximum vlaue\\n        //that is the last index value of the array\\n                if(nums.length<=2){\\n            return nums[nums.length-1];\\n        }\\n        \\n        \\n        //create a variable to store the previos value of the array\\n        int previous = Integer.MAX_VALUE;\\n        int count = 0;\\n        for(int p = nums.length -1; p>=0;p--){\\n            \\n            //if the previous element is not equal to the current element \\n            //that means distinct(not duplicate) then\\n            //store it in the previous variable and just increase the count value by one\\n            if(nums[p]!=previous){\\n                previous = nums[p];\\n                count++;\\n            }\\n            \\n            //when the count will be at 3 that means we are now at \\n            //third distinct maximum no so return it \\n            if(count ==3){\\n                return previous;\\n            }\\n        }\\n        \\n        \\n        //it is for the case like[1,6,6,6,6,6] for this case the return condition \\n        //of the above loop will never hit so below is the check for this condition\\n        //if the array contain duplicate largest value\\n        if(count >0){\\n            return nums[nums.length-1];\\n        }\\n        \\n        return previous;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1651998,
                "title": "o-n-time-o-1-space-c-100-faster-without-using-long-int-type",
                "content": "![image](https://assets.leetcode.com/users/images/df557862-3491-40f9-a2fe-134c6e6a9a9f_1640671696.049484.png)\\n```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int first = INT_MIN, second = INT_MIN, third = INT_MIN;\\n        \\n        bool flag = false;\\n        \\n        for(int i=0; i<n; ++i) {\\n            \\n            if(first<nums[i]) {\\n                third = second;\\n                second = first;\\n                first = nums[i];\\n            }\\n            else if(first>nums[i] and second<nums[i]) {\\n                third = second;\\n                second = nums[i];\\n            }\\n            else if(second>nums[i] and third<nums[i]) {\\n                third = nums[i];\\n            }\\n            \\n            if(nums[i]==INT_MIN)\\n                flag = true;\\n        }\\n        \\n        if(flag) {\\n            if(first!=second and second!=third) {\\n                return third;\\n            }\\n            return first;\\n        }\\n        \\n        if(third==INT_MIN)\\n            return first;\\n        return third;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int first = INT_MIN, second = INT_MIN, third = INT_MIN;\\n        \\n        bool flag = false;\\n        \\n        for(int i=0; i<n; ++i) {\\n            \\n            if(first<nums[i]) {\\n                third = second;\\n                second = first;\\n                first = nums[i];\\n            }\\n            else if(first>nums[i] and second<nums[i]) {\\n                third = second;\\n                second = nums[i];\\n            }\\n            else if(second>nums[i] and third<nums[i]) {\\n                third = nums[i];\\n            }\\n            \\n            if(nums[i]==INT_MIN)\\n                flag = true;\\n        }\\n        \\n        if(flag) {\\n            if(first!=second and second!=third) {\\n                return third;\\n            }\\n            return first;\\n        }\\n        \\n        if(third==INT_MIN)\\n            return first;\\n        return third;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1018124,
                "title": "java-solution",
                "content": "```\\n\\t/*\\n\\t * Runtime: 0 ms, faster than 100.00% of Java online submissions for Third\\n\\t * Maximum Number. Memory Usage: 38.8 MB, less than 54.59% of Java online\\n\\t * submissions for Third Maximum Number.\\n\\t */\\n\\tpublic int thirdMax(int[] nums) {\\n\\t\\t// Initialize three max values\\n\\t\\tint max1 = Integer.MIN_VALUE;\\n\\t\\tint max2 = Integer.MIN_VALUE;\\n\\t\\tint max3 = Integer.MIN_VALUE;\\n\\n\\t\\t// If the array has only one value, return that value\\n\\t\\tif (nums.length == 1) {\\n\\t\\t\\treturn nums[0];\\n\\t\\t}\\n\\n\\t\\t// If the array has only two values, return the largest of those values\\n\\t\\tif (nums.length == 2) {\\n\\t\\t\\treturn (nums[0] > nums[1]) ? nums[0] : nums[1];\\n\\t\\t}\\n\\n\\t\\t// Iterate through array, finding the three largest values\\n\\t\\t// count the number of distinct values\\n\\t\\tboolean minValueUsed = false;\\n\\t\\tint count = 0;\\n\\t\\tfor (int value : nums) {\\n\\t\\t\\t// Since the max values were initialized at Integer.MIN_VALUE, check if\\n\\t\\t\\t// Integer.MIN_VALUE\\n\\t\\t\\t// is included in the array, but only count it once.\\n\\t\\t\\tif (value == Integer.MIN_VALUE && !minValueUsed) {\\n\\t\\t\\t\\tminValueUsed = true;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (value == max1 || value == max2 || value == max3) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (value > max1) {\\n\\t\\t\\t\\t\\tmax3 = max2;\\n\\t\\t\\t\\t\\tmax2 = max1;\\n\\t\\t\\t\\t\\tmax1 = value;\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t} else if (value > max2) {\\n\\t\\t\\t\\t\\tmax3 = max2;\\n\\t\\t\\t\\t\\tmax2 = value;\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t} else if (value > max3) {\\n\\t\\t\\t\\t\\tmax3 = value;\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// If there were more than two distinct values, return the third largest.\\n\\t\\tif (count > 2) {\\n\\t\\t\\treturn max3;\\n\\t\\t} else {\\n\\t\\t\\t// If there were less than three distinct values, return the largest value\\n\\t\\t\\treturn max1;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "```\\n\\t/*\\n\\t * Runtime: 0 ms, faster than 100.00% of Java online submissions for Third\\n\\t * Maximum Number. Memory Usage: 38.8 MB, less than 54.59% of Java online\\n\\t * submissions for Third Maximum Number.\\n\\t */\\n\\tpublic int thirdMax(int[] nums) {\\n\\t\\t// Initialize three max values\\n\\t\\tint max1 = Integer.MIN_VALUE;\\n\\t\\tint max2 = Integer.MIN_VALUE;\\n\\t\\tint max3 = Integer.MIN_VALUE;\\n\\n\\t\\t// If the array has only one value, return that value\\n\\t\\tif (nums.length == 1) {\\n\\t\\t\\treturn nums[0];\\n\\t\\t}\\n\\n\\t\\t// If the array has only two values, return the largest of those values\\n\\t\\tif (nums.length == 2) {\\n\\t\\t\\treturn (nums[0] > nums[1]) ? nums[0] : nums[1];\\n\\t\\t}\\n\\n\\t\\t// Iterate through array, finding the three largest values\\n\\t\\t// count the number of distinct values\\n\\t\\tboolean minValueUsed = false;\\n\\t\\tint count = 0;\\n\\t\\tfor (int value : nums) {\\n\\t\\t\\t// Since the max values were initialized at Integer.MIN_VALUE, check if\\n\\t\\t\\t// Integer.MIN_VALUE\\n\\t\\t\\t// is included in the array, but only count it once.\\n\\t\\t\\tif (value == Integer.MIN_VALUE && !minValueUsed) {\\n\\t\\t\\t\\tminValueUsed = true;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (value == max1 || value == max2 || value == max3) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (value > max1) {\\n\\t\\t\\t\\t\\tmax3 = max2;\\n\\t\\t\\t\\t\\tmax2 = max1;\\n\\t\\t\\t\\t\\tmax1 = value;\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t} else if (value > max2) {\\n\\t\\t\\t\\t\\tmax3 = max2;\\n\\t\\t\\t\\t\\tmax2 = value;\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t} else if (value > max3) {\\n\\t\\t\\t\\t\\tmax3 = value;\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// If there were more than two distinct values, return the third largest.\\n\\t\\tif (count > 2) {\\n\\t\\t\\treturn max3;\\n\\t\\t} else {\\n\\t\\t\\t// If there were less than three distinct values, return the largest value\\n\\t\\t\\treturn max1;\\n\\t\\t}\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 150439,
                "title": "c-solution-no-set-or-sort-using-a-bool-var-to-examine-special-case",
                "content": "```class Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        int res;\\n        int a, b, c;\\n        bool min_flag=0;\\n        a=b=c=INT_MIN;\\n        for(auto num : nums) {\\n            if(num==INT_MIN) min_flag=1;\\n            if(num==a || num==b || num==c) continue;\\n            if(num>c) c=num;\\n            if(c>b) swap(c, b);\\n            if(b>a) swap(b, a);\\n        }\\n        res = min_flag?((b==INT_MIN)?a:c):((c==INT_MIN)?a:c);\\n        return res;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        int res;\\n        int a, b, c;\\n        bool min_flag=0;\\n        a=b=c=INT_MIN;\\n        for(auto num : nums) {\\n            if(num==INT_MIN) min_flag=1;\\n            if(num==a || num==b || num==c) continue;\\n            if(num>c) c=num;\\n            if(c>b) swap(c, b);\\n            if(b>a) swap(b, a);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3597975,
                "title": "third-maximum-number-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are two ways to solve it: the first one which I have put in comment part, in it we find the first maximum one by one as it is in a unsorted array but in the second one we have sorted the array because of which we need not to swap the values.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\n/*class Solution {\\n    public int thirdMax(int[] nums) {\\n        long m1=Long.MIN_VALUE;\\n        long m2=Long.MIN_VALUE;\\n        long m3=Long.MIN_VALUE;\\n        for(int i:nums)\\n        {\\n            if(i>m1)\\n            {\\n                m3=m2;\\n                m2=m1;\\n                m1=i;\\n            }\\n            else if(m1>i && i>m2)\\n            {\\n                m3=m2;\\n                m2=i;\\n            }\\n            else if(m2>i && i>m3)\\n             m3=i;\\n        }\\n        return (m3==Long.MIN_VALUE ? (int)m1 :(int) m3);\\n    }\\n}*/\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        long m1=Long.MIN_VALUE;\\n        long m2=Long.MIN_VALUE;\\n        long m3=Long.MIN_VALUE;\\n        Arrays.sort(nums);\\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            if(nums[i]>m1)\\n             m1=nums[i];\\n            else if(m1>nums[i] && nums[i]>m2)\\n             m2=nums[i];\\n            else if(m2>nums[i] && nums[i]>m3)\\n             m3=nums[i];\\n        }\\n        return (m3==Long.MIN_VALUE ? (int)m1 :(int) m3);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*class Solution {\\n    public int thirdMax(int[] nums) {\\n        long m1=Long.MIN_VALUE;\\n        long m2=Long.MIN_VALUE;\\n        long m3=Long.MIN_VALUE;\\n        for(int i:nums)\\n        {\\n            if(i>m1)\\n            {\\n                m3=m2;\\n                m2=m1;\\n                m1=i;\\n            }\\n            else if(m1>i && i>m2)\\n            {\\n                m3=m2;\\n                m2=i;\\n            }\\n            else if(m2>i && i>m3)\\n             m3=i;\\n        }\\n        return (m3==Long.MIN_VALUE ? (int)m1 :(int) m3);\\n    }\\n}*/\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        long m1=Long.MIN_VALUE;\\n        long m2=Long.MIN_VALUE;\\n        long m3=Long.MIN_VALUE;\\n        Arrays.sort(nums);\\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            if(nums[i]>m1)\\n             m1=nums[i];\\n            else if(m1>nums[i] && nums[i]>m2)\\n             m2=nums[i];\\n            else if(m2>nums[i] && nums[i]>m3)\\n             m3=nums[i];\\n        }\\n        return (m3==Long.MIN_VALUE ? (int)m1 :(int) m3);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3536785,
                "title": "easy-java-solution-with-explanation-beats-100-0ms",
                "content": "# Approach\\nThis code aims to find the third maximum value in an array of integers (`nums`). Let\\'s break down the code step by step:\\n\\n1. Three variables are declared and initialized with the minimum possible value for a `long` data type: `max`, `secondMax`, and `thirdMax`. These variables will keep track of the first, second, and third maximum values encountered in the array.\\n\\n2. The code then iterates through each element (`num`) in the `nums` array using an enhanced for loop.\\n\\n3. Inside the loop, the code checks if the current element (`num`) is greater than the current maximum (`max`).\\n\\n4. If `num` is greater than `max`, the variables are updated accordingly:\\n   - The current value of `secondMax` is assigned to `thirdMax`.\\n   - The current value of `max` is assigned to `secondMax`.\\n   - The value of `num` becomes the new `max`.\\n\\n5. If `num` is not greater than `max`, the code checks if it is greater than `secondMax` and less than `max`. This condition ensures that `num` becomes the second maximum value.\\n\\n6. If `num` is not greater than `max` or `secondMax`, the code checks if it is greater than `thirdMax` and less than `secondMax`. If true, `num` becomes the third maximum value.\\n\\n7. After iterating through all the elements in the array, the code checks if the third maximum value was updated from its initial value (`Long.MIN_VALUE`). If it wasn\\'t, it means that there is no distinct third maximum value in the array. In this case, the code returns the maximum value (`max`), cast to an integer.\\n\\n8. If the third maximum value was updated, the code returns the value of `thirdMax`, cast to an integer.\\n\\nThe code utilizes the `long` data type for the maximum variables to handle the possibility of large input values that might exceed the range of `int`.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        long max = Long.MIN_VALUE;\\n        long secondMax = Long.MIN_VALUE;\\n        long thirdMax = Long.MIN_VALUE;\\n\\n        for (int num:nums){\\n            if (num> max){\\n                thirdMax = secondMax;\\n                secondMax = max;\\n                max = num;\\n            } else if (num>secondMax && num<max) {\\n                thirdMax = secondMax;\\n                secondMax = num;\\n            } else if (num>thirdMax && num<secondMax) {\\n                thirdMax = num;\\n            }\\n        }\\n        int result = (thirdMax==Long.MIN_VALUE) ? (int)max : (int)thirdMax;\\n        return result;\\n    }\\n}\\n```\\n**Please upvote if you like the solution.\\nHappy Coding**",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        long max = Long.MIN_VALUE;\\n        long secondMax = Long.MIN_VALUE;\\n        long thirdMax = Long.MIN_VALUE;\\n\\n        for (int num:nums){\\n            if (num> max){\\n                thirdMax = secondMax;\\n                secondMax = max;\\n                max = num;\\n            } else if (num>secondMax && num<max) {\\n                thirdMax = secondMax;\\n                secondMax = num;\\n            } else if (num>thirdMax && num<secondMax) {\\n                thirdMax = num;\\n            }\\n        }\\n        int result = (thirdMax==Long.MIN_VALUE) ? (int)max : (int)thirdMax;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303376,
                "title": "using-heapq-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        nums=list(set(nums))\\n        if len(nums)<3:\\n            return max(nums)\\n        n=[-i for i in nums]\\n        heapq.heapify(n)\\n        for i in range(3):\\n            poping=heapq.heappop(n)\\n            if i==2:\\n                return -(poping)\\n            \\n\\n           \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        nums=list(set(nums))\\n        if len(nums)<3:\\n            return max(nums)\\n        n=[-i for i in nums]\\n        heapq.heapify(n)\\n        for i in range(3):\\n            poping=heapq.heappop(n)\\n            if i==2:\\n                return -(poping)\\n            \\n\\n           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629514,
                "title": "c-easy-to-understand-beginners-friendly-set-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        set<int> st;\\n        for(auto it : nums){\\n            st.insert(it);\\n        }\\n        vector<int> temp;\\n        for(auto it : st){\\n            temp.push_back(it);\\n        }\\n        if(st.size() >= 3){\\n            return temp[temp.size()-3];\\n        }\\n        else{\\n            return temp[temp.size()-1];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        set<int> st;\\n        for(auto it : nums){\\n            st.insert(it);\\n        }\\n        vector<int> temp;\\n        for(auto it : st){\\n            temp.push_back(it);\\n        }\\n        if(st.size() >= 3){\\n            return temp[temp.size()-3];\\n        }\\n        else{\\n            return temp[temp.size()-1];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2466021,
                "title": "java-solution-in-simple-and-in-minimum-lines",
                "content": "```\\nclass Solution {\\n    public int thirdMax(int[] arr) {\\n        SortedSet< Integer > set = new TreeSet<>();\\n        for ( int e : arr ) set.add(e);\\n        if ( set.size() == 1 ) return set.first();\\n        else if ( set.size() == 2 ) return set.last();\\n        set.remove(set.last());\\n        set.remove(set.last());\\n        return set.last();\\n    }\\n}\\n```\\n\\nvote up if you find usefull !!!",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int thirdMax(int[] arr) {\\n        SortedSet< Integer > set = new TreeSet<>();\\n        for ( int e : arr ) set.add(e);\\n        if ( set.size() == 1 ) return set.first();\\n        else if ( set.size() == 2 ) return set.last();\\n        set.remove(set.last());\\n        set.remove(set.last());\\n        return set.last();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910739,
                "title": "very-easy-c-solution-with-comments",
                "content": "```\\n    int thirdMax(vector<int>& nums) {\\n        set<int> s(nums.begin() , nums.end());  //first we put all the elements in a set to remove all duplicate elements \\n        vector<int> ans;  //we create an empty array to put elements back from set.\\n        \\n        for(auto it: s){\\n            ans.push_back(it);\\n        }\\n        sort(ans.begin() , ans.end() , greater<int>());     //sort the array in descending order.\\n        \\n        if(ans.size()==1 or ans.size()==2 )         //corner case  if size of array is less than 3 then we have to return 2 largest element.\\n            return ans[0];\\n\\t\\t\\t\\n        return ans[2];         //return the answer.\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int thirdMax(vector<int>& nums) {\\n        set<int> s(nums.begin() , nums.end());  //first we put all the elements in a set to remove all duplicate elements \\n        vector<int> ans;  //we create an empty array to put elements back from set.\\n        \\n        for(auto it: s){\\n            ans.push_back(it);\\n        }\\n        sort(ans.begin() , ans.end() , greater<int>());     //sort the array in descending order.\\n        \\n        if(ans.size()==1 or ans.size()==2 )         //corner case  if size of array is less than 3 then we have to return 2 largest element.\\n            return ans[0];\\n\\t\\t\\t\\n        return ans[2];         //return the answer.\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1910071,
                "title": "java-0ms-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        \\n        long firstMax = Long.MIN_VALUE;\\n        long secondMax = Long.MIN_VALUE;\\n        long thirdMax = Long.MIN_VALUE;\\n        \\n        for(int i = 0; i<nums.length; i++){\\n            if(nums[i]>firstMax){\\n                thirdMax = secondMax;\\n                secondMax = firstMax;\\n                firstMax = nums[i];\\n            }\\n            else if(nums[i]>secondMax && nums[i]<firstMax){\\n                thirdMax = secondMax;\\n                secondMax = nums[i];\\n            }\\n            else if(nums[i]>thirdMax && nums[i]<secondMax) thirdMax = nums[i];\\n        }\\n        \\n        if(thirdMax == Long.MIN_VALUE) return (int)firstMax;\\n        \\n        return (int)thirdMax;\\n    }\\n}\\n```\\n\\nDo UPVOTE if it helped you. Happy Learning !!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        \\n        long firstMax = Long.MIN_VALUE;\\n        long secondMax = Long.MIN_VALUE;\\n        long thirdMax = Long.MIN_VALUE;\\n        \\n        for(int i = 0; i<nums.length; i++){\\n            if(nums[i]>firstMax){\\n                thirdMax = secondMax;\\n                secondMax = firstMax;\\n                firstMax = nums[i];\\n            }\\n            else if(nums[i]>secondMax && nums[i]<firstMax){\\n                thirdMax = secondMax;\\n                secondMax = nums[i];\\n            }\\n            else if(nums[i]>thirdMax && nums[i]<secondMax) thirdMax = nums[i];\\n        }\\n        \\n        if(thirdMax == Long.MIN_VALUE) return (int)firstMax;\\n        \\n        return (int)thirdMax;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1843358,
                "title": "c-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        set<int> s(nums.begin(),nums.end());\\n        vector<int>vec(s.begin(),s.end());\\n        if(vec.size()<3)\\n        {\\n            return vec[vec.size()-1];\\n        }\\n        else\\n        {\\n            return vec[vec.size()-3];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        set<int> s(nums.begin(),nums.end());\\n        vector<int>vec(s.begin(),s.end());\\n        if(vec.size()<3)\\n        {\\n            return vec[vec.size()-1];\\n        }\\n        else\\n        {\\n            return vec[vec.size()-3];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718449,
                "title": "third-max-element-c-with-explanation",
                "content": "``` \\nint thirdMax(vector<int>& nums) {\\n        \\n        //copy each elemnt of vector(nums) to set(st)\\n        //which will automatically eliminate duplicates\\n       \\n    set<int>st(nums.begin(),nums.end());\\n        \\n        \\n        //if the size of set(st) less than 3 we will return the maximum element \\n        //else  return the 3rd max elemnt\\n    \\n        \\n        \\n        return st.size()<3?*max_element(st.begin(),st.end()):*next(st.begin(),st.size()-3);\\n        \\n        \\n        \\n        //explanation with a example\\n        //nums[]=1,2,3,5\\n        //here size is greater than 3 so 3rd max elmnt will be returned\\n        //*next(st.begin(),st.size()-3)==>  it will return the 3\\n        \\n        \\n        \\n        \\n    \\n    }\\n\\t\\n        ```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "``` \\nint thirdMax(vector<int>& nums) {\\n        \\n        //copy each elemnt of vector(nums) to set(st)\\n        //which will automatically eliminate duplicates\\n       \\n    set<int>st(nums.begin(),nums.end());\\n        \\n        \\n        //if the size of set(st) less than 3 we will return the maximum element \\n        //else  return the 3rd max elemnt\\n    \\n        \\n        \\n        return st.size()<3?*max_element(st.begin(),st.end()):*next(st.begin(),st.size()-3);\\n        \\n        \\n        \\n        //explanation with a example\\n        //nums[]=1,2,3,5\\n        //here size is greater than 3 so 3rd max elmnt will be returned\\n        //*next(st.begin(),st.size()-3)==>  it will return the 3\\n        \\n        \\n        \\n        \\n    \\n    }\\n\\t\\n        ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1614126,
                "title": "easy-python-solution",
                "content": "```\\ndef thirdMax(self, nums: List[int]) -> int:\\n        l=[]\\n        for i in nums:\\n            if i not in l:\\n                l.append(i)\\n        l.sort()\\n        return l[-3] if len(l)>=3 else l[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef thirdMax(self, nums: List[int]) -> int:\\n        l=[]\\n        for i in nums:\\n            if i not in l:\\n                l.append(i)\\n        l.sort()\\n        return l[-3] if len(l)>=3 else l[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1461970,
                "title": "simple-python-o-n-three-pointer-solution",
                "content": "```Python\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        max1 = max2 = max3 = -float(\"inf\")\\n        # max1 < max2 < max3\\n        for n in nums:\\n            if n in [max1, max2, max3]:\\n                continue\\n            if n > max3:\\n                max1 = max2\\n                max2 = max3\\n                max3 = n\\n            elif n > max2:\\n                max1 = max2\\n                max2 = n\\n            elif n > max1:\\n                max1 = n\\n        return max1 if max1 != -float(\"inf\") else max3\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```Python\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        max1 = max2 = max3 = -float(\"inf\")\\n        # max1 < max2 < max3\\n        for n in nums:\\n            if n in [max1, max2, max3]:\\n                continue\\n            if n > max3:\\n                max1 = max2\\n                max2 = max3\\n                max3 = n\\n            elif n > max2:\\n                max1 = max2\\n                max2 = n\\n            elif n > max1:\\n                max1 = n\\n        return max1 if max1 != -float(\"inf\") else max3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 790342,
                "title": "c-easy-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        if (std::set<int>(nums.begin(), nums.end()).size() <= 2)\\n            return *max_element(nums.begin(), nums.end());\\n        vector<int> high = {INT_MIN, INT_MIN, INT_MIN};\\n        for (int i=0; i<nums.size();i++)\\n        {\\n            if (nums[i] > high[0])\\n            {\\n                high.pop_back();\\n                high.insert(high.begin(), nums[i]);\\n            }\\n            else if ((nums[i] < high[0]) && (nums[i] > high[1]))\\n            {\\n                high.pop_back();\\n                high.insert(high.begin()+1, nums[i]);\\n            }\\n            else if ((nums[i] < high[1]) && (nums[i] > high[2]))\\n            {\\n                high.pop_back();\\n                high.insert(high.begin()+2, nums[i]);\\n            }\\n        }\\n        return high[2];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        if (std::set<int>(nums.begin(), nums.end()).size() <= 2)\\n            return *max_element(nums.begin(), nums.end());\\n        vector<int> high = {INT_MIN, INT_MIN, INT_MIN};\\n        for (int i=0; i<nums.size();i++)\\n        {\\n            if (nums[i] > high[0])\\n            {\\n                high.pop_back();\\n                high.insert(high.begin(), nums[i]);\\n            }\\n            else if ((nums[i] < high[0]) && (nums[i] > high[1]))\\n            {\\n                high.pop_back();\\n                high.insert(high.begin()+1, nums[i]);\\n            }\\n            else if ((nums[i] < high[1]) && (nums[i] > high[2]))\\n            {\\n                high.pop_back();\\n                high.insert(high.begin()+2, nums[i]);\\n            }\\n        }\\n        return high[2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 734257,
                "title": "python-3-using-set-easy-to-understand",
                "content": "This problem can be solved using sets. Sets are used for eliminating duplicate elements.\\n\\nApproach:\\n1. ```max(nums)``` is returned if ```len(set(nums)) < 3```\\n2. If the length of the set is greater than 2, then sort the set, convert it into a list, and **return the 3rd element from the end of the list.**\\n\\n```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        if (len(set(nums)) < 3):\\n            return max(nums)\\n        else:\\n            return list(sorted(set(nums)))[len(set(nums)) - 3]\\n```\\n\\n\\n**ALTERNATE SOLUTION:**\\n\\nThis problem actually has a straight-forward approach. That is, **removing the max element from the set twice.**\\n```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        if len(set(nums)) < 3:\\n            return max(set(nums))\\n        nums.remove(max(set(nums)))\\n        nums.remove(max(set(nums)))\\n        return max(set(nums))\\n```\\n**Even though this code is pretty fast and can be used for this problem, I would suggest coding a solution that is guaranteed to work for** ```Nth Maximum Number```.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```max(nums)```\n```len(set(nums)) < 3```\n```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        if (len(set(nums)) < 3):\\n            return max(nums)\\n        else:\\n            return list(sorted(set(nums)))[len(set(nums)) - 3]\\n```\n```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        if len(set(nums)) < 3:\\n            return max(set(nums))\\n        nums.remove(max(set(nums)))\\n        nums.remove(max(set(nums)))\\n        return max(set(nums))\\n```\n```Nth Maximum Number```",
                "codeTag": "Java"
            },
            {
                "id": 666979,
                "title": "c-solution-with-set",
                "content": "```\\nint thirdMax(vector<int>& nums) {\\n\\tset<int, greater<int>> sNums(nums.begin(), nums.end());\\n\\tif (sNums.size() < 3)\\n\\t\\treturn *sNums.begin();\\n\\treturn *next(begin(sNums), 2);\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nint thirdMax(vector<int>& nums) {\\n\\tset<int, greater<int>> sNums(nums.begin(), nums.end());\\n\\tif (sNums.size() < 3)\\n\\t\\treturn *sNums.begin();\\n\\treturn *next(begin(sNums), 2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 364568,
                "title": "4-ms-faster-than-98-84-of-c-online-submissions",
                "content": "Runtime: 4 ms, faster than 98.84% of C++ online submissions for Third Maximum Number.\\nMemory Usage: 9.1 MB, less than 76.92% of C++ online submissions for Third Maximum Number.\\n\\n```\\nint thirdMax(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        long long maxNo = nums[0];\\n        long long secondMax = LONG_MIN;\\n        long long thirdMax = LONG_MIN;\\n        \\n        for(int i=1; i<n; i++)\\n        {\\n            if(nums[i] > maxNo)\\n            {\\n                thirdMax = secondMax;\\n                secondMax = maxNo;\\n                maxNo = nums[i];\\n            } else if(nums[i] < maxNo && nums[i] > secondMax)\\n            {\\n                thirdMax = secondMax;\\n                secondMax = nums[i];\\n            } else if(nums[i] < secondMax && nums[i] > thirdMax)\\n            {\\n                thirdMax = nums[i];\\n            }\\n        }\\n        \\n        return (thirdMax == LONG_MIN ? maxNo : thirdMax);\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "Runtime: 4 ms, faster than 98.84% of C++ online submissions for Third Maximum Number.\\nMemory Usage: 9.1 MB, less than 76.92% of C++ online submissions for Third Maximum Number.\\n\\n```\\nint thirdMax(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        long long maxNo = nums[0];\\n        long long secondMax = LONG_MIN;\\n        long long thirdMax = LONG_MIN;\\n        \\n        for(int i=1; i<n; i++)\\n        {\\n            if(nums[i] > maxNo)\\n            {\\n                thirdMax = secondMax;\\n                secondMax = maxNo;\\n                maxNo = nums[i];\\n            } else if(nums[i] < maxNo && nums[i] > secondMax)\\n            {\\n                thirdMax = secondMax;\\n                secondMax = nums[i];\\n            } else if(nums[i] < secondMax && nums[i] > thirdMax)\\n            {\\n                thirdMax = nums[i];\\n            }\\n        }\\n        \\n        return (thirdMax == LONG_MIN ? maxNo : thirdMax);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 355468,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        Arrays.sort(nums,0,nums.length);\\n        \\n        int count=0;\\n        int max=nums[nums.length-1];\\n        for(int i=nums.length-2;i>=0;i--)   {\\n            if(count==2)    break;\\n            if(nums[i]<max) {\\n                count++;\\n                max=nums[i];\\n            }\\n        }\\n        if(count==2)    return max;\\n        return nums[nums.length-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        Arrays.sort(nums,0,nums.length);\\n        \\n        int count=0;\\n        int max=nums[nums.length-1];\\n        for(int i=nums.length-2;i>=0;i--)   {\\n            if(count==2)    break;\\n            if(nums[i]<max) {\\n                count++;\\n                max=nums[i];\\n            }\\n        }\\n        if(count==2)    return max;\\n        return nums[nums.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 304780,
                "title": "java-solution-using-priority-queue-minheap-with-explanation",
                "content": "```\\nclass Solution {\\n    //We pushed n times and popped n-3 times(when n >=3). \\n    //Therefore, when we peeked the top element after all these operations, we get the 3rd maximum in the whole array.\\n    //Although add() and remove() takes O(log(n)), the size of our priority queue is always <=4, so adding n integers in a priority queue with size four only takes O(n*log(4)), which is O(n) in fact.\\n    public int thirdMax(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>();\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        for(int i = 0; i < nums.length; i++) {\\n            if(!set.contains(nums[i])) {\\n                set.add(nums[i]);\\n                pq.offer(nums[i]);\\n                if(pq.size() > 3) {\\n                    pq.poll();\\n                }\\n            }\\n        }\\n        if (pq.size() < 3) {\\n            int result = 0;\\n            while (!pq.isEmpty()) {\\n                result = pq.poll();\\n            }\\n            return result;\\n        }\\n        return pq.peek();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //We pushed n times and popped n-3 times(when n >=3). \\n    //Therefore, when we peeked the top element after all these operations, we get the 3rd maximum in the whole array.\\n    //Although add() and remove() takes O(log(n)), the size of our priority queue is always <=4, so adding n integers in a priority queue with size four only takes O(n*log(4)), which is O(n) in fact.\\n    public int thirdMax(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>();\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        for(int i = 0; i < nums.length; i++) {\\n            if(!set.contains(nums[i])) {\\n                set.add(nums[i]);\\n                pq.offer(nums[i]);\\n                if(pq.size() > 3) {\\n                    pq.poll();\\n                }\\n            }\\n        }\\n        if (pq.size() < 3) {\\n            int result = 0;\\n            while (!pq.isEmpty()) {\\n                result = pq.poll();\\n            }\\n            return result;\\n        }\\n        return pq.peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 244500,
                "title": "python-min-heap-o-n-space-and-almost-o-n-time",
                "content": "```\\nfrom heapq import heappush, heappushpop\\n\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        # Will have N*log(k) complexity, in this case log(k=3) = 1.09\\n        # Using O(N) space, giving us a unique representation of the input\\n        nums = set(nums)\\n        \\n        # Edgecase\\n        if len(nums) < 3:\\n          return max(nums)\\n\\n        heap = []\\n        \\n        # Put 3 elements in our min-heap\\n        for _ in range(3):\\n          heappush(heap, nums.pop())\\n          \\n        # Pushpop remaining elements, giving us\\n        # the 3 largest unique elements from nums\\n        while nums:\\n          heappushpop(heap, nums.pop())\\n          \\n        return heap[0]\\n          \\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heappush, heappushpop\\n\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        # Will have N*log(k) complexity, in this case log(k=3) = 1.09\\n        # Using O(N) space, giving us a unique representation of the input\\n        nums = set(nums)\\n        \\n        # Edgecase\\n        if len(nums) < 3:\\n          return max(nums)\\n\\n        heap = []\\n        \\n        # Put 3 elements in our min-heap\\n        for _ in range(3):\\n          heappush(heap, nums.pop())\\n          \\n        # Pushpop remaining elements, giving us\\n        # the 3 largest unique elements from nums\\n        while nums:\\n          heappushpop(heap, nums.pop())\\n          \\n        return heap[0]\\n          \\n```",
                "codeTag": "Java"
            },
            {
                "id": 90278,
                "title": "swift-using-set-int",
                "content": "Loop the array and put items in Set, every time removes the .min() one, \\nyet maybe this runs nlogn time for min() and max()?\\n ```\\nclass Solution {\\n    func thirdMax(_ nums: [Int]) -> Int {\\n        \\n/* solution A: use Set<int> to check and keep 3 items, remove the min;*/\\n        var top3 = Set<Int>()\\n        for num in nums {\\n            top3.insert(num)\\n            if top3.count > 3 {\\n                let min = top3.min() \\n                top3.remove(min!)\\n            }\\n        }\\n        return (top3.count == 3) ? top3.min()! : top3.max()!\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func thirdMax(_ nums: [Int]) -> Int {\\n        \\n/* solution A: use Set<int> to check and keep 3 items, remove the min;*/\\n        var top3 = Set<Int>()\\n        for num in nums {\\n            top3.insert(num)\\n            if top3.count > 3 {\\n                let min = top3.min() \\n                top3.remove(min!)\\n            }\\n        }\\n        return (top3.count == 3) ? top3.min()! : top3.max()!\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 90367,
                "title": "java-solution-with-minimum-value-time-complexity-o-n-space-complexity-o-1",
                "content": "public int thirdMax(int[] nums) {\\n        if(nums==null || nums.length==0){\\n            return 0;\\n        }\\n        long first = Long.MIN_VALUE;\\n        long second = Long.MIN_VALUE;\\n        long third = Long.MIN_VALUE;\\n\\n        for(int i=0;i<nums.length;i++){\\n            int val = nums[i];\\n            if(val > first){\\n                third = second;\\n                second = first;    \\n                first = val;\\n            }else if(val < first){\\n                if(val > second){\\n                    third = second;\\n                    second = val;\\n                }else if(val < second){\\n                    if(val > third){\\n                        third = val;\\n                    }\\n                }\\n            }\\n        }\\n        if(third==Long.MIN_VALUE){\\n            return ((int)first);\\n        }\\n        return ((int)third);\\n    }",
                "solutionTags": [],
                "code": "public int thirdMax(int[] nums) {\\n        if(nums==null || nums.length==0){\\n            return 0;\\n        }\\n        long first = Long.MIN_VALUE;\\n        long second = Long.MIN_VALUE;\\n        long third = Long.MIN_VALUE;\\n\\n        for(int i=0;i<nums.length;i++){\\n            int val = nums[i];\\n            if(val > first){\\n                third = second;\\n                second = first;    \\n                first = val;\\n            }else if(val < first){\\n                if(val > second){\\n                    third = second;\\n                    second = val;\\n                }else if(val < second){\\n                    if(val > third){\\n                        third = val;\\n                    }\\n                }\\n            }\\n        }\\n        if(third==Long.MIN_VALUE){\\n            return ((int)first);\\n        }\\n        return ((int)third);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 90427,
                "title": "concise-c-solution",
                "content": "```\\nint thirdMax(int* nums, int numsSize) {\\n    long max1, max2, max3;\\n    int i;\\n    for (max1 = max2 = max3 = LONG_MIN, i = 0; i < numsSize; i++) {\\n        if (max3 >= nums[i] || max1 == nums[i] || max2 == nums[i])\\n            continue;\\n        max3 = nums[i];\\n        if (max2 < max3)\\n            swap(&max2, &max3);\\n        if (max1 < max2)\\n            swap(&max1, &max2);\\n    }\\n    return max3 == LONG_MIN ? max1 : max3;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint thirdMax(int* nums, int numsSize) {\\n    long max1, max2, max3;\\n    int i;\\n    for (max1 = max2 = max3 = LONG_MIN, i = 0; i < numsSize; i++) {\\n        if (max3 >= nums[i] || max1 == nums[i] || max2 == nums[i])\\n            continue;\\n        max3 = nums[i];\\n        if (max2 < max3)\\n            swap(&max2, &max3);\\n        if (max1 < max2)\\n            swap(&max1, &max2);\\n    }\\n    return max3 == LONG_MIN ? max1 : max3;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4009099,
                "title": "c-beats-100-o-n-best-approach-so-far",
                "content": "\\n\\n# Approach\\ntaking 3 variable with min. values\\nif first, second, third is duplicate -> skip.\\nelse if value is greater than first ,store the value of a in first ,first\\'s value in second, second\\'s value in third.\\n\\nand similarly do if a is greater than second or third.\\nthen at lst check the value of third and return accordingly.   \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        long long first = LLONG_MIN;\\n        long long second = LLONG_MIN;\\n        long long third = LLONG_MIN;\\n\\n        for (int num : nums) {\\n            if (num == first || num == second || num == third) {\\n                continue; // Skip duplicates\\n            }\\n            if (num > first) {\\n                third = second;\\n                second = first;\\n                first = num;\\n            } else if (num > second) {\\n                third = second;\\n                second = num;\\n            } else if (num > third) {\\n                third = num;\\n            }\\n        }\\n\\n        return (third != LLONG_MIN) ? third : first;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        long long first = LLONG_MIN;\\n        long long second = LLONG_MIN;\\n        long long third = LLONG_MIN;\\n\\n        for (int num : nums) {\\n            if (num == first || num == second || num == third) {\\n                continue; // Skip duplicates\\n            }\\n            if (num > first) {\\n                third = second;\\n                second = first;\\n                first = num;\\n            } else if (num > second) {\\n                third = second;\\n                second = num;\\n            } else if (num > third) {\\n                third = num;\\n            }\\n        }\\n\\n        return (third != LLONG_MIN) ? third : first;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715312,
                "title": "c-accepted-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    public int ThirdMax(int[] nums) {\\n        var m1=long.MinValue;\\n        var m2=long.MinValue;\\n        var m3=long.MinValue;\\n        for(int i=0;i<nums.Length;i++){\\n            if(nums[i]==m1||nums[i]==m2||nums[i]==m3)\\n                continue;\\n            if(nums[i]>m1){\\n                m3=m2;\\n                m2=m1;\\n                m1=nums[i];    \\n            }\\n            else if(nums[i]>m2){\\n                m3=m2;\\n                m2=nums[i];\\n            }\\n            else if(nums[i]>m3){\\n                m3=nums[i];\\n            }\\n        }\\n        return m3==long.MinValue?(int)m1:(int)m3;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int ThirdMax(int[] nums) {\\n        var m1=long.MinValue;\\n        var m2=long.MinValue;\\n        var m3=long.MinValue;\\n        for(int i=0;i<nums.Length;i++){\\n            if(nums[i]==m1||nums[i]==m2||nums[i]==m3)\\n                continue;\\n            if(nums[i]>m1){\\n                m3=m2;\\n                m2=m1;\\n                m1=nums[i];    \\n            }\\n            else if(nums[i]>m2){\\n                m3=m2;\\n                m2=nums[i];\\n            }\\n            else if(nums[i]>m3){\\n                m3=nums[i];\\n            }\\n        }\\n        return m3==long.MinValue?(int)m1:(int)m3;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641471,
                "title": "c-soro",
                "content": "## Intuition\\nGive it a ```dry run```, you well get it.\\n\\n....\\nhey you, yes you.. please do vote this up and let leetcode know you are enjoying what you are watching.\\n# Complexity\\n- Time complexity: ```O(n)```  Single Iteration\\n\\n- Space complexity: ```O(1)``` Constant time\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        int maxi1 = INT_MIN;\\n        int maxi2 = INT_MIN;\\n        int maxi3 = INT_MIN;\\n        int flag = 0;\\n\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(nums[i] > maxi1) {\\n                maxi3 = maxi2;\\n                maxi2 = maxi1;\\n                maxi1 = nums[i];\\n            }\\n            else if(nums[i] < maxi1 && nums[i] > maxi2) {\\n                maxi3 = maxi2;\\n                maxi2 = nums[i];\\n            }\\n            else if(nums[i] < maxi2 && nums[i] > maxi3) maxi3 = nums[i];\\n\\n            if(nums[i] == INT_MIN) flag = 1;\\n        }\\n\\n        if(nums.size() < 3) return maxi1;\\n        if(nums.size() >= 3 && flag == 0 && maxi3 == INT_MIN) return maxi1;\\n        if(flag == 1 && maxi2 == INT_MIN) return maxi1;\\n        return maxi3;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```dry run```\n```O(n)```\n```O(1)```\n```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        int maxi1 = INT_MIN;\\n        int maxi2 = INT_MIN;\\n        int maxi3 = INT_MIN;\\n        int flag = 0;\\n\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(nums[i] > maxi1) {\\n                maxi3 = maxi2;\\n                maxi2 = maxi1;\\n                maxi1 = nums[i];\\n            }\\n            else if(nums[i] < maxi1 && nums[i] > maxi2) {\\n                maxi3 = maxi2;\\n                maxi2 = nums[i];\\n            }\\n            else if(nums[i] < maxi2 && nums[i] > maxi3) maxi3 = nums[i];\\n\\n            if(nums[i] == INT_MIN) flag = 1;\\n        }\\n\\n        if(nums.size() < 3) return maxi1;\\n        if(nums.size() >= 3 && flag == 0 && maxi3 == INT_MIN) return maxi1;\\n        if(flag == 1 && maxi2 == INT_MIN) return maxi1;\\n        return maxi3;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448444,
                "title": "javascript-performant-easy-to-understand-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince the problem states that we are only interested in distinct values (the distinct maximum), the first step is to create an array that only holds the distinct values from `nums`. We can do that using `Set`, which by default doesn\\'t allow duplicates, so we create an array from a new set of `nums`.\\n\\nThen we can sort the array to make it easier to find the maximum value. If the length of `arr` is at least three, that means that we can return the third value from the end, because that would be the third maximum number since the array is sorted. Otherwise, we return the maximum number, which is the last element in the array.\\n\\n# Complexity\\n- Time complexity: O(n log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar thirdMax = function(nums) {\\n    const arr = [...new Set(nums)];\\n\\n    arr.sort((a, b) => a - b);\\n\\n    if (arr.length >= 3) {\\n        return arr[arr.length - 3];\\n    } else {\\n        return arr[arr.length - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Sort"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar thirdMax = function(nums) {\\n    const arr = [...new Set(nums)];\\n\\n    arr.sort((a, b) => a - b);\\n\\n    if (arr.length >= 3) {\\n        return arr[arr.length - 3];\\n    } else {\\n        return arr[arr.length - 1];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3308917,
                "title": "simple-solution-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int ThirdMax(int[] nums) {\\n        HashSet<int> set = new HashSet<int>();\\n    foreach (int num in nums) {\\n        set.Add(num);\\n        if (set.Count > 3) set.Remove(set.Min());\\n    }\\n    if (set.Count < 3) return set.Max();\\n    return set.Min();    \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int ThirdMax(int[] nums) {\\n        HashSet<int> set = new HashSet<int>();\\n    foreach (int num in nums) {\\n        set.Add(num);\\n        if (set.Count > 3) set.Remove(set.Min());\\n    }\\n    if (set.Count < 3) return set.Max();\\n    return set.Min();    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262586,
                "title": "414-time-93-15-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Eliminate duplicates: First, eliminate duplicates from the input list nums using the set() method and convert it back to a list.\\n2. Handle edge cases: If the length of the modified nums list is less than 3, then return the maximum element from the list.\\n3. Sort in decreasing order: Sort the nums list in descending order using the sorted() method with the reverse=True argument.\\n4. Find the third maximum: Loop through the sorted nums list, and count the number of times a new distinct element is encountered by comparing it with the previous element. If the count is equal to 3, return the current element.\\n5. Return the maximum element: If the loop completes without finding the third maximum element, return the first element of the nums list, which is the maximum element.\\n\\n# Complexity\\n- Time complexity:\\nO(n log n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        nums = list(set(nums))  # Eliminate duplicates\\n        if len(nums) < 3:\\n            return max(nums)\\n        nums = sorted(nums, reverse=True)  # Sort in decreasing order\\n        count = 1\\n        for i in range(1, len(nums)):\\n            if nums[i] < nums[i-1]:\\n                count += 1\\n                if count == 3:\\n                    return nums[i]\\n        return nums[0]  # Return the maximum element\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        nums = list(set(nums))  # Eliminate duplicates\\n        if len(nums) < 3:\\n            return max(nums)\\n        nums = sorted(nums, reverse=True)  # Sort in decreasing order\\n        count = 1\\n        for i in range(1, len(nums)):\\n            if nums[i] < nums[i-1]:\\n                count += 1\\n                if count == 3:\\n                    return nums[i]\\n        return nums[0]  # Return the maximum element\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254817,
                "title": "easy-to-understand-code-of-third-maximum-number-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        Arrays.sort(nums);\\nint n = nums.length;\\nint count = 1;\\nint f= 0;\\nfor(int i=n-1;i>0;i--){\\nif(nums[i] == nums[i-1]){\\nf = f + 1; // for checking how many times max or second max value repeating\\n}\\nelse{\\ncount = count + 1; // for getting distinct max value count (until 3rd max value)\\n}\\nif(count == 3){\\nreturn nums[n-count-f]; // n=total value , count = 3, flag = how many times max or second max repeating\\n}\\n}\\nreturn nums[n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        Arrays.sort(nums);\\nint n = nums.length;\\nint count = 1;\\nint f= 0;\\nfor(int i=n-1;i>0;i--){\\nif(nums[i] == nums[i-1]){\\nf = f + 1; // for checking how many times max or second max value repeating\\n}\\nelse{\\ncount = count + 1; // for getting distinct max value count (until 3rd max value)\\n}\\nif(count == 3){\\nreturn nums[n-count-f]; // n=total value , count = 3, flag = how many times max or second max repeating\\n}\\n}\\nreturn nums[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222643,
                "title": "using-priorityqueue",
                "content": "**PLEASE UPVOTE IF YOU LIKE THE APPROACH**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) \\n    {\\n        priority_queue <int> pq;\\n\\n        unordered_set <int> us(nums.begin(), nums.end());\\n\\n        for(auto x: us)\\n            pq.push(x);\\n\\n        if(pq.size() < 3)\\n          return pq.top();\\n\\n        int count = 0;\\n        while(pq.size() && count != 2)\\n        {\\n            count++;\\n            pq.pop();\\n        }\\n\\n        return pq.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) \\n    {\\n        priority_queue <int> pq;\\n\\n        unordered_set <int> us(nums.begin(), nums.end());\\n\\n        for(auto x: us)\\n            pq.push(x);\\n\\n        if(pq.size() < 3)\\n          return pq.top();\\n\\n        int count = 0;\\n        while(pq.size() && count != 2)\\n        {\\n            count++;\\n            pq.pop();\\n        }\\n\\n        return pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140114,
                "title": "2-simple-easy-to-understand-approaches",
                "content": "# Using Set & Priory Queue\\n\\n```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n         PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n           Set<Integer> set = new HashSet<>();\\n         for(Integer i:nums){\\n              if (set.add(i)) {\\n                pq.add(i);\\n            }\\n         }\\n          if (pq.size() < 3) {\\n            return pq.peek();\\n        }\\n         pq.remove();\\n         pq.remove();\\n         return pq.remove();\\n    }\\n}\\n```\\n\\n# Using TreeSet \\n\\n```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        TreeSet<Integer> set = new TreeSet<>(Comparator.reverseOrder());\\n        for (int n : nums) {\\n            set.add(n);\\n        }\\n        if (set.size() < 3) {\\n            return set.first();\\n        }\\n        set.remove(set.first());\\n        set.remove(set.first());\\n        return set.first();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n         PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n           Set<Integer> set = new HashSet<>();\\n         for(Integer i:nums){\\n              if (set.add(i)) {\\n                pq.add(i);\\n            }\\n         }\\n          if (pq.size() < 3) {\\n            return pq.peek();\\n        }\\n         pq.remove();\\n         pq.remove();\\n         return pq.remove();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        TreeSet<Integer> set = new TreeSet<>(Comparator.reverseOrder());\\n        for (int n : nums) {\\n            set.add(n);\\n        }\\n        if (set.size() < 3) {\\n            return set.first();\\n        }\\n        set.remove(set.first());\\n        set.remove(set.first());\\n        return set.first();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3127021,
                "title": "c-clean-priority-queue-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing SET we could solve the first problem right away, whihc is the disctinction between numbers.\\n\\nAs a second step we could keep track on a priority_queue, so we always have the maximum number on top. That being said we can pop() 2 numbers if necessary, then always return the top(), or the Maximum number.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        set<int> distinct(nums.begin(), nums.end());\\n\\n        priority_queue<int> maxNum;\\n\\n        for(auto x : distinct) {\\n            maxNum.push(x);\\n        }\\n\\n        if(maxNum.size() > 2){\\n            maxNum.pop();\\n            maxNum.pop();\\n        } \\n\\n        return maxNum.top();\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        set<int> distinct(nums.begin(), nums.end());\\n\\n        priority_queue<int> maxNum;\\n\\n        for(auto x : distinct) {\\n            maxNum.push(x);\\n        }\\n\\n        if(maxNum.size() > 2){\\n            maxNum.pop();\\n            maxNum.pop();\\n        } \\n\\n        return maxNum.top();\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057413,
                "title": "simple-cpp-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        set<int>ss(nums.begin(),nums.end());\\n        if(ss.size()<3)return *max_element(nums.begin(),nums.end());\\n       int t=ss.size()-3;\\n       auto it=ss.begin();\\n       while(t--)\\n       {\\n           it++;\\n       }\\n       return *it;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        set<int>ss(nums.begin(),nums.end());\\n        if(ss.size()<3)return *max_element(nums.begin(),nums.end());\\n       int t=ss.size()-3;\\n       auto it=ss.begin();\\n       while(t--)\\n       {\\n           it++;\\n       }\\n       return *it;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975702,
                "title": "95-faster-and-94-on-memory",
                "content": "![Screenshot 2022-12-31 at 19.30.00.png](https://assets.leetcode.com/users/images/75d7d931-eb46-42c9-bc17-0e47e0faf8b6_1672497021.1643512.png)\\n\\n```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        a, b, c = -2**31-1, -2**31-1, -2**31-1\\n        for i in nums:\\n            if a<i: \\n                a, b, c = i, a, b\\n            elif b<i:\\n                if a!=i:\\n                    b, c = i, b\\n            elif c<i:\\n                if b!=i: c = i\\n        if c==-2**31-1: return a\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        a, b, c = -2**31-1, -2**31-1, -2**31-1\\n        for i in nums:\\n            if a<i: \\n                a, b, c = i, a, b\\n            elif b<i:\\n                if a!=i:\\n                    b, c = i, b\\n            elif c<i:\\n                if b!=i: c = i\\n        if c==-2**31-1: return a\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891870,
                "title": "not-so-fast-but-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we need the third highest, I decided to sort somehow to make it easier to locate.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe don\\'t have any restrictions of keeping count or length of array so the best way I thought of was to use set to get unique value and then sort them in descending order and store it in a list. Now we can just return 3 element from the start and if it fails we can return first element from the list.\\n\\n# Code\\n```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        lst = list(sorted(set(nums),reverse=True))\\n        try:\\n            return lst[2]\\n        except:\\n            return lst[0]\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        lst = list(sorted(set(nums),reverse=True))\\n        try:\\n            return lst[2]\\n        except:\\n            return lst[0]\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629512,
                "title": "easy-c-solution",
                "content": "```\\n\\n        set<int> a;\\n        vector<int> ans;\\n        \\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            a.insert(nums[i]);\\n        }\\n        \\n        \\n        for(auto x : a)\\n        {\\n            ans.push_back(x);\\n        }\\n        \\n        \\n        if(ans.size()==1)\\n        {\\n            return ans[0];\\n        }\\n        if(ans.size()==2)\\n        {\\n            sort(ans.begin(),ans.end());\\n            return ans[1];\\n        }\\n        \\n        if(ans.size()>=3)\\n            return ans[ans.size()-3];\\n        \\n        return ans[ans.size()];\\n```",
                "solutionTags": [],
                "code": "```\\n\\n        set<int> a;\\n        vector<int> ans;\\n        \\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            a.insert(nums[i]);\\n        }\\n        \\n        \\n        for(auto x : a)\\n        {\\n            ans.push_back(x);\\n        }\\n        \\n        \\n        if(ans.size()==1)\\n        {\\n            return ans[0];\\n        }\\n        if(ans.size()==2)\\n        {\\n            sort(ans.begin(),ans.end());\\n            return ans[1];\\n        }\\n        \\n        if(ans.size()>=3)\\n            return ans[ans.size()-3];\\n        \\n        return ans[ans.size()];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2515288,
                "title": "javascript-easy-o-n-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar thirdMax = function(nums) {\\n    let N = nums.length;\\n    let m1=-Infinity,m2=-Infinity,m3=-Infinity;\\n    for(let i=0;i<N;i++){\\n        if (nums[i] === m1 || nums[i] === m2 || nums[i] === m3) continue;\\n        if(nums[i]>m1){\\n            m3=m2;\\n            m2=m1;\\n            m1= nums[i];\\n        }else if(nums[i]>m2){\\n            m3=m2;\\n            m2= nums[i];\\n        }else if(nums[i]>m3){\\n            m3= nums[i];\\n        }\\n    };\\n    return m3 == -Infinity ? m1 :m3;\\n};\\n```\\n\\n**Upvote** if you like it \\uD83D\\uDE01",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar thirdMax = function(nums) {\\n    let N = nums.length;\\n    let m1=-Infinity,m2=-Infinity,m3=-Infinity;\\n    for(let i=0;i<N;i++){\\n        if (nums[i] === m1 || nums[i] === m2 || nums[i] === m3) continue;\\n        if(nums[i]>m1){\\n            m3=m2;\\n            m2=m1;\\n            m1= nums[i];\\n        }else if(nums[i]>m2){\\n            m3=m2;\\n            m2= nums[i];\\n        }else if(nums[i]>m3){\\n            m3= nums[i];\\n        }\\n    };\\n    return m3 == -Infinity ? m1 :m3;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2511748,
                "title": "think-it-through",
                "content": "#### Edge Cases:\\n1. nums array is empty; check if it is a constraint, possible or not\\n2. len(nums) == 1; return the only element in nums array as it is maximum\\n3. len(nums) == 2; returm the maximum element, according to question we have to return max element if third_max is not found\\n4. len(set(nums)) >= 3; we have our third_max; find the third maximum and return it as answer\\n\\n#### Test Cases:\\n[]\\n[1]\\n[2, 1]\\n[1, 2]\\n[3, 2, 1]\\n[3, 1, 2, 1, 3, 4, 5]\\n[4, 2, 1, 5, 1, 3]\\n[3, 1, 3, 1, 3, 3, 1]\\n\\n#### Approaches:\\n1. **Brute Force, Messy**\\nIntuition:\\nFind first maximum, similarly second maximum and third maximum in different iterations of for loop. While finding second_max we ensure that the num is lesser than first_max and not equal to first_max. Similarly for third max we ensure that num is lesser than second_max and not equal to second_max.\\n*Time: O(n) we are iterating over nums array 3 times thus, O(3 x n) ==> O(n)\\nSpace: O(1), we keep three variables namely, first_max, second_max and third_max*\\n\\n2. **Better Brute Force, Messy (lot of hard coding comparison is required)**\\nIntuition:\\nKeep three variables first_max, second_max and third_max, use them to find all three in single iteration of nums array.\\n*Time: O(n), we are iterating over nums array just once\\nSpace: O(1), same as above*\\n\\n```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        first_max = second_max = third_max = float(\\'-inf\\')\\n        \\n        for num in nums:\\n            if num > first_max:\\n                third_max = second_max\\n                second_max = first_max\\n                first_max = num\\n            elif second_max < num < first_max:\\n                third_max = second_max\\n                second_max = num\\n            elif third_max < num < second_max:\\n                third_max = num\\n                \\n        if third_max > float(\\'-inf\\'):\\n            return third_max\\n        \\n        return first_max\\n```\\n3. **Programmatically better solution, use set**\\nIntuition:\\nUse a set to remove duplicates from nums array. Find first_max and remove this element from set in O(1) time, similarly find next max whichi would now be second_max and remove it from the set. Now, return the maximum element from the set. We should check the size of the set as an edge case for len(set(nums)) <= 2 to return the maximum element.\\n*Time: O(n), removal of an element from set takes O(1) and finding max element takes O(3 x n) ==> O(n) time\\nSpace: O(n), set(nums) is the additional space*\\n\\n```\\nclass Solution:\\n    def thirdMax(self, nums: \"List[int]\") -> int:\\n        # removed duplicates from nums array by changing it to sets\\n        nums = set(nums)\\n\\n        # consider the edge case if len(nums) <= 2\\n        if len(nums) <= 2:\\n            return max(nums)\\n\\n        # find first_max and remove it from the set\\n        first_max = max(nums)\\n        nums.remove(first_max)\\n\\n        # find second_max and remove it from the set\\n        second_max = max(nums)\\n        nums.remove(second_max)\\n        \\n        # find third_max and return it as an answer\\n        return max(nums)\\n        \\n```\\n\\n4. **Optimised solution, use set**\\nCredit - Leetcode solution\\nIntuition:\\nStore only the three max elements from nums array by iterating over nums array 3 times like above.\\nFurther Optimisation: Store nums\\' elements in a resultant set thus, it would contain at most 3 elements at any point of time. We keep removing the min element if length of this set becomes 4, maintaining it to be 3.\\n*Time: O(n), iterate through all the elements of nums array at most once.\\nSpace: O(1), the additional space, set in question will not contain more than 3 elements O(3) ==> O(1)*\\n\\n```\\nclass Solution:\\n    def thirdMax(self, nums: \"List[int]\") -> int:\\n        result = set()\\n\\n        for num in nums:\\n            result.add(num)\\n\\n            if len(result) > 3:\\n                result.remove(min(result))  # min(result) will execute in O(3) time\\n\\n        return min(result) if len(result) == 3 else max(result)\\n```\\n\\n5. **kth largest element, use heap**\\nThis generalises the concept of finding any max or min numbers in given array. Can be used if array doesn\\'t have duplicates else we need to remove duplicates or do not perform heappush if element is already present in the heap.\\nIntuition:\\nUse a Min Heap of size 3. Iterate over nums array and whenever a num is greater than the min heap[0], minimum element in min heap, we extract it and insert current num.\\n*Time: O(n), we iterate over each element only once and removal from & insertion into heap will be O(logk) => O(log3) => O(1) constant. Thus, O(n) time complexity.\\nSpace: O(1), min heap size =  3 which is constant*\\n```\\nimport heapq\\n\\nclass Solution:\\n    def thirdMax(self, nums: \"List[int]\") -> int:\\n        heap = []\\n\\t\\t# either we do below line:\\n\\t\\tnums = set(nums)\\n        for num in nums:\\n\\t\\t\\t# or check if num is already present in heap, do not heappush:\\n\\t\\t\\t# if num in nums:\\n            heapq.heappush(heap, num)\\n            if len(heap) > 3:\\n                heapq.heappop(heap)\\n\\n        return heap[0] if len(heap) == 3 else max(heap)\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        first_max = second_max = third_max = float(\\'-inf\\')\\n        \\n        for num in nums:\\n            if num > first_max:\\n                third_max = second_max\\n                second_max = first_max\\n                first_max = num\\n            elif second_max < num < first_max:\\n                third_max = second_max\\n                second_max = num\\n            elif third_max < num < second_max:\\n                third_max = num\\n                \\n        if third_max > float(\\'-inf\\'):\\n            return third_max\\n        \\n        return first_max\\n```\n```\\nclass Solution:\\n    def thirdMax(self, nums: \"List[int]\") -> int:\\n        # removed duplicates from nums array by changing it to sets\\n        nums = set(nums)\\n\\n        # consider the edge case if len(nums) <= 2\\n        if len(nums) <= 2:\\n            return max(nums)\\n\\n        # find first_max and remove it from the set\\n        first_max = max(nums)\\n        nums.remove(first_max)\\n\\n        # find second_max and remove it from the set\\n        second_max = max(nums)\\n        nums.remove(second_max)\\n        \\n        # find third_max and return it as an answer\\n        return max(nums)\\n        \\n```\n```\\nclass Solution:\\n    def thirdMax(self, nums: \"List[int]\") -> int:\\n        result = set()\\n\\n        for num in nums:\\n            result.add(num)\\n\\n            if len(result) > 3:\\n                result.remove(min(result))  # min(result) will execute in O(3) time\\n\\n        return min(result) if len(result) == 3 else max(result)\\n```\n```\\nimport heapq\\n\\nclass Solution:\\n    def thirdMax(self, nums: \"List[int]\") -> int:\\n        heap = []\\n\\t\\t# either we do below line:\\n\\t\\tnums = set(nums)\\n        for num in nums:\\n\\t\\t\\t# or check if num is already present in heap, do not heappush:\\n\\t\\t\\t# if num in nums:\\n            heapq.heappush(heap, num)\\n            if len(heap) > 3:\\n                heapq.heappop(heap)\\n\\n        return heap[0] if len(heap) == 3 else max(heap)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451731,
                "title": "javascript-simple-solution-with-sorting",
                "content": "```\\nvar thirdMax = function(nums) {\\n    nums = nums.sort((a,b) => a-b);\\n    let current;\\n    let count = 0;\\n   \\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        if (nums[i] !== current) {\\n            current = nums[i];\\n            count++;\\n        }\\n\\n        if (count === 3) return current;\\n    }\\n    \\n    return nums[nums.length - 1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar thirdMax = function(nums) {\\n    nums = nums.sort((a,b) => a-b);\\n    let current;\\n    let count = 0;\\n   \\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        if (nums[i] !== current) {\\n            current = nums[i];\\n            count++;\\n        }\\n\\n        if (count === 3) return current;\\n    }\\n    \\n    return nums[nums.length - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2139743,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        Set<Integer> ls= new HashSet<Integer>();\\n        for(Integer in: nums)\\n            ls.add(in);\\n          \\n        if(ls.size()==1) return nums[0];\\n        if(ls.size()==2) return Collections.max(ls);\\n        ls.remove(Collections.max(ls));\\n        ls.remove(Collections.max(ls));\\n        return Collections.max(ls);\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int thirdMax(int[] nums) {\\n        Set<Integer> ls= new HashSet<Integer>();\\n        for(Integer in: nums)\\n            ls.add(in);\\n          \\n        if(ls.size()==1) return nums[0];\\n        if(ls.size()==2) return Collections.max(ls);\\n        ls.remove(Collections.max(ls));\\n        ls.remove(Collections.max(ls));\\n        return Collections.max(ls);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2114731,
                "title": "neat-c-code-third-maximum-number",
                "content": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int temp = nums[nums.size()-1];\\n        int count = 1;\\n        for(int i=nums.size()-2;i>=0;i--){\\n            if(temp>nums[i]){\\n                count++;\\n                temp = nums[i];\\n            }\\n            if(count==3)\\n                return temp;\\n        }\\n        return nums[nums.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int temp = nums[nums.size()-1];\\n        int count = 1;\\n        for(int i=nums.size()-2;i>=0;i--){\\n            if(temp>nums[i]){\\n                count++;\\n                temp = nums[i];\\n            }\\n            if(count==3)\\n                return temp;\\n        }\\n        return nums[nums.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013751,
                "title": "python-oneliner",
                "content": "```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        return max(nums) if len(set(nums)) < 3 else sorted(list(set(nums)))[-3]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        return max(nums) if len(set(nums)) < 3 else sorted(list(set(nums)))[-3]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824601,
                "title": "fast-and-easy-c-solution",
                "content": "The idea is to first sort the array and count drop from the end of the list i.e if value gets dropped increase the drop count by 1. If drop count==2 then we got our 3rd largest element at index i-1 .\\nAnd if no 3rd max is present return the last element of the sorted list which is the largest value.\\n```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n       int drop=0;\\n      if(nums.size()==1)\\n        return nums[0];\\n      \\n      for(int i=nums.size()-1;i>0;i--)\\n      {\\n        if(nums[i]>nums[i-1])\\n          drop++;\\n        if(drop==2)\\n          return nums[i-1];\\n      }\\n      \\n      return nums[nums.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n       int drop=0;\\n      if(nums.size()==1)\\n        return nums[0];\\n      \\n      for(int i=nums.size()-1;i>0;i--)\\n      {\\n        if(nums[i]>nums[i-1])\\n          drop++;\\n        if(drop==2)\\n          return nums[i-1];\\n      }\\n      \\n      return nums[nums.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611363,
                "title": "java-treeset-o-n",
                "content": "Top K elements approach... Replacing PriorityQueue with TreeSet because of distinct constriants...\\n\\nTime Complexity: O(n * log3) ~ O(n)\\nSpace Complexity: O(3) ~ O(1)\\n\\nPls upvote if it\\'s useful to you... thanks for dropping-by...  :-)\\n\\n```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        TreeSet<Integer> set = new TreeSet<>(); //min set for 3rd distinct maximum element\\n        \\n        for(int num:nums) {\\n            if(set.size() < 3)                                    //add new candidate as size is < 3 \\n                set.add(num);                                     //O(log3) ~ O(1)\\n            else if(set.first() < num && !set.contains(num)) {   //add new candidate if it\\'s valid & distinct  //O(1)\\n                set.pollFirst();\\n                set.add(num);                                    //O(log3) ~ O(1)\\n            }\\n        }\\n        \\n        return set.size() == 3 ? set.first() : set.last();     //check set size & accordingly return the result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        TreeSet<Integer> set = new TreeSet<>(); //min set for 3rd distinct maximum element\\n        \\n        for(int num:nums) {\\n            if(set.size() < 3)                                    //add new candidate as size is < 3 \\n                set.add(num);                                     //O(log3) ~ O(1)\\n            else if(set.first() < num && !set.contains(num)) {   //add new candidate if it\\'s valid & distinct  //O(1)\\n                set.pollFirst();\\n                set.add(num);                                    //O(log3) ~ O(1)\\n            }\\n        }\\n        \\n        return set.size() == 3 ? set.first() : set.last();     //check set size & accordingly return the result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592901,
                "title": "o-n-time-and-o-1-space-solution-in-c",
                "content": "```  \\nint thirdMax(vector<int>& nums) {\\n        int maxN = nums[0];\\n        long secondMax = LONG_MIN, thirdMax = LONG_MIN;\\n        int n = nums.size();\\n        for(int i = 0; i<n ;i++){\\n            if(nums[i]>maxN){\\n                thirdMax = secondMax;\\n                secondMax = maxN;\\n                maxN = nums[i];\\n            }\\n            else if(nums[i] != maxN){\\n                if(secondMax==LONG_MIN || nums[i]>secondMax){\\n                    thirdMax = secondMax;\\n                    secondMax = nums[i];\\n                }\\n                else if(nums[i]<secondMax && nums[i]>thirdMax)\\n                    thirdMax = nums[i];\\n            }\\n        }\\n        if(thirdMax == LONG_MIN || secondMax == LONG_MIN)\\n            return maxN;\\n        else\\n            return thirdMax;\\n        }\\n```",
                "solutionTags": [],
                "code": "```  \\nint thirdMax(vector<int>& nums) {\\n        int maxN = nums[0];\\n        long secondMax = LONG_MIN, thirdMax = LONG_MIN;\\n        int n = nums.size();\\n        for(int i = 0; i<n ;i++){\\n            if(nums[i]>maxN){\\n                thirdMax = secondMax;\\n                secondMax = maxN;\\n                maxN = nums[i];\\n            }\\n            else if(nums[i] != maxN){\\n                if(secondMax==LONG_MIN || nums[i]>secondMax){\\n                    thirdMax = secondMax;\\n                    secondMax = nums[i];\\n                }\\n                else if(nums[i]<secondMax && nums[i]>thirdMax)\\n                    thirdMax = nums[i];\\n            }\\n        }\\n        if(thirdMax == LONG_MIN || secondMax == LONG_MIN)\\n            return maxN;\\n        else\\n            return thirdMax;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1570006,
                "title": "easy-java-solution-using-sorting-array-list",
                "content": "```\\nclass Solution {\\n    public int thirdMax(int[] arr) {\\n        int count=3;\\n        Arrays.sort(arr);\\n        List<Integer>ans=new ArrayList<>();\\n        for(int i=arr.length-1;i>=0;i--){\\n          if(ans.contains(arr[i])){\\n              continue;\\n          }\\n          count--;\\n          \\n          if(count==0){\\n              return arr[i];\\n          }\\n          ans.add(arr[i]);        \\n        } \\n        return arr[arr.length-1];    \\n        }\\n    }\\n\\t",
                "solutionTags": [],
                "code": "class Solution {\\n    public int thirdMax(int[] arr) {\\n        int count=3;\\n        Arrays.sort(arr);\\n        List<Integer>ans=new ArrayList<>();\\n        for(int i=arr.length-1;i>=0;i--){\\n          if(ans.contains(arr[i])){\\n              continue;\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 1564461,
                "title": "0-ms-faster-than-100-00-solution-tc-o-n-and-sc-o-1",
                "content": "```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        \\n        // use long data tyoe because, the constraint includes Integer.MIN_VALUE and Integer.MAX_VALUE;\\n        long max1 = Long.MIN_VALUE;\\n        long max2 = Long.MIN_VALUE;\\n        long max3 = Long.MIN_VALUE;\\n        \\n        // if nums has only one element\\n        if(nums.length ==1){\\n            return nums[0];\\n        }\\n         // if nums has only two elements\\n        if(nums.length == 2){\\n            return Math.max(nums[0], nums[1]);\\n        }\\n        \\n        // use 3 variables to keep track of first maximum, second maximum and third maximum\\n        for(int num : nums){\\n            if(num > max1){\\n                max3 = max2;\\n                max2 = max1;\\n                max1 = num;\\n            }else if(num > max2 && num != max1){\\n                max3 = max2;\\n                max2 = num;\\n            }else if(num > max3 && num != max1 && num != max2){\\n                max3 = num;\\n            }\\n            \\n        }\\n        \\n        // at the end if thr third max is still Long.MIN_VALUE, it means there are no 3 distinct element in\\n\\t\\t// nums. So we return the maximum as specified on the question\\n        if(max3 == Long.MIN_VALUE){\\n            return (int)max1;\\n        }\\n        return (int)max3;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        \\n        // use long data tyoe because, the constraint includes Integer.MIN_VALUE and Integer.MAX_VALUE;\\n        long max1 = Long.MIN_VALUE;\\n        long max2 = Long.MIN_VALUE;\\n        long max3 = Long.MIN_VALUE;\\n        \\n        // if nums has only one element\\n        if(nums.length ==1){\\n            return nums[0];\\n        }\\n         // if nums has only two elements\\n        if(nums.length == 2){\\n            return Math.max(nums[0], nums[1]);\\n        }\\n        \\n        // use 3 variables to keep track of first maximum, second maximum and third maximum\\n        for(int num : nums){\\n            if(num > max1){\\n                max3 = max2;\\n                max2 = max1;\\n                max1 = num;\\n            }else if(num > max2 && num != max1){\\n                max3 = max2;\\n                max2 = num;\\n            }else if(num > max3 && num != max1 && num != max2){\\n                max3 = num;\\n            }\\n            \\n        }\\n        \\n        // at the end if thr third max is still Long.MIN_VALUE, it means there are no 3 distinct element in\\n\\t\\t// nums. So we return the maximum as specified on the question\\n        if(max3 == Long.MIN_VALUE){\\n            return (int)max1;\\n        }\\n        return (int)max3;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471725,
                "title": "c-solution-o-n-in-time-o-1-in-space-using-long",
                "content": "```\\nint thirdMax(int* nums, int numsSize){\\n    long first = ((long)INT_MIN)-1, second = ((long)INT_MIN)-1, third = ((long)INT_MIN)-1;\\n    int i = 0;\\n    \\n    while(i < numsSize){\\n        if(nums[i] > first){\\n            third = second;\\n            second = first;\\n            first = nums[i];\\n        }\\n        else if(nums[i] > second && nums[i] != first){\\n            third = second;\\n            second = nums[i];\\n        }\\n        else if(nums[i] > third && nums[i] != first && nums[i] != second){\\n            third = nums[i];\\n        }\\n        i++;\\n    }\\n    \\n    if(third == ((long)INT_MIN)-1) return (int)first;\\n    return (int)third;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint thirdMax(int* nums, int numsSize){\\n    long first = ((long)INT_MIN)-1, second = ((long)INT_MIN)-1, third = ((long)INT_MIN)-1;\\n    int i = 0;\\n    \\n    while(i < numsSize){\\n        if(nums[i] > first){\\n            third = second;\\n            second = first;\\n            first = nums[i];\\n        }\\n        else if(nums[i] > second && nums[i] != first){\\n            third = second;\\n            second = nums[i];\\n        }\\n        else if(nums[i] > third && nums[i] != first && nums[i] != second){\\n            third = nums[i];\\n        }\\n        i++;\\n    }\\n    \\n    if(third == ((long)INT_MIN)-1) return (int)first;\\n    return (int)third;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1414019,
                "title": "java-3-solutions-heap-o-n-sort-o-nlogn-iterate-o-1-space",
                "content": "**Heap :\\nRuntime: 3 ms, faster than 48.64% of Java online submissions for Third Maximum Number.\\nMemory Usage: 38.7 MB, less than 77.83% of Java online submissions for Third Maximum Number.**\\n```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        Set<Integer> set = new HashSet<>();\\n        \\n        int i = 0,max = Integer.MIN_VALUE;\\n        \\n        while(pq.size() < 3 && i < nums.length){\\n            if(!set.contains(nums[i]))pq.offer(nums[i]);\\n            set.add(nums[i]);\\n            max = Math.max(nums[i++],max);\\n        }\\n        \\n        while( i < nums.length){\\n            if(nums[i] > pq.peek() && !set.contains(nums[i])){\\n                pq.poll();\\n                pq.offer(nums[i]);\\n            }\\n            set.add(nums[i]);\\n            max = Math.max(nums[i],max);\\n            i++;\\n        }\\n        \\n        return pq.size() == 3 ? pq.poll() : max;\\n    }\\n}\\n```\\n**Sort :\\nRuntime: 1 ms, faster than 89.49% of Java online submissions for Third Maximum Number.\\nMemory Usage: 38.7 MB, less than 77.83% of Java online submissions for Third Maximum Number.**\\n```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length,count = 1;\\n        if(n < 3)return nums[n-1];\\n        for(int i = n-2 ;i>= 0;i--){\\n            if(nums[i + 1] != nums[i])count++;\\n            if(count == 3)return nums[i];\\n        }\\n        return nums[n-1];\\n    }\\n}\\n```\\n**Iterate : O(1) space & O(n) time\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Third Maximum Number.\\nMemory Usage: 39.1 MB, less than 28.55% of Java online submissions for Third Maximum Number.**\\n```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        \\n        long one = Long.MIN_VALUE,two = Long.MIN_VALUE,three = Long.MIN_VALUE;\\n        for(int i : nums){\\n            if((int)i > one){\\n                three = two;\\n                two = one;\\n                one  = i;\\n            }else if((int)i == one){\\n                continue;\\n            }else if((int)i > two){\\n                three = two;\\n                two = i;\\n            }else if((int)i == two){\\n                continue;\\n            }else if((int)i > three){\\n                three = i;\\n            }\\n        }\\n        return three == Long.MIN_VALUE ? (int)one : (int)three;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        Set<Integer> set = new HashSet<>();\\n        \\n        int i = 0,max = Integer.MIN_VALUE;\\n        \\n        while(pq.size() < 3 && i < nums.length){\\n            if(!set.contains(nums[i]))pq.offer(nums[i]);\\n            set.add(nums[i]);\\n            max = Math.max(nums[i++],max);\\n        }\\n        \\n        while( i < nums.length){\\n            if(nums[i] > pq.peek() && !set.contains(nums[i])){\\n                pq.poll();\\n                pq.offer(nums[i]);\\n            }\\n            set.add(nums[i]);\\n            max = Math.max(nums[i],max);\\n            i++;\\n        }\\n        \\n        return pq.size() == 3 ? pq.poll() : max;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length,count = 1;\\n        if(n < 3)return nums[n-1];\\n        for(int i = n-2 ;i>= 0;i--){\\n            if(nums[i + 1] != nums[i])count++;\\n            if(count == 3)return nums[i];\\n        }\\n        return nums[n-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        \\n        long one = Long.MIN_VALUE,two = Long.MIN_VALUE,three = Long.MIN_VALUE;\\n        for(int i : nums){\\n            if((int)i > one){\\n                three = two;\\n                two = one;\\n                one  = i;\\n            }else if((int)i == one){\\n                continue;\\n            }else if((int)i > two){\\n                three = two;\\n                two = i;\\n            }else if((int)i == two){\\n                continue;\\n            }else if((int)i > three){\\n                three = i;\\n            }\\n        }\\n        return three == Long.MIN_VALUE ? (int)one : (int)three;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376448,
                "title": "java-solution-easy-to-understand-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    public int thirdMax(int[] arr) {\\n        int index1 = 0;\\n        int index2 = -1;\\n        int index3 = -1;\\n        \\n        for(int i = 1; i < arr.length; i++){\\n            if(arr[i] > arr[index1]){\\n                index3 = index2;\\n                index2 = index1;\\n                index1 = i;\\n            }else if(arr[i] < arr[index1]){\\n                if(index2 == -1 || arr[i] > arr[index2]){\\n                    index3 = index2;\\n                    index2 = i;\\n                }else if((index3 == -1 || arr[i] > arr[index3]) && arr[i] != arr[index2]){\\n                    index3 = i;\\n                }\\n            }\\n        }\\n        \\n        if(index3 != -1){\\n            return arr[index3];\\n        }else{\\n            return arr[index1];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int thirdMax(int[] arr) {\\n        int index1 = 0;\\n        int index2 = -1;\\n        int index3 = -1;\\n        \\n        for(int i = 1; i < arr.length; i++){\\n            if(arr[i] > arr[index1]){\\n                index3 = index2;\\n                index2 = index1;\\n                index1 = i;\\n            }else if(arr[i] < arr[index1]){\\n                if(index2 == -1 || arr[i] > arr[index2]){\\n                    index3 = index2;\\n                    index2 = i;\\n                }else if((index3 == -1 || arr[i] > arr[index3]) && arr[i] != arr[index2]){\\n                    index3 = i;\\n                }\\n            }\\n        }\\n        \\n        if(index3 != -1){\\n            return arr[index3];\\n        }else{\\n            return arr[index1];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1293975,
                "title": "c-0ms-100-faster-o-n-o-1-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        long first = LONG_MIN, second = LONG_MIN, third = LONG_MIN;\\n        \\n        for(auto const& x: nums){\\n            if(x != first && x!= second && x!= third){\\n                if(x > second){\\n                    if(x > first)\\n                        third = second, second = first, first = x;\\n                    else\\n                        third = second, second = x;\\n                }\\n                else{\\n                    if(x > third)\\n                        third = x;\\n                }\\n            }\\n        }\\n        \\n        if(third != LONG_MIN) return third;\\n        else return max(first, second);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        long first = LONG_MIN, second = LONG_MIN, third = LONG_MIN;\\n        \\n        for(auto const& x: nums){\\n            if(x != first && x!= second && x!= third){\\n                if(x > second){\\n                    if(x > first)\\n                        third = second, second = first, first = x;\\n                    else\\n                        third = second, second = x;\\n                }\\n                else{\\n                    if(x > third)\\n                        third = x;\\n                }\\n            }\\n        }\\n        \\n        if(third != LONG_MIN) return third;\\n        else return max(first, second);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1163937,
                "title": "javascript",
                "content": "```\\nvar thirdMax = function(nums) {\\n    nums.sort((a,b) => b-a);\\n    \\n    const result = Array.from(new Set(nums));\\n    \\n    return result.length < 3 ? result[0] : result[2];\\n};",
                "solutionTags": [],
                "code": "```\\nvar thirdMax = function(nums) {\\n    nums.sort((a,b) => b-a);\\n    \\n    const result = Array.from(new Set(nums));\\n    \\n    return result.length < 3 ? result[0] : result[2];\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1145841,
                "title": "java-priorityqueue-solution",
                "content": "Use Priority Queue to store first, second, third largest numbers. If pq contains this value, ignore it. Meanwhil remeber maximum value of this array. At last, return third largest number if pq.size() == 3, otherwise return max.\\n```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        int max = Integer.MIN_VALUE;\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>();\\n        for(int i:nums){\\n            max = Math.max(max,i);\\n            if(!pq.contains(i))\\n                pq.add(i);\\n            if(pq.size() > 3)\\n                pq.poll();\\n        }\\n        return pq.size() == 3 ?pq.peek():max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        int max = Integer.MIN_VALUE;\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>();\\n        for(int i:nums){\\n            max = Math.max(max,i);\\n            if(!pq.contains(i))\\n                pq.add(i);\\n            if(pq.size() > 3)\\n                pq.poll();\\n        }\\n        return pq.size() == 3 ?pq.peek():max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907012,
                "title": "use-3-pointer-o-1-space-and-o-n-time-clean-and-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        int* m0=NULL, *m1=NULL, *m2=NULL;\\n        for(int i=0; i<nums.size(); i++){\\n            if((m0 && nums[i]==*m0) || (m1 && nums[i]==*m1) || (m2 && nums[i]==*m2)) continue;\\n            if(!m2 || nums[i] > *m2){\\n                m0 = m1;\\n                m1 = m2;\\n                m2 = &nums[i];\\n            } else if(!m1 || nums[i] > *m1){\\n                m0 = m1;\\n                m1 = &nums[i];\\n            } else if(!m0 || nums[i] > *m0){\\n                m0 = &nums[i];\\n            }\\n        }\\n        if(m0) return *m0;\\n        else return *m2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        int* m0=NULL, *m1=NULL, *m2=NULL;\\n        for(int i=0; i<nums.size(); i++){\\n            if((m0 && nums[i]==*m0) || (m1 && nums[i]==*m1) || (m2 && nums[i]==*m2)) continue;\\n            if(!m2 || nums[i] > *m2){\\n                m0 = m1;\\n                m1 = m2;\\n                m2 = &nums[i];\\n            } else if(!m1 || nums[i] > *m1){\\n                m0 = m1;\\n                m1 = &nums[i];\\n            } else if(!m0 || nums[i] > *m0){\\n                m0 = &nums[i];\\n            }\\n        }\\n        if(m0) return *m0;\\n        else return *m2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 809157,
                "title": "c-corner-cases-covered-using-long-long",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        long long inf=(long long)-1e10;\\n        long long a=-1,b=-1,c=-1;\\n        a=b=c=inf;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(a==nums[i] or b==nums[i] or c==nums[i])continue;\\n            if(nums[i]>a){\\n                c=b;\\n                b=a;\\n                a=nums[i];\\n            }\\n            else if(nums[i]>b){\\n                c=b;\\n                b=nums[i];\\n            }\\n            else if(nums[i]>c)\\n                c=nums[i];\\n            // cout<<\"a= \"<<a<<\" b= \"<<b<<\" c= \"<<c<<endl;\\n        }\\n        return c==inf?a:c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        long long inf=(long long)-1e10;\\n        long long a=-1,b=-1,c=-1;\\n        a=b=c=inf;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(a==nums[i] or b==nums[i] or c==nums[i])continue;\\n            if(nums[i]>a){\\n                c=b;\\n                b=a;\\n                a=nums[i];\\n            }\\n            else if(nums[i]>b){\\n                c=b;\\n                b=nums[i];\\n            }\\n            else if(nums[i]>c)\\n                c=nums[i];\\n            // cout<<\"a= \"<<a<<\" b= \"<<b<<\" c= \"<<c<<endl;\\n        }\\n        return c==inf?a:c;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 787586,
                "title": "python-3-o-n-time-complexity-o-1-extra-space",
                "content": "```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        \\n        \\'\\'\\'\\n            Time complexity: O(n)\\n            Space complexity: O(1)\\n            \\n            Using a max heap of size 3 will result (log 3)*O(n), which is still O(n)\\n            However, Python has nlargsest() from heapq library instead of max heap\\n        \\'\\'\\'\\n        \\n        nums = list(set(nums))  # 2*O(n)\\n        \\n        if len(nums) < 3:\\n            return max(nums)    # O(n)\\n        \\n        for i in range(2):      # 2*O(n)\\n            nums.remove(max(nums))\\n            \\n        return max(nums)        # O(n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        \\n        \\'\\'\\'\\n            Time complexity: O(n)\\n            Space complexity: O(1)\\n            \\n            Using a max heap of size 3 will result (log 3)*O(n), which is still O(n)\\n            However, Python has nlargsest() from heapq library instead of max heap\\n        \\'\\'\\'\\n        \\n        nums = list(set(nums))  # 2*O(n)\\n        \\n        if len(nums) < 3:\\n            return max(nums)    # O(n)\\n        \\n        for i in range(2):      # 2*O(n)\\n            nums.remove(max(nums))\\n            \\n        return max(nums)        # O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 766632,
                "title": "java-treeset-solution-o-n",
                "content": "````\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for(int i:nums) {\\n            Integer j = new Integer(i);\\n            set.add(j);\\n        }\\n        if(set.size()>=3){\\n            set.pollLast();\\n            set.pollLast();\\n        }\\n        return set.last();\\n    }\\n}\\n````",
                "solutionTags": [
                    "Java"
                ],
                "code": "````\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for(int i:nums) {\\n            Integer j = new Integer(i);\\n            set.add(j);\\n        }\\n        if(set.size()>=3){\\n            set.pollLast();\\n            set.pollLast();\\n        }\\n        return set.last();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696447,
                "title": "java-solution-o-n",
                "content": "```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n\\t//Using Integer instead of int so that we can use .equals() method.\\n        Integer max1=null;\\n        Integer max2=null;\\n        Integer max3=null;\\n        for(Integer i:nums)\\n        { \\n\\t\\t\\t// We have to skip element which is already assinged to either of the 3 variable.\\n            if(i.equals(max1) || i.equals(max2) || i.equals(max3))\\n                continue;\\n\\t\\t\\t// Initialize max1 if either null or value is greater than max1.\\n            if(max1==null|| i>max1){\\n                max3=max2; // If we have found any value greater than max1 we have to change max2 and max3 accordingly.\\n                max2=max1;\\n                max1=i;   \\n            }else if(max2==null|| i>max2){\\n                max3=max2;\\n                max2=i;   \\n            }else if(max3==null|| i>max3){\\n                max3=i;   \\n            }\\n             \\n        }\\n\\t\\t//checking for output \\n        return (max3==null)?max1:max3;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n\\t//Using Integer instead of int so that we can use .equals() method.\\n        Integer max1=null;\\n        Integer max2=null;\\n        Integer max3=null;\\n        for(Integer i:nums)\\n        { \\n\\t\\t\\t// We have to skip element which is already assinged to either of the 3 variable.\\n            if(i.equals(max1) || i.equals(max2) || i.equals(max3))\\n                continue;\\n\\t\\t\\t// Initialize max1 if either null or value is greater than max1.\\n            if(max1==null|| i>max1){\\n                max3=max2; // If we have found any value greater than max1 we have to change max2 and max3 accordingly.\\n                max2=max1;\\n                max1=i;   \\n            }else if(max2==null|| i>max2){\\n                max3=max2;\\n                max2=i;   \\n            }else if(max3==null|| i>max3){\\n                max3=i;   \\n            }\\n             \\n        }\\n\\t\\t//checking for output \\n        return (max3==null)?max1:max3;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 679580,
                "title": "javascript-68ms",
                "content": "```\\nconst thirdMax = (nums) => {\\n    nums = [...new Set(nums)];\\n    nums = nums.sort((a, b) => b - a);\\n    if (nums.length < 3) {\\n        return nums[0];\\n    }\\n    return nums[2];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst thirdMax = (nums) => {\\n    nums = [...new Set(nums)];\\n    nums = nums.sort((a, b) => b - a);\\n    if (nums.length < 3) {\\n        return nums[0];\\n    }\\n    return nums[2];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 559672,
                "title": "c-solutions-one-pass-sortedset-hashset",
                "content": "**One-Pass**\\n```\\n    public int ThirdMax(int[] nums) {\\n        \\n        long max1 = Int64.MinValue, max2 = Int64.MinValue, max3 = Int64.MinValue;        \\n        \\n        foreach(int num in nums)\\n        {            \\n            if(num > max1)\\n            {\\n                max3 = max2;\\n                max2 = max1;\\n                max1 = num;\\n            }\\n            else if(num < max1 && num > max2)\\n            {\\n                max3 = max2;\\n                max2 = num;   \\n            }\\n            else if(num < max2 && num > max3)\\n                max3 = num;\\n        }\\n        \\n        return max3 == Int64.MinValue? (int)max1 : (int)max3;\\n    }\\n```\\n\\n**MinHeap(SortedSet)**\\n```\\n    public int ThirdMax(int[] nums) {\\n          \\n        SortedSet<int> set = new SortedSet<int>();\\n        \\n        foreach(int num in nums)\\n        {\\n            set.Add(num);\\n            \\n            if(set.Count > 3)\\n                set.Remove(set.Min());\\n        }\\n                     \\n        return set.Count == 3? set.Min() : set.Max();\\n    }\\n```\\n**HashSet**\\n```\\n    public int ThirdMax(int[] nums) {\\n          \\n        HashSet<int> set = new HashSet<int>();\\n        \\n        foreach(int num in nums)\\n            set.Add(num);\\n            \\n        var sortedSet = set.OrderByDescending(x=>x);\\n        \\n        return set.Count >= 3 ? sortedSet.ToList()[2]: sortedSet.ToList()[0];\\n    }\\n```\\nNote: Both HashSet and SortedSet cannot contain duplicate elements.",
                "solutionTags": [],
                "code": "```\\n    public int ThirdMax(int[] nums) {\\n        \\n        long max1 = Int64.MinValue, max2 = Int64.MinValue, max3 = Int64.MinValue;        \\n        \\n        foreach(int num in nums)\\n        {            \\n            if(num > max1)\\n            {\\n                max3 = max2;\\n                max2 = max1;\\n                max1 = num;\\n            }\\n            else if(num < max1 && num > max2)\\n            {\\n                max3 = max2;\\n                max2 = num;   \\n            }\\n            else if(num < max2 && num > max3)\\n                max3 = num;\\n        }\\n        \\n        return max3 == Int64.MinValue? (int)max1 : (int)max3;\\n    }\\n```\n```\\n    public int ThirdMax(int[] nums) {\\n          \\n        SortedSet<int> set = new SortedSet<int>();\\n        \\n        foreach(int num in nums)\\n        {\\n            set.Add(num);\\n            \\n            if(set.Count > 3)\\n                set.Remove(set.Min());\\n        }\\n                     \\n        return set.Count == 3? set.Min() : set.Max();\\n    }\\n```\n```\\n    public int ThirdMax(int[] nums) {\\n          \\n        HashSet<int> set = new HashSet<int>();\\n        \\n        foreach(int num in nums)\\n            set.Add(num);\\n            \\n        var sortedSet = set.OrderByDescending(x=>x);\\n        \\n        return set.Count >= 3 ? sortedSet.ToList()[2]: sortedSet.ToList()[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 521612,
                "title": "c-faster-than-90-48-less-than-100-00-mem-o-n",
                "content": "Runtime: 92 ms\\nMemory Usage: 24.6 MB\\n\\n```\\npublic int ThirdMax(int[] nums) {\\n        int?[] maxList = new int?[3];        \\n        \\n        for(int i=0; i< nums.Length; i++)\\n        {           \\n            if (maxList[0] == null ||  maxList[0] < nums[i]) \\n            {   maxList[2] = maxList[1]; \\n                maxList[1] = maxList[0]; \\n                maxList[0] = nums[i]; \\n            }\\n            else if ((maxList[1] == null || maxList[1] < nums[i]) &&  nums[i] < maxList[0]) \\n            {\\n                 maxList[2] = maxList[1]; \\n                 maxList[1] = nums[i]; \\n            }\\n            else if ((maxList[2] == null || maxList[2] < nums[i]) && nums[i] < maxList[1]) \\n            { \\n                 maxList[2] = nums[i];\\n            }\\n        }\\n        \\n        return (int)(maxList[2] ?? maxList[0]);\\n    }",
                "solutionTags": [],
                "code": "Runtime: 92 ms\\nMemory Usage: 24.6 MB\\n\\n```\\npublic int ThirdMax(int[] nums) {\\n        int?[] maxList = new int?[3];        \\n        \\n        for(int i=0; i< nums.Length; i++)\\n        {           \\n            if (maxList[0] == null ||  maxList[0] < nums[i]) \\n            {   maxList[2] = maxList[1]; \\n                maxList[1] = maxList[0]; \\n                maxList[0] = nums[i]; \\n            }\\n            else if ((maxList[1] == null || maxList[1] < nums[i]) &&  nums[i] < maxList[0]) \\n            {\\n                 maxList[2] = maxList[1]; \\n                 maxList[1] = nums[i]; \\n            }\\n            else if ((maxList[2] == null || maxList[2] < nums[i]) && nums[i] < maxList[1]) \\n            { \\n                 maxList[2] = nums[i];\\n            }\\n        }\\n        \\n        return (int)(maxList[2] ?? maxList[0]);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 441534,
                "title": "java-solution-2-ms-faster-than-70-13",
                "content": "```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        Integer f = null,s= null,t=null;\\n        for(int i=0; i< nums.length; i++){\\n            int c = nums[i];\\n            if( (f!= null && f==c) || ( s!= null && s==c) || (t!= null && t == c) ) continue;\\n            if(t == null || c > t){\\n                f=s;\\n                s=t;\\n                t=c;\\n            }else if( s==null || c >s){\\n                f=s;\\n                s=c;\\n            }else if( f==null ||  c >=f){\\n                f=c;\\n            }\\n        }\\n        return f != null ? f : t;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        Integer f = null,s= null,t=null;\\n        for(int i=0; i< nums.length; i++){\\n            int c = nums[i];\\n            if( (f!= null && f==c) || ( s!= null && s==c) || (t!= null && t == c) ) continue;\\n            if(t == null || c > t){\\n                f=s;\\n                s=t;\\n                t=c;\\n            }else if( s==null || c >s){\\n                f=s;\\n                s=c;\\n            }else if( f==null ||  c >=f){\\n                f=c;\\n            }\\n        }\\n        return f != null ? f : t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 437602,
                "title": "really-short-and-simple-js-solution-o-n-o-1",
                "content": "```js\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar thirdMax = function(nums) {\\n  let max = -Infinity;\\n  let mid = -Infinity;\\n  let min = -Infinity;\\n  \\n  for (x of nums) {\\n    if (x > max) {\\n      min = mid;\\n      mid = max;\\n      max = x;\\n    }  else if (x > mid  && x < max) {\\n      min = mid;  \\n      mid = x;\\n    } else if (x > min && x < mid) {\\n      min = x;\\n    }\\n  }\\n  \\n  return (min > -Infinity) ? min : max;\\n  \\n};\\n```",
                "solutionTags": [],
                "code": "```js\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar thirdMax = function(nums) {\\n  let max = -Infinity;\\n  let mid = -Infinity;\\n  let min = -Infinity;\\n  \\n  for (x of nums) {\\n    if (x > max) {\\n      min = mid;\\n      mid = max;\\n      max = x;\\n    }  else if (x > mid  && x < max) {\\n      min = mid;  \\n      mid = x;\\n    } else if (x > min && x < mid) {\\n      min = x;\\n    }\\n  }\\n  \\n  return (min > -Infinity) ? min : max;\\n  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 403979,
                "title": "python-sets",
                "content": "```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        \\n        numset = set(nums)\\n        \\n        if len(numset) <= 2:\\n            return max(nums)\\n        \\n        else:\\n            for i in range(2):\\n                numset = numset - {max(numset)}\\n                \\n            return max(numset)\\n```",
                "solutionTags": [
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        \\n        numset = set(nums)\\n        \\n        if len(numset) <= 2:\\n            return max(nums)\\n        \\n        else:\\n            for i in range(2):\\n                numset = numset - {max(numset)}\\n                \\n            return max(numset)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 216449,
                "title": "swift-three-pointers",
                "content": "```class Solution {\\n    func thirdMax(_ nums: [Int]) -> Int {\\n        guard nums.count >= 3 else { return nums.max() ?? 0 }\\n        \\n        var max1 = Int.min\\n        var max2 = Int.min\\n        var max3 = Int.min\\n        \\n        for n in nums where n != max1 && n != max2 && n != max3 {\\n            if n > max1 {\\n                max3 = max2\\n                max2 = max1\\n                max1 = n\\n            } else if n > max2 {\\n                max3 = max2\\n                max2 = n\\n            } else if n > max3 {\\n                max3 = n\\n            }\\n        }\\n        \\n        if max3 != Int.min {\\n            return max3\\n        } else {\\n            return nums.max() ?? 0\\n        }\\n    }\\n}```",
                "solutionTags": [],
                "code": "```class Solution {\\n    func thirdMax(_ nums: [Int]) -> Int {\\n        guard nums.count >= 3 else { return nums.max() ?? 0 }\\n        \\n        var max1 = Int.min\\n        var max2 = Int.min\\n        var max3 = Int.min\\n        \\n        for n in nums where n != max1 && n != max2 && n != max3 {\\n            if n > max1 {\\n                max3 = max2\\n                max2 = max1\\n                max1 = n\\n            } else if n > max2 {\\n                max3 = max2\\n                max2 = n\\n            } else if n > max3 {\\n                max3 = n\\n            }\\n        }\\n        \\n        if max3 != Int.min {\\n            return max3\\n        } else {\\n            return nums.max() ?? 0\\n        }\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 111963,
                "title": "a-simple-c-solution-accepted",
                "content": "```\\nint thirdMax(int* nums, int numsSize) {\\n    int max1=INT_MIN;\\n    int max2=INT_MIN;\\n    int max3=INT_MIN;\\n    int count=0;\\n    for(int i=0;i<numsSize;i++){\\n        if(max1<=nums[i]){\\n           max1=nums[i]; \\n        }\\n    }\\n    for(int i=0;i<numsSize;i++){\\n        if(max2<=nums[i]&&nums[i]<max1){\\n            max2=nums[i];\\n        }  \\n    }\\n    for(int i=0;i<numsSize;i++){\\n        if(max3<=nums[i]&&nums[i]<max2){\\n            max3=nums[i];\\n            count++;\\n        } \\n    }\\n    if(count==0){return max1;}\\n    return max3;\\n}\\n````",
                "solutionTags": [],
                "code": "```\\nint thirdMax(int* nums, int numsSize) {\\n    int max1=INT_MIN;\\n    int max2=INT_MIN;\\n    int max3=INT_MIN;\\n    int count=0;\\n    for(int i=0;i<numsSize;i++){\\n        if(max1<=nums[i]){\\n           max1=nums[i]; \\n        }\\n    }\\n    for(int i=0;i<numsSize;i++){\\n        if(max2<=nums[i]&&nums[i]<max1){\\n            max2=nums[i];\\n        }  \\n    }\\n    for(int i=0;i<numsSize;i++){\\n        if(max3<=nums[i]&&nums[i]<max2){\\n            max3=nums[i];\\n            count++;\\n        } \\n    }\\n    if(count==0){return max1;}\\n    return max3;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 90393,
                "title": "c-handles-int-maxvalue-should-it-appear-in-numbers-array",
                "content": "This problem is simple but a little tricky to handle edge cases without a ton of if statements.  Anyhow, my idea was to use a helper function to find the max below a given max, I call this \"NextMax\".  Use it to find first max, use that to find second max and use that to find third max, still O(n) solution.  When no next max is found my NextMax function returns the max and so to handle the edge cases I check that the NextMax is less than previous max, else this is the condition where we should return the max.\\n\\nIf there is a more elegant solution I'd like to see it!  Thanks.\\n\\n\\n    public int ThirdMax(int[] nums) {\\n        int max = NextMax(nums, int.MaxValue);    \\n        int max2 = NextMax(nums, max);\\n        if (max2 == max) return max;\\n        else\\n        {\\n            int max3 = NextMax(nums, max2);\\n            if (max3 == max2) return max;\\n            else return max3;\\n        }\\n    }\\n    \\n    public int NextMax(int[] nums, int max)\\n    {\\n        int nextMax = 0;\\n        bool any = false;\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            if (nums[i] < max)\\n            {\\n                if (any == false)\\n                {\\n                    nextMax = nums[i];\\n                    any = true;\\n                }\\n                else if (nums[i] > nextMax)\\n                {\\n                    nextMax = nums[i];\\n                }\\n            }\\n        }\\n        \\n        return any ? nextMax : max;\\n    }",
                "solutionTags": [],
                "code": "This problem is simple but a little tricky to handle edge cases without a ton of if statements.  Anyhow, my idea was to use a helper function to find the max below a given max, I call this \"NextMax\".  Use it to find first max, use that to find second max and use that to find third max, still O(n) solution.  When no next max is found my NextMax function returns the max and so to handle the edge cases I check that the NextMax is less than previous max, else this is the condition where we should return the max.\\n\\nIf there is a more elegant solution I'd like to see it!  Thanks.\\n\\n\\n    public int ThirdMax(int[] nums) {\\n        int max = NextMax(nums, int.MaxValue);    \\n        int max2 = NextMax(nums, max);\\n        if (max2 == max) return max;\\n        else\\n        {\\n            int max3 = NextMax(nums, max2);\\n            if (max3 == max2) return max;\\n            else return max3;\\n        }\\n    }\\n    \\n    public int NextMax(int[] nums, int max)\\n    {\\n        int nextMax = 0;\\n        bool any = false;\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            if (nums[i] < max)\\n            {\\n                if (any == false)\\n                {\\n                    nextMax = nums[i];\\n                    any = true;\\n                }\\n                else if (nums[i] > nextMax)\\n                {\\n                    nextMax = nums[i];\\n                }\\n            }\\n        }\\n        \\n        return any ? nextMax : max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 90233,
                "title": "using-java-treeset",
                "content": "Using a TreeSet which contains at most three elements at all time so the space complexity is O(1)\\nAnd, the time complexity should be n\\\\*(3\\\\*log(3)), which still in O(n). \\n\\n```\\npublic int thirdMax(int[] nums) {\\n        TreeSet<Integer> set = new TreeSet();\\n        for (int num : nums){\\n            if (! set.contains(num) ){\\n                set.add(num);\\n                while (set.size() > 3) set.pollFirst();\\n            }\\n        }\\n        return set.size() > 2 ? set.pollFirst(): set.pollLast();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int thirdMax(int[] nums) {\\n        TreeSet<Integer> set = new TreeSet();\\n        for (int num : nums){\\n            if (! set.contains(num) ){\\n                set.add(num);\\n                while (set.size() > 3) set.pollFirst();\\n            }\\n        }\\n        return set.size() > 2 ? set.pollFirst(): set.pollLast();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 90429,
                "title": "make-clear-about-how-to-handle-the-duplicated-number",
                "content": "It seems when the array has duplicated numbers, we should treat it as we first remove all the duplicates. \\n\\n```\\nSubmission Result: Wrong Answer More Details \\n\\nInput:\\n[1,2,2,5,3,5]\\nOutput:\\n3\\nExpected:\\n2\\n```",
                "solutionTags": [],
                "code": "```\\nSubmission Result: Wrong Answer More Details \\n\\nInput:\\n[1,2,2,5,3,5]\\nOutput:\\n3\\nExpected:\\n2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3524334,
                "title": "easy-to-understand-solution-uses-distinct-and-sort-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int ThirdMax(int[] nums) {\\n          List<int> list = nums.Distinct().ToList();\\n            list.Sort();\\n            if(list.Count < 3)\\n            {\\n                return list[list.Count - 1];\\n            }\\n\\n    \\n            return list[list.Count - 3];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int ThirdMax(int[] nums) {\\n          List<int> list = nums.Distinct().ToList();\\n            list.Sort();\\n            if(list.Count < 3)\\n            {\\n                return list[list.Count - 1];\\n            }\\n\\n    \\n            return list[list.Count - 3];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497343,
                "title": "easy-c-solution-using-sort-method",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAfter sorting the given array, the element at [n-3] will be the maximum element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        set<int> numsSet;\\n        vector<int> ans;\\n\\n        for(int i=0;i<nums.size();i++)\\n            numsSet.insert(nums[i]);\\n        \\n        for(auto x : numsSet)\\n            ans.push_back(x);\\n\\n        if(ans.size()==1)\\n            return ans[0];\\n  \\n        if(ans.size()==2){\\n            sort(ans.begin(),ans.end());\\n            return ans[1];\\n        }\\n\\n        if(ans.size()>=3)\\n            return ans[ans.size()-3];\\n        \\n        return ans[ans.size()];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        set<int> numsSet;\\n        vector<int> ans;\\n\\n        for(int i=0;i<nums.size();i++)\\n            numsSet.insert(nums[i]);\\n        \\n        for(auto x : numsSet)\\n            ans.push_back(x);\\n\\n        if(ans.size()==1)\\n            return ans[0];\\n  \\n        if(ans.size()==2){\\n            sort(ans.begin(),ans.end());\\n            return ans[1];\\n        }\\n\\n        if(ans.size()>=3)\\n            return ans[ans.size()-3];\\n        \\n        return ans[ans.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497005,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    get rid of duplicate element from array and add only\\n    the element only once to priority queue\\n\\n    if PQ size< 3 then return the first element else return the 3rd\\n     element popped\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        HashSet<Integer> set= new HashSet<>();\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n\\n        for(int num: nums){\\n            if(!set.contains(num)){\\n                pq.add(num);\\n                set.add(num);\\n            }\\n    }\\n    \\n    int p=0;\\n    int n=pq.size();\\n    if(n<3) return pq.poll();\\n    for(int i=0;i<3;i++){\\n        \\n        p=pq.poll();\\n        \\n        \\n    }\\n\\nreturn p;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        HashSet<Integer> set= new HashSet<>();\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n\\n        for(int num: nums){\\n            if(!set.contains(num)){\\n                pq.add(num);\\n                set.add(num);\\n            }\\n    }\\n    \\n    int p=0;\\n    int n=pq.size();\\n    if(n<3) return pq.poll();\\n    for(int i=0;i<3;i++){\\n        \\n        p=pq.poll();\\n        \\n        \\n    }\\n\\nreturn p;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452578,
                "title": "using-set-and-sort-function-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfirst i just use sort function and array el are assding order but it is not working then i use set then sort and working fine\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst i use the set method to remove all the dublicate the sort the array, then check the length and return the value\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(n))  // because of sort function\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar thirdMax = function(nums) {\\n    set =[...new Set(nums)]\\n    set.sort((a,b)=>a-b);\\nif(set.length<3){\\n    return set[set.length-1]\\n}\\n\\n    return set[set.length-3]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar thirdMax = function(nums) {\\n    set =[...new Set(nums)]\\n    set.sort((a,b)=>a-b);\\nif(set.length<3){\\n    return set[set.length-1]\\n}\\n\\n    return set[set.length-3]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3336245,
                "title": "c-beats-95-69-time-92-35-space-o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach: \\n\\u2022 Go on traversing the array and updating the first maximum, second maximum, and third maximum variables accordingly.\\n\\n\\u2022 Keep in mind that as we have initialized the minimum values to INT_MIN, we can also have INT_MIN value as the array value (look at the constraints).\\n\\n\\u2022 To resolve this issue, we can have another variable describing if the variable value is updated to INT_MIN from the array value OR is the initialized default value INT_MIN. For this, we use pair.\\n\\n\\u2022 We can thus easily find the solution depending on whether the third minimum pair value was updated.\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        \\n        int n= nums.size();\\n        \\n        pair<int, int>fm= {INT_MIN, -1};\\n        pair<int, int>sm= {INT_MIN, -1};\\n        pair<int, int>tm= {INT_MIN, -1};\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i]>fm.first||(nums[i]==INT_MIN&&fm.second==-1))\\n            {\\n                if(sm.second!=-1)\\n                {\\n                    tm.first= sm.first;\\n                    tm.second=1;\\n                }\\n                if(fm.second!=-1)\\n                {\\n                    sm.first= fm.first;\\n                    sm.second=1;\\n                }\\n                fm.first= nums[i];\\n                fm.second=1;\\n            }\\n            if(fm.first==nums[i])\\n            {\\n                continue;\\n            }\\n            else if(nums[i]>sm.first||(nums[i]==INT_MIN&&sm.second==-1))\\n            {\\n                if(sm.second!=-1)\\n                {\\n                    tm= sm;\\n                    tm.second=1;\\n                }\\n                sm.first= nums[i];\\n                sm.second=1;\\n            }\\n            if(sm.first==nums[i])\\n            {\\n                continue;\\n            }\\n            else if(nums[i]>tm.first||(nums[i]==INT_MIN&&tm.second==-1))\\n            {\\n                tm.first= nums[i];\\n                tm.second= 1;\\n            }\\n        }\\n        if(tm.second==-1) return fm.first;\\n        \\n        return tm.first;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        \\n        int n= nums.size();\\n        \\n        pair<int, int>fm= {INT_MIN, -1};\\n        pair<int, int>sm= {INT_MIN, -1};\\n        pair<int, int>tm= {INT_MIN, -1};\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i]>fm.first||(nums[i]==INT_MIN&&fm.second==-1))\\n            {\\n                if(sm.second!=-1)\\n                {\\n                    tm.first= sm.first;\\n                    tm.second=1;\\n                }\\n                if(fm.second!=-1)\\n                {\\n                    sm.first= fm.first;\\n                    sm.second=1;\\n                }\\n                fm.first= nums[i];\\n                fm.second=1;\\n            }\\n            if(fm.first==nums[i])\\n            {\\n                continue;\\n            }\\n            else if(nums[i]>sm.first||(nums[i]==INT_MIN&&sm.second==-1))\\n            {\\n                if(sm.second!=-1)\\n                {\\n                    tm= sm;\\n                    tm.second=1;\\n                }\\n                sm.first= nums[i];\\n                sm.second=1;\\n            }\\n            if(sm.first==nums[i])\\n            {\\n                continue;\\n            }\\n            else if(nums[i]>tm.first||(nums[i]==INT_MIN&&tm.second==-1))\\n            {\\n                tm.first= nums[i];\\n                tm.second= 1;\\n            }\\n        }\\n        if(tm.second==-1) return fm.first;\\n        \\n        return tm.first;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276736,
                "title": "one-line-solution-beats-95-15-of-runtimes",
                "content": "![Screen Shot 2023-03-09 at 3.48.36 PM.png](https://assets.leetcode.com/users/images/0c861477-a49b-4fb3-87b2-e32330d54ed1_1678373347.4268534.png)\\n\\n\\n```\\nfunction thirdMax(nums: number[]): number {\\n    return [...new Set(nums)].length < 3 ? [...new Set(nums)].sort((a, b) => b - a)[0] :  [...new Set(nums)].sort((a, b) => b - a)[2];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction thirdMax(nums: number[]): number {\\n    return [...new Set(nums)].length < 3 ? [...new Set(nums)].sort((a, b) => b - a)[0] :  [...new Set(nums)].sort((a, b) => b - a)[2];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3256980,
                "title": "most-easiest-code-easy-to-understand-remove-duplicates",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)-->time complexity\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    o(n)--space complexity\\n# Code\\n```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        y=set(nums)\\n        m=list(y)\\n        if len(y)==1:\\n            return m[0]\\n        elif len(y)==2:\\n            m.sort()\\n            return m[-1]\\n        else:\\n            for i in range(3):\\n                for j in range(len(m)-1):\\n                    if m[j]>m[j+1]:\\n                        m[j],m[j+1]=m[j+1],m[j]\\n            return m[-3]\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        y=set(nums)\\n        m=list(y)\\n        if len(y)==1:\\n            return m[0]\\n        elif len(y)==2:\\n            m.sort()\\n            return m[-1]\\n        else:\\n            for i in range(3):\\n                for j in range(len(m)-1):\\n                    if m[j]>m[j+1]:\\n                        m[j],m[j+1]=m[j+1],m[j]\\n            return m[-3]\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3215260,
                "title": "third-maximum-number-java-set-priority-queue",
                "content": "# Code\\n```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n\\n        Set<Integer> set = new HashSet<>();\\n        for(int i=nums.length-1; i>=0; i--){\\n            set.add(nums[i]);\\n        }\\n        if(set.size() < 3) return Collections.max(set);\\n\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int num: set){\\n            pq.offer(num);\\n            if(pq.size() > 3) pq.poll();\\n        }\\n\\n        if(pq.size() == 2) pq.poll();\\n\\n        return pq.peek();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n\\n        Set<Integer> set = new HashSet<>();\\n        for(int i=nums.length-1; i>=0; i--){\\n            set.add(nums[i]);\\n        }\\n        if(set.size() < 3) return Collections.max(set);\\n\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int num: set){\\n            pq.offer(num);\\n            if(pq.size() > 3) pq.poll();\\n        }\\n\\n        if(pq.size() == 2) pq.poll();\\n\\n        return pq.peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210686,
                "title": "find-the-third-maximum-number-in-a-list-with-this-genius-puzzle-solving-code-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen you are given a problem, the first thing you think about is how to solve it. It\\'s like when you have a puzzle, you need to think of the best way to put the pieces together to finish it. So, the first thoughts on how to solve a problem are like the first steps you take to finish a puzzle.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSolving a problem is like finding a solution to a question. You need to have a plan, or an approach, to do it. Just like when you have homework, you need to have a plan on how to finish it. In this code, the approach is to find the third maximum number in a list of numbers. The code looks at each number in the list, and compares it to the maximum numbers it has found so far. If the number is bigger than the first maximum number, it becomes the new first maximum number. If it\\'s bigger than the second maximum number, it becomes the new second maximum number. If it\\'s bigger than the third maximum number, it becomes the new third maximum number. The code keeps track of the three maximum numbers and returns the third one. If there are less than three unique numbers in the list, it just returns the first maximum number.\\n# Complexity\\n- Time complexity: The time it takes to solve the problem is proportional to the number of unique numbers in the list. So, the time complexity is $$O(n)$$, where n is the number of unique numbers.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The code uses a set to keep track of the unique numbers, so the space complexity is also $$O(n)$$, where n is the number of unique numbers.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        first_max = second_max = third_max = float(\\'-inf\\')\\n        unique_nums = set(nums)\\n\\n        for num in unique_nums:\\n            if num > first_max:\\n                third_max = second_max\\n                second_max = first_max\\n                first_max = num\\n            elif num > second_max:\\n                third_max = second_max\\n                second_max = num\\n            elif num > third_max:\\n                third_max = num\\n\\n        return third_max if len(unique_nums) >= 3 else first_max\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        first_max = second_max = third_max = float(\\'-inf\\')\\n        unique_nums = set(nums)\\n\\n        for num in unique_nums:\\n            if num > first_max:\\n                third_max = second_max\\n                second_max = first_max\\n                first_max = num\\n            elif num > second_max:\\n                third_max = second_max\\n                second_max = num\\n            elif num > third_max:\\n                third_max = num\\n\\n        return third_max if len(unique_nums) >= 3 else first_max\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169012,
                "title": "optimized-solution-keep-track-of-3-elements-o-n-timecomplexity",
                "content": "# Intuition\\nOptimized Solution of O(n) Time Complexity and O(1) Space Complexity\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing Optimization solution by keeping track of Max 3 elements as sorting takes O(n logn) so to improve that used this algorithm.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n             int n = nums.size(); \\n             int fir, sec,i; // dummy variables\\n             int mx[3]= {INT_MIN,INT_MIN,INT_MIN};// declare the minimum elements \\n             int cnt =0; // unique elements found count =0\\n             bool flag =1; // flag =1 means true \\n             for(int i =0; i<n; i++){\\n                 if (nums[i]==mx[0]||nums[i]==mx[1]||nums[i]==mx[2]) \\n                 {if(nums[i]==INT_MIN&& flag){\\n                   flag =0; \\n                   cnt++; // increase count cnt = 1\\n               }\\n               continue; // set return back and again loop run // mx = int_min\\n                 \\n        }\\n                 if (nums[i]>mx[0])\\n                 { \\n                     cnt++;\\n                     // if so then increase the count\\n                     fir =mx[0]; // int_min\\n                     sec= mx[1]; // int_min\\n                     mx[0]=nums[i]; // 3 \\n                     mx[1]=fir;\\n                     mx[2]=sec;\\n        }\\n          \\n                  else if(nums[i]>mx[1]){\\n                      cnt++;\\n                      fir =mx[1];\\n                      mx[1]=nums[i];\\n                      mx[2]=fir;\\n        }\\n                  else if(nums[i]>mx[2]){\\n                      cnt++;\\n                      mx[2]=nums[i];\\n        }\\n}\\n\\n\\n\\nif (cnt<=2){\\n    return mx[0];\\n    }\\nelse\\n    {\\n    return mx[2];\\n    }\\n    \\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n             int n = nums.size(); \\n             int fir, sec,i; // dummy variables\\n             int mx[3]= {INT_MIN,INT_MIN,INT_MIN};// declare the minimum elements \\n             int cnt =0; // unique elements found count =0\\n             bool flag =1; // flag =1 means true \\n             for(int i =0; i<n; i++){\\n                 if (nums[i]==mx[0]||nums[i]==mx[1]||nums[i]==mx[2]) \\n                 {if(nums[i]==INT_MIN&& flag){\\n                   flag =0; \\n                   cnt++; // increase count cnt = 1\\n               }\\n               continue; // set return back and again loop run // mx = int_min\\n                 \\n        }\\n                 if (nums[i]>mx[0])\\n                 { \\n                     cnt++;\\n                     // if so then increase the count\\n                     fir =mx[0]; // int_min\\n                     sec= mx[1]; // int_min\\n                     mx[0]=nums[i]; // 3 \\n                     mx[1]=fir;\\n                     mx[2]=sec;\\n        }\\n          \\n                  else if(nums[i]>mx[1]){\\n                      cnt++;\\n                      fir =mx[1];\\n                      mx[1]=nums[i];\\n                      mx[2]=fir;\\n        }\\n                  else if(nums[i]>mx[2]){\\n                      cnt++;\\n                      mx[2]=nums[i];\\n        }\\n}\\n\\n\\n\\nif (cnt<=2){\\n    return mx[0];\\n    }\\nelse\\n    {\\n    return mx[2];\\n    }\\n    \\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168810,
                "title": "easy-java-sol-with-explanation",
                "content": "\\n\\n# Approach\\nI firstly sorted the array and then created an arraylist, so that I can eliminate the duplicates and form an array without any duplicates. After that just coding the conditions to get the desired results.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        ArrayList<Integer> l=new ArrayList<>();\\n        Arrays.sort(nums);\\n        for (int i=0;i<nums.length;i++) {\\n// Here I\\'m coding a codition to prevent addition of duplicates in the list.\\n            if (i==0 || nums[i]!=nums[i-1]) {\\n                l.add(nums[i]);\\n            }\\n        }\\n        int[] arr=new int[l.size()];\\n        for (int i=0;i<arr.length;i++) {\\n            arr[i]=l.get(i);\\n        }\\n        if (arr.length>=3) {\\n            return arr[l.size()-3];\\n        }\\n        return arr[l.size()-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        ArrayList<Integer> l=new ArrayList<>();\\n        Arrays.sort(nums);\\n        for (int i=0;i<nums.length;i++) {\\n// Here I\\'m coding a codition to prevent addition of duplicates in the list.\\n            if (i==0 || nums[i]!=nums[i-1]) {\\n                l.add(nums[i]);\\n            }\\n        }\\n        int[] arr=new int[l.size()];\\n        for (int i=0;i<arr.length;i++) {\\n            arr[i]=l.get(i);\\n        }\\n        if (arr.length>=3) {\\n            return arr[l.size()-3];\\n        }\\n        return arr[l.size()-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113587,
                "title": "easy-to-understand-solution-time-o-n-space-o-1-1ms-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is that we find the largest number in turn where the next search excludes the previous large number.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The first loop looks for the first largest number and stores it in `firstDistinct`\\n2. the second loop looks for the largest number that is less than `firstDistinct` and stores it in `secondDistinct`.\\n3. The third loop looks for the largest number that is less than `secondDistinct` and stores it in `thirdDistinct`.\\nAdditional condition **equals** in `nums[i] >= thirdDistinct`. Equals when the third largest number and is the default value(`Integer.MIN_VALUE`) when initializing the `thirdDistinct` variable.\\n4. boolean variable `isChanged` is declared to know whether the third largest number was found; if not, then return the first largest number.\\n5. If `isChanged` is true then return the third number.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        int firstDistinct = Integer.MIN_VALUE;\\n        int secondDistinct = Integer.MIN_VALUE;\\n        int thirdDistinct = Integer.MIN_VALUE;\\n        boolean isChanged = false;\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] > firstDistinct) {\\n                firstDistinct = nums[i];\\n            }\\n        }\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] > secondDistinct && nums[i] < firstDistinct) {\\n                secondDistinct = nums[i];\\n            }\\n        }\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] >= thirdDistinct && nums[i] < secondDistinct) {\\n                thirdDistinct = nums[i];\\n                isChanged = true;\\n            }\\n        }\\n        if(!isChanged) {\\n            return firstDistinct;\\n        }\\n        return thirdDistinct;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int thirdMax(int[] nums) {\\n        int firstDistinct = Integer.MIN_VALUE;\\n        int secondDistinct = Integer.MIN_VALUE;\\n        int thirdDistinct = Integer.MIN_VALUE;\\n        boolean isChanged = false;\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] > firstDistinct) {\\n                firstDistinct = nums[i];\\n            }\\n        }\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] > secondDistinct && nums[i] < firstDistinct) {\\n                secondDistinct = nums[i];\\n            }\\n        }\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] >= thirdDistinct && nums[i] < secondDistinct) {\\n                thirdDistinct = nums[i];\\n                isChanged = true;\\n            }\\n        }\\n        if(!isChanged) {\\n            return firstDistinct;\\n        }\\n        return thirdDistinct;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097798,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint thirdMax(int* nums, int numsSize)\\n{\\n\\n    int n=numsSize,temp;\\n    \\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=i+1;j<n;j++)\\n        {\\n            if(nums[i]<nums[j])\\n            {\\n                temp=nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=temp;\\n            }\\n        }\\n    }\\n\\n   int count=1,pos;\\n\\n    if(n<3)\\n    return nums[0];\\n    else\\n    {\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(nums[i]!=nums[i+1])\\n            count++;\\n            if(count==3)\\n            pos=i+1;\\n\\n        }\\n        if(count<3)\\n        return nums[0];\\n\\n        return nums[pos];\\n    }\\n\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint thirdMax(int* nums, int numsSize)\\n{\\n\\n    int n=numsSize,temp;\\n    \\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=i+1;j<n;j++)\\n        {\\n            if(nums[i]<nums[j])\\n            {\\n                temp=nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=temp;\\n            }\\n        }\\n    }\\n\\n   int count=1,pos;\\n\\n    if(n<3)\\n    return nums[0];\\n    else\\n    {\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(nums[i]!=nums[i+1])\\n            count++;\\n            if(count==3)\\n            pos=i+1;\\n\\n        }\\n        if(count<3)\\n        return nums[0];\\n\\n        return nums[pos];\\n    }\\n\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3083228,
                "title": "c-hash-table-min-heap-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n+nlogn)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        unordered_map<int, int>m;\\n        for(int i=0; i<nums.size(); i++){\\n            if(m.find(nums[i])==m.end()){\\n                m[nums[i]]++;\\n            }\\n            else{\\n                nums.erase(nums.begin()+i);\\n                i--;\\n            }\\n        }\\n        priority_queue<int, vector<int>, greater<int>>q;\\n        for(int i=0; i<nums.size(); i++){\\n            q.push(nums[i]);\\n            if(3<q.size()){\\n                q.pop();\\n            }\\n        }\\n        if(q.size()<3){\\n            return *max_element(nums.begin(), nums.end());\\n        }\\n        return q.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        unordered_map<int, int>m;\\n        for(int i=0; i<nums.size(); i++){\\n            if(m.find(nums[i])==m.end()){\\n                m[nums[i]]++;\\n            }\\n            else{\\n                nums.erase(nums.begin()+i);\\n                i--;\\n            }\\n        }\\n        priority_queue<int, vector<int>, greater<int>>q;\\n        for(int i=0; i<nums.size(); i++){\\n            q.push(nums[i]);\\n            if(3<q.size()){\\n                q.pop();\\n            }\\n        }\\n        if(q.size()<3){\\n            return *max_element(nums.begin(), nums.end());\\n        }\\n        return q.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038963,
                "title": "easy-and-understandable-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int thirdMax(int[] arr) {\\n    int n = arr.length, posTL = -1;\\n\\tint large = Arrays.stream(arr).max().getAsInt();\\n\\tint secondLarge = Integer.MIN_VALUE;\\n    int thirdLarge = Integer.MIN_VALUE;\\n\\n    for (int i = 0; i < n; i++) {\\n    if(arr[i] > secondLarge && arr[i] != large) {\\n        secondLarge = arr[i];\\n    }\\n    }\\n\\n    for (int i = 0; i < n; i++) {\\n    if(arr[i] >= thirdLarge && arr[i] != secondLarge && arr[i] != large) {\\n        thirdLarge = arr[i];\\n        posTL = i;\\n    }\\n    }\\n    if(n == 1){\\n        return arr[0];\\n    } else if(posTL == -1) {\\n        return large;\\n    }\\n\\treturn thirdLarge;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int thirdMax(int[] arr) {\\n    int n = arr.length, posTL = -1;\\n\\tint large = Arrays.stream(arr).max().getAsInt();\\n\\tint secondLarge = Integer.MIN_VALUE;\\n    int thirdLarge = Integer.MIN_VALUE;\\n\\n    for (int i = 0; i < n; i++) {\\n    if(arr[i] > secondLarge && arr[i] != large) {\\n        secondLarge = arr[i];\\n    }\\n    }\\n\\n    for (int i = 0; i < n; i++) {\\n    if(arr[i] >= thirdLarge && arr[i] != secondLarge && arr[i] != large) {\\n        thirdLarge = arr[i];\\n        posTL = i;\\n    }\\n    }\\n    if(n == 1){\\n        return arr[0];\\n    } else if(posTL == -1) {\\n        return large;\\n    }\\n\\treturn thirdLarge;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033722,
                "title": "java-7-line-solution-treeset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse a `TreeSet` data structure with reverse sorting order. Remove the smallest element when the size of the set becomes greater than 3. This will ensure that the set holds the 3 largest numbers at any given time.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Add each element of the input array to the set.\\n1. If the size of the set becomes greater than 3, remove the last (smallest) element.\\n1. At the end if the set contains 3 elements, return the smallest of the 3, else return the largest element.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int thirdMax(int[] nums) {\\n    TreeSet<Integer> set = new TreeSet<>(Collections.reverseOrder());\\n\\n    for (int n : nums) {\\n      set.add(n);\\n      if (set.size() > 3) set.pollLast();\\n    }\\n    return set.size() == 3 ? set.pollLast() : set.pollFirst();\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n  public int thirdMax(int[] nums) {\\n    TreeSet<Integer> set = new TreeSet<>(Collections.reverseOrder());\\n\\n    for (int n : nums) {\\n      set.add(n);\\n      if (set.size() > 3) set.pollLast();\\n    }\\n    return set.size() == 3 ? set.pollLast() : set.pollFirst();\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2864106,
                "title": "beats-99-easy-python-solution",
                "content": "```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        if len(nums) >= 3:\\n            checked = set()\\n            count = 0\\n            nums.sort()\\n            for i in range(len(nums) - 1, -1, -1):\\n                if nums[i] not in checked:\\n                    if count == 2:\\n                        return nums[i]\\n                    else:\\n                        checked.add(nums[i])\\n                        count += 1\\n            return max(nums)\\n        else:\\n            return max(nums)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        if len(nums) >= 3:\\n            checked = set()\\n            count = 0\\n            nums.sort()\\n            for i in range(len(nums) - 1, -1, -1):\\n                if nums[i] not in checked:\\n                    if count == 2:\\n                        return nums[i]\\n                    else:\\n                        checked.add(nums[i])\\n                        count += 1\\n            return max(nums)\\n        else:\\n            return max(nums)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566790,
                "content": [
                    {
                        "username": "coldknight",
                        "content": "Isn't 3 the third maximum number of [1,2,2,5,3,5]? Why OJ gave 2?"
                    },
                    {
                        "username": "biswambar",
                        "content": "it\\'s mentioned in the question that, you have to find the third \"distinct\" maximum number.\\ndistinct(not duplicate) means unique\\nthe arr = [1,2,2,5,3,5] for distinct element will be -> arr = [1,2,3,5]  so 2 is the answer. \\n"
                    },
                    {
                        "username": "szp14",
                        "content": "For the testing case [-2147483648, 1, 2], the third maximum number is -2147483648, but the \"Run\" command of this question returns 2"
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) where is the relation with num.lenght?\\n"
                    },
                    {
                        "username": "singh_3662",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) his case has a num length of 3 which lies between 1 to 10^4"
                    },
                    {
                        "username": "darveshchauhan0001",
                        "content": "num length should be between 1 to 10^4"
                    },
                    {
                        "username": "xqcow",
                        "content": "why does this question have so many dislikes?"
                    },
                    {
                        "username": "aro",
                        "content": "\"THIRD DISTINCT NUMBER\""
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "It\\'s harder than some mediums in the same category as this one requires handling some annoying edge cases"
                    },
                    {
                        "username": "chrispeloso2",
                        "content": "The prompt is kinda confusing imo"
                    },
                    {
                        "username": "heg816",
                        "content": "The edgecases can be annoying. It\\'s not a bad prompt, but many questions with sneaky or tedious edgecases tend to get downvoted regardless of quality"
                    },
                    {
                        "username": "wtfk",
                        "content": "why test has Integer.MIN_VALUE!!!!\\n\\nare you crazy ?\\nare you crazy?"
                    },
                    {
                        "username": "honua",
                        "content": "that\\'s a good edge case, isn\\'t it? :D "
                    },
                    {
                        "username": "steeeevenn",
                        "content": "Hey so I run my code but one of the test case failed. However, I don\\'t the expected answer is correct. \\nThe input is [5,2,2]. The third maximun does not exist, so it should return the second maximum, which is 2. But the system is saying the expected answer is 5, which is the maximum.  Any ideas?\\n![image](https://assets.leetcode.com/users/images/77d31306-7523-465a-927c-9936842fc8e8_1619580785.8389773.png)\\n"
                    },
                    {
                        "username": "jackere1",
                        "content": "class Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        set<int> numSet(nums.begin(), nums.end());\\n\\n        set<int>::iterator itr = numSet.end();\\n\\n        cout << *itr;\\n        if(numSet.size() < 3)\\n            return *itr;\\n\\n        advance(itr, -3);\\n        return *itr;\\n    }\\n};\\n\\nI have same problem here and I tested my code 1000 times. It gives correct answer on my machine but gives 2 on this machine. What is wrong the with compiler?"
                    },
                    {
                        "username": "andresstawski",
                        "content": "If the third maximum does not exist, return the maximum number."
                    },
                    {
                        "username": "ankit_borbora",
                        "content": "The question says that if a 3rd max no. is not present, then print the maximum no. Not the second max no."
                    },
                    {
                        "username": "shreysaini1998",
                        "content": "it says in question if 3rd max does not exist, return the 1st max"
                    },
                    {
                        "username": "N8mare",
                        "content": "read the question properly,,,if 3rd max doesn\\'t exists then return the maximum number"
                    },
                    {
                        "username": "AyushThakur-7",
                        "content": " Try by adding the elements in a arraylist and removing the duplicates as you add the elements. After this you just need to transfer the elements back to an array and  apply required conditions."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thanks done\\n"
                    },
                    {
                        "username": "Geeks-Vegeta",
                        "content": "def thirdMax(self, nums: List[int]) -> int:\\n        newset=list(set(nums))\\n        lenset=len(newset)\\n        newset.sort(reverse=True)\\n        if lenset>=3:\\n            return newset[2]\\n        else:\\n            return newset[0]"
                    },
                    {
                        "username": "sathishb1139",
                        "content": "o(n log n) right\\n"
                    },
                    {
                        "username": "mustafaAlhillo",
                        "content": "for test case [1,2147483647,-2147483648], Why the expected answer is -2147483648. \nthose are two elements and it should return the Max value which is 1,2147483647"
                    },
                    {
                        "username": "pstrait",
                        "content": "Wut? that\\'s 3 elements.  Element #1 = 1.  Element #2 = 2147483647.  Element #3 = -2147483647."
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "using python 3:-\\n\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        x = sorted(set(nums),reverse=True)\\n        if len(x) < 3:\\n            return x[0]\\n        else:\\n            return x[2]"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/414_Third_Max_Num.cpp"
                    }
                ]
            },
            {
                "id": 1565163,
                "content": [
                    {
                        "username": "coldknight",
                        "content": "Isn't 3 the third maximum number of [1,2,2,5,3,5]? Why OJ gave 2?"
                    },
                    {
                        "username": "biswambar",
                        "content": "it\\'s mentioned in the question that, you have to find the third \"distinct\" maximum number.\\ndistinct(not duplicate) means unique\\nthe arr = [1,2,2,5,3,5] for distinct element will be -> arr = [1,2,3,5]  so 2 is the answer. \\n"
                    },
                    {
                        "username": "szp14",
                        "content": "For the testing case [-2147483648, 1, 2], the third maximum number is -2147483648, but the \"Run\" command of this question returns 2"
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) where is the relation with num.lenght?\\n"
                    },
                    {
                        "username": "singh_3662",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) his case has a num length of 3 which lies between 1 to 10^4"
                    },
                    {
                        "username": "darveshchauhan0001",
                        "content": "num length should be between 1 to 10^4"
                    },
                    {
                        "username": "xqcow",
                        "content": "why does this question have so many dislikes?"
                    },
                    {
                        "username": "aro",
                        "content": "\"THIRD DISTINCT NUMBER\""
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "It\\'s harder than some mediums in the same category as this one requires handling some annoying edge cases"
                    },
                    {
                        "username": "chrispeloso2",
                        "content": "The prompt is kinda confusing imo"
                    },
                    {
                        "username": "heg816",
                        "content": "The edgecases can be annoying. It\\'s not a bad prompt, but many questions with sneaky or tedious edgecases tend to get downvoted regardless of quality"
                    },
                    {
                        "username": "wtfk",
                        "content": "why test has Integer.MIN_VALUE!!!!\\n\\nare you crazy ?\\nare you crazy?"
                    },
                    {
                        "username": "honua",
                        "content": "that\\'s a good edge case, isn\\'t it? :D "
                    },
                    {
                        "username": "steeeevenn",
                        "content": "Hey so I run my code but one of the test case failed. However, I don\\'t the expected answer is correct. \\nThe input is [5,2,2]. The third maximun does not exist, so it should return the second maximum, which is 2. But the system is saying the expected answer is 5, which is the maximum.  Any ideas?\\n![image](https://assets.leetcode.com/users/images/77d31306-7523-465a-927c-9936842fc8e8_1619580785.8389773.png)\\n"
                    },
                    {
                        "username": "jackere1",
                        "content": "class Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        set<int> numSet(nums.begin(), nums.end());\\n\\n        set<int>::iterator itr = numSet.end();\\n\\n        cout << *itr;\\n        if(numSet.size() < 3)\\n            return *itr;\\n\\n        advance(itr, -3);\\n        return *itr;\\n    }\\n};\\n\\nI have same problem here and I tested my code 1000 times. It gives correct answer on my machine but gives 2 on this machine. What is wrong the with compiler?"
                    },
                    {
                        "username": "andresstawski",
                        "content": "If the third maximum does not exist, return the maximum number."
                    },
                    {
                        "username": "ankit_borbora",
                        "content": "The question says that if a 3rd max no. is not present, then print the maximum no. Not the second max no."
                    },
                    {
                        "username": "shreysaini1998",
                        "content": "it says in question if 3rd max does not exist, return the 1st max"
                    },
                    {
                        "username": "N8mare",
                        "content": "read the question properly,,,if 3rd max doesn\\'t exists then return the maximum number"
                    },
                    {
                        "username": "AyushThakur-7",
                        "content": " Try by adding the elements in a arraylist and removing the duplicates as you add the elements. After this you just need to transfer the elements back to an array and  apply required conditions."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thanks done\\n"
                    },
                    {
                        "username": "Geeks-Vegeta",
                        "content": "def thirdMax(self, nums: List[int]) -> int:\\n        newset=list(set(nums))\\n        lenset=len(newset)\\n        newset.sort(reverse=True)\\n        if lenset>=3:\\n            return newset[2]\\n        else:\\n            return newset[0]"
                    },
                    {
                        "username": "sathishb1139",
                        "content": "o(n log n) right\\n"
                    },
                    {
                        "username": "mustafaAlhillo",
                        "content": "for test case [1,2147483647,-2147483648], Why the expected answer is -2147483648. \nthose are two elements and it should return the Max value which is 1,2147483647"
                    },
                    {
                        "username": "pstrait",
                        "content": "Wut? that\\'s 3 elements.  Element #1 = 1.  Element #2 = 2147483647.  Element #3 = -2147483647."
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "using python 3:-\\n\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        x = sorted(set(nums),reverse=True)\\n        if len(x) < 3:\\n            return x[0]\\n        else:\\n            return x[2]"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/414_Third_Max_Num.cpp"
                    }
                ]
            },
            {
                "id": 1715635,
                "content": [
                    {
                        "username": "coldknight",
                        "content": "Isn't 3 the third maximum number of [1,2,2,5,3,5]? Why OJ gave 2?"
                    },
                    {
                        "username": "biswambar",
                        "content": "it\\'s mentioned in the question that, you have to find the third \"distinct\" maximum number.\\ndistinct(not duplicate) means unique\\nthe arr = [1,2,2,5,3,5] for distinct element will be -> arr = [1,2,3,5]  so 2 is the answer. \\n"
                    },
                    {
                        "username": "szp14",
                        "content": "For the testing case [-2147483648, 1, 2], the third maximum number is -2147483648, but the \"Run\" command of this question returns 2"
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) where is the relation with num.lenght?\\n"
                    },
                    {
                        "username": "singh_3662",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) his case has a num length of 3 which lies between 1 to 10^4"
                    },
                    {
                        "username": "darveshchauhan0001",
                        "content": "num length should be between 1 to 10^4"
                    },
                    {
                        "username": "xqcow",
                        "content": "why does this question have so many dislikes?"
                    },
                    {
                        "username": "aro",
                        "content": "\"THIRD DISTINCT NUMBER\""
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "It\\'s harder than some mediums in the same category as this one requires handling some annoying edge cases"
                    },
                    {
                        "username": "chrispeloso2",
                        "content": "The prompt is kinda confusing imo"
                    },
                    {
                        "username": "heg816",
                        "content": "The edgecases can be annoying. It\\'s not a bad prompt, but many questions with sneaky or tedious edgecases tend to get downvoted regardless of quality"
                    },
                    {
                        "username": "wtfk",
                        "content": "why test has Integer.MIN_VALUE!!!!\\n\\nare you crazy ?\\nare you crazy?"
                    },
                    {
                        "username": "honua",
                        "content": "that\\'s a good edge case, isn\\'t it? :D "
                    },
                    {
                        "username": "steeeevenn",
                        "content": "Hey so I run my code but one of the test case failed. However, I don\\'t the expected answer is correct. \\nThe input is [5,2,2]. The third maximun does not exist, so it should return the second maximum, which is 2. But the system is saying the expected answer is 5, which is the maximum.  Any ideas?\\n![image](https://assets.leetcode.com/users/images/77d31306-7523-465a-927c-9936842fc8e8_1619580785.8389773.png)\\n"
                    },
                    {
                        "username": "jackere1",
                        "content": "class Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        set<int> numSet(nums.begin(), nums.end());\\n\\n        set<int>::iterator itr = numSet.end();\\n\\n        cout << *itr;\\n        if(numSet.size() < 3)\\n            return *itr;\\n\\n        advance(itr, -3);\\n        return *itr;\\n    }\\n};\\n\\nI have same problem here and I tested my code 1000 times. It gives correct answer on my machine but gives 2 on this machine. What is wrong the with compiler?"
                    },
                    {
                        "username": "andresstawski",
                        "content": "If the third maximum does not exist, return the maximum number."
                    },
                    {
                        "username": "ankit_borbora",
                        "content": "The question says that if a 3rd max no. is not present, then print the maximum no. Not the second max no."
                    },
                    {
                        "username": "shreysaini1998",
                        "content": "it says in question if 3rd max does not exist, return the 1st max"
                    },
                    {
                        "username": "N8mare",
                        "content": "read the question properly,,,if 3rd max doesn\\'t exists then return the maximum number"
                    },
                    {
                        "username": "AyushThakur-7",
                        "content": " Try by adding the elements in a arraylist and removing the duplicates as you add the elements. After this you just need to transfer the elements back to an array and  apply required conditions."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thanks done\\n"
                    },
                    {
                        "username": "Geeks-Vegeta",
                        "content": "def thirdMax(self, nums: List[int]) -> int:\\n        newset=list(set(nums))\\n        lenset=len(newset)\\n        newset.sort(reverse=True)\\n        if lenset>=3:\\n            return newset[2]\\n        else:\\n            return newset[0]"
                    },
                    {
                        "username": "sathishb1139",
                        "content": "o(n log n) right\\n"
                    },
                    {
                        "username": "mustafaAlhillo",
                        "content": "for test case [1,2147483647,-2147483648], Why the expected answer is -2147483648. \nthose are two elements and it should return the Max value which is 1,2147483647"
                    },
                    {
                        "username": "pstrait",
                        "content": "Wut? that\\'s 3 elements.  Element #1 = 1.  Element #2 = 2147483647.  Element #3 = -2147483647."
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "using python 3:-\\n\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        x = sorted(set(nums),reverse=True)\\n        if len(x) < 3:\\n            return x[0]\\n        else:\\n            return x[2]"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/414_Third_Max_Num.cpp"
                    }
                ]
            },
            {
                "id": 1572284,
                "content": [
                    {
                        "username": "coldknight",
                        "content": "Isn't 3 the third maximum number of [1,2,2,5,3,5]? Why OJ gave 2?"
                    },
                    {
                        "username": "biswambar",
                        "content": "it\\'s mentioned in the question that, you have to find the third \"distinct\" maximum number.\\ndistinct(not duplicate) means unique\\nthe arr = [1,2,2,5,3,5] for distinct element will be -> arr = [1,2,3,5]  so 2 is the answer. \\n"
                    },
                    {
                        "username": "szp14",
                        "content": "For the testing case [-2147483648, 1, 2], the third maximum number is -2147483648, but the \"Run\" command of this question returns 2"
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) where is the relation with num.lenght?\\n"
                    },
                    {
                        "username": "singh_3662",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) his case has a num length of 3 which lies between 1 to 10^4"
                    },
                    {
                        "username": "darveshchauhan0001",
                        "content": "num length should be between 1 to 10^4"
                    },
                    {
                        "username": "xqcow",
                        "content": "why does this question have so many dislikes?"
                    },
                    {
                        "username": "aro",
                        "content": "\"THIRD DISTINCT NUMBER\""
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "It\\'s harder than some mediums in the same category as this one requires handling some annoying edge cases"
                    },
                    {
                        "username": "chrispeloso2",
                        "content": "The prompt is kinda confusing imo"
                    },
                    {
                        "username": "heg816",
                        "content": "The edgecases can be annoying. It\\'s not a bad prompt, but many questions with sneaky or tedious edgecases tend to get downvoted regardless of quality"
                    },
                    {
                        "username": "wtfk",
                        "content": "why test has Integer.MIN_VALUE!!!!\\n\\nare you crazy ?\\nare you crazy?"
                    },
                    {
                        "username": "honua",
                        "content": "that\\'s a good edge case, isn\\'t it? :D "
                    },
                    {
                        "username": "steeeevenn",
                        "content": "Hey so I run my code but one of the test case failed. However, I don\\'t the expected answer is correct. \\nThe input is [5,2,2]. The third maximun does not exist, so it should return the second maximum, which is 2. But the system is saying the expected answer is 5, which is the maximum.  Any ideas?\\n![image](https://assets.leetcode.com/users/images/77d31306-7523-465a-927c-9936842fc8e8_1619580785.8389773.png)\\n"
                    },
                    {
                        "username": "jackere1",
                        "content": "class Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        set<int> numSet(nums.begin(), nums.end());\\n\\n        set<int>::iterator itr = numSet.end();\\n\\n        cout << *itr;\\n        if(numSet.size() < 3)\\n            return *itr;\\n\\n        advance(itr, -3);\\n        return *itr;\\n    }\\n};\\n\\nI have same problem here and I tested my code 1000 times. It gives correct answer on my machine but gives 2 on this machine. What is wrong the with compiler?"
                    },
                    {
                        "username": "andresstawski",
                        "content": "If the third maximum does not exist, return the maximum number."
                    },
                    {
                        "username": "ankit_borbora",
                        "content": "The question says that if a 3rd max no. is not present, then print the maximum no. Not the second max no."
                    },
                    {
                        "username": "shreysaini1998",
                        "content": "it says in question if 3rd max does not exist, return the 1st max"
                    },
                    {
                        "username": "N8mare",
                        "content": "read the question properly,,,if 3rd max doesn\\'t exists then return the maximum number"
                    },
                    {
                        "username": "AyushThakur-7",
                        "content": " Try by adding the elements in a arraylist and removing the duplicates as you add the elements. After this you just need to transfer the elements back to an array and  apply required conditions."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thanks done\\n"
                    },
                    {
                        "username": "Geeks-Vegeta",
                        "content": "def thirdMax(self, nums: List[int]) -> int:\\n        newset=list(set(nums))\\n        lenset=len(newset)\\n        newset.sort(reverse=True)\\n        if lenset>=3:\\n            return newset[2]\\n        else:\\n            return newset[0]"
                    },
                    {
                        "username": "sathishb1139",
                        "content": "o(n log n) right\\n"
                    },
                    {
                        "username": "mustafaAlhillo",
                        "content": "for test case [1,2147483647,-2147483648], Why the expected answer is -2147483648. \nthose are two elements and it should return the Max value which is 1,2147483647"
                    },
                    {
                        "username": "pstrait",
                        "content": "Wut? that\\'s 3 elements.  Element #1 = 1.  Element #2 = 2147483647.  Element #3 = -2147483647."
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "using python 3:-\\n\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        x = sorted(set(nums),reverse=True)\\n        if len(x) < 3:\\n            return x[0]\\n        else:\\n            return x[2]"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/414_Third_Max_Num.cpp"
                    }
                ]
            },
            {
                "id": 1575195,
                "content": [
                    {
                        "username": "coldknight",
                        "content": "Isn't 3 the third maximum number of [1,2,2,5,3,5]? Why OJ gave 2?"
                    },
                    {
                        "username": "biswambar",
                        "content": "it\\'s mentioned in the question that, you have to find the third \"distinct\" maximum number.\\ndistinct(not duplicate) means unique\\nthe arr = [1,2,2,5,3,5] for distinct element will be -> arr = [1,2,3,5]  so 2 is the answer. \\n"
                    },
                    {
                        "username": "szp14",
                        "content": "For the testing case [-2147483648, 1, 2], the third maximum number is -2147483648, but the \"Run\" command of this question returns 2"
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) where is the relation with num.lenght?\\n"
                    },
                    {
                        "username": "singh_3662",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) his case has a num length of 3 which lies between 1 to 10^4"
                    },
                    {
                        "username": "darveshchauhan0001",
                        "content": "num length should be between 1 to 10^4"
                    },
                    {
                        "username": "xqcow",
                        "content": "why does this question have so many dislikes?"
                    },
                    {
                        "username": "aro",
                        "content": "\"THIRD DISTINCT NUMBER\""
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "It\\'s harder than some mediums in the same category as this one requires handling some annoying edge cases"
                    },
                    {
                        "username": "chrispeloso2",
                        "content": "The prompt is kinda confusing imo"
                    },
                    {
                        "username": "heg816",
                        "content": "The edgecases can be annoying. It\\'s not a bad prompt, but many questions with sneaky or tedious edgecases tend to get downvoted regardless of quality"
                    },
                    {
                        "username": "wtfk",
                        "content": "why test has Integer.MIN_VALUE!!!!\\n\\nare you crazy ?\\nare you crazy?"
                    },
                    {
                        "username": "honua",
                        "content": "that\\'s a good edge case, isn\\'t it? :D "
                    },
                    {
                        "username": "steeeevenn",
                        "content": "Hey so I run my code but one of the test case failed. However, I don\\'t the expected answer is correct. \\nThe input is [5,2,2]. The third maximun does not exist, so it should return the second maximum, which is 2. But the system is saying the expected answer is 5, which is the maximum.  Any ideas?\\n![image](https://assets.leetcode.com/users/images/77d31306-7523-465a-927c-9936842fc8e8_1619580785.8389773.png)\\n"
                    },
                    {
                        "username": "jackere1",
                        "content": "class Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        set<int> numSet(nums.begin(), nums.end());\\n\\n        set<int>::iterator itr = numSet.end();\\n\\n        cout << *itr;\\n        if(numSet.size() < 3)\\n            return *itr;\\n\\n        advance(itr, -3);\\n        return *itr;\\n    }\\n};\\n\\nI have same problem here and I tested my code 1000 times. It gives correct answer on my machine but gives 2 on this machine. What is wrong the with compiler?"
                    },
                    {
                        "username": "andresstawski",
                        "content": "If the third maximum does not exist, return the maximum number."
                    },
                    {
                        "username": "ankit_borbora",
                        "content": "The question says that if a 3rd max no. is not present, then print the maximum no. Not the second max no."
                    },
                    {
                        "username": "shreysaini1998",
                        "content": "it says in question if 3rd max does not exist, return the 1st max"
                    },
                    {
                        "username": "N8mare",
                        "content": "read the question properly,,,if 3rd max doesn\\'t exists then return the maximum number"
                    },
                    {
                        "username": "AyushThakur-7",
                        "content": " Try by adding the elements in a arraylist and removing the duplicates as you add the elements. After this you just need to transfer the elements back to an array and  apply required conditions."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thanks done\\n"
                    },
                    {
                        "username": "Geeks-Vegeta",
                        "content": "def thirdMax(self, nums: List[int]) -> int:\\n        newset=list(set(nums))\\n        lenset=len(newset)\\n        newset.sort(reverse=True)\\n        if lenset>=3:\\n            return newset[2]\\n        else:\\n            return newset[0]"
                    },
                    {
                        "username": "sathishb1139",
                        "content": "o(n log n) right\\n"
                    },
                    {
                        "username": "mustafaAlhillo",
                        "content": "for test case [1,2147483647,-2147483648], Why the expected answer is -2147483648. \nthose are two elements and it should return the Max value which is 1,2147483647"
                    },
                    {
                        "username": "pstrait",
                        "content": "Wut? that\\'s 3 elements.  Element #1 = 1.  Element #2 = 2147483647.  Element #3 = -2147483647."
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "using python 3:-\\n\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        x = sorted(set(nums),reverse=True)\\n        if len(x) < 3:\\n            return x[0]\\n        else:\\n            return x[2]"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/414_Third_Max_Num.cpp"
                    }
                ]
            },
            {
                "id": 1795765,
                "content": [
                    {
                        "username": "coldknight",
                        "content": "Isn't 3 the third maximum number of [1,2,2,5,3,5]? Why OJ gave 2?"
                    },
                    {
                        "username": "biswambar",
                        "content": "it\\'s mentioned in the question that, you have to find the third \"distinct\" maximum number.\\ndistinct(not duplicate) means unique\\nthe arr = [1,2,2,5,3,5] for distinct element will be -> arr = [1,2,3,5]  so 2 is the answer. \\n"
                    },
                    {
                        "username": "szp14",
                        "content": "For the testing case [-2147483648, 1, 2], the third maximum number is -2147483648, but the \"Run\" command of this question returns 2"
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) where is the relation with num.lenght?\\n"
                    },
                    {
                        "username": "singh_3662",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) his case has a num length of 3 which lies between 1 to 10^4"
                    },
                    {
                        "username": "darveshchauhan0001",
                        "content": "num length should be between 1 to 10^4"
                    },
                    {
                        "username": "xqcow",
                        "content": "why does this question have so many dislikes?"
                    },
                    {
                        "username": "aro",
                        "content": "\"THIRD DISTINCT NUMBER\""
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "It\\'s harder than some mediums in the same category as this one requires handling some annoying edge cases"
                    },
                    {
                        "username": "chrispeloso2",
                        "content": "The prompt is kinda confusing imo"
                    },
                    {
                        "username": "heg816",
                        "content": "The edgecases can be annoying. It\\'s not a bad prompt, but many questions with sneaky or tedious edgecases tend to get downvoted regardless of quality"
                    },
                    {
                        "username": "wtfk",
                        "content": "why test has Integer.MIN_VALUE!!!!\\n\\nare you crazy ?\\nare you crazy?"
                    },
                    {
                        "username": "honua",
                        "content": "that\\'s a good edge case, isn\\'t it? :D "
                    },
                    {
                        "username": "steeeevenn",
                        "content": "Hey so I run my code but one of the test case failed. However, I don\\'t the expected answer is correct. \\nThe input is [5,2,2]. The third maximun does not exist, so it should return the second maximum, which is 2. But the system is saying the expected answer is 5, which is the maximum.  Any ideas?\\n![image](https://assets.leetcode.com/users/images/77d31306-7523-465a-927c-9936842fc8e8_1619580785.8389773.png)\\n"
                    },
                    {
                        "username": "jackere1",
                        "content": "class Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        set<int> numSet(nums.begin(), nums.end());\\n\\n        set<int>::iterator itr = numSet.end();\\n\\n        cout << *itr;\\n        if(numSet.size() < 3)\\n            return *itr;\\n\\n        advance(itr, -3);\\n        return *itr;\\n    }\\n};\\n\\nI have same problem here and I tested my code 1000 times. It gives correct answer on my machine but gives 2 on this machine. What is wrong the with compiler?"
                    },
                    {
                        "username": "andresstawski",
                        "content": "If the third maximum does not exist, return the maximum number."
                    },
                    {
                        "username": "ankit_borbora",
                        "content": "The question says that if a 3rd max no. is not present, then print the maximum no. Not the second max no."
                    },
                    {
                        "username": "shreysaini1998",
                        "content": "it says in question if 3rd max does not exist, return the 1st max"
                    },
                    {
                        "username": "N8mare",
                        "content": "read the question properly,,,if 3rd max doesn\\'t exists then return the maximum number"
                    },
                    {
                        "username": "AyushThakur-7",
                        "content": " Try by adding the elements in a arraylist and removing the duplicates as you add the elements. After this you just need to transfer the elements back to an array and  apply required conditions."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thanks done\\n"
                    },
                    {
                        "username": "Geeks-Vegeta",
                        "content": "def thirdMax(self, nums: List[int]) -> int:\\n        newset=list(set(nums))\\n        lenset=len(newset)\\n        newset.sort(reverse=True)\\n        if lenset>=3:\\n            return newset[2]\\n        else:\\n            return newset[0]"
                    },
                    {
                        "username": "sathishb1139",
                        "content": "o(n log n) right\\n"
                    },
                    {
                        "username": "mustafaAlhillo",
                        "content": "for test case [1,2147483647,-2147483648], Why the expected answer is -2147483648. \nthose are two elements and it should return the Max value which is 1,2147483647"
                    },
                    {
                        "username": "pstrait",
                        "content": "Wut? that\\'s 3 elements.  Element #1 = 1.  Element #2 = 2147483647.  Element #3 = -2147483647."
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "using python 3:-\\n\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        x = sorted(set(nums),reverse=True)\\n        if len(x) < 3:\\n            return x[0]\\n        else:\\n            return x[2]"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/414_Third_Max_Num.cpp"
                    }
                ]
            },
            {
                "id": 1728986,
                "content": [
                    {
                        "username": "coldknight",
                        "content": "Isn't 3 the third maximum number of [1,2,2,5,3,5]? Why OJ gave 2?"
                    },
                    {
                        "username": "biswambar",
                        "content": "it\\'s mentioned in the question that, you have to find the third \"distinct\" maximum number.\\ndistinct(not duplicate) means unique\\nthe arr = [1,2,2,5,3,5] for distinct element will be -> arr = [1,2,3,5]  so 2 is the answer. \\n"
                    },
                    {
                        "username": "szp14",
                        "content": "For the testing case [-2147483648, 1, 2], the third maximum number is -2147483648, but the \"Run\" command of this question returns 2"
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) where is the relation with num.lenght?\\n"
                    },
                    {
                        "username": "singh_3662",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) his case has a num length of 3 which lies between 1 to 10^4"
                    },
                    {
                        "username": "darveshchauhan0001",
                        "content": "num length should be between 1 to 10^4"
                    },
                    {
                        "username": "xqcow",
                        "content": "why does this question have so many dislikes?"
                    },
                    {
                        "username": "aro",
                        "content": "\"THIRD DISTINCT NUMBER\""
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "It\\'s harder than some mediums in the same category as this one requires handling some annoying edge cases"
                    },
                    {
                        "username": "chrispeloso2",
                        "content": "The prompt is kinda confusing imo"
                    },
                    {
                        "username": "heg816",
                        "content": "The edgecases can be annoying. It\\'s not a bad prompt, but many questions with sneaky or tedious edgecases tend to get downvoted regardless of quality"
                    },
                    {
                        "username": "wtfk",
                        "content": "why test has Integer.MIN_VALUE!!!!\\n\\nare you crazy ?\\nare you crazy?"
                    },
                    {
                        "username": "honua",
                        "content": "that\\'s a good edge case, isn\\'t it? :D "
                    },
                    {
                        "username": "steeeevenn",
                        "content": "Hey so I run my code but one of the test case failed. However, I don\\'t the expected answer is correct. \\nThe input is [5,2,2]. The third maximun does not exist, so it should return the second maximum, which is 2. But the system is saying the expected answer is 5, which is the maximum.  Any ideas?\\n![image](https://assets.leetcode.com/users/images/77d31306-7523-465a-927c-9936842fc8e8_1619580785.8389773.png)\\n"
                    },
                    {
                        "username": "jackere1",
                        "content": "class Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        set<int> numSet(nums.begin(), nums.end());\\n\\n        set<int>::iterator itr = numSet.end();\\n\\n        cout << *itr;\\n        if(numSet.size() < 3)\\n            return *itr;\\n\\n        advance(itr, -3);\\n        return *itr;\\n    }\\n};\\n\\nI have same problem here and I tested my code 1000 times. It gives correct answer on my machine but gives 2 on this machine. What is wrong the with compiler?"
                    },
                    {
                        "username": "andresstawski",
                        "content": "If the third maximum does not exist, return the maximum number."
                    },
                    {
                        "username": "ankit_borbora",
                        "content": "The question says that if a 3rd max no. is not present, then print the maximum no. Not the second max no."
                    },
                    {
                        "username": "shreysaini1998",
                        "content": "it says in question if 3rd max does not exist, return the 1st max"
                    },
                    {
                        "username": "N8mare",
                        "content": "read the question properly,,,if 3rd max doesn\\'t exists then return the maximum number"
                    },
                    {
                        "username": "AyushThakur-7",
                        "content": " Try by adding the elements in a arraylist and removing the duplicates as you add the elements. After this you just need to transfer the elements back to an array and  apply required conditions."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thanks done\\n"
                    },
                    {
                        "username": "Geeks-Vegeta",
                        "content": "def thirdMax(self, nums: List[int]) -> int:\\n        newset=list(set(nums))\\n        lenset=len(newset)\\n        newset.sort(reverse=True)\\n        if lenset>=3:\\n            return newset[2]\\n        else:\\n            return newset[0]"
                    },
                    {
                        "username": "sathishb1139",
                        "content": "o(n log n) right\\n"
                    },
                    {
                        "username": "mustafaAlhillo",
                        "content": "for test case [1,2147483647,-2147483648], Why the expected answer is -2147483648. \nthose are two elements and it should return the Max value which is 1,2147483647"
                    },
                    {
                        "username": "pstrait",
                        "content": "Wut? that\\'s 3 elements.  Element #1 = 1.  Element #2 = 2147483647.  Element #3 = -2147483647."
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "using python 3:-\\n\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        x = sorted(set(nums),reverse=True)\\n        if len(x) < 3:\\n            return x[0]\\n        else:\\n            return x[2]"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/414_Third_Max_Num.cpp"
                    }
                ]
            },
            {
                "id": 1685970,
                "content": [
                    {
                        "username": "coldknight",
                        "content": "Isn't 3 the third maximum number of [1,2,2,5,3,5]? Why OJ gave 2?"
                    },
                    {
                        "username": "biswambar",
                        "content": "it\\'s mentioned in the question that, you have to find the third \"distinct\" maximum number.\\ndistinct(not duplicate) means unique\\nthe arr = [1,2,2,5,3,5] for distinct element will be -> arr = [1,2,3,5]  so 2 is the answer. \\n"
                    },
                    {
                        "username": "szp14",
                        "content": "For the testing case [-2147483648, 1, 2], the third maximum number is -2147483648, but the \"Run\" command of this question returns 2"
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) where is the relation with num.lenght?\\n"
                    },
                    {
                        "username": "singh_3662",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) his case has a num length of 3 which lies between 1 to 10^4"
                    },
                    {
                        "username": "darveshchauhan0001",
                        "content": "num length should be between 1 to 10^4"
                    },
                    {
                        "username": "xqcow",
                        "content": "why does this question have so many dislikes?"
                    },
                    {
                        "username": "aro",
                        "content": "\"THIRD DISTINCT NUMBER\""
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "It\\'s harder than some mediums in the same category as this one requires handling some annoying edge cases"
                    },
                    {
                        "username": "chrispeloso2",
                        "content": "The prompt is kinda confusing imo"
                    },
                    {
                        "username": "heg816",
                        "content": "The edgecases can be annoying. It\\'s not a bad prompt, but many questions with sneaky or tedious edgecases tend to get downvoted regardless of quality"
                    },
                    {
                        "username": "wtfk",
                        "content": "why test has Integer.MIN_VALUE!!!!\\n\\nare you crazy ?\\nare you crazy?"
                    },
                    {
                        "username": "honua",
                        "content": "that\\'s a good edge case, isn\\'t it? :D "
                    },
                    {
                        "username": "steeeevenn",
                        "content": "Hey so I run my code but one of the test case failed. However, I don\\'t the expected answer is correct. \\nThe input is [5,2,2]. The third maximun does not exist, so it should return the second maximum, which is 2. But the system is saying the expected answer is 5, which is the maximum.  Any ideas?\\n![image](https://assets.leetcode.com/users/images/77d31306-7523-465a-927c-9936842fc8e8_1619580785.8389773.png)\\n"
                    },
                    {
                        "username": "jackere1",
                        "content": "class Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        set<int> numSet(nums.begin(), nums.end());\\n\\n        set<int>::iterator itr = numSet.end();\\n\\n        cout << *itr;\\n        if(numSet.size() < 3)\\n            return *itr;\\n\\n        advance(itr, -3);\\n        return *itr;\\n    }\\n};\\n\\nI have same problem here and I tested my code 1000 times. It gives correct answer on my machine but gives 2 on this machine. What is wrong the with compiler?"
                    },
                    {
                        "username": "andresstawski",
                        "content": "If the third maximum does not exist, return the maximum number."
                    },
                    {
                        "username": "ankit_borbora",
                        "content": "The question says that if a 3rd max no. is not present, then print the maximum no. Not the second max no."
                    },
                    {
                        "username": "shreysaini1998",
                        "content": "it says in question if 3rd max does not exist, return the 1st max"
                    },
                    {
                        "username": "N8mare",
                        "content": "read the question properly,,,if 3rd max doesn\\'t exists then return the maximum number"
                    },
                    {
                        "username": "AyushThakur-7",
                        "content": " Try by adding the elements in a arraylist and removing the duplicates as you add the elements. After this you just need to transfer the elements back to an array and  apply required conditions."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thanks done\\n"
                    },
                    {
                        "username": "Geeks-Vegeta",
                        "content": "def thirdMax(self, nums: List[int]) -> int:\\n        newset=list(set(nums))\\n        lenset=len(newset)\\n        newset.sort(reverse=True)\\n        if lenset>=3:\\n            return newset[2]\\n        else:\\n            return newset[0]"
                    },
                    {
                        "username": "sathishb1139",
                        "content": "o(n log n) right\\n"
                    },
                    {
                        "username": "mustafaAlhillo",
                        "content": "for test case [1,2147483647,-2147483648], Why the expected answer is -2147483648. \nthose are two elements and it should return the Max value which is 1,2147483647"
                    },
                    {
                        "username": "pstrait",
                        "content": "Wut? that\\'s 3 elements.  Element #1 = 1.  Element #2 = 2147483647.  Element #3 = -2147483647."
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "using python 3:-\\n\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        x = sorted(set(nums),reverse=True)\\n        if len(x) < 3:\\n            return x[0]\\n        else:\\n            return x[2]"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/414_Third_Max_Num.cpp"
                    }
                ]
            },
            {
                "id": 1795815,
                "content": [
                    {
                        "username": "coldknight",
                        "content": "Isn't 3 the third maximum number of [1,2,2,5,3,5]? Why OJ gave 2?"
                    },
                    {
                        "username": "biswambar",
                        "content": "it\\'s mentioned in the question that, you have to find the third \"distinct\" maximum number.\\ndistinct(not duplicate) means unique\\nthe arr = [1,2,2,5,3,5] for distinct element will be -> arr = [1,2,3,5]  so 2 is the answer. \\n"
                    },
                    {
                        "username": "szp14",
                        "content": "For the testing case [-2147483648, 1, 2], the third maximum number is -2147483648, but the \"Run\" command of this question returns 2"
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) where is the relation with num.lenght?\\n"
                    },
                    {
                        "username": "singh_3662",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) his case has a num length of 3 which lies between 1 to 10^4"
                    },
                    {
                        "username": "darveshchauhan0001",
                        "content": "num length should be between 1 to 10^4"
                    },
                    {
                        "username": "xqcow",
                        "content": "why does this question have so many dislikes?"
                    },
                    {
                        "username": "aro",
                        "content": "\"THIRD DISTINCT NUMBER\""
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "It\\'s harder than some mediums in the same category as this one requires handling some annoying edge cases"
                    },
                    {
                        "username": "chrispeloso2",
                        "content": "The prompt is kinda confusing imo"
                    },
                    {
                        "username": "heg816",
                        "content": "The edgecases can be annoying. It\\'s not a bad prompt, but many questions with sneaky or tedious edgecases tend to get downvoted regardless of quality"
                    },
                    {
                        "username": "wtfk",
                        "content": "why test has Integer.MIN_VALUE!!!!\\n\\nare you crazy ?\\nare you crazy?"
                    },
                    {
                        "username": "honua",
                        "content": "that\\'s a good edge case, isn\\'t it? :D "
                    },
                    {
                        "username": "steeeevenn",
                        "content": "Hey so I run my code but one of the test case failed. However, I don\\'t the expected answer is correct. \\nThe input is [5,2,2]. The third maximun does not exist, so it should return the second maximum, which is 2. But the system is saying the expected answer is 5, which is the maximum.  Any ideas?\\n![image](https://assets.leetcode.com/users/images/77d31306-7523-465a-927c-9936842fc8e8_1619580785.8389773.png)\\n"
                    },
                    {
                        "username": "jackere1",
                        "content": "class Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        set<int> numSet(nums.begin(), nums.end());\\n\\n        set<int>::iterator itr = numSet.end();\\n\\n        cout << *itr;\\n        if(numSet.size() < 3)\\n            return *itr;\\n\\n        advance(itr, -3);\\n        return *itr;\\n    }\\n};\\n\\nI have same problem here and I tested my code 1000 times. It gives correct answer on my machine but gives 2 on this machine. What is wrong the with compiler?"
                    },
                    {
                        "username": "andresstawski",
                        "content": "If the third maximum does not exist, return the maximum number."
                    },
                    {
                        "username": "ankit_borbora",
                        "content": "The question says that if a 3rd max no. is not present, then print the maximum no. Not the second max no."
                    },
                    {
                        "username": "shreysaini1998",
                        "content": "it says in question if 3rd max does not exist, return the 1st max"
                    },
                    {
                        "username": "N8mare",
                        "content": "read the question properly,,,if 3rd max doesn\\'t exists then return the maximum number"
                    },
                    {
                        "username": "AyushThakur-7",
                        "content": " Try by adding the elements in a arraylist and removing the duplicates as you add the elements. After this you just need to transfer the elements back to an array and  apply required conditions."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thanks done\\n"
                    },
                    {
                        "username": "Geeks-Vegeta",
                        "content": "def thirdMax(self, nums: List[int]) -> int:\\n        newset=list(set(nums))\\n        lenset=len(newset)\\n        newset.sort(reverse=True)\\n        if lenset>=3:\\n            return newset[2]\\n        else:\\n            return newset[0]"
                    },
                    {
                        "username": "sathishb1139",
                        "content": "o(n log n) right\\n"
                    },
                    {
                        "username": "mustafaAlhillo",
                        "content": "for test case [1,2147483647,-2147483648], Why the expected answer is -2147483648. \nthose are two elements and it should return the Max value which is 1,2147483647"
                    },
                    {
                        "username": "pstrait",
                        "content": "Wut? that\\'s 3 elements.  Element #1 = 1.  Element #2 = 2147483647.  Element #3 = -2147483647."
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "using python 3:-\\n\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        x = sorted(set(nums),reverse=True)\\n        if len(x) < 3:\\n            return x[0]\\n        else:\\n            return x[2]"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/414_Third_Max_Num.cpp"
                    }
                ]
            },
            {
                "id": 1716064,
                "content": [
                    {
                        "username": "coldknight",
                        "content": "Isn't 3 the third maximum number of [1,2,2,5,3,5]? Why OJ gave 2?"
                    },
                    {
                        "username": "biswambar",
                        "content": "it\\'s mentioned in the question that, you have to find the third \"distinct\" maximum number.\\ndistinct(not duplicate) means unique\\nthe arr = [1,2,2,5,3,5] for distinct element will be -> arr = [1,2,3,5]  so 2 is the answer. \\n"
                    },
                    {
                        "username": "szp14",
                        "content": "For the testing case [-2147483648, 1, 2], the third maximum number is -2147483648, but the \"Run\" command of this question returns 2"
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) where is the relation with num.lenght?\\n"
                    },
                    {
                        "username": "singh_3662",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) his case has a num length of 3 which lies between 1 to 10^4"
                    },
                    {
                        "username": "darveshchauhan0001",
                        "content": "num length should be between 1 to 10^4"
                    },
                    {
                        "username": "xqcow",
                        "content": "why does this question have so many dislikes?"
                    },
                    {
                        "username": "aro",
                        "content": "\"THIRD DISTINCT NUMBER\""
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "It\\'s harder than some mediums in the same category as this one requires handling some annoying edge cases"
                    },
                    {
                        "username": "chrispeloso2",
                        "content": "The prompt is kinda confusing imo"
                    },
                    {
                        "username": "heg816",
                        "content": "The edgecases can be annoying. It\\'s not a bad prompt, but many questions with sneaky or tedious edgecases tend to get downvoted regardless of quality"
                    },
                    {
                        "username": "wtfk",
                        "content": "why test has Integer.MIN_VALUE!!!!\\n\\nare you crazy ?\\nare you crazy?"
                    },
                    {
                        "username": "honua",
                        "content": "that\\'s a good edge case, isn\\'t it? :D "
                    },
                    {
                        "username": "steeeevenn",
                        "content": "Hey so I run my code but one of the test case failed. However, I don\\'t the expected answer is correct. \\nThe input is [5,2,2]. The third maximun does not exist, so it should return the second maximum, which is 2. But the system is saying the expected answer is 5, which is the maximum.  Any ideas?\\n![image](https://assets.leetcode.com/users/images/77d31306-7523-465a-927c-9936842fc8e8_1619580785.8389773.png)\\n"
                    },
                    {
                        "username": "jackere1",
                        "content": "class Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        set<int> numSet(nums.begin(), nums.end());\\n\\n        set<int>::iterator itr = numSet.end();\\n\\n        cout << *itr;\\n        if(numSet.size() < 3)\\n            return *itr;\\n\\n        advance(itr, -3);\\n        return *itr;\\n    }\\n};\\n\\nI have same problem here and I tested my code 1000 times. It gives correct answer on my machine but gives 2 on this machine. What is wrong the with compiler?"
                    },
                    {
                        "username": "andresstawski",
                        "content": "If the third maximum does not exist, return the maximum number."
                    },
                    {
                        "username": "ankit_borbora",
                        "content": "The question says that if a 3rd max no. is not present, then print the maximum no. Not the second max no."
                    },
                    {
                        "username": "shreysaini1998",
                        "content": "it says in question if 3rd max does not exist, return the 1st max"
                    },
                    {
                        "username": "N8mare",
                        "content": "read the question properly,,,if 3rd max doesn\\'t exists then return the maximum number"
                    },
                    {
                        "username": "AyushThakur-7",
                        "content": " Try by adding the elements in a arraylist and removing the duplicates as you add the elements. After this you just need to transfer the elements back to an array and  apply required conditions."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thanks done\\n"
                    },
                    {
                        "username": "Geeks-Vegeta",
                        "content": "def thirdMax(self, nums: List[int]) -> int:\\n        newset=list(set(nums))\\n        lenset=len(newset)\\n        newset.sort(reverse=True)\\n        if lenset>=3:\\n            return newset[2]\\n        else:\\n            return newset[0]"
                    },
                    {
                        "username": "sathishb1139",
                        "content": "o(n log n) right\\n"
                    },
                    {
                        "username": "mustafaAlhillo",
                        "content": "for test case [1,2147483647,-2147483648], Why the expected answer is -2147483648. \nthose are two elements and it should return the Max value which is 1,2147483647"
                    },
                    {
                        "username": "pstrait",
                        "content": "Wut? that\\'s 3 elements.  Element #1 = 1.  Element #2 = 2147483647.  Element #3 = -2147483647."
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "using python 3:-\\n\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        x = sorted(set(nums),reverse=True)\\n        if len(x) < 3:\\n            return x[0]\\n        else:\\n            return x[2]"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/414_Third_Max_Num.cpp"
                    }
                ]
            },
            {
                "id": 1566790,
                "content": [
                    {
                        "username": "coldknight",
                        "content": "Isn't 3 the third maximum number of [1,2,2,5,3,5]? Why OJ gave 2?"
                    },
                    {
                        "username": "biswambar",
                        "content": "it\\'s mentioned in the question that, you have to find the third \"distinct\" maximum number.\\ndistinct(not duplicate) means unique\\nthe arr = [1,2,2,5,3,5] for distinct element will be -> arr = [1,2,3,5]  so 2 is the answer. \\n"
                    },
                    {
                        "username": "szp14",
                        "content": "For the testing case [-2147483648, 1, 2], the third maximum number is -2147483648, but the \"Run\" command of this question returns 2"
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) where is the relation with num.lenght?\\n"
                    },
                    {
                        "username": "singh_3662",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) his case has a num length of 3 which lies between 1 to 10^4"
                    },
                    {
                        "username": "darveshchauhan0001",
                        "content": "num length should be between 1 to 10^4"
                    },
                    {
                        "username": "xqcow",
                        "content": "why does this question have so many dislikes?"
                    },
                    {
                        "username": "aro",
                        "content": "\"THIRD DISTINCT NUMBER\""
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "It\\'s harder than some mediums in the same category as this one requires handling some annoying edge cases"
                    },
                    {
                        "username": "chrispeloso2",
                        "content": "The prompt is kinda confusing imo"
                    },
                    {
                        "username": "heg816",
                        "content": "The edgecases can be annoying. It\\'s not a bad prompt, but many questions with sneaky or tedious edgecases tend to get downvoted regardless of quality"
                    },
                    {
                        "username": "wtfk",
                        "content": "why test has Integer.MIN_VALUE!!!!\\n\\nare you crazy ?\\nare you crazy?"
                    },
                    {
                        "username": "honua",
                        "content": "that\\'s a good edge case, isn\\'t it? :D "
                    },
                    {
                        "username": "steeeevenn",
                        "content": "Hey so I run my code but one of the test case failed. However, I don\\'t the expected answer is correct. \\nThe input is [5,2,2]. The third maximun does not exist, so it should return the second maximum, which is 2. But the system is saying the expected answer is 5, which is the maximum.  Any ideas?\\n![image](https://assets.leetcode.com/users/images/77d31306-7523-465a-927c-9936842fc8e8_1619580785.8389773.png)\\n"
                    },
                    {
                        "username": "jackere1",
                        "content": "class Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        set<int> numSet(nums.begin(), nums.end());\\n\\n        set<int>::iterator itr = numSet.end();\\n\\n        cout << *itr;\\n        if(numSet.size() < 3)\\n            return *itr;\\n\\n        advance(itr, -3);\\n        return *itr;\\n    }\\n};\\n\\nI have same problem here and I tested my code 1000 times. It gives correct answer on my machine but gives 2 on this machine. What is wrong the with compiler?"
                    },
                    {
                        "username": "andresstawski",
                        "content": "If the third maximum does not exist, return the maximum number."
                    },
                    {
                        "username": "ankit_borbora",
                        "content": "The question says that if a 3rd max no. is not present, then print the maximum no. Not the second max no."
                    },
                    {
                        "username": "shreysaini1998",
                        "content": "it says in question if 3rd max does not exist, return the 1st max"
                    },
                    {
                        "username": "N8mare",
                        "content": "read the question properly,,,if 3rd max doesn\\'t exists then return the maximum number"
                    },
                    {
                        "username": "AyushThakur-7",
                        "content": " Try by adding the elements in a arraylist and removing the duplicates as you add the elements. After this you just need to transfer the elements back to an array and  apply required conditions."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thanks done\\n"
                    },
                    {
                        "username": "Geeks-Vegeta",
                        "content": "def thirdMax(self, nums: List[int]) -> int:\\n        newset=list(set(nums))\\n        lenset=len(newset)\\n        newset.sort(reverse=True)\\n        if lenset>=3:\\n            return newset[2]\\n        else:\\n            return newset[0]"
                    },
                    {
                        "username": "sathishb1139",
                        "content": "o(n log n) right\\n"
                    },
                    {
                        "username": "mustafaAlhillo",
                        "content": "for test case [1,2147483647,-2147483648], Why the expected answer is -2147483648. \nthose are two elements and it should return the Max value which is 1,2147483647"
                    },
                    {
                        "username": "pstrait",
                        "content": "Wut? that\\'s 3 elements.  Element #1 = 1.  Element #2 = 2147483647.  Element #3 = -2147483647."
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "using python 3:-\\n\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        x = sorted(set(nums),reverse=True)\\n        if len(x) < 3:\\n            return x[0]\\n        else:\\n            return x[2]"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/414_Third_Max_Num.cpp"
                    }
                ]
            },
            {
                "id": 1565163,
                "content": [
                    {
                        "username": "coldknight",
                        "content": "Isn't 3 the third maximum number of [1,2,2,5,3,5]? Why OJ gave 2?"
                    },
                    {
                        "username": "biswambar",
                        "content": "it\\'s mentioned in the question that, you have to find the third \"distinct\" maximum number.\\ndistinct(not duplicate) means unique\\nthe arr = [1,2,2,5,3,5] for distinct element will be -> arr = [1,2,3,5]  so 2 is the answer. \\n"
                    },
                    {
                        "username": "szp14",
                        "content": "For the testing case [-2147483648, 1, 2], the third maximum number is -2147483648, but the \"Run\" command of this question returns 2"
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) where is the relation with num.lenght?\\n"
                    },
                    {
                        "username": "singh_3662",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) his case has a num length of 3 which lies between 1 to 10^4"
                    },
                    {
                        "username": "darveshchauhan0001",
                        "content": "num length should be between 1 to 10^4"
                    },
                    {
                        "username": "xqcow",
                        "content": "why does this question have so many dislikes?"
                    },
                    {
                        "username": "aro",
                        "content": "\"THIRD DISTINCT NUMBER\""
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "It\\'s harder than some mediums in the same category as this one requires handling some annoying edge cases"
                    },
                    {
                        "username": "chrispeloso2",
                        "content": "The prompt is kinda confusing imo"
                    },
                    {
                        "username": "heg816",
                        "content": "The edgecases can be annoying. It\\'s not a bad prompt, but many questions with sneaky or tedious edgecases tend to get downvoted regardless of quality"
                    },
                    {
                        "username": "wtfk",
                        "content": "why test has Integer.MIN_VALUE!!!!\\n\\nare you crazy ?\\nare you crazy?"
                    },
                    {
                        "username": "honua",
                        "content": "that\\'s a good edge case, isn\\'t it? :D "
                    },
                    {
                        "username": "steeeevenn",
                        "content": "Hey so I run my code but one of the test case failed. However, I don\\'t the expected answer is correct. \\nThe input is [5,2,2]. The third maximun does not exist, so it should return the second maximum, which is 2. But the system is saying the expected answer is 5, which is the maximum.  Any ideas?\\n![image](https://assets.leetcode.com/users/images/77d31306-7523-465a-927c-9936842fc8e8_1619580785.8389773.png)\\n"
                    },
                    {
                        "username": "jackere1",
                        "content": "class Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        set<int> numSet(nums.begin(), nums.end());\\n\\n        set<int>::iterator itr = numSet.end();\\n\\n        cout << *itr;\\n        if(numSet.size() < 3)\\n            return *itr;\\n\\n        advance(itr, -3);\\n        return *itr;\\n    }\\n};\\n\\nI have same problem here and I tested my code 1000 times. It gives correct answer on my machine but gives 2 on this machine. What is wrong the with compiler?"
                    },
                    {
                        "username": "andresstawski",
                        "content": "If the third maximum does not exist, return the maximum number."
                    },
                    {
                        "username": "ankit_borbora",
                        "content": "The question says that if a 3rd max no. is not present, then print the maximum no. Not the second max no."
                    },
                    {
                        "username": "shreysaini1998",
                        "content": "it says in question if 3rd max does not exist, return the 1st max"
                    },
                    {
                        "username": "N8mare",
                        "content": "read the question properly,,,if 3rd max doesn\\'t exists then return the maximum number"
                    },
                    {
                        "username": "AyushThakur-7",
                        "content": " Try by adding the elements in a arraylist and removing the duplicates as you add the elements. After this you just need to transfer the elements back to an array and  apply required conditions."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thanks done\\n"
                    },
                    {
                        "username": "Geeks-Vegeta",
                        "content": "def thirdMax(self, nums: List[int]) -> int:\\n        newset=list(set(nums))\\n        lenset=len(newset)\\n        newset.sort(reverse=True)\\n        if lenset>=3:\\n            return newset[2]\\n        else:\\n            return newset[0]"
                    },
                    {
                        "username": "sathishb1139",
                        "content": "o(n log n) right\\n"
                    },
                    {
                        "username": "mustafaAlhillo",
                        "content": "for test case [1,2147483647,-2147483648], Why the expected answer is -2147483648. \nthose are two elements and it should return the Max value which is 1,2147483647"
                    },
                    {
                        "username": "pstrait",
                        "content": "Wut? that\\'s 3 elements.  Element #1 = 1.  Element #2 = 2147483647.  Element #3 = -2147483647."
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "using python 3:-\\n\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        x = sorted(set(nums),reverse=True)\\n        if len(x) < 3:\\n            return x[0]\\n        else:\\n            return x[2]"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/414_Third_Max_Num.cpp"
                    }
                ]
            },
            {
                "id": 1715635,
                "content": [
                    {
                        "username": "coldknight",
                        "content": "Isn't 3 the third maximum number of [1,2,2,5,3,5]? Why OJ gave 2?"
                    },
                    {
                        "username": "biswambar",
                        "content": "it\\'s mentioned in the question that, you have to find the third \"distinct\" maximum number.\\ndistinct(not duplicate) means unique\\nthe arr = [1,2,2,5,3,5] for distinct element will be -> arr = [1,2,3,5]  so 2 is the answer. \\n"
                    },
                    {
                        "username": "szp14",
                        "content": "For the testing case [-2147483648, 1, 2], the third maximum number is -2147483648, but the \"Run\" command of this question returns 2"
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) where is the relation with num.lenght?\\n"
                    },
                    {
                        "username": "singh_3662",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) his case has a num length of 3 which lies between 1 to 10^4"
                    },
                    {
                        "username": "darveshchauhan0001",
                        "content": "num length should be between 1 to 10^4"
                    },
                    {
                        "username": "xqcow",
                        "content": "why does this question have so many dislikes?"
                    },
                    {
                        "username": "aro",
                        "content": "\"THIRD DISTINCT NUMBER\""
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "It\\'s harder than some mediums in the same category as this one requires handling some annoying edge cases"
                    },
                    {
                        "username": "chrispeloso2",
                        "content": "The prompt is kinda confusing imo"
                    },
                    {
                        "username": "heg816",
                        "content": "The edgecases can be annoying. It\\'s not a bad prompt, but many questions with sneaky or tedious edgecases tend to get downvoted regardless of quality"
                    },
                    {
                        "username": "wtfk",
                        "content": "why test has Integer.MIN_VALUE!!!!\\n\\nare you crazy ?\\nare you crazy?"
                    },
                    {
                        "username": "honua",
                        "content": "that\\'s a good edge case, isn\\'t it? :D "
                    },
                    {
                        "username": "steeeevenn",
                        "content": "Hey so I run my code but one of the test case failed. However, I don\\'t the expected answer is correct. \\nThe input is [5,2,2]. The third maximun does not exist, so it should return the second maximum, which is 2. But the system is saying the expected answer is 5, which is the maximum.  Any ideas?\\n![image](https://assets.leetcode.com/users/images/77d31306-7523-465a-927c-9936842fc8e8_1619580785.8389773.png)\\n"
                    },
                    {
                        "username": "jackere1",
                        "content": "class Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        set<int> numSet(nums.begin(), nums.end());\\n\\n        set<int>::iterator itr = numSet.end();\\n\\n        cout << *itr;\\n        if(numSet.size() < 3)\\n            return *itr;\\n\\n        advance(itr, -3);\\n        return *itr;\\n    }\\n};\\n\\nI have same problem here and I tested my code 1000 times. It gives correct answer on my machine but gives 2 on this machine. What is wrong the with compiler?"
                    },
                    {
                        "username": "andresstawski",
                        "content": "If the third maximum does not exist, return the maximum number."
                    },
                    {
                        "username": "ankit_borbora",
                        "content": "The question says that if a 3rd max no. is not present, then print the maximum no. Not the second max no."
                    },
                    {
                        "username": "shreysaini1998",
                        "content": "it says in question if 3rd max does not exist, return the 1st max"
                    },
                    {
                        "username": "N8mare",
                        "content": "read the question properly,,,if 3rd max doesn\\'t exists then return the maximum number"
                    },
                    {
                        "username": "AyushThakur-7",
                        "content": " Try by adding the elements in a arraylist and removing the duplicates as you add the elements. After this you just need to transfer the elements back to an array and  apply required conditions."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thanks done\\n"
                    },
                    {
                        "username": "Geeks-Vegeta",
                        "content": "def thirdMax(self, nums: List[int]) -> int:\\n        newset=list(set(nums))\\n        lenset=len(newset)\\n        newset.sort(reverse=True)\\n        if lenset>=3:\\n            return newset[2]\\n        else:\\n            return newset[0]"
                    },
                    {
                        "username": "sathishb1139",
                        "content": "o(n log n) right\\n"
                    },
                    {
                        "username": "mustafaAlhillo",
                        "content": "for test case [1,2147483647,-2147483648], Why the expected answer is -2147483648. \nthose are two elements and it should return the Max value which is 1,2147483647"
                    },
                    {
                        "username": "pstrait",
                        "content": "Wut? that\\'s 3 elements.  Element #1 = 1.  Element #2 = 2147483647.  Element #3 = -2147483647."
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "using python 3:-\\n\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        x = sorted(set(nums),reverse=True)\\n        if len(x) < 3:\\n            return x[0]\\n        else:\\n            return x[2]"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/414_Third_Max_Num.cpp"
                    }
                ]
            },
            {
                "id": 1572284,
                "content": [
                    {
                        "username": "coldknight",
                        "content": "Isn't 3 the third maximum number of [1,2,2,5,3,5]? Why OJ gave 2?"
                    },
                    {
                        "username": "biswambar",
                        "content": "it\\'s mentioned in the question that, you have to find the third \"distinct\" maximum number.\\ndistinct(not duplicate) means unique\\nthe arr = [1,2,2,5,3,5] for distinct element will be -> arr = [1,2,3,5]  so 2 is the answer. \\n"
                    },
                    {
                        "username": "szp14",
                        "content": "For the testing case [-2147483648, 1, 2], the third maximum number is -2147483648, but the \"Run\" command of this question returns 2"
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) where is the relation with num.lenght?\\n"
                    },
                    {
                        "username": "singh_3662",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) his case has a num length of 3 which lies between 1 to 10^4"
                    },
                    {
                        "username": "darveshchauhan0001",
                        "content": "num length should be between 1 to 10^4"
                    },
                    {
                        "username": "xqcow",
                        "content": "why does this question have so many dislikes?"
                    },
                    {
                        "username": "aro",
                        "content": "\"THIRD DISTINCT NUMBER\""
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "It\\'s harder than some mediums in the same category as this one requires handling some annoying edge cases"
                    },
                    {
                        "username": "chrispeloso2",
                        "content": "The prompt is kinda confusing imo"
                    },
                    {
                        "username": "heg816",
                        "content": "The edgecases can be annoying. It\\'s not a bad prompt, but many questions with sneaky or tedious edgecases tend to get downvoted regardless of quality"
                    },
                    {
                        "username": "wtfk",
                        "content": "why test has Integer.MIN_VALUE!!!!\\n\\nare you crazy ?\\nare you crazy?"
                    },
                    {
                        "username": "honua",
                        "content": "that\\'s a good edge case, isn\\'t it? :D "
                    },
                    {
                        "username": "steeeevenn",
                        "content": "Hey so I run my code but one of the test case failed. However, I don\\'t the expected answer is correct. \\nThe input is [5,2,2]. The third maximun does not exist, so it should return the second maximum, which is 2. But the system is saying the expected answer is 5, which is the maximum.  Any ideas?\\n![image](https://assets.leetcode.com/users/images/77d31306-7523-465a-927c-9936842fc8e8_1619580785.8389773.png)\\n"
                    },
                    {
                        "username": "jackere1",
                        "content": "class Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        set<int> numSet(nums.begin(), nums.end());\\n\\n        set<int>::iterator itr = numSet.end();\\n\\n        cout << *itr;\\n        if(numSet.size() < 3)\\n            return *itr;\\n\\n        advance(itr, -3);\\n        return *itr;\\n    }\\n};\\n\\nI have same problem here and I tested my code 1000 times. It gives correct answer on my machine but gives 2 on this machine. What is wrong the with compiler?"
                    },
                    {
                        "username": "andresstawski",
                        "content": "If the third maximum does not exist, return the maximum number."
                    },
                    {
                        "username": "ankit_borbora",
                        "content": "The question says that if a 3rd max no. is not present, then print the maximum no. Not the second max no."
                    },
                    {
                        "username": "shreysaini1998",
                        "content": "it says in question if 3rd max does not exist, return the 1st max"
                    },
                    {
                        "username": "N8mare",
                        "content": "read the question properly,,,if 3rd max doesn\\'t exists then return the maximum number"
                    },
                    {
                        "username": "AyushThakur-7",
                        "content": " Try by adding the elements in a arraylist and removing the duplicates as you add the elements. After this you just need to transfer the elements back to an array and  apply required conditions."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thanks done\\n"
                    },
                    {
                        "username": "Geeks-Vegeta",
                        "content": "def thirdMax(self, nums: List[int]) -> int:\\n        newset=list(set(nums))\\n        lenset=len(newset)\\n        newset.sort(reverse=True)\\n        if lenset>=3:\\n            return newset[2]\\n        else:\\n            return newset[0]"
                    },
                    {
                        "username": "sathishb1139",
                        "content": "o(n log n) right\\n"
                    },
                    {
                        "username": "mustafaAlhillo",
                        "content": "for test case [1,2147483647,-2147483648], Why the expected answer is -2147483648. \nthose are two elements and it should return the Max value which is 1,2147483647"
                    },
                    {
                        "username": "pstrait",
                        "content": "Wut? that\\'s 3 elements.  Element #1 = 1.  Element #2 = 2147483647.  Element #3 = -2147483647."
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "using python 3:-\\n\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        x = sorted(set(nums),reverse=True)\\n        if len(x) < 3:\\n            return x[0]\\n        else:\\n            return x[2]"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/414_Third_Max_Num.cpp"
                    }
                ]
            },
            {
                "id": 1575195,
                "content": [
                    {
                        "username": "coldknight",
                        "content": "Isn't 3 the third maximum number of [1,2,2,5,3,5]? Why OJ gave 2?"
                    },
                    {
                        "username": "biswambar",
                        "content": "it\\'s mentioned in the question that, you have to find the third \"distinct\" maximum number.\\ndistinct(not duplicate) means unique\\nthe arr = [1,2,2,5,3,5] for distinct element will be -> arr = [1,2,3,5]  so 2 is the answer. \\n"
                    },
                    {
                        "username": "szp14",
                        "content": "For the testing case [-2147483648, 1, 2], the third maximum number is -2147483648, but the \"Run\" command of this question returns 2"
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) where is the relation with num.lenght?\\n"
                    },
                    {
                        "username": "singh_3662",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) his case has a num length of 3 which lies between 1 to 10^4"
                    },
                    {
                        "username": "darveshchauhan0001",
                        "content": "num length should be between 1 to 10^4"
                    },
                    {
                        "username": "xqcow",
                        "content": "why does this question have so many dislikes?"
                    },
                    {
                        "username": "aro",
                        "content": "\"THIRD DISTINCT NUMBER\""
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "It\\'s harder than some mediums in the same category as this one requires handling some annoying edge cases"
                    },
                    {
                        "username": "chrispeloso2",
                        "content": "The prompt is kinda confusing imo"
                    },
                    {
                        "username": "heg816",
                        "content": "The edgecases can be annoying. It\\'s not a bad prompt, but many questions with sneaky or tedious edgecases tend to get downvoted regardless of quality"
                    },
                    {
                        "username": "wtfk",
                        "content": "why test has Integer.MIN_VALUE!!!!\\n\\nare you crazy ?\\nare you crazy?"
                    },
                    {
                        "username": "honua",
                        "content": "that\\'s a good edge case, isn\\'t it? :D "
                    },
                    {
                        "username": "steeeevenn",
                        "content": "Hey so I run my code but one of the test case failed. However, I don\\'t the expected answer is correct. \\nThe input is [5,2,2]. The third maximun does not exist, so it should return the second maximum, which is 2. But the system is saying the expected answer is 5, which is the maximum.  Any ideas?\\n![image](https://assets.leetcode.com/users/images/77d31306-7523-465a-927c-9936842fc8e8_1619580785.8389773.png)\\n"
                    },
                    {
                        "username": "jackere1",
                        "content": "class Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        set<int> numSet(nums.begin(), nums.end());\\n\\n        set<int>::iterator itr = numSet.end();\\n\\n        cout << *itr;\\n        if(numSet.size() < 3)\\n            return *itr;\\n\\n        advance(itr, -3);\\n        return *itr;\\n    }\\n};\\n\\nI have same problem here and I tested my code 1000 times. It gives correct answer on my machine but gives 2 on this machine. What is wrong the with compiler?"
                    },
                    {
                        "username": "andresstawski",
                        "content": "If the third maximum does not exist, return the maximum number."
                    },
                    {
                        "username": "ankit_borbora",
                        "content": "The question says that if a 3rd max no. is not present, then print the maximum no. Not the second max no."
                    },
                    {
                        "username": "shreysaini1998",
                        "content": "it says in question if 3rd max does not exist, return the 1st max"
                    },
                    {
                        "username": "N8mare",
                        "content": "read the question properly,,,if 3rd max doesn\\'t exists then return the maximum number"
                    },
                    {
                        "username": "AyushThakur-7",
                        "content": " Try by adding the elements in a arraylist and removing the duplicates as you add the elements. After this you just need to transfer the elements back to an array and  apply required conditions."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thanks done\\n"
                    },
                    {
                        "username": "Geeks-Vegeta",
                        "content": "def thirdMax(self, nums: List[int]) -> int:\\n        newset=list(set(nums))\\n        lenset=len(newset)\\n        newset.sort(reverse=True)\\n        if lenset>=3:\\n            return newset[2]\\n        else:\\n            return newset[0]"
                    },
                    {
                        "username": "sathishb1139",
                        "content": "o(n log n) right\\n"
                    },
                    {
                        "username": "mustafaAlhillo",
                        "content": "for test case [1,2147483647,-2147483648], Why the expected answer is -2147483648. \nthose are two elements and it should return the Max value which is 1,2147483647"
                    },
                    {
                        "username": "pstrait",
                        "content": "Wut? that\\'s 3 elements.  Element #1 = 1.  Element #2 = 2147483647.  Element #3 = -2147483647."
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "using python 3:-\\n\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        x = sorted(set(nums),reverse=True)\\n        if len(x) < 3:\\n            return x[0]\\n        else:\\n            return x[2]"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/414_Third_Max_Num.cpp"
                    }
                ]
            },
            {
                "id": 1795765,
                "content": [
                    {
                        "username": "coldknight",
                        "content": "Isn't 3 the third maximum number of [1,2,2,5,3,5]? Why OJ gave 2?"
                    },
                    {
                        "username": "biswambar",
                        "content": "it\\'s mentioned in the question that, you have to find the third \"distinct\" maximum number.\\ndistinct(not duplicate) means unique\\nthe arr = [1,2,2,5,3,5] for distinct element will be -> arr = [1,2,3,5]  so 2 is the answer. \\n"
                    },
                    {
                        "username": "szp14",
                        "content": "For the testing case [-2147483648, 1, 2], the third maximum number is -2147483648, but the \"Run\" command of this question returns 2"
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) where is the relation with num.lenght?\\n"
                    },
                    {
                        "username": "singh_3662",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) his case has a num length of 3 which lies between 1 to 10^4"
                    },
                    {
                        "username": "darveshchauhan0001",
                        "content": "num length should be between 1 to 10^4"
                    },
                    {
                        "username": "xqcow",
                        "content": "why does this question have so many dislikes?"
                    },
                    {
                        "username": "aro",
                        "content": "\"THIRD DISTINCT NUMBER\""
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "It\\'s harder than some mediums in the same category as this one requires handling some annoying edge cases"
                    },
                    {
                        "username": "chrispeloso2",
                        "content": "The prompt is kinda confusing imo"
                    },
                    {
                        "username": "heg816",
                        "content": "The edgecases can be annoying. It\\'s not a bad prompt, but many questions with sneaky or tedious edgecases tend to get downvoted regardless of quality"
                    },
                    {
                        "username": "wtfk",
                        "content": "why test has Integer.MIN_VALUE!!!!\\n\\nare you crazy ?\\nare you crazy?"
                    },
                    {
                        "username": "honua",
                        "content": "that\\'s a good edge case, isn\\'t it? :D "
                    },
                    {
                        "username": "steeeevenn",
                        "content": "Hey so I run my code but one of the test case failed. However, I don\\'t the expected answer is correct. \\nThe input is [5,2,2]. The third maximun does not exist, so it should return the second maximum, which is 2. But the system is saying the expected answer is 5, which is the maximum.  Any ideas?\\n![image](https://assets.leetcode.com/users/images/77d31306-7523-465a-927c-9936842fc8e8_1619580785.8389773.png)\\n"
                    },
                    {
                        "username": "jackere1",
                        "content": "class Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        set<int> numSet(nums.begin(), nums.end());\\n\\n        set<int>::iterator itr = numSet.end();\\n\\n        cout << *itr;\\n        if(numSet.size() < 3)\\n            return *itr;\\n\\n        advance(itr, -3);\\n        return *itr;\\n    }\\n};\\n\\nI have same problem here and I tested my code 1000 times. It gives correct answer on my machine but gives 2 on this machine. What is wrong the with compiler?"
                    },
                    {
                        "username": "andresstawski",
                        "content": "If the third maximum does not exist, return the maximum number."
                    },
                    {
                        "username": "ankit_borbora",
                        "content": "The question says that if a 3rd max no. is not present, then print the maximum no. Not the second max no."
                    },
                    {
                        "username": "shreysaini1998",
                        "content": "it says in question if 3rd max does not exist, return the 1st max"
                    },
                    {
                        "username": "N8mare",
                        "content": "read the question properly,,,if 3rd max doesn\\'t exists then return the maximum number"
                    },
                    {
                        "username": "AyushThakur-7",
                        "content": " Try by adding the elements in a arraylist and removing the duplicates as you add the elements. After this you just need to transfer the elements back to an array and  apply required conditions."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thanks done\\n"
                    },
                    {
                        "username": "Geeks-Vegeta",
                        "content": "def thirdMax(self, nums: List[int]) -> int:\\n        newset=list(set(nums))\\n        lenset=len(newset)\\n        newset.sort(reverse=True)\\n        if lenset>=3:\\n            return newset[2]\\n        else:\\n            return newset[0]"
                    },
                    {
                        "username": "sathishb1139",
                        "content": "o(n log n) right\\n"
                    },
                    {
                        "username": "mustafaAlhillo",
                        "content": "for test case [1,2147483647,-2147483648], Why the expected answer is -2147483648. \nthose are two elements and it should return the Max value which is 1,2147483647"
                    },
                    {
                        "username": "pstrait",
                        "content": "Wut? that\\'s 3 elements.  Element #1 = 1.  Element #2 = 2147483647.  Element #3 = -2147483647."
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "using python 3:-\\n\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        x = sorted(set(nums),reverse=True)\\n        if len(x) < 3:\\n            return x[0]\\n        else:\\n            return x[2]"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/414_Third_Max_Num.cpp"
                    }
                ]
            },
            {
                "id": 1728986,
                "content": [
                    {
                        "username": "coldknight",
                        "content": "Isn't 3 the third maximum number of [1,2,2,5,3,5]? Why OJ gave 2?"
                    },
                    {
                        "username": "biswambar",
                        "content": "it\\'s mentioned in the question that, you have to find the third \"distinct\" maximum number.\\ndistinct(not duplicate) means unique\\nthe arr = [1,2,2,5,3,5] for distinct element will be -> arr = [1,2,3,5]  so 2 is the answer. \\n"
                    },
                    {
                        "username": "szp14",
                        "content": "For the testing case [-2147483648, 1, 2], the third maximum number is -2147483648, but the \"Run\" command of this question returns 2"
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) where is the relation with num.lenght?\\n"
                    },
                    {
                        "username": "singh_3662",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) his case has a num length of 3 which lies between 1 to 10^4"
                    },
                    {
                        "username": "darveshchauhan0001",
                        "content": "num length should be between 1 to 10^4"
                    },
                    {
                        "username": "xqcow",
                        "content": "why does this question have so many dislikes?"
                    },
                    {
                        "username": "aro",
                        "content": "\"THIRD DISTINCT NUMBER\""
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "It\\'s harder than some mediums in the same category as this one requires handling some annoying edge cases"
                    },
                    {
                        "username": "chrispeloso2",
                        "content": "The prompt is kinda confusing imo"
                    },
                    {
                        "username": "heg816",
                        "content": "The edgecases can be annoying. It\\'s not a bad prompt, but many questions with sneaky or tedious edgecases tend to get downvoted regardless of quality"
                    },
                    {
                        "username": "wtfk",
                        "content": "why test has Integer.MIN_VALUE!!!!\\n\\nare you crazy ?\\nare you crazy?"
                    },
                    {
                        "username": "honua",
                        "content": "that\\'s a good edge case, isn\\'t it? :D "
                    },
                    {
                        "username": "steeeevenn",
                        "content": "Hey so I run my code but one of the test case failed. However, I don\\'t the expected answer is correct. \\nThe input is [5,2,2]. The third maximun does not exist, so it should return the second maximum, which is 2. But the system is saying the expected answer is 5, which is the maximum.  Any ideas?\\n![image](https://assets.leetcode.com/users/images/77d31306-7523-465a-927c-9936842fc8e8_1619580785.8389773.png)\\n"
                    },
                    {
                        "username": "jackere1",
                        "content": "class Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        set<int> numSet(nums.begin(), nums.end());\\n\\n        set<int>::iterator itr = numSet.end();\\n\\n        cout << *itr;\\n        if(numSet.size() < 3)\\n            return *itr;\\n\\n        advance(itr, -3);\\n        return *itr;\\n    }\\n};\\n\\nI have same problem here and I tested my code 1000 times. It gives correct answer on my machine but gives 2 on this machine. What is wrong the with compiler?"
                    },
                    {
                        "username": "andresstawski",
                        "content": "If the third maximum does not exist, return the maximum number."
                    },
                    {
                        "username": "ankit_borbora",
                        "content": "The question says that if a 3rd max no. is not present, then print the maximum no. Not the second max no."
                    },
                    {
                        "username": "shreysaini1998",
                        "content": "it says in question if 3rd max does not exist, return the 1st max"
                    },
                    {
                        "username": "N8mare",
                        "content": "read the question properly,,,if 3rd max doesn\\'t exists then return the maximum number"
                    },
                    {
                        "username": "AyushThakur-7",
                        "content": " Try by adding the elements in a arraylist and removing the duplicates as you add the elements. After this you just need to transfer the elements back to an array and  apply required conditions."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thanks done\\n"
                    },
                    {
                        "username": "Geeks-Vegeta",
                        "content": "def thirdMax(self, nums: List[int]) -> int:\\n        newset=list(set(nums))\\n        lenset=len(newset)\\n        newset.sort(reverse=True)\\n        if lenset>=3:\\n            return newset[2]\\n        else:\\n            return newset[0]"
                    },
                    {
                        "username": "sathishb1139",
                        "content": "o(n log n) right\\n"
                    },
                    {
                        "username": "mustafaAlhillo",
                        "content": "for test case [1,2147483647,-2147483648], Why the expected answer is -2147483648. \nthose are two elements and it should return the Max value which is 1,2147483647"
                    },
                    {
                        "username": "pstrait",
                        "content": "Wut? that\\'s 3 elements.  Element #1 = 1.  Element #2 = 2147483647.  Element #3 = -2147483647."
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "using python 3:-\\n\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        x = sorted(set(nums),reverse=True)\\n        if len(x) < 3:\\n            return x[0]\\n        else:\\n            return x[2]"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/414_Third_Max_Num.cpp"
                    }
                ]
            },
            {
                "id": 1685970,
                "content": [
                    {
                        "username": "coldknight",
                        "content": "Isn't 3 the third maximum number of [1,2,2,5,3,5]? Why OJ gave 2?"
                    },
                    {
                        "username": "biswambar",
                        "content": "it\\'s mentioned in the question that, you have to find the third \"distinct\" maximum number.\\ndistinct(not duplicate) means unique\\nthe arr = [1,2,2,5,3,5] for distinct element will be -> arr = [1,2,3,5]  so 2 is the answer. \\n"
                    },
                    {
                        "username": "szp14",
                        "content": "For the testing case [-2147483648, 1, 2], the third maximum number is -2147483648, but the \"Run\" command of this question returns 2"
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) where is the relation with num.lenght?\\n"
                    },
                    {
                        "username": "singh_3662",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) his case has a num length of 3 which lies between 1 to 10^4"
                    },
                    {
                        "username": "darveshchauhan0001",
                        "content": "num length should be between 1 to 10^4"
                    },
                    {
                        "username": "xqcow",
                        "content": "why does this question have so many dislikes?"
                    },
                    {
                        "username": "aro",
                        "content": "\"THIRD DISTINCT NUMBER\""
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "It\\'s harder than some mediums in the same category as this one requires handling some annoying edge cases"
                    },
                    {
                        "username": "chrispeloso2",
                        "content": "The prompt is kinda confusing imo"
                    },
                    {
                        "username": "heg816",
                        "content": "The edgecases can be annoying. It\\'s not a bad prompt, but many questions with sneaky or tedious edgecases tend to get downvoted regardless of quality"
                    },
                    {
                        "username": "wtfk",
                        "content": "why test has Integer.MIN_VALUE!!!!\\n\\nare you crazy ?\\nare you crazy?"
                    },
                    {
                        "username": "honua",
                        "content": "that\\'s a good edge case, isn\\'t it? :D "
                    },
                    {
                        "username": "steeeevenn",
                        "content": "Hey so I run my code but one of the test case failed. However, I don\\'t the expected answer is correct. \\nThe input is [5,2,2]. The third maximun does not exist, so it should return the second maximum, which is 2. But the system is saying the expected answer is 5, which is the maximum.  Any ideas?\\n![image](https://assets.leetcode.com/users/images/77d31306-7523-465a-927c-9936842fc8e8_1619580785.8389773.png)\\n"
                    },
                    {
                        "username": "jackere1",
                        "content": "class Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        set<int> numSet(nums.begin(), nums.end());\\n\\n        set<int>::iterator itr = numSet.end();\\n\\n        cout << *itr;\\n        if(numSet.size() < 3)\\n            return *itr;\\n\\n        advance(itr, -3);\\n        return *itr;\\n    }\\n};\\n\\nI have same problem here and I tested my code 1000 times. It gives correct answer on my machine but gives 2 on this machine. What is wrong the with compiler?"
                    },
                    {
                        "username": "andresstawski",
                        "content": "If the third maximum does not exist, return the maximum number."
                    },
                    {
                        "username": "ankit_borbora",
                        "content": "The question says that if a 3rd max no. is not present, then print the maximum no. Not the second max no."
                    },
                    {
                        "username": "shreysaini1998",
                        "content": "it says in question if 3rd max does not exist, return the 1st max"
                    },
                    {
                        "username": "N8mare",
                        "content": "read the question properly,,,if 3rd max doesn\\'t exists then return the maximum number"
                    },
                    {
                        "username": "AyushThakur-7",
                        "content": " Try by adding the elements in a arraylist and removing the duplicates as you add the elements. After this you just need to transfer the elements back to an array and  apply required conditions."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thanks done\\n"
                    },
                    {
                        "username": "Geeks-Vegeta",
                        "content": "def thirdMax(self, nums: List[int]) -> int:\\n        newset=list(set(nums))\\n        lenset=len(newset)\\n        newset.sort(reverse=True)\\n        if lenset>=3:\\n            return newset[2]\\n        else:\\n            return newset[0]"
                    },
                    {
                        "username": "sathishb1139",
                        "content": "o(n log n) right\\n"
                    },
                    {
                        "username": "mustafaAlhillo",
                        "content": "for test case [1,2147483647,-2147483648], Why the expected answer is -2147483648. \nthose are two elements and it should return the Max value which is 1,2147483647"
                    },
                    {
                        "username": "pstrait",
                        "content": "Wut? that\\'s 3 elements.  Element #1 = 1.  Element #2 = 2147483647.  Element #3 = -2147483647."
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "using python 3:-\\n\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        x = sorted(set(nums),reverse=True)\\n        if len(x) < 3:\\n            return x[0]\\n        else:\\n            return x[2]"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/414_Third_Max_Num.cpp"
                    }
                ]
            },
            {
                "id": 1795815,
                "content": [
                    {
                        "username": "coldknight",
                        "content": "Isn't 3 the third maximum number of [1,2,2,5,3,5]? Why OJ gave 2?"
                    },
                    {
                        "username": "biswambar",
                        "content": "it\\'s mentioned in the question that, you have to find the third \"distinct\" maximum number.\\ndistinct(not duplicate) means unique\\nthe arr = [1,2,2,5,3,5] for distinct element will be -> arr = [1,2,3,5]  so 2 is the answer. \\n"
                    },
                    {
                        "username": "szp14",
                        "content": "For the testing case [-2147483648, 1, 2], the third maximum number is -2147483648, but the \"Run\" command of this question returns 2"
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) where is the relation with num.lenght?\\n"
                    },
                    {
                        "username": "singh_3662",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) his case has a num length of 3 which lies between 1 to 10^4"
                    },
                    {
                        "username": "darveshchauhan0001",
                        "content": "num length should be between 1 to 10^4"
                    },
                    {
                        "username": "xqcow",
                        "content": "why does this question have so many dislikes?"
                    },
                    {
                        "username": "aro",
                        "content": "\"THIRD DISTINCT NUMBER\""
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "It\\'s harder than some mediums in the same category as this one requires handling some annoying edge cases"
                    },
                    {
                        "username": "chrispeloso2",
                        "content": "The prompt is kinda confusing imo"
                    },
                    {
                        "username": "heg816",
                        "content": "The edgecases can be annoying. It\\'s not a bad prompt, but many questions with sneaky or tedious edgecases tend to get downvoted regardless of quality"
                    },
                    {
                        "username": "wtfk",
                        "content": "why test has Integer.MIN_VALUE!!!!\\n\\nare you crazy ?\\nare you crazy?"
                    },
                    {
                        "username": "honua",
                        "content": "that\\'s a good edge case, isn\\'t it? :D "
                    },
                    {
                        "username": "steeeevenn",
                        "content": "Hey so I run my code but one of the test case failed. However, I don\\'t the expected answer is correct. \\nThe input is [5,2,2]. The third maximun does not exist, so it should return the second maximum, which is 2. But the system is saying the expected answer is 5, which is the maximum.  Any ideas?\\n![image](https://assets.leetcode.com/users/images/77d31306-7523-465a-927c-9936842fc8e8_1619580785.8389773.png)\\n"
                    },
                    {
                        "username": "jackere1",
                        "content": "class Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        set<int> numSet(nums.begin(), nums.end());\\n\\n        set<int>::iterator itr = numSet.end();\\n\\n        cout << *itr;\\n        if(numSet.size() < 3)\\n            return *itr;\\n\\n        advance(itr, -3);\\n        return *itr;\\n    }\\n};\\n\\nI have same problem here and I tested my code 1000 times. It gives correct answer on my machine but gives 2 on this machine. What is wrong the with compiler?"
                    },
                    {
                        "username": "andresstawski",
                        "content": "If the third maximum does not exist, return the maximum number."
                    },
                    {
                        "username": "ankit_borbora",
                        "content": "The question says that if a 3rd max no. is not present, then print the maximum no. Not the second max no."
                    },
                    {
                        "username": "shreysaini1998",
                        "content": "it says in question if 3rd max does not exist, return the 1st max"
                    },
                    {
                        "username": "N8mare",
                        "content": "read the question properly,,,if 3rd max doesn\\'t exists then return the maximum number"
                    },
                    {
                        "username": "AyushThakur-7",
                        "content": " Try by adding the elements in a arraylist and removing the duplicates as you add the elements. After this you just need to transfer the elements back to an array and  apply required conditions."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thanks done\\n"
                    },
                    {
                        "username": "Geeks-Vegeta",
                        "content": "def thirdMax(self, nums: List[int]) -> int:\\n        newset=list(set(nums))\\n        lenset=len(newset)\\n        newset.sort(reverse=True)\\n        if lenset>=3:\\n            return newset[2]\\n        else:\\n            return newset[0]"
                    },
                    {
                        "username": "sathishb1139",
                        "content": "o(n log n) right\\n"
                    },
                    {
                        "username": "mustafaAlhillo",
                        "content": "for test case [1,2147483647,-2147483648], Why the expected answer is -2147483648. \nthose are two elements and it should return the Max value which is 1,2147483647"
                    },
                    {
                        "username": "pstrait",
                        "content": "Wut? that\\'s 3 elements.  Element #1 = 1.  Element #2 = 2147483647.  Element #3 = -2147483647."
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "using python 3:-\\n\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        x = sorted(set(nums),reverse=True)\\n        if len(x) < 3:\\n            return x[0]\\n        else:\\n            return x[2]"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/414_Third_Max_Num.cpp"
                    }
                ]
            },
            {
                "id": 1716064,
                "content": [
                    {
                        "username": "coldknight",
                        "content": "Isn't 3 the third maximum number of [1,2,2,5,3,5]? Why OJ gave 2?"
                    },
                    {
                        "username": "biswambar",
                        "content": "it\\'s mentioned in the question that, you have to find the third \"distinct\" maximum number.\\ndistinct(not duplicate) means unique\\nthe arr = [1,2,2,5,3,5] for distinct element will be -> arr = [1,2,3,5]  so 2 is the answer. \\n"
                    },
                    {
                        "username": "szp14",
                        "content": "For the testing case [-2147483648, 1, 2], the third maximum number is -2147483648, but the \"Run\" command of this question returns 2"
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) where is the relation with num.lenght?\\n"
                    },
                    {
                        "username": "singh_3662",
                        "content": "[@darveshchauhan0001](/darveshchauhan0001) his case has a num length of 3 which lies between 1 to 10^4"
                    },
                    {
                        "username": "darveshchauhan0001",
                        "content": "num length should be between 1 to 10^4"
                    },
                    {
                        "username": "xqcow",
                        "content": "why does this question have so many dislikes?"
                    },
                    {
                        "username": "aro",
                        "content": "\"THIRD DISTINCT NUMBER\""
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "It\\'s harder than some mediums in the same category as this one requires handling some annoying edge cases"
                    },
                    {
                        "username": "chrispeloso2",
                        "content": "The prompt is kinda confusing imo"
                    },
                    {
                        "username": "heg816",
                        "content": "The edgecases can be annoying. It\\'s not a bad prompt, but many questions with sneaky or tedious edgecases tend to get downvoted regardless of quality"
                    },
                    {
                        "username": "wtfk",
                        "content": "why test has Integer.MIN_VALUE!!!!\\n\\nare you crazy ?\\nare you crazy?"
                    },
                    {
                        "username": "honua",
                        "content": "that\\'s a good edge case, isn\\'t it? :D "
                    },
                    {
                        "username": "steeeevenn",
                        "content": "Hey so I run my code but one of the test case failed. However, I don\\'t the expected answer is correct. \\nThe input is [5,2,2]. The third maximun does not exist, so it should return the second maximum, which is 2. But the system is saying the expected answer is 5, which is the maximum.  Any ideas?\\n![image](https://assets.leetcode.com/users/images/77d31306-7523-465a-927c-9936842fc8e8_1619580785.8389773.png)\\n"
                    },
                    {
                        "username": "jackere1",
                        "content": "class Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        set<int> numSet(nums.begin(), nums.end());\\n\\n        set<int>::iterator itr = numSet.end();\\n\\n        cout << *itr;\\n        if(numSet.size() < 3)\\n            return *itr;\\n\\n        advance(itr, -3);\\n        return *itr;\\n    }\\n};\\n\\nI have same problem here and I tested my code 1000 times. It gives correct answer on my machine but gives 2 on this machine. What is wrong the with compiler?"
                    },
                    {
                        "username": "andresstawski",
                        "content": "If the third maximum does not exist, return the maximum number."
                    },
                    {
                        "username": "ankit_borbora",
                        "content": "The question says that if a 3rd max no. is not present, then print the maximum no. Not the second max no."
                    },
                    {
                        "username": "shreysaini1998",
                        "content": "it says in question if 3rd max does not exist, return the 1st max"
                    },
                    {
                        "username": "N8mare",
                        "content": "read the question properly,,,if 3rd max doesn\\'t exists then return the maximum number"
                    },
                    {
                        "username": "AyushThakur-7",
                        "content": " Try by adding the elements in a arraylist and removing the duplicates as you add the elements. After this you just need to transfer the elements back to an array and  apply required conditions."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thanks done\\n"
                    },
                    {
                        "username": "Geeks-Vegeta",
                        "content": "def thirdMax(self, nums: List[int]) -> int:\\n        newset=list(set(nums))\\n        lenset=len(newset)\\n        newset.sort(reverse=True)\\n        if lenset>=3:\\n            return newset[2]\\n        else:\\n            return newset[0]"
                    },
                    {
                        "username": "sathishb1139",
                        "content": "o(n log n) right\\n"
                    },
                    {
                        "username": "mustafaAlhillo",
                        "content": "for test case [1,2147483647,-2147483648], Why the expected answer is -2147483648. \nthose are two elements and it should return the Max value which is 1,2147483647"
                    },
                    {
                        "username": "pstrait",
                        "content": "Wut? that\\'s 3 elements.  Element #1 = 1.  Element #2 = 2147483647.  Element #3 = -2147483647."
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "using python 3:-\\n\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        x = sorted(set(nums),reverse=True)\\n        if len(x) < 3:\\n            return x[0]\\n        else:\\n            return x[2]"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/414_Third_Max_Num.cpp"
                    }
                ]
            },
            {
                "id": 1678173,
                "content": [
                    {
                        "username": "kumavine",
                        "content": "For test case [5,2,2].... output should be 2 as per problem details. But system is saying 5. \\n"
                    },
                    {
                        "username": "mustafaAlhillo",
                        "content": "The question says \nFirst, only distinct(no dublicates ) which is  = [2,5] .\nSecond, it says \"If the third maximum does not exist, return the maximum number.\". Hence , max =5 "
                    },
                    {
                        "username": "timbaginski",
                        "content": "[1,2,2,5,3,5] gives 2. But isn\\'t 5 the third distinct max int? 1 is the first distinct int, the 2 twos are the second distinct, and 5 is the third. Yet it expects 2. Can somebody explain?"
                    },
                    {
                        "username": "N8mare",
                        "content": "distinct word in the question simply means that the max number shouldn\\'t repeat like if arr = [2,3,5,5] the 3 max nums here are - (5,3,2).\\nso simply find the 3 distinct max integers from nums and return the 3rd max which will be 2 in my example and 2 in yours as well!"
                    },
                    {
                        "username": "xianjun",
                        "content": "Correct should be 3, while the system returns 2 as result."
                    },
                    {
                        "username": "MeteorJune",
                        "content": "Test cases of [1,1,2] and [1, 2, 2] are needed. In addition, test cases such as [-2147483648, 1,1] and [-2147483648, 1,2] are needed too."
                    },
                    {
                        "username": "jordandong",
                        "content": "[-2147483648, 1, 2]\\n\\nshould return -2147483648, but OJ gives 2\\n\\n[1, 2, -2147483648]\\n\\nshould return -2147483648, OJ gvies correct answers"
                    },
                    {
                        "username": "user6359S",
                        "content": "What distinct? Should all 3 be distinct? Only 3 should be distinct? Why [2,2,3,1] gives 1? Who the fuck create these shitty problems? Indian coders?"
                    },
                    {
                        "username": "pyratu",
                        "content": "nums = [1,2,2,5,3,5]\\nwhy is expected 2? The answer should be 5"
                    },
                    {
                        "username": "AnishDhomase",
                        "content": "I didn\\'t understand Why this question have so many dislikes?"
                    },
                    {
                        "username": "shubham_mathur18",
                        "content": "This question is not that easy I tried it for more than 5 times but failed but after spending so many time i took help and then solved, don\\'t judge it  like easy one think more"
                    },
                    {
                        "username": "juhyeontae",
                        "content": "Hey bro, I think this problem is medium "
                    }
                ]
            },
            {
                "id": 1575725,
                "content": [
                    {
                        "username": "kumavine",
                        "content": "For test case [5,2,2].... output should be 2 as per problem details. But system is saying 5. \\n"
                    },
                    {
                        "username": "mustafaAlhillo",
                        "content": "The question says \nFirst, only distinct(no dublicates ) which is  = [2,5] .\nSecond, it says \"If the third maximum does not exist, return the maximum number.\". Hence , max =5 "
                    },
                    {
                        "username": "timbaginski",
                        "content": "[1,2,2,5,3,5] gives 2. But isn\\'t 5 the third distinct max int? 1 is the first distinct int, the 2 twos are the second distinct, and 5 is the third. Yet it expects 2. Can somebody explain?"
                    },
                    {
                        "username": "N8mare",
                        "content": "distinct word in the question simply means that the max number shouldn\\'t repeat like if arr = [2,3,5,5] the 3 max nums here are - (5,3,2).\\nso simply find the 3 distinct max integers from nums and return the 3rd max which will be 2 in my example and 2 in yours as well!"
                    },
                    {
                        "username": "xianjun",
                        "content": "Correct should be 3, while the system returns 2 as result."
                    },
                    {
                        "username": "MeteorJune",
                        "content": "Test cases of [1,1,2] and [1, 2, 2] are needed. In addition, test cases such as [-2147483648, 1,1] and [-2147483648, 1,2] are needed too."
                    },
                    {
                        "username": "jordandong",
                        "content": "[-2147483648, 1, 2]\\n\\nshould return -2147483648, but OJ gives 2\\n\\n[1, 2, -2147483648]\\n\\nshould return -2147483648, OJ gvies correct answers"
                    },
                    {
                        "username": "user6359S",
                        "content": "What distinct? Should all 3 be distinct? Only 3 should be distinct? Why [2,2,3,1] gives 1? Who the fuck create these shitty problems? Indian coders?"
                    },
                    {
                        "username": "pyratu",
                        "content": "nums = [1,2,2,5,3,5]\\nwhy is expected 2? The answer should be 5"
                    },
                    {
                        "username": "AnishDhomase",
                        "content": "I didn\\'t understand Why this question have so many dislikes?"
                    },
                    {
                        "username": "shubham_mathur18",
                        "content": "This question is not that easy I tried it for more than 5 times but failed but after spending so many time i took help and then solved, don\\'t judge it  like easy one think more"
                    },
                    {
                        "username": "juhyeontae",
                        "content": "Hey bro, I think this problem is medium "
                    }
                ]
            },
            {
                "id": 1571691,
                "content": [
                    {
                        "username": "kumavine",
                        "content": "For test case [5,2,2].... output should be 2 as per problem details. But system is saying 5. \\n"
                    },
                    {
                        "username": "mustafaAlhillo",
                        "content": "The question says \nFirst, only distinct(no dublicates ) which is  = [2,5] .\nSecond, it says \"If the third maximum does not exist, return the maximum number.\". Hence , max =5 "
                    },
                    {
                        "username": "timbaginski",
                        "content": "[1,2,2,5,3,5] gives 2. But isn\\'t 5 the third distinct max int? 1 is the first distinct int, the 2 twos are the second distinct, and 5 is the third. Yet it expects 2. Can somebody explain?"
                    },
                    {
                        "username": "N8mare",
                        "content": "distinct word in the question simply means that the max number shouldn\\'t repeat like if arr = [2,3,5,5] the 3 max nums here are - (5,3,2).\\nso simply find the 3 distinct max integers from nums and return the 3rd max which will be 2 in my example and 2 in yours as well!"
                    },
                    {
                        "username": "xianjun",
                        "content": "Correct should be 3, while the system returns 2 as result."
                    },
                    {
                        "username": "MeteorJune",
                        "content": "Test cases of [1,1,2] and [1, 2, 2] are needed. In addition, test cases such as [-2147483648, 1,1] and [-2147483648, 1,2] are needed too."
                    },
                    {
                        "username": "jordandong",
                        "content": "[-2147483648, 1, 2]\\n\\nshould return -2147483648, but OJ gives 2\\n\\n[1, 2, -2147483648]\\n\\nshould return -2147483648, OJ gvies correct answers"
                    },
                    {
                        "username": "user6359S",
                        "content": "What distinct? Should all 3 be distinct? Only 3 should be distinct? Why [2,2,3,1] gives 1? Who the fuck create these shitty problems? Indian coders?"
                    },
                    {
                        "username": "pyratu",
                        "content": "nums = [1,2,2,5,3,5]\\nwhy is expected 2? The answer should be 5"
                    },
                    {
                        "username": "AnishDhomase",
                        "content": "I didn\\'t understand Why this question have so many dislikes?"
                    },
                    {
                        "username": "shubham_mathur18",
                        "content": "This question is not that easy I tried it for more than 5 times but failed but after spending so many time i took help and then solved, don\\'t judge it  like easy one think more"
                    },
                    {
                        "username": "juhyeontae",
                        "content": "Hey bro, I think this problem is medium "
                    }
                ]
            },
            {
                "id": 1571693,
                "content": [
                    {
                        "username": "kumavine",
                        "content": "For test case [5,2,2].... output should be 2 as per problem details. But system is saying 5. \\n"
                    },
                    {
                        "username": "mustafaAlhillo",
                        "content": "The question says \nFirst, only distinct(no dublicates ) which is  = [2,5] .\nSecond, it says \"If the third maximum does not exist, return the maximum number.\". Hence , max =5 "
                    },
                    {
                        "username": "timbaginski",
                        "content": "[1,2,2,5,3,5] gives 2. But isn\\'t 5 the third distinct max int? 1 is the first distinct int, the 2 twos are the second distinct, and 5 is the third. Yet it expects 2. Can somebody explain?"
                    },
                    {
                        "username": "N8mare",
                        "content": "distinct word in the question simply means that the max number shouldn\\'t repeat like if arr = [2,3,5,5] the 3 max nums here are - (5,3,2).\\nso simply find the 3 distinct max integers from nums and return the 3rd max which will be 2 in my example and 2 in yours as well!"
                    },
                    {
                        "username": "xianjun",
                        "content": "Correct should be 3, while the system returns 2 as result."
                    },
                    {
                        "username": "MeteorJune",
                        "content": "Test cases of [1,1,2] and [1, 2, 2] are needed. In addition, test cases such as [-2147483648, 1,1] and [-2147483648, 1,2] are needed too."
                    },
                    {
                        "username": "jordandong",
                        "content": "[-2147483648, 1, 2]\\n\\nshould return -2147483648, but OJ gives 2\\n\\n[1, 2, -2147483648]\\n\\nshould return -2147483648, OJ gvies correct answers"
                    },
                    {
                        "username": "user6359S",
                        "content": "What distinct? Should all 3 be distinct? Only 3 should be distinct? Why [2,2,3,1] gives 1? Who the fuck create these shitty problems? Indian coders?"
                    },
                    {
                        "username": "pyratu",
                        "content": "nums = [1,2,2,5,3,5]\\nwhy is expected 2? The answer should be 5"
                    },
                    {
                        "username": "AnishDhomase",
                        "content": "I didn\\'t understand Why this question have so many dislikes?"
                    },
                    {
                        "username": "shubham_mathur18",
                        "content": "This question is not that easy I tried it for more than 5 times but failed but after spending so many time i took help and then solved, don\\'t judge it  like easy one think more"
                    },
                    {
                        "username": "juhyeontae",
                        "content": "Hey bro, I think this problem is medium "
                    }
                ]
            },
            {
                "id": 1571692,
                "content": [
                    {
                        "username": "kumavine",
                        "content": "For test case [5,2,2].... output should be 2 as per problem details. But system is saying 5. \\n"
                    },
                    {
                        "username": "mustafaAlhillo",
                        "content": "The question says \nFirst, only distinct(no dublicates ) which is  = [2,5] .\nSecond, it says \"If the third maximum does not exist, return the maximum number.\". Hence , max =5 "
                    },
                    {
                        "username": "timbaginski",
                        "content": "[1,2,2,5,3,5] gives 2. But isn\\'t 5 the third distinct max int? 1 is the first distinct int, the 2 twos are the second distinct, and 5 is the third. Yet it expects 2. Can somebody explain?"
                    },
                    {
                        "username": "N8mare",
                        "content": "distinct word in the question simply means that the max number shouldn\\'t repeat like if arr = [2,3,5,5] the 3 max nums here are - (5,3,2).\\nso simply find the 3 distinct max integers from nums and return the 3rd max which will be 2 in my example and 2 in yours as well!"
                    },
                    {
                        "username": "xianjun",
                        "content": "Correct should be 3, while the system returns 2 as result."
                    },
                    {
                        "username": "MeteorJune",
                        "content": "Test cases of [1,1,2] and [1, 2, 2] are needed. In addition, test cases such as [-2147483648, 1,1] and [-2147483648, 1,2] are needed too."
                    },
                    {
                        "username": "jordandong",
                        "content": "[-2147483648, 1, 2]\\n\\nshould return -2147483648, but OJ gives 2\\n\\n[1, 2, -2147483648]\\n\\nshould return -2147483648, OJ gvies correct answers"
                    },
                    {
                        "username": "user6359S",
                        "content": "What distinct? Should all 3 be distinct? Only 3 should be distinct? Why [2,2,3,1] gives 1? Who the fuck create these shitty problems? Indian coders?"
                    },
                    {
                        "username": "pyratu",
                        "content": "nums = [1,2,2,5,3,5]\\nwhy is expected 2? The answer should be 5"
                    },
                    {
                        "username": "AnishDhomase",
                        "content": "I didn\\'t understand Why this question have so many dislikes?"
                    },
                    {
                        "username": "shubham_mathur18",
                        "content": "This question is not that easy I tried it for more than 5 times but failed but after spending so many time i took help and then solved, don\\'t judge it  like easy one think more"
                    },
                    {
                        "username": "juhyeontae",
                        "content": "Hey bro, I think this problem is medium "
                    }
                ]
            },
            {
                "id": 1733172,
                "content": [
                    {
                        "username": "kumavine",
                        "content": "For test case [5,2,2].... output should be 2 as per problem details. But system is saying 5. \\n"
                    },
                    {
                        "username": "mustafaAlhillo",
                        "content": "The question says \nFirst, only distinct(no dublicates ) which is  = [2,5] .\nSecond, it says \"If the third maximum does not exist, return the maximum number.\". Hence , max =5 "
                    },
                    {
                        "username": "timbaginski",
                        "content": "[1,2,2,5,3,5] gives 2. But isn\\'t 5 the third distinct max int? 1 is the first distinct int, the 2 twos are the second distinct, and 5 is the third. Yet it expects 2. Can somebody explain?"
                    },
                    {
                        "username": "N8mare",
                        "content": "distinct word in the question simply means that the max number shouldn\\'t repeat like if arr = [2,3,5,5] the 3 max nums here are - (5,3,2).\\nso simply find the 3 distinct max integers from nums and return the 3rd max which will be 2 in my example and 2 in yours as well!"
                    },
                    {
                        "username": "xianjun",
                        "content": "Correct should be 3, while the system returns 2 as result."
                    },
                    {
                        "username": "MeteorJune",
                        "content": "Test cases of [1,1,2] and [1, 2, 2] are needed. In addition, test cases such as [-2147483648, 1,1] and [-2147483648, 1,2] are needed too."
                    },
                    {
                        "username": "jordandong",
                        "content": "[-2147483648, 1, 2]\\n\\nshould return -2147483648, but OJ gives 2\\n\\n[1, 2, -2147483648]\\n\\nshould return -2147483648, OJ gvies correct answers"
                    },
                    {
                        "username": "user6359S",
                        "content": "What distinct? Should all 3 be distinct? Only 3 should be distinct? Why [2,2,3,1] gives 1? Who the fuck create these shitty problems? Indian coders?"
                    },
                    {
                        "username": "pyratu",
                        "content": "nums = [1,2,2,5,3,5]\\nwhy is expected 2? The answer should be 5"
                    },
                    {
                        "username": "AnishDhomase",
                        "content": "I didn\\'t understand Why this question have so many dislikes?"
                    },
                    {
                        "username": "shubham_mathur18",
                        "content": "This question is not that easy I tried it for more than 5 times but failed but after spending so many time i took help and then solved, don\\'t judge it  like easy one think more"
                    },
                    {
                        "username": "juhyeontae",
                        "content": "Hey bro, I think this problem is medium "
                    }
                ]
            },
            {
                "id": 2034592,
                "content": [
                    {
                        "username": "kumavine",
                        "content": "For test case [5,2,2].... output should be 2 as per problem details. But system is saying 5. \\n"
                    },
                    {
                        "username": "mustafaAlhillo",
                        "content": "The question says \nFirst, only distinct(no dublicates ) which is  = [2,5] .\nSecond, it says \"If the third maximum does not exist, return the maximum number.\". Hence , max =5 "
                    },
                    {
                        "username": "timbaginski",
                        "content": "[1,2,2,5,3,5] gives 2. But isn\\'t 5 the third distinct max int? 1 is the first distinct int, the 2 twos are the second distinct, and 5 is the third. Yet it expects 2. Can somebody explain?"
                    },
                    {
                        "username": "N8mare",
                        "content": "distinct word in the question simply means that the max number shouldn\\'t repeat like if arr = [2,3,5,5] the 3 max nums here are - (5,3,2).\\nso simply find the 3 distinct max integers from nums and return the 3rd max which will be 2 in my example and 2 in yours as well!"
                    },
                    {
                        "username": "xianjun",
                        "content": "Correct should be 3, while the system returns 2 as result."
                    },
                    {
                        "username": "MeteorJune",
                        "content": "Test cases of [1,1,2] and [1, 2, 2] are needed. In addition, test cases such as [-2147483648, 1,1] and [-2147483648, 1,2] are needed too."
                    },
                    {
                        "username": "jordandong",
                        "content": "[-2147483648, 1, 2]\\n\\nshould return -2147483648, but OJ gives 2\\n\\n[1, 2, -2147483648]\\n\\nshould return -2147483648, OJ gvies correct answers"
                    },
                    {
                        "username": "user6359S",
                        "content": "What distinct? Should all 3 be distinct? Only 3 should be distinct? Why [2,2,3,1] gives 1? Who the fuck create these shitty problems? Indian coders?"
                    },
                    {
                        "username": "pyratu",
                        "content": "nums = [1,2,2,5,3,5]\\nwhy is expected 2? The answer should be 5"
                    },
                    {
                        "username": "AnishDhomase",
                        "content": "I didn\\'t understand Why this question have so many dislikes?"
                    },
                    {
                        "username": "shubham_mathur18",
                        "content": "This question is not that easy I tried it for more than 5 times but failed but after spending so many time i took help and then solved, don\\'t judge it  like easy one think more"
                    },
                    {
                        "username": "juhyeontae",
                        "content": "Hey bro, I think this problem is medium "
                    }
                ]
            },
            {
                "id": 2021400,
                "content": [
                    {
                        "username": "kumavine",
                        "content": "For test case [5,2,2].... output should be 2 as per problem details. But system is saying 5. \\n"
                    },
                    {
                        "username": "mustafaAlhillo",
                        "content": "The question says \nFirst, only distinct(no dublicates ) which is  = [2,5] .\nSecond, it says \"If the third maximum does not exist, return the maximum number.\". Hence , max =5 "
                    },
                    {
                        "username": "timbaginski",
                        "content": "[1,2,2,5,3,5] gives 2. But isn\\'t 5 the third distinct max int? 1 is the first distinct int, the 2 twos are the second distinct, and 5 is the third. Yet it expects 2. Can somebody explain?"
                    },
                    {
                        "username": "N8mare",
                        "content": "distinct word in the question simply means that the max number shouldn\\'t repeat like if arr = [2,3,5,5] the 3 max nums here are - (5,3,2).\\nso simply find the 3 distinct max integers from nums and return the 3rd max which will be 2 in my example and 2 in yours as well!"
                    },
                    {
                        "username": "xianjun",
                        "content": "Correct should be 3, while the system returns 2 as result."
                    },
                    {
                        "username": "MeteorJune",
                        "content": "Test cases of [1,1,2] and [1, 2, 2] are needed. In addition, test cases such as [-2147483648, 1,1] and [-2147483648, 1,2] are needed too."
                    },
                    {
                        "username": "jordandong",
                        "content": "[-2147483648, 1, 2]\\n\\nshould return -2147483648, but OJ gives 2\\n\\n[1, 2, -2147483648]\\n\\nshould return -2147483648, OJ gvies correct answers"
                    },
                    {
                        "username": "user6359S",
                        "content": "What distinct? Should all 3 be distinct? Only 3 should be distinct? Why [2,2,3,1] gives 1? Who the fuck create these shitty problems? Indian coders?"
                    },
                    {
                        "username": "pyratu",
                        "content": "nums = [1,2,2,5,3,5]\\nwhy is expected 2? The answer should be 5"
                    },
                    {
                        "username": "AnishDhomase",
                        "content": "I didn\\'t understand Why this question have so many dislikes?"
                    },
                    {
                        "username": "shubham_mathur18",
                        "content": "This question is not that easy I tried it for more than 5 times but failed but after spending so many time i took help and then solved, don\\'t judge it  like easy one think more"
                    },
                    {
                        "username": "juhyeontae",
                        "content": "Hey bro, I think this problem is medium "
                    }
                ]
            },
            {
                "id": 2020292,
                "content": [
                    {
                        "username": "kumavine",
                        "content": "For test case [5,2,2].... output should be 2 as per problem details. But system is saying 5. \\n"
                    },
                    {
                        "username": "mustafaAlhillo",
                        "content": "The question says \nFirst, only distinct(no dublicates ) which is  = [2,5] .\nSecond, it says \"If the third maximum does not exist, return the maximum number.\". Hence , max =5 "
                    },
                    {
                        "username": "timbaginski",
                        "content": "[1,2,2,5,3,5] gives 2. But isn\\'t 5 the third distinct max int? 1 is the first distinct int, the 2 twos are the second distinct, and 5 is the third. Yet it expects 2. Can somebody explain?"
                    },
                    {
                        "username": "N8mare",
                        "content": "distinct word in the question simply means that the max number shouldn\\'t repeat like if arr = [2,3,5,5] the 3 max nums here are - (5,3,2).\\nso simply find the 3 distinct max integers from nums and return the 3rd max which will be 2 in my example and 2 in yours as well!"
                    },
                    {
                        "username": "xianjun",
                        "content": "Correct should be 3, while the system returns 2 as result."
                    },
                    {
                        "username": "MeteorJune",
                        "content": "Test cases of [1,1,2] and [1, 2, 2] are needed. In addition, test cases such as [-2147483648, 1,1] and [-2147483648, 1,2] are needed too."
                    },
                    {
                        "username": "jordandong",
                        "content": "[-2147483648, 1, 2]\\n\\nshould return -2147483648, but OJ gives 2\\n\\n[1, 2, -2147483648]\\n\\nshould return -2147483648, OJ gvies correct answers"
                    },
                    {
                        "username": "user6359S",
                        "content": "What distinct? Should all 3 be distinct? Only 3 should be distinct? Why [2,2,3,1] gives 1? Who the fuck create these shitty problems? Indian coders?"
                    },
                    {
                        "username": "pyratu",
                        "content": "nums = [1,2,2,5,3,5]\\nwhy is expected 2? The answer should be 5"
                    },
                    {
                        "username": "AnishDhomase",
                        "content": "I didn\\'t understand Why this question have so many dislikes?"
                    },
                    {
                        "username": "shubham_mathur18",
                        "content": "This question is not that easy I tried it for more than 5 times but failed but after spending so many time i took help and then solved, don\\'t judge it  like easy one think more"
                    },
                    {
                        "username": "juhyeontae",
                        "content": "Hey bro, I think this problem is medium "
                    }
                ]
            },
            {
                "id": 2014666,
                "content": [
                    {
                        "username": "kumavine",
                        "content": "For test case [5,2,2].... output should be 2 as per problem details. But system is saying 5. \\n"
                    },
                    {
                        "username": "mustafaAlhillo",
                        "content": "The question says \nFirst, only distinct(no dublicates ) which is  = [2,5] .\nSecond, it says \"If the third maximum does not exist, return the maximum number.\". Hence , max =5 "
                    },
                    {
                        "username": "timbaginski",
                        "content": "[1,2,2,5,3,5] gives 2. But isn\\'t 5 the third distinct max int? 1 is the first distinct int, the 2 twos are the second distinct, and 5 is the third. Yet it expects 2. Can somebody explain?"
                    },
                    {
                        "username": "N8mare",
                        "content": "distinct word in the question simply means that the max number shouldn\\'t repeat like if arr = [2,3,5,5] the 3 max nums here are - (5,3,2).\\nso simply find the 3 distinct max integers from nums and return the 3rd max which will be 2 in my example and 2 in yours as well!"
                    },
                    {
                        "username": "xianjun",
                        "content": "Correct should be 3, while the system returns 2 as result."
                    },
                    {
                        "username": "MeteorJune",
                        "content": "Test cases of [1,1,2] and [1, 2, 2] are needed. In addition, test cases such as [-2147483648, 1,1] and [-2147483648, 1,2] are needed too."
                    },
                    {
                        "username": "jordandong",
                        "content": "[-2147483648, 1, 2]\\n\\nshould return -2147483648, but OJ gives 2\\n\\n[1, 2, -2147483648]\\n\\nshould return -2147483648, OJ gvies correct answers"
                    },
                    {
                        "username": "user6359S",
                        "content": "What distinct? Should all 3 be distinct? Only 3 should be distinct? Why [2,2,3,1] gives 1? Who the fuck create these shitty problems? Indian coders?"
                    },
                    {
                        "username": "pyratu",
                        "content": "nums = [1,2,2,5,3,5]\\nwhy is expected 2? The answer should be 5"
                    },
                    {
                        "username": "AnishDhomase",
                        "content": "I didn\\'t understand Why this question have so many dislikes?"
                    },
                    {
                        "username": "shubham_mathur18",
                        "content": "This question is not that easy I tried it for more than 5 times but failed but after spending so many time i took help and then solved, don\\'t judge it  like easy one think more"
                    },
                    {
                        "username": "juhyeontae",
                        "content": "Hey bro, I think this problem is medium "
                    }
                ]
            },
            {
                "id": 1981920,
                "content": [
                    {
                        "username": "Undefeated22",
                        "content": "WHat to do\\n\\n"
                    },
                    {
                        "username": "jackere1",
                        "content": "When I print the all numbers in [5, 2, 2] case, It gives 5 2 2 2. My code is here and it gives wrong result:\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        for(int &x: nums) {\\n            cout << x << \" \";\\n        }\\n        set<int> numSet(nums.begin(), nums.end());\\n\\n        set<int>::iterator itr = numSet.end();\\n\\n        cout << *itr;\\n        if(numSet.size() < 3)\\n            return *itr;\\n\\n        advance(itr, -3);\\n        return *itr;\\n    }\\n};"
                    },
                    {
                        "username": "andresstawski",
                        "content": "someone knows why this doesnt work on [1,2,2,5,3,5]?\\n\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        \\n        nums.erase(std::unique(nums.begin(), nums.end()), nums.end());\\n        sort(nums.begin(), nums.end());\\n        if(nums.size() < 3) return nums[nums.size() - 1];\\n         \\n        int ans = nums[nums.size()-3];\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Since 3n belongs to O(n), trivial iterate-three-times solution is, in fact, O(n).\n\n3n belongs to O(n), as limit of 3n/n approaches 3, a finite non-zero number."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "for ar[1,2,2,5,3,5] my output is 5 ans expected output is 2 how??\\n"
                    },
                    {
                        "username": "haneesha11",
                        "content": "Firstly convert the list into set and sort the set in descending order (use reverse=True) then check if length of nums is greater then or equal to three if yes then return the element in the second index else return the first index\\n "
                    },
                    {
                        "username": "sunnycs121",
                        "content": "Why so many people disliked this question?"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "One of the possible solution would be put distinct element in some other vector and apply 3 passes of bubble sort it will take O(n) time but it also taking space O(n)"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Use Hash Map to store unique values <br> \\nMy Easy and simple Solution : -> \\n\\nhttps://leetcode.com/problems/third-maximum-number/solutions/3139423/c-easy-and-simple-solution/"
                    },
                    {
                        "username": "rafiul29",
                        "content": "# JavaScript  solution\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar thirdMax = function(nums) {\\n    let arr=[...new Set([...nums])]\\n    arr.sort((a,b)=>a-b)\\n    if(arr.length<3){\\n        return arr[arr.length-1]\\n    }\\n    return  arr[arr.length-3]\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1936950,
                "content": [
                    {
                        "username": "Undefeated22",
                        "content": "WHat to do\\n\\n"
                    },
                    {
                        "username": "jackere1",
                        "content": "When I print the all numbers in [5, 2, 2] case, It gives 5 2 2 2. My code is here and it gives wrong result:\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        for(int &x: nums) {\\n            cout << x << \" \";\\n        }\\n        set<int> numSet(nums.begin(), nums.end());\\n\\n        set<int>::iterator itr = numSet.end();\\n\\n        cout << *itr;\\n        if(numSet.size() < 3)\\n            return *itr;\\n\\n        advance(itr, -3);\\n        return *itr;\\n    }\\n};"
                    },
                    {
                        "username": "andresstawski",
                        "content": "someone knows why this doesnt work on [1,2,2,5,3,5]?\\n\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        \\n        nums.erase(std::unique(nums.begin(), nums.end()), nums.end());\\n        sort(nums.begin(), nums.end());\\n        if(nums.size() < 3) return nums[nums.size() - 1];\\n         \\n        int ans = nums[nums.size()-3];\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Since 3n belongs to O(n), trivial iterate-three-times solution is, in fact, O(n).\n\n3n belongs to O(n), as limit of 3n/n approaches 3, a finite non-zero number."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "for ar[1,2,2,5,3,5] my output is 5 ans expected output is 2 how??\\n"
                    },
                    {
                        "username": "haneesha11",
                        "content": "Firstly convert the list into set and sort the set in descending order (use reverse=True) then check if length of nums is greater then or equal to three if yes then return the element in the second index else return the first index\\n "
                    },
                    {
                        "username": "sunnycs121",
                        "content": "Why so many people disliked this question?"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "One of the possible solution would be put distinct element in some other vector and apply 3 passes of bubble sort it will take O(n) time but it also taking space O(n)"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Use Hash Map to store unique values <br> \\nMy Easy and simple Solution : -> \\n\\nhttps://leetcode.com/problems/third-maximum-number/solutions/3139423/c-easy-and-simple-solution/"
                    },
                    {
                        "username": "rafiul29",
                        "content": "# JavaScript  solution\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar thirdMax = function(nums) {\\n    let arr=[...new Set([...nums])]\\n    arr.sort((a,b)=>a-b)\\n    if(arr.length<3){\\n        return arr[arr.length-1]\\n    }\\n    return  arr[arr.length-3]\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1924122,
                "content": [
                    {
                        "username": "Undefeated22",
                        "content": "WHat to do\\n\\n"
                    },
                    {
                        "username": "jackere1",
                        "content": "When I print the all numbers in [5, 2, 2] case, It gives 5 2 2 2. My code is here and it gives wrong result:\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        for(int &x: nums) {\\n            cout << x << \" \";\\n        }\\n        set<int> numSet(nums.begin(), nums.end());\\n\\n        set<int>::iterator itr = numSet.end();\\n\\n        cout << *itr;\\n        if(numSet.size() < 3)\\n            return *itr;\\n\\n        advance(itr, -3);\\n        return *itr;\\n    }\\n};"
                    },
                    {
                        "username": "andresstawski",
                        "content": "someone knows why this doesnt work on [1,2,2,5,3,5]?\\n\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        \\n        nums.erase(std::unique(nums.begin(), nums.end()), nums.end());\\n        sort(nums.begin(), nums.end());\\n        if(nums.size() < 3) return nums[nums.size() - 1];\\n         \\n        int ans = nums[nums.size()-3];\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Since 3n belongs to O(n), trivial iterate-three-times solution is, in fact, O(n).\n\n3n belongs to O(n), as limit of 3n/n approaches 3, a finite non-zero number."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "for ar[1,2,2,5,3,5] my output is 5 ans expected output is 2 how??\\n"
                    },
                    {
                        "username": "haneesha11",
                        "content": "Firstly convert the list into set and sort the set in descending order (use reverse=True) then check if length of nums is greater then or equal to three if yes then return the element in the second index else return the first index\\n "
                    },
                    {
                        "username": "sunnycs121",
                        "content": "Why so many people disliked this question?"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "One of the possible solution would be put distinct element in some other vector and apply 3 passes of bubble sort it will take O(n) time but it also taking space O(n)"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Use Hash Map to store unique values <br> \\nMy Easy and simple Solution : -> \\n\\nhttps://leetcode.com/problems/third-maximum-number/solutions/3139423/c-easy-and-simple-solution/"
                    },
                    {
                        "username": "rafiul29",
                        "content": "# JavaScript  solution\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar thirdMax = function(nums) {\\n    let arr=[...new Set([...nums])]\\n    arr.sort((a,b)=>a-b)\\n    if(arr.length<3){\\n        return arr[arr.length-1]\\n    }\\n    return  arr[arr.length-3]\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1897382,
                "content": [
                    {
                        "username": "Undefeated22",
                        "content": "WHat to do\\n\\n"
                    },
                    {
                        "username": "jackere1",
                        "content": "When I print the all numbers in [5, 2, 2] case, It gives 5 2 2 2. My code is here and it gives wrong result:\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        for(int &x: nums) {\\n            cout << x << \" \";\\n        }\\n        set<int> numSet(nums.begin(), nums.end());\\n\\n        set<int>::iterator itr = numSet.end();\\n\\n        cout << *itr;\\n        if(numSet.size() < 3)\\n            return *itr;\\n\\n        advance(itr, -3);\\n        return *itr;\\n    }\\n};"
                    },
                    {
                        "username": "andresstawski",
                        "content": "someone knows why this doesnt work on [1,2,2,5,3,5]?\\n\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        \\n        nums.erase(std::unique(nums.begin(), nums.end()), nums.end());\\n        sort(nums.begin(), nums.end());\\n        if(nums.size() < 3) return nums[nums.size() - 1];\\n         \\n        int ans = nums[nums.size()-3];\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Since 3n belongs to O(n), trivial iterate-three-times solution is, in fact, O(n).\n\n3n belongs to O(n), as limit of 3n/n approaches 3, a finite non-zero number."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "for ar[1,2,2,5,3,5] my output is 5 ans expected output is 2 how??\\n"
                    },
                    {
                        "username": "haneesha11",
                        "content": "Firstly convert the list into set and sort the set in descending order (use reverse=True) then check if length of nums is greater then or equal to three if yes then return the element in the second index else return the first index\\n "
                    },
                    {
                        "username": "sunnycs121",
                        "content": "Why so many people disliked this question?"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "One of the possible solution would be put distinct element in some other vector and apply 3 passes of bubble sort it will take O(n) time but it also taking space O(n)"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Use Hash Map to store unique values <br> \\nMy Easy and simple Solution : -> \\n\\nhttps://leetcode.com/problems/third-maximum-number/solutions/3139423/c-easy-and-simple-solution/"
                    },
                    {
                        "username": "rafiul29",
                        "content": "# JavaScript  solution\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar thirdMax = function(nums) {\\n    let arr=[...new Set([...nums])]\\n    arr.sort((a,b)=>a-b)\\n    if(arr.length<3){\\n        return arr[arr.length-1]\\n    }\\n    return  arr[arr.length-3]\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1872174,
                "content": [
                    {
                        "username": "Undefeated22",
                        "content": "WHat to do\\n\\n"
                    },
                    {
                        "username": "jackere1",
                        "content": "When I print the all numbers in [5, 2, 2] case, It gives 5 2 2 2. My code is here and it gives wrong result:\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        for(int &x: nums) {\\n            cout << x << \" \";\\n        }\\n        set<int> numSet(nums.begin(), nums.end());\\n\\n        set<int>::iterator itr = numSet.end();\\n\\n        cout << *itr;\\n        if(numSet.size() < 3)\\n            return *itr;\\n\\n        advance(itr, -3);\\n        return *itr;\\n    }\\n};"
                    },
                    {
                        "username": "andresstawski",
                        "content": "someone knows why this doesnt work on [1,2,2,5,3,5]?\\n\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        \\n        nums.erase(std::unique(nums.begin(), nums.end()), nums.end());\\n        sort(nums.begin(), nums.end());\\n        if(nums.size() < 3) return nums[nums.size() - 1];\\n         \\n        int ans = nums[nums.size()-3];\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Since 3n belongs to O(n), trivial iterate-three-times solution is, in fact, O(n).\n\n3n belongs to O(n), as limit of 3n/n approaches 3, a finite non-zero number."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "for ar[1,2,2,5,3,5] my output is 5 ans expected output is 2 how??\\n"
                    },
                    {
                        "username": "haneesha11",
                        "content": "Firstly convert the list into set and sort the set in descending order (use reverse=True) then check if length of nums is greater then or equal to three if yes then return the element in the second index else return the first index\\n "
                    },
                    {
                        "username": "sunnycs121",
                        "content": "Why so many people disliked this question?"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "One of the possible solution would be put distinct element in some other vector and apply 3 passes of bubble sort it will take O(n) time but it also taking space O(n)"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Use Hash Map to store unique values <br> \\nMy Easy and simple Solution : -> \\n\\nhttps://leetcode.com/problems/third-maximum-number/solutions/3139423/c-easy-and-simple-solution/"
                    },
                    {
                        "username": "rafiul29",
                        "content": "# JavaScript  solution\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar thirdMax = function(nums) {\\n    let arr=[...new Set([...nums])]\\n    arr.sort((a,b)=>a-b)\\n    if(arr.length<3){\\n        return arr[arr.length-1]\\n    }\\n    return  arr[arr.length-3]\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1802271,
                "content": [
                    {
                        "username": "Undefeated22",
                        "content": "WHat to do\\n\\n"
                    },
                    {
                        "username": "jackere1",
                        "content": "When I print the all numbers in [5, 2, 2] case, It gives 5 2 2 2. My code is here and it gives wrong result:\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        for(int &x: nums) {\\n            cout << x << \" \";\\n        }\\n        set<int> numSet(nums.begin(), nums.end());\\n\\n        set<int>::iterator itr = numSet.end();\\n\\n        cout << *itr;\\n        if(numSet.size() < 3)\\n            return *itr;\\n\\n        advance(itr, -3);\\n        return *itr;\\n    }\\n};"
                    },
                    {
                        "username": "andresstawski",
                        "content": "someone knows why this doesnt work on [1,2,2,5,3,5]?\\n\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        \\n        nums.erase(std::unique(nums.begin(), nums.end()), nums.end());\\n        sort(nums.begin(), nums.end());\\n        if(nums.size() < 3) return nums[nums.size() - 1];\\n         \\n        int ans = nums[nums.size()-3];\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Since 3n belongs to O(n), trivial iterate-three-times solution is, in fact, O(n).\n\n3n belongs to O(n), as limit of 3n/n approaches 3, a finite non-zero number."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "for ar[1,2,2,5,3,5] my output is 5 ans expected output is 2 how??\\n"
                    },
                    {
                        "username": "haneesha11",
                        "content": "Firstly convert the list into set and sort the set in descending order (use reverse=True) then check if length of nums is greater then or equal to three if yes then return the element in the second index else return the first index\\n "
                    },
                    {
                        "username": "sunnycs121",
                        "content": "Why so many people disliked this question?"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "One of the possible solution would be put distinct element in some other vector and apply 3 passes of bubble sort it will take O(n) time but it also taking space O(n)"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Use Hash Map to store unique values <br> \\nMy Easy and simple Solution : -> \\n\\nhttps://leetcode.com/problems/third-maximum-number/solutions/3139423/c-easy-and-simple-solution/"
                    },
                    {
                        "username": "rafiul29",
                        "content": "# JavaScript  solution\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar thirdMax = function(nums) {\\n    let arr=[...new Set([...nums])]\\n    arr.sort((a,b)=>a-b)\\n    if(arr.length<3){\\n        return arr[arr.length-1]\\n    }\\n    return  arr[arr.length-3]\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1796017,
                "content": [
                    {
                        "username": "Undefeated22",
                        "content": "WHat to do\\n\\n"
                    },
                    {
                        "username": "jackere1",
                        "content": "When I print the all numbers in [5, 2, 2] case, It gives 5 2 2 2. My code is here and it gives wrong result:\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        for(int &x: nums) {\\n            cout << x << \" \";\\n        }\\n        set<int> numSet(nums.begin(), nums.end());\\n\\n        set<int>::iterator itr = numSet.end();\\n\\n        cout << *itr;\\n        if(numSet.size() < 3)\\n            return *itr;\\n\\n        advance(itr, -3);\\n        return *itr;\\n    }\\n};"
                    },
                    {
                        "username": "andresstawski",
                        "content": "someone knows why this doesnt work on [1,2,2,5,3,5]?\\n\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        \\n        nums.erase(std::unique(nums.begin(), nums.end()), nums.end());\\n        sort(nums.begin(), nums.end());\\n        if(nums.size() < 3) return nums[nums.size() - 1];\\n         \\n        int ans = nums[nums.size()-3];\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Since 3n belongs to O(n), trivial iterate-three-times solution is, in fact, O(n).\n\n3n belongs to O(n), as limit of 3n/n approaches 3, a finite non-zero number."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "for ar[1,2,2,5,3,5] my output is 5 ans expected output is 2 how??\\n"
                    },
                    {
                        "username": "haneesha11",
                        "content": "Firstly convert the list into set and sort the set in descending order (use reverse=True) then check if length of nums is greater then or equal to three if yes then return the element in the second index else return the first index\\n "
                    },
                    {
                        "username": "sunnycs121",
                        "content": "Why so many people disliked this question?"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "One of the possible solution would be put distinct element in some other vector and apply 3 passes of bubble sort it will take O(n) time but it also taking space O(n)"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Use Hash Map to store unique values <br> \\nMy Easy and simple Solution : -> \\n\\nhttps://leetcode.com/problems/third-maximum-number/solutions/3139423/c-easy-and-simple-solution/"
                    },
                    {
                        "username": "rafiul29",
                        "content": "# JavaScript  solution\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar thirdMax = function(nums) {\\n    let arr=[...new Set([...nums])]\\n    arr.sort((a,b)=>a-b)\\n    if(arr.length<3){\\n        return arr[arr.length-1]\\n    }\\n    return  arr[arr.length-3]\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1795299,
                "content": [
                    {
                        "username": "Undefeated22",
                        "content": "WHat to do\\n\\n"
                    },
                    {
                        "username": "jackere1",
                        "content": "When I print the all numbers in [5, 2, 2] case, It gives 5 2 2 2. My code is here and it gives wrong result:\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        for(int &x: nums) {\\n            cout << x << \" \";\\n        }\\n        set<int> numSet(nums.begin(), nums.end());\\n\\n        set<int>::iterator itr = numSet.end();\\n\\n        cout << *itr;\\n        if(numSet.size() < 3)\\n            return *itr;\\n\\n        advance(itr, -3);\\n        return *itr;\\n    }\\n};"
                    },
                    {
                        "username": "andresstawski",
                        "content": "someone knows why this doesnt work on [1,2,2,5,3,5]?\\n\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        \\n        nums.erase(std::unique(nums.begin(), nums.end()), nums.end());\\n        sort(nums.begin(), nums.end());\\n        if(nums.size() < 3) return nums[nums.size() - 1];\\n         \\n        int ans = nums[nums.size()-3];\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Since 3n belongs to O(n), trivial iterate-three-times solution is, in fact, O(n).\n\n3n belongs to O(n), as limit of 3n/n approaches 3, a finite non-zero number."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "for ar[1,2,2,5,3,5] my output is 5 ans expected output is 2 how??\\n"
                    },
                    {
                        "username": "haneesha11",
                        "content": "Firstly convert the list into set and sort the set in descending order (use reverse=True) then check if length of nums is greater then or equal to three if yes then return the element in the second index else return the first index\\n "
                    },
                    {
                        "username": "sunnycs121",
                        "content": "Why so many people disliked this question?"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "One of the possible solution would be put distinct element in some other vector and apply 3 passes of bubble sort it will take O(n) time but it also taking space O(n)"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Use Hash Map to store unique values <br> \\nMy Easy and simple Solution : -> \\n\\nhttps://leetcode.com/problems/third-maximum-number/solutions/3139423/c-easy-and-simple-solution/"
                    },
                    {
                        "username": "rafiul29",
                        "content": "# JavaScript  solution\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar thirdMax = function(nums) {\\n    let arr=[...new Set([...nums])]\\n    arr.sort((a,b)=>a-b)\\n    if(arr.length<3){\\n        return arr[arr.length-1]\\n    }\\n    return  arr[arr.length-3]\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1786924,
                "content": [
                    {
                        "username": "Undefeated22",
                        "content": "WHat to do\\n\\n"
                    },
                    {
                        "username": "jackere1",
                        "content": "When I print the all numbers in [5, 2, 2] case, It gives 5 2 2 2. My code is here and it gives wrong result:\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        for(int &x: nums) {\\n            cout << x << \" \";\\n        }\\n        set<int> numSet(nums.begin(), nums.end());\\n\\n        set<int>::iterator itr = numSet.end();\\n\\n        cout << *itr;\\n        if(numSet.size() < 3)\\n            return *itr;\\n\\n        advance(itr, -3);\\n        return *itr;\\n    }\\n};"
                    },
                    {
                        "username": "andresstawski",
                        "content": "someone knows why this doesnt work on [1,2,2,5,3,5]?\\n\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        \\n        nums.erase(std::unique(nums.begin(), nums.end()), nums.end());\\n        sort(nums.begin(), nums.end());\\n        if(nums.size() < 3) return nums[nums.size() - 1];\\n         \\n        int ans = nums[nums.size()-3];\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Since 3n belongs to O(n), trivial iterate-three-times solution is, in fact, O(n).\n\n3n belongs to O(n), as limit of 3n/n approaches 3, a finite non-zero number."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "for ar[1,2,2,5,3,5] my output is 5 ans expected output is 2 how??\\n"
                    },
                    {
                        "username": "haneesha11",
                        "content": "Firstly convert the list into set and sort the set in descending order (use reverse=True) then check if length of nums is greater then or equal to three if yes then return the element in the second index else return the first index\\n "
                    },
                    {
                        "username": "sunnycs121",
                        "content": "Why so many people disliked this question?"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "One of the possible solution would be put distinct element in some other vector and apply 3 passes of bubble sort it will take O(n) time but it also taking space O(n)"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Use Hash Map to store unique values <br> \\nMy Easy and simple Solution : -> \\n\\nhttps://leetcode.com/problems/third-maximum-number/solutions/3139423/c-easy-and-simple-solution/"
                    },
                    {
                        "username": "rafiul29",
                        "content": "# JavaScript  solution\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar thirdMax = function(nums) {\\n    let arr=[...new Set([...nums])]\\n    arr.sort((a,b)=>a-b)\\n    if(arr.length<3){\\n        return arr[arr.length-1]\\n    }\\n    return  arr[arr.length-3]\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1783761,
                "content": [
                    {
                        "username": "Undefeated22",
                        "content": "WHat to do\\n\\n"
                    },
                    {
                        "username": "jackere1",
                        "content": "When I print the all numbers in [5, 2, 2] case, It gives 5 2 2 2. My code is here and it gives wrong result:\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        for(int &x: nums) {\\n            cout << x << \" \";\\n        }\\n        set<int> numSet(nums.begin(), nums.end());\\n\\n        set<int>::iterator itr = numSet.end();\\n\\n        cout << *itr;\\n        if(numSet.size() < 3)\\n            return *itr;\\n\\n        advance(itr, -3);\\n        return *itr;\\n    }\\n};"
                    },
                    {
                        "username": "andresstawski",
                        "content": "someone knows why this doesnt work on [1,2,2,5,3,5]?\\n\\nclass Solution {\\npublic:\\n    int thirdMax(vector<int>& nums) {\\n        \\n        nums.erase(std::unique(nums.begin(), nums.end()), nums.end());\\n        sort(nums.begin(), nums.end());\\n        if(nums.size() < 3) return nums[nums.size() - 1];\\n         \\n        int ans = nums[nums.size()-3];\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Since 3n belongs to O(n), trivial iterate-three-times solution is, in fact, O(n).\n\n3n belongs to O(n), as limit of 3n/n approaches 3, a finite non-zero number."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "for ar[1,2,2,5,3,5] my output is 5 ans expected output is 2 how??\\n"
                    },
                    {
                        "username": "haneesha11",
                        "content": "Firstly convert the list into set and sort the set in descending order (use reverse=True) then check if length of nums is greater then or equal to three if yes then return the element in the second index else return the first index\\n "
                    },
                    {
                        "username": "sunnycs121",
                        "content": "Why so many people disliked this question?"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "One of the possible solution would be put distinct element in some other vector and apply 3 passes of bubble sort it will take O(n) time but it also taking space O(n)"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Use Hash Map to store unique values <br> \\nMy Easy and simple Solution : -> \\n\\nhttps://leetcode.com/problems/third-maximum-number/solutions/3139423/c-easy-and-simple-solution/"
                    },
                    {
                        "username": "rafiul29",
                        "content": "# JavaScript  solution\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar thirdMax = function(nums) {\\n    let arr=[...new Set([...nums])]\\n    arr.sort((a,b)=>a-b)\\n    if(arr.length<3){\\n        return arr[arr.length-1]\\n    }\\n    return  arr[arr.length-3]\\n};\\n```"
                    }
                ]
            }
        ]
    },
    {
        "title": "Freedom Trail",
        "question_content": "<p>In the video game Fallout 4, the quest <strong>&quot;Road to Freedom&quot;</strong> requires players to reach a metal dial called the <strong>&quot;Freedom Trail Ring&quot;</strong> and use the dial to spell a specific keyword to open the door.</p>\n\n<p>Given a string <code>ring</code> that represents the code engraved on the outer ring and another string <code>key</code> that represents the keyword that needs to be spelled, return <em>the minimum number of steps to spell all the characters in the keyword</em>.</p>\n\n<p>Initially, the first character of the ring is aligned at the <code>&quot;12:00&quot;</code> direction. You should spell all the characters in <code>key</code> one by one by rotating <code>ring</code> clockwise or anticlockwise to make each character of the string key aligned at the <code>&quot;12:00&quot;</code> direction and then by pressing the center button.</p>\n\n<p>At the stage of rotating the ring to spell the key character <code>key[i]</code>:</p>\n\n<ol>\n\t<li>You can rotate the ring clockwise or anticlockwise by one place, which counts as <strong>one step</strong>. The final purpose of the rotation is to align one of <code>ring</code>&#39;s characters at the <code>&quot;12:00&quot;</code> direction, where this character must equal <code>key[i]</code>.</li>\n\t<li>If the character <code>key[i]</code> has been aligned at the <code>&quot;12:00&quot;</code> direction, press the center button to spell, which also counts as <strong>one step</strong>. After the pressing, you could begin to spell the next character in the key (next stage). Otherwise, you have finished all the spelling.</li>\n</ol>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2018/10/22/ring.jpg\" style=\"width: 450px; height: 450px;\" />\n<pre>\n<strong>Input:</strong> ring = &quot;godding&quot;, key = &quot;gd&quot;\n<strong>Output:</strong> 4\n<strong>Explanation:</strong>\nFor the first key character &#39;g&#39;, since it is already in place, we just need 1 step to spell this character. \nFor the second key character &#39;d&#39;, we need to rotate the ring &quot;godding&quot; anticlockwise by two steps to make it become &quot;ddinggo&quot;.\nAlso, we need 1 more step for spelling.\nSo the final output is 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> ring = &quot;godding&quot;, key = &quot;godding&quot;\n<strong>Output:</strong> 13\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= ring.length, key.length &lt;= 100</code></li>\n\t<li><code>ring</code> and <code>key</code> consist of only lower case English letters.</li>\n\t<li>It is guaranteed that <code>key</code> could always be spelled by rotating <code>ring</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 98902,
                "title": "concise-java-dp-solution",
                "content": "```\\npublic class Solution {\\n    public int findRotateSteps(String ring, String key) {\\n        int n = ring.length();\\n        int m = key.length();\\n        int[][] dp = new int[m + 1][n];\\n        \\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j] = Integer.MAX_VALUE;\\n                for (int k = 0; k < n; k++) {\\n                    if (ring.charAt(k) == key.charAt(i)) {\\n                        int diff = Math.abs(j - k);\\n                        int step = Math.min(diff, n - diff);\\n                        dp[i][j] = Math.min(dp[i][j], step + dp[i + 1][k]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0] + m;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findRotateSteps(String ring, String key) {\\n        int n = ring.length();\\n        int m = key.length();\\n        int[][] dp = new int[m + 1][n];\\n        \\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j] = Integer.MAX_VALUE;\\n                for (int k = 0; k < n; k++) {\\n                    if (ring.charAt(k) == key.charAt(i)) {\\n                        int diff = Math.abs(j - k);\\n                        int step = Math.min(diff, n - diff);\\n                        dp[i][j] = Math.min(dp[i][j], step + dp[i + 1][k]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0] + m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98929,
                "title": "evolve-from-brute-force-to-dp",
                "content": "1. brute force, try all next steps.\\n```\\n    int findRotateSteps(string ring, string key) {\\n        vector<int> pos[26];\\n        for(int i=0;i<ring.size();i++) pos[ring[i]-'a'].push_back(i);\\n        return findSteps(0, 0, ring, key, pos);    \\n    }\\n    int findSteps(int p1, int p2, string &ring, string &key, vector<int> pos[26]) {\\n        if(p2==key.size()) return 0;\\n        int r = ring.size(), ms=INT_MAX;\\n        for(int nxt:pos[key[p2]-'a']) {\\n            int dist = abs(p1-nxt);\\n            ms = min(ms,min(dist, r-dist)+findSteps(nxt,p2+1,ring,key,pos));    \\n        }\\n        return ms+1;\\n    }\\n```\\n2. O(kr^2) Memoization. There are overlapping sub-problems in #1. We only need to process a substring of key once.\\n```\\n    int findRotateSteps(string ring, string key) {\\n        vector<int> pos[26];\\n        int r = ring.size();\\n        for(int i=0;i<r;i++) pos[ring[i]-'a'].push_back(i);\\n        vector<vector<int>> mem(r,vector<int>(key.size()));\\n        return findSteps(0, 0, ring, key, pos,mem);    \\n    }\\n    int findSteps(int p1, int p2, string &ring, string &key, vector<int> pos[26],vector<vector<int>>& mem) {\\n        if(p2==key.size()) return 0;\\n        if(mem[p1][p2]) return mem[p1][p2];\\n        int r = ring.size(), ms=INT_MAX;\\n        for(int nxt:pos[key[p2]-'a']) {\\n            int dist = abs(p1-nxt);\\n            ms = min(ms,min(dist, r-dist)+findSteps(nxt,p2+1,ring,key,pos,mem));    \\n        }\\n        return mem[p1][p2]=ms+1;\\n    }\\n```\\n3. O(kr^2) dp\\n```\\n    int findRotateSteps(string ring, string key) {\\n        vector<int> pos[26];\\n        int r = ring.size(), k = key.size();\\n        for(int i=0;i<r;i++) pos[ring[i]-'a'].push_back(i);\\n        vector<vector<int>> dp(k+1,vector<int>(r,INT_MAX));\\n        dp[k].assign(r,0);\\n        for(int i=k-1;i>=0;i--) \\n            for(int j=0;j<r;j++)\\n                for(int nxt:pos[key[i]-'a']) {\\n                    int dist = abs(j-nxt);\\n                    dp[i][j]=min(dp[i][j],min(dist,r-dist)+dp[i+1][nxt]);\\n                }\\n        return dp[0][0]+k;\\n    }\\n```\\n4. linear space dp\\n```\\n    int findRotateSteps(string ring, string key) {\\n        vector<int> pos[26];\\n        int r = ring.size(), k = key.size();\\n        for(int i=0;i<r;i++) pos[ring[i]-'a'].push_back(i);\\n        vector<int> pre(r), cur(r,INT_MAX), *p_pre = &pre, *p_cur = &cur;\\n        for(int i=k-1;i>=0;i--) {\\n            for(int j=0;j<r;j++)\\n                for(int nxt:pos[key[i]-'a']) {\\n                    int dist = abs(j-nxt);\\n                    (*p_cur)[j]=min((*p_cur)[j],min(dist,r-dist)+(*p_pre)[nxt]);\\n                }\\n            swap(p_pre,p_cur);\\n            p_cur->assign(r,INT_MAX);\\n        }\\n        return (*p_pre)[0]+k;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int findRotateSteps(string ring, string key) {\\n        vector<int> pos[26];\\n        for(int i=0;i<ring.size();i++) pos[ring[i]-'a'].push_back(i);\\n        return findSteps(0, 0, ring, key, pos);    \\n    }\\n    int findSteps(int p1, int p2, string &ring, string &key, vector<int> pos[26]) {\\n        if(p2==key.size()) return 0;\\n        int r = ring.size(), ms=INT_MAX;\\n        for(int nxt:pos[key[p2]-'a']) {\\n            int dist = abs(p1-nxt);\\n            ms = min(ms,min(dist, r-dist)+findSteps(nxt,p2+1,ring,key,pos));    \\n        }\\n        return ms+1;\\n    }\\n```\n```\\n    int findRotateSteps(string ring, string key) {\\n        vector<int> pos[26];\\n        int r = ring.size();\\n        for(int i=0;i<r;i++) pos[ring[i]-'a'].push_back(i);\\n        vector<vector<int>> mem(r,vector<int>(key.size()));\\n        return findSteps(0, 0, ring, key, pos,mem);    \\n    }\\n    int findSteps(int p1, int p2, string &ring, string &key, vector<int> pos[26],vector<vector<int>>& mem) {\\n        if(p2==key.size()) return 0;\\n        if(mem[p1][p2]) return mem[p1][p2];\\n        int r = ring.size(), ms=INT_MAX;\\n        for(int nxt:pos[key[p2]-'a']) {\\n            int dist = abs(p1-nxt);\\n            ms = min(ms,min(dist, r-dist)+findSteps(nxt,p2+1,ring,key,pos,mem));    \\n        }\\n        return mem[p1][p2]=ms+1;\\n    }\\n```\n```\\n    int findRotateSteps(string ring, string key) {\\n        vector<int> pos[26];\\n        int r = ring.size(), k = key.size();\\n        for(int i=0;i<r;i++) pos[ring[i]-'a'].push_back(i);\\n        vector<vector<int>> dp(k+1,vector<int>(r,INT_MAX));\\n        dp[k].assign(r,0);\\n        for(int i=k-1;i>=0;i--) \\n            for(int j=0;j<r;j++)\\n                for(int nxt:pos[key[i]-'a']) {\\n                    int dist = abs(j-nxt);\\n                    dp[i][j]=min(dp[i][j],min(dist,r-dist)+dp[i+1][nxt]);\\n                }\\n        return dp[0][0]+k;\\n    }\\n```\n```\\n    int findRotateSteps(string ring, string key) {\\n        vector<int> pos[26];\\n        int r = ring.size(), k = key.size();\\n        for(int i=0;i<r;i++) pos[ring[i]-'a'].push_back(i);\\n        vector<int> pre(r), cur(r,INT_MAX), *p_pre = &pre, *p_cur = &cur;\\n        for(int i=k-1;i>=0;i--) {\\n            for(int j=0;j<r;j++)\\n                for(int nxt:pos[key[i]-'a']) {\\n                    int dist = abs(j-nxt);\\n                    (*p_cur)[j]=min((*p_cur)[j],min(dist,r-dist)+(*p_pre)[nxt]);\\n                }\\n            swap(p_pre,p_cur);\\n            p_cur->assign(r,INT_MAX);\\n        }\\n        return (*p_pre)[0]+k;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 98916,
                "title": "super-clear-dfs-memorization-solution",
                "content": "\\n```\\npublic class Solution {\\n    public int findRotateSteps(String ring, String key) {\\n           Map<String,Integer> map = new HashMap();\\n           return dfs(ring, key, 0, map);\\n    }\\n    \\n    public int dfs(String ring, String key, int index, Map<String,Integer> map){\\n        if(index == key.length()){\\n            return 0;\\n        }\\n    \\n        char c = key.charAt(index);\\n        String hashKey = ring + index;\\n        if(map.containsKey(hashKey)) return map.get(hashKey);\\n        \\n        int minSteps = Integer.MAX_VALUE;\\n        for(int i = 0; i < ring.length(); i ++){\\n            if(ring.charAt(i) == c){\\n                String s = ring.substring(i, ring.length()) + ring.substring(0, i);\\n                int steps = 1 + Math.min(i, ring.length() - i);\\n                steps += dfs(s, key, index + 1, map);\\n                minSteps = Math.min(minSteps, steps);\\n            }\\n        }\\n        \\n        map.put(hashKey, minSteps);\\n        \\n        return minSteps;\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findRotateSteps(String ring, String key) {\\n           Map<String,Integer> map = new HashMap();\\n           return dfs(ring, key, 0, map);\\n    }\\n    \\n    public int dfs(String ring, String key, int index, Map<String,Integer> map){\\n        if(index == key.length()){\\n            return 0;\\n        }\\n    \\n        char c = key.charAt(index);\\n        String hashKey = ring + index;\\n        if(map.containsKey(hashKey)) return map.get(hashKey);\\n        \\n        int minSteps = Integer.MAX_VALUE;\\n        for(int i = 0; i < ring.length(); i ++){\\n            if(ring.charAt(i) == c){\\n                String s = ring.substring(i, ring.length()) + ring.substring(0, i);\\n                int steps = 1 + Math.min(i, ring.length() - i);\\n                steps += dfs(s, key, index + 1, map);\\n                minSteps = Math.min(minSteps, steps);\\n            }\\n        }\\n        \\n        map.put(hashKey, minSteps);\\n        \\n        return minSteps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1147789,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8  The ART of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\nLet `dp[i][j] `denote the minimum steps performed when the ring\\'s 12:00 direction (ie. \"setting\") is aligned with the `i`<sup>th</sup> index of `ring` to find the `j`<sup>th</sup> index of `key`.  Then the recurrence relation is `dp[i][j] = min(dp[i][j], 1 + steps(i, k) + dp[k][j + 1])` whenever `ring[k] == key[j]`.  Thus, we find each optimal `i`<sup>th</sup> `ring` \"setting\" by recursively considering each next optimal `k`<sup>th</sup> ring \"setting\" until the `j`<sup>th</sup> `key` has been reached (at cost `0` which is the base case \\uD83D\\uDED1 ).\\n\\nAn astute observer will notice the bottom-up solution can be memory optimized, ie. the current `j`<sup>th</sup> column\\'s optimal solution is only dependent upon the previous `j + 1`<sup>th</sup> column\\'s optimal solution, thus we can use `cur` and `pre` to denote the current `j`<sup>th</sup> column and previous `j + 1`<sup>th</sup> column correspondingly to reduce the memory consumption from `O(M * N)` to `O(M)`, ie. instead of storing the entire `dp` matrix in memory, we can simply store the current and previous columns in memory which results in `2 * M` cells since there are two columns, each of \"height\" `M` rows.  It follows, `2` is simply a constant factor removed from this enhanced asymptotic bound.\\n\\n---\\n\\n**Kotlin Solutions:**\\n\\n*Step 1: All possibilities are considered via top-down brute-force depth-first-search*\\n```\\nclass Solution {\\n    fun findRotateSteps(ring: String, key: String): Int {\\n        var M = ring.length\\n        var N = key.length\\n        fun steps(i: Int, k: Int): Int {\\n            var x = Math.abs(i - k)\\n            return Math.min(x, M - x) // \\u2B50\\uFE0F minimum x steps to rotate the ring from i..k (\\uD83D\\uDEAB without wrap-around, \\u2705 with wrap-around)\\n        }\\n        fun go(i: Int = 0, j: Int = 0): Int {\\n            if (j == N)\\n                return 0 // \\uD83D\\uDED1 base case\\n            var best = (1e9 + 7).toInt()\\n            for (k in 0 until M)\\n                if (ring[k] == key[j])\\n                    best = Math.min(best, 1 + steps(i, k) + go(k, j + 1)) // \\uD83C\\uDFAF min steps to reach key[j] from each ring[i] is the min steps to reach key[j + 1] from ring[k], \\uD83D\\uDD0D find optimal k via exhaustive search\\n            return best\\n        }\\n        return go() // \\uD83D\\uDE80 when the ring starts at i = 0 (ie. index 0 is aligned with the 12:00 direction of the ring) return the min steps to construct key[j = 0..N - 1]\\n    }\\n}\\n```\\n\\n*Step 2: Remember each subproblem\\'s optimal solution via a DP memo*\\n```\\nclass Solution {\\n    fun findRotateSteps(ring: String, key: String): Int {\\n        var m = mutableMapOf<String, Int>()\\n        var M = ring.length\\n        var N = key.length\\n        fun steps(i: Int, k: Int): Int {\\n            var x = Math.abs(i - k)\\n            return Math.min(x, M - x) // \\u2B50\\uFE0F minimum x steps to rotate the ring from i..k (\\uD83D\\uDEAB without wrap-around, \\u2705 with wrap-around)\\n        }\\n        fun go(i: Int = 0, j: Int = 0): Int {\\n            var hash = \"$i, $j\"\\n            if (m.contains(hash))\\n                return m[hash]!! // \\uD83E\\uDD14 memo\\n            if (j == N) {\\n                m[hash] = 0 // \\uD83D\\uDED1 base case\\n                return m[hash]!!\\n            }\\n            var best = (1e9 + 7).toInt()\\n            for (k in 0 until M)\\n                if (ring[k] == key[j])\\n                    best = Math.min(best, 1 + steps(i, k) + go(k, j + 1)) // \\uD83C\\uDFAF min steps to reach key[j] from each ring[i] is the min steps to reach key[j + 1] from ring[k], \\uD83D\\uDD0D find optimal k via exhaustive search\\n            m[hash] = best\\n            return m[hash]!!\\n        }\\n        return go() // \\uD83D\\uDE80 when the ring starts at i = 0 (ie. index 0 is aligned with the 12:00 direction of the ring) return the min steps to construct key[j = 0..N - 1]\\n    }\\n}\\n```\\n\\n*Step 3: Turn the top-down solution upside-down to create the bottom-up solution*\\n```\\nclass Solution {\\n    fun findRotateSteps(ring: String, key: String): Int {\\n        var M = ring.length\\n        var N = key.length\\n        fun steps(i: Int, k: Int): Int {\\n            var x = Math.abs(i - k)\\n            return Math.min(x, M - x) // \\u2B50\\uFE0F minimum x steps to rotate the ring from i..k (\\uD83D\\uDEAB without wrap-around, \\u2705 with wrap-around)\\n        }\\n        var INF = (1e9 + 7).toInt()\\n        var dp = Array(M){ Array(N + 1){ INF } } // \\uD83E\\uDD14 memo\\n        for (i in 0 until M)\\n            dp[i][N] = 0 // \\uD83D\\uDED1 base case\\n        for (j in N - 1 downTo 0)          // key j\\n            for (i in 0 until M)           // cur i\\n                for (k in 0 until M)       // pre i (optimal k-th value is found as the recursive stack unwinds)\\n                    if (ring[k] == key[j])\\n                        dp[i][j] = Math.min(dp[i][j], 1 + steps(i, k) + dp[k][j + 1]) // \\uD83C\\uDFAF min steps to reach key[j] from each ring[i] is the min steps to reach key[j + 1] from ring[k], \\uD83D\\uDD0D find optimal k via exhaustive search\\n        return dp[0][0] // \\uD83D\\uDE80 when the ring starts at i = 0 (ie. index 0 is aligned with the 12:00 direction of the ring) return the min steps to construct key[j = 0..N - 1]\\n    }\\n}\\n```\\n\\n*Step 4: Optional Memory Optimization*\\n```\\nclass Solution {\\n    fun findRotateSteps(ring: String, key: String): Int {\\n        var M = ring.length\\n        var N = key.length\\n        fun steps(i: Int, k: Int): Int {\\n            var x = Math.abs(i - k)\\n            return Math.min(x, M - x) // \\u2B50\\uFE0F minimum x steps to rotate the ring from i..k (\\uD83D\\uDEAB without wrap-around, \\u2705 with wrap-around)\\n        }\\n        var INF = (1e9 + 7).toInt()\\n        var pre = IntArray(M) { 0 } // \\uD83E\\uDD14 memo + \\uD83D\\uDED1 base case\\n        for (j in N - 1 downTo 0) {        // key j\\n            var cur = IntArray(M) { INF }\\n            for (i in 0 until M)           // cur i\\n                for (k in 0 until M)       // pre i (optimal k-th value is found as the recursive stack unwinds)\\n                    if (ring[k] == key[j])\\n                        cur[i] = Math.min(cur[i], 1 + steps(i, k) + pre[k]) // \\uD83C\\uDFAF min steps to reach key[j] from each ring[i] is the min steps to reach key[j + 1] from ring[k], \\uD83D\\uDD0D find optimal k via exhaustive search\\n            pre = cur.copyOf()\\n        }\\n        return pre[0] // \\uD83D\\uDE80 when the ring starts at i = 0 (ie. index 0 is aligned with the 12:00 direction of the ring) return the min steps to construct key[j = 0..N - 1]\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n\\n*Step 1: All possibilities are considered via top-down brute-force depth-first-search*\\n```\\nlet findRotateSteps = (ring, key) => {\\n    let M = ring.length,\\n        N = key.length;\\n    let steps = (i, k) => {\\n        let x = Math.abs(i - k);\\n        return Math.min(x, M - x); // \\u2B50\\uFE0F minimum x steps to rotate the ring from i..k (\\uD83D\\uDEAB without wrap-around, \\u2705 with wrap-around)\\n    };\\n    let go = (i = 0, j = 0, best = Infinity) => {\\n        if (j == N)\\n            return 0; // \\uD83D\\uDED1 base case\\n        for (let k = 0; k < M; ++k)\\n            if (ring[k] == key[j])\\n                best = Math.min(best, 1 + steps(i, k) + go(k, j + 1)); // \\uD83C\\uDFAF min steps to reach key[j] from each ring[i] is the min steps to reach key[j + 1] from ring[k], \\uD83D\\uDD0D find optimal k via exhaustive search\\n        return best;\\n    };\\n    return go(); // \\uD83D\\uDE80 when the ring starts at i = 0 (ie. index 0 is aligned with the 12:00 direction of the ring) return the min steps to construct key[j = 0..N - 1]\\n};\\n```\\n\\n*Step 2: Remember each subproblem\\'s optimal solution via a DP memo*\\n```\\nlet findRotateSteps = (ring, key, m = new Map()) => {\\n    let M = ring.length,\\n        N = key.length;\\n    let steps = (i, k) => {\\n        let x = Math.abs(i - k);\\n        return Math.min(x, M - x); // \\u2B50\\uFE0F minimum x steps to rotate the ring from i..k (\\uD83D\\uDEAB without wrap-around, \\u2705 with wrap-around)\\n    };\\n    let go = (i = 0, j = 0, best = Infinity) => {\\n        let hash = `${i},${j}`;\\n        if (m.has(hash))\\n            return m.get(hash); // \\uD83E\\uDD14 memo\\n        if (j == N)\\n            return m.set(hash, 0).get(hash); // \\uD83D\\uDED1 base case\\n        for (let k = 0; k < M; ++k)\\n            if (ring[k] == key[j])\\n                best = Math.min(best, 1 + steps(i, k) + go(k, j + 1)); // \\uD83C\\uDFAF min steps to reach key[j] from each ring[i] is the min steps to reach key[j + 1] from ring[k], \\uD83D\\uDD0D find optimal k via exhaustive search\\n        return m.set(hash, best).get(hash);\\n    };\\n    return go(); // \\uD83D\\uDE80 when the ring starts at i = 0 (ie. index 0 is aligned with the 12:00 direction of the ring) return the min steps to construct key[j = 0..N - 1]\\n};\\n```\\n\\n*Step 3: Turn the top-down solution upside-down to create the bottom-up solution*\\n```\\nlet findRotateSteps = (ring, key, m = new Map()) => {\\n    let M = ring.length,\\n        N = key.length;\\n    let steps = (i, k) => {\\n        let x = Math.abs(i - k);\\n        return Math.min(x, M - x); // \\u2B50\\uFE0F minimum x steps to rotate the ring from i..k (\\uD83D\\uDEAB without wrap-around, \\u2705 with wrap-around)\\n    };\\n    let dp = [...Array(M)].map(_ => Array(N + 1).fill(Infinity)); // \\uD83E\\uDD14 memo\\n    for (let i = 0; i < M; ++i)\\n        dp[i][N] = 0; // \\uD83D\\uDED1 base case\\n    for (let j = N - 1; 0 <= j; --j)    // key j\\n        for (let i = 0; i < M; ++i)     // cur i\\n            for (let k = 0; k < M; ++k) // pre i (optimal k-th value is found as the recursive stack unwinds)\\n                if (ring[k] == key[j])\\n                    dp[i][j] = Math.min(dp[i][j], 1 + steps(i, k) + dp[k][j + 1]); // \\uD83C\\uDFAF min steps to reach key[j] from each ring[i] is the min steps to reach key[j + 1] from ring[k], \\uD83D\\uDD0D find optimal k via exhaustive search\\n    return dp[0][0]; // \\uD83D\\uDE80 when the ring starts at i = 0 (ie. index 0 is aligned with the 12:00 direction of the ring) return the min steps to construct key[j = 0..N - 1]\\n};\\n```\\n\\n*Step 4: Optional Memory Optimization*\\n```\\nlet findRotateSteps = (ring, key, m = new Map()) => {\\n    let M = ring.length,\\n        N = key.length;\\n    let steps = (i, k) => {\\n        let x = Math.abs(i - k);\\n        return Math.min(x, M - x); // \\u2B50\\uFE0F minimum x steps to rotate the ring from i..k (\\uD83D\\uDEAB without wrap-around, \\u2705 with wrap-around)\\n    };\\n    let pre = Array(M).fill(0); // \\uD83E\\uDD14 memo + \\uD83D\\uDED1 base case\\n    for (let j = N - 1; 0 <= j; --j) {     // key j\\n        let cur = Array(M).fill(Infinity);\\n        for (let i = 0; i < M; ++i)        // cur i\\n            for (let k = 0; k < M; ++k)    // pre i (optimal k-th value is found as the recursive stack unwinds)\\n                if (ring[k] == key[j])\\n                    cur[i] = Math.min(cur[i], 1 + steps(i, k) + pre[k]); // \\uD83C\\uDFAF min steps to reach key[j] from each ring[i] is the min steps to reach key[j + 1] from ring[k], \\uD83D\\uDD0D find optimal k via exhaustive search\\n        pre = [...cur];\\n    }\\n        \\n    return pre[0]; // \\uD83D\\uDE80 when the ring starts at i = 0 (ie. index 0 is aligned with the 12:00 direction of the ring) return the min steps to construct key[j = 0..N - 1]\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:** Notice how awesomely simply it is to add memoization to the DFS exhaustive search of all possibilites, ie. we simply add the `@cache` decorator -- that was easy! \\uD83E\\uDD73 \\n\\n*Step 1: All possibilities are considered via top-down brute-force depth-first-search*\\n```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        M, N = len(ring), len(key)\\n        def steps(i, k):\\n            x = abs(i - k)\\n            return min(x, M - x) # \\u2B50\\uFE0F minimum x steps to rotate the ring from i..k (\\uD83D\\uDEAB without wrap-around, \\u2705 with wrap-around)\\n        def go(i = 0, j = 0, best = float(\\'inf\\')):\\n            if j == N:\\n                return 0 # \\uD83D\\uDED1 base case\\n            for k in range(M):\\n                if ring[k] == key[j]:\\n                    best = min(best, 1 + steps(i, k) + go(k, j + 1)) # \\uD83C\\uDFAF min steps to reach key[j] from each ring[i] is the min steps to reach key[j + 1] from ring[k], \\uD83D\\uDD0D find optimal k via exhaustive search\\n            return best\\n        return go() # \\uD83D\\uDE80 when the ring starts at i = 0 (ie. index 0 is aligned with the 12:00 direction of the ring) return the min steps to construct key[j = 0..N - 1]\\n```\\n\\n*Step 2: Remember each subproblem\\'s optimal solution via a DP memo*\\n```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        M, N = len(ring), len(key)\\n        def steps(i, k):\\n            x = abs(i - k)\\n            return min(x, M - x) # \\u2B50\\uFE0F minimum x steps to rotate the ring from i..k (\\uD83D\\uDEAB without wrap-around, \\u2705 with wrap-around)\\n        @cache # \\uD83E\\uDD14 memo, ie. that was easy! \\uD83E\\uDD73\\n        def go(i = 0, j = 0, best = float(\\'inf\\')):\\n            if j == N:\\n                return 0 # \\uD83D\\uDED1 base case\\n            for k in range(M):\\n                if ring[k] == key[j]:\\n                    best = min(best, 1 + steps(i, k) + go(k, j + 1)) # \\uD83C\\uDFAF min steps to reach key[j] from each ring[i] is the min steps to reach key[j + 1] from ring[k], \\uD83D\\uDD0D find optimal k via exhaustive search\\n            return best\\n        return go() # \\uD83D\\uDE80 when the ring starts at i = 0 (ie. index 0 is aligned with the 12:00 direction of the ring) return the min steps to construct key[j = 0..N - 1]\\n```\\n\\n*Step 3: Turn the top-down solution upside-down to create the bottom-up solution*\\n```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        M, N = len(ring), len(key)\\n        def steps(i, k):\\n            x = abs(i - k)\\n            return min(x, M - x) # \\u2B50\\uFE0F minimum x steps to rotate the ring from i..k (\\uD83D\\uDEAB without wrap-around, \\u2705 with wrap-around)\\n        dp = [[float(\\'inf\\') for _ in range(N + 1)] for _ in range(M)] # \\uD83E\\uDD14 memo\\n        for i in range(M):\\n            dp[i][N] = 0 # \\uD83D\\uDED1 base case\\n        for j in range(N - 1, -1, -1): # key j\\n            for i in range(M):         # cur i\\n                for k in range(M):     # pre i (optimal k-th value is found as the recursive stack unwinds)\\n                    if ring[k] == key[j]:\\n                        dp[i][j] = min(dp[i][j], 1 + steps(i, k) + dp[k][j + 1]) # \\uD83C\\uDFAF min steps to reach key[j] from each ring[i] is the min steps to reach key[j + 1] from ring[k], \\uD83D\\uDD0D find optimal k via exhaustive search\\n        return dp[0][0] # \\uD83D\\uDE80 when the ring starts at i = 0 (ie. index 0 is aligned with the 12:00 direction of the ring) return the min steps to construct key[j = 0..N - 1]\\n```\\n\\n*Step 4: Optional Memory Optimization*\\n```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        M, N = len(ring), len(key)\\n        def steps(i, k):\\n            x = abs(i - k)\\n            return min(x, M - x) # \\u2B50\\uFE0F minimum x steps to rotate the ring from i..k (\\uD83D\\uDEAB without wrap-around, \\u2705 with wrap-around)\\n        pre = [0] * M              # \\uD83E\\uDD14 memo + \\uD83D\\uDED1 base case (ie. pre[0..M-1] = 0)\\n        j = N - 1\\n        while 0 <= j:              # key j\\n            cur = [float(\\'inf\\')] * M\\n            for i in range(M):     # cur i\\n                for k in range(M): # pre i (optimal k-th value is found as the recursive stack unwinds)\\n                    if ring[k] == key[j]:\\n                        cur[i] = min(cur[i], 1 + steps(i, k) + pre[k]) # \\uD83C\\uDFAF min steps to reach key[j] from each ring[i] is the min steps to reach key[j + 1] from ring[k], \\uD83D\\uDD0D find optimal k via exhaustive search (\\'cur\\' denotes the current (j)th column and \\'pre\\' denotes the previous (j+1)th column)\\n            pre = cur.copy()\\n            j -= 1\\n        return pre[0] # \\uD83D\\uDE80 when the ring starts at i = 0 (ie. index 0 is aligned with the 12:00 direction of the ring) return the min steps to construct key[j = N - 1..0]\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n*Step 1: All possibilities are considered via top-down brute-force depth-first-search*\\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int, int)>;\\n    int findRotateSteps(string ring, string key, int INF = 1e9 + 7) {\\n        int M = ring.size(),\\n            N = key.size();\\n        auto steps = [=](auto i, auto k) {\\n            auto x = abs(i - k);\\n            return min(x, M - x); // \\u2B50\\uFE0F minimum x steps to rotate the ring from i..k (\\uD83D\\uDEAB without wrap-around, \\u2705 with wrap-around)\\n        };\\n        fun go = [&](auto i, auto j) {\\n            if (j == N)\\n                return 0; // \\uD83D\\uDED1 base case\\n            auto best = INF;\\n            for (auto k{ 0 }; k < M; ++k) // pre i (optimal k-th value is found as the recursive stack unwinds)\\n                if (ring[k] == key[j]) \\n                    best = min(best, 1 + steps(i, k) + go(k, j + 1)); // \\uD83C\\uDFAF min steps to reach key[j] from each ring[i] is the min steps to reach key[j + 1] from ring[k], \\uD83D\\uDD0D find optimal k via exhaustive search\\n            return best;\\n        };\\n        return go(0, 0); // \\uD83D\\uDE80 when the ring starts at i = 0 (ie. index 0 is aligned with the 12:00 direction of the ring) return the min steps to construct key[j = 0..N - 1]\\n    }\\n};\\n```\\n\\n*Step 2: Remember each subproblem\\'s optimal solution via a DP memo*\\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<int, unordered_map<int, int>>;\\n    int findRotateSteps(string ring, string key, int INF = 1e9 + 7, Map m = {}) {\\n        int M = ring.size(),\\n            N = key.size();\\n        auto steps = [=](auto i, auto k) {\\n            return min(abs(i - k), M - abs(i - k)); // \\u2B50\\uFE0F minimum x steps to rotate the ring from i..k (\\uD83D\\uDEAB without wrap-around, \\u2705 with wrap-around)\\n        };\\n        fun go = [&](auto i, auto j) {\\n            if (m[i][j])\\n                return m[i][j];     // \\uD83E\\uDD14 memo\\n            if (j == N)\\n                return m[i][j] = 0; // \\uD83D\\uDED1 base case\\n            auto best = INF;\\n            for (auto k{ 0 }; k < M; ++k) // pre i (optimal k-th value is found as the recursive stack unwinds)\\n                if (ring[k] == key[j])\\n                    best = min(best, 1 + steps(i, k) + go(k, j + 1)); // \\uD83C\\uDFAF min steps to reach key[j] from each ring[i] is the min steps to reach key[j + 1] from ring[k], \\uD83D\\uDD0D find optimal k via exhaustive search\\n            return m[i][j] = best;\\n        };\\n        return go(0, 0); // \\uD83D\\uDE80 when the ring starts at i = 0 (ie. index 0 is aligned with the 12:00 direction of the ring) return the min steps to construct key[j = 0..N - 1]\\n    }\\n};\\n```\\n\\n*Step 3: Turn the top-down solution upside-down to create the bottom-up solution*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int findRotateSteps(string ring, string key, int INF = 1e9 + 7) {\\n        int M = ring.size(),\\n            N = key.size();\\n        auto steps = [=](auto i, auto k) {\\n            return min(abs(i - k), M - abs(i - k)); // \\u2B50\\uFE0F minimum x steps to rotate the ring from i..k (\\uD83D\\uDEAB without wrap-around, \\u2705 with wrap-around)\\n        };\\n        VVI dp(M, VI(N + 1, INF));            // \\uD83E\\uDD14 memo\\n        for (auto i{ 0 }; i < M; ++i)\\n            for (auto k{ 0 }; k < M; ++k)\\n                dp[i][N] = 0;                 // \\uD83D\\uDED1 base case\\n        for (auto j{ N - 1 }; 0 <= j; --j)    // key j\\n            for (auto i{ 0 }; i < M; ++i)     // cur i\\n                for (auto k{ 0 }; k < M; ++k) // pre i (optimal k-th value is found as the recursive stack unwinds)\\n                    if (ring[k] == key[j])\\n                        dp[i][j] = min(dp[i][j], 1 + steps(i, k) + dp[k][j + 1]); // \\uD83C\\uDFAF min steps to reach key[j] from each ring[i] is the min steps to reach key[j + 1] from ring[k], \\uD83D\\uDD0D find optimal k via exhaustive search\\n        return dp[0][0]; // \\uD83D\\uDE80 when the ring starts at i = 0 (ie. index 0 is aligned with the 12:00 direction of the ring) return the min steps to construct key[j = 0..N - 1]\\n    }\\n};\\n```\\n\\n*Step 4: Optional Memory Optimization*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int findRotateSteps(string ring, string key, int INF = 1e9 + 7) {\\n        int M = ring.size(),\\n            N = key.size();\\n        auto steps = [=](auto i, auto k) {\\n            return min(abs(i - k), M - abs(i - k)); // \\u2B50\\uFE0F minimum of steps to rotate the ring from i..k (\\uD83D\\uDEAB without wrap-around, \\u2705 with wrap-around)\\n        };\\n        VI pre(M); // \\uD83E\\uDD14 memo + \\uD83D\\uDED1 base case (ie. pre is default initialized to contain all 0s)\\n        for (auto j{ N - 1 }; 0 <= j; --j) {  // key j\\n            VI cur(M, INF);\\n            for (auto i{ 0 }; i < M; ++i)     // cur i\\n                for (auto k{ 0 }; k < M; ++k) // pre i (optimal k-th value is found as the recursive stack unwinds)\\n                    if (ring[k] == key[j])\\n                        cur[i] = min(cur[i], 1 + steps(i, k) + pre[k]); // \\uD83C\\uDFAF min steps to reach key[j] from each ring[i] is the min steps to reach key[j + 1] from ring[k], \\uD83D\\uDD0D find optimal k via exhaustive search\\n            swap(pre, cur);\\n        }\\n        return pre[0]; // \\uD83D\\uDE80 when the ring starts at i = 0 (ie. index 0 is aligned with the 12:00 direction of the ring) return the min steps to construct key[j = 0..N - 1]\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun findRotateSteps(ring: String, key: String): Int {\\n        var M = ring.length\\n        var N = key.length\\n        fun steps(i: Int, k: Int): Int {\\n            var x = Math.abs(i - k)\\n            return Math.min(x, M - x) // \\u2B50\\uFE0F minimum x steps to rotate the ring from i..k (\\uD83D\\uDEAB without wrap-around, \\u2705 with wrap-around)\\n        }\\n        fun go(i: Int = 0, j: Int = 0): Int {\\n            if (j == N)\\n                return 0 // \\uD83D\\uDED1 base case\\n            var best = (1e9 + 7).toInt()\\n            for (k in 0 until M)\\n                if (ring[k] == key[j])\\n                    best = Math.min(best, 1 + steps(i, k) + go(k, j + 1)) // \\uD83C\\uDFAF min steps to reach key[j] from each ring[i] is the min steps to reach key[j + 1] from ring[k], \\uD83D\\uDD0D find optimal k via exhaustive search\\n            return best\\n        }\\n        return go() // \\uD83D\\uDE80 when the ring starts at i = 0 (ie. index 0 is aligned with the 12:00 direction of the ring) return the min steps to construct key[j = 0..N - 1]\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun findRotateSteps(ring: String, key: String): Int {\\n        var m = mutableMapOf<String, Int>()\\n        var M = ring.length\\n        var N = key.length\\n        fun steps(i: Int, k: Int): Int {\\n            var x = Math.abs(i - k)\\n            return Math.min(x, M - x) // \\u2B50\\uFE0F minimum x steps to rotate the ring from i..k (\\uD83D\\uDEAB without wrap-around, \\u2705 with wrap-around)\\n        }\\n        fun go(i: Int = 0, j: Int = 0): Int {\\n            var hash = \"$i, $j\"\\n            if (m.contains(hash))\\n                return m[hash]!! // \\uD83E\\uDD14 memo\\n            if (j == N) {\\n                m[hash] = 0 // \\uD83D\\uDED1 base case\\n                return m[hash]!!\\n            }\\n            var best = (1e9 + 7).toInt()\\n            for (k in 0 until M)\\n                if (ring[k] == key[j])\\n                    best = Math.min(best, 1 + steps(i, k) + go(k, j + 1)) // \\uD83C\\uDFAF min steps to reach key[j] from each ring[i] is the min steps to reach key[j + 1] from ring[k], \\uD83D\\uDD0D find optimal k via exhaustive search\\n            m[hash] = best\\n            return m[hash]!!\\n        }\\n        return go() // \\uD83D\\uDE80 when the ring starts at i = 0 (ie. index 0 is aligned with the 12:00 direction of the ring) return the min steps to construct key[j = 0..N - 1]\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun findRotateSteps(ring: String, key: String): Int {\\n        var M = ring.length\\n        var N = key.length\\n        fun steps(i: Int, k: Int): Int {\\n            var x = Math.abs(i - k)\\n            return Math.min(x, M - x) // \\u2B50\\uFE0F minimum x steps to rotate the ring from i..k (\\uD83D\\uDEAB without wrap-around, \\u2705 with wrap-around)\\n        }\\n        var INF = (1e9 + 7).toInt()\\n        var dp = Array(M){ Array(N + 1){ INF } } // \\uD83E\\uDD14 memo\\n        for (i in 0 until M)\\n            dp[i][N] = 0 // \\uD83D\\uDED1 base case\\n        for (j in N - 1 downTo 0)          // key j\\n            for (i in 0 until M)           // cur i\\n                for (k in 0 until M)       // pre i (optimal k-th value is found as the recursive stack unwinds)\\n                    if (ring[k] == key[j])\\n                        dp[i][j] = Math.min(dp[i][j], 1 + steps(i, k) + dp[k][j + 1]) // \\uD83C\\uDFAF min steps to reach key[j] from each ring[i] is the min steps to reach key[j + 1] from ring[k], \\uD83D\\uDD0D find optimal k via exhaustive search\\n        return dp[0][0] // \\uD83D\\uDE80 when the ring starts at i = 0 (ie. index 0 is aligned with the 12:00 direction of the ring) return the min steps to construct key[j = 0..N - 1]\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun findRotateSteps(ring: String, key: String): Int {\\n        var M = ring.length\\n        var N = key.length\\n        fun steps(i: Int, k: Int): Int {\\n            var x = Math.abs(i - k)\\n            return Math.min(x, M - x) // \\u2B50\\uFE0F minimum x steps to rotate the ring from i..k (\\uD83D\\uDEAB without wrap-around, \\u2705 with wrap-around)\\n        }\\n        var INF = (1e9 + 7).toInt()\\n        var pre = IntArray(M) { 0 } // \\uD83E\\uDD14 memo + \\uD83D\\uDED1 base case\\n        for (j in N - 1 downTo 0) {        // key j\\n            var cur = IntArray(M) { INF }\\n            for (i in 0 until M)           // cur i\\n                for (k in 0 until M)       // pre i (optimal k-th value is found as the recursive stack unwinds)\\n                    if (ring[k] == key[j])\\n                        cur[i] = Math.min(cur[i], 1 + steps(i, k) + pre[k]) // \\uD83C\\uDFAF min steps to reach key[j] from each ring[i] is the min steps to reach key[j + 1] from ring[k], \\uD83D\\uDD0D find optimal k via exhaustive search\\n            pre = cur.copyOf()\\n        }\\n        return pre[0] // \\uD83D\\uDE80 when the ring starts at i = 0 (ie. index 0 is aligned with the 12:00 direction of the ring) return the min steps to construct key[j = 0..N - 1]\\n    }\\n}\\n```\n```\\nlet findRotateSteps = (ring, key) => {\\n    let M = ring.length,\\n        N = key.length;\\n    let steps = (i, k) => {\\n        let x = Math.abs(i - k);\\n        return Math.min(x, M - x); // \\u2B50\\uFE0F minimum x steps to rotate the ring from i..k (\\uD83D\\uDEAB without wrap-around, \\u2705 with wrap-around)\\n    };\\n    let go = (i = 0, j = 0, best = Infinity) => {\\n        if (j == N)\\n            return 0; // \\uD83D\\uDED1 base case\\n        for (let k = 0; k < M; ++k)\\n            if (ring[k] == key[j])\\n                best = Math.min(best, 1 + steps(i, k) + go(k, j + 1)); // \\uD83C\\uDFAF min steps to reach key[j] from each ring[i] is the min steps to reach key[j + 1] from ring[k], \\uD83D\\uDD0D find optimal k via exhaustive search\\n        return best;\\n    };\\n    return go(); // \\uD83D\\uDE80 when the ring starts at i = 0 (ie. index 0 is aligned with the 12:00 direction of the ring) return the min steps to construct key[j = 0..N - 1]\\n};\\n```\n```\\nlet findRotateSteps = (ring, key, m = new Map()) => {\\n    let M = ring.length,\\n        N = key.length;\\n    let steps = (i, k) => {\\n        let x = Math.abs(i - k);\\n        return Math.min(x, M - x); // \\u2B50\\uFE0F minimum x steps to rotate the ring from i..k (\\uD83D\\uDEAB without wrap-around, \\u2705 with wrap-around)\\n    };\\n    let go = (i = 0, j = 0, best = Infinity) => {\\n        let hash = `${i},${j}`;\\n        if (m.has(hash))\\n            return m.get(hash); // \\uD83E\\uDD14 memo\\n        if (j == N)\\n            return m.set(hash, 0).get(hash); // \\uD83D\\uDED1 base case\\n        for (let k = 0; k < M; ++k)\\n            if (ring[k] == key[j])\\n                best = Math.min(best, 1 + steps(i, k) + go(k, j + 1)); // \\uD83C\\uDFAF min steps to reach key[j] from each ring[i] is the min steps to reach key[j + 1] from ring[k], \\uD83D\\uDD0D find optimal k via exhaustive search\\n        return m.set(hash, best).get(hash);\\n    };\\n    return go(); // \\uD83D\\uDE80 when the ring starts at i = 0 (ie. index 0 is aligned with the 12:00 direction of the ring) return the min steps to construct key[j = 0..N - 1]\\n};\\n```\n```\\nlet findRotateSteps = (ring, key, m = new Map()) => {\\n    let M = ring.length,\\n        N = key.length;\\n    let steps = (i, k) => {\\n        let x = Math.abs(i - k);\\n        return Math.min(x, M - x); // \\u2B50\\uFE0F minimum x steps to rotate the ring from i..k (\\uD83D\\uDEAB without wrap-around, \\u2705 with wrap-around)\\n    };\\n    let dp = [...Array(M)].map(_ => Array(N + 1).fill(Infinity)); // \\uD83E\\uDD14 memo\\n    for (let i = 0; i < M; ++i)\\n        dp[i][N] = 0; // \\uD83D\\uDED1 base case\\n    for (let j = N - 1; 0 <= j; --j)    // key j\\n        for (let i = 0; i < M; ++i)     // cur i\\n            for (let k = 0; k < M; ++k) // pre i (optimal k-th value is found as the recursive stack unwinds)\\n                if (ring[k] == key[j])\\n                    dp[i][j] = Math.min(dp[i][j], 1 + steps(i, k) + dp[k][j + 1]); // \\uD83C\\uDFAF min steps to reach key[j] from each ring[i] is the min steps to reach key[j + 1] from ring[k], \\uD83D\\uDD0D find optimal k via exhaustive search\\n    return dp[0][0]; // \\uD83D\\uDE80 when the ring starts at i = 0 (ie. index 0 is aligned with the 12:00 direction of the ring) return the min steps to construct key[j = 0..N - 1]\\n};\\n```\n```\\nlet findRotateSteps = (ring, key, m = new Map()) => {\\n    let M = ring.length,\\n        N = key.length;\\n    let steps = (i, k) => {\\n        let x = Math.abs(i - k);\\n        return Math.min(x, M - x); // \\u2B50\\uFE0F minimum x steps to rotate the ring from i..k (\\uD83D\\uDEAB without wrap-around, \\u2705 with wrap-around)\\n    };\\n    let pre = Array(M).fill(0); // \\uD83E\\uDD14 memo + \\uD83D\\uDED1 base case\\n    for (let j = N - 1; 0 <= j; --j) {     // key j\\n        let cur = Array(M).fill(Infinity);\\n        for (let i = 0; i < M; ++i)        // cur i\\n            for (let k = 0; k < M; ++k)    // pre i (optimal k-th value is found as the recursive stack unwinds)\\n                if (ring[k] == key[j])\\n                    cur[i] = Math.min(cur[i], 1 + steps(i, k) + pre[k]); // \\uD83C\\uDFAF min steps to reach key[j] from each ring[i] is the min steps to reach key[j + 1] from ring[k], \\uD83D\\uDD0D find optimal k via exhaustive search\\n        pre = [...cur];\\n    }\\n        \\n    return pre[0]; // \\uD83D\\uDE80 when the ring starts at i = 0 (ie. index 0 is aligned with the 12:00 direction of the ring) return the min steps to construct key[j = 0..N - 1]\\n};\\n```\n```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        M, N = len(ring), len(key)\\n        def steps(i, k):\\n            x = abs(i - k)\\n            return min(x, M - x) # \\u2B50\\uFE0F minimum x steps to rotate the ring from i..k (\\uD83D\\uDEAB without wrap-around, \\u2705 with wrap-around)\\n        def go(i = 0, j = 0, best = float(\\'inf\\')):\\n            if j == N:\\n                return 0 # \\uD83D\\uDED1 base case\\n            for k in range(M):\\n                if ring[k] == key[j]:\\n                    best = min(best, 1 + steps(i, k) + go(k, j + 1)) # \\uD83C\\uDFAF min steps to reach key[j] from each ring[i] is the min steps to reach key[j + 1] from ring[k], \\uD83D\\uDD0D find optimal k via exhaustive search\\n            return best\\n        return go() # \\uD83D\\uDE80 when the ring starts at i = 0 (ie. index 0 is aligned with the 12:00 direction of the ring) return the min steps to construct key[j = 0..N - 1]\\n```\n```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        M, N = len(ring), len(key)\\n        def steps(i, k):\\n            x = abs(i - k)\\n            return min(x, M - x) # \\u2B50\\uFE0F minimum x steps to rotate the ring from i..k (\\uD83D\\uDEAB without wrap-around, \\u2705 with wrap-around)\\n        @cache # \\uD83E\\uDD14 memo, ie. that was easy! \\uD83E\\uDD73\\n        def go(i = 0, j = 0, best = float(\\'inf\\')):\\n            if j == N:\\n                return 0 # \\uD83D\\uDED1 base case\\n            for k in range(M):\\n                if ring[k] == key[j]:\\n                    best = min(best, 1 + steps(i, k) + go(k, j + 1)) # \\uD83C\\uDFAF min steps to reach key[j] from each ring[i] is the min steps to reach key[j + 1] from ring[k], \\uD83D\\uDD0D find optimal k via exhaustive search\\n            return best\\n        return go() # \\uD83D\\uDE80 when the ring starts at i = 0 (ie. index 0 is aligned with the 12:00 direction of the ring) return the min steps to construct key[j = 0..N - 1]\\n```\n```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        M, N = len(ring), len(key)\\n        def steps(i, k):\\n            x = abs(i - k)\\n            return min(x, M - x) # \\u2B50\\uFE0F minimum x steps to rotate the ring from i..k (\\uD83D\\uDEAB without wrap-around, \\u2705 with wrap-around)\\n        dp = [[float(\\'inf\\') for _ in range(N + 1)] for _ in range(M)] # \\uD83E\\uDD14 memo\\n        for i in range(M):\\n            dp[i][N] = 0 # \\uD83D\\uDED1 base case\\n        for j in range(N - 1, -1, -1): # key j\\n            for i in range(M):         # cur i\\n                for k in range(M):     # pre i (optimal k-th value is found as the recursive stack unwinds)\\n                    if ring[k] == key[j]:\\n                        dp[i][j] = min(dp[i][j], 1 + steps(i, k) + dp[k][j + 1]) # \\uD83C\\uDFAF min steps to reach key[j] from each ring[i] is the min steps to reach key[j + 1] from ring[k], \\uD83D\\uDD0D find optimal k via exhaustive search\\n        return dp[0][0] # \\uD83D\\uDE80 when the ring starts at i = 0 (ie. index 0 is aligned with the 12:00 direction of the ring) return the min steps to construct key[j = 0..N - 1]\\n```\n```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        M, N = len(ring), len(key)\\n        def steps(i, k):\\n            x = abs(i - k)\\n            return min(x, M - x) # \\u2B50\\uFE0F minimum x steps to rotate the ring from i..k (\\uD83D\\uDEAB without wrap-around, \\u2705 with wrap-around)\\n        pre = [0] * M              # \\uD83E\\uDD14 memo + \\uD83D\\uDED1 base case (ie. pre[0..M-1] = 0)\\n        j = N - 1\\n        while 0 <= j:              # key j\\n            cur = [float(\\'inf\\')] * M\\n            for i in range(M):     # cur i\\n                for k in range(M): # pre i (optimal k-th value is found as the recursive stack unwinds)\\n                    if ring[k] == key[j]:\\n                        cur[i] = min(cur[i], 1 + steps(i, k) + pre[k]) # \\uD83C\\uDFAF min steps to reach key[j] from each ring[i] is the min steps to reach key[j + 1] from ring[k], \\uD83D\\uDD0D find optimal k via exhaustive search (\\'cur\\' denotes the current (j)th column and \\'pre\\' denotes the previous (j+1)th column)\\n            pre = cur.copy()\\n            j -= 1\\n        return pre[0] # \\uD83D\\uDE80 when the ring starts at i = 0 (ie. index 0 is aligned with the 12:00 direction of the ring) return the min steps to construct key[j = N - 1..0]\\n```\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int, int)>;\\n    int findRotateSteps(string ring, string key, int INF = 1e9 + 7) {\\n        int M = ring.size(),\\n            N = key.size();\\n        auto steps = [=](auto i, auto k) {\\n            auto x = abs(i - k);\\n            return min(x, M - x); // \\u2B50\\uFE0F minimum x steps to rotate the ring from i..k (\\uD83D\\uDEAB without wrap-around, \\u2705 with wrap-around)\\n        };\\n        fun go = [&](auto i, auto j) {\\n            if (j == N)\\n                return 0; // \\uD83D\\uDED1 base case\\n            auto best = INF;\\n            for (auto k{ 0 }; k < M; ++k) // pre i (optimal k-th value is found as the recursive stack unwinds)\\n                if (ring[k] == key[j]) \\n                    best = min(best, 1 + steps(i, k) + go(k, j + 1)); // \\uD83C\\uDFAF min steps to reach key[j] from each ring[i] is the min steps to reach key[j + 1] from ring[k], \\uD83D\\uDD0D find optimal k via exhaustive search\\n            return best;\\n        };\\n        return go(0, 0); // \\uD83D\\uDE80 when the ring starts at i = 0 (ie. index 0 is aligned with the 12:00 direction of the ring) return the min steps to construct key[j = 0..N - 1]\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<int, unordered_map<int, int>>;\\n    int findRotateSteps(string ring, string key, int INF = 1e9 + 7, Map m = {}) {\\n        int M = ring.size(),\\n            N = key.size();\\n        auto steps = [=](auto i, auto k) {\\n            return min(abs(i - k), M - abs(i - k)); // \\u2B50\\uFE0F minimum x steps to rotate the ring from i..k (\\uD83D\\uDEAB without wrap-around, \\u2705 with wrap-around)\\n        };\\n        fun go = [&](auto i, auto j) {\\n            if (m[i][j])\\n                return m[i][j];     // \\uD83E\\uDD14 memo\\n            if (j == N)\\n                return m[i][j] = 0; // \\uD83D\\uDED1 base case\\n            auto best = INF;\\n            for (auto k{ 0 }; k < M; ++k) // pre i (optimal k-th value is found as the recursive stack unwinds)\\n                if (ring[k] == key[j])\\n                    best = min(best, 1 + steps(i, k) + go(k, j + 1)); // \\uD83C\\uDFAF min steps to reach key[j] from each ring[i] is the min steps to reach key[j + 1] from ring[k], \\uD83D\\uDD0D find optimal k via exhaustive search\\n            return m[i][j] = best;\\n        };\\n        return go(0, 0); // \\uD83D\\uDE80 when the ring starts at i = 0 (ie. index 0 is aligned with the 12:00 direction of the ring) return the min steps to construct key[j = 0..N - 1]\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int findRotateSteps(string ring, string key, int INF = 1e9 + 7) {\\n        int M = ring.size(),\\n            N = key.size();\\n        auto steps = [=](auto i, auto k) {\\n            return min(abs(i - k), M - abs(i - k)); // \\u2B50\\uFE0F minimum x steps to rotate the ring from i..k (\\uD83D\\uDEAB without wrap-around, \\u2705 with wrap-around)\\n        };\\n        VVI dp(M, VI(N + 1, INF));            // \\uD83E\\uDD14 memo\\n        for (auto i{ 0 }; i < M; ++i)\\n            for (auto k{ 0 }; k < M; ++k)\\n                dp[i][N] = 0;                 // \\uD83D\\uDED1 base case\\n        for (auto j{ N - 1 }; 0 <= j; --j)    // key j\\n            for (auto i{ 0 }; i < M; ++i)     // cur i\\n                for (auto k{ 0 }; k < M; ++k) // pre i (optimal k-th value is found as the recursive stack unwinds)\\n                    if (ring[k] == key[j])\\n                        dp[i][j] = min(dp[i][j], 1 + steps(i, k) + dp[k][j + 1]); // \\uD83C\\uDFAF min steps to reach key[j] from each ring[i] is the min steps to reach key[j + 1] from ring[k], \\uD83D\\uDD0D find optimal k via exhaustive search\\n        return dp[0][0]; // \\uD83D\\uDE80 when the ring starts at i = 0 (ie. index 0 is aligned with the 12:00 direction of the ring) return the min steps to construct key[j = 0..N - 1]\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int findRotateSteps(string ring, string key, int INF = 1e9 + 7) {\\n        int M = ring.size(),\\n            N = key.size();\\n        auto steps = [=](auto i, auto k) {\\n            return min(abs(i - k), M - abs(i - k)); // \\u2B50\\uFE0F minimum of steps to rotate the ring from i..k (\\uD83D\\uDEAB without wrap-around, \\u2705 with wrap-around)\\n        };\\n        VI pre(M); // \\uD83E\\uDD14 memo + \\uD83D\\uDED1 base case (ie. pre is default initialized to contain all 0s)\\n        for (auto j{ N - 1 }; 0 <= j; --j) {  // key j\\n            VI cur(M, INF);\\n            for (auto i{ 0 }; i < M; ++i)     // cur i\\n                for (auto k{ 0 }; k < M; ++k) // pre i (optimal k-th value is found as the recursive stack unwinds)\\n                    if (ring[k] == key[j])\\n                        cur[i] = min(cur[i], 1 + steps(i, k) + pre[k]); // \\uD83C\\uDFAF min steps to reach key[j] from each ring[i] is the min steps to reach key[j + 1] from ring[k], \\uD83D\\uDD0D find optimal k via exhaustive search\\n            swap(pre, cur);\\n        }\\n        return pre[0]; // \\uD83D\\uDE80 when the ring starts at i = 0 (ie. index 0 is aligned with the 12:00 direction of the ring) return the min steps to construct key[j = 0..N - 1]\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98897,
                "title": "java-clear-solution-dfs-memoization",
                "content": "Hi There! The key point in the problem is to make decision whether to move clockwise or anticlockwise. Actually to get optimal answer, we have to move clockwise for some characters of ```key``` and anti-clockwise for others. If apply brute force, then for each position in ```key``` we have two options,\\n  * Search for the character clockwise\\n  * Search for the character anti-clockwise\\n\\nTo find optimal answer we need to try both options and get minimum of them. Thus, we obtain ```dfs solution``` for the problem. But, there are duplicate calculation for some positions. Therefore, we need to memorize ```states```. The ```state``` is defined by position of the```ring``` and the index of character in the ```key```. This way, we can avoid calculating number of steps for the same state. Code will clarify the idea more.\\n```\\npublic class Solution {\\n    Map<String, Map<Integer, Integer>> memo;\\n    public int findRotateSteps(String ring, String key) {\\n        memo = new HashMap<>();\\n        return dfs(ring, key, 0);\\n    }\\n    \\n    private int findPos(String ring, char ch){ // find first occurrence clockwise\\n        return ring.indexOf(ch);\\n    }\\n    \\n    private int findBackPos(String ring, char ch){ //find first occurrence  anti-clockwise\\n        if(ring.charAt(0) == ch) return 0;\\n        for(int i = ring.length()-1;i>0;i--){\\n            if(ring.charAt(i) == ch) return i;\\n        }\\n        return 0;\\n    }\\n    \\n    private int dfs(String ring, String key, int i){\\n        if(i == key.length()) return 0;\\n        int res = 0;\\n        char ch = key.charAt(i);\\n        if(memo.containsKey(ring) && memo.get(ring).containsKey(i)) return memo.get(ring).get(i);\\n        int f = findPos(ring, ch);\\n        int b = findBackPos(ring, ch);\\n        int forward = 1+f+dfs(ring.substring(f)+ring.substring(0, f), key, i+1);\\n        int back = 1+ring.length()-b + dfs(ring.substring(b)+ring.substring(0, b),key, i+1);\\n        res = Math.min(forward, back);\\n        Map<Integer, Integer> ans = memo.getOrDefault(ring, new HashMap<>());\\n        ans.put(i, res);\\n        memo.put(ring, ans);\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "```key```\n```key```\n```dfs solution```\n```states```\n```state```\n```ring```\n```key```",
                "codeTag": "Unknown"
            },
            {
                "id": 159154,
                "title": "my-7-lines-python-dp-solution-beats-100-124-ms",
                "content": "* Store every index of every character in ring in indexes hashtable\\n* Initialize steps for every index in ring in DP\\n* For first character of key, update every DP[i] as distance btw zero index plus 1 step for press\\n* For every next character in key, update every DP[i] as min distance btw pre indexes plus 1 step for press\\n* Return min DP for last character of key\\n```\\nclass Solution:\\n    def findRotateSteps(self, ring, key):\\n        indexes, n, dp, pre = collections.defaultdict(list), len(ring), [0] * len(ring), key[0]\\n        for i, c in enumerate(ring):\\n            indexes[c].append(i)\\n        for i in indexes[key[0]]:\\n            dp[i] = min(i, n - i) + 1\\n        for c in key[1:]:\\n            for i in indexes[c]:\\n                dp[i] = min(dp[j] + min(i - j, j + n - i) if i >= j else dp[j] + min(j - i, i + n - j) for j in indexes[pre]) + 1\\n            pre = c\\n        return min(dp[i] for i in indexes[key[-1]])\\n```\\nCompressed\\n```\\nclass Solution:\\n    def findRotateSteps(self, ring, key):\\n        ind, n, dp, pre = collections.defaultdict(list), len(ring), [0] * len(ring), key[0]\\n        for i, c in enumerate(ring): ind[c].append(i)\\n        for i in ind[key[0]]: dp[i] = min(i, n - i) + 1\\n        for c in key[1:]:\\n            for i in ind[c]: dp[i] = min(dp[j] + min(i - j, j + n - i) if i >= j else dp[j] + min(j - i, i + n - j) for j in ind[pre]) + 1\\n            pre = c\\n        return min(dp[i] for i in ind[key[-1]])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findRotateSteps(self, ring, key):\\n        indexes, n, dp, pre = collections.defaultdict(list), len(ring), [0] * len(ring), key[0]\\n        for i, c in enumerate(ring):\\n            indexes[c].append(i)\\n        for i in indexes[key[0]]:\\n            dp[i] = min(i, n - i) + 1\\n        for c in key[1:]:\\n            for i in indexes[c]:\\n                dp[i] = min(dp[j] + min(i - j, j + n - i) if i >= j else dp[j] + min(j - i, i + n - j) for j in indexes[pre]) + 1\\n            pre = c\\n        return min(dp[i] for i in indexes[key[-1]])\\n```\n```\\nclass Solution:\\n    def findRotateSteps(self, ring, key):\\n        ind, n, dp, pre = collections.defaultdict(list), len(ring), [0] * len(ring), key[0]\\n        for i, c in enumerate(ring): ind[c].append(i)\\n        for i in ind[key[0]]: dp[i] = min(i, n - i) + 1\\n        for c in key[1:]:\\n            for i in ind[c]: dp[i] = min(dp[j] + min(i - j, j + n - i) if i >= j else dp[j] + min(j - i, i + n - j) for j in ind[pre]) + 1\\n            pre = c\\n        return min(dp[i] for i in ind[key[-1]])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 194601,
                "title": "dp-solution-with-detailed-text-and-video-explanation",
                "content": "## LeetCode 514. Freedom Trail\\n### Note\\nIf you prefer video over text, please check out this link: https://www.youtube.com/watch?v=e3vDi0NvIzU\\nwhich has the same content as follows.\\n### Explanation\\n```cpp\\n// Given a string ring:\\n\\n  0   1   2   3   4   5   6\\n+---+---+---+---+---+---+---+\\n| G | O | D | D | I | N | G |\\n+---+---+---+---+---+---+---+\\n\\n// and keyword \"GDI\"\\n\\n      0   1   2   3   4   5   6\\n    +---+---+---+---+---+---+---+\\n    | G | O | D | D | I | N | G |\\n    +---+---+---+---+---+---+---+\\n  G | 1 |   |   |   |   |   | 2 |\\n  D |   |   | 4 | 5 |   |   |   |\\n  I |   |   |   |   | 7 |   |   |                 \\n\\n// For the first character G of KEY \"GDI\", \\n// we have two Gs in the string ring, ring[0] and ring[6], \\n// Let OPT(KEY) denote the minimum number of steps to spell KEY.\\nKEY: G\\n// If we choose G0\\nOPT(G0) = 0 + 1 = 1\\n// If we choose G6\\nOPT(G6) = 1 + 1 = 2\\n\\n// For the second character D of KEY \"GDI\", \\n// we have two Ds in the string ring, ring[2] and ring[3], \\nKEY: GD\\n// and the ring now points to G (G0 or G6).\\n// If we choose D2\\nOPT(GD2) = min(OPT(G0) + G0->D2, OPT(G6) + G6->D2) + 1 = 4\\n// If we choose D3\\nOPT(GD3) = min(OPT(G0) + G0->D3, OPT(G6) + G6->D3) + 1 = 5\\n\\n// For the third character I of KEY \"GDI\", \\n// we have one I in the ring string, ring[4], \\n// and the ring now points to D (D2 or D3).\\nKEY: GDI\\nOPT(GDI4) = min(OPT(GD2) + D2->I4, OPT(GD3) + D3->I4) + 1 = 7\\n\\n\\n// Sub-problems and state:\\nLet dp[i][j] denote the minimum number of steps to spell keyword[0..i] with ring arrow pointing at index j.\\n// OPT(GD2) => dp[1][2]\\n// keyword(GD)\\n//         01\\n// the dial stops at D\\n//                   2\\n\\n// OPT(GDI4) => dp[2][4]\\n// keyword(GDI)\\n//         012\\n// the dial stops at I\\n//                   4\\n\\nRecurrence Relation:\\n// Emm.. Too lazy to figure this. I believe you\\'re able to figure this out by yourself or you can look at my code directly,\\n// which should be very easy to understand.\\n```\\n### Code\\n```cpp\\nclass Solution {\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        int N = ring.length();\\n        int M = key.length();\\n        \\n        vector<vector<int>> dp(N, vector<int>(M, INT_MAX));\\n        \\n        vector<vector<int>> char_pos_map(26, vector<int>());\\n        for(int i = 0; i < N; ++i) {\\n            int cur_char = ring[i] - \\'a\\';\\n            char_pos_map[cur_char].push_back(i);\\n        }\\n        \\n        int res = INT_MAX;\\n        for(int i = 0; i < M; ++i){\\n            int cur_char = key[i] - \\'a\\';\\n            for(int cur_pos : char_pos_map[cur_char]){\\n                if(i == 0) {\\n                    dp[cur_pos][0] = min(cur_pos, N - cur_pos) + 1;\\n                } else {\\n                    int pre_char = key[i - 1] - \\'a\\';\\n                    for(int pre_pos : char_pos_map[pre_char]){\\n                        int diff = min(abs(cur_pos - pre_pos), N - abs(cur_pos - pre_pos));\\n                        dp[cur_pos][i] = min(dp[cur_pos][i], dp[pre_pos][i - 1] + diff + 1);\\n                    }\\n                }\\n                if(i == M - 1)\\n                    res = min(res, dp[cur_pos][M - 1]);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// Given a string ring:\\n\\n  0   1   2   3   4   5   6\\n+---+---+---+---+---+---+---+\\n| G | O | D | D | I | N | G |\\n+---+---+---+---+---+---+---+\\n\\n// and keyword \"GDI\"\\n\\n      0   1   2   3   4   5   6\\n    +---+---+---+---+---+---+---+\\n    | G | O | D | D | I | N | G |\\n    +---+---+---+---+---+---+---+\\n  G | 1 |   |   |   |   |   | 2 |\\n  D |   |   | 4 | 5 |   |   |   |\\n  I |   |   |   |   | 7 |   |   |                 \\n\\n// For the first character G of KEY \"GDI\", \\n// we have two Gs in the string ring, ring[0] and ring[6], \\n// Let OPT(KEY) denote the minimum number of steps to spell KEY.\\nKEY: G\\n// If we choose G0\\nOPT(G0) = 0 + 1 = 1\\n// If we choose G6\\nOPT(G6) = 1 + 1 = 2\\n\\n// For the second character D of KEY \"GDI\", \\n// we have two Ds in the string ring, ring[2] and ring[3], \\nKEY: GD\\n// and the ring now points to G (G0 or G6).\\n// If we choose D2\\nOPT(GD2) = min(OPT(G0) + G0->D2, OPT(G6) + G6->D2) + 1 = 4\\n// If we choose D3\\nOPT(GD3) = min(OPT(G0) + G0->D3, OPT(G6) + G6->D3) + 1 = 5\\n\\n// For the third character I of KEY \"GDI\", \\n// we have one I in the ring string, ring[4], \\n// and the ring now points to D (D2 or D3).\\nKEY: GDI\\nOPT(GDI4) = min(OPT(GD2) + D2->I4, OPT(GD3) + D3->I4) + 1 = 7\\n\\n\\n// Sub-problems and state:\\nLet dp[i][j] denote the minimum number of steps to spell keyword[0..i] with ring arrow pointing at index j.\\n// OPT(GD2) => dp[1][2]\\n// keyword(GD)\\n//         01\\n// the dial stops at D\\n//                   2\\n\\n// OPT(GDI4) => dp[2][4]\\n// keyword(GDI)\\n//         012\\n// the dial stops at I\\n//                   4\\n\\nRecurrence Relation:\\n// Emm.. Too lazy to figure this. I believe you\\'re able to figure this out by yourself or you can look at my code directly,\\n// which should be very easy to understand.\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        int N = ring.length();\\n        int M = key.length();\\n        \\n        vector<vector<int>> dp(N, vector<int>(M, INT_MAX));\\n        \\n        vector<vector<int>> char_pos_map(26, vector<int>());\\n        for(int i = 0; i < N; ++i) {\\n            int cur_char = ring[i] - \\'a\\';\\n            char_pos_map[cur_char].push_back(i);\\n        }\\n        \\n        int res = INT_MAX;\\n        for(int i = 0; i < M; ++i){\\n            int cur_char = key[i] - \\'a\\';\\n            for(int cur_pos : char_pos_map[cur_char]){\\n                if(i == 0) {\\n                    dp[cur_pos][0] = min(cur_pos, N - cur_pos) + 1;\\n                } else {\\n                    int pre_char = key[i - 1] - \\'a\\';\\n                    for(int pre_pos : char_pos_map[pre_char]){\\n                        int diff = min(abs(cur_pos - pre_pos), N - abs(cur_pos - pre_pos));\\n                        dp[cur_pos][i] = min(dp[cur_pos][i], dp[pre_pos][i - 1] + diff + 1);\\n                    }\\n                }\\n                if(i == M - 1)\\n                    res = min(res, dp[cur_pos][M - 1]);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98920,
                "title": "shared-my-c-dp-solution-19ms",
                "content": "Simple dp idea\\n1. recording each index of characters in ring,beacuse each characters we have search in this time would be starting index in the next search \\n2. How could we solve the problem that rotate the ring to the left or right ?   My idea is **min((tmp[j] + size -it)%size,(it + size - tmp[j])%size)**\\n\\n * Suppose you want to rotate the ring to the right and search 'k', and the size is 5.\\nWe could calculate it by **this + size -k(index)%size** \\n\\n```\\nthis -  -  -  -  k\\n```\\n\\n * If we want to rotate the ring to the left\\uff0cwhat should we do? It is the same problem  with above problem,move **this** to its right,and reach **k**\\n```\\nk -  -  -  -   this\\n```\\n * So we could calculate it by **k(index) + size -this%size**\\n* There are many people use **abs()** instead of **%size**,I think it's faster than mine :)\\n\\n\\n\\n\\n\\n````\\nclass Solution {\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        int size = ring.size();\\n        int ksize = key.size();\\n        unordered_map<char,vector<int>> mp;//stored index of each characters in ring,pay attention to duplcate characters.\\n        for(int i=0;i<size;++i){\\n            mp[ring[i]].push_back(i);\\n        }\\n        \\n        vector<vector<int>> dp(ksize+1,vector<int> (size,INT_MAX));// initializing dp vector \\n        fill(dp[0].begin(),dp[0].end(),0);\\n        \\n        vector<int> tmp(1,0);// starting index\\n        \\n        int res = INT_MAX;\\n        for(int i=1;i<=ksize;++i){\\n            for(auto it:mp[key[i-1]]){  //\\n                for(int j=0;j<tmp.size();++j){  //Search The shortest distance key[i-1] in ring\\n                    int minDist = min((tmp[j] + size -it)%size,(it + size - tmp[j])%size) + dp[i-1][tmp[j]];// Look at the above explanation\\n                    dp[i][it] =min(dp[i][it],minDist);\\n                    res = (i!=ksize?res:min(res,dp[i][it])); //Can we optimize it?\\n                }\\n            }\\n            tmp = mp[key[i-1]]; //next start is the characters we search in this time\\n        }\\n        return res + ksize;\\n    }\\n};\\n````\\n\\n**update (optimazed space complexity)**\\n\\n````\\nclass Solution {\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        int size = ring.size();\\n        int ksize = key.size();\\n        vector<vector<int>> mp(26);   //Optimazed_1 use vector instead of unordered_map\\n            //stored index of each ,pay attention to duplcate characters.\\n        for(int i=0;i<size;++i){\\n            mp[ring[i]-'a'].push_back(i);\\n        }\\n        \\n        vector<int> dp (size,INT_MAX);   //Optimazed_2,use less space \\n        dp[0] = 0;\\n        \\n        vector<int> startIndex(1,0);// starting index\\n\\n        for(int i=1;i<=ksize;++i){\\n            vector<int> nextDp(size,INT_MAX);\\n            for(auto it:mp[key[i-1]-'a']){\\n                for(int j=0;j<startIndex.size();++j){\\n                    int minDist = min((startIndex[j] + size -it)%size,(it + size - startIndex[j])%size) + dp[startIndex[j]];// Look at the above explanation\\n                    nextDp[it] =min(nextDp[it],minDist);\\n                }\\n            }\\n            startIndex = mp[key[i-1]-'a'];\\n            dp = nextDp;\\n        }\\n        \\n        int res = INT_MAX;\\n        for(int i=0;i<size;++i){\\n            res = min(res,dp[i]);\\n        }  // get the smallest value(step)\\n        \\n        return res + ksize;\\n    }\\n};\\n\\n````",
                "solutionTags": [],
                "code": "```\\nthis -  -  -  -  k\\n```\n```\\nk -  -  -  -   this\\n```\n````\\nclass Solution {\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        int size = ring.size();\\n        int ksize = key.size();\\n        unordered_map<char,vector<int>> mp;//stored index of each characters in ring,pay attention to duplcate characters.\\n        for(int i=0;i<size;++i){\\n            mp[ring[i]].push_back(i);\\n        }\\n        \\n        vector<vector<int>> dp(ksize+1,vector<int> (size,INT_MAX));// initializing dp vector \\n        fill(dp[0].begin(),dp[0].end(),0);\\n        \\n        vector<int> tmp(1,0);// starting index\\n        \\n        int res = INT_MAX;\\n        for(int i=1;i<=ksize;++i){\\n            for(auto it:mp[key[i-1]]){  //\\n                for(int j=0;j<tmp.size();++j){  //Search The shortest distance key[i-1] in ring\\n                    int minDist = min((tmp[j] + size -it)%size,(it + size - tmp[j])%size) + dp[i-1][tmp[j]];// Look at the above explanation\\n                    dp[i][it] =min(dp[i][it],minDist);\\n                    res = (i!=ksize?res:min(res,dp[i][it])); //Can we optimize it?\\n                }\\n            }\\n            tmp = mp[key[i-1]]; //next start is the characters we search in this time\\n        }\\n        return res + ksize;\\n    }\\n};\\n```\n````\\nclass Solution {\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        int size = ring.size();\\n        int ksize = key.size();\\n        vector<vector<int>> mp(26);   //Optimazed_1 use vector instead of unordered_map\\n            //stored index of each ,pay attention to duplcate characters.\\n        for(int i=0;i<size;++i){\\n            mp[ring[i]-'a'].push_back(i);\\n        }\\n        \\n        vector<int> dp (size,INT_MAX);   //Optimazed_2,use less space \\n        dp[0] = 0;\\n        \\n        vector<int> startIndex(1,0);// starting index\\n\\n        for(int i=1;i<=ksize;++i){\\n            vector<int> nextDp(size,INT_MAX);\\n            for(auto it:mp[key[i-1]-'a']){\\n                for(int j=0;j<startIndex.size();++j){\\n                    int minDist = min((startIndex[j] + size -it)%size,(it + size - startIndex[j])%size) + dp[startIndex[j]];// Look at the above explanation\\n                    nextDp[it] =min(nextDp[it],minDist);\\n                }\\n            }\\n            startIndex = mp[key[i-1]-'a'];\\n            dp = nextDp;\\n        }\\n        \\n        int res = INT_MAX;\\n        for(int i=0;i<size;++i){\\n            res = min(res,dp[i]);\\n        }  // get the smallest value(step)\\n        \\n        return res + ksize;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98936,
                "title": "easy-understand-python-solution",
                "content": "I use a variable ```state``` to keep current state for every step in the string key. \\nkey of ```state```: position of the ring\\nvalue of ```state```: and minimum cost\\n\\nIt's like greedy algorithme and dp, though I only keep the state of last step.\\n\\n```\\ndef findRotateSteps(self, ring, key):\\n        # the distance between two points (i, j) on the ring\\n        def dist(i, j):\\n            return min(abs(i - j), len(ring) - abs(i - j))\\n        # build the position list for each character in ring\\n        pos = {}\\n        for i, c in enumerate(ring):\\n            if c in pos: pos[c].append(i)\\n            else: pos[c] = [i]\\n        # the current possible state: {position of the ring: the cost}\\n        state = {0: 0}\\n        for c in key:\\n            next_state = {}\\n            for j in pos[c]:  # every possible target position\\n                next_state[j] = float('inf')\\n                for i in state:  # every possible start position\\n                    next_state[j] = min(next_state[j], dist(i, j) + state[i])\\n            state = next_state\\n        return min(state.values()) + len(key)\\n````\\nI can still improve it by checking if it's same character successive.",
                "solutionTags": [],
                "code": "```state```\n```state```\n```state```\n```\\ndef findRotateSteps(self, ring, key):\\n        # the distance between two points (i, j) on the ring\\n        def dist(i, j):\\n            return min(abs(i - j), len(ring) - abs(i - j))\\n        # build the position list for each character in ring\\n        pos = {}\\n        for i, c in enumerate(ring):\\n            if c in pos: pos[c].append(i)\\n            else: pos[c] = [i]\\n        # the current possible state: {position of the ring: the cost}\\n        state = {0: 0}\\n        for c in key:\\n            next_state = {}\\n            for j in pos[c]:  # every possible target position\\n                next_state[j] = float('inf')\\n                for i in state:  # every possible start position\\n                    next_state[j] = min(next_state[j], dist(i, j) + state[i])\\n            state = next_state\\n        return min(state.values()) + len(key)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 98900,
                "title": "o-rk-time-dp-solution",
                "content": "We can further improve the runtime of [this DP Solution](https://discuss.leetcode.com/topic/81684/concise-java-dp-solution) from `O(R * R * K)` to `O(R * (26 + K)) = O(RK)`, where `R = |Ring|` and `K = |Key|`. Basically, we can do the inner-most loop in `O(1)` time. The idea is that if we are currently at position `i` and require the previous char equal to some letter `ch`, we just need to check the position (with letter `ch`) that is closest to `i` from its left or right. Thus, at most two positions need to be checked, instead of the entire ring.\\n\\n**Update:** The preprocessing of the following code takes `O(R^2 * 26) = O(R^2)` time. But I believe there must exist a faster way, and ~~I was just too lazy to do that~~...\\n**Update:** Okay, the preprocessing can be done in `O(26 * R) = O(R)` time.\\n\\n```\\npublic int findRotateSteps(String ring, String key) {\\n    int R = ring.length(), K = key.length();\\n    int[][] prev = new int[R][26], next = new int[R][26];\\n    for (int i = 0; i < R; i++) {\\n        Arrays.fill(prev[i], -1);\\n        Arrays.fill(next[i], -1);\\n        for (int j = (i + 1) % R; j != i; j = (j + 1) % R) {\\n            int ch = ring.charAt(j) - 'a';\\n            if (next[i][ch] == -1) next[i][ch] = j;\\n        }\\n        for (int j = (i - 1 + R) % R; j != i; j = (j - 1 + R) % R) {\\n            int ch = ring.charAt(j) - 'a';\\n            if (prev[i][ch] == -1) prev[i][ch] = j;\\n        }\\n        prev[i][ring.charAt(i) - 'a'] = next[i][ring.charAt(i) - 'a'] = i;\\n    }\\n\\n    int[][] f = new int[K][R];\\n    int ans = Integer.MAX_VALUE;\\n    for (int i = 0; i < K; i++) {\\n        for (int j = 0; j < R; j++) {\\n            f[i][j] = Integer.MAX_VALUE / 2;\\n\\n            if (key.charAt(i) == ring.charAt(j)) {\\n                if (i == 0) f[i][j] = Math.min(f[i][j], dist(0, j, ring.length()));\\n                else {\\n                    int preKey = key.charAt(i - 1) - 'a';\\n                    f[i][j] = Math.min(f[i][j], f[i - 1][prev[j][preKey]] + dist(prev[j][preKey], j, ring.length()));\\n                    f[i][j] = Math.min(f[i][j], f[i - 1][next[j][preKey]] + dist(next[j][preKey], j, ring.length()));\\n                }\\n            }\\n            if (i == K - 1) ans = Math.min(ans, f[i][j]);\\n        }\\n    }\\n    return ans + K;\\n}\\n```\\n\\nAn `O(26R) = O(R)`-time preprocessing.\\n```java\\nint R = ring.length(), K = key.length();\\nint[][] prev = new int[R][26], next = new int[R][26];\\nMap<Character, List<Integer>> map = new HashMap<>();\\nfor (int i = 0; i < ring.length(); i++) {\\n    char ch = ring.charAt(i);\\n    map.putIfAbsent(ch, new ArrayList<>());\\n    map.get(ch).add(i);\\n}\\nfor (char ch : map.keySet()) {\\n    List<Integer> list = map.get(ch);\\n    for (int i = 0, ptr = 0; i < ring.length(); i++) {\\n        next[i][ch - 'a'] = list.get(ptr);\\n        prev[i][ch - 'a'] = list.get((ptr - 1 + list.size()) % list.size());\\n        if (ring.charAt(i) == ch) ptr = (ptr + 1) % list.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findRotateSteps(String ring, String key) {\\n    int R = ring.length(), K = key.length();\\n    int[][] prev = new int[R][26], next = new int[R][26];\\n    for (int i = 0; i < R; i++) {\\n        Arrays.fill(prev[i], -1);\\n        Arrays.fill(next[i], -1);\\n        for (int j = (i + 1) % R; j != i; j = (j + 1) % R) {\\n            int ch = ring.charAt(j) - 'a';\\n            if (next[i][ch] == -1) next[i][ch] = j;\\n        }\\n        for (int j = (i - 1 + R) % R; j != i; j = (j - 1 + R) % R) {\\n            int ch = ring.charAt(j) - 'a';\\n            if (prev[i][ch] == -1) prev[i][ch] = j;\\n        }\\n        prev[i][ring.charAt(i) - 'a'] = next[i][ring.charAt(i) - 'a'] = i;\\n    }\\n\\n    int[][] f = new int[K][R];\\n    int ans = Integer.MAX_VALUE;\\n    for (int i = 0; i < K; i++) {\\n        for (int j = 0; j < R; j++) {\\n            f[i][j] = Integer.MAX_VALUE / 2;\\n\\n            if (key.charAt(i) == ring.charAt(j)) {\\n                if (i == 0) f[i][j] = Math.min(f[i][j], dist(0, j, ring.length()));\\n                else {\\n                    int preKey = key.charAt(i - 1) - 'a';\\n                    f[i][j] = Math.min(f[i][j], f[i - 1][prev[j][preKey]] + dist(prev[j][preKey], j, ring.length()));\\n                    f[i][j] = Math.min(f[i][j], f[i - 1][next[j][preKey]] + dist(next[j][preKey], j, ring.length()));\\n                }\\n            }\\n            if (i == K - 1) ans = Math.min(ans, f[i][j]);\\n        }\\n    }\\n    return ans + K;\\n}\\n```\n```java\\nint R = ring.length(), K = key.length();\\nint[][] prev = new int[R][26], next = new int[R][26];\\nMap<Character, List<Integer>> map = new HashMap<>();\\nfor (int i = 0; i < ring.length(); i++) {\\n    char ch = ring.charAt(i);\\n    map.putIfAbsent(ch, new ArrayList<>());\\n    map.get(ch).add(i);\\n}\\nfor (char ch : map.keySet()) {\\n    List<Integer> list = map.get(ch);\\n    for (int i = 0, ptr = 0; i < ring.length(); i++) {\\n        next[i][ch - 'a'] = list.get(ptr);\\n        prev[i][ch - 'a'] = list.get((ptr - 1 + list.size()) % list.size());\\n        if (ring.charAt(i) == ch) ptr = (ptr + 1) % list.size();\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 163971,
                "title": "dp-c-solution",
                "content": "- Due to duplicates, we first have a map that stores the indices of each letter in ring. This is used to find the rotation distance.\\n- The rotation distance between two letters indexed at i and j is min(abs(i - j), N - abs(i - j)), where N is the size of ring.\\n\\n```\\nclass Solution {\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        int N = ring.size();\\n        unordered_map<char, vector<int>> indexMap;\\n        for (int i = 0; i < N; ++i) {\\n            indexMap[ring[i]].push_back(i);\\n        }\\n        \\n        vector<vector<pair<int, int>>> dp(key.size());\\n        for (int i : indexMap[key[0]]) {\\n            int dist = min(i, N - i);\\n            dp[0].push_back({i, dist});\\n        }\\n        \\n        int minOverall = INT_MAX;\\n        \\n        for (int i = 1; i < key.size(); ++i) {\\n            for (int idx : indexMap[key[i]]) {\\n                int minDist = INT_MAX;\\n                for (auto& pair : dp[i - 1]) {\\n                    int absDist = abs(pair.first - idx);\\n                    int dist = min(absDist, N - absDist);\\n                    minDist = min(minDist, dist + pair.second);\\n                }\\n                dp[i].push_back({idx, minDist});\\n                if (i == key.size() - 1) minOverall = min(minDist, minOverall);\\n            }\\n        }\\n        \\n        return minOverall + key.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        int N = ring.size();\\n        unordered_map<char, vector<int>> indexMap;\\n        for (int i = 0; i < N; ++i) {\\n            indexMap[ring[i]].push_back(i);\\n        }\\n        \\n        vector<vector<pair<int, int>>> dp(key.size());\\n        for (int i : indexMap[key[0]]) {\\n            int dist = min(i, N - i);\\n            dp[0].push_back({i, dist});\\n        }\\n        \\n        int minOverall = INT_MAX;\\n        \\n        for (int i = 1; i < key.size(); ++i) {\\n            for (int idx : indexMap[key[i]]) {\\n                int minDist = INT_MAX;\\n                for (auto& pair : dp[i - 1]) {\\n                    int absDist = abs(pair.first - idx);\\n                    int dist = min(absDist, N - absDist);\\n                    minDist = min(minDist, dist + pair.second);\\n                }\\n                dp[i].push_back({idx, minDist});\\n                if (i == key.size() - 1) minOverall = min(minDist, minOverall);\\n            }\\n        }\\n        \\n        return minOverall + key.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98953,
                "title": "java-dp-with-explanation",
                "content": "The dp is a 2D integer array, with height = the length of **ring**, with width = the length of **key**. So DP[i][j] represents that if we want to spell the next character key[**j**], and at the same time the 12:00 aligns with the ring[**i**], then what is the minimum steps to spell the **whole key start at key[j]**. If we finish the DP array, then the answer is just DP[0][0], which means the minimum steps to spell the **whole key** start at key[0], if currently 12:00 aligns with the ring[0], and this is exactly the original problem. And don't forget to plus the length of key, which is the steps we need to push the button.\\n\\n\\n```\\n// by fallcreek\\npublic class Solution {\\n    public int findRotateSteps(String ring, String key) {        \\n        int[][] dp = new int[ring.length()][key.length()];\\n        for(int[] line : dp)    Arrays.fill(line, -1);\\n        \\n        return helper(ring, 0, key, 0, dp) + key.length();\\n    }\\n    \\n    public int helper(String ring, int rIndex, String key, int kIndex, int[][] dp){\\n        if(kIndex == key.length()) return 0;\\n        if(dp[rIndex][kIndex] != -1) return dp[rIndex][kIndex];\\n        \\n        char dest = key.charAt(kIndex);\\n        \\n        int nextIndex = ring.indexOf(dest);\\n        int sol = Integer.MAX_VALUE;\\n        do{\\n            int move = Math.min(Math.abs(rIndex - nextIndex), ring.length() - Math.abs(rIndex - nextIndex));\\n            int remain = helper(ring, nextIndex, key, kIndex + 1, dp);\\n            sol = Math.min(sol, move + remain);\\n            nextIndex = ring.indexOf(dest, nextIndex + 1);\\n        }while(nextIndex != -1);\\n        dp[rIndex][kIndex] = sol;\\n        return sol;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// by fallcreek\\npublic class Solution {\\n    public int findRotateSteps(String ring, String key) {        \\n        int[][] dp = new int[ring.length()][key.length()];\\n        for(int[] line : dp)    Arrays.fill(line, -1);\\n        \\n        return helper(ring, 0, key, 0, dp) + key.length();\\n    }\\n    \\n    public int helper(String ring, int rIndex, String key, int kIndex, int[][] dp){\\n        if(kIndex == key.length()) return 0;\\n        if(dp[rIndex][kIndex] != -1) return dp[rIndex][kIndex];\\n        \\n        char dest = key.charAt(kIndex);\\n        \\n        int nextIndex = ring.indexOf(dest);\\n        int sol = Integer.MAX_VALUE;\\n        do{\\n            int move = Math.min(Math.abs(rIndex - nextIndex), ring.length() - Math.abs(rIndex - nextIndex));\\n            int remain = helper(ring, nextIndex, key, kIndex + 1, dp);\\n            sol = Math.min(sol, move + remain);\\n            nextIndex = ring.indexOf(dest, nextIndex + 1);\\n        }while(nextIndex != -1);\\n        dp[rIndex][kIndex] = sol;\\n        return sol;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 121035,
                "title": "java-dfs-memo-solution-beats-100-very-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int findRotateSteps(String ring, String key) {\\n        char[] ringArr = ring.toCharArray();\\n        char[] keyArr = key.toCharArray();\\n        \\n        return dfs(ringArr, keyArr, 0, 0, new int[ringArr.length][keyArr.length]);\\n    }\\n    private  int dfs(char[] ring, char[] target, int targetIndex, int ringIndex, int[][] memo){\\n        if(targetIndex == target.length)    return 0;\\n        \\n        if(memo[ringIndex][targetIndex] != 0)   return memo[ringIndex][targetIndex];\\n        \\n        int min = Integer.MAX_VALUE;\\n        for(int i = 0;i < ring.length;i++){\\n            if(ring[i] != target[targetIndex])  continue;\\n            \\n            int dif = Math.abs(i - ringIndex);\\n            int distance =  1 + Math.min(dif, ring.length - dif) + dfs(ring, target, targetIndex + 1, i, memo);\\n            min = Math.min(min, distance);            \\n        }\\n        \\n        memo[ringIndex][targetIndex] = min;\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findRotateSteps(String ring, String key) {\\n        char[] ringArr = ring.toCharArray();\\n        char[] keyArr = key.toCharArray();\\n        \\n        return dfs(ringArr, keyArr, 0, 0, new int[ringArr.length][keyArr.length]);\\n    }\\n    private  int dfs(char[] ring, char[] target, int targetIndex, int ringIndex, int[][] memo){\\n        if(targetIndex == target.length)    return 0;\\n        \\n        if(memo[ringIndex][targetIndex] != 0)   return memo[ringIndex][targetIndex];\\n        \\n        int min = Integer.MAX_VALUE;\\n        for(int i = 0;i < ring.length;i++){\\n            if(ring[i] != target[targetIndex])  continue;\\n            \\n            int dif = Math.abs(i - ringIndex);\\n            int distance =  1 + Math.min(dif, ring.length - dif) + dfs(ring, target, targetIndex + 1, i, memo);\\n            min = Math.min(min, distance);            \\n        }\\n        \\n        memo[ringIndex][targetIndex] = min;\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 759788,
                "title": "java-simple-dp",
                "content": "dp[i][j] is the min to finish the code, for surfix key[i:], start from ring.charAt(j);\\ndp[0][0] will the the min moves, since it starts at index 0 of ring;\\n```\\n    public int findRotateSteps(String r, String key) {\\n        int m = r.length(), n = key.length(), dp[][] = new int[n + 1][m];\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = 0; j < m; j++) {\\n                dp[i][j] = Integer.MAX_VALUE;\\n                for (int k = 0; k < m; k++) {\\n                    if (r.charAt(k) == key.charAt(i)) {\\n                        int move = Math.abs(j - k), min = Math.min(move, m - move);\\n                        dp[i][j] = Math.min(dp[i][j], min + dp[i + 1][k]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][0] + n;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int findRotateSteps(String r, String key) {\\n        int m = r.length(), n = key.length(), dp[][] = new int[n + 1][m];\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = 0; j < m; j++) {\\n                dp[i][j] = Integer.MAX_VALUE;\\n                for (int k = 0; k < m; k++) {\\n                    if (r.charAt(k) == key.charAt(i)) {\\n                        int move = Math.abs(j - k), min = Math.min(move, m - move);\\n                        dp[i][j] = Math.min(dp[i][j], min + dp[i + 1][k]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][0] + n;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 98918,
                "title": "java-easy-understanding-solution-recursion-memorization",
                "content": "The state is represented by the 12:00 direction of index p and the current index of key to spell.\\nInitially, p = 0. Rotate both direction to find the character to match the character in key to spell. there are two cases:\\n1. left rotation and right rotation end up with same index (i==j) then there is only one branch\\n2. they end up with different index then there are two branch\\nBelow is the code please feel free to advise\\n\\n```\\n    public int findRotateSteps(String ring, String key) {\\n        if(ring.length()==0 || key.length()==0) return 0;\\n        return findShortest(ring.toCharArray(), 0, key.toCharArray(), 0, new int[ring.length()][key.length()]);\\n    }\\n    private int findShortest(char[] arr, int p,  char[] key, int idx, int[][] mem) {\\n        if(idx==key.length) return 0;\\n        if(mem[p][idx]>0) return mem[p][idx];\\n        int c1 = 0, c2=0,i=p, j=p;\\n        for(; arr[i]!=key[idx]; c1++) {\\n            i=(i+1)%arr.length;\\n        }\\n        for(; arr[j]!=key[idx];c2++) {\\n            j=(j-1+arr.length)%arr.length;\\n        }\\n        if(i==j) { //rotate to same location then use the less count one\\n            mem[p][idx]= Math.min(c1,c2)+1 + findShortest(arr, i, key, idx+1, mem);\\n        } else {\\n            int r1 = findShortest(arr, i, key, idx+1, mem) + c1 + 1;\\n            int r2 = findShortest(arr, j, key, idx+1, mem) + c2 + 1;\\n            mem[p][idx] = Math.min(r1,r2);\\n        }\\n        return mem[p][idx];\\n    }",
                "solutionTags": [],
                "code": "The state is represented by the 12:00 direction of index p and the current index of key to spell.\\nInitially, p = 0. Rotate both direction to find the character to match the character in key to spell. there are two cases:\\n1. left rotation and right rotation end up with same index (i==j) then there is only one branch\\n2. they end up with different index then there are two branch\\nBelow is the code please feel free to advise\\n\\n```\\n    public int findRotateSteps(String ring, String key) {\\n        if(ring.length()==0 || key.length()==0) return 0;\\n        return findShortest(ring.toCharArray(), 0, key.toCharArray(), 0, new int[ring.length()][key.length()]);\\n    }\\n    private int findShortest(char[] arr, int p,  char[] key, int idx, int[][] mem) {\\n        if(idx==key.length) return 0;\\n        if(mem[p][idx]>0) return mem[p][idx];\\n        int c1 = 0, c2=0,i=p, j=p;\\n        for(; arr[i]!=key[idx]; c1++) {\\n            i=(i+1)%arr.length;\\n        }\\n        for(; arr[j]!=key[idx];c2++) {\\n            j=(j-1+arr.length)%arr.length;\\n        }\\n        if(i==j) { //rotate to same location then use the less count one\\n            mem[p][idx]= Math.min(c1,c2)+1 + findShortest(arr, i, key, idx+1, mem);\\n        } else {\\n            int r1 = findShortest(arr, i, key, idx+1, mem) + c1 + 1;\\n            int r2 = findShortest(arr, j, key, idx+1, mem) + c2 + 1;\\n            mem[p][idx] = Math.min(r1,r2);\\n        }\\n        return mem[p][idx];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3289069,
                "title": "514-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Define a function dp(i, j) that takes two parameters:\\ni: index of the character in the ring that is currently aligned with the \"12:00\" direction.\\nj: index of the character in the key that needs to be spelled.\\n2. If the current combination of i and j has already been computed and stored in the memoization dictionary, return its value.\\n3. If j is equal to the length of the key, it means that all characters in the key have been spelled. Return 0 as there are no more steps needed.\\n4. Initialize a variable ans to infinity.\\n5. Loop through each character in the ring and check if it matches the character in the key at index j.\\n6. If it is a match, calculate the number of steps needed to move the current character to the \"12:00\" direction using the formula:\\ndelta: absolute difference between the current character\\'s index and the index of the character that is aligned with the \"12:00\" direction.\\nsteps: minimum of delta and len(ring) - delta, which represents the shortest number of steps needed to rotate the ring clockwise or anticlockwise to align the current character with the \"12:00\" direction.\\n7. Recursively call dp with the next character in the key at index j+1 and the current character in the ring at index k.\\n8. Update ans to the minimum of its current value and the sum of steps and the result of the recursive call to dp.\\n9. Store the result in the memoization dictionary using the current combination of i and j as the key.\\n10. Return ans as the minimum number of steps needed to spell all characters in the key starting from index j, plus the length of the key itself to account for the steps needed to press the center button.\\n11. Call dp with initial values of i=0 and j=0 to solve the problem.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        memo = {}\\n        def dp(i: int, j: int) -> int:\\n            if (i, j) in memo:\\n                return memo[(i, j)]\\n            if j == len(key):\\n                return 0\\n            ans = float(\\'inf\\')\\n            for k in range(len(ring)):\\n                if ring[k] == key[j]:\\n                    delta = abs(k - i)\\n                    steps = min(delta, len(ring) - delta)\\n                    ans = min(ans, steps + dp(k, j+1))\\n            memo[(i, j)] = ans\\n            return ans\\n        return dp(0, 0) + len(key)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        memo = {}\\n        def dp(i: int, j: int) -> int:\\n            if (i, j) in memo:\\n                return memo[(i, j)]\\n            if j == len(key):\\n                return 0\\n            ans = float(\\'inf\\')\\n            for k in range(len(ring)):\\n                if ring[k] == key[j]:\\n                    delta = abs(k - i)\\n                    steps = min(delta, len(ring) - delta)\\n                    ans = min(ans, steps + dp(k, j+1))\\n            memo[(i, j)] = ans\\n            return ans\\n        return dp(0, 0) + len(key)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775612,
                "title": "dfs-memo-12ms",
                "content": "\\tint dp[101][101];\\n    int util(string &ring,string &key,int index,int pos){\\n        \\n        if(dp[index][pos]!=0) return dp[index][pos];\\n        if(index>=key.size()) return 0;\\n        \\n        int mi=INT_MAX;\\n        for(int i=0;i<ring.size();i++){\\n            if(ring[i]==key[index]){\\n                int x;\\n                if(pos>i){\\n                    x=min(pos-i,(int)ring.length()-pos+i);\\n                }\\n                else\\n                    x=min(i-pos,(int)ring.length()-i+pos);\\n                    mi=min(mi,1+x+util(ring,key,index+1,i));\\n            }\\n            \\n        }\\n        return dp[index][pos]=mi;\\n    }\\n    int findRotateSteps(string ring, string key) {\\n        return util(ring,key,0,0);\\n    }",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "\\tint dp[101][101];\\n    int util(string &ring,string &key,int index,int pos){\\n        \\n        if(dp[index][pos]!=0) return dp[index][pos];\\n        if(index>=key.size()) return 0;\\n        \\n        int mi=INT_MAX;\\n        for(int i=0;i<ring.size();i++){\\n            if(ring[i]==key[index]){\\n                int x;\\n                if(pos>i){\\n                    x=min(pos-i,(int)ring.length()-pos+i);\\n                }\\n                else\\n                    x=min(i-pos,(int)ring.length()-i+pos);\\n                    mi=min(mi,1+x+util(ring,key,index+1,i));\\n            }\\n            \\n        }\\n        return dp[index][pos]=mi;\\n    }\\n    int findRotateSteps(string ring, string key) {\\n        return util(ring,key,0,0);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1234154,
                "title": "top-down-dp-c-straight-farword",
                "content": "```\\nclass Solution {\\npublic:int dp[101][101];\\n    int findRotateSteps(string ring, string key) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,0,ring,key);\\n    }\\n    int solve(int i,int j,string ring,string k)\\n    {\\n        int n=ring.size();\\n        int m=k.size();\\n        if(j==m)return 0;\\n       if(dp[i][j]!=-1)return dp[i][j];\\n        int ans=INT_MAX;\\n        for(int i1=0;i1<n;i1++)\\n        {\\n            if(ring[i1]==k[j])\\n            {\\n                int x=abs(i-i1);\\n                ans=min(ans,min(x,n-x)+solve(i1,j+1,ring,k));\\n            }\\n        }\\n        return dp[i][j]=ans+1;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:int dp[101][101];\\n    int findRotateSteps(string ring, string key) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,0,ring,key);\\n    }\\n    int solve(int i,int j,string ring,string k)\\n    {\\n        int n=ring.size();\\n        int m=k.size();\\n        if(j==m)return 0;\\n       if(dp[i][j]!=-1)return dp[i][j];\\n        int ans=INT_MAX;\\n        for(int i1=0;i1<n;i1++)\\n        {\\n            if(ring[i1]==k[j])\\n            {\\n                int x=abs(i-i1);\\n                ans=min(ans,min(x,n-x)+solve(i1,j+1,ring,k));\\n            }\\n        }\\n        return dp[i][j]=ans+1;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367305,
                "title": "python-3-8-lines-dfs-dict-t-m-67-28",
                "content": "```\\nclass Solution:\\n    def findRotateSteps(self, ring, key):\\n        \\n        rLen, kLen, d = len(ring), len(key), defaultdict(list)\\n        dist = lambda x,y : min((x-y)%rLen, (y-x)%rLen)\\n\\n        for i, ch in enumerate(ring): d[ch].append(i)\\n\\n        @lru_cache(None)\\n        def dfs(curr = 0,next = 0):\\n\\n            if next >= kLen: return 0\\n\\n            return min(dist(curr,k)+dfs(k,next+1) for k in d[key[next]])\\n\\n        return dfs() + kLen\\n```\\n[https://leetcode.com/problems/freedom-trail/submissions/926131041/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*^3) and space complexity is *O*(*N*^2).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findRotateSteps(self, ring, key):\\n        \\n        rLen, kLen, d = len(ring), len(key), defaultdict(list)\\n        dist = lambda x,y : min((x-y)%rLen, (y-x)%rLen)\\n\\n        for i, ch in enumerate(ring): d[ch].append(i)\\n\\n        @lru_cache(None)\\n        def dfs(curr = 0,next = 0):\\n\\n            if next >= kLen: return 0\\n\\n            return min(dist(curr,k)+dfs(k,next+1) for k in d[key[next]])\\n\\n        return dfs() + kLen\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400826,
                "title": "java-dfs-memorization-solution-beats-99",
                "content": "```java\\nclass Solution {\\n    public int findRotateSteps(String ring, String key) {\\n        List<Integer>[] indexs = new List[26];\\n        for (int i = 0; i < 26; i++) {\\n            indexs[i] = new ArrayList<>();\\n        }\\n        for (int i = 0; i < ring.length(); i++) {\\n            indexs[ring.charAt(i) - \\'a\\'].add(i);\\n        }\\n        int[][] dp = new int[key.length()][ring.length()];\\n        return dfs(dp, indexs, 0, 0, ring.length(), key.toCharArray());\\n    }\\n    \\n    public int dfs(int[][] dp, List<Integer>[] indexs, int pos, int pre, int n, char[] chs) {\\n        if (pos == chs.length) return 0;\\n        if (dp[pos][pre] > 0) return dp[pos][pre];\\n        int min = Integer.MAX_VALUE;\\n        for (int index : indexs[chs[pos] - \\'a\\']) {\\n            int d = Math.abs(index - pre);\\n            int move = Math.min(d, n - d) + 1;\\n            min = Math.min(min, move + dfs(dp, indexs, pos + 1, index, n, chs));\\n        }\\n        dp[pos][pre] = min;\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int findRotateSteps(String ring, String key) {\\n        List<Integer>[] indexs = new List[26];\\n        for (int i = 0; i < 26; i++) {\\n            indexs[i] = new ArrayList<>();\\n        }\\n        for (int i = 0; i < ring.length(); i++) {\\n            indexs[ring.charAt(i) - \\'a\\'].add(i);\\n        }\\n        int[][] dp = new int[key.length()][ring.length()];\\n        return dfs(dp, indexs, 0, 0, ring.length(), key.toCharArray());\\n    }\\n    \\n    public int dfs(int[][] dp, List<Integer>[] indexs, int pos, int pre, int n, char[] chs) {\\n        if (pos == chs.length) return 0;\\n        if (dp[pos][pre] > 0) return dp[pos][pre];\\n        int min = Integer.MAX_VALUE;\\n        for (int index : indexs[chs[pos] - \\'a\\']) {\\n            int d = Math.abs(index - pre);\\n            int move = Math.min(d, n - d) + 1;\\n            min = Math.min(min, move + dfs(dp, indexs, pos + 1, index, n, chs));\\n        }\\n        dp[pos][pre] = min;\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98898,
                "title": "easy-to-understand-dfs-solution",
                "content": "```\\nclass Solution {\\n    public int findRotateSteps(String ring, String key) {\\n        char[] rings = ring.toCharArray();\\n        char[] keys  = key.toCharArray();\\n        return dfs(rings, keys, 0, 0, new HashMap<String, Integer>()) + key.length();\\n    }\\n    \\n    private int dfs(char[] rings, char[] keys, int keyIdx, int ringIdx, HashMap<String, Integer> ht) {\\n        if(keyIdx==keys.length) return 0;\\n        String key = keyIdx+\"-\"+ringIdx;\\n        if(ht.containsKey(key)) return ht.get(key);\\n        int minDistance = Integer.MAX_VALUE;\\n        for(int i=0;i<rings.length;++i) {\\n            if(rings[i]!=keys[keyIdx]) continue;\\n            int diff = Math.abs(i-ringIdx);\\n            int distance = Math.min(diff, rings.length-diff) + dfs(rings, keys, keyIdx+1, i, ht);\\n            minDistance = Math.min(minDistance, distance);\\n        }\\n        ht.put(key, minDistance);\\n        return minDistance;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findRotateSteps(String ring, String key) {\\n        char[] rings = ring.toCharArray();\\n        char[] keys  = key.toCharArray();\\n        return dfs(rings, keys, 0, 0, new HashMap<String, Integer>()) + key.length();\\n    }\\n    \\n    private int dfs(char[] rings, char[] keys, int keyIdx, int ringIdx, HashMap<String, Integer> ht) {\\n        if(keyIdx==keys.length) return 0;\\n        String key = keyIdx+\"-\"+ringIdx;\\n        if(ht.containsKey(key)) return ht.get(key);\\n        int minDistance = Integer.MAX_VALUE;\\n        for(int i=0;i<rings.length;++i) {\\n            if(rings[i]!=keys[keyIdx]) continue;\\n            int diff = Math.abs(i-ringIdx);\\n            int distance = Math.min(diff, rings.length-diff) + dfs(rings, keys, keyIdx+1, i, ht);\\n            minDistance = Math.min(minDistance, distance);\\n        }\\n        ht.put(key, minDistance);\\n        return minDistance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98937,
                "title": "python-solution-222-ms",
                "content": "First, the distance between two positions (i, j) can be defined as \\n```\\ndist(i, j) = min(|i - j|, n - |i - j|)\\n```\\nSecond, we need a dictionary, h, which tells us the characters on the ring and its possible positions of the ring (a list of positions). \\n\\nThe ring starts with one possible status: pcl_pre = [[position, cost]] = [[0, 0]]. For each next character, ch, on the key, we can have several choices of positions, h[ch]. Since we don't know which route will give the minimum total cost later, we need to compute and store the minimum cost for each possible next positions, h[ch], from all possible current positions, pcl_pre. In the end, we return the minimum total cost for the last character on the key.\\n \\n```\\nclass Solution(object):\\n    def findRotateSteps(self, ring, key):\\n        n = len(ring)\\n        #the distance between two points (i, j) on the ring\\n        def dist(i, j):\\n            return min(abs(i - j), n - abs(i - j))\\n        #build the position list for each character in ring    \\n        h = {}\\n        for i in xrange(n):\\n            a = ring[i]\\n            if a in h: h[a].append(i)\\n            else: h[a] = [i]\\n        \\n        pcl_pre = [[0,0]] #list of possible previous position of the ring and the cost\\n        for k in key:\\n            pl_k = h[k] #obtain the location list of character k\\n            pcl_next = [[p, 0] for p in pl_k] #list of possible next position of the ring and the cost\\n            \\n            for pc_next in pcl_next:\\n                p_next = pc_next[0] #next possible position\\n                #Find minimum cost to p_next\\n                cmin = dist(p_next, pcl_pre[0][0]) + pcl_pre[0][1]\\n                for pc_pre in pcl_pre:\\n                    cmin = min(cmin, dist(p_next, pc_pre[0]) + pc_pre[1])\\n                pc_next[1] = cmin\\n            \\n            pcl_pre = pcl_next\\n        \\n        #Find the min cost for all possible end positions\\n        cmin = pcl_pre[0][1]\\n        for pc in pcl_pre:\\n            cmin = min(cmin, pc[1])\\n        return len(key) + cmin\\n```\\nOne can actually improve this method by doing it backward. In this way, we can just return the cost to position = 0 instead of searching over all possible end positions.",
                "solutionTags": [],
                "code": "```\\ndist(i, j) = min(|i - j|, n - |i - j|)\\n```\n```\\nclass Solution(object):\\n    def findRotateSteps(self, ring, key):\\n        n = len(ring)\\n        #the distance between two points (i, j) on the ring\\n        def dist(i, j):\\n            return min(abs(i - j), n - abs(i - j))\\n        #build the position list for each character in ring    \\n        h = {}\\n        for i in xrange(n):\\n            a = ring[i]\\n            if a in h: h[a].append(i)\\n            else: h[a] = [i]\\n        \\n        pcl_pre = [[0,0]] #list of possible previous position of the ring and the cost\\n        for k in key:\\n            pl_k = h[k] #obtain the location list of character k\\n            pcl_next = [[p, 0] for p in pl_k] #list of possible next position of the ring and the cost\\n            \\n            for pc_next in pcl_next:\\n                p_next = pc_next[0] #next possible position\\n                #Find minimum cost to p_next\\n                cmin = dist(p_next, pcl_pre[0][0]) + pcl_pre[0][1]\\n                for pc_pre in pcl_pre:\\n                    cmin = min(cmin, dist(p_next, pc_pre[0]) + pc_pre[1])\\n                pc_next[1] = cmin\\n            \\n            pcl_pre = pcl_next\\n        \\n        #Find the min cost for all possible end positions\\n        cmin = pcl_pre[0][1]\\n        for pc in pcl_pre:\\n            cmin = min(cmin, pc[1])\\n        return len(key) + cmin\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98939,
                "title": "c-dfs-memorization",
                "content": "Use a vector of vector to store the positions of each lower case in ```ring```. It is not necessary to rotate ring or update vector ```v```. Instead, use variable ```offset``` to present the current state of the ring. Because the length is ```1 ~ 100```, so just use current index ```cur``` and ```offset%n``` as the key to store the min step of current sub string of ```key```, i.e.\\n```m[cur + ((offset % n) << 8)]``` is the min step to dial ```key.substr(cur)``` with ```ring``` at the state after rotate ```offset % n``` steps.\\n\\n```\\nclass Solution {\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        vector<vector<int>> v(26);\\n        unordered_map<int, int> memo;\\n        int n = ring.size();\\n        for (int i = 0; i < n; i++) {\\n            v[ring[i]-'a'].push_back(i);\\n        }\\n        \\n        return dfs(v, n, 0, key, 0, memo);\\n    }\\n    \\n    int dfs(vector<vector<int>>& v, int n, int offset, string& key, int cur, unordered_map<int, int>& memo) {\\n        if (cur == key.size()) return 0;\\n        int k = cur + ((offset % n) << 8);\\n        if (memo.count(k)) return memo[k];\\n        int res = INT_MAX;\\n        for (auto x : v[key[cur]-'a']) {\\n            x = (x+offset) % n;\\n            res = min(res, min(x, n-x)+1+dfs(v, n, offset+n-x, key, cur+1, memo));\\n        }\\n        memo[k] = res;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```ring```\n```v```\n```offset```\n```1 ~ 100```\n```cur```\n```offset%n```\n```key```\n```m[cur + ((offset % n) << 8)]```\n```key.substr(cur)```\n```ring```\n```offset % n```\n```\\nclass Solution {\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        vector<vector<int>> v(26);\\n        unordered_map<int, int> memo;\\n        int n = ring.size();\\n        for (int i = 0; i < n; i++) {\\n            v[ring[i]-'a'].push_back(i);\\n        }\\n        \\n        return dfs(v, n, 0, key, 0, memo);\\n    }\\n    \\n    int dfs(vector<vector<int>>& v, int n, int offset, string& key, int cur, unordered_map<int, int>& memo) {\\n        if (cur == key.size()) return 0;\\n        int k = cur + ((offset % n) << 8);\\n        if (memo.count(k)) return memo[k];\\n        int res = INT_MAX;\\n        for (auto x : v[key[cur]-'a']) {\\n            x = (x+offset) % n;\\n            res = min(res, min(x, n-x)+1+dfs(v, n, offset+n-x, key, cur+1, memo));\\n        }\\n        memo[k] = res;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831431,
                "title": "state-transition-clean-c-solution",
                "content": "Assume that we have done at some moment, this means the ring is aligned with the char postions, and we know their costs.\\n\\nTo move to the current char, we try to reach all positions with current char from all positions with previous char, and take the minimum cost as the cost of get current char at each valid postion.\\n\\nLet\\'s define the status i as the ring is aligned with the ith char. Then initilal status set is just {postion = 0, cost = 0},  and repreat the previous transition step untill done. The minimum cost postion is what we need.\\n\\nNotice that the transition distance is min(abs(x-y),ring.size() - abs(x)), and we need to add ring.size() to the final result dur ti the press button cost.\\n\\nSpace O(n), Time (kn^2)\\n\\n\\n```\\nclass Solution {\\n    using pii = pair<int, int>;\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        int n = ring.size();\\n        map<char, vector<int>> matches;\\n        for(int i = 0; i < n; i++){\\n            matches[ring[i]].push_back(i);\\n        }\\n        vector<pii> pos_cost;\\n        pos_cost.push_back({0, 0});\\n        for(auto ch : key){\\n            vector<pii> pos_cost_curr;\\n            for(auto curr_pos : matches[ch]){\\n                int curr_cost = INT_MAX;\\n                for(auto [pos, cost] : pos_cost){\\n                    int clkwise_trans_cost = abs(pos - curr_pos);\\n                    int temp_cost = cost + min(clkwise_trans_cost, n - clkwise_trans_cost);\\n                    curr_cost = min(curr_cost, temp_cost);\\n                }\\n                pos_cost_curr.push_back({curr_pos, curr_cost});\\n            }\\n            pos_cost = pos_cost_curr;\\n        }\\n        int min_cost = INT_MAX;\\n        for(auto [pos, cost] : pos_cost){\\n            min_cost = min(min_cost, cost);\\n        }\\n        return min_cost + key.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    using pii = pair<int, int>;\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        int n = ring.size();\\n        map<char, vector<int>> matches;\\n        for(int i = 0; i < n; i++){\\n            matches[ring[i]].push_back(i);\\n        }\\n        vector<pii> pos_cost;\\n        pos_cost.push_back({0, 0});\\n        for(auto ch : key){\\n            vector<pii> pos_cost_curr;\\n            for(auto curr_pos : matches[ch]){\\n                int curr_cost = INT_MAX;\\n                for(auto [pos, cost] : pos_cost){\\n                    int clkwise_trans_cost = abs(pos - curr_pos);\\n                    int temp_cost = cost + min(clkwise_trans_cost, n - clkwise_trans_cost);\\n                    curr_cost = min(curr_cost, temp_cost);\\n                }\\n                pos_cost_curr.push_back({curr_pos, curr_cost});\\n            }\\n            pos_cost = pos_cost_curr;\\n        }\\n        int min_cost = INT_MAX;\\n        for(auto [pos, cost] : pos_cost){\\n            min_cost = min(min_cost, cost);\\n        }\\n        return min_cost + key.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648889,
                "title": "c-solution-dp-memoization-store-indexes-of-all-characters-explore-all-possibilities",
                "content": "`Please upvote if this post is helpful`\\n\\n# Complexity\\nLet m and n be size of `ring` and `key` respectively.\\n- Time complexity:\\n$$O(m*n*(100))$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int helper(string& ring,string& key,int idx1,int idx2,map<char,vector<int>>& mp){\\n        int n = ring.size();\\n        if(idx2==key.size()){\\n            return 0;\\n        }\\n        if(dp[idx1][idx2]!=-1) return dp[idx1][idx2];\\n        if(ring[idx1]==key[idx2]){\\n            return 1+helper(ring,key,idx1,idx2+1,mp);\\n        }\\n        int ans = INT_MAX;\\n        char tofind = key[idx2];\\n        vector<int> allIdx = mp[tofind];\\n        \\n        for(auto it : allIdx){\\n            int mindist = min(abs(it-idx1),n-abs(it-idx1));\\n            int tempans = helper(ring,key,it,idx2,mp);\\n            if(tempans!=INT_MAX)\\n            ans = min(ans,mindist+tempans);\\n        }\\n        return dp[idx1][idx2] = ans;\\n    }\\n\\n    int findRotateSteps(string ring, string key) {\\n        memset(dp,-1,sizeof(dp));\\n        map<char,vector<int>> mp;\\n        for(int i = 0;i<ring.size();i++){\\n            mp[ring[i]].push_back(i);\\n        }\\n        return helper(ring,key,0,0,mp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int helper(string& ring,string& key,int idx1,int idx2,map<char,vector<int>>& mp){\\n        int n = ring.size();\\n        if(idx2==key.size()){\\n            return 0;\\n        }\\n        if(dp[idx1][idx2]!=-1) return dp[idx1][idx2];\\n        if(ring[idx1]==key[idx2]){\\n            return 1+helper(ring,key,idx1,idx2+1,mp);\\n        }\\n        int ans = INT_MAX;\\n        char tofind = key[idx2];\\n        vector<int> allIdx = mp[tofind];\\n        \\n        for(auto it : allIdx){\\n            int mindist = min(abs(it-idx1),n-abs(it-idx1));\\n            int tempans = helper(ring,key,it,idx2,mp);\\n            if(tempans!=INT_MAX)\\n            ans = min(ans,mindist+tempans);\\n        }\\n        return dp[idx1][idx2] = ans;\\n    }\\n\\n    int findRotateSteps(string ring, string key) {\\n        memset(dp,-1,sizeof(dp));\\n        map<char,vector<int>> mp;\\n        for(int i = 0;i<ring.size();i++){\\n            mp[ring[i]].push_back(i);\\n        }\\n        return helper(ring,key,0,0,mp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2172830,
                "title": "c-concise-top-down-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<int> pos[26];\\n    int findRotateSteps(string ring, string key) {\\n        n = ring.size(), m = key.size();\\n        for(int i = 0; i < n; i++)\\n            pos[ring[i] - \\'a\\'].push_back(i);\\n        vector<vector<int>> memo(n, vector<int>(m, INT_MAX));\\n        return helper(0, 0, memo, ring, key);\\n    }\\n    int helper(int i, int j, vector<vector<int>>& memo, string &ring, string &key){\\n        if(j == m) return 0;\\n        if(memo[i][j] != INT_MAX) return memo[i][j];\\n        int best = INT_MAX;\\n        for(int &next: pos[key[j] - \\'a\\']){\\n            int diff = abs(i - next);\\n            best = min(best, min(diff, n - diff) + helper(next, j + 1, memo, ring, key));\\n        }\\n        return memo[i][j] = best + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<int> pos[26];\\n    int findRotateSteps(string ring, string key) {\\n        n = ring.size(), m = key.size();\\n        for(int i = 0; i < n; i++)\\n            pos[ring[i] - \\'a\\'].push_back(i);\\n        vector<vector<int>> memo(n, vector<int>(m, INT_MAX));\\n        return helper(0, 0, memo, ring, key);\\n    }\\n    int helper(int i, int j, vector<vector<int>>& memo, string &ring, string &key){\\n        if(j == m) return 0;\\n        if(memo[i][j] != INT_MAX) return memo[i][j];\\n        int best = INT_MAX;\\n        for(int &next: pos[key[j] - \\'a\\']){\\n            int diff = abs(i - next);\\n            best = min(best, min(diff, n - diff) + helper(next, j + 1, memo, ring, key));\\n        }\\n        return memo[i][j] = best + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1869263,
                "title": "java-dp-solution",
                "content": "```\\nclass Solution {\\n    private Map<Character, List<Integer>> charToIndex = new HashMap<>();\\n    private int[][] memo;\\n    private int m, n;\\n    \\n    public int findRotateSteps(String ring, String key) {\\n        this.m = ring.length();\\n        this.n = key.length();\\n        memo = new int[m][n];\\n        \\n        for(int i = 0; i < m; i++) {   \\n            char c = ring.charAt(i);\\n            \\n            charToIndex.putIfAbsent(c, new ArrayList<>());\\n            charToIndex.get(c).add(i);\\n        }\\n        \\n        return dp(ring, 0, key, 0);\\n    }\\n    \\n    private int dp(String ring, int i, String key, int j) {\\n        if(j == n) {\\n            return 0;\\n        }\\n        \\n        if(memo[i][j] != 0) {\\n            return memo[i][j];\\n        }\\n                \\n        int res = Integer.MAX_VALUE;\\n        \\n        for(int k: charToIndex.get(key.charAt(j))) {\\n            int diff = Math.abs(k - i);\\n            \\n            // clockwise or anticlockwise\\n            diff = Math.min(diff, m - diff);\\n            \\n            int subProblem = dp(ring, k, key, j + 1);\\n            \\n            // 1: button press\\n            res = Math.min(res, diff + 1 + subProblem);\\n        }\\n        \\n        memo[i][j] = res;\\n        \\n        return memo[i][j];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    private Map<Character, List<Integer>> charToIndex = new HashMap<>();\\n    private int[][] memo;\\n    private int m, n;\\n    \\n    public int findRotateSteps(String ring, String key) {\\n        this.m = ring.length();\\n        this.n = key.length();\\n        memo = new int[m][n];\\n        \\n        for(int i = 0; i < m; i++) {   \\n            char c = ring.charAt(i);\\n            \\n            charToIndex.putIfAbsent(c, new ArrayList<>());\\n            charToIndex.get(c).add(i);\\n        }\\n        \\n        return dp(ring, 0, key, 0);\\n    }\\n    \\n    private int dp(String ring, int i, String key, int j) {\\n        if(j == n) {\\n            return 0;\\n        }\\n        \\n        if(memo[i][j] != 0) {\\n            return memo[i][j];\\n        }\\n                \\n        int res = Integer.MAX_VALUE;\\n        \\n        for(int k: charToIndex.get(key.charAt(j))) {\\n            int diff = Math.abs(k - i);\\n            \\n            // clockwise or anticlockwise\\n            diff = Math.min(diff, m - diff);\\n            \\n            int subProblem = dp(ring, k, key, j + 1);\\n            \\n            // 1: button press\\n            res = Math.min(res, diff + 1 + subProblem);\\n        }\\n        \\n        memo[i][j] = res;\\n        \\n        return memo[i][j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367426,
                "title": "python3-top-down-dp",
                "content": "\\n```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        locs = {}\\n        for i, ch in enumerate(ring): locs.setdefault(ch, []).append(i)\\n            \\n        @cache \\n        def fn(i, j): \\n            \"\"\"Return turns to finish key[j:] startin from ith position on ring.\"\"\"\\n            if j == len(key): return 0 \\n            loc = locs[key[j]]\\n            k = bisect_left(loc, i) % len(loc)\\n            ans = min(abs(i-loc[k]), len(ring) - abs(i-loc[k])) + fn(loc[k], j+1)\\n            k = (k-1) % len(loc)\\n            ans = min(ans, min(abs(i-loc[k]), len(ring) - abs(i-loc[k])) + fn(loc[k], j+1))\\n            return ans \\n        \\n        return fn(0, 0) + len(key)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        locs = {}\\n        for i, ch in enumerate(ring): locs.setdefault(ch, []).append(i)\\n            \\n        @cache \\n        def fn(i, j): \\n            \"\"\"Return turns to finish key[j:] startin from ith position on ring.\"\"\"\\n            if j == len(key): return 0 \\n            loc = locs[key[j]]\\n            k = bisect_left(loc, i) % len(loc)\\n            ans = min(abs(i-loc[k]), len(ring) - abs(i-loc[k])) + fn(loc[k], j+1)\\n            k = (k-1) % len(loc)\\n            ans = min(ans, min(abs(i-loc[k]), len(ring) - abs(i-loc[k])) + fn(loc[k], j+1))\\n            return ans \\n        \\n        return fn(0, 0) + len(key)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971811,
                "title": "c-dp-with-memoization-the-simplest-ever",
                "content": "The code is pretty much self explainatory, we keep a start pointer to mark the 12:00 position and move it in a circular fashion to calculate the values. \\n\\n```\\n    int memo(string ring, string key, int start, int n, int m, int ki, vector<vector<int>> & dp){\\n        \\n        if(start >=n || ki>= m) return 0; \\n        if(dp[ki][start]!= -1)return dp[ki][start]; \\n        int i=0; \\n        int res = INT_MAX; \\n        for(int i=start;i<n+start; i++){\\n            if(ring[i%n] == key[ki]){\\n                int add = min(abs(i%n-start), abs(n- abs(i%n-start))); \\n                res = min( add+ memo(ring,key, i%n, n,m,ki+1, dp), res); \\n                \\n            }\\n        }\\n        return dp[ki][start] = res ; \\n        \\n    }\\n    \\n    int findRotateSteps(string ring, string key) {\\n        int n = ring.size() ;\\n        int m = key.size(); \\n        vector<vector <int>> dp(m+1,vector <int> (n+1, -1)) ;\\n        return memo(ring, key, 0, n, m, 0, dp) +key.size(); \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\n    int memo(string ring, string key, int start, int n, int m, int ki, vector<vector<int>> & dp){\\n        \\n        if(start >=n || ki>= m) return 0; \\n        if(dp[ki][start]!= -1)return dp[ki][start]; \\n        int i=0; \\n        int res = INT_MAX; \\n        for(int i=start;i<n+start; i++){\\n            if(ring[i%n] == key[ki]){\\n                int add = min(abs(i%n-start), abs(n- abs(i%n-start))); \\n                res = min( add+ memo(ring,key, i%n, n,m,ki+1, dp), res); \\n                \\n            }\\n        }\\n        return dp[ki][start] = res ; \\n        \\n    }\\n    \\n    int findRotateSteps(string ring, string key) {\\n        int n = ring.size() ;\\n        int m = key.size(); \\n        vector<vector <int>> dp(m+1,vector <int> (n+1, -1)) ;\\n        return memo(ring, key, 0, n, m, 0, dp) +key.size(); \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 758356,
                "title": "java-memoization-fast-commented-code",
                "content": "```\\nclass Solution {\\n    \\n    int[][] memo;\\n    \\n    public int findRotateSteps(String ring, String key) {\\n        this.memo = new int[ring.length()][key.length()]; // the first key is the position on the ring we are on, the second is how many letters we have completed!\\n        return dfs(ring, key, 0, 0);\\n    }\\n    \\n    // pos represents the pos of the ring we are sitting on, and the steps represents how many letters we\\'ve gone through\\n    public int dfs(String ring, String key, int pos, int steps) {\\n        \\n        if (steps == key.length())\\n            return 0;\\n        \\n        // have we already analyzed one path? -- no point moving further left or right from this position        \\n        if (this.memo[pos][steps] != 0)            \\n            return this.memo[pos][steps];\\n\\n        boolean clockWise = false, counterClockWise = false;\\n        int clockSteps = Integer.MAX_VALUE, counterClockSteps = Integer.MAX_VALUE;\\n        \\n        for (int i = 0; i < ring.length(); i++) {\\n            int curr = (i + pos) % ring.length(); // handles loop\\n            if (!clockWise && ring.charAt(curr) == key.charAt(steps)) {\\n                clockSteps = i + dfs(ring, key, curr, steps + 1);\\n                clockWise = true;\\n            }\\n            \\n            int curr2 = pos - i;\\n            if (curr2 < 0)\\n                curr2 = ring.length() + pos - i; // every position we are negative is one off of the length!\\n            \\n            if (!counterClockWise && ring.charAt(curr2) == key.charAt(steps)) {\\n                counterClockSteps = i + dfs(ring, key, curr2, steps + 1);\\n                counterClockWise = true;\\n            }\\n            \\n            if (clockWise && counterClockWise)\\n                break;\\n        }\\n        \\n        return this.memo[pos][steps] = Math.min(clockSteps, counterClockSteps) + 1; // +1 to click the button\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "class Solution {\\n    \\n    int[][] memo;\\n    \\n    public int findRotateSteps(String ring, String key) {\\n        this.memo = new int[ring.length()][key.length()]; // the first key is the position on the ring we are on, the second is how many letters we have completed!\\n        return dfs(ring, key, 0, 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 748290,
                "title": "c-solution-beasts-80-time-and-90-mem",
                "content": "First I think it\\'s a greedy problem, however when implement it, I realize it should be a DP problem, because the optimal choice for one step is not neccessary the optimal choice for the whole process (just like Jump game, you don\\'t always choose the furthest steps). So whenever you find a character of `key` in `ring`, consider it as an option and process further and select the option with smallest `cost`.\\n\\nPS: waste to much time on the testcase with `size > 100` because I don\\'t read the constrain.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> memo;\\n    int helper_fn(string& ring, string& key, int ring_pos, int key_pos) {\\n        if (key_pos >= key.size()) return 0;\\n        int cost = INT_MAX, n = ring.size();\\n        if (memo[ring_pos][key_pos] > 0) {\\n                return memo[ring_pos][key_pos];\\n        }\\n        /// it\\'s dp, not greedy, because you don\\'t know what\\'s comming though\\n        for (int j = 0, i = ring_pos; j < n; ++i, ++j) {\\n            if (i >= n) i = 0;\\n            if (ring[i] == key[key_pos]) {\\n                cost = min(cost,min(j,n-j)+1+helper_fn(ring,key,i,key_pos+1));\\n            }\\n        }\\n        memo[ring_pos][key_pos] = cost;\\n        return cost;\\n    }\\n    \\n    int findRotateSteps(string ring, string key) {\\n        int n = ring.size(), m = key.size();\\n        memo = vector<vector<int>>(n,vector<int>(m,0));\\n        return helper_fn(ring,key,0,0);\\n    }\\n};\\n\\n/*\\nLEDUCCANH\\nDUCE\\n\\nint find(s,char,pos)->cost\\nit\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> memo;\\n    int helper_fn(string& ring, string& key, int ring_pos, int key_pos) {\\n        if (key_pos >= key.size()) return 0;\\n        int cost = INT_MAX, n = ring.size();\\n        if (memo[ring_pos][key_pos] > 0) {\\n                return memo[ring_pos][key_pos];\\n        }\\n        /// it\\'s dp, not greedy, because you don\\'t know what\\'s comming though\\n        for (int j = 0, i = ring_pos; j < n; ++i, ++j) {\\n            if (i >= n) i = 0;\\n            if (ring[i] == key[key_pos]) {\\n                cost = min(cost,min(j,n-j)+1+helper_fn(ring,key,i,key_pos+1));\\n            }\\n        }\\n        memo[ring_pos][key_pos] = cost;\\n        return cost;\\n    }\\n    \\n    int findRotateSteps(string ring, string key) {\\n        int n = ring.size(), m = key.size();\\n        memo = vector<vector<int>>(n,vector<int>(m,0));\\n        return helper_fn(ring,key,0,0);\\n    }\\n};\\n\\n/*\\nLEDUCCANH\\nDUCE\\n\\nint find(s,char,pos)->cost\\nit\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 607266,
                "title": "python-min-heap-solution",
                "content": "Basic Idea: Use a min heap to store all possible combination of `(totalDistance, currentLocationOnRing, currentIndexInKey)`. Always search the branch with min totalDistance.\\n\\nOptimization: Use `seen` hash set to store visited `(currentLocationOnRing, currentIndexInKey)`. \\nIf the same `(currentLocationOnRing, currentIndexInKey)` combination appears 2 times in the heap, the 2nd one must has larger `totalDistance` than the 1st, it won\\'t be the optimal solution.  \\n\\n```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        N = len(ring)\\n        \\n        def dist(i, j):\\n            return min((i - j) % N, (j - i) % N)\\n        \\n        lookup = collections.defaultdict(list)\\n        for i, char in enumerate(ring):\\n            lookup[char].append(i)\\n        \\n        # tuple in heap: (totalDist, ringLoc, index of char in key)\\n        heap = [(0, 0, 0)]\\n        # tuple in seen: (ringLoc, index of char in key)\\n        seen = set()\\n        \\n        while heap:\\n            totalDist, ringLoc, i = heapq.heappop(heap)\\n            if i == len(key):\\n                return totalDist + len(key)\\n            if (ringLoc, i) in seen:\\n                continue\\n            seen.add((ringLoc, i))\\n            for nextLoc in lookup[key[i]]:\\n                heapq.heappush(\\n                    heap, \\n                    (totalDist + dist(ringLoc, nextLoc), nextLoc, i + 1)\\n                )\\n```\\t\\t\\t\\t",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        N = len(ring)\\n        \\n        def dist(i, j):\\n            return min((i - j) % N, (j - i) % N)\\n        \\n        lookup = collections.defaultdict(list)\\n        for i, char in enumerate(ring):\\n            lookup[char].append(i)\\n        \\n        # tuple in heap: (totalDist, ringLoc, index of char in key)\\n        heap = [(0, 0, 0)]\\n        # tuple in seen: (ringLoc, index of char in key)\\n        seen = set()\\n        \\n        while heap:\\n            totalDist, ringLoc, i = heapq.heappop(heap)\\n            if i == len(key):\\n                return totalDist + len(key)\\n            if (ringLoc, i) in seen:\\n                continue\\n            seen.add((ringLoc, i))\\n            for nextLoc in lookup[key[i]]:\\n                heapq.heappush(\\n                    heap, \\n                    (totalDist + dist(ringLoc, nextLoc), nextLoc, i + 1)\\n                )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385193,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int dist(int size, int p, int t){\\n        return min(abs(t - p), size - abs(t - p));\\n    }\\n    int findRotateSteps(string ring, string key){\\n        int m[26][100] = {{0}};\\n        int cnt[26] = {0};\\n        int dp[100][100] = {{0}};\\n\\n        const int rn = ring.size();\\n        const int kn = key.size();\\n        for(int i = 0; i < rn; ++i)\\n            m[ring[i]-\\'a\\'][cnt[ring[i]-\\'a\\']++] = i;\\n\\n        for(int i = 0; i < cnt[key[0]-\\'a\\']; ++i){\\n                dp[0][m[key[0]-\\'a\\'][i]] = dist(rn, 0, m[key[0]-\\'a\\'][i]) + 1;\\n        }\\n        for(int i = 1; i < kn; ++i){\\n            for(int j = 0; j < cnt[key[i]-\\'a\\']; ++j){\\n                int mini = INT_MAX;\\n                for(int k = 0; k < cnt[key[i-1]-\\'a\\']; ++k){\\n                    mini = min(mini, dp[i-1][m[key[i-1]-\\'a\\'][k]] + dist(rn, m[key[i]-\\'a\\'][j], m[key[i-1]-\\'a\\'][k]) + 1);\\n                }\\n                dp[i][m[key[i]-\\'a\\'][j]] = mini;\\n            }\\n        }\\n        int res = INT_MAX;\\n        for(int i = 0; i < cnt[key.back()-\\'a\\']; ++i){\\n            res = min(res, dp[kn-1][m[key[kn-1]-\\'a\\'][i]]);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n```Python3 []\\nimport bisect\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        \\n        n = len(ring)\\n        ind_dict = defaultdict(list)\\n        for i, l in enumerate(ring):\\n            ind_dict[l].append(i)\\n        \\n        prev_arr = [0]\\n        prev_inds = [0]\\n        for l in key:\\n            inds = ind_dict[l]\\n            arr = [0] * len(inds)\\n            next_inds = [0] * len(inds)\\n            for i, ind in enumerate(inds):\\n                j = bisect.bisect(prev_inds, ind)\\n                if j == len(prev_inds):\\n                    dist = min(prev_arr[-1] + ind - prev_inds[-1], prev_arr[0] + prev_inds[0] + n - ind)\\n                elif j == 0:\\n                    dist = min(prev_arr[-1] + ind + n - prev_inds[-1], prev_arr[0] + prev_inds[0] - ind)\\n                else:\\n                    dist = min(prev_arr[j - 1] + ind - prev_inds[j - 1], prev_arr[j] + prev_inds[j] - ind)\\n                arr[i] = dist\\n            prev_arr = arr\\n            prev_inds = inds\\n        return min(arr) + len(key)\\n```\\n\\n```Java []\\nclass Solution {\\n    public int findRotateSteps(String ring, String key) {\\n        char[] r=ring.toCharArray();\\n        List<Integer>[] p=new List[26];\\n        for(int i=0;i<r.length;i++) {\\n            int c=r[i]-\\'a\\';\\n            List<Integer> l=p[c];\\n            if(l==null) p[c]=l=new ArrayList<>();\\n            l.add(i);\\n        }\\n        return helper(0,0,p,key.toCharArray(),ring,new int[key.length()][r.length]);\\n    }\\n    int helper(int in, int pos, List<Integer>[] p, char[] k, String r, int[][] memo) {\\n        if(in==k.length) return 0;\\n        if(memo[in][pos]>0) return memo[in][pos]-1;\\n        int min=Integer.MAX_VALUE;\\n        for(int i: p[k[in]-\\'a\\']) {\\n            int m;\\n            if(i>=pos) m=Math.min(i-pos,pos+r.length()-i);\\n            else m=Math.min(pos-i,i+r.length()-pos);\\n            min=Math.min(min,m+helper(in+1,i,p,k,r,memo));\\n        }\\n        return (memo[in][pos]=min+2)-1;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int dist(int size, int p, int t){\\n        return min(abs(t - p), size - abs(t - p));\\n    }\\n    int findRotateSteps(string ring, string key){\\n        int m[26][100] = {{0}};\\n        int cnt[26] = {0};\\n        int dp[100][100] = {{0}};\\n\\n        const int rn = ring.size();\\n        const int kn = key.size();\\n        for(int i = 0; i < rn; ++i)\\n            m[ring[i]-\\'a\\'][cnt[ring[i]-\\'a\\']++] = i;\\n\\n        for(int i = 0; i < cnt[key[0]-\\'a\\']; ++i){\\n                dp[0][m[key[0]-\\'a\\'][i]] = dist(rn, 0, m[key[0]-\\'a\\'][i]) + 1;\\n        }\\n        for(int i = 1; i < kn; ++i){\\n            for(int j = 0; j < cnt[key[i]-\\'a\\']; ++j){\\n                int mini = INT_MAX;\\n                for(int k = 0; k < cnt[key[i-1]-\\'a\\']; ++k){\\n                    mini = min(mini, dp[i-1][m[key[i-1]-\\'a\\'][k]] + dist(rn, m[key[i]-\\'a\\'][j], m[key[i-1]-\\'a\\'][k]) + 1);\\n                }\\n                dp[i][m[key[i]-\\'a\\'][j]] = mini;\\n            }\\n        }\\n        int res = INT_MAX;\\n        for(int i = 0; i < cnt[key.back()-\\'a\\']; ++i){\\n            res = min(res, dp[kn-1][m[key[kn-1]-\\'a\\'][i]]);\\n        }\\n        return res;\\n    }\\n};\\n```\n```Python3 []\\nimport bisect\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        \\n        n = len(ring)\\n        ind_dict = defaultdict(list)\\n        for i, l in enumerate(ring):\\n            ind_dict[l].append(i)\\n        \\n        prev_arr = [0]\\n        prev_inds = [0]\\n        for l in key:\\n            inds = ind_dict[l]\\n            arr = [0] * len(inds)\\n            next_inds = [0] * len(inds)\\n            for i, ind in enumerate(inds):\\n                j = bisect.bisect(prev_inds, ind)\\n                if j == len(prev_inds):\\n                    dist = min(prev_arr[-1] + ind - prev_inds[-1], prev_arr[0] + prev_inds[0] + n - ind)\\n                elif j == 0:\\n                    dist = min(prev_arr[-1] + ind + n - prev_inds[-1], prev_arr[0] + prev_inds[0] - ind)\\n                else:\\n                    dist = min(prev_arr[j - 1] + ind - prev_inds[j - 1], prev_arr[j] + prev_inds[j] - ind)\\n                arr[i] = dist\\n            prev_arr = arr\\n            prev_inds = inds\\n        return min(arr) + len(key)\\n```\n```Java []\\nclass Solution {\\n    public int findRotateSteps(String ring, String key) {\\n        char[] r=ring.toCharArray();\\n        List<Integer>[] p=new List[26];\\n        for(int i=0;i<r.length;i++) {\\n            int c=r[i]-\\'a\\';\\n            List<Integer> l=p[c];\\n            if(l==null) p[c]=l=new ArrayList<>();\\n            l.add(i);\\n        }\\n        return helper(0,0,p,key.toCharArray(),ring,new int[key.length()][r.length]);\\n    }\\n    int helper(int in, int pos, List<Integer>[] p, char[] k, String r, int[][] memo) {\\n        if(in==k.length) return 0;\\n        if(memo[in][pos]>0) return memo[in][pos]-1;\\n        int min=Integer.MAX_VALUE;\\n        for(int i: p[k[in]-\\'a\\']) {\\n            int m;\\n            if(i>=pos) m=Math.min(i-pos,pos+r.length()-i);\\n            else m=Math.min(pos-i,i+r.length()-pos);\\n            min=Math.min(min,m+helper(in+1,i,p,k,r,memo));\\n        }\\n        return (memo[in][pos]=min+2)-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941345,
                "title": "c-simple-and-short-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    \\n    int solve(string& ring,string& key,int topPos,int currIndex,vector<vector<int>>& dp) {\\n        if(currIndex >= key.size()) // base case\\n            return 0;\\n        if(dp[topPos][currIndex]!=-1) // if already visited this position then return\\n            return dp[topPos][currIndex];\\n        int ans = INT_MAX;\\n        for(int i=0;i<n;i++) { \\n            if(ring[(topPos+i)%n] == key[currIndex]) { // whenever the position on ring and key[currIndex], do dfs\\n                ans = min(ans, solve(ring,key,(topPos+i)%n,currIndex+1,dp) + min(i,n-i) + 1);  // min(i,n-i) added bcoz ring can be rotated in both directions, we take the minimum\\n            }\\n        }\\n        dp[topPos][currIndex] = ans;\\n        return ans;\\n    }\\n    \\n    int findRotateSteps(string ring, string key) {\\n        n = ring.size();\\n\\t\\t// creating the dp vector\\n        vector<vector<int>> dp(n+5,vector<int>(key.size()+5,-1));\\n        return solve(ring,key,0,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    \\n    int solve(string& ring,string& key,int topPos,int currIndex,vector<vector<int>>& dp) {\\n        if(currIndex >= key.size()) // base case\\n            return 0;\\n        if(dp[topPos][currIndex]!=-1) // if already visited this position then return\\n            return dp[topPos][currIndex];\\n        int ans = INT_MAX;\\n        for(int i=0;i<n;i++) { \\n            if(ring[(topPos+i)%n] == key[currIndex]) { // whenever the position on ring and key[currIndex], do dfs\\n                ans = min(ans, solve(ring,key,(topPos+i)%n,currIndex+1,dp) + min(i,n-i) + 1);  // min(i,n-i) added bcoz ring can be rotated in both directions, we take the minimum\\n            }\\n        }\\n        dp[topPos][currIndex] = ans;\\n        return ans;\\n    }\\n    \\n    int findRotateSteps(string ring, string key) {\\n        n = ring.size();\\n\\t\\t// creating the dp vector\\n        vector<vector<int>> dp(n+5,vector<int>(key.size()+5,-1));\\n        return solve(ring,key,0,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779800,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(string s,string t,int i,int j,vector<vector<int>>& dp){\\n        \\n        if(j>=t.size()){\\n            return 0;\\n        }\\n        \\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        \\n        char c=t[j];\\n        int k=i,cct=0;\\n        int p=i,act=0;\\n        while(true){\\n            if(s[k]==c){\\n                break;\\n            }\\n            k++;\\n            cct++;\\n            if(k==s.size()){\\n                k=0;\\n            }\\n        }\\n        while(true){\\n            if(s[p]==c){\\n                break;\\n            }\\n            p--;\\n            act++;\\n            if(p<0){\\n                p=s.size()-1;\\n            }\\n        }\\n        \\n        return dp[i][j]=min(cct+1+helper(s,t,k,j+1,dp),act+1+helper(s,t,p,j+1,dp));\\n        \\n        \\n        \\n        \\n    }\\n    int findRotateSteps(string ring, string key) {\\n       \\n        vector<vector<int>> dp(ring.size()+1,vector<int>(key.size()+1,-1));\\n        return helper(ring,key,0,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(string s,string t,int i,int j,vector<vector<int>>& dp){\\n        \\n        if(j>=t.size()){\\n            return 0;\\n        }\\n        \\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        \\n        char c=t[j];\\n        int k=i,cct=0;\\n        int p=i,act=0;\\n        while(true){\\n            if(s[k]==c){\\n                break;\\n            }\\n            k++;\\n            cct++;\\n            if(k==s.size()){\\n                k=0;\\n            }\\n        }\\n        while(true){\\n            if(s[p]==c){\\n                break;\\n            }\\n            p--;\\n            act++;\\n            if(p<0){\\n                p=s.size()-1;\\n            }\\n        }\\n        \\n        return dp[i][j]=min(cct+1+helper(s,t,k,j+1,dp),act+1+helper(s,t,p,j+1,dp));\\n        \\n        \\n        \\n        \\n    }\\n    int findRotateSteps(string ring, string key) {\\n       \\n        vector<vector<int>> dp(ring.size()+1,vector<int>(key.size()+1,-1));\\n        return helper(ring,key,0,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672096,
                "title": "dp-solution-explaination-youtube",
                "content": "https://www.youtube.com/watch?v=L1T6pd2etRI\\n\\nvery good explanation\\ncode:\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> memo;\\n    int helper_fn(string& ring, string& key, int ring_pos, int key_pos) {\\n        if (key_pos >= key.size()) return 0;\\n        int cost = INT_MAX, n = ring.size();\\n        if (memo[ring_pos][key_pos] > 0) {\\n                return memo[ring_pos][key_pos];\\n        }\\n        /// it\\'s dp, not greedy, because you don\\'t know what\\'s comming though\\n        for (int j = 0, i = ring_pos; j < n; ++i, ++j) {\\n            if (i >= n) i = 0;\\n            if (ring[i] == key[key_pos]) {\\n                cost = min(cost,min(j,n-j)+1+helper_fn(ring,key,i,key_pos+1));\\n            }\\n        }\\n        memo[ring_pos][key_pos] = cost;\\n        return cost;\\n    }\\n    \\n    int findRotateSteps(string ring, string key) {\\n        int n = ring.size(), m = key.size();\\n        memo = vector<vector<int>>(n,vector<int>(m,0));\\n        return helper_fn(ring,key,0,0);\\n    }\\n};\\n```\\nplease like if you find this helpful :)\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> memo;\\n    int helper_fn(string& ring, string& key, int ring_pos, int key_pos) {\\n        if (key_pos >= key.size()) return 0;\\n        int cost = INT_MAX, n = ring.size();\\n        if (memo[ring_pos][key_pos] > 0) {\\n                return memo[ring_pos][key_pos];\\n        }\\n        /// it\\'s dp, not greedy, because you don\\'t know what\\'s comming though\\n        for (int j = 0, i = ring_pos; j < n; ++i, ++j) {\\n            if (i >= n) i = 0;\\n            if (ring[i] == key[key_pos]) {\\n                cost = min(cost,min(j,n-j)+1+helper_fn(ring,key,i,key_pos+1));\\n            }\\n        }\\n        memo[ring_pos][key_pos] = cost;\\n        return cost;\\n    }\\n    \\n    int findRotateSteps(string ring, string key) {\\n        int n = ring.size(), m = key.size();\\n        memo = vector<vector<int>>(n,vector<int>(m,0));\\n        return helper_fn(ring,key,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2538914,
                "title": "easy-to-understand-memoization-c-solution",
                "content": "Faster than 34.65 %     Memory Usage Less than 11.01%   \\n\\nDefinitely not the best but pretty easy to understand this.\\n```\\nclass Solution {\\npublic:\\n    map<int,vector<int>> mp;\\n    int helper(string &ring,string &key,int x,int y,vector<vector<int>> &dp)\\n    {\\n        if(y>=key.size())return 0;\\n        if(dp[x][y]!=-1)return dp[x][y];\\n        int n=ring.size();\\n        vector<int> temp;\\n        for(int i=0;i<mp[key[y]-\\'a\\'].size();i++)\\n        {\\n            int dis=abs(mp[key[y]-\\'a\\'][i]-x);\\n            temp.push_back(1+dis+helper(ring,key,mp[key[y]-\\'a\\'][i],y+1,dp));      // clockwise position of the characters in ring\\n            temp.push_back(n-dis+1+helper(ring,key,mp[key[y]-\\'a\\'][i],y+1,dp));    // Anti-clockwise position of the character in ring\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  \\n        }\\n        return dp[x][y]=*min_element(temp.begin(),temp.end());                    // We are storing all possible values from each found  \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  // character position,then returning the best possible outcome.\\n    }\\n    int findRotateSteps(string ring, string key) {\\n        vector<vector<int>> dp(202,vector<int>(202,-1));                          \\n        for(int i=0;i<ring.size();i++)mp[ring[i]-\\'a\\'].push_back(i);               // Storing the positions of the characters in map\\n        return helper(ring,key,0,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,vector<int>> mp;\\n    int helper(string &ring,string &key,int x,int y,vector<vector<int>> &dp)\\n    {\\n        if(y>=key.size())return 0;\\n        if(dp[x][y]!=-1)return dp[x][y];\\n        int n=ring.size();\\n        vector<int> temp;\\n        for(int i=0;i<mp[key[y]-\\'a\\'].size();i++)\\n        {\\n            int dis=abs(mp[key[y]-\\'a\\'][i]-x);\\n            temp.push_back(1+dis+helper(ring,key,mp[key[y]-\\'a\\'][i],y+1,dp));      // clockwise position of the characters in ring\\n            temp.push_back(n-dis+1+helper(ring,key,mp[key[y]-\\'a\\'][i],y+1,dp));    // Anti-clockwise position of the character in ring\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  \\n        }\\n        return dp[x][y]=*min_element(temp.begin(),temp.end());                    // We are storing all possible values from each found  \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  // character position,then returning the best possible outcome.\\n    }\\n    int findRotateSteps(string ring, string key) {\\n        vector<vector<int>> dp(202,vector<int>(202,-1));                          \\n        for(int i=0;i<ring.size();i++)mp[ring[i]-\\'a\\'].push_back(i);               // Storing the positions of the characters in map\\n        return helper(ring,key,0,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2516947,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n    HashMap<Character, List<Integer>> charToIndex = new HashMap<>();\\n    int[][] memo;\\n    \\n    public int findRotateSteps(String ring, String key) {\\n        int m = ring.length();\\n        int n = key.length();\\n        memo = new int[m][n];\\n        \\n        for(int i = 0; i < ring.length(); i ++){\\n            char c = ring.charAt(i);\\n            if(!charToIndex.containsKey(c)){\\n                charToIndex.put(c, new LinkedList<Integer>());\\n            }\\n            charToIndex.get(c).add(i);\\n        }\\n        \\n        return dp(ring, 0, key, 0);\\n    }\\n    \\n    public int dp(String ring, int i, String key, int j){\\n        if(j == key.length()){\\n            return 0;\\n        }\\n        if(memo[i][j] != 0){\\n            return memo[i][j];\\n        }\\n        \\n        int n = ring.length();\\n        int res = Integer.MAX_VALUE;\\n        \\n        for(int k : charToIndex.get(key.charAt(j))){\\n            int delta = Math.abs(k - i);\\n            delta = Math.min(delta, n - delta);\\n            int subProblem = dp(ring, k, key, j + 1);\\n            res = Math.min(res, delta + 1 + subProblem);\\n        }\\n        \\n        memo[i][j] = res;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    HashMap<Character, List<Integer>> charToIndex = new HashMap<>();\\n    int[][] memo;\\n    \\n    public int findRotateSteps(String ring, String key) {\\n        int m = ring.length();\\n        int n = key.length();\\n        memo = new int[m][n];\\n        \\n        for(int i = 0; i < ring.length(); i ++){\\n            char c = ring.charAt(i);\\n            if(!charToIndex.containsKey(c)){\\n                charToIndex.put(c, new LinkedList<Integer>());\\n            }\\n            charToIndex.get(c).add(i);\\n        }\\n        \\n        return dp(ring, 0, key, 0);\\n    }\\n    \\n    public int dp(String ring, int i, String key, int j){\\n        if(j == key.length()){\\n            return 0;\\n        }\\n        if(memo[i][j] != 0){\\n            return memo[i][j];\\n        }\\n        \\n        int n = ring.length();\\n        int res = Integer.MAX_VALUE;\\n        \\n        for(int k : charToIndex.get(key.charAt(j))){\\n            int delta = Math.abs(k - i);\\n            delta = Math.min(delta, n - delta);\\n            int subProblem = dp(ring, k, key, j + 1);\\n            res = Math.min(res, delta + 1 + subProblem);\\n        }\\n        \\n        memo[i][j] = res;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2369037,
                "title": "faster-than-96-40-python3",
                "content": "![image](https://assets.leetcode.com/users/images/f8f1d4b6-c057-48b3-9172-cbb4ada2d11c_1659439500.6358123.png)\\n```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        char_pos = defaultdict(set)\\n        for i, c in enumerate(ring):\\n            char_pos[c].add(i)\\n        \\n        def minStep(fromm, to):\\n            if fromm == to:\\n                return 0\\n            minSteps = abs(fromm - to)\\n            minSteps = min(minSteps, abs(len(ring) - minSteps))\\n            return minSteps\\n        \\n        n = len(key)\\n        dp = [0] * len(ring)\\n        for p in char_pos[key[0]]:\\n            dp[p] = minStep(0, p)\\n        prev_char = key[0]\\n        for c in key[1:]:\\n            if prev_char == c:\\n                continue\\n            for next_pos in char_pos[c]:\\n                dp[next_pos] = min(dp[prev_pos] + minStep(prev_pos, next_pos) for prev_pos in char_pos[prev_char])\\n            prev_char = c\\n        return min(dp[p] for p in char_pos[prev_char]) + len(key)\\n```\\n.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        char_pos = defaultdict(set)\\n        for i, c in enumerate(ring):\\n            char_pos[c].add(i)\\n        \\n        def minStep(fromm, to):\\n            if fromm == to:\\n                return 0\\n            minSteps = abs(fromm - to)\\n            minSteps = min(minSteps, abs(len(ring) - minSteps))\\n            return minSteps\\n        \\n        n = len(key)\\n        dp = [0] * len(ring)\\n        for p in char_pos[key[0]]:\\n            dp[p] = minStep(0, p)\\n        prev_char = key[0]\\n        for c in key[1:]:\\n            if prev_char == c:\\n                continue\\n            for next_pos in char_pos[c]:\\n                dp[next_pos] = min(dp[prev_pos] + minStep(prev_pos, next_pos) for prev_pos in char_pos[prev_char])\\n            prev_char = c\\n        return min(dp[p] for p in char_pos[prev_char]) + len(key)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2255804,
                "title": "c-top-down-recursion-with-memoization-cleanest-code",
                "content": "Please upvote\\n```\\nclass Solution {\\npublic:\\n   \\n    int helper(string s,string t,int i,int j,vector<vector<int>>& dp){\\n        \\n        if(j>=t.size()){\\n            return 0;\\n        }\\n        \\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        \\n        char c=t[j];//this is the current character of t which needs to be macthed\\n    \\n        //and we are at the ith postion currently\\n        int k=i,cct=0;\\n\\t\\t//cct means clowise count fro clockwise rotation\\n        int p=i,act=0;\\n      //act means anitclockwise count fot anticlockwise rotation\\n        while(true){\\n            if(s[k]==c){\\n                break;\\n            }\\n            k++;\\n            cct++;\\n            if(k==s.size()){\\n                k=0;\\n            }\\n        }\\n        while(true){\\n            if(s[p]==c){\\n                break;\\n            }\\n            p--;\\n            act++;\\n            if(p<0){\\n                p=s.size()-1;\\n            }\\n        }\\n        \\n        return dp[i][j]=min(cct+1+helper(s,t,k,j+1,dp),act+1+helper(s,t,p,j+1,dp));\\n        \\n        \\n        \\n        \\n    }\\n    int findRotateSteps(string ring, string key) {\\n        //the only thing is you can rotate in two ways\\n        //either clockwise or anticlockwise AT EACH STEP\\n        //so do both and take the minimum \\n        //knapscak types although not that similar\\n        vector<vector<int>> dp(ring.size()+1,vector<int>(key.size()+1,-1));\\n        return helper(ring,key,0,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int helper(string s,string t,int i,int j,vector<vector<int>>& dp){\\n        \\n        if(j>=t.size()){\\n            return 0;\\n        }\\n        \\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        \\n        char c=t[j];//this is the current character of t which needs to be macthed\\n    \\n        //and we are at the ith postion currently\\n        int k=i,cct=0;\\n\\t\\t//cct means clowise count fro clockwise rotation\\n        int p=i,act=0;\\n      //act means anitclockwise count fot anticlockwise rotation\\n        while(true){\\n            if(s[k]==c){\\n                break;\\n            }\\n            k++;\\n            cct++;\\n            if(k==s.size()){\\n                k=0;\\n            }\\n        }\\n        while(true){\\n            if(s[p]==c){\\n                break;\\n            }\\n            p--;\\n            act++;\\n            if(p<0){\\n                p=s.size()-1;\\n            }\\n        }\\n        \\n        return dp[i][j]=min(cct+1+helper(s,t,k,j+1,dp),act+1+helper(s,t,p,j+1,dp));\\n        \\n        \\n        \\n        \\n    }\\n    int findRotateSteps(string ring, string key) {\\n        //the only thing is you can rotate in two ways\\n        //either clockwise or anticlockwise AT EACH STEP\\n        //so do both and take the minimum \\n        //knapscak types although not that similar\\n        vector<vector<int>> dp(ring.size()+1,vector<int>(key.size()+1,-1));\\n        return helper(ring,key,0,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2023821,
                "title": "100-faster-c-solution",
                "content": "public class Solution {\\n    \\n    Dictionary<Tuple<int,int>,int> m = new Dictionary<Tuple<int,int>,int>();\\n    \\n    public int FindRotateSteps(string ring, string key) {\\n\\n        int steps = FindRotateSteps(ring,key,0,0);\\n            \\n        return steps;\\n    }\\n    \\n    public int FindRotateSteps(string r, string k, int rp, int kp) {\\n        if(kp == k.Length) {\\n            // End of the spell!\\n            return 0;\\n        }\\n        else {\\n            Tuple<int,int> cacheKey = new Tuple<int,int>(rp,kp);\\n            if(m.ContainsKey(cacheKey)) {\\n                return m[cacheKey];\\n            }\\n            int localMinStep = Int32.MaxValue;\\n            int leftP = rp;\\n            int rightP = rp;\\n            int distance = 0;\\n            \\n            for(int i=0;i<(r.Length/2)+1;i++) {\\n                int stepNeeded = 0;\\n                \\n                if(r[rightP] == k[kp]) {\\n                    int childSteps = FindRotateSteps(r,k,rightP,kp+1);\\n                    stepNeeded = distance + 1 + childSteps;\\n                    if(localMinStep > stepNeeded) {\\n                        localMinStep = stepNeeded;\\n                    }\\n                }\\n                \\n                if(r[leftP] == k[kp]) {\\n                    int childSteps = FindRotateSteps(r,k,leftP,kp+1);\\n                    stepNeeded = distance + 1 + childSteps;\\n                    if(localMinStep > stepNeeded) {\\n                        localMinStep = stepNeeded;\\n                    }\\n                }\\n                \\n                distance++;\\n                leftP--;\\n                rightP++;\\n                if(leftP < 0) {\\n                    leftP = r.Length-1;\\n                }\\n                if(rightP > r.Length -1) {\\n                    rightP = 0;\\n                }\\n                \\n            }\\n            \\n            m.Add(cacheKey,localMinStep);\\n            return localMinStep;\\n        }\\n    }\\n    \\n\\n}",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\n    \\n    Dictionary<Tuple<int,int>,int> m = new Dictionary<Tuple<int,int>,int>();\\n    \\n    public int FindRotateSteps(string ring, string key) {\\n\\n        int steps = FindRotateSteps(ring,key,0,0);\\n            \\n        return steps;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1967582,
                "title": "python-dp-solution",
                "content": "```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        keys = defaultdict(list)\\n        for ind, c in enumerate(ring):\\n            keys[c].append(ind)\\n        def getVals(pos, c):\\n            lst = []\\n            for ind in keys[c]:\\n                if pos < ind:\\n                    curr = min(ind-pos, len(ring)-ind+pos)\\n                elif pos > ind:\\n                    curr = min(pos-ind, len(ring)-pos+ind)\\n                else:\\n                    curr = 0\\n                lst.append((curr, ind))\\n            return lst\\n        @cache\\n        def dp(pos, ind):\\n            if ind == len(key):\\n                return 0\\n            if ring[pos] == key[ind]:\\n                return dp(pos, ind+1)\\n            lst = getVals(pos, key[ind])\\n            return min(x+dp(y, ind+1) for x, y in lst)\\n        return dp(0, 0) + len(key)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        keys = defaultdict(list)\\n        for ind, c in enumerate(ring):\\n            keys[c].append(ind)\\n        def getVals(pos, c):\\n            lst = []\\n            for ind in keys[c]:\\n                if pos < ind:\\n                    curr = min(ind-pos, len(ring)-ind+pos)\\n                elif pos > ind:\\n                    curr = min(pos-ind, len(ring)-pos+ind)\\n                else:\\n                    curr = 0\\n                lst.append((curr, ind))\\n            return lst\\n        @cache\\n        def dp(pos, ind):\\n            if ind == len(key):\\n                return 0\\n            if ring[pos] == key[ind]:\\n                return dp(pos, ind+1)\\n            lst = getVals(pos, key[ind])\\n            return min(x+dp(y, ind+1) for x, y in lst)\\n        return dp(0, 0) + len(key)",
                "codeTag": "Java"
            },
            {
                "id": 1842431,
                "title": "c-cleasnest-and-easiest-dp-code",
                "content": "```\\n    int dp[101][101], n, m                                                              ;\\n    string key, ring                                                                    ;\\n    int solve(int ring_pos, int key_pos)                                                {\\n        if(key_pos >= m) return 0                                                       ;\\n        if(dp[ring_pos][key_pos] != -1) return dp[ring_pos][key_pos]                    ;\\n        int steps = INT_MAX                                                             ;\\n        for(int i = 0; i < n; i++)                                                      {\\n            if(key[key_pos] == ring[i])                                                 {\\n                int clock_wise_dist = abs(i-ring_pos)                                   ;\\n                int anti_wise_dist = n-abs(i-ring_pos)                                  ;\\n                int next_word_dist = min(clock_wise_dist, anti_wise_dist)               ;\\n                int centre_button_press = 1                                             ;\\n                int future_cost = solve(i, key_pos+1)                                   ;\\n                steps = min(steps, (next_word_dist+centre_button_press+future_cost))    ;}}\\n        return dp[ring_pos][key_pos] = steps                                            ;}    \\n    \\n    int findRotateSteps(string r, string k)                                             {\\n        ring = r; key = k                                                               ;\\n        m = k.size(), n = r.size()                                                      ;\\n        memset(dp, -1, sizeof(dp))                                                      ;\\n        return solve(0,0)                                                               ;}\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n    int dp[101][101], n, m                                                              ;\\n    string key, ring                                                                    ;\\n    int solve(int ring_pos, int key_pos)                                                {\\n        if(key_pos >= m) return 0                                                       ;\\n        if(dp[ring_pos][key_pos] != -1) return dp[ring_pos][key_pos]                    ;\\n        int steps = INT_MAX                                                             ;\\n        for(int i = 0; i < n; i++)                                                      {\\n            if(key[key_pos] == ring[i])                                                 {\\n                int clock_wise_dist = abs(i-ring_pos)                                   ;\\n                int anti_wise_dist = n-abs(i-ring_pos)                                  ;\\n                int next_word_dist = min(clock_wise_dist, anti_wise_dist)               ;\\n                int centre_button_press = 1                                             ;\\n                int future_cost = solve(i, key_pos+1)                                   ;\\n                steps = min(steps, (next_word_dist+centre_button_press+future_cost))    ;}}\\n        return dp[ring_pos][key_pos] = steps                                            ;}    \\n    \\n    int findRotateSteps(string r, string k)                                             {\\n        ring = r; key = k                                                               ;\\n        m = k.size(), n = r.size()                                                      ;\\n        memset(dp, -1, sizeof(dp))                                                      ;\\n        return solve(0,0)                                                               ;}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1821924,
                "title": "python-naive-recursion-with-cache",
                "content": "The recurrence relation is straight-forward, either take a clockwise step or take an anti-clockwise step to find the next character:\\n\\n`rec(i) = min(clockwise(i+1), anticlockwise(i+1))` for `0 <= i < len(key)`\\n\\nCode:\\n```python\\nclass Solution:\\n\\t# Finds distance of char in the ring from 0th index,\\n\\t# in either clockwise (-1) or anti-clockwise (1) direction\\n    def find_char_dist(self, char, ring, direction):\\n        dist = 1    # initialize with 1 just to account for pressing the center button\\n        n = len(ring)\\n        for i in range(n):\\n            if ring[(n+i*direction)%n] == char:\\n                return dist\\n            dist += 1\\n    \\n\\t# rotates the ring by dist amount (can be negative).\\n\\t# [slow, better to use indices than creating new string everytime]\\n    def rotate(self, ring, dist):\\n        return ring[dist:] + ring[:dist]\\n            \\n\\t# The recursive function\\n    @cache\\n    def rec(self, i, ring, key):\\n        if i == len(key): return 0\\n        acw = self.find_char_dist(key[i], ring, 1)\\n        cw = self.find_char_dist(key[i], ring, -1)\\n\\t\\t\\n\\t\\t# next line prunes redundant recursion branch when we find the char\\n\\t\\t# in 0th index, since we don\\'t rotate the string in either direction\\n        if acw == cw == 1:\\n            return 1 + self.rec(i+1, ring, key)\\n        \\n        return min(\\n            acw + self.rec(i+1, self.rotate(ring, acw-1), key),\\n            cw + self.rec(i+1, self.rotate(ring, -cw+1), key)\\n        )\\n        \\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        return self.rec(0, ring, key)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n\\t# Finds distance of char in the ring from 0th index,\\n\\t# in either clockwise (-1) or anti-clockwise (1) direction\\n    def find_char_dist(self, char, ring, direction):\\n        dist = 1    # initialize with 1 just to account for pressing the center button\\n        n = len(ring)\\n        for i in range(n):\\n            if ring[(n+i*direction)%n] == char:\\n                return dist\\n            dist += 1\\n    \\n\\t# rotates the ring by dist amount (can be negative).\\n\\t# [slow, better to use indices than creating new string everytime]\\n    def rotate(self, ring, dist):\\n        return ring[dist:] + ring[:dist]\\n            \\n\\t# The recursive function\\n    @cache\\n    def rec(self, i, ring, key):\\n        if i == len(key): return 0\\n        acw = self.find_char_dist(key[i], ring, 1)\\n        cw = self.find_char_dist(key[i], ring, -1)\\n\\t\\t\\n\\t\\t# next line prunes redundant recursion branch when we find the char\\n\\t\\t# in 0th index, since we don\\'t rotate the string in either direction\\n        if acw == cw == 1:\\n            return 1 + self.rec(i+1, ring, key)\\n        \\n        return min(\\n            acw + self.rec(i+1, self.rotate(ring, acw-1), key),\\n            cw + self.rec(i+1, self.rotate(ring, -cw+1), key)\\n        )\\n        \\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        return self.rec(0, ring, key)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750656,
                "title": "java-100-bfs-with-explanation-comments",
                "content": "First, some observations:\\n1. We will always press the button once for every letter in the key, so we can just ignore those presses and add them in at the very end.\\n2. If there are double letters (e.g. \\'b\\' immediately followed by \\'b\\'), there is no point in moving the ring for the second letter.\\n3. If we know all of the places in the ring where the kth letter in key is found, and if we know the minimum cost to reach the each of those places, then we can easily calculate the minimum cost for each of the places where the (k+1)th character of the key are found in the ring.  Therefore, we can solve inductively for each letter in the key.\\n\\nThis approach uses 2-row 2D arrays to track positions (pos) and costs (cost) of the letters at consecutive positions in the key.  Initially, the only entry is position zero (the first letter in ring) with cost zero.  In the first iteration, it finds all of the positions in the ring where the first letter of the key can be found, and calculates the distance to each one as the cost.  For the second iteration, it finds all of the positions in the ring where the second letter of the key is found, and for each position, it calculates the minimum total cost from the previous positions.  This process continues, alternately overwriting rows in pos and cost, until all letters in key have  been checked.  The final answer is the minimum cost, plus the number of letters in the key.\\n\\nExample: ring = \"godding\", key = \"gd\"\\n* Initially, the first row of pos indicates that there is one position (index zero), with cost zero.\\n* For the first letter of the key, the letter g can be found in two places in the ring, at index 0 and index 6.  The cost to reach index 0 is zero, and the cost to reach index 6 is 1.\\n* For the second letter of the key, the letter d can be found in two places in the ring, at index 2 and 3.  For index 2, we can get there from index 0 at a total cost of 0 + 2 (previous cost 0, plus distance from 0 to 2) or from index 6 at a total cost of 1 + 3 (previous cost 1, plus distance from 6 to 2).  The minimum cost to reach index 2 will be 2.  For index 3, we can get there from index 0 at a total cost of 0 + 3 or from index 6 at a total cost of 1 + 3, so the minimum cost to reach index 3 is 3.\\n* We have reached the end of the key.  Find the minimum total cost from the last letter, in this case min(2,3) = 2.  The answer is 2 plus the number of letters in key, or 2 + 2 = 4.\\n\\n```\\nclass Solution {\\n    public int findRotateSteps(String ring, String key) {\\n        final int ringLen = ring.length();\\n        int[][] pos = new int[2][ringLen];\\n        int[][] cost = new int[2][ringLen];\\n        int r = 0; // index of the last complete row\\n        int sz = 1; // size of the data in the last complete row\\n        int lastCh = \\' \\'; // last character\\n        for (int i = 0; i < key.length(); i++) {\\n            // If this character is the same as the last one, don\\'t move.\\n            char ch = key.charAt(i);\\n            if (ch == lastCh) continue;\\n\\n            // Otherwise, find all matching characters in the ring,\\n            // and compute the minimum distance (cost) to reach each one.\\n            int sz1 = 0;\\n            for (int j = 0; j < ringLen; j++) {\\n                if (ring.charAt(j) == ch) {\\n                    pos[1-r][sz1] = j;\\n                    int c = cost[r][0] + dist(ringLen, pos[r][0], j);\\n                    for (int k = 1; k < sz; k++) {\\n                        c = Math.min(c, cost[r][k] + dist(ringLen, pos[r][k], j));\\n                    }\\n                    cost[1-r][sz1++] = c;\\n                }\\n            }\\n\\n            // Update state for the next pass\\n            lastCh = ch;\\n            r = 1-r;\\n            sz = sz1;\\n        }\\n\\n        // Find the lowest cost, and return it\\n        int answer = cost[r][0];\\n        for (int k = 1; k < sz; k++) answer = Math.min(answer, cost[r][k]);\\n        return answer + key.length();\\n    }\\n    \\n    // Find the distance (cost) between two positions on a wheel of length ringLen.\\n    private int dist(int ringLen, int idx0, int idx1) {\\n        int diff = idx1 - idx0;\\n        if (diff < 0) return Math.min(-diff, ringLen + diff);\\n        return Math.min(diff, ringLen - diff);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findRotateSteps(String ring, String key) {\\n        final int ringLen = ring.length();\\n        int[][] pos = new int[2][ringLen];\\n        int[][] cost = new int[2][ringLen];\\n        int r = 0; // index of the last complete row\\n        int sz = 1; // size of the data in the last complete row\\n        int lastCh = \\' \\'; // last character\\n        for (int i = 0; i < key.length(); i++) {\\n            // If this character is the same as the last one, don\\'t move.\\n            char ch = key.charAt(i);\\n            if (ch == lastCh) continue;\\n\\n            // Otherwise, find all matching characters in the ring,\\n            // and compute the minimum distance (cost) to reach each one.\\n            int sz1 = 0;\\n            for (int j = 0; j < ringLen; j++) {\\n                if (ring.charAt(j) == ch) {\\n                    pos[1-r][sz1] = j;\\n                    int c = cost[r][0] + dist(ringLen, pos[r][0], j);\\n                    for (int k = 1; k < sz; k++) {\\n                        c = Math.min(c, cost[r][k] + dist(ringLen, pos[r][k], j));\\n                    }\\n                    cost[1-r][sz1++] = c;\\n                }\\n            }\\n\\n            // Update state for the next pass\\n            lastCh = ch;\\n            r = 1-r;\\n            sz = sz1;\\n        }\\n\\n        // Find the lowest cost, and return it\\n        int answer = cost[r][0];\\n        for (int k = 1; k < sz; k++) answer = Math.min(answer, cost[r][k]);\\n        return answer + key.length();\\n    }\\n    \\n    // Find the distance (cost) between two positions on a wheel of length ringLen.\\n    private int dist(int ringLen, int idx0, int idx1) {\\n        int diff = idx1 - idx0;\\n        if (diff < 0) return Math.min(-diff, ringLen + diff);\\n        return Math.min(diff, ringLen - diff);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1554501,
                "title": "c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int solve(string &ring,string &key,int ptr,int index){\\n        int n = ring.size();\\n        int m = key.size();\\n        if(index >= m) return 0;\\n        if(dp[index][ptr] != -1)\\n            return dp[index][ptr];\\n        int steps = 1e9;\\n        for(int i = 0;i < n;i++){\\n            if(ring[i] == key[index]){\\n                steps = min(steps,min(abs(i-ptr),n-abs(i-ptr))+1+solve(ring,key,i,index+1));\\n            }\\n        }\\n        return dp[index][ptr] = steps;\\n    }\\n    int findRotateSteps(string ring, string key) {\\n        int ptr = 0,index = 0;\\n        int n = ring.size();\\n        int m = key.size();\\n        dp.assign(m+1,vector<int>(n+1,-1));\\n        return solve(ring,key,ptr,index);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int solve(string &ring,string &key,int ptr,int index){\\n        int n = ring.size();\\n        int m = key.size();\\n        if(index >= m) return 0;\\n        if(dp[index][ptr] != -1)\\n            return dp[index][ptr];\\n        int steps = 1e9;\\n        for(int i = 0;i < n;i++){\\n            if(ring[i] == key[index]){\\n                steps = min(steps,min(abs(i-ptr),n-abs(i-ptr))+1+solve(ring,key,i,index+1));\\n            }\\n        }\\n        return dp[index][ptr] = steps;\\n    }\\n    int findRotateSteps(string ring, string key) {\\n        int ptr = 0,index = 0;\\n        int n = ring.size();\\n        int m = key.size();\\n        dp.assign(m+1,vector<int>(n+1,-1));\\n        return solve(ring,key,ptr,index);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546245,
                "title": "c-python-recursive-dp-memoization",
                "content": "graph stores the index of every character present in the ring.\\nif ptr be pointer to current char in ring and j be the indices of current char in key which is  present in graph,\\nthen just compute abs(ptr-j) for clockwise and abs(abs(ptr-j)-m) for anti-clockwise where m is length of ring\\nFinally apply memoization to wind it up.\\nC++ ->\\n\\n```\\nclass Solution {\\npublic:\\n    string Ring,Key;\\n    map<pair<int,int>,int> memo;\\n    int n,m;\\n    unordered_map<char,vector<int>> Graph;\\n    int dp(int ptr,int idx){\\n        if (idx==n) return 0;\\n        if (memo.find(make_pair(ptr,idx))!=memo.end()) return memo[make_pair(ptr,idx)];\\n        int ans=INT_MAX;\\n        for (int j:Graph[Key[idx]]) ans=min(ans,dp(j,idx+1)+min(abs(ptr-j),abs(abs(ptr-j)-m)));\\n        return memo[make_pair(ptr,idx)]=ans;\\n    }\\n    int findRotateSteps(string ring, string key) {\\n        ios_base::sync_with_stdio(false);cin.tie(NULL);\\n        Ring=ring;\\n        Key=key;\\n        m=ring.size();\\n        n=key.size();\\n        unordered_map<char,vector<int>> graph;\\n        for (int i=0;i<m;i++) graph[ring[i]].push_back(i);\\n        Graph=graph;\\n        return dp(0,0)+n;\\n    }\\n};\\n```\\n\\nPython ->\\n\\n```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        m,n=len(ring),len(key)\\n        graph=defaultdict(list)\\n        for i in range(m):\\n            graph[ring[i]].append(i)\\n        @lru_cache(None)\\n        def dp(ptr,idx):\\n            if (idx==n): return 0\\n            ans=sys.maxsize\\n            for j in graph[key[idx]]:\\n                ans=min(ans,dp(j,idx+1)+min(abs(ptr-j),abs(abs(ptr-j)-m)))\\n            return ans\\n        return dp(0,0)+n\\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string Ring,Key;\\n    map<pair<int,int>,int> memo;\\n    int n,m;\\n    unordered_map<char,vector<int>> Graph;\\n    int dp(int ptr,int idx){\\n        if (idx==n) return 0;\\n        if (memo.find(make_pair(ptr,idx))!=memo.end()) return memo[make_pair(ptr,idx)];\\n        int ans=INT_MAX;\\n        for (int j:Graph[Key[idx]]) ans=min(ans,dp(j,idx+1)+min(abs(ptr-j),abs(abs(ptr-j)-m)));\\n        return memo[make_pair(ptr,idx)]=ans;\\n    }\\n    int findRotateSteps(string ring, string key) {\\n        ios_base::sync_with_stdio(false);cin.tie(NULL);\\n        Ring=ring;\\n        Key=key;\\n        m=ring.size();\\n        n=key.size();\\n        unordered_map<char,vector<int>> graph;\\n        for (int i=0;i<m;i++) graph[ring[i]].push_back(i);\\n        Graph=graph;\\n        return dp(0,0)+n;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        m,n=len(ring),len(key)\\n        graph=defaultdict(list)\\n        for i in range(m):\\n            graph[ring[i]].append(i)\\n        @lru_cache(None)\\n        def dp(ptr,idx):\\n            if (idx==n): return 0\\n            ans=sys.maxsize\\n            for j in graph[key[idx]]:\\n                ans=min(ans,dp(j,idx+1)+min(abs(ptr-j),abs(abs(ptr-j)-m)))\\n            return ans\\n        return dp(0,0)+n\\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1476399,
                "title": "python-bfs-solution",
                "content": "- Use a queue to store the ring index, key index and step it took to get to the current state as you turn the ring clockwise (Towards the right) or anticlockwise (Towards the left).\\n- You need to wrap around while moving clockwise and anticlockwise.\\n- You need a visited set to store states you have been in before so you don\\'t continue exploring those states.\\n- There\\'s an edge case for  ring =\"aaaaa\" key=\"aaaaa\"\\n- I had to change this:  \\n  ```\\n\\t\\t\\t\\t  if(key[keyIndex] == ring[index]):\\n                    step += 1\\n                    keyIndex += 1\\n  ```\\n- To This:\\n\\n  ```\\n\\t           while(keyIndex < len(key) and key[keyIndex] == ring[index]):\\n                    step += 1\\n                    keyIndex += 1\\n  ```\\n  \\n- i.e if you at a ring letter that keeps matching the next key letter, continue matching and incrementing the steps\\n\\n```\\n        queue = deque([(0, 0, 0)])\\n        visited = set()\\n        \\n        while len(queue):\\n            \\n            for _ in range(len(queue)):\\n                keyIndex, index, step = queue.popleft()\\n                \\n                while(keyIndex < len(key) and key[keyIndex] == ring[index]):\\n                    step += 1\\n                    keyIndex += 1\\n\\n                if keyIndex == len(key):\\n                    return step\\n                \\n                rightIndex = 0 if index + 1 == len(ring) else index + 1\\n                \\n                if (keyIndex, rightIndex) not in visited:\\n                    visited.add((keyIndex, rightIndex))\\n                    queue.append((keyIndex, rightIndex, step + 1))\\n\\n                leftIndex = len(ring) - 1 if index - 1 == -1 else index - 1\\n                if (keyIndex, leftIndex) not in visited:\\n                    visited.add((keyIndex, leftIndex))\\n                    queue.append((keyIndex, leftIndex, step + 1))\\n        \\n        return -1\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\t\\t\\t  if(key[keyIndex] == ring[index]):\\n                    step += 1\\n                    keyIndex += 1\\n  ```\n```\\n\\t           while(keyIndex < len(key) and key[keyIndex] == ring[index]):\\n                    step += 1\\n                    keyIndex += 1\\n  ```\n```\\n        queue = deque([(0, 0, 0)])\\n        visited = set()\\n        \\n        while len(queue):\\n            \\n            for _ in range(len(queue)):\\n                keyIndex, index, step = queue.popleft()\\n                \\n                while(keyIndex < len(key) and key[keyIndex] == ring[index]):\\n                    step += 1\\n                    keyIndex += 1\\n\\n                if keyIndex == len(key):\\n                    return step\\n                \\n                rightIndex = 0 if index + 1 == len(ring) else index + 1\\n                \\n                if (keyIndex, rightIndex) not in visited:\\n                    visited.add((keyIndex, rightIndex))\\n                    queue.append((keyIndex, rightIndex, step + 1))\\n\\n                leftIndex = len(ring) - 1 if index - 1 == -1 else index - 1\\n                if (keyIndex, leftIndex) not in visited:\\n                    visited.add((keyIndex, leftIndex))\\n                    queue.append((keyIndex, leftIndex, step + 1))\\n        \\n        return -1\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1370880,
                "title": "eazy-pezy-memozi-sulonzi",
                "content": "```\\nclass Solution {\\n    public int findRotateSteps(String s, String key) {\\n    HashMap<Character,ArrayList<Integer>> hm=new HashMap<>();\\n        \\n        for(char i=\\'a\\';i<=\\'z\\';i++)\\n            hm.put(i,new ArrayList<>());\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            char ch=s.charAt(i);\\n            hm.get(ch).add(i);\\n        }\\n        \\n        int[][] dp=new int[s.length()+1][key.length()+1];\\n        \\n        return Util(s,key,0,0,hm,dp);\\n    }\\n    \\n    \\n    public int Util(String ring,String key,int i,int j,HashMap<Character,ArrayList<Integer>> hm,int[][] dp)\\n    {\\n        if(j==key.length())\\n            return 0;\\n        if(dp[i][j]!=0)\\n            return dp[i][j];\\n        \\n        int ans=Integer.MAX_VALUE;\\n\\t\\t//for Clicking  the center button\\n        if(ring.charAt(i)==key.charAt(j))\\n        {\\n            ans=1+Util(ring,key,i,j+1,hm,dp);\\n        }\\n        else\\n        {\\n\\t\\t//for calculating cost for clock or anti clockwise rotation \\n            char ch=key.charAt(j);\\n            for(int idx:hm.get(ch))\\n            {\\n                ans=Math.min(ans,Math.min(Math.abs(idx-i),ring.length()-Math.abs(idx-i))+Util(ring,key,idx,j,hm,dp));\\n            }\\n        }\\n        \\n        dp[i][j]=ans;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int findRotateSteps(String s, String key) {\\n    HashMap<Character,ArrayList<Integer>> hm=new HashMap<>();\\n        \\n        for(char i=\\'a\\';i<=\\'z\\';i++)\\n            hm.put(i,new ArrayList<>());\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            char ch=s.charAt(i);\\n            hm.get(ch).add(i);\\n        }\\n        \\n        int[][] dp=new int[s.length()+1][key.length()+1];\\n        \\n        return Util(s,key,0,0,hm,dp);\\n    }\\n    \\n    \\n    public int Util(String ring,String key,int i,int j,HashMap<Character,ArrayList<Integer>> hm,int[][] dp)\\n    {\\n        if(j==key.length())\\n            return 0;\\n        if(dp[i][j]!=0)\\n            return dp[i][j];\\n        \\n        int ans=Integer.MAX_VALUE;\\n\\t\\t//for Clicking  the center button\\n        if(ring.charAt(i)==key.charAt(j))\\n        {\\n            ans=1+Util(ring,key,i,j+1,hm,dp);\\n        }\\n        else\\n        {\\n\\t\\t//for calculating cost for clock or anti clockwise rotation \\n            char ch=key.charAt(j);\\n            for(int idx:hm.get(ch))\\n            {\\n                ans=Math.min(ans,Math.min(Math.abs(idx-i),ring.length()-Math.abs(idx-i))+Util(ring,key,idx,j,hm,dp));\\n            }\\n        }\\n        \\n        dp[i][j]=ans;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1072542,
                "title": "weird-bug-on-test-case-299-local-compiler-gives-correct-answer-but-leetcode-does-not",
                "content": "straight forward dfs + memorization. if ring[i] == key[i], we can go either left or right\\notherwise we have to keep going on the same direction until we find a match.\\n\\nrunning the code locally gives me correct answer 856, but in leetcode it keeps giving me 857. No idea what is wrong\\n\\n\\nCould someone helpe!\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        vector<vector<vector<int>>> memo(ring.size() + 1, vector<vector<int>>(key.size() + 1, vector<int>(2, -1)));\\n        return std::min(dp(ring, 0, key, 0, 1, memo), dp(ring, 0, key, 0, 0, memo));\\n    }\\n\\n    int dp(string& ring, int pos, string& key, int idx, int direction, vector<vector<vector<int>>>& memo) {\\n        if (idx == key.size()) {\\n            return -1;\\n        }\\n        if (pos == ring.size()) {\\n            pos = 0;\\n        }\\n        if (pos == -1) {\\n            pos = ring.size() - 1;\\n        }\\n        if (memo[pos][idx][direction] != -1) {\\n            return memo[pos][idx][direction];\\n        }\\n        int result = 0;\\n        if (ring[pos] == key[idx]) {\\n            while (idx < key.size() && ring[pos] == key[idx]) {\\n                result += 1;\\n                idx++;\\n            }\\n            result += 1 + std::min(dp(ring, pos + 1, key, idx, 0, memo), dp(ring, pos - 1, key, idx, 1, memo));\\n        }\\n        else if (direction == 0) {\\n            result = 1 + dp(ring, pos + 1, key, idx, 0, memo);\\n        }\\n        else {\\n            result = 1 + dp(ring, pos - 1, key, idx, 1, memo);\\n        }\\n        return memo[pos][idx][direction] = result;\\n    }\\n\\n    int main() {\\n        string s = \"wfzhwppstxapizcqvgsgfjcmkcnjwoscawziwxjcyudtxtmceudbibykwaiixstjrtsxtaxxgacyydpjmpieclqjgssvpsmaisfe\";\\n        string y = \"ycicdxlcjypaasiagtsdawcuvqpcezkfpsjnstwvjztjsiiiedmxigfcqwuzywpxafjcbwgytbckspmgojiwsxhmsaxmsxtetxpr\";\\n        int x = findRotateSteps(s, y);\\n        return 0;\\n   }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        vector<vector<vector<int>>> memo(ring.size() + 1, vector<vector<int>>(key.size() + 1, vector<int>(2, -1)));\\n        return std::min(dp(ring, 0, key, 0, 1, memo), dp(ring, 0, key, 0, 0, memo));\\n    }\\n\\n    int dp(string& ring, int pos, string& key, int idx, int direction, vector<vector<vector<int>>>& memo) {\\n        if (idx == key.size()) {\\n            return -1;\\n        }\\n        if (pos == ring.size()) {\\n            pos = 0;\\n        }\\n        if (pos == -1) {\\n            pos = ring.size() - 1;\\n        }\\n        if (memo[pos][idx][direction] != -1) {\\n            return memo[pos][idx][direction];\\n        }\\n        int result = 0;\\n        if (ring[pos] == key[idx]) {\\n            while (idx < key.size() && ring[pos] == key[idx]) {\\n                result += 1;\\n                idx++;\\n            }\\n            result += 1 + std::min(dp(ring, pos + 1, key, idx, 0, memo), dp(ring, pos - 1, key, idx, 1, memo));\\n        }\\n        else if (direction == 0) {\\n            result = 1 + dp(ring, pos + 1, key, idx, 0, memo);\\n        }\\n        else {\\n            result = 1 + dp(ring, pos - 1, key, idx, 1, memo);\\n        }\\n        return memo[pos][idx][direction] = result;\\n    }\\n\\n    int main() {\\n        string s = \"wfzhwppstxapizcqvgsgfjcmkcnjwoscawziwxjcyudtxtmceudbibykwaiixstjrtsxtaxxgacyydpjmpieclqjgssvpsmaisfe\";\\n        string y = \"ycicdxlcjypaasiagtsdawcuvqpcezkfpsjnstwvjztjsiiiedmxigfcqwuzywpxafjcbwgytbckspmgojiwsxhmsaxmsxtetxpr\";\\n        int x = findRotateSteps(s, y);\\n        return 0;\\n   }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1061570,
                "title": "java-dfs-map-cache-with-comments",
                "content": "```\\n    int rN;\\n    int kN;\\n    Map<Character, List<Integer>> indexMap;\\n    String ring;\\n    String key;\\n    Integer[][] cache;\\n\\n    public int findRotateSteps(String ring, String key) {\\n        rN = ring.length();\\n        kN = key.length();\\n        indexMap = new HashMap<>();\\n        this.ring = ring;\\n        this.key = key;\\n        cache = new Integer[kN][rN];\\n        for (int i = 0; i < rN; i++) { // Record which char exists in which index\\n            char c = ring.charAt(i);\\n            indexMap.computeIfAbsent(c, x -> new ArrayList<>());\\n            indexMap.get(c).add(i);\\n        }\\n        return dfs(0, 0);\\n    }\\n\\n    private int dfs(int kI, int rI) {\\n        if (kI == kN) return 0; // No more char to spell\\n        if (cache[kI][rI] != null) return cache[kI][rI]; // Use the cache\\n        int min = Integer.MAX_VALUE;\\n        for (int i : indexMap.get(key.charAt(kI))) { // Explore all different ways to spell key.charAt(kI)\\n            int diff = Math.abs(i - rI); // The move between i and ring index (rI)\\n            int cost = Math.min(diff, rN - diff) + 1; // min(clockwise,anti-clockwise)+1-> 1 is the cost to press\\n            min = Math.min(min, cost + dfs(kI + 1, i)); // Does current path minimize the answer?\\n        }\\n        cache[kI][rI] = min; // Add the answer to the cache\\n        return min; // Return the min\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int rN;\\n    int kN;\\n    Map<Character, List<Integer>> indexMap;\\n    String ring;\\n    String key;\\n    Integer[][] cache;\\n\\n    public int findRotateSteps(String ring, String key) {\\n        rN = ring.length();\\n        kN = key.length();\\n        indexMap = new HashMap<>();\\n        this.ring = ring;\\n        this.key = key;\\n        cache = new Integer[kN][rN];\\n        for (int i = 0; i < rN; i++) { // Record which char exists in which index\\n            char c = ring.charAt(i);\\n            indexMap.computeIfAbsent(c, x -> new ArrayList<>());\\n            indexMap.get(c).add(i);\\n        }\\n        return dfs(0, 0);\\n    }\\n\\n    private int dfs(int kI, int rI) {\\n        if (kI == kN) return 0; // No more char to spell\\n        if (cache[kI][rI] != null) return cache[kI][rI]; // Use the cache\\n        int min = Integer.MAX_VALUE;\\n        for (int i : indexMap.get(key.charAt(kI))) { // Explore all different ways to spell key.charAt(kI)\\n            int diff = Math.abs(i - rI); // The move between i and ring index (rI)\\n            int cost = Math.min(diff, rN - diff) + 1; // min(clockwise,anti-clockwise)+1-> 1 is the cost to press\\n            min = Math.min(min, cost + dfs(kI + 1, i)); // Does current path minimize the answer?\\n        }\\n        cache[kI][rI] = min; // Add the answer to the cache\\n        return min; // Return the min\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1029769,
                "title": "simple-intutive-recursive-solution-with-memozisation",
                "content": "\\n\\n\\tint dp[150][150];\\n\\t\\n\\tint helper(string &ring,string &key,int n,int m,int i,int prev){\\n\\t\\tif(i==m)return 0;\\n\\t\\t\\n\\t\\tif(dp[i][prev]!=-1)return dp[i][prev];\\n    int ans=10000;\\n\\t\\tfor(int k=0;k<n;k++){\\n\\t\\t\\tif(ring[k]==key[i]){\\n\\t\\t\\t\\tans=min(ans,1+helper(ring,key,n,m,i+1,k)+min(abs(prev-k),n-abs(prev-k)));\\n\\t\\t\\t}\\n    }\\n\\t\\treturn dp[i][prev]=ans;\\n\\t}\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\t\\tint findRotateSteps(string ring, string key) {\\n\\t\\t\\t\\tint n=ring.length();\\n\\t\\t\\t\\tint m=key.length();\\n\\t\\t\\t\\n\\t\\t\\t\\tfor(int i=0;i<150;i++){\\n\\t\\t\\t\\t\\tfor(int j=0;j<150;j++)dp[i][j]=-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t\\treturn helper(ring,key,n,m,0,0);\\n\\t\\t\\t}\\n\\t};\\n\\n\\t",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\t\\tint findRotateSteps(string ring, string key) {\\n\\t\\t\\t\\tint n=ring.length();\\n\\t\\t\\t\\tint m=key.length();\\n\\t\\t\\t\\n\\t\\t\\t\\tfor(int i=0;i<150;i++){\\n\\t\\t\\t\\t\\tfor(int j=0;j<150;j++)dp[i][j]=-1;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 979480,
                "title": "java-bottom-up-dp-14ms-running-time-solution",
                "content": "```\\n/*\\n\\nTime Complexity = O(M * (N ^ 2))\\nSpace Complexity = O(M * N)\\n\\n** word cost and distance is used interchangeably\\n\\nLet key = k1 k2 k3 ..... ki-2 ki-1 ki ki+1 ..... kn-1 kn\\n\\nDP[i][j] = min cost to set at top first \\'i + 1\\' letters of key where \\'i\\'th character is at \\'j\\'th position in ring\\nDP[0][j] = min cost from \\'1\\'st letter in ring to \\'j\\'th position in ring where \\'1\\'st letter in key is places\\nDP[i][j] = min(DP[i - 1][k] + minCost(k, j)) ; k = position of \\'i\\'th letter in ring and j = position of \\'i + 1\\'th letter in ring\\n\\nfinal answer = min(DP[M - 1][j]) + M ; where j are the positions of keys \\'M\\'th letter in ring and M is length of key\\n\\n- preprocess\\nprecompute set of positions for all letters in ring\\n\\n- base case\\nfor all positions in set1, minCost from \\'1\\'st letter in ring\\n\\n- minCost(k, j) - minimum cost (= distance) between position \\'k\\' and position \\'j\\' in ring\\n* k == j\\nminCost = 0\\n\\n* k < j\\n** (j - k) <= N / 2\\nminCost = (j - k)\\n** (j - k) > N / 2\\nminCost = N - (j - k)\\n\\n* k > j\\n** (k - j) <= N / 2\\nminCost = (k - j)\\n** (k - j) > N / 2\\nminCost = N - (k - j)\\n\\n*/\\n\\nclass Solution {\\n    public int findRotateSteps(String ring, String key) {\\n        int M = key.length(), N = ring.length(), minTotalCost = Integer.MAX_VALUE, ans = 0;\\n        Map<Character, Set<Integer>> positionsByCharacterInRing = new HashMap<Character, Set<Integer>>();\\n        Set<Integer> positions = null;\\n        for(int i = 0; i < N; i++) {\\n            positions = positionsByCharacterInRing.getOrDefault(ring.charAt(i), new HashSet<Integer>());\\n            positions.add(i);\\n            positionsByCharacterInRing.put(ring.charAt(i), positions);\\n        }\\n        int[][] DP = new int[M][N];\\n        for(Integer j : positionsByCharacterInRing.get(key.charAt(0))) {\\n            DP[0][j] = getMinCost(N, 0, j);\\n        }\\n        for(int i = 1; i < M; i++) {\\n            for(Integer j : positionsByCharacterInRing.get(key.charAt(i))) {\\n                ans = Integer.MAX_VALUE;\\n                for(Integer k : positionsByCharacterInRing.get(key.charAt(i - 1))) {\\n                    ans = Math.min(ans, DP[i - 1][k] + getMinCost(N, k, j));\\n                }\\n                DP[i][j] = ans;\\n            }\\n        }\\n        for(Integer j : positionsByCharacterInRing.get(key.charAt(M - 1))) {\\n            minTotalCost = Math.min(minTotalCost, DP[M - 1][j]);\\n        }\\n        minTotalCost += M;\\n        return minTotalCost;\\n    }\\n\\n    private int getMinCost(int N, int k, int j) {\\n        if(k == j) {\\n            return 0;\\n        }\\n        if(k < j) {\\n            if((j - k) <= (N / 2)) {\\n                return (j - k);\\n            }\\n            return (N - (j - k));\\n        }\\n        if((k - j) <= (N / 2)) {\\n            return (k - j);\\n        }\\n        return (N - (k - j));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\nTime Complexity = O(M * (N ^ 2))\\nSpace Complexity = O(M * N)\\n\\n** word cost and distance is used interchangeably\\n\\nLet key = k1 k2 k3 ..... ki-2 ki-1 ki ki+1 ..... kn-1 kn\\n\\nDP[i][j] = min cost to set at top first \\'i + 1\\' letters of key where \\'i\\'th character is at \\'j\\'th position in ring\\nDP[0][j] = min cost from \\'1\\'st letter in ring to \\'j\\'th position in ring where \\'1\\'st letter in key is places\\nDP[i][j] = min(DP[i - 1][k] + minCost(k, j)) ; k = position of \\'i\\'th letter in ring and j = position of \\'i + 1\\'th letter in ring\\n\\nfinal answer = min(DP[M - 1][j]) + M ; where j are the positions of keys \\'M\\'th letter in ring and M is length of key\\n\\n- preprocess\\nprecompute set of positions for all letters in ring\\n\\n- base case\\nfor all positions in set1, minCost from \\'1\\'st letter in ring\\n\\n- minCost(k, j) - minimum cost (= distance) between position \\'k\\' and position \\'j\\' in ring\\n* k == j\\nminCost = 0\\n\\n* k < j\\n** (j - k) <= N / 2\\nminCost = (j - k)\\n** (j - k) > N / 2\\nminCost = N - (j - k)\\n\\n* k > j\\n** (k - j) <= N / 2\\nminCost = (k - j)\\n** (k - j) > N / 2\\nminCost = N - (k - j)\\n\\n*/\\n\\nclass Solution {\\n    public int findRotateSteps(String ring, String key) {\\n        int M = key.length(), N = ring.length(), minTotalCost = Integer.MAX_VALUE, ans = 0;\\n        Map<Character, Set<Integer>> positionsByCharacterInRing = new HashMap<Character, Set<Integer>>();\\n        Set<Integer> positions = null;\\n        for(int i = 0; i < N; i++) {\\n            positions = positionsByCharacterInRing.getOrDefault(ring.charAt(i), new HashSet<Integer>());\\n            positions.add(i);\\n            positionsByCharacterInRing.put(ring.charAt(i), positions);\\n        }\\n        int[][] DP = new int[M][N];\\n        for(Integer j : positionsByCharacterInRing.get(key.charAt(0))) {\\n            DP[0][j] = getMinCost(N, 0, j);\\n        }\\n        for(int i = 1; i < M; i++) {\\n            for(Integer j : positionsByCharacterInRing.get(key.charAt(i))) {\\n                ans = Integer.MAX_VALUE;\\n                for(Integer k : positionsByCharacterInRing.get(key.charAt(i - 1))) {\\n                    ans = Math.min(ans, DP[i - 1][k] + getMinCost(N, k, j));\\n                }\\n                DP[i][j] = ans;\\n            }\\n        }\\n        for(Integer j : positionsByCharacterInRing.get(key.charAt(M - 1))) {\\n            minTotalCost = Math.min(minTotalCost, DP[M - 1][j]);\\n        }\\n        minTotalCost += M;\\n        return minTotalCost;\\n    }\\n\\n    private int getMinCost(int N, int k, int j) {\\n        if(k == j) {\\n            return 0;\\n        }\\n        if(k < j) {\\n            if((j - k) <= (N / 2)) {\\n                return (j - k);\\n            }\\n            return (N - (j - k));\\n        }\\n        if((k - j) <= (N / 2)) {\\n            return (k - j);\\n        }\\n        return (N - (k - j));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821330,
                "title": "dp-24ms-n-k-log-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int findDistance(int a, int b, int n, bool clockwise) {\\n        if (clockwise) {\\n            if (a >= b)\\n                return a - b;\\n            return a + n - b;\\n        }\\n        if (b >= a)\\n            return b - a;\\n        return n - a + b;\\n    }\\n\\n    int rec(int ringIndex, int keyIndex, string& key, vector<vector<int>>& dp, vector<int> pos[]) {\\n        if (keyIndex == (int)key.size())\\n            return 0;\\n        if (dp[ringIndex][keyIndex] != -1)\\n            return dp[ringIndex][keyIndex];\\n        int antiClockwise = lower_bound(pos[key[keyIndex] - \\'a\\'].begin(), pos[key[keyIndex] - \\'a\\'].end(), ringIndex) - pos[key[keyIndex] - \\'a\\'].begin();\\n        int clockwise = upper_bound(pos[key[keyIndex] - \\'a\\'].begin(), pos[key[keyIndex] - \\'a\\'].end(), ringIndex) - pos[key[keyIndex] - \\'a\\'].begin() - 1;\\n        if (antiClockwise == pos[key[keyIndex] - \\'a\\'].size())\\n            antiClockwise = 0;\\n        if (clockwise == -1)\\n            clockwise = (int)pos[key[keyIndex] - \\'a\\'].size() - 1;\\n        antiClockwise = pos[key[keyIndex] - \\'a\\'][antiClockwise];\\n        clockwise = pos[key[keyIndex] - \\'a\\'][clockwise];\\n        return dp[ringIndex][keyIndex] = min(findDistance(ringIndex, antiClockwise, dp.size(), false) + rec(antiClockwise, keyIndex + 1, key, dp, pos), findDistance(ringIndex, clockwise, dp.size(), true) + rec(clockwise, keyIndex + 1, key, dp, pos));\\n    }\\n\\n    int findRotateSteps(string ring, string key) {\\n        int n = ring.length(), m = key.length();\\n        vector<vector<int>> dp;\\n\\t    dp.resize(n, vector<int> (m, -1));\\n        vector<int> pos[26];\\n        for (int i = 0; i < n; i++)\\n            pos[ring[i] - \\'a\\'].push_back(i);\\n        return rec(0, 0, key, dp, pos) + key.size();\\n    }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDistance(int a, int b, int n, bool clockwise) {\\n        if (clockwise) {\\n            if (a >= b)\\n                return a - b;\\n            return a + n - b;\\n        }\\n        if (b >= a)\\n            return b - a;\\n        return n - a + b;\\n    }\\n\\n    int rec(int ringIndex, int keyIndex, string& key, vector<vector<int>>& dp, vector<int> pos[]) {\\n        if (keyIndex == (int)key.size())\\n            return 0;\\n        if (dp[ringIndex][keyIndex] != -1)\\n            return dp[ringIndex][keyIndex];\\n        int antiClockwise = lower_bound(pos[key[keyIndex] - \\'a\\'].begin(), pos[key[keyIndex] - \\'a\\'].end(), ringIndex) - pos[key[keyIndex] - \\'a\\'].begin();\\n        int clockwise = upper_bound(pos[key[keyIndex] - \\'a\\'].begin(), pos[key[keyIndex] - \\'a\\'].end(), ringIndex) - pos[key[keyIndex] - \\'a\\'].begin() - 1;\\n        if (antiClockwise == pos[key[keyIndex] - \\'a\\'].size())\\n            antiClockwise = 0;\\n        if (clockwise == -1)\\n            clockwise = (int)pos[key[keyIndex] - \\'a\\'].size() - 1;\\n        antiClockwise = pos[key[keyIndex] - \\'a\\'][antiClockwise];\\n        clockwise = pos[key[keyIndex] - \\'a\\'][clockwise];\\n        return dp[ringIndex][keyIndex] = min(findDistance(ringIndex, antiClockwise, dp.size(), false) + rec(antiClockwise, keyIndex + 1, key, dp, pos), findDistance(ringIndex, clockwise, dp.size(), true) + rec(clockwise, keyIndex + 1, key, dp, pos));\\n    }\\n\\n    int findRotateSteps(string ring, string key) {\\n        int n = ring.length(), m = key.length();\\n        vector<vector<int>> dp;\\n\\t    dp.resize(n, vector<int> (m, -1));\\n        vector<int> pos[26];\\n        for (int i = 0; i < n; i++)\\n            pos[ring[i] - \\'a\\'].push_back(i);\\n        return rec(0, 0, key, dp, pos) + key.size();\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 801518,
                "title": "concise-python-o-krlogr-top-down-solution-with-explanation-beats-98",
                "content": "The DP structure for this problem is pretty clear; at each step, we need to rotate the dial either clockwise or anti-clockwise until we get to the next letter in the key. Crucially, we never need to rotate past our first encounter with the correct letter. Why? Because whatever advantage we could get by rotating past the first encounter and pressing later, we could also obtain by pressing the button at our first encounter and then rotating to the new location.\\n\\nThus our subproblem is completely defined by\\n\\n1. Our current location on the dial\\n2. The next letter we need to process on the key.\\n\\nEach parent subproblem has exactly two children: we choose between rotating right to the next letter or rotating left, and process the letter after the one we\\'re currently processing. In other words, if we\\'re at position i in the ring and position j in the key, our child subproblems would be (left, j+1) and (right, j+1), where left and right are the closest occurrences of key[j] traveling counter-clockwise and clockwise, respectively.\\n\\nAll that\\'s left to do is to find left and right, and how far away they are from our current position in the ring i. We can employ a clever trick to do this in sublinear time.\\n\\n1. first, duplicate the ring 3x to simplify the edge cases involving looping to the other edge of the ring\\n2. in a dictionary, map each letter to a list of all the indices containing it (including the ring repetitions)\\n3. use binary search to find the closest indices to the left and right of i\\n\\n```\\nimport collections\\nimport bisect\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        locations = collections.defaultdict(list)\\n        l = len(ring)\\n        ring = ring + ring + ring\\n\\t\\t# we will only be on the middle ring; the left and right ones\\n\\t\\t# simulate looping over the left/right edges\\n        for i, c in enumerate(ring):\\n            locations[c].append(i)\\n            \\n        \\n        @lru_cache(None)\\n        def dfs(ring_loc, key_loc):\\n            if key_loc >= len(key): # finished processing key\\n                return 0\\n            nc = key[key_loc] # next character to process\\n            left = locations[nc][bisect.bisect_right(locations[nc], ring_loc) - 1]\\n\\t\\t\\t# locations[nc] is a list of all the indices of nc in our 3 rings\\n\\t\\t\\t# bisect.bisect_right(locations[nc], ring_loc) - 1 returns the index of the first location in \\n\\t\\t\\t# locations[nc] that is <= ring_loc\\n            l_distance = ring_loc - left\\n            left = (left % l) + l # correct for loop-overs\\n            right = locations[nc][bisect.bisect_left(locations[nc], ring_loc)]\\n\\t\\t\\t# bisect.bisect_left(locations[nc], ring_loc)] returns the index of the first location in \\n\\t\\t\\t# locations[nc] that is >= ring_loc\\n            r_distance = right - ring_loc\\n            right = (right % l) + l\\n            return min(l_distance + dfs(left, key_loc+1),\\n                       r_distance + dfs(right, key_loc+1))\\n        \\n        return dfs(l, 0) + len(key) # we can account for pressing buttons at the end\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nimport bisect\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        locations = collections.defaultdict(list)\\n        l = len(ring)\\n        ring = ring + ring + ring\\n\\t\\t# we will only be on the middle ring; the left and right ones\\n\\t\\t# simulate looping over the left/right edges\\n        for i, c in enumerate(ring):\\n            locations[c].append(i)\\n            \\n        \\n        @lru_cache(None)\\n        def dfs(ring_loc, key_loc):\\n            if key_loc >= len(key): # finished processing key\\n                return 0\\n            nc = key[key_loc] # next character to process\\n            left = locations[nc][bisect.bisect_right(locations[nc], ring_loc) - 1]\\n\\t\\t\\t# locations[nc] is a list of all the indices of nc in our 3 rings\\n\\t\\t\\t# bisect.bisect_right(locations[nc], ring_loc) - 1 returns the index of the first location in \\n\\t\\t\\t# locations[nc] that is <= ring_loc\\n            l_distance = ring_loc - left\\n            left = (left % l) + l # correct for loop-overs\\n            right = locations[nc][bisect.bisect_left(locations[nc], ring_loc)]\\n\\t\\t\\t# bisect.bisect_left(locations[nc], ring_loc)] returns the index of the first location in \\n\\t\\t\\t# locations[nc] that is >= ring_loc\\n            r_distance = right - ring_loc\\n            right = (right % l) + l\\n            return min(l_distance + dfs(left, key_loc+1),\\n                       r_distance + dfs(right, key_loc+1))\\n        \\n        return dfs(l, 0) + len(key) # we can account for pressing buttons at the end\\n```",
                "codeTag": "Java"
            },
            {
                "id": 778083,
                "title": "basic-memorization-with-normal-recursion-code",
                "content": "```\\nclass Solution {\\n    int [][]dp;\\n    Map<Character,List<Integer>>pos;\\n    public int getCost(int index_key,char []key,int index_ring,char []ring){\\n        int r = ring.length;\\n        if(index_key == key.length){\\n            return 0;\\n        }\\n        if(dp[index_key][index_ring]!=Integer.MAX_VALUE){\\n            return dp[index_key][index_ring];\\n        }\\n        int min = Integer.MAX_VALUE;\\n        char ch = key[index_key];\\n        if(pos.containsKey(ch)){\\n           for(int index : pos.get(ch)){\\n               int cost = Math.abs(index_ring - index);\\n               int min_cost = Math.min(cost,r - cost);\\n               min = Math.min(min,min_cost + getCost(index_key + 1,key,index,ring));\\n           } \\n        }\\n        else{\\n            return -1;\\n        }\\n        dp[index_key][index_ring] = min;\\n        return min;\\n    }\\n    public int findRotateSteps(String ring, String key) {\\n        char []ring_ = ring.toCharArray();\\n        char []key_ = key.toCharArray();\\n        pos= new HashMap<>();\\n        int idx = 0; //index of the ring\\n        for(char ch : ring_){\\n            if(!pos.containsKey(ch)){\\n                pos.put(ch,new ArrayList<>());\\n            }\\n            pos.get(ch).add(idx);\\n            idx++;\\n        }\\n        int m1 =ring_.length,m2 = key_.length;\\n        dp = new int[key_.length][ring_.length];\\n        for(int []d : dp){\\n            Arrays.fill(d,Integer.MAX_VALUE);\\n        }\\n        return m2 + getCost(0,key_,0,ring_);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int [][]dp;\\n    Map<Character,List<Integer>>pos;\\n    public int getCost(int index_key,char []key,int index_ring,char []ring){\\n        int r = ring.length;\\n        if(index_key == key.length){\\n            return 0;\\n        }\\n        if(dp[index_key][index_ring]!=Integer.MAX_VALUE){\\n            return dp[index_key][index_ring];\\n        }\\n        int min = Integer.MAX_VALUE;\\n        char ch = key[index_key];\\n        if(pos.containsKey(ch)){\\n           for(int index : pos.get(ch)){\\n               int cost = Math.abs(index_ring - index);\\n               int min_cost = Math.min(cost,r - cost);\\n               min = Math.min(min,min_cost + getCost(index_key + 1,key,index,ring));\\n           } \\n        }\\n        else{\\n            return -1;\\n        }\\n        dp[index_key][index_ring] = min;\\n        return min;\\n    }\\n    public int findRotateSteps(String ring, String key) {\\n        char []ring_ = ring.toCharArray();\\n        char []key_ = key.toCharArray();\\n        pos= new HashMap<>();\\n        int idx = 0; //index of the ring\\n        for(char ch : ring_){\\n            if(!pos.containsKey(ch)){\\n                pos.put(ch,new ArrayList<>());\\n            }\\n            pos.get(ch).add(idx);\\n            idx++;\\n        }\\n        int m1 =ring_.length,m2 = key_.length;\\n        dp = new int[key_.length][ring_.length];\\n        for(int []d : dp){\\n            Arrays.fill(d,Integer.MAX_VALUE);\\n        }\\n        return m2 + getCost(0,key_,0,ring_);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 754249,
                "title": "4ms-rust-dp",
                "content": "f[k][j] = min{f[k-1][i] + diff , where `i` is the `index_i` of key[k-1] and `j` is the `index_j` of key[k] and `diff` is the movement from `index_i` to `index_j` }\\n\\n```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn find_rotate_steps(ring: String, key: String) -> i32 {\\n        let mut f: Vec<Vec<i64>> = vec![vec![std::i32::MAX as i64; ring.len()]; key.len()];\\n        let mut map = HashMap::new();\\n        for (i, c) in ring.char_indices() {\\n            map.entry(c).or_insert(Vec::new()).push(i);\\n        }\\n        let key: Vec<char> = key.chars().collect();\\n        for &i in map[&key[0]].iter() {\\n            f[0][i] = (ring.len() as i64 - i as i64).abs().min(i as i64);\\n        }\\n\\n        for k in 1..key.len() {\\n            for &to in map[&key[k]].iter() {\\n                for &from in map[&key[k - 1]].iter() {\\n                    let diff = (from as i64 - to as i64).abs();\\n                    let diff = diff.min((ring.len() as i64 - diff).abs());\\n                    f[k][to] = f[k][to].min(f[k - 1][from] + diff);\\n                }\\n            }\\n        }\\n        map[&key[key.len() - 1]]\\n            .iter()\\n            .fold(std::i64::MAX, |ret, idx| ret.min(f[key.len() - 1][*idx])) as i32\\n            + key.len() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn find_rotate_steps(ring: String, key: String) -> i32 {\\n        let mut f: Vec<Vec<i64>> = vec![vec![std::i32::MAX as i64; ring.len()]; key.len()];\\n        let mut map = HashMap::new();\\n        for (i, c) in ring.char_indices() {\\n            map.entry(c).or_insert(Vec::new()).push(i);\\n        }\\n        let key: Vec<char> = key.chars().collect();\\n        for &i in map[&key[0]].iter() {\\n            f[0][i] = (ring.len() as i64 - i as i64).abs().min(i as i64);\\n        }\\n\\n        for k in 1..key.len() {\\n            for &to in map[&key[k]].iter() {\\n                for &from in map[&key[k - 1]].iter() {\\n                    let diff = (from as i64 - to as i64).abs();\\n                    let diff = diff.min((ring.len() as i64 - diff).abs());\\n                    f[k][to] = f[k][to].min(f[k - 1][from] + diff);\\n                }\\n            }\\n        }\\n        map[&key[key.len() - 1]]\\n            .iter()\\n            .fold(std::i64::MAX, |ret, idx| ret.min(f[key.len() - 1][*idx])) as i32\\n            + key.len() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 725486,
                "title": "java-recursive-with-memo-9-ms",
                "content": "class FreedomTrailHandler\\n{\\n    String ring,key;\\n    List<Integer>characters[];\\n    int storage[][];\\n    void input(String ring,String key)\\n    {\\n        this.key=key;\\n        this.ring=ring;\\n        storage=new int[ring.length()+1][key.length()+1];\\n        for (int temp[]:storage)\\n            Arrays.fill(temp,-1);\\n        characters=new List[26];\\n        for (int i=0;i<26;i++)\\n            characters[i]=new ArrayList<Integer>();\\n        for (int i=0;i<ring.length();i++)\\n            characters[ring.charAt(i)-\\'a\\'].add(i);\\n    }\\n    int minimumSteps(int current_at_12_00_ring,int keyIndex)\\n    {\\n\\n        if (keyIndex==key.length())\\n            return 0;\\n        if (storage[current_at_12_00_ring][keyIndex]!=-1)\\n            return storage[current_at_12_00_ring][keyIndex];\\n        int minimum=Integer.MAX_VALUE;\\n        for(int i:characters[key.charAt(keyIndex)-\\'a\\'])\\n        {\\n            minimum=Math.min(minimum,1+distance(current_at_12_00_ring,i)+minimumSteps(i,keyIndex+1));\\n        }\\n        return storage[current_at_12_00_ring][keyIndex]=minimum==Integer.MAX_VALUE?0:minimum;\\n    }\\n    int distance(int current_index,int going_index)\\n    {\\n        int d=Math.abs(current_index-going_index);\\n        return Math.min(d,ring.length()-d);\\n    }\\n\\n\\n}\\n\\nclass Solution {\\n    public int findRotateSteps(String ring, String key) {\\n        FreedomTrailHandler handler =new FreedomTrailHandler();\\n        handler.input(ring,key);\\n        return handler.minimumSteps(0,0);\\n    }\\n}",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n    public int findRotateSteps(String ring, String key) {\\n        FreedomTrailHandler handler =new FreedomTrailHandler();\\n        handler.input(ring,key);\\n        return handler.minimumSteps(0,0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 643280,
                "title": "c-simple-solution-bfs-precomputation-and-dp",
                "content": "The problem can be modeled as follows - \\nTake all chars in the string ring as nodes in a graph (numbered- 0...ring.length()-1). Now there is an edge between 2 nodes in the graph if they are adjacent to each other in the string. We will also count circular adjacency (ie 0 with ring.length()-1).\\nThen we make a table of shortest paths between all pairs of nodes in the graph. This distance table can be easily computed using BFS from all nodes.\\n\\nNow its time to do the DP.\\nDP table is defined as follows - dp[i][j] is the shorest path from the starting node to ith element of key if we arrive at its jth occurence in ring (as there might be multiple occurences of the same char in ring).\\nThen the DP recurrence can be stated as -\\n dp[i][j] = min(dp[i-1][k]+dist[node][pnode]) over all k, where k are the possible nodes of the i-1th character of key, node and pnode are the current and prev nodes respectively.\\n \\nFinally our answer is the minimum of all distances if dp[key.size()-1][k], plus the size of string k (which corresponds to the button press at each char in key).\\n\\n```\\nint findRotateSteps(string ring, string key) {\\n        int n = ring.size(); int k = key.size();\\n        vector<int> adj[n];\\n        adj[0].push_back(n-1);\\n        adj[n-1].push_back(0);\\n        for(int i = 0;i<n-1;i++){\\n            adj[i].push_back(i+1);\\n            adj[i+1].push_back(i);\\n        }\\n        \\n        vector<vector<int>> dist(n,vector<int>(n,0));\\n        for(int i = 0;i<n;i++){\\n            vector<bool> visited(n);\\n            visited[i] = true;\\n            dist[i][i] = 0;\\n            queue<int> q;\\n            q.push(i);\\n            while(!q.empty()){\\n                int s = q.front(); q.pop();\\n                for(auto c:adj[s]){\\n                    if(visited[c]) continue;\\n                    visited[c] = true;\\n                    dist[i][c] = dist[i][s]+1;\\n                    q.push(c);\\n                }\\n            }\\n        }\\n        vector<int> occ[26];\\n        for(int i = 0;i<n;i++){\\n            occ[ring.at(i)-\\'a\\'].push_back(i);\\n        }\\n        int curr = 0;\\n        \\n        vector<int> dp[k];\\n        for(int i = 0;i<k;i++){\\n            dp[i].resize(occ[key.at(i)-\\'a\\'].size());\\n        }\\n        \\n        for(int i = 0;i<dp[0].size();i++){\\n            int c = key.at(0)-\\'a\\';\\n            dp[0][i] = dist[curr][occ[c][i]];\\n        }\\n        \\n        for(int i = 1;i<k;i++){\\n            for(int j = 0;j<dp[i].size();j++){\\n                dp[i][j] = 1e9;\\n                int node = occ[key.at(i)-\\'a\\'][j];\\n                for(int z = 0;z<dp[i-1].size();z++){\\n                    int pnode = occ[key.at(i-1)-\\'a\\'][z];\\n                    dp[i][j] = min(dp[i-1][z]+dist[node][pnode],dp[i][j]);\\n                }\\n            }\\n        }\\n        \\n        int ans = dp[k-1][0];\\n        for(int i = 0;i<dp[k-1].size();i++){\\n            ans = min(dp[k-1][i],ans);\\n        }\\n        return ans+k;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint findRotateSteps(string ring, string key) {\\n        int n = ring.size(); int k = key.size();\\n        vector<int> adj[n];\\n        adj[0].push_back(n-1);\\n        adj[n-1].push_back(0);\\n        for(int i = 0;i<n-1;i++){\\n            adj[i].push_back(i+1);\\n            adj[i+1].push_back(i);\\n        }\\n        \\n        vector<vector<int>> dist(n,vector<int>(n,0));\\n        for(int i = 0;i<n;i++){\\n            vector<bool> visited(n);\\n            visited[i] = true;\\n            dist[i][i] = 0;\\n            queue<int> q;\\n            q.push(i);\\n            while(!q.empty()){\\n                int s = q.front(); q.pop();\\n                for(auto c:adj[s]){\\n                    if(visited[c]) continue;\\n                    visited[c] = true;\\n                    dist[i][c] = dist[i][s]+1;\\n                    q.push(c);\\n                }\\n            }\\n        }\\n        vector<int> occ[26];\\n        for(int i = 0;i<n;i++){\\n            occ[ring.at(i)-\\'a\\'].push_back(i);\\n        }\\n        int curr = 0;\\n        \\n        vector<int> dp[k];\\n        for(int i = 0;i<k;i++){\\n            dp[i].resize(occ[key.at(i)-\\'a\\'].size());\\n        }\\n        \\n        for(int i = 0;i<dp[0].size();i++){\\n            int c = key.at(0)-\\'a\\';\\n            dp[0][i] = dist[curr][occ[c][i]];\\n        }\\n        \\n        for(int i = 1;i<k;i++){\\n            for(int j = 0;j<dp[i].size();j++){\\n                dp[i][j] = 1e9;\\n                int node = occ[key.at(i)-\\'a\\'][j];\\n                for(int z = 0;z<dp[i-1].size();z++){\\n                    int pnode = occ[key.at(i-1)-\\'a\\'][z];\\n                    dp[i][j] = min(dp[i-1][z]+dist[node][pnode],dp[i][j]);\\n                }\\n            }\\n        }\\n        \\n        int ans = dp[k-1][0];\\n        for(int i = 0;i<dp[k-1].size();i++){\\n            ans = min(dp[k-1][i],ans);\\n        }\\n        return ans+k;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 603278,
                "title": "java-dp-with-possible-indexes",
                "content": "```java\\nclass Solution {\\n    \\n    public int findRotateSteps(String ring, String key) {\\n        List<Integer>[] map = new ArrayList[26];\\n        for (int i = 0; i < 26; i++) map[i] = new ArrayList<>();\\n        for (int i = 0; i < ring.length(); i++) {\\n            map[ring.charAt(i) - \\'a\\'].add(i);\\n        }\\n        \\n        int len = ring.length();\\n        // key - last spelled index in ring\\n        // val - minimun cost to reach this state\\n        // states has get updated when we go through key\\n        Map<Integer, Integer> states = new HashMap<>();\\n        states.put(0, 0);\\n        for (char c : key.toCharArray()) {\\n            Map<Integer, Integer> next = new HashMap<>();\\n            // cur represents a possible index\\n            // pre represents previous index\\n            for (int cur : map[c - \\'a\\']) {\\n                int step = Integer.MAX_VALUE;\\n                for (int pre : states.keySet()) {\\n                    int dist = Math.abs(cur - pre);\\n                    step = Math.min(step, states.get(pre) + Math.min(len - dist, dist));\\n                }\\n                next.put(cur, step + 1);\\n            }\\n            states = next;\\n        }\\n        // return the minimun cost in final states set\\n        return states.values().stream().reduce(Integer.MAX_VALUE, (a, b) -> Math.min(a, b));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    \\n    public int findRotateSteps(String ring, String key) {\\n        List<Integer>[] map = new ArrayList[26];\\n        for (int i = 0; i < 26; i++) map[i] = new ArrayList<>();\\n        for (int i = 0; i < ring.length(); i++) {\\n            map[ring.charAt(i) - \\'a\\'].add(i);\\n        }\\n        \\n        int len = ring.length();\\n        // key - last spelled index in ring\\n        // val - minimun cost to reach this state\\n        // states has get updated when we go through key\\n        Map<Integer, Integer> states = new HashMap<>();\\n        states.put(0, 0);\\n        for (char c : key.toCharArray()) {\\n            Map<Integer, Integer> next = new HashMap<>();\\n            // cur represents a possible index\\n            // pre represents previous index\\n            for (int cur : map[c - \\'a\\']) {\\n                int step = Integer.MAX_VALUE;\\n                for (int pre : states.keySet()) {\\n                    int dist = Math.abs(cur - pre);\\n                    step = Math.min(step, states.get(pre) + Math.min(len - dist, dist));\\n                }\\n                next.put(cur, step + 1);\\n            }\\n            states = next;\\n        }\\n        // return the minimun cost in final states set\\n        return states.values().stream().reduce(Integer.MAX_VALUE, (a, b) -> Math.min(a, b));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 524666,
                "title": "simple-recursion-dp-solution-in-c",
                "content": "```\\nclass Solution {\\n    int helper(vector<vector<int>> &dp, string &ring, string &key, int i, int j) {\\n        if (j == key.size())\\n            return 0;\\n        \\n        if (dp[i][j] == 0) {\\n            if (ring[i] == key[j])\\n                dp[i][j] = 1 + helper(dp, ring, key, i, j+1);\\n            else {\\n                // clockwise\\n                int pos1 = i, step1 = 0;\\n                while (ring[pos1] != key[j])\\n                    pos1 = (pos1 + 1) % ring.size(), step1++;\\n                // anticlockwise\\n                int pos2 = i, step2 = 0;\\n                while (ring[pos2] != key[j])\\n                    pos2 = (pos2 - 1 + ring.size()) % ring.size(), step2++;\\n                dp[i][j] = 1 + min(step1 + helper(dp, ring, key, pos1, j+1), step2 + helper(dp, ring, key, pos2, j+1));\\n            }\\n        }\\n        return dp[i][j];\\n    }\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        vector<vector<int>> dp(ring.size(), vector<int>(key.size()));\\n        \\n        return helper(dp, ring, key, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int helper(vector<vector<int>> &dp, string &ring, string &key, int i, int j) {\\n        if (j == key.size())\\n            return 0;\\n        \\n        if (dp[i][j] == 0) {\\n            if (ring[i] == key[j])\\n                dp[i][j] = 1 + helper(dp, ring, key, i, j+1);\\n            else {\\n                // clockwise\\n                int pos1 = i, step1 = 0;\\n                while (ring[pos1] != key[j])\\n                    pos1 = (pos1 + 1) % ring.size(), step1++;\\n                // anticlockwise\\n                int pos2 = i, step2 = 0;\\n                while (ring[pos2] != key[j])\\n                    pos2 = (pos2 - 1 + ring.size()) % ring.size(), step2++;\\n                dp[i][j] = 1 + min(step1 + helper(dp, ring, key, pos1, j+1), step2 + helper(dp, ring, key, pos2, j+1));\\n            }\\n        }\\n        return dp[i][j];\\n    }\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        vector<vector<int>> dp(ring.size(), vector<int>(key.size()));\\n        \\n        return helper(dp, ring, key, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 522101,
                "title": "concise-java-top-down-dp-in-20-lines",
                "content": "```\\n    public int findRotateSteps(String ring, String key) {\\n        return dfs(ring.toCharArray(), 0, key.toCharArray(), 0, new int[ring.length()][key.length()]);\\n    }\\n    \\n    private int dfs(char[] ring, int pos, char[] key, int idx, int[][] mem) {\\n        if (idx == key.length) \\n            return 0;\\n        if (mem[pos][idx] > 0) \\n            return mem[p][idx];\\n        int minSteps = Integer.MAX_VALUE;\\n        for (int i = 0; i < ring.length; i++) {\\n            if (ring[i] == key[idx]) {\\n                int distance = Math.min(Math.abs(i - pos), ring.length - Math.abs(i - pos));\\n                minSteps = Math.min(minSteps, distance + 1 + dfs(ring, i, key, idx + 1, mem));\\n            }\\n        }\\n        mem[pos][idx] = minSteps;\\n        return mem[pos][idx];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int findRotateSteps(String ring, String key) {\\n        return dfs(ring.toCharArray(), 0, key.toCharArray(), 0, new int[ring.length()][key.length()]);\\n    }\\n    \\n    private int dfs(char[] ring, int pos, char[] key, int idx, int[][] mem) {\\n        if (idx == key.length) \\n            return 0;\\n        if (mem[pos][idx] > 0) \\n            return mem[p][idx];\\n        int minSteps = Integer.MAX_VALUE;\\n        for (int i = 0; i < ring.length; i++) {\\n            if (ring[i] == key[idx]) {\\n                int distance = Math.min(Math.abs(i - pos), ring.length - Math.abs(i - pos));\\n                minSteps = Math.min(minSteps, distance + 1 + dfs(ring, i, key, idx + 1, mem));\\n            }\\n        }\\n        mem[pos][idx] = minSteps;\\n        return mem[pos][idx];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 336820,
                "title": "84ms-python3-solution-beat-100",
                "content": "The key is that for the next target in key, you only need to visit 1) your current position if it is among your target position, or 2) the closest clockwise and anticlockwise position otherwise.\\n```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        prev, m = {0 : 0}, len(ring)\\n        ldict = {}\\n        for i, l in enumerate(ring):\\n            if not l in ldict:\\n                ldict[l] = [i]\\n            else:\\n                ldict[l].append(i)\\n        \\n        for target in key:\\n            cur = {}\\n            for previ in prev:\\n                tlist, midi = ldict[target], None\\n                if tlist[0] > previ or tlist[-1] < previ:\\n                    lefti, righti = tlist[-1], tlist[0]\\n                else:\\n                    for i in tlist:\\n                        if i == previ:\\n                            midi = i\\n                            break\\n                        elif i < previ:\\n                            lefti = i\\n                        else:\\n                            righti = i\\n                            break\\n                if midi != None:\\n                    stepinc = min(abs(midi - previ), m - abs(midi - previ))\\n                    if not midi in cur:\\n                        cur[midi] = prev[previ] + stepinc\\n                    else:\\n                        cur[midi] = min(cur[midi], prev[previ] + stepinc)\\n                else:\\n                    stepinc = min(abs(lefti - previ), m - abs(lefti - previ))\\n                    if not lefti in cur:\\n                        cur[lefti] = prev[previ] + stepinc\\n                    else:\\n                        cur[lefti] = min(cur[lefti], prev[previ] + stepinc)\\n                    if righti != lefti:\\n                        stepinc = min(abs(righti - previ), m - abs(righti - previ))\\n                        if not righti in cur:\\n                            cur[righti] = prev[previ] + stepinc\\n                        else:\\n                            cur[righti] = min(cur[righti], prev[previ] + stepinc)\\n            prev = cur\\n        \\n        return min(prev.values()) + len(key)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        prev, m = {0 : 0}, len(ring)\\n        ldict = {}\\n        for i, l in enumerate(ring):\\n            if not l in ldict:\\n                ldict[l] = [i]\\n            else:\\n                ldict[l].append(i)\\n        \\n        for target in key:\\n            cur = {}\\n            for previ in prev:\\n                tlist, midi = ldict[target], None\\n                if tlist[0] > previ or tlist[-1] < previ:\\n                    lefti, righti = tlist[-1], tlist[0]\\n                else:\\n                    for i in tlist:\\n                        if i == previ:\\n                            midi = i\\n                            break\\n                        elif i < previ:\\n                            lefti = i\\n                        else:\\n                            righti = i\\n                            break\\n                if midi != None:\\n                    stepinc = min(abs(midi - previ), m - abs(midi - previ))\\n                    if not midi in cur:\\n                        cur[midi] = prev[previ] + stepinc\\n                    else:\\n                        cur[midi] = min(cur[midi], prev[previ] + stepinc)\\n                else:\\n                    stepinc = min(abs(lefti - previ), m - abs(lefti - previ))\\n                    if not lefti in cur:\\n                        cur[lefti] = prev[previ] + stepinc\\n                    else:\\n                        cur[lefti] = min(cur[lefti], prev[previ] + stepinc)\\n                    if righti != lefti:\\n                        stepinc = min(abs(righti - previ), m - abs(righti - previ))\\n                        if not righti in cur:\\n                            cur[righti] = prev[previ] + stepinc\\n                        else:\\n                            cur[righti] = min(cur[righti], prev[previ] + stepinc)\\n            prev = cur\\n        \\n        return min(prev.values()) + len(key)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 292906,
                "title": "simple-python3-solution",
                "content": "```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        \\n        stepsmap = {0:0}\\n        for target in key:\\n            cur = {}\\n            for idx in stepsmap:\\n                for i, c in enumerate(ring):\\n                    if c == target:\\n                        steps = min(abs(idx-i), len(ring)-abs(idx-i))\\n                        cur[i] = steps+stepsmap[idx] if i not in cur else min(cur[i], steps+stepsmap[idx])\\n            stepsmap = cur\\n            \\n        return min(stepsmap.values()) + len(key)        \\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        \\n        stepsmap = {0:0}\\n        for target in key:\\n            cur = {}\\n            for idx in stepsmap:\\n                for i, c in enumerate(ring):\\n                    if c == target:\\n                        steps = min(abs(idx-i), len(ring)-abs(idx-i))\\n                        cur[i] = steps+stepsmap[idx] if i not in cur else min(cur[i], steps+stepsmap[idx])\\n            stepsmap = cur\\n            \\n        return min(stepsmap.values()) + len(key)        \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 256846,
                "title": "javascript-o-r-2-k-time-and-space-beats-100-with-comments",
                "content": "```\\nlet findRotateSteps = (ring, key) => {\\n\\n  // We\\'ll be making a memo (named dp) of the following size: \\n  //  width = ring.length\\n  //  height = key.length + 1\\n  let width = ring.length, height = key.length + 1;\\n\\n  // We\\'ll initialize every entry in dp with Infinity, except for the [0][0]\\n  // position, which starts out as 0\\n  let dp = [];\\n  for (let i = 0; i < height; i += 1) dp.push(new Array(width).fill(Infinity));\\n  dp[0][0] = 0;\\n\\n  // We\\'re looping over this entire memo starting at the second row (r = 1), from\\n  // top to bottom, left to right. Starting at this second row represents the first \\n  // character in the key (named keyChar).\\n  for (let r = 1; r < height; r +=1) {\\n    let keyChar = key.charAt(r - 1);\\n\\n    // Now we check if the ring character (named rChar) is equal to the keyChar. \\n    for (let col = 0; col < width; col += 1) {\\n      let rChar = ring.charAt(col);\\n\\n      if (keyChar !== rChar) continue;\\n      // If they aren\\'t equal^^, we continue.\\n\\n\\n      // Else, if they are equal we need to examine all of the previous rows numbers that\\n      // are not infinity, calculate the distance to get from there to the current column\\n      // index where we\\'re at, and do this for all of the previous rows numbers. We\\'ll assign\\n      // the minimum of these numbers to our dp[r][col]. This will now become the minimum \\n      // number of steps needed to get to this specific character in the ring that matches\\n      // the character in the key.\\n\\n      // The minArr stores all of the distances from the previous character in the key and ring,\\n      // to the current character in the key and ring. And we assign, as said previously, the\\n      // minimum of all of these distances to dp[r][col] below the for-loop.\\n      let minArr = [];\\n      for (let prevColIdx = 0; prevColIdx < width; prevColIdx += 1) {\\n        let val = dp[r - 1][prevColIdx];\\n        if (val === Infinity) continue;\\n\\n        minArr.push(val + Math.min(Math.abs(prevColIdx - col), Math.abs(width - Math.abs(prevColIdx - col))));\\n      }\\n\\n      // Assigning the minima of all of these distances to dp[r][col]\\n      dp[r][col] = Math.min(...minArr);\\n    }\\n  }\\n\\n  // Finally, once we exit these loops, we\\'ll take the minimum number out of all of \\n  // the numbers in the last row (i.e. row at index height - 1).\\n  // We add key.length to account for button presses.\\n  let min = Math.min(...dp[height - 1]);\\n  min += key.length;\\n\\n  // We return this minimum.\\n  return min;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet findRotateSteps = (ring, key) => {\\n\\n  // We\\'ll be making a memo (named dp) of the following size: \\n  //  width = ring.length\\n  //  height = key.length + 1\\n  let width = ring.length, height = key.length + 1;\\n\\n  // We\\'ll initialize every entry in dp with Infinity, except for the [0][0]\\n  // position, which starts out as 0\\n  let dp = [];\\n  for (let i = 0; i < height; i += 1) dp.push(new Array(width).fill(Infinity));\\n  dp[0][0] = 0;\\n\\n  // We\\'re looping over this entire memo starting at the second row (r = 1), from\\n  // top to bottom, left to right. Starting at this second row represents the first \\n  // character in the key (named keyChar).\\n  for (let r = 1; r < height; r +=1) {\\n    let keyChar = key.charAt(r - 1);\\n\\n    // Now we check if the ring character (named rChar) is equal to the keyChar. \\n    for (let col = 0; col < width; col += 1) {\\n      let rChar = ring.charAt(col);\\n\\n      if (keyChar !== rChar) continue;\\n      // If they aren\\'t equal^^, we continue.\\n\\n\\n      // Else, if they are equal we need to examine all of the previous rows numbers that\\n      // are not infinity, calculate the distance to get from there to the current column\\n      // index where we\\'re at, and do this for all of the previous rows numbers. We\\'ll assign\\n      // the minimum of these numbers to our dp[r][col]. This will now become the minimum \\n      // number of steps needed to get to this specific character in the ring that matches\\n      // the character in the key.\\n\\n      // The minArr stores all of the distances from the previous character in the key and ring,\\n      // to the current character in the key and ring. And we assign, as said previously, the\\n      // minimum of all of these distances to dp[r][col] below the for-loop.\\n      let minArr = [];\\n      for (let prevColIdx = 0; prevColIdx < width; prevColIdx += 1) {\\n        let val = dp[r - 1][prevColIdx];\\n        if (val === Infinity) continue;\\n\\n        minArr.push(val + Math.min(Math.abs(prevColIdx - col), Math.abs(width - Math.abs(prevColIdx - col))));\\n      }\\n\\n      // Assigning the minima of all of these distances to dp[r][col]\\n      dp[r][col] = Math.min(...minArr);\\n    }\\n  }\\n\\n  // Finally, once we exit these loops, we\\'ll take the minimum number out of all of \\n  // the numbers in the last row (i.e. row at index height - 1).\\n  // We add key.length to account for button presses.\\n  let min = Math.min(...dp[height - 1]);\\n  min += key.length;\\n\\n  // We return this minimum.\\n  return min;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 250416,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution(object):\\n    def findRotateSteps(self, ring, key):\\n        \"\"\"\\n        :type ring: \\n        :type key: str\\n        :rtype: int\\n        \"\"\"\\n        m,n=len(key),len(ring)\\n        dp=[[float(\\'inf\\')]*(n) for _ in xrange(m)]\\n        for j in xrange(n-1,-1,-1):\\n            if ring[j]==key[m-1]:\\n                dp[m-1][j]=1\\n        for i in xrange(m-2,-1,-1):\\n            for j in xrange(n-1,-1,-1):\\n                if ring[j]==key[i]:\\n                    for k in xrange(n):\\n                        if ring[(j+k)%n]==key[i+1]:\\n                            dp[i][j]=min(dp[i][j],1+min(k,n-k)+dp[i+1][(j+k)%n])\\n        res=float(\\'inf\\')\\n        for k in xrange(n):\\n            if ring[k]==key[0]:\\n                res=min(res,min(k,n-k)+dp[0][k])\\n        return res\\n\\nclass Solution(object):\\n    def findRotateSteps(self, ring, key):\\n        \"\"\"\\n        :type ring: str\\n        :type key: str\\n        :rtype: int\\n        \"\"\"\\n        dp=[[float(\\'inf\\')]*(len(ring)) for _ in xrange(len(key))]\\n        for j in xrange(len(ring)-1,-1,-1):\\n            res=float(\\'inf\\')\\n            for i in xrange(len(ring)):\\n                if ring[(j+i)%len(ring)]==key[-1]:\\n                    res=min(res,i,len(ring)-i)\\n            dp[len(key)-1][j]=1+res\\n                \\n        for i in xrange(len(key)-2,-1,-1):\\n            for j in xrange(len(ring)-1,-1,-1):\\n                \\n                res=float(\\'inf\\')\\n                for k in xrange(len(ring)):\\n                    if ring[(j+k)%len(ring)]==key[i]:\\n                        res=min(res,1+min(k,len(ring)-k)+dp[i+1][(j+k)%len(ring)])\\n                dp[i][j]=res\\n        return dp[0][0]\\n\\n                \\nclass Solution(object):\\n    def findRotateSteps(self, ring, key):\\n        \"\"\"\\n        :type ring: str\\n        :type key: str\\n        :rtype: int\\n        \"\"\"\\n        memo={}\\n        def check(pos,idx):\\n            if (pos,idx) in memo:\\n                return memo[(pos,idx)]\\n            if pos>=len(key):\\n                return 0\\n            res=float(\\'inf\\')\\n            for i in xrange(len(ring)):\\n                idx_new=(i+idx)%len(ring)\\n                if ring[idx_new]==key[pos]:\\n                    rotation=min(i,len(ring)-i)\\n                    res=min(res,rotation+1+check(pos+1,idx_new))\\n            memo[(pos,idx)]=res\\n            return res\\n        return check(0,0)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findRotateSteps(self, ring, key):\\n        \"\"\"\\n        :type ring: \\n        :type key: str\\n        :rtype: int\\n        \"\"\"\\n        m,n=len(key),len(ring)\\n        dp=[[float(\\'inf\\')]*(n) for _ in xrange(m)]\\n        for j in xrange(n-1,-1,-1):\\n            if ring[j]==key[m-1]:\\n                dp[m-1][j]=1\\n        for i in xrange(m-2,-1,-1):\\n            for j in xrange(n-1,-1,-1):\\n                if ring[j]==key[i]:\\n                    for k in xrange(n):\\n                        if ring[(j+k)%n]==key[i+1]:\\n                            dp[i][j]=min(dp[i][j],1+min(k,n-k)+dp[i+1][(j+k)%n])\\n        res=float(\\'inf\\')\\n        for k in xrange(n):\\n            if ring[k]==key[0]:\\n                res=min(res,min(k,n-k)+dp[0][k])\\n        return res\\n\\nclass Solution(object):\\n    def findRotateSteps(self, ring, key):\\n        \"\"\"\\n        :type ring: str\\n        :type key: str\\n        :rtype: int\\n        \"\"\"\\n        dp=[[float(\\'inf\\')]*(len(ring)) for _ in xrange(len(key))]\\n        for j in xrange(len(ring)-1,-1,-1):\\n            res=float(\\'inf\\')\\n            for i in xrange(len(ring)):\\n                if ring[(j+i)%len(ring)]==key[-1]:\\n                    res=min(res,i,len(ring)-i)\\n            dp[len(key)-1][j]=1+res\\n                \\n        for i in xrange(len(key)-2,-1,-1):\\n            for j in xrange(len(ring)-1,-1,-1):\\n                \\n                res=float(\\'inf\\')\\n                for k in xrange(len(ring)):\\n                    if ring[(j+k)%len(ring)]==key[i]:\\n                        res=min(res,1+min(k,len(ring)-k)+dp[i+1][(j+k)%len(ring)])\\n                dp[i][j]=res\\n        return dp[0][0]\\n\\n                \\nclass Solution(object):\\n    def findRotateSteps(self, ring, key):\\n        \"\"\"\\n        :type ring: str\\n        :type key: str\\n        :rtype: int\\n        \"\"\"\\n        memo={}\\n        def check(pos,idx):\\n            if (pos,idx) in memo:\\n                return memo[(pos,idx)]\\n            if pos>=len(key):\\n                return 0\\n            res=float(\\'inf\\')\\n            for i in xrange(len(ring)):\\n                idx_new=(i+idx)%len(ring)\\n                if ring[idx_new]==key[pos]:\\n                    rotation=min(i,len(ring)-i)\\n                    res=min(res,rotation+1+check(pos+1,idx_new))\\n            memo[(pos,idx)]=res\\n            return res\\n        return check(0,0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 231829,
                "title": "annotated-dp-solution-using-rust",
                "content": "```\\nimpl Solution {\\n    pub fn find_rotate_steps(ring: String, key: String) -> i32 {\\n        let mut index = vec![Vec::new(); 26]; // indices of each ring character\\n        for (idx, char) in ring.chars().enumerate() {\\n            index[(char as u8 - \\'a\\' as u8) as usize].push(idx);\\n        }\\n        // d[i][j] = min steps to rotate key[j..] with ring pointing at index i\\n        let mut d = vec![vec![0; key.len()+1]; ring.len()];\\n        for k_pos in (0..key.len()).rev() {\\n            for r_pos in (0..ring.len()) {\\n                let mut min_so_far = std::i32::MAX;\\n                for r_idx in &index[(key.as_bytes()[k_pos] - \\'a\\' as u8) as usize] {\\n                    // find the clockwise rotation from current position r_pos to\\n                    // position r_idx pointing at the desired character key[k_pos]\\n                    let distance = (r_pos as i32 - *r_idx as i32).abs();\\n                    // check if counter-clockwise rotation is shorter\\n                    let min_distance = std::cmp::min(distance, ring.len() as i32 - distance);\\n                    // relax min_so_far in case rotating to r_idx is beneficial\\n                    min_so_far = std::cmp::min(min_so_far, min_distance + d[*r_idx][k_pos+1]) \\n                }\\n                d[r_pos][k_pos] = min_so_far + 1; // steps to rotate + pressing the center button\\n            }\\n        }\\n        d[0][0] // min steps to rotate k[0..] with ring at its initial position 0\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn find_rotate_steps(ring: String, key: String) -> i32 {\\n        let mut index = vec![Vec::new(); 26]; // indices of each ring character\\n        for (idx, char) in ring.chars().enumerate() {\\n            index[(char as u8 - \\'a\\' as u8) as usize].push(idx);\\n        }\\n        // d[i][j] = min steps to rotate key[j..] with ring pointing at index i\\n        let mut d = vec![vec![0; key.len()+1]; ring.len()];\\n        for k_pos in (0..key.len()).rev() {\\n            for r_pos in (0..ring.len()) {\\n                let mut min_so_far = std::i32::MAX;\\n                for r_idx in &index[(key.as_bytes()[k_pos] - \\'a\\' as u8) as usize] {\\n                    // find the clockwise rotation from current position r_pos to\\n                    // position r_idx pointing at the desired character key[k_pos]\\n                    let distance = (r_pos as i32 - *r_idx as i32).abs();\\n                    // check if counter-clockwise rotation is shorter\\n                    let min_distance = std::cmp::min(distance, ring.len() as i32 - distance);\\n                    // relax min_so_far in case rotating to r_idx is beneficial\\n                    min_so_far = std::cmp::min(min_so_far, min_distance + d[*r_idx][k_pos+1]) \\n                }\\n                d[r_pos][k_pos] = min_so_far + 1; // steps to rotate + pressing the center button\\n            }\\n        }\\n        d[0][0] // min steps to rotate k[0..] with ring at its initial position 0\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 209125,
                "title": "memoized-recursive-solution-in-python-long-explanation",
                "content": "This solution isn\\'t the best, but I think it\\'s pretty intuitive.  I sort of rushed to the solution without planning, so there are some odd design choices, but I\\'ll explain everything.\\n# General strategy\\nThe goal was to find the minimal number of steps to input the key using the ring system described in the problem statement.  Since duplicates can exist, a greedy algorithm wouldn\\'t be guaranteed to be correct.  For example:\\n**ring:  \"abcdazyxwvut\"\\nkey: \"dat\"**\\nA greedy algorithm would go \"clockwise\" from 0 to 3 to get to the only \\'d,\\' enter d, then move cw to the \\'a\\' right after it at index 4, since it is the locally optimal move.  The fastest way to get to \\'t\\' from there would be ccw 5 positions.  The total moves would be 3+1+1+1+5+1=12\\n\\nThe best way to input the key would be to go cw from 0 to 3 to enter \\'d,\\' move ccw from 3 to 0 to enter \\'a,\\' then move ccw from 0 to 11 to enter \\'t.\\'  This will result in a move-count of 10 rather than 12.\\n\\nAnother thing to keep in mind is that it will never be worthwhile to pass by the currently needed letter, as stopping for it would always be less than or equal to the cost of passing.\\n\\nSince we know being greedy won\\'t always work, we must try something more exhaustive.  A naive approach would be to check every possible way to get to each spot and return the minimum case.  This will work given enough time and computing power, but it doesn\\'t meet the time constraints of the problem.  Initially, this was what I tried and I didn\\'t really want to start over to do a dp solution, so I just memoized.  Memoizing is hugely beneficial to the runtime of these kinds of problems.  A bottom-up approach would be even better, but it\\'s also harder to understand.  Since memoizing was good enough I\\'ll just leave it at that:\\n\\n# Solution explanation\\nTo begin, I made a dictionary to keep track of the cases I\\'ve already checked.  The keys are a tuple that consists of the remaining part of the string and the current index.  The values are the costs to finish typing the string at the index. \\n\\nThe recursive function first checks the base case where the remaining part of the key is an empty string.  If this is true, the search should end.  The cost of inputting nothing is 0, so it returns 0.\\n\\nNext, it checks if we\\'ve already tested this case by seeing if it\\'s in the memo dict.  If it is, then it returns the value stored for that key.\\n\\nNext we check if the index that the ring is positioned on is the letter that we need for the key.  If it is, then we check the cases for going cw or ccw with the letter excluded from the key and starting at the index we left off at in the ring.  We take the minimum of these and add 1 (for the cost of entering the letter).  This value is put into the memo dict and returned.\\n\\nFinally, to move the ring, it just changes the index until it is at the first letter in the key string.  Using modulo operator makes the string act like a circle.\\n\\n\\n\\n```\\nclass Solution(object):\\n    def findRotateSteps(self, ring, key):\\n        \"\"\"\\n        :type ring: str\\n        :type key: str\\n        :rtype: int\\n        \"\"\"\\n        size = len(ring)\\n        memo = {} # keys: remaining part of key w/ current index, vals: value associated with key fragment\\n        def recurse(idx, nk, direction): # current index, remaining part of key, direction to move\\n            if nk == \"\":\\n                return 0\\n            elif tuple([nk, idx]) in memo:\\n                return memo[tuple([nk, idx])]\\n            elif ring[idx] == nk[0]:\\n                memo[tuple([nk, idx])] = 1 + min(recurse(idx,nk[1:],1), recurse(idx, nk[1:], -1))\\n                return memo[tuple([nk, idx])]\\n            else:\\n                c= 0\\n                while ring[idx] != nk[0]:\\n                    idx = (idx+direction)%size\\n                    c += 1\\n                return c + recurse(idx, nk, direction)\\n        return min(recurse(0, key, 1), recurse(0,key,-1))\\n```\\n\\n# Reflection and criticism\\nThis solution is sort of unideal.  I didn\\'t really plan it out too well.  I should have combined the last two parts of the recursive call into one case.  I didn\\'t really need to use a dictionary, a list could have worked a little bit better since I didn\\'t really need to know the remaining part of the key, just its length.  As mentioned above, I could have implemented a bottom-up approach.  Lots of other stuff could be improved.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findRotateSteps(self, ring, key):\\n        \"\"\"\\n        :type ring: str\\n        :type key: str\\n        :rtype: int\\n        \"\"\"\\n        size = len(ring)\\n        memo = {} # keys: remaining part of key w/ current index, vals: value associated with key fragment\\n        def recurse(idx, nk, direction): # current index, remaining part of key, direction to move\\n            if nk == \"\":\\n                return 0\\n            elif tuple([nk, idx]) in memo:\\n                return memo[tuple([nk, idx])]\\n            elif ring[idx] == nk[0]:\\n                memo[tuple([nk, idx])] = 1 + min(recurse(idx,nk[1:],1), recurse(idx, nk[1:], -1))\\n                return memo[tuple([nk, idx])]\\n            else:\\n                c= 0\\n                while ring[idx] != nk[0]:\\n                    idx = (idx+direction)%size\\n                    c += 1\\n                return c + recurse(idx, nk, direction)\\n        return min(recurse(0, key, 1), recurse(0,key,-1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 190527,
                "title": "c-8ms-100-dp-binary-search-or-two-pointers",
                "content": "First we can use DP, as the operation of new character has no dependancy on the paths to last character. Then we need to find the minimun cost from one character to the next. Here I maintain an array of possible locations of last character. As it is constructed in an ordered way, we could apply binary search to find the closest indexes to the current character.\\nAfter I implemented this, I found that the indexes of current character are also visited in order. So this question becomes : given two sorted arrays ```A``` and ```B```, for each ```A[i]```, find the nearest ```B[j]```. Then we could apply Two Pointers to get a linear time performance.\\n```C++\\nclass Solution {\\n    \\n    // find the minimun cost to stop at ring[j]\\n    int getMinDistance(vector<pair<int, int>>& cur, int j, int len) {\\n        int le, ri;\\n        if (j < cur[0].first || j >= cur.back().first) {\\n            \\n            // j is out of bound of cur, so the leftmost and rightmost locations are nearest\\n            ri = 0;\\n            le = cur.size()-1;\\n        }\\n        else {\\n            \\n            // binary search to find location with smallest distance\\n            le = 0, ri = cur.size()-1;\\n            while (le < ri) {\\n                int mi = le + (ri - le) / 2;\\n                if (j <= cur[mi].first)\\n                    ri = mi;\\n                else if (j >= cur[mi+1].first)\\n                    le = mi+1;\\n                else {\\n                    le = mi;\\n                    break;\\n                }\\n            }\\n            ri = le + 1;\\n        }\\n        \\n        // find the minimun cost\\n        int lo = cur[le].first, ro = cur[ri].first;\\n        int lecost = min(abs(j-lo), len - abs(j-lo)) + cur[le].second;\\n        int ricost = min(abs(j-ro), len - abs(j-ro)) + cur[ri].second;\\n        return min(lecost, ricost);\\n    }\\n    \\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        int N = key.size(), M = ring.size();\\n        \\n        // use 1D array to apply DP\\n        //   cur, _cur are always in ascending order, which support binary search\\n        vector<pair<int, int>> cur, _cur;\\n        for (int j=0; j<M; j++) \\n            if (key[0] == ring[j])\\n                cur.push_back( {j, min(j, M-j)} );\\n        \\n        for (int i=1; i<N; i++) {\\n            for (int j=0; j<M; j++) {\\n                if (ring[j] == key[i]) \\n                    _cur.push_back( {j, getMinDistance(cur, j, M)} );\\n            }\\n            cur = _cur;\\n            _cur.clear();\\n        }\\n        \\n        int cost = INT_MAX;\\n        for (auto p : cur) \\n            cost = min(cost, p.second);\\n        return cost + N;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```A```\n```B```\n```A[i]```\n```B[j]```\n```C++\\nclass Solution {\\n    \\n    // find the minimun cost to stop at ring[j]\\n    int getMinDistance(vector<pair<int, int>>& cur, int j, int len) {\\n        int le, ri;\\n        if (j < cur[0].first || j >= cur.back().first) {\\n            \\n            // j is out of bound of cur, so the leftmost and rightmost locations are nearest\\n            ri = 0;\\n            le = cur.size()-1;\\n        }\\n        else {\\n            \\n            // binary search to find location with smallest distance\\n            le = 0, ri = cur.size()-1;\\n            while (le < ri) {\\n                int mi = le + (ri - le) / 2;\\n                if (j <= cur[mi].first)\\n                    ri = mi;\\n                else if (j >= cur[mi+1].first)\\n                    le = mi+1;\\n                else {\\n                    le = mi;\\n                    break;\\n                }\\n            }\\n            ri = le + 1;\\n        }\\n        \\n        // find the minimun cost\\n        int lo = cur[le].first, ro = cur[ri].first;\\n        int lecost = min(abs(j-lo), len - abs(j-lo)) + cur[le].second;\\n        int ricost = min(abs(j-ro), len - abs(j-ro)) + cur[ri].second;\\n        return min(lecost, ricost);\\n    }\\n    \\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        int N = key.size(), M = ring.size();\\n        \\n        // use 1D array to apply DP\\n        //   cur, _cur are always in ascending order, which support binary search\\n        vector<pair<int, int>> cur, _cur;\\n        for (int j=0; j<M; j++) \\n            if (key[0] == ring[j])\\n                cur.push_back( {j, min(j, M-j)} );\\n        \\n        for (int i=1; i<N; i++) {\\n            for (int j=0; j<M; j++) {\\n                if (ring[j] == key[i]) \\n                    _cur.push_back( {j, getMinDistance(cur, j, M)} );\\n            }\\n            cur = _cur;\\n            _cur.clear();\\n        }\\n        \\n        int cost = INT_MAX;\\n        for (auto p : cur) \\n            cost = min(cost, p.second);\\n        return cost + N;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 190254,
                "title": "c-dfs-solution-easy-to-understand",
                "content": "```\nclass Solution {\npublic:\n    int findRotateSteps(string ring, string key) {\n        return dfs(ring, key, 0, 0);\n    }\n\n    int dfs(string& ring, string& key, int offset, int count) {\n        if (count == key.size()) return 0;\n        if (memory.find(make_pair(offset, count)) != memory.end()) return memory[make_pair(offset, count)];\n        int res = INT_MAX;\n        for (int i = 0; i < ring.size(); i++) {\n            if (ring[i] == key[count]) {\n                int step = max(offset, i) - min(offset, i);\n                step = min(step, (int)(ring.size() - step));\n                res = min(res, step + 1 + dfs(ring, key, i, count + 1));\n            }\n        }\n        memory[make_pair(offset, count)] = res;\n        return res;\n    }\nprivate:\n    map<pair<int, int>, int> memory;\n};\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\npublic:\n    int findRotateSteps(string ring, string key) {\n        return dfs(ring, key, 0, 0);\n    }\n\n    int dfs(string& ring, string& key, int offset, int count) {\n        if (count == key.size()) return 0;\n        if (memory.find(make_pair(offset, count)) != memory.end()) return memory[make_pair(offset, count)];\n        int res = INT_MAX;\n        for (int i = 0; i < ring.size(); i++) {\n            if (ring[i] == key[count]) {\n                int step = max(offset, i) - min(offset, i);\n                step = min(step, (int)(ring.size() - step));\n                res = min(res, step + 1 + dfs(ring, key, i, count + 1));\n            }\n        }\n        memory[make_pair(offset, count)] = res;\n        return res;\n    }\nprivate:\n    map<pair<int, int>, int> memory;\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 178512,
                "title": "java-beats-100-as-of-10-6-2018",
                "content": "```\\nclass Solution {\\n    public int findRotateSteps(String ring, String key) {\\n        if (ring == null) return 0;\\n        List<Integer>[] r = new List[26];\\n        for (int i = 0; i < 26; i++) {\\n            r[i] = new ArrayList<Integer>();\\n        }\\n        for (int i = 0; i < ring.length(); i++) {\\n            r[ring.charAt(i) - \\'a\\'].add(i);\\n        }\\n        int[][] cache = new int[ring.length()][key.length()];\\n        return search(r, ring.length(), 0, key, 0, cache);\\n    }\\n    \\n    private int search(List<Integer>[] ring, int len, int p, String key, int index, int[][] cache) {\\n        if (index == key.length()) return 0;\\n        if (cache[p][index] > 0) return cache[p][index];\\n        char c = key.charAt(index);\\n        List<Integer> indices = ring[c - \\'a\\'];\\n        int min = Integer.MAX_VALUE;\\n        for (int i: indices) {\\n            int oneDir = Math.abs(p - i);\\n            int otherDir = len - oneDir;\\n            min = Math.min(min, 1 + Math.min(oneDir, otherDir) + search(ring, len, i, key, index + 1, cache));\\n        }\\n        cache[p][index] = min;\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findRotateSteps(String ring, String key) {\\n        if (ring == null) return 0;\\n        List<Integer>[] r = new List[26];\\n        for (int i = 0; i < 26; i++) {\\n            r[i] = new ArrayList<Integer>();\\n        }\\n        for (int i = 0; i < ring.length(); i++) {\\n            r[ring.charAt(i) - \\'a\\'].add(i);\\n        }\\n        int[][] cache = new int[ring.length()][key.length()];\\n        return search(r, ring.length(), 0, key, 0, cache);\\n    }\\n    \\n    private int search(List<Integer>[] ring, int len, int p, String key, int index, int[][] cache) {\\n        if (index == key.length()) return 0;\\n        if (cache[p][index] > 0) return cache[p][index];\\n        char c = key.charAt(index);\\n        List<Integer> indices = ring[c - \\'a\\'];\\n        int min = Integer.MAX_VALUE;\\n        for (int i: indices) {\\n            int oneDir = Math.abs(p - i);\\n            int otherDir = len - oneDir;\\n            min = Math.min(min, 1 + Math.min(oneDir, otherDir) + search(ring, len, i, key, index + 1, cache));\\n        }\\n        cache[p][index] = min;\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 155521,
                "title": "logical-thinking-with-code",
                "content": "**Logical Thinking**\\n`The start index of subkey` and `the index of the char at ring aligned at 12:00 direction` can uniquely identify a **state**.\\n**state(i, j)** is the minimum cost to spell subkey starting at i when ring[j] is at 12:00 direction (withouth pressing the center button).\\n**goal state** is `state(0, 0) + keyLength` (we need to press the center button keyLength times)\\n**state transition**\\n```\\ncur state is:  state[i][j], k = ring.indexOf(key[i]) there can be multiple k\\'s                   \\nnext state can be: state[i + 1][k] + smaller cost from j to k between left or right rotation (i.e. steps)   \\n\\nstanding at cur state, we can choose the k that causes min cost,\\nthus, state[i][j] = min(state[i + 1][k] + steps)\\n```\\n\\n\\n**Clear Code**\\n```\\n    public int findRotateSteps(String ring, String key) {\\n        \\n        // corner case to add\\n        \\n        int keyLength = key.length(), ringLength = ring.length();\\n        int[][] state = new int[keyLength + 1][ringLength];\\n        for (int i = keyLength - 1; i >= 0; i--) {\\n            for (int j = 0; j < ringLength; j++) {\\n                state[i][j] = Integer.MAX_VALUE;\\n                for (int k = 0; k < ringLength; k++) {\\n                    if (ring.charAt(k) == key.charAt(i)) {\\n                        int diff = Math.abs(k - j);\\n                        int steps = Math.min(diff, ringLength - diff);\\n                        state[i][j] = Math.min(state[i][j], state[i + 1][k] + steps);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return state[0][0] + keyLength;\\n    }\\n```\\n**I would appreciate your VOTE UP ;)**",
                "solutionTags": [],
                "code": "```\\ncur state is:  state[i][j], k = ring.indexOf(key[i]) there can be multiple k\\'s                   \\nnext state can be: state[i + 1][k] + smaller cost from j to k between left or right rotation (i.e. steps)   \\n\\nstanding at cur state, we can choose the k that causes min cost,\\nthus, state[i][j] = min(state[i + 1][k] + steps)\\n```\n```\\n    public int findRotateSteps(String ring, String key) {\\n        \\n        // corner case to add\\n        \\n        int keyLength = key.length(), ringLength = ring.length();\\n        int[][] state = new int[keyLength + 1][ringLength];\\n        for (int i = keyLength - 1; i >= 0; i--) {\\n            for (int j = 0; j < ringLength; j++) {\\n                state[i][j] = Integer.MAX_VALUE;\\n                for (int k = 0; k < ringLength; k++) {\\n                    if (ring.charAt(k) == key.charAt(i)) {\\n                        int diff = Math.abs(k - j);\\n                        int steps = Math.min(diff, ringLength - diff);\\n                        state[i][j] = Math.min(state[i][j], state[i + 1][k] + steps);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return state[0][0] + keyLength;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 138155,
                "title": "javascript-solution-104ms-with-detailed-explanation",
                "content": "We only need to look at the **first clockwise** `and` **first anti-clockwise** position of next key letter from the current one.\\n\\nWhy not all? Let\\'s imagine a very big ring -- the size of the sun and your key being \"gogogogo\". Let\\'s say the letters g and o are next to each other across the diameter from start position at 6\\'o clock region. Ideally, you\\'d wanna get there and just move back and forth.\\n\\nNow let\\'s try to come up with ring configs that will prevent you from getting there. Let\\'s say \"g\" and \"o\" are present somewhere in the 11\\'o clock and 1\\'o clock regions respectively. So moving just back and forth between these 2 positions is suboptimal to the entire solution. But, because we look for first clockwise `and` first anti-clockwise position of the next character from current, we would end up reaching at the \"o\" in 6\\'o clock and then rocking back and forth which is also the best solution since we used one interim position to strike off a character while reaching there.\\n\\nIf there is another \"g\" in our way, say in 3\\'o clock region, then to reach the \"o\" in 6\\'o clock position then we\\'d make our next stop in 3\\'o clock region. From that point, we\\'d try to move back to the 2\\'o clock region but also try to look for the \"g\" in 6\\'o clock position. Net effect will be either you\\'d end up with the 2 letters next to one another around the 2\\'o clock region leading to the optimal solution or you reaching the 6\\'o clock position via all these stops that count towards the final solution making it optimal.\\n\\nSo, here all I have done is look for the first clockwise adn first anti clockwise position of next character in key from the current index. If you have reached the end then we greedily take the lowest cost option. Otherwise we pick the option that took the lowest cost to reach the end from the current position. We also keep storing the information that given our position on ring and the next character to find, what was the best possible solution. This will keep us from exploring the same path many times over.\\n\\n    var findRotateSteps = function(ring, key, keyIndex=0, currentRingIndex=0, memo={}) {\\n        let ckey = `${keyIndex},${currentRingIndex}`;\\n        if(ckey in memo) {\\n            return memo[ckey];\\n        }\\n\\n        let letter = key[keyIndex];\\n        let clockwiseIndex = ring.indexOf(letter, currentRingIndex);\\n        let clockwiseDistance;\\n        if(clockwiseIndex < 0 ){ \\n            clockwiseIndex = ring.indexOf(letter);\\n            clockwiseDistance = ring.length - currentRingIndex + clockwiseIndex;\\n        }else{\\n            clockwiseDistance = clockwiseIndex - currentRingIndex;\\n        }\\n        \\n        let antiClockIndex = ring.lastIndexOf(letter, currentRingIndex);\\n        let antiClockDistance;\\n        if(antiClockIndex < 0) {\\n            antiClockIndex = ring.lastIndexOf(letter);\\n            antiClockDistance = currentRingIndex + ring.length - antiClockIndex;\\n        } else {\\n            antiClockDistance = currentRingIndex - antiClockIndex;\\n        }\\n        \\n        if(keyIndex === key.length-1) {\\n            memo[ckey] = 1+ Math.min(clockwiseDistance, antiClockDistance);\\n            return memo[ckey];\\n        }\\n        \\n        memo[ckey] = 1 + Math.min(clockwiseDistance + findRotateSteps(ring, key, keyIndex+1, clockwiseIndex, memo), \\n                                    antiClockDistance + findRotateSteps(ring, key, keyIndex+1, antiClockIndex, memo));\\n        return memo[ckey];\\n    }",
                "solutionTags": [],
                "code": "We only need to look at the **first clockwise** `and` **first anti-clockwise** position of next key letter from the current one.\\n\\nWhy not all? Let\\'s imagine a very big ring -- the size of the sun and your key being \"gogogogo\". Let\\'s say the letters g and o are next to each other across the diameter from start position at 6\\'o clock region. Ideally, you\\'d wanna get there and just move back and forth.\\n\\nNow let\\'s try to come up with ring configs that will prevent you from getting there. Let\\'s say \"g\" and \"o\" are present somewhere in the 11\\'o clock and 1\\'o clock regions respectively. So moving just back and forth between these 2 positions is suboptimal to the entire solution. But, because we look for first clockwise `and` first anti-clockwise position of the next character from current, we would end up reaching at the \"o\" in 6\\'o clock and then rocking back and forth which is also the best solution since we used one interim position to strike off a character while reaching there.\\n\\nIf there is another \"g\" in our way, say in 3\\'o clock region, then to reach the \"o\" in 6\\'o clock position then we\\'d make our next stop in 3\\'o clock region. From that point, we\\'d try to move back to the 2\\'o clock region but also try to look for the \"g\" in 6\\'o clock position. Net effect will be either you\\'d end up with the 2 letters next to one another around the 2\\'o clock region leading to the optimal solution or you reaching the 6\\'o clock position via all these stops that count towards the final solution making it optimal.\\n\\nSo, here all I have done is look for the first clockwise adn first anti clockwise position of next character in key from the current index. If you have reached the end then we greedily take the lowest cost option. Otherwise we pick the option that took the lowest cost to reach the end from the current position. We also keep storing the information that given our position on ring and the next character to find, what was the best possible solution. This will keep us from exploring the same path many times over.\\n\\n    var findRotateSteps = function(ring, key, keyIndex=0, currentRingIndex=0, memo={}) {\\n        let ckey = `${keyIndex},${currentRingIndex}`;\\n        if(ckey in memo) {\\n            return memo[ckey];\\n        }\\n\\n        let letter = key[keyIndex];\\n        let clockwiseIndex = ring.indexOf(letter, currentRingIndex);\\n        let clockwiseDistance;\\n        if(clockwiseIndex < 0 ){ \\n            clockwiseIndex = ring.indexOf(letter);\\n            clockwiseDistance = ring.length - currentRingIndex + clockwiseIndex;\\n        }else{\\n            clockwiseDistance = clockwiseIndex - currentRingIndex;\\n        }\\n        \\n        let antiClockIndex = ring.lastIndexOf(letter, currentRingIndex);\\n        let antiClockDistance;\\n        if(antiClockIndex < 0) {\\n            antiClockIndex = ring.lastIndexOf(letter);\\n            antiClockDistance = currentRingIndex + ring.length - antiClockIndex;\\n        } else {\\n            antiClockDistance = currentRingIndex - antiClockIndex;\\n        }\\n        \\n        if(keyIndex === key.length-1) {\\n            memo[ckey] = 1+ Math.min(clockwiseDistance, antiClockDistance);\\n            return memo[ckey];\\n        }\\n        \\n        memo[ckey] = 1 + Math.min(clockwiseDistance + findRotateSteps(ring, key, keyIndex+1, clockwiseIndex, memo), \\n                                    antiClockDistance + findRotateSteps(ring, key, keyIndex+1, antiClockIndex, memo));\\n        return memo[ckey];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 98926,
                "title": "cpp-22ms-dp-solution",
                "content": "```\\nclass Solution {\\n    vector<vector<int>> dp;\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        if (key.empty()) return 0;\\n        int keyLen = key.length(), ringLen = ring.length();\\n        \\n        dp = vector<vector<int>>(keyLen, vector<int>(ringLen, -1));\\n        \\n        for (int i = 0; i < ringLen; i++) {\\n            if (ring[i] == key[0]) {\\n                dp[0][i] = min(i, ringLen - i) + 1;\\n            }\\n        }\\n        \\n        for (int i = 1; i < keyLen; i++) {\\n            for (int j = 0; j < ringLen; j++) {\\n                if (ring[j] == key[i]) {\\n                    int step = INT_MAX;\\n                    for (int k = 0; k < ringLen; k++) {\\n                        if (dp[i - 1][k] >= 0) {\\n                            int t = abs(k - j);\\n                            step = min(step, min(t, ringLen - t) + 1 + dp[i - 1][k]);\\n                        }\\n                    }\\n                    dp[i][j] = step;\\n                }\\n            }\\n        }\\n        \\n        int minStep = INT_MAX;\\n        for (int i = 0; i < ringLen; i++) {\\n            if (dp[keyLen - 1][i] >= 0) {\\n                minStep = min(minStep, dp[keyLen - 1][i]);\\n            }\\n        }\\n        \\n        return minStep;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> dp;\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        if (key.empty()) return 0;\\n        int keyLen = key.length(), ringLen = ring.length();\\n        \\n        dp = vector<vector<int>>(keyLen, vector<int>(ringLen, -1));\\n        \\n        for (int i = 0; i < ringLen; i++) {\\n            if (ring[i] == key[0]) {\\n                dp[0][i] = min(i, ringLen - i) + 1;\\n            }\\n        }\\n        \\n        for (int i = 1; i < keyLen; i++) {\\n            for (int j = 0; j < ringLen; j++) {\\n                if (ring[j] == key[i]) {\\n                    int step = INT_MAX;\\n                    for (int k = 0; k < ringLen; k++) {\\n                        if (dp[i - 1][k] >= 0) {\\n                            int t = abs(k - j);\\n                            step = min(step, min(t, ringLen - t) + 1 + dp[i - 1][k]);\\n                        }\\n                    }\\n                    dp[i][j] = step;\\n                }\\n            }\\n        }\\n        \\n        int minStep = INT_MAX;\\n        for (int i = 0; i < ringLen; i++) {\\n            if (dp[keyLen - 1][i] >= 0) {\\n                minStep = min(minStep, dp[keyLen - 1][i]);\\n            }\\n        }\\n        \\n        return minStep;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98931,
                "title": "java-dfs-memoization-beats-99-42-33ms",
                "content": "The catch is that greedy approach may not always lead to optimum solution. Hence here in this problem, we need to try all the different paths available from a particular state. \\n\\nA state is defined by the current character of **ring** at 12.00 position and the next character of **key** to be formed by rotating the ring.\\n\\n**Approach:**\\nFor every single character **\"X\"** at Key, find the minimum steps to reach all the occurrences of the character X from the current character at 12.00 position. For every occurrence, repeat for the next character of the key.\\n\\n```\\npublic class FreedomTrail {\\n\\tchar[] ringa;\\n\\tchar[] keya;\\n\\tint[][] dp;\\n\\tpublic int findRotateSteps(String ring, String key){\\n\\t\\tif(ring==null || key==null)return 0;\\n\\t\\tringa = ring.toCharArray();\\n\\t\\tkeya = key.toCharArray();\\n\\t\\tdp = new int[ringa.length][keya.length];\\n\\t\\treturn find(0,0);\\n\\t}\\n\\tpublic int find(int ringPos, int keyPos){\\n\\t\\tif(keyPos==keya.length)return 0;\\n\\t\\tif(dp[ringPos][keyPos]!=0) return dp[ringPos][keyPos];\\n\\t\\tint ans = Integer.MAX_VALUE;\\n\\t\\tint dist;\\n\\t\\tfor(int i=0;i<ringa.length;i++){\\n\\t\\t\\tif(ringa[i]==keya[keyPos]){\\n\\t\\t\\t\\tdist = Math.min(ringa.length-Math.abs(ringPos-i),Math.abs(ringPos-i));\\n\\t\\t\\t\\tans = Math.min(ans,dist+find(i,keyPos+1));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdp[ringPos][keyPos] = ans+1;\\n\\t\\treturn ans+1;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class FreedomTrail {\\n\\tchar[] ringa;\\n\\tchar[] keya;\\n\\tint[][] dp;\\n\\tpublic int findRotateSteps(String ring, String key){\\n\\t\\tif(ring==null || key==null)return 0;\\n\\t\\tringa = ring.toCharArray();\\n\\t\\tkeya = key.toCharArray();\\n\\t\\tdp = new int[ringa.length][keya.length];\\n\\t\\treturn find(0,0);\\n\\t}\\n\\tpublic int find(int ringPos, int keyPos){\\n\\t\\tif(keyPos==keya.length)return 0;\\n\\t\\tif(dp[ringPos][keyPos]!=0) return dp[ringPos][keyPos];\\n\\t\\tint ans = Integer.MAX_VALUE;\\n\\t\\tint dist;\\n\\t\\tfor(int i=0;i<ringa.length;i++){\\n\\t\\t\\tif(ringa[i]==keya[keyPos]){\\n\\t\\t\\t\\tdist = Math.min(ringa.length-Math.abs(ringPos-i),Math.abs(ringPos-i));\\n\\t\\t\\t\\tans = Math.min(ans,dist+find(i,keyPos+1));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdp[ringPos][keyPos] = ans+1;\\n\\t\\treturn ans+1;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98938,
                "title": "c-dp-solution-using-hashmap-with-o-nm-time-complexity-and-o-n-space-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        int ans = 0;\\n        if(key.size() == 0)\\n            return ans;\\n        unordered_map<int,int> predp, curdp;\\n        unordered_map<int,int>::iterator it;\\n        int n = key.size(), m = ring.size(), k, idx, cnt, j;\\n        predp[0] = 0;\\n        for(int i = 0; i < n; ++ i){\\n            curdp.clear();\\n            for(it = predp.begin(); it != predp.end(); ++ it ){\\n                idx = it->first;\\n                for(int j = 0; j < m; ++ j){\\n                    if( ring[(idx + j)%m] == key[i] ){\\n                        if(curdp.find((idx + j)%m) == curdp.end())\\n                            curdp[(idx + j)%m] = predp[idx] + j + 1;\\n                        else\\n                            curdp[(idx + j)%m] = min(curdp[(idx + j)%m], predp[idx] + j + 1);\\n                        break;\\n                    }\\n                }\\n                for(int j = 0; j < m; ++ j){\\n                    if( ring[(idx - j + m)%m] == key[i] ){\\n                        if(curdp.find((idx - j + m)%m) == curdp.end())\\n                            curdp[(idx - j + m)%m] = predp[idx] + j + 1;\\n                        else\\n                            curdp[(idx - j + m)%m] = min(curdp[(idx - j + m)%m], predp[idx] + j + 1);\\n                        break;\\n                    }\\n                }\\n            }\\n            predp = curdp;\\n        }\\n        ans = INT_MAX;\\n        for(it = curdp.begin(); it != curdp.end(); ++ it)\\n            ans = min(ans, it->second);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        int ans = 0;\\n        if(key.size() == 0)\\n            return ans;\\n        unordered_map<int,int> predp, curdp;\\n        unordered_map<int,int>::iterator it;\\n        int n = key.size(), m = ring.size(), k, idx, cnt, j;\\n        predp[0] = 0;\\n        for(int i = 0; i < n; ++ i){\\n            curdp.clear();\\n            for(it = predp.begin(); it != predp.end(); ++ it ){\\n                idx = it->first;\\n                for(int j = 0; j < m; ++ j){\\n                    if( ring[(idx + j)%m] == key[i] ){\\n                        if(curdp.find((idx + j)%m) == curdp.end())\\n                            curdp[(idx + j)%m] = predp[idx] + j + 1;\\n                        else\\n                            curdp[(idx + j)%m] = min(curdp[(idx + j)%m], predp[idx] + j + 1);\\n                        break;\\n                    }\\n                }\\n                for(int j = 0; j < m; ++ j){\\n                    if( ring[(idx - j + m)%m] == key[i] ){\\n                        if(curdp.find((idx - j + m)%m) == curdp.end())\\n                            curdp[(idx - j + m)%m] = predp[idx] + j + 1;\\n                        else\\n                            curdp[(idx - j + m)%m] = min(curdp[(idx - j + m)%m], predp[idx] + j + 1);\\n                        break;\\n                    }\\n                }\\n            }\\n            predp = curdp;\\n        }\\n        ans = INT_MAX;\\n        for(it = curdp.begin(); it != curdp.end(); ++ it)\\n            ans = min(ans, it->second);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98940,
                "title": "c-13ms-with-o-n-space",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        vector<vector<int> > pos(26, vector<int>());\\n        for(int i = 0;i < ring.length();i ++)\\n            pos[ring[i] - 'a'].push_back(i);\\n        \\n        int len = ring.length();\\n        vector<vector<int> > nums(2, vector<int>(len, 0));\\n        for(int i = key.length()-1;i > 0;i --) {\\n            int now = key[i] - 'a';\\n            int pre = key[i-1] - 'a';\\n            for(int j = 0;j < pos[pre].size();j ++) {\\n                int u = pos[pre][j];\\n                nums[i%2][u] = INT_MAX;\\n                for(int k = 0;k < pos[now].size();k ++) {\\n                    int v = pos[now][k];\\n                    int dis = min(abs(v - u), len - abs(v - u));\\n                    nums[i%2][u] = min(nums[i%2][u], nums[(i+1)%2][v] + dis);\\n                }\\n            }\\n        }\\n        \\n        nums[0][0] = INT_MAX;\\n        for(int k = 0;k < pos[key[0] - 'a'].size();k ++) {\\n            int v = pos[key[0] - 'a'][k];\\n            int dis = min(v, len - v);\\n            nums[0][0] = min(nums[0][0], nums[1][v] + dis);\\n        }\\n                \\n        return nums[0][0] + key.length();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        vector<vector<int> > pos(26, vector<int>());\\n        for(int i = 0;i < ring.length();i ++)\\n            pos[ring[i] - 'a'].push_back(i);\\n        \\n        int len = ring.length();\\n        vector<vector<int> > nums(2, vector<int>(len, 0));\\n        for(int i = key.length()-1;i > 0;i --) {\\n            int now = key[i] - 'a';\\n            int pre = key[i-1] - 'a';\\n            for(int j = 0;j < pos[pre].size();j ++) {\\n                int u = pos[pre][j];\\n                nums[i%2][u] = INT_MAX;\\n                for(int k = 0;k < pos[now].size();k ++) {\\n                    int v = pos[now][k];\\n                    int dis = min(abs(v - u), len - abs(v - u));\\n                    nums[i%2][u] = min(nums[i%2][u], nums[(i+1)%2][v] + dis);\\n                }\\n            }\\n        }\\n        \\n        nums[0][0] = INT_MAX;\\n        for(int k = 0;k < pos[key[0] - 'a'].size();k ++) {\\n            int v = pos[key[0] - 'a'][k];\\n            int dis = min(v, len - v);\\n            nums[0][0] = min(nums[0][0], nums[1][v] + dis);\\n        }\\n                \\n        return nums[0][0] + key.length();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98943,
                "title": "c-dp-with-dictionaries",
                "content": "```\\npublic int FindRotateSteps(string ring, string key) {\\n        Dictionary<char, List<int>> idx = new Dictionary<char, List<int>>();\\n        Dictionary<int, int> cost = new Dictionary<int, int>();\\n        for(int i = 0; i < ring.Length; i++) {\\n            if (!idx.ContainsKey(ring[i])) idx[ring[i]] = new List<int>();\\n            idx[ring[i]].Add(i);\\n        }\\n        \\n        cost[0] = 0;\\n        for(int i = 0; i < key.Length; i++) {\\n            Dictionary<int, int> newCost = new Dictionary<int, int>();\\n            foreach(int last_i in cost.Keys) {\\n                foreach(int cur_i in idx[key[i]]) {\\n                    int d0 = (last_i - cur_i) >= 0 ? last_i - cur_i : last_i - cur_i + ring.Length;\\n                    int d1 = (cur_i - last_i) >= 0 ? cur_i - last_i : cur_i - last_i + ring.Length;\\n                    newCost[cur_i] = newCost.ContainsKey(cur_i) ? Math.Min(newCost[cur_i], Math.Min(d0, d1) + cost[last_i]) : Math.Min(d0, d1) + cost[last_i];\\n                }\\n            }\\n            cost = newCost;\\n        }\\n        \\n        int minCost = int.MaxValue;\\n        foreach(int cs in cost.Values) minCost = Math.Min(minCost, cs);\\n        return minCost + key.Length;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int FindRotateSteps(string ring, string key) {\\n        Dictionary<char, List<int>> idx = new Dictionary<char, List<int>>();\\n        Dictionary<int, int> cost = new Dictionary<int, int>();\\n        for(int i = 0; i < ring.Length; i++) {\\n            if (!idx.ContainsKey(ring[i])) idx[ring[i]] = new List<int>();\\n            idx[ring[i]].Add(i);\\n        }\\n        \\n        cost[0] = 0;\\n        for(int i = 0; i < key.Length; i++) {\\n            Dictionary<int, int> newCost = new Dictionary<int, int>();\\n            foreach(int last_i in cost.Keys) {\\n                foreach(int cur_i in idx[key[i]]) {\\n                    int d0 = (last_i - cur_i) >= 0 ? last_i - cur_i : last_i - cur_i + ring.Length;\\n                    int d1 = (cur_i - last_i) >= 0 ? cur_i - last_i : cur_i - last_i + ring.Length;\\n                    newCost[cur_i] = newCost.ContainsKey(cur_i) ? Math.Min(newCost[cur_i], Math.Min(d0, d1) + cost[last_i]) : Math.Min(d0, d1) + cost[last_i];\\n                }\\n            }\\n            cost = newCost;\\n        }\\n        \\n        int minCost = int.MaxValue;\\n        foreach(int cs in cost.Values) minCost = Math.Min(minCost, cs);\\n        return minCost + key.Length;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 98935,
                "title": "dp-python-225ms-o-r-2-k-time-o-r-space-easy-to-understand",
                "content": "First make letter-position map.\\nFor every letter in key, find all possible positions in ring:\\n--->For every possible position in ring, find shortest accumulated path from all previous possible positions.\\nFinally, find the shortest accumulated path to last letter in key.\\n```\\nclass Solution(object):\\n\\n    def findRotateSteps(self, ring, key):\\n        pre_pos_cost = [[0,0]]\\n        pos_d = {}\\n        ring_len = len(ring)\\n        for idx, i in enumerate(ring):\\n            if i in pos_d:\\n                pos_d[i].append(idx)\\n            else:\\n                pos_d[i] = [idx]\\n        for k in key:\\n            cur_pos_cost = []\\n            pos_l = pos_d[k]\\n            for p in pos_l:\\n                tmp_min = float('inf')\\n                for pre in pre_pos_cost:\\n                    tmp_min = min(min(abs(pre[0]-p), ring_len-abs(pre[0]-p)) + pre[1], tmp_min)\\n                cur_pos_cost.append([p, tmp_min])\\n            pre_pos_cost = cur_pos_cost\\n        return min([p[1] for p in pre_pos_cost]) + len(key)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n\\n    def findRotateSteps(self, ring, key):\\n        pre_pos_cost = [[0,0]]\\n        pos_d = {}\\n        ring_len = len(ring)\\n        for idx, i in enumerate(ring):\\n            if i in pos_d:\\n                pos_d[i].append(idx)\\n            else:\\n                pos_d[i] = [idx]\\n        for k in key:\\n            cur_pos_cost = []\\n            pos_l = pos_d[k]\\n            for p in pos_l:\\n                tmp_min = float('inf')\\n                for pre in pre_pos_cost:\\n                    tmp_min = min(min(abs(pre[0]-p), ring_len-abs(pre[0]-p)) + pre[1], tmp_min)\\n                cur_pos_cost.append([p, tmp_min])\\n            pre_pos_cost = cur_pos_cost\\n        return min([p[1] for p in pre_pos_cost]) + len(key)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98933,
                "title": "12-line-c-dp-solution-with-comments",
                "content": "The only thing I want to point out is how to elegantly calculate circular minimum distance: ```min((k+RS-j)%RS,(j+RS-k)%RS)``` where k and j are the positions, and RS is the circle size\\n\\nDP table to help understand the example\\n```\\n    g o d d i n g\\n    0 x x x x x x\\ng   0 x x x x x 1\\nd   x x 2 3 x x x\\n\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        int ans=INT_MAX, KS=key.size(), RS=ring.size();\\n        vector<vector<int>> mem(KS+1,vector<int>(RS,INT_MAX));\\n        mem[0][0]=0; // start state\\n        for(int i=1;i<=KS;i++) // Go through every char in key\\n            for(int j=0;j<RS;j++) // Go through every char in ring\\n                if(ring[j]==key[i-1]) // ring char matches key char\\n                    for(int k=0;k<RS;k++) // look up previous result\\n                        if(mem[i-1][k]!=INT_MAX) { // find previous result\\n                            mem[i][j]=min(mem[i][j],mem[i-1][k]+min((k+RS-j)%RS,(j+RS-k)%RS)); // update current state\\n                            (i==KS)?ans=min(ans,mem[KS][j]):0; // if last row, update answer\\n                        }\\n        return ans+KS;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```min((k+RS-j)%RS,(j+RS-k)%RS)```\n```\\n    g o d d i n g\\n    0 x x x x x x\\ng   0 x x x x x 1\\nd   x x 2 3 x x x\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        int ans=INT_MAX, KS=key.size(), RS=ring.size();\\n        vector<vector<int>> mem(KS+1,vector<int>(RS,INT_MAX));\\n        mem[0][0]=0; // start state\\n        for(int i=1;i<=KS;i++) // Go through every char in key\\n            for(int j=0;j<RS;j++) // Go through every char in ring\\n                if(ring[j]==key[i-1]) // ring char matches key char\\n                    for(int k=0;k<RS;k++) // look up previous result\\n                        if(mem[i-1][k]!=INT_MAX) { // find previous result\\n                            mem[i][j]=min(mem[i][j],mem[i-1][k]+min((k+RS-j)%RS,(j+RS-k)%RS)); // update current state\\n                            (i==KS)?ans=min(ans,mem[KS][j]):0; // if last row, update answer\\n                        }\\n        return ans+KS;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98917,
                "title": "python-recursive-solution",
                "content": "There are 2 different situation to consider.\\n1. If there is no duplicate characters in the ring, we only need to find the closest character that equal to key[0], since there is no duplicates, we can choose either direction to look for the character, if the step to reach this character is x by one direction, to reach here through the other direction is len(ring) - x.\\n\\n2. If there are duplicates, we need to try the first match from both direction and choose the minimum steps.\\n\\n```\\nfrom collections import Counter\\n\\nclass Solution(object):\\n    def findRotateSteps(self, ring, key):\\n        if not ring or not key: return 0\\n        self.duplicates = {i for i, v in Counter(ring).items() if v > 1}\\n        self.cache = {}\\n        return self.helper(ring, key)\\n        \\n    def helper(self, ring, key):\\n        if not key: return 0\\n        if (ring, key) in self.cache:\\n            return self.cache[(ring, key)]\\n        c = key[0]\\n        if c in self.duplicates:\\n            cw, ccw = ring.rfind(c), ring.find(c)\\n            res = 1 + min(len(ring) - cw + self.helper(ring[cw:] + ring[:cw], key[1:]), ccw + self.helper(ring[ccw:] + ring[:ccw], key[1:]))\\n        else:\\n            pos = ring.find(c)\\n            res = 1 + min(pos, len(ring) - pos) + self.helper(ring[pos:] + ring[:pos], key[1:])\\n        self.cache[(ring, key)] = res\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution(object):\\n    def findRotateSteps(self, ring, key):\\n        if not ring or not key: return 0\\n        self.duplicates = {i for i, v in Counter(ring).items() if v > 1}\\n        self.cache = {}\\n        return self.helper(ring, key)\\n        \\n    def helper(self, ring, key):\\n        if not key: return 0\\n        if (ring, key) in self.cache:\\n            return self.cache[(ring, key)]\\n        c = key[0]\\n        if c in self.duplicates:\\n            cw, ccw = ring.rfind(c), ring.find(c)\\n            res = 1 + min(len(ring) - cw + self.helper(ring[cw:] + ring[:cw], key[1:]), ccw + self.helper(ring[ccw:] + ring[:ccw], key[1:]))\\n        else:\\n            pos = ring.find(c)\\n            res = 1 + min(pos, len(ring) - pos) + self.helper(ring[pos:] + ring[:pos], key[1:])\\n        self.cache[(ring, key)] = res\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079239,
                "title": "easy-c-recursive-approach",
                "content": "```\\n1.The intution is that we fix the key , and from that point we search in anticlockwise  as well as in clockwise direction to find the next character of key.\\n2.Then we should check the min distance from fix to both acw and cw. \\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(int idx,int fix,string &key,string &ring){\\n        if(idx == key.size())return 0;\\n        if(dp[idx][fix] != -1)return dp[idx][fix];\\n        \\n        \\n        int acw = 0, cw = 0, n = ring.size();\\n        if(key[idx] == ring[fix]){\\n            return dp[idx][fix] = solve(idx+1,fix,key,ring) + 1;\\n        }\\n        for(int i = fix-1; i != fix; ){\\n            i = (i+n)%n;\\n            if(ring[i] == key[idx]){\\n                acw = i; break;\\n            }\\n            i--;\\n        }\\n        for(int i = fix+1; i != fix; ){\\n            i = (i + n)%n;\\n            if(ring[i] == key[idx]){\\n                cw = i; break;\\n            }\\n            i++;\\n        }\\n       \\n        int op1 = solve(idx+1,acw,key,ring) + min(abs(fix-acw),abs(fix+n-acw))+1;\\n        int op2 = solve(idx+1,cw,key,ring) + min(abs(fix-cw),abs(n-fix+cw))+1;\\n        return dp[idx][fix] = min(op1,op2);\\n    }\\n    int findRotateSteps(string ring, string key) {\\n        int n = ring.size(), fix = 0;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,0,key,ring);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n1.The intution is that we fix the key , and from that point we search in anticlockwise  as well as in clockwise direction to find the next character of key.\\n2.Then we should check the min distance from fix to both acw and cw. \\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(int idx,int fix,string &key,string &ring){\\n        if(idx == key.size())return 0;\\n        if(dp[idx][fix] != -1)return dp[idx][fix];\\n        \\n        \\n        int acw = 0, cw = 0, n = ring.size();\\n        if(key[idx] == ring[fix]){\\n            return dp[idx][fix] = solve(idx+1,fix,key,ring) + 1;\\n        }\\n        for(int i = fix-1; i != fix; ){\\n            i = (i+n)%n;\\n            if(ring[i] == key[idx]){\\n                acw = i; break;\\n            }\\n            i--;\\n        }\\n        for(int i = fix+1; i != fix; ){\\n            i = (i + n)%n;\\n            if(ring[i] == key[idx]){\\n                cw = i; break;\\n            }\\n            i++;\\n        }\\n       \\n        int op1 = solve(idx+1,acw,key,ring) + min(abs(fix-acw),abs(fix+n-acw))+1;\\n        int op2 = solve(idx+1,cw,key,ring) + min(abs(fix-cw),abs(n-fix+cw))+1;\\n        return dp[idx][fix] = min(op1,op2);\\n    }\\n    int findRotateSteps(string ring, string key) {\\n        int n = ring.size(), fix = 0;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,0,key,ring);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065849,
                "title": "easy-to-follow-very-intuitive-approach",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution {\\n    int[][][] dp;\\n\\n    public int findRotateSteps(String ring, String key) {\\n        dp = new int[ring.length()][key.length()][3];\\n\\n        //dp array  represents that from a particular index of key, the number of steps required\\n        // to complete the key, while the dial head is at a particular index of the ring(string), and 3rd dimension is the direction we can move the dial from the particular index(0==> both direction, 1==>clockwise, 2==>anticlockwise)\\n\\n        return recursion(ring, key, 0, 0, 0, 0);\\n    }\\n\\n    public int recursion(String ring, String key, int index1, int index2, int count, int rotate) {\\n        if (index2 == key.length()) {\\n            return 0;\\n        }\\n        if (count == ring.length()) {\\n            return (int) 1e9;\\n        }\\n        if (dp[index1][index2][rotate] != 0) {\\n            return dp[index1][index2][rotate];\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        if (ring.charAt(index1) == key.charAt(index2)) {\\n            int res1 = 1 + recursion(ring, key, index1, index2 + 1, 0, 0);\\n          \\n            ans = Math.min(ans, res1);\\n        }\\n\\n        if (rotate == 0) {\\n            int temp1 = 1+recursion(ring, key, (index1 + 1) % ring.length(), index2, count + 1, 1);\\n            int temp2 = 1+recursion(ring, key, (ring.length() + index1 - 1) % ring.length(), index2, count + 1, 2);\\n            ans = Math.min(ans, Math.min(temp1, temp2));\\n        } else {\\n            if (rotate == 1) {\\n                int temp1 = 1+recursion(ring, key, (index1 + 1) % ring.length(), index2, count + 1, 1);\\n                ans = Math.min(ans, temp1);\\n            } else {\\n                int temp2 = 1+recursion(ring, key, (ring.length() + index1 - 1) % ring.length(), index2, count + 1, 2);\\n                ans = Math.min(ans, temp2);\\n            }\\n        }\\n        return dp[index1][index2][rotate] = ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[][][] dp;\\n\\n    public int findRotateSteps(String ring, String key) {\\n        dp = new int[ring.length()][key.length()][3];\\n\\n        //dp array  represents that from a particular index of key, the number of steps required\\n        // to complete the key, while the dial head is at a particular index of the ring(string), and 3rd dimension is the direction we can move the dial from the particular index(0==> both direction, 1==>clockwise, 2==>anticlockwise)\\n\\n        return recursion(ring, key, 0, 0, 0, 0);\\n    }\\n\\n    public int recursion(String ring, String key, int index1, int index2, int count, int rotate) {\\n        if (index2 == key.length()) {\\n            return 0;\\n        }\\n        if (count == ring.length()) {\\n            return (int) 1e9;\\n        }\\n        if (dp[index1][index2][rotate] != 0) {\\n            return dp[index1][index2][rotate];\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        if (ring.charAt(index1) == key.charAt(index2)) {\\n            int res1 = 1 + recursion(ring, key, index1, index2 + 1, 0, 0);\\n          \\n            ans = Math.min(ans, res1);\\n        }\\n\\n        if (rotate == 0) {\\n            int temp1 = 1+recursion(ring, key, (index1 + 1) % ring.length(), index2, count + 1, 1);\\n            int temp2 = 1+recursion(ring, key, (ring.length() + index1 - 1) % ring.length(), index2, count + 1, 2);\\n            ans = Math.min(ans, Math.min(temp1, temp2));\\n        } else {\\n            if (rotate == 1) {\\n                int temp1 = 1+recursion(ring, key, (index1 + 1) % ring.length(), index2, count + 1, 1);\\n                ans = Math.min(ans, temp1);\\n            } else {\\n                int temp2 = 1+recursion(ring, key, (ring.length() + index1 - 1) % ring.length(), index2, count + 1, 2);\\n                ans = Math.min(ans, temp2);\\n            }\\n        }\\n        return dp[index1][index2][rotate] = ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038871,
                "title": "c-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nmemoization\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(kr^2)\\n- k=key.\\n- r=ring\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int dfs(string& ring, string& key, int index, unordered_map<string, int>&memo){\\n        if(index==key.length())\\n            return 0;\\n        string hashkey=ring+to_string(index);\\n        if(auto it=memo.find(hashkey); it!=memo.end())\\n            return it->second;\\n        int ans=INT_MAX;\\n        for(size_t i=0;i<ring.length();++i){\\n            if(ring[i]==key[index]){\\n                int rot=min(i, ring.length()-i);\\n                string newring=ring.substr(i)+ring.substr(0,i);\\n                move(memo);\\n                int remrot=dfs(newring, key, index+1, memo);\\n                ans=min(ans, rot+remrot);\\n            }\\n        }\\n        return memo[hashkey]=ans;\\n    }\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        unordered_map<string, int>memo{};\\n        return dfs(ring, key, 0, memo)+key.length();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dfs(string& ring, string& key, int index, unordered_map<string, int>&memo){\\n        if(index==key.length())\\n            return 0;\\n        string hashkey=ring+to_string(index);\\n        if(auto it=memo.find(hashkey); it!=memo.end())\\n            return it->second;\\n        int ans=INT_MAX;\\n        for(size_t i=0;i<ring.length();++i){\\n            if(ring[i]==key[index]){\\n                int rot=min(i, ring.length()-i);\\n                string newring=ring.substr(i)+ring.substr(0,i);\\n                move(memo);\\n                int remrot=dfs(newring, key, index+1, memo);\\n                ans=min(ans, rot+remrot);\\n            }\\n        }\\n        return memo[hashkey]=ans;\\n    }\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        unordered_map<string, int>memo{};\\n        return dfs(ring, key, 0, memo)+key.length();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009937,
                "title": "easy-c-solution-dp-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <bits/stdc++.h>\\nclass Solution {\\n\\npublic:\\nint minii(int a,int b){\\n    if(a<b)\\n    return a;\\n    return b;\\n}\\nint solve(string &ring,string &key ,int index,int j,vector<vector<int>> &dp){\\n    if(index>=key.length())\\n    return 0;\\n    if(dp[index][j]!=-1)\\n    return dp[index][j];\\n\\n    int ans=1e9;\\n    int k=j;\\n    if(ring[k]==key[index]){\\n        ans=min(ans,solve(ring,key,index+1,j,dp));\\n    }\\n    k=(k+1)%ring.length();\\n    while(k%ring.length()!= j){  \\n        if(ring[k]==key[index] ){\\n            int incl=0;\\n            int d=ring.length()-abs(j-k);\\n            int mini=minii(abs(j-k),abs(d));\\n            incl=mini+solve(ring,key,index+1,k,dp);\\n            ans=min(incl,ans);\\n        }\\n        k=(k+1)%ring.length();\\n    }\\n    return dp[index][j]=ans;\\n\\n}\\n    int findRotateSteps(string ring, string key) {\\n        int n=ring.length();\\n        int m=key.length();\\n        int p=max(n,m);\\n        vector<vector<int>> dp(p+1,vector<int>(p+1,-1));\\n       int ans=solve(ring,key,0,0,dp);\\n       return ans+key.length();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nclass Solution {\\n\\npublic:\\nint minii(int a,int b){\\n    if(a<b)\\n    return a;\\n    return b;\\n}\\nint solve(string &ring,string &key ,int index,int j,vector<vector<int>> &dp){\\n    if(index>=key.length())\\n    return 0;\\n    if(dp[index][j]!=-1)\\n    return dp[index][j];\\n\\n    int ans=1e9;\\n    int k=j;\\n    if(ring[k]==key[index]){\\n        ans=min(ans,solve(ring,key,index+1,j,dp));\\n    }\\n    k=(k+1)%ring.length();\\n    while(k%ring.length()!= j){  \\n        if(ring[k]==key[index] ){\\n            int incl=0;\\n            int d=ring.length()-abs(j-k);\\n            int mini=minii(abs(j-k),abs(d));\\n            incl=mini+solve(ring,key,index+1,k,dp);\\n            ans=min(incl,ans);\\n        }\\n        k=(k+1)%ring.length();\\n    }\\n    return dp[index][j]=ans;\\n\\n}\\n    int findRotateSteps(string ring, string key) {\\n        int n=ring.length();\\n        int m=key.length();\\n        int p=max(n,m);\\n        vector<vector<int>> dp(p+1,vector<int>(p+1,-1));\\n       int ans=solve(ring,key,0,0,dp);\\n       return ans+key.length();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3908316,
                "title": "breadth-first-search-java-clean-code",
                "content": "# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n- n: length of ring\\n- m: length of key\\n\\n# Code\\n```\\nclass State {\\n    StringBuilder key;\\n    int steps;\\n    int index;\\n\\n    public State(StringBuilder key, int steps, int index) {\\n        this.key = key;\\n        this.steps = steps;\\n        this.index = index;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return key + \"  \" + index + \"  \" + steps;\\n    }\\n}\\n\\nclass Solution {\\n    public int findRotateSteps(String ring, String key) {\\n        Queue<State> queue = new ArrayDeque<>(List.of(new State(new StringBuilder(), 0, 0)));\\n        boolean[][] visited = new boolean[key.length()][ring.length()];\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                State current = queue.remove();\\n                StringBuilder currKey = current.key;\\n                int index = current.index, steps = current.steps;\\n                while(currKey.length() < key.length() && key.charAt(currKey.length()) == ring.charAt(index)) {\\n                    currKey.append(ring.charAt(index));\\n                    steps++;\\n                }\\n                if(currKey.toString().equals(key)) return steps;\\n                if(visited[currKey.length()][index]) continue;\\n                visited[currKey.length()][index] = true;\\n                State right = new State(new StringBuilder(currKey), steps + 1, getIndex(ring, index + 1));\\n                State left = new State(new StringBuilder(currKey), steps + 1, getIndex(ring, index - 1));\\n                if(!visited[currKey.length()][right.index]) queue.add(right);\\n                if(!visited[currKey.length()][left.index]) queue.add(left);\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    private int getIndex(String ring, int index) {\\n        int next = index % ring.length();\\n        if(next >= 0) return next;\\n        return ring.length() + next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass State {\\n    StringBuilder key;\\n    int steps;\\n    int index;\\n\\n    public State(StringBuilder key, int steps, int index) {\\n        this.key = key;\\n        this.steps = steps;\\n        this.index = index;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return key + \"  \" + index + \"  \" + steps;\\n    }\\n}\\n\\nclass Solution {\\n    public int findRotateSteps(String ring, String key) {\\n        Queue<State> queue = new ArrayDeque<>(List.of(new State(new StringBuilder(), 0, 0)));\\n        boolean[][] visited = new boolean[key.length()][ring.length()];\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                State current = queue.remove();\\n                StringBuilder currKey = current.key;\\n                int index = current.index, steps = current.steps;\\n                while(currKey.length() < key.length() && key.charAt(currKey.length()) == ring.charAt(index)) {\\n                    currKey.append(ring.charAt(index));\\n                    steps++;\\n                }\\n                if(currKey.toString().equals(key)) return steps;\\n                if(visited[currKey.length()][index]) continue;\\n                visited[currKey.length()][index] = true;\\n                State right = new State(new StringBuilder(currKey), steps + 1, getIndex(ring, index + 1));\\n                State left = new State(new StringBuilder(currKey), steps + 1, getIndex(ring, index - 1));\\n                if(!visited[currKey.length()][right.index]) queue.add(right);\\n                if(!visited[currKey.length()][left.index]) queue.add(left);\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    private int getIndex(String ring, int index) {\\n        int next = index % ring.length();\\n        if(next >= 0) return next;\\n        return ring.length() + next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894568,
                "title": "cpp-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\npublic:\\n    int solve(int s, int pos, string &ring, string &key, vector<vector<int>> &dp) {\\n        if(pos == key.size()) {\\n            return 0;\\n        }\\n        if(dp[s][pos] != -1) return dp[s][pos];\\n        \\n        if(ring[s] == key[pos]) {\\n            return dp[s][pos] = 1 + solve(s, pos + 1, ring , key, dp);\\n        }\\n\\n        int left = s;\\n        int right = s;\\n        for(int i = s; ; i = (i + 1) % ring.size()) {\\n            if(ring[i] == key[pos]) {\\n                right = i;\\n                break;\\n            }\\n        }\\n\\n        for(int i = s; ; i = (i - 1 + ring.size()) % ring.size()) {\\n            if(ring[i] == key[pos]) {\\n                left = i;\\n                break;\\n            }\\n        }\\n\\n        int lleft, rright;\\n        if(left < s) lleft = s - left;\\n        else lleft = s + ring.size() - left;\\n\\n        if(right > s) rright = right - s;\\n        else rright = ring.size() - s + right;\\n\\n        return dp[s][pos] = 1 + min(solve(left, pos + 1, ring, key, dp) + lleft,\\n                    solve(right, pos + 1, ring, key, dp) + rright); \\n    }\\n    int findRotateSteps(string ring, string key) {\\n        vector<vector<int>> dp(ring.size(), vector<int>(key.size(), -1));\\n        return solve(0, 0, ring, key, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    int solve(int s, int pos, string &ring, string &key, vector<vector<int>> &dp) {\\n        if(pos == key.size()) {\\n            return 0;\\n        }\\n        if(dp[s][pos] != -1) return dp[s][pos];\\n        \\n        if(ring[s] == key[pos]) {\\n            return dp[s][pos] = 1 + solve(s, pos + 1, ring , key, dp);\\n        }\\n\\n        int left = s;\\n        int right = s;\\n        for(int i = s; ; i = (i + 1) % ring.size()) {\\n            if(ring[i] == key[pos]) {\\n                right = i;\\n                break;\\n            }\\n        }\\n\\n        for(int i = s; ; i = (i - 1 + ring.size()) % ring.size()) {\\n            if(ring[i] == key[pos]) {\\n                left = i;\\n                break;\\n            }\\n        }\\n\\n        int lleft, rright;\\n        if(left < s) lleft = s - left;\\n        else lleft = s + ring.size() - left;\\n\\n        if(right > s) rright = right - s;\\n        else rright = ring.size() - s + right;\\n\\n        return dp[s][pos] = 1 + min(solve(left, pos + 1, ring, key, dp) + lleft,\\n                    solve(right, pos + 1, ring, key, dp) + rright); \\n    }\\n    int findRotateSteps(string ring, string key) {\\n        vector<vector<int>> dp(ring.size(), vector<int>(key.size(), -1));\\n        return solve(0, 0, ring, key, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892708,
                "title": "my-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int findRotateSteps(string ring, string key) {\\n    return dfs(ring, key, 0, {}) + key.length();\\n  }\\n\\n private:\\n  // # of rotates of ring to match key[index:]\\n  int dfs(const string& ring, const string& key, int index,\\n          unordered_map<string, int>&& memo) {\\n    if (index == key.length())\\n      return 0;\\n    // Add the index to prevent duplicate\\n    const string hashKey = ring + to_string(index);\\n    if (const auto it = memo.find(hashKey); it != memo.cend())\\n      return it->second;\\n\\n    int ans = INT_MAX;\\n\\n    // For each ring[i] == key[index]\\n    // We rotate the ring to match ring[i] w/ key[index]\\n    // Then recursively match newRing w/ key[index + 1:]\\n    for (size_t i = 0; i < ring.length(); ++i)\\n      if (ring[i] == key[index]) {\\n        const int minRotates = min(i, ring.length() - i);\\n        const string& newRing = ring.substr(i) + ring.substr(0, i);\\n        const int remainingRotates = dfs(newRing, key, index + 1, move(memo));\\n        ans = min(ans, minRotates + remainingRotates);\\n      }\\n\\n    return memo[hashKey] = ans;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int findRotateSteps(string ring, string key) {\\n    return dfs(ring, key, 0, {}) + key.length();\\n  }\\n\\n private:\\n  // # of rotates of ring to match key[index:]\\n  int dfs(const string& ring, const string& key, int index,\\n          unordered_map<string, int>&& memo) {\\n    if (index == key.length())\\n      return 0;\\n    // Add the index to prevent duplicate\\n    const string hashKey = ring + to_string(index);\\n    if (const auto it = memo.find(hashKey); it != memo.cend())\\n      return it->second;\\n\\n    int ans = INT_MAX;\\n\\n    // For each ring[i] == key[index]\\n    // We rotate the ring to match ring[i] w/ key[index]\\n    // Then recursively match newRing w/ key[index + 1:]\\n    for (size_t i = 0; i < ring.length(); ++i)\\n      if (ring[i] == key[index]) {\\n        const int minRotates = min(i, ring.length() - i);\\n        const string& newRing = ring.substr(i) + ring.substr(0, i);\\n        const int remainingRotates = dfs(newRing, key, index + 1, move(memo));\\n        ans = min(ans, minRotates + remainingRotates);\\n      }\\n\\n    return memo[hashKey] = ans;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888299,
                "title": "c-dp-good-time-and-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsed q - too much time\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDP  - for each key find all matching ring positions and update count\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n x m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        int m =\\xA0(int)ring.size();\\n        int n = (int)key.size();\\n        vector<vector<int>> loc(26);\\n        for(int i=0; i<m; i++) loc[ring[i]-\\'a\\'].push_back(i);\\n        vector<int> q1(m,INT_MAX);\\n        vector<int> q2(m,INT_MAX);\\n        vector<int> &q = q1;\\n        vector<int> &next = q2;\\n        q[0] = 0;\\n        int prev = ring[0]-\\'a\\';\\n        for(auto k: key)\\n        {\\n            int i = k -\\'a\\';\\n            for(auto pos:loc[prev])\\n            {\\n                if (q[pos] == INT_MAX) continue;\\n                int cnt = q[pos];\\n                q[pos] = INT_MAX;\\n                for(auto l : loc[i])\\n                {\\n                    int bck = pos - l;\\n                    if (bck < 0) bck += m;\\n                    int fwd = l - pos;\\n                    if (fwd < 0) fwd += m;\\n                    next[l] = min(next[l],cnt + min(fwd,bck)+1);\\n                }\\n             }\\n             prev = i;\\n            swap(next,q);\\n        }\\n        int ans = INT_MAX;\\n        for(int pos = 0; pos<m; pos++)\\n            ans = min (ans,q[pos]);\\n        return (ans);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        int m =\\xA0(int)ring.size();\\n        int n = (int)key.size();\\n        vector<vector<int>> loc(26);\\n        for(int i=0; i<m; i++) loc[ring[i]-\\'a\\'].push_back(i);\\n        vector<int> q1(m,INT_MAX);\\n        vector<int> q2(m,INT_MAX);\\n        vector<int> &q = q1;\\n        vector<int> &next = q2;\\n        q[0] = 0;\\n        int prev = ring[0]-\\'a\\';\\n        for(auto k: key)\\n        {\\n            int i = k -\\'a\\';\\n            for(auto pos:loc[prev])\\n            {\\n                if (q[pos] == INT_MAX) continue;\\n                int cnt = q[pos];\\n                q[pos] = INT_MAX;\\n                for(auto l : loc[i])\\n                {\\n                    int bck = pos - l;\\n                    if (bck < 0) bck += m;\\n                    int fwd = l - pos;\\n                    if (fwd < 0) fwd += m;\\n                    next[l] = min(next[l],cnt + min(fwd,bck)+1);\\n                }\\n             }\\n             prev = i;\\n            swap(next,q);\\n        }\\n        int ans = INT_MAX;\\n        for(int pos = 0; pos<m; pos++)\\n            ans = min (ans,q[pos]);\\n        return (ans);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885879,
                "title": "python3-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport collections\\nimport sys\\n\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        # Store the positions of each character of ring in a dictionary\\n        pos = collections.defaultdict(list)\\n        for i, ch in enumerate(ring):\\n            pos[ch].append(i)\\n            \\n        # Initial dp table\\n        m, n = len(key), len(ring)\\n        dp = [[0]*n for _ in range(m)]\\n        min_val = sys.maxsize\\n\\n        # For the first character in key, calculate the minimum steps directly\\n        for i in pos[key[0]]:\\n            dp[0][i] = min(i, n - i) + 1\\n            min_val = min(min_val, dp[0][i])\\n\\n        for i in range(1, m):\\n            min_val = sys.maxsize\\n            for j in pos[key[i]]:\\n                dp[i][j] = min(dp[i - 1][k] + min(abs(j - k), n - abs(j - k)) for k in pos[key[i - 1]]) + 1\\n                min_val = min(min_val, dp[i][j])\\n                \\n        return min_val\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport collections\\nimport sys\\n\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        # Store the positions of each character of ring in a dictionary\\n        pos = collections.defaultdict(list)\\n        for i, ch in enumerate(ring):\\n            pos[ch].append(i)\\n            \\n        # Initial dp table\\n        m, n = len(key), len(ring)\\n        dp = [[0]*n for _ in range(m)]\\n        min_val = sys.maxsize\\n\\n        # For the first character in key, calculate the minimum steps directly\\n        for i in pos[key[0]]:\\n            dp[0][i] = min(i, n - i) + 1\\n            min_val = min(min_val, dp[0][i])\\n\\n        for i in range(1, m):\\n            min_val = sys.maxsize\\n            for j in pos[key[i]]:\\n                dp[i][j] = min(dp[i - 1][k] + min(abs(j - k), n - abs(j - k)) for k in pos[key[i - 1]]) + 1\\n                min_val = min(min_val, dp[i][j])\\n                \\n        return min_val\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875281,
                "title": "python-solution-beats-98-67",
                "content": "# Code\\n```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        ln=len(ring)\\n        kln=len(key)\\n        def getSetp(id1,id2):\\n            d=abs(id1-id2)\\n            return min(d,ln-d)+1\\n    \\n        mp=defaultdict(list)\\n        for i,n in enumerate(ring):\\n            mp[n].append(i)\\n        for m in mp.values():\\n            m.sort()\\n        \\n        @cache\\n        def dps(id,ta)->int:\\n            c=key[ta]\\n            if ta==kln-1:\\n                if ring[id]==c:\\n                    return 1\\n                elif len(mp[c])==1:\\n                    return getSetp(id,mp[c][0])\\n                elif len(mp[c])==2:\\n                    return min(getSetp(id,mp[c][0]),getSetp(id,mp[c][1]))\\n                else:\\n                    n=bisect.bisect_left(mp[c],id)-1\\n                    if n==-1 or n==len(mp[c])-1:\\n                        return min(getSetp(id,mp[c][0]),getSetp(id,mp[c][-1]))\\n                    else:\\n                        return min(getSetp(id,mp[c][n]),getSetp(id,mp[c][n+1]))\\n            else:\\n                if ring[id]==c:\\n                    return dps(id,ta+1)+1\\n                elif len(mp[c])==1:\\n                    return getSetp(id,mp[c][0])+dps(mp[c][0],ta+1)\\n                elif len(mp[c])==2:\\n                    return min(getSetp(id,mp[c][0])+dps(mp[c][0],ta+1),getSetp(id,mp[c][1])+dps(mp[c][1],ta+1))\\n                else:\\n                    n=bisect.bisect_left(mp[c],id)-1\\n                    if n==-1 or n==len(mp[c])-1:\\n                        return min(getSetp(id,mp[c][0])+dps(mp[c][0],ta+1),getSetp(id,mp[c][-1])+dps(mp[c][-1],ta+1))\\n                    else:\\n                        return min(getSetp(id,mp[c][n])+dps(mp[c][n],ta+1),getSetp(id,mp[c][n+1])+dps(mp[c][n+1],ta+1))\\n        return dps(0,0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        ln=len(ring)\\n        kln=len(key)\\n        def getSetp(id1,id2):\\n            d=abs(id1-id2)\\n            return min(d,ln-d)+1\\n    \\n        mp=defaultdict(list)\\n        for i,n in enumerate(ring):\\n            mp[n].append(i)\\n        for m in mp.values():\\n            m.sort()\\n        \\n        @cache\\n        def dps(id,ta)->int:\\n            c=key[ta]\\n            if ta==kln-1:\\n                if ring[id]==c:\\n                    return 1\\n                elif len(mp[c])==1:\\n                    return getSetp(id,mp[c][0])\\n                elif len(mp[c])==2:\\n                    return min(getSetp(id,mp[c][0]),getSetp(id,mp[c][1]))\\n                else:\\n                    n=bisect.bisect_left(mp[c],id)-1\\n                    if n==-1 or n==len(mp[c])-1:\\n                        return min(getSetp(id,mp[c][0]),getSetp(id,mp[c][-1]))\\n                    else:\\n                        return min(getSetp(id,mp[c][n]),getSetp(id,mp[c][n+1]))\\n            else:\\n                if ring[id]==c:\\n                    return dps(id,ta+1)+1\\n                elif len(mp[c])==1:\\n                    return getSetp(id,mp[c][0])+dps(mp[c][0],ta+1)\\n                elif len(mp[c])==2:\\n                    return min(getSetp(id,mp[c][0])+dps(mp[c][0],ta+1),getSetp(id,mp[c][1])+dps(mp[c][1],ta+1))\\n                else:\\n                    n=bisect.bisect_left(mp[c],id)-1\\n                    if n==-1 or n==len(mp[c])-1:\\n                        return min(getSetp(id,mp[c][0])+dps(mp[c][0],ta+1),getSetp(id,mp[c][-1])+dps(mp[c][-1],ta+1))\\n                    else:\\n                        return min(getSetp(id,mp[c][n])+dps(mp[c][n],ta+1),getSetp(id,mp[c][n+1])+dps(mp[c][n+1],ta+1))\\n        return dps(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870976,
                "title": "rust-top-down-dp",
                "content": "# Approach\\n\\nFor each key character, try every single character in the ring that matches, and recursively calculate their respective number of steps. **Dynamic programming** with memoization can be used to cache the results.\\n\\n# Code\\n```rust\\npub struct DP {\\n    key: Vec<char>,\\n    ring: Vec<char>,\\n    n: usize, m: usize,\\n\\n    memo: Vec<Vec<Option<usize>>>,\\n}\\n\\nimpl DP {\\n    pub fn new(key: Vec<char>, ring: Vec<char>) -> Self {\\n        let (n, m) = (key.len(), ring.len());\\n\\n        let memo = vec![vec![None; m + 1]; n + 1];\\n\\n        Self {\\n            key, ring,\\n            n, m,\\n            memo\\n        }\\n    }\\n}\\n\\nimpl DP {\\n    pub fn solve(&mut self, i: usize, cursor: usize) -> usize {\\n        if i > self.n { return usize::MIN; }\\n        if cursor > self.m { return usize::MIN; }\\n\\n        if let Some(ret) = self.memo[i][cursor] {\\n            return ret; // cached\\n        }\\n\\n        let ret = self.solve_inner(i, cursor);\\n        self.memo[i][cursor] = Some(ret);\\n        ret\\n    }\\n\\n    fn solve_inner(&mut self, i: usize, cursor: usize) -> usize {\\n        if i >= self.n { return usize::MIN }\\n        if cursor >= self.m { return usize::MIN; }\\n\\n        let target = self.key[i];\\n        if target == self.ring[cursor] {\\n            return self.solve(i + 1, cursor) + 1; // greedy\\n        }\\n\\n        let mut ret = usize::MAX;\\n\\n        // need to turn the ring\\n        for cursor_next in 0..self.m {\\n            if target != self.ring[cursor_next] { continue; }\\n\\n            let mut diff = usize::MAX;\\n            diff = diff.min((cursor_next + self.m - cursor) % self.m);\\n            diff = diff.min((cursor + self.m - cursor_next) % self.m);\\n\\n            let mut _ret = self.solve(i + 1, cursor_next);\\n            _ret += diff + 1;\\n\\n            ret = ret.min(_ret);\\n        }\\n\\n        ret\\n    }\\n}\\n\\nimpl Solution {\\n    fn preproc(s: String) -> Vec<char> {\\n        s.chars().collect::<Vec<_>>()\\n    }\\n\\n    pub fn find_rotate_steps(ring: String, key: String) -> i32 {\\n        let ring = Self::preproc(ring);\\n        let key = Self::preproc(key);\\n\\n        let mut dp = DP::new(key, ring);\\n        dp.solve(usize::MIN, usize::MIN) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "```rust\\npub struct DP {\\n    key: Vec<char>,\\n    ring: Vec<char>,\\n    n: usize, m: usize,\\n\\n    memo: Vec<Vec<Option<usize>>>,\\n}\\n\\nimpl DP {\\n    pub fn new(key: Vec<char>, ring: Vec<char>) -> Self {\\n        let (n, m) = (key.len(), ring.len());\\n\\n        let memo = vec![vec![None; m + 1]; n + 1];\\n\\n        Self {\\n            key, ring,\\n            n, m,\\n            memo\\n        }\\n    }\\n}\\n\\nimpl DP {\\n    pub fn solve(&mut self, i: usize, cursor: usize) -> usize {\\n        if i > self.n { return usize::MIN; }\\n        if cursor > self.m { return usize::MIN; }\\n\\n        if let Some(ret) = self.memo[i][cursor] {\\n            return ret; // cached\\n        }\\n\\n        let ret = self.solve_inner(i, cursor);\\n        self.memo[i][cursor] = Some(ret);\\n        ret\\n    }\\n\\n    fn solve_inner(&mut self, i: usize, cursor: usize) -> usize {\\n        if i >= self.n { return usize::MIN }\\n        if cursor >= self.m { return usize::MIN; }\\n\\n        let target = self.key[i];\\n        if target == self.ring[cursor] {\\n            return self.solve(i + 1, cursor) + 1; // greedy\\n        }\\n\\n        let mut ret = usize::MAX;\\n\\n        // need to turn the ring\\n        for cursor_next in 0..self.m {\\n            if target != self.ring[cursor_next] { continue; }\\n\\n            let mut diff = usize::MAX;\\n            diff = diff.min((cursor_next + self.m - cursor) % self.m);\\n            diff = diff.min((cursor + self.m - cursor_next) % self.m);\\n\\n            let mut _ret = self.solve(i + 1, cursor_next);\\n            _ret += diff + 1;\\n\\n            ret = ret.min(_ret);\\n        }\\n\\n        ret\\n    }\\n}\\n\\nimpl Solution {\\n    fn preproc(s: String) -> Vec<char> {\\n        s.chars().collect::<Vec<_>>()\\n    }\\n\\n    pub fn find_rotate_steps(ring: String, key: String) -> i32 {\\n        let ring = Self::preproc(ring);\\n        let key = Self::preproc(key);\\n\\n        let mut dp = DP::new(key, ring);\\n        dp.solve(usize::MIN, usize::MIN) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3853557,
                "title": "python-dp-beats-100-easy-explained-with-comments",
                "content": "# Code\\n```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        index = defaultdict(list)\\n        #Index Hashing\\n        for i in range(len(ring)):\\n            index[ring[i]].append(i)\\n        #DFS function + DP\\n        @lru_cache\\n        def dfs(r, k):\\n            if k == len(key):\\n                return 0\\n            ans = float(\"inf\")\\n            for idx in index[key[k]]:\\n                clockwise_movement_cost = abs(idx - r) + 1\\n                anticlockwise_movement_cost = len(ring) - abs(idx - r) + 1\\n                ans = min(ans, min(clockwise_movement_cost, anticlockwise_movement_cost) + dfs(idx, k + 1))\\n            return ans\\n        #Invoking fn\\n        return dfs(0, 0)\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        index = defaultdict(list)\\n        #Index Hashing\\n        for i in range(len(ring)):\\n            index[ring[i]].append(i)\\n        #DFS function + DP\\n        @lru_cache\\n        def dfs(r, k):\\n            if k == len(key):\\n                return 0\\n            ans = float(\"inf\")\\n            for idx in index[key[k]]:\\n                clockwise_movement_cost = abs(idx - r) + 1\\n                anticlockwise_movement_cost = len(ring) - abs(idx - r) + 1\\n                ans = min(ans, min(clockwise_movement_cost, anticlockwise_movement_cost) + dfs(idx, k + 1))\\n            return ans\\n        #Invoking fn\\n        return dfs(0, 0)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831339,
                "title": "c-dp",
                "content": "```\\npublic class Solution {\\n    public int FindRotateSteps(string ring, string key) {\\n        Dictionary<char,List<int>> dict= GenerateHash(ring);\\n        int res=int.MaxValue;\\n\\n        int[] dp=new int[ring.Length];\\n        List<int> prev_locs=new List<int>();\\n        prev_locs.Add(0);\\n        \\n        for(int i=0;i<key.Length;i++){\\n            int[] dp2=new int[ring.Length+1];\\n            List<int> curr_locs=dict[key[i]];\\n            \\n            foreach(int curr_loc in curr_locs){\\n                dp2[curr_loc]=int.MaxValue;\\n                foreach(int prev_loc in prev_locs){\\n                    dp2[curr_loc]=Math.Min(dp2[curr_loc],dp[prev_loc] + GetDistance(ring, prev_loc,curr_loc));\\n                }\\n            }\\n            \\n            prev_locs=curr_locs;\\n            dp=dp2;\\n        }\\n        \\n        foreach(int last_loc in prev_locs)\\n            res=Math.Min(res,dp[last_loc]);\\n        \\n        return res+key.Length;\\n    }\\n    \\n    public int GetDistance(string ring, int prev_loc,int curr_loc){\\n        return Math.Min(\\n                        Math.Abs(prev_loc-curr_loc)\\n                        ,Math.Abs(ring.Length-Math.Abs(prev_loc-curr_loc))\\n        );\\n        \\n    }\\n    \\n    public Dictionary<char,List<int>> GenerateHash(string ring){\\n        Dictionary<char,List<int>> dict=new Dictionary<char,List<int>>();\\n        \\n        \\n        for(int i=0;i<ring.Length;i++){\\n            if(!dict.ContainsKey(ring[i]))\\n                dict.Add(ring[i],new List<int>());\\n            \\n            dict[ring[i]].Add(i);\\n        }\\n        \\n        return dict;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindRotateSteps(string ring, string key) {\\n        Dictionary<char,List<int>> dict= GenerateHash(ring);\\n        int res=int.MaxValue;\\n\\n        int[] dp=new int[ring.Length];\\n        List<int> prev_locs=new List<int>();\\n        prev_locs.Add(0);\\n        \\n        for(int i=0;i<key.Length;i++){\\n            int[] dp2=new int[ring.Length+1];\\n            List<int> curr_locs=dict[key[i]];\\n            \\n            foreach(int curr_loc in curr_locs){\\n                dp2[curr_loc]=int.MaxValue;\\n                foreach(int prev_loc in prev_locs){\\n                    dp2[curr_loc]=Math.Min(dp2[curr_loc],dp[prev_loc] + GetDistance(ring, prev_loc,curr_loc));\\n                }\\n            }\\n            \\n            prev_locs=curr_locs;\\n            dp=dp2;\\n        }\\n        \\n        foreach(int last_loc in prev_locs)\\n            res=Math.Min(res,dp[last_loc]);\\n        \\n        return res+key.Length;\\n    }\\n    \\n    public int GetDistance(string ring, int prev_loc,int curr_loc){\\n        return Math.Min(\\n                        Math.Abs(prev_loc-curr_loc)\\n                        ,Math.Abs(ring.Length-Math.Abs(prev_loc-curr_loc))\\n        );\\n        \\n    }\\n    \\n    public Dictionary<char,List<int>> GenerateHash(string ring){\\n        Dictionary<char,List<int>> dict=new Dictionary<char,List<int>>();\\n        \\n        \\n        for(int i=0;i<ring.Length;i++){\\n            if(!dict.ContainsKey(ring[i]))\\n                dict.Add(ring[i],new List<int>());\\n            \\n            dict[ring[i]].Add(i);\\n        }\\n        \\n        return dict;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779161,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// \\u6CE8\\u610F\\uFF1Ajava \\u4EE3\\u7801\\u7531 chatGPT\\\\U0001f916 \\u6839\\u636E\\u6211\\u7684 cpp \\u4EE3\\u7801\\u7FFB\\u8BD1\\uFF0C\\u65E8\\u5728\\u5E2E\\u52A9\\u4E0D\\u540C\\u80CC\\u666F\\u7684\\u8BFB\\u8005\\u7406\\u89E3\\u7B97\\u6CD5\\u903B\\u8F91\\u3002\\n// \\u672C\\u4EE3\\u7801\\u5DF2\\u7ECF\\u901A\\u8FC7\\u529B\\u6263\\u7684\\u6D4B\\u8BD5\\u7528\\u4F8B\\uFF0C\\u5E94\\u8BE5\\u53EF\\u76F4\\u63A5\\u6210\\u529F\\u63D0\\u4EA4\\u3002\\n\\nclass Solution {\\n    // \\u5B57\\u7B26 -> \\u7D22\\u5F15\\u5217\\u8868\\n    Map<Character, List<Integer>> charToIndex = new HashMap<>();\\n    // \\u5907\\u5FD8\\u5F55\\n    int[][] memo;\\n\\n    /* \\u4E3B\\u51FD\\u6570 */\\n    public int findRotateSteps(String ring, String key) {\\n        int m = ring.length();\\n        int n = key.length();\\n        // \\u5907\\u5FD8\\u5F55\\u5168\\u90E8\\u521D\\u59CB\\u5316\\u4E3A 0\\n        memo = new int[m][n];\\n        for (int[] row : memo) {\\n            Arrays.fill(row, 0);\\n        }\\n        // \\u8BB0\\u5F55\\u5706\\u73AF\\u4E0A\\u5B57\\u7B26\\u5230\\u7D22\\u5F15\\u7684\\u6620\\u5C04\\n        for (int i = 0; i < ring.length(); i++) {\\n            char c = ring.charAt(i);\\n            List<Integer> list = charToIndex.getOrDefault(c, new ArrayList<>());\\n            list.add(i);\\n            charToIndex.put(c, list);\\n        }\\n        // \\u5706\\u76D8\\u6307\\u9488\\u6700\\u521D\\u6307\\u5411 12 \\u70B9\\u949F\\u65B9\\u5411\\uFF0C\\n        // \\u4ECE\\u7B2C\\u4E00\\u4E2A\\u5B57\\u7B26\\u5F00\\u59CB\\u8F93\\u5165 key\\n        return dp(ring, 0, key, 0);\\n    }\\n\\n    // \\u8BA1\\u7B97\\u5706\\u76D8\\u6307\\u9488\\u5728 ring[i]\\uFF0C\\u8F93\\u5165 key[j..] \\u7684\\u6700\\u5C11\\u64CD\\u4F5C\\u6570\\n    private int dp(String ring, int i, String key, int j) {\\n        // base case \\u5B8C\\u6210\\u8F93\\u5165\\n        if (j == key.length()) return 0;\\n        // \\u67E5\\u627E\\u5907\\u5FD8\\u5F55\\uFF0C\\u907F\\u514D\\u91CD\\u53E0\\u5B50\\u95EE\\u9898\\n        if (memo[i][j] != 0) return memo[i][j];\\n\\n        int n = ring.length();\\n        // \\u505A\\u9009\\u62E9\\n        int res = Integer.MAX_VALUE;\\n        char c = key.charAt(j);\\n        // ring \\u4E0A\\u53EF\\u80FD\\u6709\\u591A\\u4E2A\\u5B57\\u7B26 key[j]\\n        for (int k : charToIndex.getOrDefault(c, new ArrayList<>())) {\\n            // \\u62E8\\u52A8\\u6307\\u9488\\u7684\\u6B21\\u6570\\n            int delta = Math.abs(k - i);\\n            // \\u9009\\u62E9\\u987A\\u65F6\\u9488\\u8FD8\\u662F\\u9006\\u65F6\\u9488\\n            delta = Math.min(delta, n - delta);\\n            // \\u5C06\\u6307\\u9488\\u62E8\\u5230 ring[k]\\uFF0C\\u7EE7\\u7EED\\u8F93\\u5165 key[j+1..]\\n            int subProblem = dp(ring, k, key, j + 1);\\n            // \\u9009\\u62E9\\u300C\\u6574\\u4F53\\u300D\\u64CD\\u4F5C\\u6B21\\u6570\\u6700\\u5C11\\u7684\\n            // \\u52A0\\u4E00\\u662F\\u56E0\\u4E3A\\u6309\\u52A8\\u6309\\u94AE\\u4E5F\\u662F\\u4E00\\u6B21\\u64CD\\u4F5C\\n            res = Math.min(res, 1 + delta + subProblem);\\n        }\\n        // \\u5C06\\u7ED3\\u679C\\u5B58\\u5165\\u5907\\u5FD8\\u5F55\\n        memo[i][j] = res;\\n        return res;\\n    }\\n}\\n// \\u8BE6\\u7EC6\\u89E3\\u6790\\u53C2\\u89C1\\uFF1A\\n// https://labuladong.github.io/article/?qno=\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// \\u6CE8\\u610F\\uFF1Ajava \\u4EE3\\u7801\\u7531 chatGPT\\\\U0001f916 \\u6839\\u636E\\u6211\\u7684 cpp \\u4EE3\\u7801\\u7FFB\\u8BD1\\uFF0C\\u65E8\\u5728\\u5E2E\\u52A9\\u4E0D\\u540C\\u80CC\\u666F\\u7684\\u8BFB\\u8005\\u7406\\u89E3\\u7B97\\u6CD5\\u903B\\u8F91\\u3002\\n// \\u672C\\u4EE3\\u7801\\u5DF2\\u7ECF\\u901A\\u8FC7\\u529B\\u6263\\u7684\\u6D4B\\u8BD5\\u7528\\u4F8B\\uFF0C\\u5E94\\u8BE5\\u53EF\\u76F4\\u63A5\\u6210\\u529F\\u63D0\\u4EA4\\u3002\\n\\nclass Solution {\\n    // \\u5B57\\u7B26 -> \\u7D22\\u5F15\\u5217\\u8868\\n    Map<Character, List<Integer>> charToIndex = new HashMap<>();\\n    // \\u5907\\u5FD8\\u5F55\\n    int[][] memo;\\n\\n    /* \\u4E3B\\u51FD\\u6570 */\\n    public int findRotateSteps(String ring, String key) {\\n        int m = ring.length();\\n        int n = key.length();\\n        // \\u5907\\u5FD8\\u5F55\\u5168\\u90E8\\u521D\\u59CB\\u5316\\u4E3A 0\\n        memo = new int[m][n];\\n        for (int[] row : memo) {\\n            Arrays.fill(row, 0);\\n        }\\n        // \\u8BB0\\u5F55\\u5706\\u73AF\\u4E0A\\u5B57\\u7B26\\u5230\\u7D22\\u5F15\\u7684\\u6620\\u5C04\\n        for (int i = 0; i < ring.length(); i++) {\\n            char c = ring.charAt(i);\\n            List<Integer> list = charToIndex.getOrDefault(c, new ArrayList<>());\\n            list.add(i);\\n            charToIndex.put(c, list);\\n        }\\n        // \\u5706\\u76D8\\u6307\\u9488\\u6700\\u521D\\u6307\\u5411 12 \\u70B9\\u949F\\u65B9\\u5411\\uFF0C\\n        // \\u4ECE\\u7B2C\\u4E00\\u4E2A\\u5B57\\u7B26\\u5F00\\u59CB\\u8F93\\u5165 key\\n        return dp(ring, 0, key, 0);\\n    }\\n\\n    // \\u8BA1\\u7B97\\u5706\\u76D8\\u6307\\u9488\\u5728 ring[i]\\uFF0C\\u8F93\\u5165 key[j..] \\u7684\\u6700\\u5C11\\u64CD\\u4F5C\\u6570\\n    private int dp(String ring, int i, String key, int j) {\\n        // base case \\u5B8C\\u6210\\u8F93\\u5165\\n        if (j == key.length()) return 0;\\n        // \\u67E5\\u627E\\u5907\\u5FD8\\u5F55\\uFF0C\\u907F\\u514D\\u91CD\\u53E0\\u5B50\\u95EE\\u9898\\n        if (memo[i][j] != 0) return memo[i][j];\\n\\n        int n = ring.length();\\n        // \\u505A\\u9009\\u62E9\\n        int res = Integer.MAX_VALUE;\\n        char c = key.charAt(j);\\n        // ring \\u4E0A\\u53EF\\u80FD\\u6709\\u591A\\u4E2A\\u5B57\\u7B26 key[j]\\n        for (int k : charToIndex.getOrDefault(c, new ArrayList<>())) {\\n            // \\u62E8\\u52A8\\u6307\\u9488\\u7684\\u6B21\\u6570\\n            int delta = Math.abs(k - i);\\n            // \\u9009\\u62E9\\u987A\\u65F6\\u9488\\u8FD8\\u662F\\u9006\\u65F6\\u9488\\n            delta = Math.min(delta, n - delta);\\n            // \\u5C06\\u6307\\u9488\\u62E8\\u5230 ring[k]\\uFF0C\\u7EE7\\u7EED\\u8F93\\u5165 key[j+1..]\\n            int subProblem = dp(ring, k, key, j + 1);\\n            // \\u9009\\u62E9\\u300C\\u6574\\u4F53\\u300D\\u64CD\\u4F5C\\u6B21\\u6570\\u6700\\u5C11\\u7684\\n            // \\u52A0\\u4E00\\u662F\\u56E0\\u4E3A\\u6309\\u52A8\\u6309\\u94AE\\u4E5F\\u662F\\u4E00\\u6B21\\u64CD\\u4F5C\\n            res = Math.min(res, 1 + delta + subProblem);\\n        }\\n        // \\u5C06\\u7ED3\\u679C\\u5B58\\u5165\\u5907\\u5FD8\\u5F55\\n        memo[i][j] = res;\\n        return res;\\n    }\\n}\\n// \\u8BE6\\u7EC6\\u89E3\\u6790\\u53C2\\u89C1\\uFF1A\\n// https://labuladong.github.io/article/?qno=\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773200,
                "title": "dp-memoization-best-solution-easy-to-understand",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n#include <bits/stdc++.h>\\r\\nusing namespace std;\\r\\nclass Solution\\r\\n{\\r\\npublic:\\r\\n    int f(int ring_ind, int key_ind, string &ring, string &key, vector<vector<int>> &dp)\\r\\n    {\\r\\n        int n = ring.size();\\r\\n        int m = key.size();\\r\\n        // base case\\r\\n        if (key_ind >= m)\\r\\n        {\\r\\n            return 0;\\r\\n        }\\r\\n        if (dp[ring_ind][key_ind] != -1)\\r\\n        {\\r\\n            return dp[ring_ind][key_ind];\\r\\n        }\\r\\n\\r\\n        // trying all possibilities\\r\\n        int steps = 1e9;\\r\\n        for (int i = 0; i < n; i++)\\r\\n        {\\r\\n            if (ring[i] == key[key_ind])\\r\\n            {\\r\\n                int clockWise = abs(i - ring_ind) + 1 + f(i, key_ind + 1, ring, key, dp);\\r\\n                int antiClockWise = n - abs(i - ring_ind) + 1 + f(i, key_ind + 1, ring, key, dp);\\r\\n                steps = min(steps, min(clockWise, antiClockWise));\\r\\n            }\\r\\n        }\\r\\n        return dp[ring_ind][key_ind] = steps;\\r\\n    }\\r\\n    int findRotateSteps(string ring, string key)\\r\\n    {\\r\\n        int n = ring.size();\\r\\n        int m = key.size();\\r\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\r\\n        return f(0, 0, ring, key, dp);\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\n#include <bits/stdc++.h>\\r\\nusing namespace std;\\r\\nclass Solution\\r\\n{\\r\\npublic:\\r\\n    int f(int ring_ind, int key_ind, string &ring, string &key, vector<vector<int>> &dp)\\r\\n    {\\r\\n        int n = ring.size();\\r\\n        int m = key.size();\\r\\n        // base case\\r\\n        if (key_ind >= m)\\r\\n        {\\r\\n            return 0;\\r\\n        }\\r\\n        if (dp[ring_ind][key_ind] != -1)\\r\\n        {\\r\\n            return dp[ring_ind][key_ind];\\r\\n        }\\r\\n\\r\\n        // trying all possibilities\\r\\n        int steps = 1e9;\\r\\n        for (int i = 0; i < n; i++)\\r\\n        {\\r\\n            if (ring[i] == key[key_ind])\\r\\n            {\\r\\n                int clockWise = abs(i - ring_ind) + 1 + f(i, key_ind + 1, ring, key, dp);\\r\\n                int antiClockWise = n - abs(i - ring_ind) + 1 + f(i, key_ind + 1, ring, key, dp);\\r\\n                steps = min(steps, min(clockWise, antiClockWise));\\r\\n            }\\r\\n        }\\r\\n        return dp[ring_ind][key_ind] = steps;\\r\\n    }\\r\\n    int findRotateSteps(string ring, string key)\\r\\n    {\\r\\n        int n = ring.size();\\r\\n        int m = key.size();\\r\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\r\\n        return f(0, 0, ring, key, dp);\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3770812,
                "title": "dp-solution",
                "content": "# Intuition\\nTwo key concepts for DP problems: state and choices\\n\\nWe have two states here:\\n- Current letter on the ring\\n- Current target letter for key\\n\\nChoice is about how we could move the current index to get the target letter, we need to try all options and get the minimum cost. We can use a memo data structure to keep track of the visited state (i, j). i is the current index on the ring while j is the index for key.\\n\\n# Code\\n```\\nclass Solution {\\n    lateinit var memo: Array<IntArray>\\n    lateinit var charIndices: Array<MutableList<Int>>\\n    fun findRotateSteps(ring: String, key: String): Int {\\n        val m = ring.length; val n = key.length\\n        memo = Array(m) { IntArray(n) { Int.MAX_VALUE } }\\n        charIndices = Array(26) { mutableListOf<Int>() }\\n        ring.forEachIndexed { ind, char -> charIndices[char - \\'a\\'].add(ind) }\\n        \\n        return dp(ring, 0, key, 0) + n\\n    }\\n    \\n    fun dp(ring: String, i: Int, key: String, j: Int): Int {\\n        if (j >= key.length) return 0\\n        \\n        if (memo[i][j] != Int.MAX_VALUE) return memo[i][j]\\n        \\n        var result = Int.MAX_VALUE\\n        for (index in charIndices[key[j] - \\'a\\']) {\\n            val oneWay = Math.abs(i - index)\\n            val step = Math.min(oneWay, Math.abs(ring.length - oneWay))\\n            val subProblem = dp(ring, index, key, j + 1)\\n            \\n            result = Math.min(result, step + subProblem)\\n        }\\n        \\n        memo[i][j] = result\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    lateinit var memo: Array<IntArray>\\n    lateinit var charIndices: Array<MutableList<Int>>\\n    fun findRotateSteps(ring: String, key: String): Int {\\n        val m = ring.length; val n = key.length\\n        memo = Array(m) { IntArray(n) { Int.MAX_VALUE } }\\n        charIndices = Array(26) { mutableListOf<Int>() }\\n        ring.forEachIndexed { ind, char -> charIndices[char - \\'a\\'].add(ind) }\\n        \\n        return dp(ring, 0, key, 0) + n\\n    }\\n    \\n    fun dp(ring: String, i: Int, key: String, j: Int): Int {\\n        if (j >= key.length) return 0\\n        \\n        if (memo[i][j] != Int.MAX_VALUE) return memo[i][j]\\n        \\n        var result = Int.MAX_VALUE\\n        for (index in charIndices[key[j] - \\'a\\']) {\\n            val oneWay = Math.abs(i - index)\\n            val step = Math.min(oneWay, Math.abs(ring.length - oneWay))\\n            val subProblem = dp(ring, index, key, j + 1)\\n            \\n            result = Math.min(result, step + subProblem)\\n        }\\n        \\n        memo[i][j] = result\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750955,
                "title": "intuitive-cpp-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. State: memo[i][j] = the minimum steps take if currently at ring[i] and want to spell key[j...]\\n2. Choices: which character to go to if got multiple characters in the ring equals to key[j]\\n3. State transfer: memo[i][j] = min(1 + distance[ring[i] to ring[x] + memo[ring[x]][j+1]), for all ring[x] where ring[x] = key[j]\\n4. Base case: when finished spelling key, return 0\\n5. Helper state: charPositions stores all locations of each char, e.g. d: [2, 3]\\n\\n# Complexity\\n- Time complexity: O(mn)\\n\\n- Space complexity: O(mn)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp(string ring, string key, unordered_map<char, vector<int>>& charPositions, vector<vector<int>>& memo, int i, int j) {\\n        if (j >= key.size()) {\\n            return 0;\\n        }\\n        if (memo[i][j] != -888) {\\n            return memo[i][j];\\n        }\\n        int res = INT_MAX;\\n        for (int choice : charPositions[key[j]]) {\\n            int delta = abs(choice - i);\\n            int size = ring.size(); // note ring.size() by nature is of type unsigned long, so here do an implicit type cast to int\\n            int distance = min(delta, size - delta);\\n            res = min(res, 1 + distance + dp(ring, key, charPositions, memo, choice, j+1));\\n        }\\n        memo[i][j] = res;\\n        return memo[i][j];\\n    }\\n    \\n    int findRotateSteps(string ring, string key) {\\n        unordered_map<char, vector<int>> charPositions;\\n        for (int i = 0; i < ring.size(); i++) {\\n            charPositions[ring[i]].push_back(i);\\n        }\\n\\n        vector<vector<int>> memo(ring.size(), vector<int>(key.size(), -888));\\n        return dp(ring, key, charPositions, memo, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp(string ring, string key, unordered_map<char, vector<int>>& charPositions, vector<vector<int>>& memo, int i, int j) {\\n        if (j >= key.size()) {\\n            return 0;\\n        }\\n        if (memo[i][j] != -888) {\\n            return memo[i][j];\\n        }\\n        int res = INT_MAX;\\n        for (int choice : charPositions[key[j]]) {\\n            int delta = abs(choice - i);\\n            int size = ring.size(); // note ring.size() by nature is of type unsigned long, so here do an implicit type cast to int\\n            int distance = min(delta, size - delta);\\n            res = min(res, 1 + distance + dp(ring, key, charPositions, memo, choice, j+1));\\n        }\\n        memo[i][j] = res;\\n        return memo[i][j];\\n    }\\n    \\n    int findRotateSteps(string ring, string key) {\\n        unordered_map<char, vector<int>> charPositions;\\n        for (int i = 0; i < ring.size(); i++) {\\n            charPositions[ring[i]].push_back(i);\\n        }\\n\\n        vector<vector<int>> memo(ring.size(), vector<int>(key.size(), -888));\\n        return dp(ring, key, charPositions, memo, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742499,
                "title": "dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        \"\"\"Trial 1: WA\\n        BUG: e.g., ring=\\'abccdbc\\', key=\\'abd\\'\\n            If greedy, then 0-1-4, but choosing the other b is better\\n        Search: tried to design dp state as the current pointer and the rest of the ring,\\n            while in fact, only the current position and the next char is enough\\n        \"\"\"\\n        m = defaultdict(list)\\n        for i, c in enumerate(ring):\\n            m[c].append(i)\\n\\n        # i = 0\\n        # steps = 0\\n        # for k in key:\\n        #     next_s, next_i = float(\\'inf\\'), None\\n        #     for j in m[k]:\\n        #         s = min(abs(i-j), len(ring) - abs(i-j))\\n        #         if s < next_s:\\n        #             next_s, next_i = s, j\\n        #     steps += next_s\\n        #     i = next_i\\n        # return steps + len(key)\\n\\n        @cache\\n        def dp(i, j):  # the min ops when pointer at ring[i] and about to enter key[j:]\\n            if j == len(key):\\n                return 0\\n            steps = []\\n            for ii in m[key[j]]:\\n                s = min(abs(ii-i), len(ring) - abs(ii-i))\\n                steps.append(s + 1 + dp(ii, j+1))\\n            return min(steps)\\n        return dp(0, 0)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        \"\"\"Trial 1: WA\\n        BUG: e.g., ring=\\'abccdbc\\', key=\\'abd\\'\\n            If greedy, then 0-1-4, but choosing the other b is better\\n        Search: tried to design dp state as the current pointer and the rest of the ring,\\n            while in fact, only the current position and the next char is enough\\n        \"\"\"\\n        m = defaultdict(list)\\n        for i, c in enumerate(ring):\\n            m[c].append(i)\\n\\n        # i = 0\\n        # steps = 0\\n        # for k in key:\\n        #     next_s, next_i = float(\\'inf\\'), None\\n        #     for j in m[k]:\\n        #         s = min(abs(i-j), len(ring) - abs(i-j))\\n        #         if s < next_s:\\n        #             next_s, next_i = s, j\\n        #     steps += next_s\\n        #     i = next_i\\n        # return steps + len(key)\\n\\n        @cache\\n        def dp(i, j):  # the min ops when pointer at ring[i] and about to enter key[j:]\\n            if j == len(key):\\n                return 0\\n            steps = []\\n            for ii in m[key[j]]:\\n                s = min(abs(ii-i), len(ring) - abs(ii-i))\\n                steps.append(s + 1 + dp(ii, j+1))\\n            return min(steps)\\n        return dp(0, 0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741129,
                "title": "freedom-trail-dynamic-programming",
                "content": "# Code\\n```\\nclass Solution:\\n    def getIndexList(self, ch, ring):\\n        res = []\\n        for i in range(len(ring)):\\n            if ring[i] == ch:\\n                res.append(i)\\n        return res\\n\\n    def getRotationStep(self, ring, ring_index, target_index):\\n        return min(abs(ring_index - target_index), len(ring) - abs(ring_index - target_index))\\n\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        # dp(pos, i) means the number of steps taken when the ring is at index i and the key[pos] is spelled\\n        key = ring[0] + key\\n        dp = [[float(\\'inf\\')] * len(ring) for i in range(len(key))]\\n        for pos in range(len(key)):\\n            if pos == 0:\\n                for i in range(len(ring)):\\n                    dp[pos][i] = 0\\n                continue\\n            prev_char = key[pos-1]\\n            target = key[pos]\\n            if pos == 1:\\n                prev_index_list = [0]\\n            else:\\n                prev_index_list = self.getIndexList(prev_char, ring)\\n            target_index_list = self.getIndexList(target, ring)\\n            for i in target_index_list:\\n                for j in prev_index_list:\\n                    dp[pos][i] = min(dp[pos][i], dp[pos-1][j] + self.getRotationStep(ring, j, i) + 1)\\n        \\n        res = float(\\'inf\\')\\n        for i in range(len(ring)):\\n            steps = dp[len(key)-1][i]\\n            res = min(res, steps)\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def getIndexList(self, ch, ring):\\n        res = []\\n        for i in range(len(ring)):\\n            if ring[i] == ch:\\n                res.append(i)\\n        return res\\n\\n    def getRotationStep(self, ring, ring_index, target_index):\\n        return min(abs(ring_index - target_index), len(ring) - abs(ring_index - target_index))\\n\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        # dp(pos, i) means the number of steps taken when the ring is at index i and the key[pos] is spelled\\n        key = ring[0] + key\\n        dp = [[float(\\'inf\\')] * len(ring) for i in range(len(key))]\\n        for pos in range(len(key)):\\n            if pos == 0:\\n                for i in range(len(ring)):\\n                    dp[pos][i] = 0\\n                continue\\n            prev_char = key[pos-1]\\n            target = key[pos]\\n            if pos == 1:\\n                prev_index_list = [0]\\n            else:\\n                prev_index_list = self.getIndexList(prev_char, ring)\\n            target_index_list = self.getIndexList(target, ring)\\n            for i in target_index_list:\\n                for j in prev_index_list:\\n                    dp[pos][i] = min(dp[pos][i], dp[pos-1][j] + self.getRotationStep(ring, j, i) + 1)\\n        \\n        res = float(\\'inf\\')\\n        for i in range(len(ring)):\\n            steps = dp[len(key)-1][i]\\n            res = min(res, steps)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740002,
                "title": "514-freedom-trail-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ndp\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. create a HashMap \\'charToIndex\\' to find the index of each char on the ring.\\n2. use dp function: dp(i, j) means the minimum number of steps to spell key[j..] when the ring points to ring[i].\\n3. to calculate dp(i, j), first we need to find indices of key[j] using \\'charToIndex\\'\\n    then for each index k, we calculate the minimum steps to spell key[j..]\\n    then update the minimum result\\n4. use a memo to reduce the repeated calculations\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(MN) where M is the length of ring and N is the length of key\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(MN) where M is the length of ring and N is the length of key\\n# Code\\n```\\nclass Solution {\\n    int[][] memo;\\n    HashMap<Character, List<Integer>> charToIndex = new HashMap<>();\\n    public int findRotateSteps(String ring, String key) {\\n        int m = ring.length(), n = key.length();\\n        memo = new int[m][n];\\n        for (int i = 0; i < m; i++){\\n            charToIndex.putIfAbsent(ring.charAt(i), new LinkedList<>());\\n            charToIndex.get(ring.charAt(i)).add(i);\\n            Arrays.fill(memo[i], -6);\\n        }\\n        return dp(ring, key, 0, 0);\\n    }\\n\\n    public int dp(String ring, String key, int i, int j){\\n        int m = ring.length(), n = key.length();\\n        if (j == n) return 0;\\n        if (memo[i][j] != -6) return memo[i][j];\\n        int res = Integer.MAX_VALUE;\\n        \\n        for (int k : charToIndex.get(key.charAt(j))){\\n            int delta = Math.abs(k - i);\\n            delta = Math.min(delta, m - delta);\\n            int subProblem = delta + 1 + dp(ring, key, k, j + 1);\\n            res = Math.min(res, subProblem);\\n        }\\n        memo[i][j] = res;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[][] memo;\\n    HashMap<Character, List<Integer>> charToIndex = new HashMap<>();\\n    public int findRotateSteps(String ring, String key) {\\n        int m = ring.length(), n = key.length();\\n        memo = new int[m][n];\\n        for (int i = 0; i < m; i++){\\n            charToIndex.putIfAbsent(ring.charAt(i), new LinkedList<>());\\n            charToIndex.get(ring.charAt(i)).add(i);\\n            Arrays.fill(memo[i], -6);\\n        }\\n        return dp(ring, key, 0, 0);\\n    }\\n\\n    public int dp(String ring, String key, int i, int j){\\n        int m = ring.length(), n = key.length();\\n        if (j == n) return 0;\\n        if (memo[i][j] != -6) return memo[i][j];\\n        int res = Integer.MAX_VALUE;\\n        \\n        for (int k : charToIndex.get(key.charAt(j))){\\n            int delta = Math.abs(k - i);\\n            delta = Math.min(delta, m - delta);\\n            int subProblem = delta + 1 + dp(ring, key, k, j + 1);\\n            res = Math.min(res, subProblem);\\n        }\\n        memo[i][j] = res;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738526,
                "title": "python-always-use-bfs-if-it-says-minimum-steps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nclean bfs code\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        n, m = len(key), len(ring)\\n        visit = set()\\n        q = [(0, 0, 0)]\\n\\n        while q:\\n            loc, spelt, lvl = q.pop(0)\\n            if spelt == n:  \\n                return lvl\\n            if (loc, spelt) in visit: \\n                continue\\n            visit.add((loc, spelt))\\n            if ring[loc] == key[spelt]:\\n                q.append((loc, spelt + 1, lvl + 1))\\n            else:\\n                q.append(((loc + 1) % m, spelt, lvl + 1))\\n                q.append(((loc - 1) % m, spelt, lvl + 1))\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        n, m = len(key), len(ring)\\n        visit = set()\\n        q = [(0, 0, 0)]\\n\\n        while q:\\n            loc, spelt, lvl = q.pop(0)\\n            if spelt == n:  \\n                return lvl\\n            if (loc, spelt) in visit: \\n                continue\\n            visit.add((loc, spelt))\\n            if ring[loc] == key[spelt]:\\n                q.append((loc, spelt + 1, lvl + 1))\\n            else:\\n                q.append(((loc + 1) % m, spelt, lvl + 1))\\n                q.append(((loc - 1) % m, spelt, lvl + 1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737337,
                "title": "java-07082023",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int findRotateSteps(String ring, String key) {\\n        HashMap<Character, List<Integer>> charIndex = new HashMap<>();\\n\\n        for (int i = 0; i < ring.length(); i++) {\\n            char c = ring.charAt(i);\\n            if (!charIndex.containsKey(c)) {\\n                charIndex.put(c, new LinkedList<>());\\n            }\\n            charIndex.get(c).add(i);\\n        }\\n\\n        int[][] dp = new int[key.length()+1][ring.length()];\\n\\n        for (int i = key.length() - 1; i >= 0; i--) {\\n            for (int j = 0; j < ring.length(); j++) {\\n                int res = Integer.MAX_VALUE;\\n                for (int k : charIndex.get(key.charAt(i))) {\\n                    int move = Math.abs(k - j);\\n                    move = Math.min(move, ring.length() - move);\\n                    res = Math.min(res, 1 + move + dp[i+1][k]);\\n                }\\n                dp[i][j] = res;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findRotateSteps(String ring, String key) {\\n        HashMap<Character, List<Integer>> charIndex = new HashMap<>();\\n\\n        for (int i = 0; i < ring.length(); i++) {\\n            char c = ring.charAt(i);\\n            if (!charIndex.containsKey(c)) {\\n                charIndex.put(c, new LinkedList<>());\\n            }\\n            charIndex.get(c).add(i);\\n        }\\n\\n        int[][] dp = new int[key.length()+1][ring.length()];\\n\\n        for (int i = key.length() - 1; i >= 0; i--) {\\n            for (int j = 0; j < ring.length(); j++) {\\n                int res = Integer.MAX_VALUE;\\n                for (int k : charIndex.get(key.charAt(i))) {\\n                    int move = Math.abs(k - j);\\n                    move = Math.min(move, ring.length() - move);\\n                    res = Math.min(res, 1 + move + dp[i+1][k]);\\n                }\\n                dp[i][j] = res;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709597,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(m * n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def findRotateSteps(ring: String, key: String): Int = {\\n      val n = ring.length\\n      val m = key.length\\n      val dp = Array.ofDim[Int](m+1, n)\\n      for (j <- m-1 to 0 by -1; i <- 0 until n) {\\n          dp(j)(i) = Int.MaxValue\\n          for (k <- 0 until n) \\n            if (ring(k) == key(j)) {\\n              val diff = math.abs(i - k)\\n              dp(j)(i) = math.min(dp(j)(i), math.min(diff, n - diff) + dp(j+1)(k))\\n            }\\n      }\\n      dp(0)(0) + m\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def findRotateSteps(ring: String, key: String): Int = {\\n      val n = ring.length\\n      val m = key.length\\n      val dp = Array.ofDim[Int](m+1, n)\\n      for (j <- m-1 to 0 by -1; i <- 0 until n) {\\n          dp(j)(i) = Int.MaxValue\\n          for (k <- 0 until n) \\n            if (ring(k) == key(j)) {\\n              val diff = math.abs(i - k)\\n              dp(j)(i) = math.min(dp(j)(i), math.min(diff, n - diff) + dp(j+1)(k))\\n            }\\n      }\\n      dp(0)(0) + m\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3698459,
                "title": "c-recursion-memoization-clean-and-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int steps(int i, int j, string ring, string key, map<char, vector<int>> &m)\\n    {\\n        if(j==key.size())\\n        return 0;\\n\\n        if(dp[i][j]!=-1)\\n        return dp[i][j];\\n\\n        int ans = INT_MAX;\\n        for(int index : m[key[j]])\\n        {\\n            int moves = min(abs(index-i), (int)ring.size() - abs(index-i));\\n            ans = min(ans, 1 + moves + steps(index, j+1, ring, key, m));\\n        }\\n        return dp[i][j] = ans;\\n    }\\n\\n    int findRotateSteps(string ring, string key) {\\n        map<char, vector<int>> m;\\n        int n = ring.size();\\n        memset(dp, -1, sizeof dp);\\n        for(int i=0; i<n; i++)\\n        m[ring[i]].push_back(i);\\n        return steps(0, 0, ring, key, m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int steps(int i, int j, string ring, string key, map<char, vector<int>> &m)\\n    {\\n        if(j==key.size())\\n        return 0;\\n\\n        if(dp[i][j]!=-1)\\n        return dp[i][j];\\n\\n        int ans = INT_MAX;\\n        for(int index : m[key[j]])\\n        {\\n            int moves = min(abs(index-i), (int)ring.size() - abs(index-i));\\n            ans = min(ans, 1 + moves + steps(index, j+1, ring, key, m));\\n        }\\n        return dp[i][j] = ans;\\n    }\\n\\n    int findRotateSteps(string ring, string key) {\\n        map<char, vector<int>> m;\\n        int n = ring.size();\\n        memset(dp, -1, sizeof dp);\\n        for(int i=0; i<n; i++)\\n        m[ring[i]].push_back(i);\\n        return steps(0, 0, ring, key, m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684822,
                "title": "memo-bottom-up-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    pair<int, int> findLetter(const string& ring, int p, char letter, char DIR = \\'L\\'){\\n        int n = ring.size();\\n        int steps = 0;\\n        for(;ring[p] != letter; p = (p + ((DIR == \\'L\\') ? 1 : -1) + n) % n){\\n            steps++;\\n        }\\n\\n        return {p, steps};\\n    }\\n\\n    int rotateSteps(string& ring, int p, string& key, int i, vector<vector<int>>& dp){\\n        int m = key.size();\\n        if(i == m){\\n            return 0;\\n        }\\n        \\n        if(dp[i][p]){\\n            return dp[i][p];\\n        }\\n\\n        auto [leftPos, leftSteps] = findLetter(ring, p, key[i], \\'L\\');\\n        auto [rightPos, rightSteps] = findLetter(ring, p, key[i], \\'R\\');\\n        \\n        dp[i][p] = min(\\n                leftSteps + 1 + rotateSteps(ring, leftPos, key, i + 1, dp),\\n                rightSteps + 1 + rotateSteps(ring, rightPos, key, i + 1, dp)\\n            );\\n\\n        return dp[i][p];\\n    }\\n\\n    int findRotateSteps(string ring, string key) {\\n        int n = ring.size();\\n        int m = key.size();\\n        vector dp(m + 5, vector<int>(n + 5));\\n        return rotateSteps(ring, 0, key, 0, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int, int> findLetter(const string& ring, int p, char letter, char DIR = \\'L\\'){\\n        int n = ring.size();\\n        int steps = 0;\\n        for(;ring[p] != letter; p = (p + ((DIR == \\'L\\') ? 1 : -1) + n) % n){\\n            steps++;\\n        }\\n\\n        return {p, steps};\\n    }\\n\\n    int rotateSteps(string& ring, int p, string& key, int i, vector<vector<int>>& dp){\\n        int m = key.size();\\n        if(i == m){\\n            return 0;\\n        }\\n        \\n        if(dp[i][p]){\\n            return dp[i][p];\\n        }\\n\\n        auto [leftPos, leftSteps] = findLetter(ring, p, key[i], \\'L\\');\\n        auto [rightPos, rightSteps] = findLetter(ring, p, key[i], \\'R\\');\\n        \\n        dp[i][p] = min(\\n                leftSteps + 1 + rotateSteps(ring, leftPos, key, i + 1, dp),\\n                rightSteps + 1 + rotateSteps(ring, rightPos, key, i + 1, dp)\\n            );\\n\\n        return dp[i][p];\\n    }\\n\\n    int findRotateSteps(string ring, string key) {\\n        int n = ring.size();\\n        int m = key.size();\\n        vector dp(m + 5, vector<int>(n + 5));\\n        return rotateSteps(ring, 0, key, 0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684821,
                "title": "memo-bottom-up-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    pair<int, int> findLetter(const string& ring, int p, char letter, char DIR = \\'L\\'){\\n        int n = ring.size();\\n        int steps = 0;\\n        for(;ring[p] != letter; p = (p + ((DIR == \\'L\\') ? 1 : -1) + n) % n){\\n            steps++;\\n        }\\n\\n        return {p, steps};\\n    }\\n\\n    int rotateSteps(string& ring, int p, string& key, int i, vector<vector<int>>& dp){\\n        int m = key.size();\\n        if(i == m){\\n            return 0;\\n        }\\n        \\n        if(dp[i][p]){\\n            return dp[i][p];\\n        }\\n\\n        auto [leftPos, leftSteps] = findLetter(ring, p, key[i], \\'L\\');\\n        auto [rightPos, rightSteps] = findLetter(ring, p, key[i], \\'R\\');\\n        \\n        dp[i][p] = min(\\n                leftSteps + 1 + rotateSteps(ring, leftPos, key, i + 1, dp),\\n                rightSteps + 1 + rotateSteps(ring, rightPos, key, i + 1, dp)\\n            );\\n\\n        return dp[i][p];\\n    }\\n\\n    int findRotateSteps(string ring, string key) {\\n        int n = ring.size();\\n        int m = key.size();\\n        vector dp(m + 5, vector<int>(n + 5));\\n        return rotateSteps(ring, 0, key, 0, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int, int> findLetter(const string& ring, int p, char letter, char DIR = \\'L\\'){\\n        int n = ring.size();\\n        int steps = 0;\\n        for(;ring[p] != letter; p = (p + ((DIR == \\'L\\') ? 1 : -1) + n) % n){\\n            steps++;\\n        }\\n\\n        return {p, steps};\\n    }\\n\\n    int rotateSteps(string& ring, int p, string& key, int i, vector<vector<int>>& dp){\\n        int m = key.size();\\n        if(i == m){\\n            return 0;\\n        }\\n        \\n        if(dp[i][p]){\\n            return dp[i][p];\\n        }\\n\\n        auto [leftPos, leftSteps] = findLetter(ring, p, key[i], \\'L\\');\\n        auto [rightPos, rightSteps] = findLetter(ring, p, key[i], \\'R\\');\\n        \\n        dp[i][p] = min(\\n                leftSteps + 1 + rotateSteps(ring, leftPos, key, i + 1, dp),\\n                rightSteps + 1 + rotateSteps(ring, rightPos, key, i + 1, dp)\\n            );\\n\\n        return dp[i][p];\\n    }\\n\\n    int findRotateSteps(string ring, string key) {\\n        int n = ring.size();\\n        int m = key.size();\\n        vector dp(m + 5, vector<int>(n + 5));\\n        return rotateSteps(ring, 0, key, 0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636724,
                "title": "easy-recursive-dp-solution",
                "content": "# Intuition\\nroate left or right at every step then return minimum\\n\\n# Approach\\nto make every character of string \"key\" at given index using string \"ring\" u can either rotate ring to either left or right so from here we can see that our state of dp depends on current state of string ring and index of string key. we will create a hashmap as dp where key is pair<string,int>.\\nnow in the function func we find the answer by rotating left first then by rotating right and we memoize it using hashmap and return the minimum of both\\n\\n# Complexity\\n- Time complexity:\\nO(N*M)\\n\\n- Space complexity:\\nO(N*M) for hashmap\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int func(string& ring, string& key, int y, unordered_map<string, int>& dp) {\\n        if (y == key.size())\\n            return 0;\\n        \\n        string pr = ring + to_string(y);\\n        if (dp.find(pr) != dp.end())\\n            return dp[pr];\\n        \\n        char to_find = key[y];\\n        int rotl = 0;\\n        string copy = ring;\\n        \\n        for (int i = 0; i < copy.size(); i++) {\\n            if (copy[i] == to_find) {\\n                rotl = i;\\n                break;\\n            }\\n        }\\n        \\n        rotate(copy.begin(), copy.begin() + rotl, copy.end());\\n        rotl += 1 + func(copy, key, y + 1, dp);\\n\\n        int rotr = 0;\\n        copy = ring;\\n        int n = copy.size();\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            if (copy[i] == to_find) {\\n                rotr = n - i;\\n                break;\\n            }\\n        }\\n        \\n        rotate(copy.begin(), copy.begin() + n - rotr, copy.end());\\n        rotr += 1 + func(copy, key, y + 1, dp);\\n        \\n        return dp[pr] = min(rotl, rotr);\\n    }\\n    \\n    \\n    int findRotateSteps(string ring, string key) {\\n        unordered_map<string, int> dp;\\n        return func(ring, key, 0, dp);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int func(string& ring, string& key, int y, unordered_map<string, int>& dp) {\\n        if (y == key.size())\\n            return 0;\\n        \\n        string pr = ring + to_string(y);\\n        if (dp.find(pr) != dp.end())\\n            return dp[pr];\\n        \\n        char to_find = key[y];\\n        int rotl = 0;\\n        string copy = ring;\\n        \\n        for (int i = 0; i < copy.size(); i++) {\\n            if (copy[i] == to_find) {\\n                rotl = i;\\n                break;\\n            }\\n        }\\n        \\n        rotate(copy.begin(), copy.begin() + rotl, copy.end());\\n        rotl += 1 + func(copy, key, y + 1, dp);\\n\\n        int rotr = 0;\\n        copy = ring;\\n        int n = copy.size();\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            if (copy[i] == to_find) {\\n                rotr = n - i;\\n                break;\\n            }\\n        }\\n        \\n        rotate(copy.begin(), copy.begin() + n - rotr, copy.end());\\n        rotr += 1 + func(copy, key, y + 1, dp);\\n        \\n        return dp[pr] = min(rotl, rotr);\\n    }\\n    \\n    \\n    int findRotateSteps(string ring, string key) {\\n        unordered_map<string, int> dp;\\n        return func(ring, key, 0, dp);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606597,
                "title": "dp",
                "content": "# Code\\n```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        n = len(ring)\\n        m = len(key)\\n        dp = [[float(\\'inf\\')] * n for _ in range(m + 1)]\\n\\n        # Set the base case\\n        dp[m] = [0] * n\\n\\n        # Create a dictionary to store the positions of each character in the ring\\n        positions = {}\\n        for i, c in enumerate(ring):\\n            if c not in positions:\\n                positions[c] = []\\n            positions[c].append(i)\\n\\n        for i in range(m - 1, -1, -1):\\n            for j in range(n):\\n                dp[i][j] = float(\\'inf\\')  # Initialize dp[i][j] to infinity\\n                for k in positions[key[i]]:\\n                    # Calculate the steps required to align the current character\\n                    # at index k with the \"12:00\" direction\\n                    steps = min(abs(j - k), n - abs(j - k))\\n\\n                    # Calculate the total steps required for the current character\\n                    # and take the minimum over all possible positions k\\n                    dp[i][j] = min(dp[i][j], steps + dp[i + 1][k])\\n\\n        # The minimum steps required to spell the entire key starting from index 0\\n        return dp[0][0] + m\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        n = len(ring)\\n        m = len(key)\\n        dp = [[float(\\'inf\\')] * n for _ in range(m + 1)]\\n\\n        # Set the base case\\n        dp[m] = [0] * n\\n\\n        # Create a dictionary to store the positions of each character in the ring\\n        positions = {}\\n        for i, c in enumerate(ring):\\n            if c not in positions:\\n                positions[c] = []\\n            positions[c].append(i)\\n\\n        for i in range(m - 1, -1, -1):\\n            for j in range(n):\\n                dp[i][j] = float(\\'inf\\')  # Initialize dp[i][j] to infinity\\n                for k in positions[key[i]]:\\n                    # Calculate the steps required to align the current character\\n                    # at index k with the \"12:00\" direction\\n                    steps = min(abs(j - k), n - abs(j - k))\\n\\n                    # Calculate the total steps required for the current character\\n                    # and take the minimum over all possible positions k\\n                    dp[i][j] = min(dp[i][j], steps + dp[i + 1][k])\\n\\n        # The minimum steps required to spell the entire key starting from index 0\\n        return dp[0][0] + m\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570704,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        unordered_map<char, vector<int>>letter2pos ;\\n        int n = key.size() ;\\n        int m = ring.size() ;\\n        for(int i = 0; i < m; i++)\\n            letter2pos[ring[i]].push_back(i) ;\\n        auto dp = vector<vector<int>>(n, vector<int>(m, INT_MAX/2)) ;\\n        for(int cur : letter2pos[key[0]])\\n            dp[0][cur] = min(cur, m - cur) ;\\n        for(int i = 1; i < n; i++){\\n            for(int cur : letter2pos[key[i]]){\\n                for(int prev : letter2pos[key[i-1]]){\\n                    dp[i][cur] = min(dp[i][cur], dp[i-1][prev] + min(abs(cur - prev), m - abs(cur - prev))) ;\\n                }\\n            }\\n        }\\n        int ret = INT_MAX ;\\n        for(int cur : letter2pos[key[n-1]]){\\n            ret = min(ret, dp[n-1][cur]) ;\\n        }\\n        return ret + n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        unordered_map<char, vector<int>>letter2pos ;\\n        int n = key.size() ;\\n        int m = ring.size() ;\\n        for(int i = 0; i < m; i++)\\n            letter2pos[ring[i]].push_back(i) ;\\n        auto dp = vector<vector<int>>(n, vector<int>(m, INT_MAX/2)) ;\\n        for(int cur : letter2pos[key[0]])\\n            dp[0][cur] = min(cur, m - cur) ;\\n        for(int i = 1; i < n; i++){\\n            for(int cur : letter2pos[key[i]]){\\n                for(int prev : letter2pos[key[i-1]]){\\n                    dp[i][cur] = min(dp[i][cur], dp[i-1][prev] + min(abs(cur - prev), m - abs(cur - prev))) ;\\n                }\\n            }\\n        }\\n        int ret = INT_MAX ;\\n        for(int cur : letter2pos[key[n-1]]){\\n            ret = min(ret, dp[n-1][cur]) ;\\n        }\\n        return ret + n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565367,
                "title": "c-short-and-simple-memo-approach",
                "content": "Sharing my solution, as I haven\\'t seen something similar here\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int dfs(string &ring, string &key, int i, int j, vector<vector<int>> &dp) {\\n\\n        if (j == key.size())\\n            return 0;\\n        \\n        if (dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int answer = INT_MAX;\\n\\n        for (int k = i, index = 0; index <= ring.size(); ++k, k %= ring.size(), ++index) {\\n            if (key[j] == ring[k]) {\\n                int search = dfs(ring, key, k, j+1, dp);\\n                answer = min(answer, 1 + abs(i-k) + search); // clockwise\\n                answer = min(answer, 1 + (int)ring.size() - abs(i-k) + search); // anti-clockwise\\n            }\\n        }\\n\\n        return dp[i][j] = answer;\\n    }\\n\\n    int findRotateSteps(string ring, string key) {\\n        vector<vector<int>> dp(ring.size(), vector<int>(key.size(), -1));\\n        return dfs(ring, key, 0, 0, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dfs(string &ring, string &key, int i, int j, vector<vector<int>> &dp) {\\n\\n        if (j == key.size())\\n            return 0;\\n        \\n        if (dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int answer = INT_MAX;\\n\\n        for (int k = i, index = 0; index <= ring.size(); ++k, k %= ring.size(), ++index) {\\n            if (key[j] == ring[k]) {\\n                int search = dfs(ring, key, k, j+1, dp);\\n                answer = min(answer, 1 + abs(i-k) + search); // clockwise\\n                answer = min(answer, 1 + (int)ring.size() - abs(i-k) + search); // anti-clockwise\\n            }\\n        }\\n\\n        return dp[i][j] = answer;\\n    }\\n\\n    int findRotateSteps(string ring, string key) {\\n        vector<vector<int>> dp(ring.size(), vector<int>(key.size(), -1));\\n        return dfs(ring, key, 0, 0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555932,
                "title": "rust-dp-easy-to-read",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse a two dimensional array to record the calculated results.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(M & N^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(M * N)\\n# Code\\n```\\nimpl Solution {\\n    pub fn find_rotate_steps(ring: String, key: String) -> i32 {\\n        let key = key.chars().into_iter().collect::<Vec<char>>();\\n        let ring = ring.chars().into_iter().collect::<Vec<char>>();\\n\\n        let (m, n) = (key.len(), ring.len());\\n        let mut dp = vec![vec![i32::MAX; n]; m]; \\n\\n        for j in 0 .. n { \\n            if ring[j] != key[0] { continue }\\n            dp[0][j] = j.min(n - j)  as i32 + 1; \\n        }\\n\\n        for i in 1 .. m {\\n            for j in 0 .. n {\\n                if ring[j] != key[i] { continue }\\n\\n                for k in 0 .. n {\\n                    if ring[k] != key[i - 1] { continue }\\n\\n                    let (u, v) = (j.max(k), j.min(k));\\n                    let temp = (u - v).min(v + n - u) as i32;\\n\\n                    dp[i][j] = dp[i][j].min(dp[i - 1][k] + temp + 1);\\n                }\\n            }\\n        }\\n\\n        *dp[m - 1].iter().min().unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_rotate_steps(ring: String, key: String) -> i32 {\\n        let key = key.chars().into_iter().collect::<Vec<char>>();\\n        let ring = ring.chars().into_iter().collect::<Vec<char>>();\\n\\n        let (m, n) = (key.len(), ring.len());\\n        let mut dp = vec![vec![i32::MAX; n]; m]; \\n\\n        for j in 0 .. n { \\n            if ring[j] != key[0] { continue }\\n            dp[0][j] = j.min(n - j)  as i32 + 1; \\n        }\\n\\n        for i in 1 .. m {\\n            for j in 0 .. n {\\n                if ring[j] != key[i] { continue }\\n\\n                for k in 0 .. n {\\n                    if ring[k] != key[i - 1] { continue }\\n\\n                    let (u, v) = (j.max(k), j.min(k));\\n                    let temp = (u - v).min(v + n - u) as i32;\\n\\n                    dp[i][j] = dp[i][j].min(dp[i - 1][k] + temp + 1);\\n                }\\n            }\\n        }\\n\\n        *dp[m - 1].iter().min().unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3522844,
                "title": "java",
                "content": "easy big improve by using char map to implament distCW and distCCW instead of O(n) each time.\\n\\n# Code\\n```\\nclass Solution {\\n    int n,k;\\n    public int findRotateSteps(String ring, String key) {\\n        n=ring.length();  \\n        k= key.length();\\n        int min = Integer.MAX_VALUE;\\n\\n        Set<Integer> [] charMap= new Set[26];\\n        mapChars(charMap, ring);\\n\\n        int dp[][] = new int[k][n]; // cost of path to the Kth letter in key being at Nth rotation clockwise.\\n       \\n        int distCCW = distCCW(0, charMap[key.charAt(0)-\\'a\\']);\\n        int distCW =  distCW(0, charMap[key.charAt(0)-\\'a\\']);\\n\\n        dp[0][(n+distCCW)%n] = Math.abs(distCCW) + 1;\\n        dp[0][distCW]  = (dp[0][distCW]==0) ? distCW + 1 : Math.min(distCW + 1,dp[0][distCW]);\\n        \\n        if (k==1) return Math.min (dp[0][(n+distCCW)%n],dp[0][distCW]);\\n\\n        for (int i=1;i<k;i++){\\n            char c = key.charAt(i-1) , next =  key.charAt(i);\\n\\n            for (int cPlace:charMap[c-\\'a\\']){\\n                    if (dp[i-1][cPlace]!=0){\\n\\n                    distCCW = distCCW(cPlace , charMap[next-\\'a\\']);\\n                    distCW = distCW(cPlace , charMap[next-\\'a\\']);\\n                    int CCWRotation = (n+cPlace+distCCW)%n,CWRotation = (cPlace+distCW)%n;\\n\\n                    if (dp[i][CCWRotation]==0)  dp[i][CCWRotation]=Integer.MAX_VALUE; // just for math min \\n                    if (dp[i][CWRotation]==0)  dp[i][CWRotation]=Integer.MAX_VALUE;\\n\\n                    dp[i][CCWRotation] =  Math.min(dp[i][CCWRotation], dp[i-1][cPlace] - distCCW + 1);\\n                    dp[i][CWRotation] = Math.min(dp[i][CWRotation],dp[i-1][cPlace] + distCW + 1);\\n                    if (i==k-1) min= Math.min (min, Math.min(dp[i][(n+cPlace+distCCW)%n], dp[i][(cPlace+distCW)%n]));\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n\\n    public void mapChars(Set<Integer>[] charMap,String ring){\\n       for (int i=0;i<ring.length();i++){\\n           char c = ring.charAt(i);\\n           if(charMap[c-\\'a\\']==null) charMap[c-\\'a\\'] = new HashSet<Integer>();\\n           charMap[c-\\'a\\'].add(i);\\n       }\\n    }\\n\\n// lazy O(n) implements here, could easilly X26 the efficency of the all algorithem if needed. I will leave it as is for now.\\n\\n    public int distCW(int start ,Set<Integer> charMap){\\n         for (int counter=0;true;counter++) if (charMap.contains((start+counter)%n)) return counter;\\n    }\\n\\n    public int distCCW(int start ,Set<Integer> charMap){\\n         for (int counter=0;true;counter--) if (charMap.contains((n+start+counter)%n))  return counter;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int n,k;\\n    public int findRotateSteps(String ring, String key) {\\n        n=ring.length();  \\n        k= key.length();\\n        int min = Integer.MAX_VALUE;\\n\\n        Set<Integer> [] charMap= new Set[26];\\n        mapChars(charMap, ring);\\n\\n        int dp[][] = new int[k][n]; // cost of path to the Kth letter in key being at Nth rotation clockwise.\\n       \\n        int distCCW = distCCW(0, charMap[key.charAt(0)-\\'a\\']);\\n        int distCW =  distCW(0, charMap[key.charAt(0)-\\'a\\']);\\n\\n        dp[0][(n+distCCW)%n] = Math.abs(distCCW) + 1;\\n        dp[0][distCW]  = (dp[0][distCW]==0) ? distCW + 1 : Math.min(distCW + 1,dp[0][distCW]);\\n        \\n        if (k==1) return Math.min (dp[0][(n+distCCW)%n],dp[0][distCW]);\\n\\n        for (int i=1;i<k;i++){\\n            char c = key.charAt(i-1) , next =  key.charAt(i);\\n\\n            for (int cPlace:charMap[c-\\'a\\']){\\n                    if (dp[i-1][cPlace]!=0){\\n\\n                    distCCW = distCCW(cPlace , charMap[next-\\'a\\']);\\n                    distCW = distCW(cPlace , charMap[next-\\'a\\']);\\n                    int CCWRotation = (n+cPlace+distCCW)%n,CWRotation = (cPlace+distCW)%n;\\n\\n                    if (dp[i][CCWRotation]==0)  dp[i][CCWRotation]=Integer.MAX_VALUE; // just for math min \\n                    if (dp[i][CWRotation]==0)  dp[i][CWRotation]=Integer.MAX_VALUE;\\n\\n                    dp[i][CCWRotation] =  Math.min(dp[i][CCWRotation], dp[i-1][cPlace] - distCCW + 1);\\n                    dp[i][CWRotation] = Math.min(dp[i][CWRotation],dp[i-1][cPlace] + distCW + 1);\\n                    if (i==k-1) min= Math.min (min, Math.min(dp[i][(n+cPlace+distCCW)%n], dp[i][(cPlace+distCW)%n]));\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n\\n    public void mapChars(Set<Integer>[] charMap,String ring){\\n       for (int i=0;i<ring.length();i++){\\n           char c = ring.charAt(i);\\n           if(charMap[c-\\'a\\']==null) charMap[c-\\'a\\'] = new HashSet<Integer>();\\n           charMap[c-\\'a\\'].add(i);\\n       }\\n    }\\n\\n// lazy O(n) implements here, could easilly X26 the efficency of the all algorithem if needed. I will leave it as is for now.\\n\\n    public int distCW(int start ,Set<Integer> charMap){\\n         for (int counter=0;true;counter++) if (charMap.contains((start+counter)%n)) return counter;\\n    }\\n\\n    public int distCCW(int start ,Set<Integer> charMap){\\n         for (int counter=0;true;counter--) if (charMap.contains((n+start+counter)%n))  return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518553,
                "title": "solution-using-viterbri-algorithm-simple-python",
                "content": "# Intuition\\nThis problem shares some similarities with solving hidden markov chain using the Viterbri algorithm. Essentially we can think of this problem as a series of state transitions, and at any timestep $t$, we only need to worry about the previous states at $t-1$.\\n\\nAs a quick example, say the string we want to match is \"abc\", and we have 3 different locations for \"a\", 3 different locatiosn for \"b\", and 3 different locations for \"c\". We start by caching distance from the starting locations to all possible a\\'s, resulting in a dictionary with 3 items.\\n\\nIn the next iterations, we have 3 different possible b\\'s to choose from, and doing it naively requires finding the distance from each a to each b, resulting in 3*3=9 items to save, and this grows exponentially afterwards. The key insight is that when we are computing the least-cost path from b to c, we don\\'t care which \"a\" we chose. We are starting fresh from a set of indices at every iteration, so for each $b_i$, we find the \"a\" that is the closest to it, and we forget about all the \"a\". **We don\\'t care how we reached each $b_i$, but we know for each $b_i$, there is only one possible optimal path that could reach it (assuming no 2 trajectories have the same cost)**. We then cache the indices of $b_i$\\'s with the minimum distances from start, and we repeat the process.\\n\\n\\n# Approach\\nThere are 2 parts in solving this problem. 1): Given 2 characters, greedily finds the minimum distance between them, which is easy to do. 2):From the current states, we compute how to get to each of the next possible states with the least amount of turning of the dial.  \\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        head, tail = 0, len(ring)-1\\n        mapping = defaultdict(list)\\n        for ind, val in enumerate(ring):\\n            mapping[val].append(ind)\\n    \\n        def get_distance(cur_locs,target,cache):\\n            result = float(\"inf\")\\n            for cur in cur_locs:\\n                if target > cur:\\n                    option_1 = target - cur \\n                    option_2 = cur + (tail+1)-target\\n                else:\\n                    option_1 = cur - target\\n                    option_2 = tail-cur+1+target \\n                # the distance = going from cur to target + distance travel to get to cur + spelling it\\n                dis = min(option_1,option_2) + cache[cur]+1 \\n                if result > dis:\\n                    result = dis\\n            return result\\n        \\n        cache = {0:0}\\n        for character in key:\\n            #get the targets \\n            locations = mapping[character]\\n            cur_locs = list(cache.keys())\\n            cache_2 = {}\\n            for location in locations:\\n                dis = get_distance(cur_locs,location,cache)\\n                cache_2[location] = dis\\n            cache = cache_2\\n        return sorted(list(cache.values()))[0]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        head, tail = 0, len(ring)-1\\n        mapping = defaultdict(list)\\n        for ind, val in enumerate(ring):\\n            mapping[val].append(ind)\\n    \\n        def get_distance(cur_locs,target,cache):\\n            result = float(\"inf\")\\n            for cur in cur_locs:\\n                if target > cur:\\n                    option_1 = target - cur \\n                    option_2 = cur + (tail+1)-target\\n                else:\\n                    option_1 = cur - target\\n                    option_2 = tail-cur+1+target \\n                # the distance = going from cur to target + distance travel to get to cur + spelling it\\n                dis = min(option_1,option_2) + cache[cur]+1 \\n                if result > dis:\\n                    result = dis\\n            return result\\n        \\n        cache = {0:0}\\n        for character in key:\\n            #get the targets \\n            locations = mapping[character]\\n            cur_locs = list(cache.keys())\\n            cache_2 = {}\\n            for location in locations:\\n                dis = get_distance(cur_locs,location,cache)\\n                cache_2[location] = dis\\n            cache = cache_2\\n        return sorted(list(cache.values()))[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516391,
                "title": "c-dynamic-programming-solution-with-explanation",
                "content": "When we rotate the ring to spell next letter, we just move to the nearest letter on the left or the nearest letter on the right (two choices).\\n```dp[i]```is the minimum moving step when ```ring[i]``` is at ```12:00```.\\nSpell key letter by letter, ```q``` store the ```i```s which ```ring[i]``` is at ```12:00```. all of letters(```ring[i]```) in q are the same.\\nInitially, ```ring[0]``` is at ```12:00```.\\nso we start to rotate the ring to spell next letter, find the nearest letter on the left and the nearest letter on the right, and calculate the moving step of both, store it to tmp, and record the minimum moving step of both letter.\\n\\ntc is O(max(ring.size(), key.size())), sc is O(max(ring.size(), key.size()))\\n\\n```cpp\\n\\nclass Solution {\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        vector<int> dp (ring.size(), 0);\\n        unordered_map<char, vector<int>> mapping;\\n        for (int i = 0; i <= ring.size(); i+=1) mapping[ring[i]].emplace_back(i);\\n        auto diff = [&ring] (int i, int j) {return min(abs(i-j), (int)ring.size() - abs(i-j));};\\n        unordered_set<int> q1 {0};\\n        unordered_set<int> q2;\\n        unordered_map<int, int> tmp;\\n        int s, cur, p, left, right;\\n        \\n        for (int i = 0; i < key.size(); i+=1) {\\n            // dp[.] is dp[.][i-1], tmp record dp[.][i]\\n            for (const int& cur: q1) {\\n                if (mapping[key[i]].size() == 1) { // only one letter on the ring\\n                    q2.insert(mapping[key[i]][0]);\\n                    if (tmp.count(mapping[key[i]][0]) == 0) tmp[mapping[key[i]][0]] = diff(cur, mapping[key[i]][0]) + dp[cur];\\n                    else tmp[mapping[key[i]][0]] = min(tmp[mapping[key[i]][0]],  diff(cur, mapping[key[i]][0]) + dp[cur]); \\n\\t\\t\\t\\t\\t// moving step from previous letter to current letter + minimum step to spell key[0~ i-1] (without pressing the buttom)\\n                    continue;\\n                }\\n                p = lower_bound(mapping[key[i]].begin(), mapping[key[i]].end(), cur) - mapping[key[i]].begin();\\n                if (p != mapping[key[i]].size() && mapping[key[i]][p] == cur) q2.insert(cur);\\n                else {\\n                    left = p % mapping[key[i]].size(), right = (p-1+mapping[key[i]].size()) % mapping[key[i]].size();\\n                    if (tmp.count(mapping[key[i]][left]) == 0) tmp[mapping[key[i]][left]] = diff(cur, mapping[key[i]][left]) + dp[cur];\\n                    else tmp[mapping[key[i]][left]] = min(tmp[mapping[key[i]][left]], diff(cur, mapping[key[i]][left]) + dp[cur]);\\n                    if (tmp.count(mapping[key[i]][right]) == 0) tmp[mapping[key[i]][right]] = diff(cur, mapping[key[i]][right]) + dp[cur];\\n                    else tmp[mapping[key[i]][right]] = min(tmp[mapping[key[i]][right]], diff(cur, mapping[key[i]][right]) + dp[cur]);\\n                    q2.insert(mapping[key[i]][left]);\\n                    q2.insert(mapping[key[i]][right]);\\n                }\\n            }\\n            for (auto& [m, n]: tmp) dp[m] = n; // update dp[.][i]\\n            tmp.clear();\\n            q1.clear();\\n            q1.swap(q2);\\n        }\\n        int min = INT_MAX;\\n        for (const int &i: q1) min = min < dp[i] ? min : dp[i];\\n        return min + key.size();\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```dp[i]```\n```ring[i]```\n```12:00```\n```q```\n```i```\n```ring[i]```\n```12:00```\n```ring[i]```\n```ring[0]```\n```12:00```\n```cpp\\n\\nclass Solution {\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        vector<int> dp (ring.size(), 0);\\n        unordered_map<char, vector<int>> mapping;\\n        for (int i = 0; i <= ring.size(); i+=1) mapping[ring[i]].emplace_back(i);\\n        auto diff = [&ring] (int i, int j) {return min(abs(i-j), (int)ring.size() - abs(i-j));};\\n        unordered_set<int> q1 {0};\\n        unordered_set<int> q2;\\n        unordered_map<int, int> tmp;\\n        int s, cur, p, left, right;\\n        \\n        for (int i = 0; i < key.size(); i+=1) {\\n            // dp[.] is dp[.][i-1], tmp record dp[.][i]\\n            for (const int& cur: q1) {\\n                if (mapping[key[i]].size() == 1) { // only one letter on the ring\\n                    q2.insert(mapping[key[i]][0]);\\n                    if (tmp.count(mapping[key[i]][0]) == 0) tmp[mapping[key[i]][0]] = diff(cur, mapping[key[i]][0]) + dp[cur];\\n                    else tmp[mapping[key[i]][0]] = min(tmp[mapping[key[i]][0]],  diff(cur, mapping[key[i]][0]) + dp[cur]); \\n\\t\\t\\t\\t\\t// moving step from previous letter to current letter + minimum step to spell key[0~ i-1] (without pressing the buttom)\\n                    continue;\\n                }\\n                p = lower_bound(mapping[key[i]].begin(), mapping[key[i]].end(), cur) - mapping[key[i]].begin();\\n                if (p != mapping[key[i]].size() && mapping[key[i]][p] == cur) q2.insert(cur);\\n                else {\\n                    left = p % mapping[key[i]].size(), right = (p-1+mapping[key[i]].size()) % mapping[key[i]].size();\\n                    if (tmp.count(mapping[key[i]][left]) == 0) tmp[mapping[key[i]][left]] = diff(cur, mapping[key[i]][left]) + dp[cur];\\n                    else tmp[mapping[key[i]][left]] = min(tmp[mapping[key[i]][left]], diff(cur, mapping[key[i]][left]) + dp[cur]);\\n                    if (tmp.count(mapping[key[i]][right]) == 0) tmp[mapping[key[i]][right]] = diff(cur, mapping[key[i]][right]) + dp[cur];\\n                    else tmp[mapping[key[i]][right]] = min(tmp[mapping[key[i]][right]], diff(cur, mapping[key[i]][right]) + dp[cur]);\\n                    q2.insert(mapping[key[i]][left]);\\n                    q2.insert(mapping[key[i]][right]);\\n                }\\n            }\\n            for (auto& [m, n]: tmp) dp[m] = n; // update dp[.][i]\\n            tmp.clear();\\n            q1.clear();\\n            q1.swap(q2);\\n        }\\n        int min = INT_MAX;\\n        for (const int &i: q1) min = min < dp[i] ? min : dp[i];\\n        return min + key.size();\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501296,
                "title": "top-down-using-precomputed-hashmap-of-indexes",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int findRotateSteps(String ring, String key) {\\n        Map<Character, List<Integer>> charIndexMap = new HashMap<>();\\n        int index = 0;\\n\\n        for (char ch : ring.toCharArray()) {\\n            List<Integer> list = charIndexMap.getOrDefault(ch, new ArrayList<>());\\n            list.add(index++);\\n            charIndexMap.put(ch, list);\\n        }\\n        Integer[][] memo = new Integer[ring.length()][key.length()];\\n        return recur(ring, key, charIndexMap, 0, 0, memo);\\n    }\\n\\n    private int recur(String ring, String key, \\n        Map<Character, List<Integer>> charIndexMap, int prevIndex, int keyIndex, Integer[][] memo) {\\n        \\n        if (keyIndex == key.length()) {\\n            return 0;\\n        }\\n\\n        if (memo[prevIndex][keyIndex] != null) {\\n            return memo[prevIndex][keyIndex];\\n        }\\n        char ch = key.charAt(keyIndex);\\n        List<Integer> indexes = charIndexMap.get(ch);\\n        int ans = Integer.MAX_VALUE;\\n\\n        for (int index : indexes) {\\n            int stepOneSide = Math.abs(index - prevIndex);\\n            int stepAnotherSide = ring.length() - stepOneSide;\\n            int step = 1 + Math.min(stepOneSide, stepAnotherSide);\\n            ans = Math.min(ans, step + recur(ring, key, charIndexMap, index, keyIndex + 1, memo));\\n        }\\n        return memo[prevIndex][keyIndex] = ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int findRotateSteps(String ring, String key) {\\n        Map<Character, List<Integer>> charIndexMap = new HashMap<>();\\n        int index = 0;\\n\\n        for (char ch : ring.toCharArray()) {\\n            List<Integer> list = charIndexMap.getOrDefault(ch, new ArrayList<>());\\n            list.add(index++);\\n            charIndexMap.put(ch, list);\\n        }\\n        Integer[][] memo = new Integer[ring.length()][key.length()];\\n        return recur(ring, key, charIndexMap, 0, 0, memo);\\n    }\\n\\n    private int recur(String ring, String key, \\n        Map<Character, List<Integer>> charIndexMap, int prevIndex, int keyIndex, Integer[][] memo) {\\n        \\n        if (keyIndex == key.length()) {\\n            return 0;\\n        }\\n\\n        if (memo[prevIndex][keyIndex] != null) {\\n            return memo[prevIndex][keyIndex];\\n        }\\n        char ch = key.charAt(keyIndex);\\n        List<Integer> indexes = charIndexMap.get(ch);\\n        int ans = Integer.MAX_VALUE;\\n\\n        for (int index : indexes) {\\n            int stepOneSide = Math.abs(index - prevIndex);\\n            int stepAnotherSide = ring.length() - stepOneSide;\\n            int step = 1 + Math.min(stepOneSide, stepAnotherSide);\\n            ans = Math.min(ans, step + recur(ring, key, charIndexMap, index, keyIndex + 1, memo));\\n        }\\n        return memo[prevIndex][keyIndex] = ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496327,
                "title": "simple-dp-memoization-python-3",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        ptr = 0\\n        ind = 0\\n        n = len(ring)\\n        m = len(key)\\n        return self.freedomTrail(ring,key,ptr,ind,{},n,m)\\n\\n\\n    def freedomTrail(self,ring,key,ptr,ind,dp,n,m):\\n        # BASE CASE\\n        if ind>=m:\\n            return 0\\n        if (ptr,ind) in dp:\\n            return dp[(ptr,ind)]\\n\\n        ans = 1e9\\n        for  i in range(n):\\n            if ring[i] == key[ind]:\\n                ans = min(ans , min(abs(ptr-i) , n- abs(ptr-i)) + 1 +  self.freedomTrail(ring,key,i,ind+1,dp,n,m))\\n                dp[(ptr,ind)] = ans\\n\\n        dp[(ptr,ind)] = ans\\n        return dp[(ptr,ind)]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        ptr = 0\\n        ind = 0\\n        n = len(ring)\\n        m = len(key)\\n        return self.freedomTrail(ring,key,ptr,ind,{},n,m)\\n\\n\\n    def freedomTrail(self,ring,key,ptr,ind,dp,n,m):\\n        # BASE CASE\\n        if ind>=m:\\n            return 0\\n        if (ptr,ind) in dp:\\n            return dp[(ptr,ind)]\\n\\n        ans = 1e9\\n        for  i in range(n):\\n            if ring[i] == key[ind]:\\n                ans = min(ans , min(abs(ptr-i) , n- abs(ptr-i)) + 1 +  self.freedomTrail(ring,key,i,ind+1,dp,n,m))\\n                dp[(ptr,ind)] = ans\\n\\n        dp[(ptr,ind)] = ans\\n        return dp[(ptr,ind)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437311,
                "title": "c-top-down-dp-20ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    // int dp[101][101];\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        // memset(dp,-1,sizeof(dp));\\n        int n=ring.size();\\n        int m=key.size();\\n        // cout<<n<<\" \"<<m;\\n        // queue<vector<int>> q;\\n        vector<int> arr[26];\\n        for(int i=0;i<n;i++){\\n            arr[ring[i]-\\'a\\'].push_back(i);\\n        }\\n        // q.push({0,-1,0});\\n        // int s=1;\\n        // int ans=INT_MAX;\\n        // while(q.size()){\\n        //     s=q.size();\\n        //     while(s--){\\n        //         auto ele=q.front();\\n        //         q.pop();\\n        //         int state=ele[0];\\n        //         int ind_key=ele[1];\\n        //         int steps=ele[2];\\n        //         if(ind_key==m-1){\\n        //             ans=min(ans,steps+m);\\n        //             continue;\\n        //         }\\n        //         if(ind_key!=-1 && dp[state][ind_key]!=-1 && dp[state][ind_key]<steps) continue;\\n        //         char c=key[ind_key+1];\\n        //         for(int& i: arr[c-\\'a\\']){\\n        //             int x=min(abs(i-state),abs(min(state,i)+n-max(state,i)));\\n        //             if(dp[i][ind_key+1]!=-1 && dp[i][ind_key+1]<steps+x) continue;\\n        //             dp[i][ind_key+1]=steps+x;\\n        //             q.push({i,ind_key+1,steps+x});\\n        //         }\\n        //     }\\n        // }\\n        // return ans;\\n        vector<int> dp(n,0);\\n        for(int i=m-2;i>=0;i--){\\n            vector<int> vec;\\n            for(int& ind: arr[key[i]-\\'a\\']){\\n                int res=INT_MAX;\\n                for(int& j: arr[key[i+1]-\\'a\\']){\\n                    res=min(res,min(abs(j-ind),abs(min(j,ind)+n-max(j,ind)))+ dp[j]);\\n                }\\n                vec.push_back(res);\\n            }\\n            int k=0;\\n            for(int& ind: arr[key[i]-\\'a\\']){\\n                dp[ind]=vec[k++];\\n            }\\n        }\\n        int ans=INT_MAX;\\n        for(int& ind: arr[key[0]-\\'a\\']){\\n            ans=min(ans,min(abs(ind-0),abs(n-ind))+ dp[ind]);\\n        }\\n        return ans+m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    // int dp[101][101];\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        // memset(dp,-1,sizeof(dp));\\n        int n=ring.size();\\n        int m=key.size();\\n        // cout<<n<<\" \"<<m;\\n        // queue<vector<int>> q;\\n        vector<int> arr[26];\\n        for(int i=0;i<n;i++){\\n            arr[ring[i]-\\'a\\'].push_back(i);\\n        }\\n        // q.push({0,-1,0});\\n        // int s=1;\\n        // int ans=INT_MAX;\\n        // while(q.size()){\\n        //     s=q.size();\\n        //     while(s--){\\n        //         auto ele=q.front();\\n        //         q.pop();\\n        //         int state=ele[0];\\n        //         int ind_key=ele[1];\\n        //         int steps=ele[2];\\n        //         if(ind_key==m-1){\\n        //             ans=min(ans,steps+m);\\n        //             continue;\\n        //         }\\n        //         if(ind_key!=-1 && dp[state][ind_key]!=-1 && dp[state][ind_key]<steps) continue;\\n        //         char c=key[ind_key+1];\\n        //         for(int& i: arr[c-\\'a\\']){\\n        //             int x=min(abs(i-state),abs(min(state,i)+n-max(state,i)));\\n        //             if(dp[i][ind_key+1]!=-1 && dp[i][ind_key+1]<steps+x) continue;\\n        //             dp[i][ind_key+1]=steps+x;\\n        //             q.push({i,ind_key+1,steps+x});\\n        //         }\\n        //     }\\n        // }\\n        // return ans;\\n        vector<int> dp(n,0);\\n        for(int i=m-2;i>=0;i--){\\n            vector<int> vec;\\n            for(int& ind: arr[key[i]-\\'a\\']){\\n                int res=INT_MAX;\\n                for(int& j: arr[key[i+1]-\\'a\\']){\\n                    res=min(res,min(abs(j-ind),abs(min(j,ind)+n-max(j,ind)))+ dp[j]);\\n                }\\n                vec.push_back(res);\\n            }\\n            int k=0;\\n            for(int& ind: arr[key[i]-\\'a\\']){\\n                dp[ind]=vec[k++];\\n            }\\n        }\\n        int ans=INT_MAX;\\n        for(int& ind: arr[key[0]-\\'a\\']){\\n            ans=min(ans,min(abs(ind-0),abs(n-ind))+ dp[ind]);\\n        }\\n        return ans+m;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3418105,
                "title": "c-top-down-dp-clean-and-concise",
                "content": "# Intuition\\nmatch every key character with every dial character, if matched -> recurse by starting from last matched index.\\nUse DP to obtain minimum result\\n\\n# Approach\\ntraverse whole ring for every character in key and calculate minimum rotaion-shifts -> recurse\\n\\n# Complexity\\n- Time complexity:\\nO(M*N)\\n\\n- Space complexity:\\nO(M*N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int memo[101][101];\\n\\n    int fun(string& key, int i, string& dial, int top) { //top is index of ring at top currently\\n        if(memo[i][top] != -1) return memo[i][top];\\n        \\n        int ans=1e9;\\n\\n        if(i==key.size()){\\n            ans=0;\\n        }\\n        else {\\n            for(int target=0;target<dial.size();target++) {\\n                if(key[i]==dial[target]) {\\n                    int min_shifts = min(abs(top-target), (int)dial.size()-abs(top-target));\\n                    ans=min(ans,min_shifts+1+fun(key,i+1,dial,target));\\n                }\\n            }\\n        }\\n        \\n        memo[i][top]=ans;\\n        return ans;\\n    }\\n\\n    int findRotateSteps(string ring, string key) {\\n        memset(memo,-1,sizeof(memo));\\n        return fun(key,0,ring,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int memo[101][101];\\n\\n    int fun(string& key, int i, string& dial, int top) { //top is index of ring at top currently\\n        if(memo[i][top] != -1) return memo[i][top];\\n        \\n        int ans=1e9;\\n\\n        if(i==key.size()){\\n            ans=0;\\n        }\\n        else {\\n            for(int target=0;target<dial.size();target++) {\\n                if(key[i]==dial[target]) {\\n                    int min_shifts = min(abs(top-target), (int)dial.size()-abs(top-target));\\n                    ans=min(ans,min_shifts+1+fun(key,i+1,dial,target));\\n                }\\n            }\\n        }\\n        \\n        memo[i][top]=ans;\\n        return ans;\\n    }\\n\\n    int findRotateSteps(string ring, string key) {\\n        memset(memo,-1,sizeof(memo));\\n        return fun(key,0,ring,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401255,
                "title": "solution-using-bfs-traversal",
                "content": "# Intuition\\nFirst intuition when I saw the problem was that it can be solved via 2D DP. After giving it more thought I realised that it just a graph were we can move to either the left side **(x-1)** of the ring array or to the right side **(x+1)** from our current position x. I decided to use simple BFS algorithm to arrive with the solution.\\n\\n# Approach\\nWe can use BFS approach here, however, the complexity stems from the fact that state of our current BFS not only depends upon where we are placed in **ring** string but also our current position of the **key** string. Thus, I created a 2D array **dis** to maintain distance such that **dis[x][idx]** represents min distance to reach **xth** position on **ring** string given that we have already matched chars from *0...idx-1* of **key** string.\\n\\nHere the trick is to also consider current index if it matches the character at **idx** position of **key** string.\\n\\n# Complexity\\n- Time complexity:\\nO(m*n) where m is the size of **ring** and n the size of **key**, as we are going to traverse each element in the 2D array only twice.\\n\\n- Space complexity:\\nSame as the time complexity.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        int m = ring.size(), n = key.size(), ans = INT_MAX;\\n        vector<vector<int>> dis(m, vector<int> (n, INT_MAX));\\n\\n        queue<pair<int,pair<int,int>>> q;\\n        q.push({0,{(ring[0] == key[0]),0}});\\n        dis[0][0] = (ring[0] == key[0]);\\n\\n        while(!q.empty()) {\\n            int x = q.front().first, d = q.front().second.first, idx = q.front().second.second;\\n            q.pop();\\n            if(ring[x] == key[idx]) idx++;\\n            if(idx == n) {\\n                ans = min(ans, d);\\n                continue;\\n            }\\n\\n            int l = (x-1+m)%m, r = (x+1)%m;\\n            int v1 = d+1+(ring[l] == key[idx]), v2 = d+1+(ring[r] == key[idx]);\\n\\n            if(v1 < dis[l][idx]) {\\n                dis[l][idx] = v1;\\n                q.push({l, {v1, idx}});\\n            }\\n            if(v2 < dis[r][idx]) {\\n                dis[r][idx] = v2;\\n                q.push({r, {v2, idx}});\\n            }\\n            if(ring[x] == key[idx]) {\\n                dis[x][idx] = d+1;\\n                q.push({x, {d+1, idx}});\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        int m = ring.size(), n = key.size(), ans = INT_MAX;\\n        vector<vector<int>> dis(m, vector<int> (n, INT_MAX));\\n\\n        queue<pair<int,pair<int,int>>> q;\\n        q.push({0,{(ring[0] == key[0]),0}});\\n        dis[0][0] = (ring[0] == key[0]);\\n\\n        while(!q.empty()) {\\n            int x = q.front().first, d = q.front().second.first, idx = q.front().second.second;\\n            q.pop();\\n            if(ring[x] == key[idx]) idx++;\\n            if(idx == n) {\\n                ans = min(ans, d);\\n                continue;\\n            }\\n\\n            int l = (x-1+m)%m, r = (x+1)%m;\\n            int v1 = d+1+(ring[l] == key[idx]), v2 = d+1+(ring[r] == key[idx]);\\n\\n            if(v1 < dis[l][idx]) {\\n                dis[l][idx] = v1;\\n                q.push({l, {v1, idx}});\\n            }\\n            if(v2 < dis[r][idx]) {\\n                dis[r][idx] = v2;\\n                q.push({r, {v2, idx}});\\n            }\\n            if(ring[x] == key[idx]) {\\n                dis[x][idx] = d+1;\\n                q.push({x, {d+1, idx}});\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397877,
                "title": "python-dp",
                "content": "```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        \\n        hashmap = defaultdict(list)\\n        \\n        for i,c in enumerate(ring):\\n            hashmap[c].append(i)\\n            \\n        n,m = len(ring),len(key)\\n        \\n        @cache\\n        def dp(i=0, j=0):\\n            if i == m: return 0\\n            ans = inf\\n            for nxt in hashmap[key[i]]:    # dont rotate - rotate clock wise - rotate anti clock wise\\n                ans = min(ans, dp(i+1, nxt) + min(abs(nxt-j), abs(n+j-nxt), abs(n-j+nxt)) + 1)\\n            return ans\\n        \\n        return dp()\\n                \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        \\n        hashmap = defaultdict(list)\\n        \\n        for i,c in enumerate(ring):\\n            hashmap[c].append(i)\\n            \\n        n,m = len(ring),len(key)\\n        \\n        @cache\\n        def dp(i=0, j=0):\\n            if i == m: return 0\\n            ans = inf\\n            for nxt in hashmap[key[i]]:    # dont rotate - rotate clock wise - rotate anti clock wise\\n                ans = min(ans, dp(i+1, nxt) + min(abs(nxt-j), abs(n+j-nxt), abs(n-j+nxt)) + 1)\\n            return ans\\n        \\n        return dp()\\n                \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392106,
                "title": "simple-python-solution-74ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we are at the right position, we just press it.\\nIf not, we just have to check leftmost and rightmost buttom to the current position.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst record down the character at every index, then do what was said in intuition, i is the current position in ring, j is the jth key we are currently dealing with.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSince we are checking left and right at every string in key, I think it is $$O(2**M)$$ where M is the length of the key.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nI think it is $$O(MN)$$ but I am not sure.\\n# Code\\n```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        N = len(ring)\\n        M = len(key)\\n        g = collections.defaultdict(list)\\n        for i, c in enumerate(ring):\\n            g[c].append(i)\\n        \\n        @lru_cache(None)\\n        def find(i=0, j=0):\\n            if j == M: return 0\\n            target = key[j]\\n            if ring[i] == key[j]:\\n                return 1 + find(i, j+1)\\n            if i < g[target][0]:\\n                right = g[target][0]\\n                left = g[target][-1]\\n                return 1 + min(find(right, j+1) + right - i, find(left, j+1) + N - left + i)\\n            elif i > g[target][-1]:\\n                left = g[target][-1]\\n                right = g[target][0]\\n                return 1 + min(find(left, j+1) + i - left, find(right, j+1) + N - i + right)\\n            else:\\n                idx = bisect.bisect(g[target], i)\\n                left, right = g[target][idx-1], g[target][idx]\\n                return 1 + min(find(left, j+1) + i - left, find(right, j+1) + right - i)\\n        return find()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        N = len(ring)\\n        M = len(key)\\n        g = collections.defaultdict(list)\\n        for i, c in enumerate(ring):\\n            g[c].append(i)\\n        \\n        @lru_cache(None)\\n        def find(i=0, j=0):\\n            if j == M: return 0\\n            target = key[j]\\n            if ring[i] == key[j]:\\n                return 1 + find(i, j+1)\\n            if i < g[target][0]:\\n                right = g[target][0]\\n                left = g[target][-1]\\n                return 1 + min(find(right, j+1) + right - i, find(left, j+1) + N - left + i)\\n            elif i > g[target][-1]:\\n                left = g[target][-1]\\n                right = g[target][0]\\n                return 1 + min(find(left, j+1) + i - left, find(right, j+1) + N - i + right)\\n            else:\\n                idx = bisect.bisect(g[target], i)\\n                left, right = g[target][idx-1], g[target][idx]\\n                return 1 + min(find(left, j+1) + i - left, find(right, j+1) + right - i)\\n        return find()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370374,
                "title": "pre-processing-top-down-dynamic-programming-with-memoization",
                "content": "# Intuition\\n\\nThis is a common Dynamic Programming problem. In short words you are a current position and you have multiple places where you can go, and you must choose which one is the best next option.\\n\\nWe enhance the performance by pre-processing this places so we dont need to search for them every time.\\n\\nThe code has a Math.min invokation to identify if the best way to arrive to that position is through the inner path or though the circular case\\n\\n# Approach\\n- Pre-processing\\n- Dynamic Programming\\n\\n# Complexity\\n- Time complexity:\\n$$O(ring.length()^2*key.length())$$ <-- we to process at most `ring.length()*key.length()` nodes thanks to memoization, and we have a for loop of at most `ring.length()` at each.\\n\\n- Space complexity:\\n$$O(ring.length()*key.length())$$\\n\\n# Code\\n![image.png](https://assets.leetcode.com/users/images/63a00c5b-e6a0-415f-91e0-a6bb69596d84_1680433041.5864263.png)\\n\\n```java\\nclass Solution {\\n    public int findRotateSteps(String ring, String key) {\\n        char[] r=ring.toCharArray();\\n        // Pre-processing\\n        List<Integer>[] p=new List[26];\\n        for(int i=0;i<r.length;i++) {\\n            int c=r[i]-\\'a\\';\\n            List<Integer> l=p[c];\\n            if(l==null) p[c]=l=new ArrayList<>();\\n            l.add(i);\\n        }\\n        // DFS / Top Down Dynamic Programming with memoization\\n        return helper(0,0,p,key.toCharArray(),ring,new int[key.length()][r.length]);\\n    }\\n    int helper(int in, int pos, List<Integer>[] p, char[] k, String r, int[][] memo) {\\n        if(in==k.length) return 0;\\n        // Memoization to avoid repeated work\\n        if(memo[in][pos]>0) return memo[in][pos]-1;\\n        int min=Integer.MAX_VALUE;\\n        for(int i: p[k[in]-\\'a\\']) {\\n            int m;\\n            // We have this logic to treat the circular case\\n            if(i>=pos) m=Math.min(i-pos,pos+r.length()-i);\\n            else m=Math.min(pos-i,i+r.length()-pos);\\n            // recursion\\n            min=Math.min(min,m+helper(in+1,i,p,k,r,memo));\\n        }\\n        // I always store the result+1, this way I can\\n        // differentiate results zero and not processed\\n        return (memo[in][pos]=min+2)-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\nclass Solution {\\n    public int findRotateSteps(String ring, String key) {\\n        char[] r=ring.toCharArray();\\n        // Pre-processing\\n        List<Integer>[] p=new List[26];\\n        for(int i=0;i<r.length;i++) {\\n            int c=r[i]-\\'a\\';\\n            List<Integer> l=p[c];\\n            if(l==null) p[c]=l=new ArrayList<>();\\n            l.add(i);\\n        }\\n        // DFS / Top Down Dynamic Programming with memoization\\n        return helper(0,0,p,key.toCharArray(),ring,new int[key.length()][r.length]);\\n    }\\n    int helper(int in, int pos, List<Integer>[] p, char[] k, String r, int[][] memo) {\\n        if(in==k.length) return 0;\\n        // Memoization to avoid repeated work\\n        if(memo[in][pos]>0) return memo[in][pos]-1;\\n        int min=Integer.MAX_VALUE;\\n        for(int i: p[k[in]-\\'a\\']) {\\n            int m;\\n            // We have this logic to treat the circular case\\n            if(i>=pos) m=Math.min(i-pos,pos+r.length()-i);\\n            else m=Math.min(pos-i,i+r.length()-pos);\\n            // recursion\\n            min=Math.min(min,m+helper(in+1,i,p,k,r,memo));\\n        }\\n        // I always store the result+1, this way I can\\n        // differentiate results zero and not processed\\n        return (memo[in][pos]=min+2)-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326799,
                "title": "sfsfdsf",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport math\\nfrom collections import defaultdict\\n\\nmemo = {}\\n\\ndef f(lookup, ring, ring_start, key):\\n    ring_start = ring_start % len(ring)\\n    global memo\\n\\n    if len(key) == 0: return 0\\n\\n    memo_key = (ring_start, key,)\\n\\n    if memo_key in memo:\\n        return memo[memo_key]\\n\\n    half_ring = math.ceil(len(ring))\\n    l_result = None\\n    r_result = None\\n\\n    ring_positions = lookup[key[0]]\\n    left_matches = [p for p in ring_positions if p<=ring_start]\\n    right_matches = [p for p in ring_positions if p>=ring_start]\\n\\n    nearest_l_match = left_matches[-1]\\n    nearest_r_match = right_matches[0]\\n\\n    l_result = abs(nearest_l_match-ring_start) + 1 + f(lookup, ring, nearest_l_match, key[1:])\\n    r_result = abs(nearest_r_match-ring_start) + 1 + f(lookup, ring, nearest_r_match, key[1:])\\n\\n    result = min([l_result, r_result,])\\n\\n    memo[memo_key] = result\\n\\n    return result\\n\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        global memo\\n        memo = {}\\n        lookup = defaultdict(list)\\n\\n        for idx, l in enumerate(ring):\\n            lookup[l].append(idx)\\n\\n            # the next two lines simplify the recursion logic\\n            lookup[l].append(idx - len(ring))\\n            lookup[l].append(idx + len(ring))\\n\\n        for l in lookup:\\n            lookup[l] = sorted(lookup[l])\\n\\n        print(lookup)\\n\\n        return f(lookup, ring, 0, key)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math\\nfrom collections import defaultdict\\n\\nmemo = {}\\n\\ndef f(lookup, ring, ring_start, key):\\n    ring_start = ring_start % len(ring)\\n    global memo\\n\\n    if len(key) == 0: return 0\\n\\n    memo_key = (ring_start, key,)\\n\\n    if memo_key in memo:\\n        return memo[memo_key]\\n\\n    half_ring = math.ceil(len(ring))\\n    l_result = None\\n    r_result = None\\n\\n    ring_positions = lookup[key[0]]\\n    left_matches = [p for p in ring_positions if p<=ring_start]\\n    right_matches = [p for p in ring_positions if p>=ring_start]\\n\\n    nearest_l_match = left_matches[-1]\\n    nearest_r_match = right_matches[0]\\n\\n    l_result = abs(nearest_l_match-ring_start) + 1 + f(lookup, ring, nearest_l_match, key[1:])\\n    r_result = abs(nearest_r_match-ring_start) + 1 + f(lookup, ring, nearest_r_match, key[1:])\\n\\n    result = min([l_result, r_result,])\\n\\n    memo[memo_key] = result\\n\\n    return result\\n\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        global memo\\n        memo = {}\\n        lookup = defaultdict(list)\\n\\n        for idx, l in enumerate(ring):\\n            lookup[l].append(idx)\\n\\n            # the next two lines simplify the recursion logic\\n            lookup[l].append(idx - len(ring))\\n            lookup[l].append(idx + len(ring))\\n\\n        for l in lookup:\\n            lookup[l] = sorted(lookup[l])\\n\\n        print(lookup)\\n\\n        return f(lookup, ring, 0, key)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326741,
                "title": "dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n * m)\\n    (where n: ring.length; m: key.length)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} ring\\n * @param {string} key\\n * @return {number}\\n */\\nvar findRotateSteps = function(ring, key) {\\n    let left_index = (i) => (i == 0) ? (ring.length - 1) : (i - 1);\\n    let right_index = (i) => (i == ring.length - 1) ? 0 : (i + 1);\\n\\n    let dp = ring.split(\\'\\').map(() => 0);\\n\\n    for (let i = key.length - 1; i >= 0; i--) {\\n        let dp_new = ring.split(\\'\\').map((x, j) => (x == key[i]) ? dp[j] : Infinity);\\n\\n        for (let j = 0; j < ring.length * 2; j++) {\\n            let x = j % ring.length;\\n            dp_new[x] = Math.min(dp_new[x], dp_new[left_index(x)] + 1);\\n            let y = ((ring.length * 2) - 1 - j) % ring.length;\\n            dp_new[y] = Math.min(dp_new[y], dp_new[right_index(y)] + 1);\\n        }\\n\\n        dp = dp_new;\\n    }\\n\\n    return dp[0] + key.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} ring\\n * @param {string} key\\n * @return {number}\\n */\\nvar findRotateSteps = function(ring, key) {\\n    let left_index = (i) => (i == 0) ? (ring.length - 1) : (i - 1);\\n    let right_index = (i) => (i == ring.length - 1) ? 0 : (i + 1);\\n\\n    let dp = ring.split(\\'\\').map(() => 0);\\n\\n    for (let i = key.length - 1; i >= 0; i--) {\\n        let dp_new = ring.split(\\'\\').map((x, j) => (x == key[i]) ? dp[j] : Infinity);\\n\\n        for (let j = 0; j < ring.length * 2; j++) {\\n            let x = j % ring.length;\\n            dp_new[x] = Math.min(dp_new[x], dp_new[left_index(x)] + 1);\\n            let y = ((ring.length * 2) - 1 - j) % ring.length;\\n            dp_new[y] = Math.min(dp_new[y], dp_new[right_index(y)] + 1);\\n        }\\n\\n        dp = dp_new;\\n    }\\n\\n    return dp[0] + key.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3297453,
                "title": "128-ms",
                "content": "```ruby\\ndef find_rotate_steps r, t\\n    return t.size if (r = r.bytes).uniq.size < 2\\n    s, z, r = {0 => 0}, r.size, r.each_index.group_by { r[_1] }\\n    t.bytes.each do\\n        e, cj = Hash.new(1e5), r[_1]\\n        s.each do | i, v |\\n            v += 1\\n            for j in cj\\n                d = (i - j).abs\\n                e[j] = [e[j], v + [d, z - d].min].min\\n            end\\n        end\\n        s = e\\n    end\\n    s.each_value.min\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef find_rotate_steps r, t\\n    return t.size if (r = r.bytes).uniq.size < 2\\n    s, z, r = {0 => 0}, r.size, r.each_index.group_by { r[_1] }\\n    t.bytes.each do\\n        e, cj = Hash.new(1e5), r[_1]\\n        s.each do | i, v |\\n            v += 1\\n            for j in cj\\n                d = (i - j).abs\\n                e[j] = [e[j], v + [d, z - d].min].min\\n            end\\n        end\\n        s = e\\n    end\\n    s.each_value.min\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3217416,
                "title": "c-dijkstra-s-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef array<int, 3> ai;\\n    int findRotateSteps(string ring, string key) {\\n        map<char, vector<int>> m;\\n        for(int i = 0; i < ring.size(); i++) m[ring[i]].push_back(i);\\n        int dist[102][102] = {};\\n        for(auto & i : dist) for(auto & j : i) j = INT_MAX;\\n        priority_queue<ai, vector<ai>, greater<ai>> q; // distance, pos, index\\n        for(auto i : m[key[0]]) q.push({1+min(i, (int)ring.length()-i), i, 0});\\n        while(!q.empty()){\\n            auto [d, t, i] = q.top();\\n            q.pop();\\n            if(i == key.size()-1) return d;\\n            for(auto j : m[key[i+1]]){\\n                int steps = 1+min({abs(t-j), t+(int)ring.length()-j, (int)ring.length()-t+j});\\n                if(d+steps<dist[i+1][j]){\\n                    dist[i+1][j] = d+steps;\\n                    q.push({d+steps, j, i+1});\\n                }\\n            }\\n        }\\n        return -1; \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    typedef array<int, 3> ai;\\n    int findRotateSteps(string ring, string key) {\\n        map<char, vector<int>> m;\\n        for(int i = 0; i < ring.size(); i++) m[ring[i]].push_back(i);\\n        int dist[102][102] = {}",
                "codeTag": "Java"
            },
            {
                "id": 3213894,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findRotateSteps(self, ring, key):\\n        n = len(ring)\\n\\n        @lru_cache(None)\\n        def dfs(i,j):\\n            if j >= len(key):\\n                return 0\\n\\n            min_val = float(\"inf\")\\n\\n            for k in range(n):\\n                if ring[k] == key[j]:\\n                    min_val = min(min_val,min(abs(k-i),n-abs(k-i))+1+dfs(k,j+1))\\n\\n            return min_val\\n\\n        return dfs(0,0)\\n\\n\\n\\n\\n            \\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findRotateSteps(self, ring, key):\\n        n = len(ring)\\n\\n        @lru_cache(None)\\n        def dfs(i,j):\\n            if j >= len(key):\\n                return 0\\n\\n            min_val = float(\"inf\")\\n\\n            for k in range(n):\\n                if ring[k] == key[j]:\\n                    min_val = min(min_val,min(abs(k-i),n-abs(k-i))+1+dfs(k,j+1))\\n\\n            return min_val\\n\\n        return dfs(0,0)\\n\\n\\n\\n\\n            \\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163051,
                "title": "rust-java-6-ms-dp-from-lee215",
                "content": "\\n```\\nuse std::cmp::min;\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn find_rotate_steps(ring: String, key: String) -> i32 {\\n\\t\\tlet position = ring.as_bytes().iter().enumerate().fold(vec![vec![]; 26], |mut acc, (i, c)| {  \\n\\t\\t    acc[(c - b\\'a\\') as usize].push(i);  \\n\\t\\t    acc  \\n\\t\\t});\\n        fn distance(i: usize, j: usize, ring: &str) -> usize {\\n            let abs = (i as i32 - j as i32).abs() as usize;\\n            let len = ring.len();\\n            min(abs, len - abs)\\n        }\\n        // divide key into chars\\n        let state = key.chars().into_iter().fold(HashMap::from([(0, 0)]), |mut curr, c| {\\n            // every possible target position\\n            position[(c as u8 - b\\'a\\') as usize].iter().fold(HashMap::new(), |mut next, &target| {\\n                let count = next.entry(target).or_insert(usize::MAX);\\n                // every possible start position\\n                for (&start, dis) in &curr {\\n                    *count = min(*count, dis + distance(target, start, &ring));\\n                }\\n                next\\n            })\\n        });\\n        (state.values().min().unwrap() + key.len()) as i32\\n    }\\n}\\n```\\njava\\n\\n```java\\nclass Solution {\\n    public int findRotateSteps(String ring, String key) {\\n        HashMap<Character, ArrayList<Integer>> position = new HashMap<>();\\n        for (int i = 0; i < ring.length(); i++) {\\n            char c = ring.charAt(i);\\n            position.putIfAbsent(c, new ArrayList<>());\\n            position.get(c).add(i);\\n        }\\n        HashMap<Integer, Integer> state = new HashMap<>();\\n        state.put(0, 0);\\n        for (char c : key.toCharArray()) {\\n            HashMap<Integer, Integer> newState = new HashMap<>();\\n            for (Integer target : position.get(c)) {\\n                for (Integer start : state.keySet()) {\\n                    int curr = newState.getOrDefault(target, Integer.MAX_VALUE);\\n                    int abs = Math.abs(target - start);\\n                    int distance = Math.min(abs, ring.length() - abs);\\n                    newState.put(target, Math.min(curr, state.get(start) + distance));\\n                }\\n            }\\n            state = newState;\\n        }\\n        return Collections.min(state.values()) + key.length();\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Rust",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nuse std::cmp::min;\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn find_rotate_steps(ring: String, key: String) -> i32 {\\n\\t\\tlet position = ring.as_bytes().iter().enumerate().fold(vec![vec![]; 26], |mut acc, (i, c)| {  \\n\\t\\t    acc[(c - b\\'a\\') as usize].push(i);  \\n\\t\\t    acc  \\n\\t\\t});\\n        fn distance(i: usize, j: usize, ring: &str) -> usize {\\n            let abs = (i as i32 - j as i32).abs() as usize;\\n            let len = ring.len();\\n            min(abs, len - abs)\\n        }\\n        // divide key into chars\\n        let state = key.chars().into_iter().fold(HashMap::from([(0, 0)]), |mut curr, c| {\\n            // every possible target position\\n            position[(c as u8 - b\\'a\\') as usize].iter().fold(HashMap::new(), |mut next, &target| {\\n                let count = next.entry(target).or_insert(usize::MAX);\\n                // every possible start position\\n                for (&start, dis) in &curr {\\n                    *count = min(*count, dis + distance(target, start, &ring));\\n                }\\n                next\\n            })\\n        });\\n        (state.values().min().unwrap() + key.len()) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3121632,
                "title": "antarnab-java-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int findRotateSteps(String ring, String key) {\\n        int n = ring.length();\\n        int m = key.length();\\n        int[][] dp = new int[m + 1][n];\\n        \\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j] = Integer.MAX_VALUE;\\n                for (int k = 0; k < n; k++) {\\n                    if (ring.charAt(k) == key.charAt(i)) {\\n                        int diff = Math.abs(j - k);\\n                        int step = Math.min(diff, n - diff);\\n                        dp[i][j] = Math.min(dp[i][j], step + dp[i + 1][k]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0] + m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public int findRotateSteps(String ring, String key) {\\n        int n = ring.length();\\n        int m = key.length();\\n        int[][] dp = new int[m + 1][n];\\n        \\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j] = Integer.MAX_VALUE;\\n                for (int k = 0; k < n; k++) {\\n                    if (ring.charAt(k) == key.charAt(i)) {\\n                        int diff = Math.abs(j - k);\\n                        int step = Math.min(diff, n - diff);\\n                        dp[i][j] = Math.min(dp[i][j], step + dp[i + 1][k]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0] + m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073361,
                "title": "python3-dp",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        char_pos = defaultdict(set)\\n        for i, c in enumerate(ring):\\n            char_pos[c].add(i)\\n        \\n        # decide next step\\n        def minStep(fromm, to):\\n            if fromm == to:\\n                return 0\\n            minSteps = abs(fromm - to)\\n            minSteps = min(minSteps, abs(len(ring) - minSteps))\\n            return minSteps\\n\\n        # initialization\\n        n = len(key)\\n        dp = [0] * len(ring)\\n        for p in char_pos[key[0]]:\\n            dp[p] = minStep(0, p)\\n        prev_char = key[0]\\n        # get relationship between current node to next node\\n        for c in key[1:]:\\n            if prev_char == c:\\n                continue\\n            for next_pos in char_pos[c]:\\n                dp[next_pos] = min(dp[prev_pos] + minStep(prev_pos, next_pos) for prev_pos in char_pos[prev_char])\\n            prev_char = c\\n        return min(dp[p] for p in char_pos[prev_char]) + len(key)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        char_pos = defaultdict(set)\\n        for i, c in enumerate(ring):\\n            char_pos[c].add(i)\\n        \\n        # decide next step\\n        def minStep(fromm, to):\\n            if fromm == to:\\n                return 0\\n            minSteps = abs(fromm - to)\\n            minSteps = min(minSteps, abs(len(ring) - minSteps))\\n            return minSteps\\n\\n        # initialization\\n        n = len(key)\\n        dp = [0] * len(ring)\\n        for p in char_pos[key[0]]:\\n            dp[p] = minStep(0, p)\\n        prev_char = key[0]\\n        # get relationship between current node to next node\\n        for c in key[1:]:\\n            if prev_char == c:\\n                continue\\n            for next_pos in char_pos[c]:\\n                dp[next_pos] = min(dp[prev_pos] + minStep(prev_pos, next_pos) for prev_pos in char_pos[prev_char])\\n            prev_char = c\\n        return min(dp[p] for p in char_pos[prev_char]) + len(key)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070972,
                "title": "java-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    // \\u5B57\\u7B26 -> \\u7D22\\u5F15\\u5217\\u8868\\n    Map<Character, List<Integer>> charToIndex = new HashMap();\\n    // \\u5907\\u5FD8\\u5F55\\n    int[][] memo;\\n\\n    public int findRotateSteps(String ring, String key) {\\n\\n        int m = ring.length(), n = key.length();\\n        // \\u5907\\u5FD8\\u5F55\\u5168\\u90E8\\u521D\\u59CB\\u5316\\u4E3A 0\\n        memo = new int[m][n];\\n        // \\u8BB0\\u5F55\\u5706\\u73AF\\u4E0A\\u5B57\\u7B26\\u5230\\u7D22\\u5F15\\u7684\\u6620\\u5C04\\n        for(int i = 0; i < m; i++) {\\n            char ch = ring.charAt(i);\\n            charToIndex.putIfAbsent(ch, new ArrayList<>());\\n            charToIndex.get(ch).add(i);\\n        }\\n        // \\u5706\\u76D8\\u6307\\u9488\\u6700\\u521D\\u6307\\u5411 12 \\u70B9\\u949F\\u65B9\\u5411\\uFF0C\\n        // \\u4ECE\\u7B2C\\u4E00\\u4E2A\\u5B57\\u7B26\\u5F00\\u59CB\\u8F93\\u5165 key\\n        return dp(ring, 0, key, 0);\\n    }\\n\\n    private int dp(String ring, int i, String key, int j) {\\n        // base case \\u5B8C\\u6210\\u8F93\\u5165\\n        if(j == key.length()) return 0;\\n        // \\u67E5\\u627E\\u5907\\u5FD8\\u5F55\\uFF0C\\u907F\\u514D\\u91CD\\u53E0\\u5B50\\u95EE\\u9898\\n        if(memo[i][j] != 0) return memo[i][j];\\n\\n        int n = ring.length();\\n        // \\u505A\\u9009\\u62E9\\n        int res = Integer.MAX_VALUE;\\n        // ring \\u4E0A\\u53EF\\u80FD\\u6709\\u591A\\u4E2A\\u5B57\\u7B26 key[j]\\n        for(int k : charToIndex.get(key.charAt(j))) {\\n            // \\u62E8\\u52A8\\u6307\\u9488\\u7684\\u6B21\\u6570\\n            int move = Math.abs(i - k);\\n            // \\u9009\\u62E9\\u987A\\u65F6\\u9488\\u8FD8\\u662F\\u9006\\u65F6\\u9488\\n            move = Math.min(move, n - move);\\n            // \\u5C06\\u6307\\u9488\\u62E8\\u5230 ring[k]\\uFF0C\\u7EE7\\u7EED\\u8F93\\u5165 key[j+1..]\\n            int subproblem = dp(ring, k, key, j+1);\\n            // \\u9009\\u62E9\\u300C\\u6574\\u4F53\\u300D\\u64CD\\u4F5C\\u6B21\\u6570\\u6700\\u5C11\\u7684\\n            // \\u52A0\\u4E00\\u662F\\u56E0\\u4E3A\\u6309\\u52A8\\u6309\\u94AE\\u4E5F\\u662F\\u4E00\\u6B21\\u64CD\\u4F5C\\n            res = Math.min(res, 1 + move + subproblem);\\n        }\\n        // \\u5C06\\u7ED3\\u679C\\u5B58\\u5165\\u5907\\u5FD8\\u5F55\\n        memo[i][j] = res;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    // \\u5B57\\u7B26 -> \\u7D22\\u5F15\\u5217\\u8868\\n    Map<Character, List<Integer>> charToIndex = new HashMap();\\n    // \\u5907\\u5FD8\\u5F55\\n    int[][] memo;\\n\\n    public int findRotateSteps(String ring, String key) {\\n\\n        int m = ring.length(), n = key.length();\\n        // \\u5907\\u5FD8\\u5F55\\u5168\\u90E8\\u521D\\u59CB\\u5316\\u4E3A 0\\n        memo = new int[m][n];\\n        // \\u8BB0\\u5F55\\u5706\\u73AF\\u4E0A\\u5B57\\u7B26\\u5230\\u7D22\\u5F15\\u7684\\u6620\\u5C04\\n        for(int i = 0; i < m; i++) {\\n            char ch = ring.charAt(i);\\n            charToIndex.putIfAbsent(ch, new ArrayList<>());\\n            charToIndex.get(ch).add(i);\\n        }\\n        // \\u5706\\u76D8\\u6307\\u9488\\u6700\\u521D\\u6307\\u5411 12 \\u70B9\\u949F\\u65B9\\u5411\\uFF0C\\n        // \\u4ECE\\u7B2C\\u4E00\\u4E2A\\u5B57\\u7B26\\u5F00\\u59CB\\u8F93\\u5165 key\\n        return dp(ring, 0, key, 0);\\n    }\\n\\n    private int dp(String ring, int i, String key, int j) {\\n        // base case \\u5B8C\\u6210\\u8F93\\u5165\\n        if(j == key.length()) return 0;\\n        // \\u67E5\\u627E\\u5907\\u5FD8\\u5F55\\uFF0C\\u907F\\u514D\\u91CD\\u53E0\\u5B50\\u95EE\\u9898\\n        if(memo[i][j] != 0) return memo[i][j];\\n\\n        int n = ring.length();\\n        // \\u505A\\u9009\\u62E9\\n        int res = Integer.MAX_VALUE;\\n        // ring \\u4E0A\\u53EF\\u80FD\\u6709\\u591A\\u4E2A\\u5B57\\u7B26 key[j]\\n        for(int k : charToIndex.get(key.charAt(j))) {\\n            // \\u62E8\\u52A8\\u6307\\u9488\\u7684\\u6B21\\u6570\\n            int move = Math.abs(i - k);\\n            // \\u9009\\u62E9\\u987A\\u65F6\\u9488\\u8FD8\\u662F\\u9006\\u65F6\\u9488\\n            move = Math.min(move, n - move);\\n            // \\u5C06\\u6307\\u9488\\u62E8\\u5230 ring[k]\\uFF0C\\u7EE7\\u7EED\\u8F93\\u5165 key[j+1..]\\n            int subproblem = dp(ring, k, key, j+1);\\n            // \\u9009\\u62E9\\u300C\\u6574\\u4F53\\u300D\\u64CD\\u4F5C\\u6B21\\u6570\\u6700\\u5C11\\u7684\\n            // \\u52A0\\u4E00\\u662F\\u56E0\\u4E3A\\u6309\\u52A8\\u6309\\u94AE\\u4E5F\\u662F\\u4E00\\u6B21\\u64CD\\u4F5C\\n            res = Math.min(res, 1 + move + subproblem);\\n        }\\n        // \\u5C06\\u7ED3\\u679C\\u5B58\\u5165\\u5907\\u5FD8\\u5F55\\n        memo[i][j] = res;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067956,
                "title": "pure-bfs-solution-dp-not-required",
                "content": "# Approach\\nMost of the solutions are surprisingly based on DP while there exists a straightforward and efficient solution using BFS. We can model the given problem as a state space search problem where the state is represented by `(i,j)`, where `i` is the index of the character present at 12:00 in the `ring` and `j` is the index of the character in the `key` yet to be matched. The initial state is `(0,0)` and the final state is `(..., key.size())`. We can simply do BFS until we reach the final state.\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n- Space complexity: $$O(m*n)$$\\n\\nwhere `m` is the length of the ring and `n` is the length of the key. There are `m*n` distinct states in the state space and we visit each state atmost once.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        int m=ring.size(), n=key.size();\\n        queue<pair<int,int>> queue;\\n        bool visited[m][n+1];\\n        memset(visited, false, sizeof visited);\\n\\n        queue.push({0, 0});\\n        visited[0][0] = true;\\n\\n        int depth = 0;\\n\\n        while(not queue.empty()) {\\n            for(int k=queue.size(); k>0; k--) {\\n                int i = queue.front().first;\\n                int j = queue.front().second;\\n                queue.pop();\\n\\n                // if we reached the end of the key\\n                if(j == n) return depth;\\n\\n                // if the character in the ring and key match\\n                if(ring[i] == key[j]) {\\n                    // press the button\\n                    if(not visited[i][j+1]) {\\n                        visited[i][j+1] = true;\\n                        queue.push({i, j+1});\\n                    }\\n                }\\n                else {\\n                    // clockwise rotation\\n                    if(not visited[(i-1+m)%m][j]) {\\n                        visited[(i-1+m)%m][j] = true;\\n                        queue.push({(i-1+m)%m, j});\\n                    }\\n                    // anticlockwise rotation\\n                    if(not visited[(i+1)%m][j]) {\\n                        visited[(i+1)%m][j] = true;\\n                        queue.push({(i+1)%m, j});\\n                    }\\n                }\\n            }\\n\\n            depth++;\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        int m=ring.size(), n=key.size();\\n        queue<pair<int,int>> queue;\\n        bool visited[m][n+1];\\n        memset(visited, false, sizeof visited);\\n\\n        queue.push({0, 0});\\n        visited[0][0] = true;\\n\\n        int depth = 0;\\n\\n        while(not queue.empty()) {\\n            for(int k=queue.size(); k>0; k--) {\\n                int i = queue.front().first;\\n                int j = queue.front().second;\\n                queue.pop();\\n\\n                // if we reached the end of the key\\n                if(j == n) return depth;\\n\\n                // if the character in the ring and key match\\n                if(ring[i] == key[j]) {\\n                    // press the button\\n                    if(not visited[i][j+1]) {\\n                        visited[i][j+1] = true;\\n                        queue.push({i, j+1});\\n                    }\\n                }\\n                else {\\n                    // clockwise rotation\\n                    if(not visited[(i-1+m)%m][j]) {\\n                        visited[(i-1+m)%m][j] = true;\\n                        queue.push({(i-1+m)%m, j});\\n                    }\\n                    // anticlockwise rotation\\n                    if(not visited[(i+1)%m][j]) {\\n                        visited[(i+1)%m][j] = true;\\n                        queue.push({(i+1)%m, j});\\n                    }\\n                }\\n            }\\n\\n            depth++;\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062114,
                "title": "java-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    HashMap<Character, List<Integer>> charToIndex = new HashMap<>();\\n    int[][] memo;\\n\\n    public int findRotateSteps(String ring, String key) {\\n        int m = ring.length();\\n        int n = key.length();\\n\\n        memo = new int[m][n];\\n\\n        for (int i = 0; i < m; i++) {\\n            char c = ring.charAt(i);\\n            if (!charToIndex.containsKey(c)) {\\n                charToIndex.put(c, new LinkedList<>());\\n            }\\n            charToIndex.get(c).add(i);\\n        }\\n\\n        return dp(ring, 0, key, 0);\\n    }\\n\\n    private int dp(String ring, int ridx, String key, int kidx) {\\n        if (kidx == key.length()) return 0;\\n        if (memo[ridx][kidx] != 0) return memo[ridx][kidx];\\n\\n        int res = Integer.MAX_VALUE;\\n\\n        for (int k: charToIndex.get(key.charAt(kidx))) {\\n            int delta = Math.abs(k - ridx);\\n            delta = Math.min(delta, ring.length() - delta);\\n            int rest = dp(ring, k, key, kidx + 1);\\n            res = Math.min(res, rest + 1 + delta);\\n        }\\n        memo[ridx][kidx] = res;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Character, List<Integer>> charToIndex = new HashMap<>();\\n    int[][] memo;\\n\\n    public int findRotateSteps(String ring, String key) {\\n        int m = ring.length();\\n        int n = key.length();\\n\\n        memo = new int[m][n];\\n\\n        for (int i = 0; i < m; i++) {\\n            char c = ring.charAt(i);\\n            if (!charToIndex.containsKey(c)) {\\n                charToIndex.put(c, new LinkedList<>());\\n            }\\n            charToIndex.get(c).add(i);\\n        }\\n\\n        return dp(ring, 0, key, 0);\\n    }\\n\\n    private int dp(String ring, int ridx, String key, int kidx) {\\n        if (kidx == key.length()) return 0;\\n        if (memo[ridx][kidx] != 0) return memo[ridx][kidx];\\n\\n        int res = Integer.MAX_VALUE;\\n\\n        for (int k: charToIndex.get(key.charAt(kidx))) {\\n            int delta = Math.abs(k - ridx);\\n            delta = Math.min(delta, ring.length() - delta);\\n            int rest = dp(ring, k, key, kidx + 1);\\n            res = Math.min(res, rest + 1 + delta);\\n        }\\n        memo[ridx][kidx] = res;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061501,
                "title": "python-dynamic-programming",
                "content": "# Intuition\\nIn this solution, I use the dynamic programming method. The logic is to find the base case and decide the next step. More details will be shown aside from the code.\\n\\n# Approach\\nDynamic Programming\\n\\n# Complexity\\n- Time complexity:\\nDynamic Programming: $O(M*N)$\\n\\n- Space complexity:\\nDynamic Programming: $O(M*N)$\\n\\n# Code\\n```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        char_pos = defaultdict(set)\\n        for i, c in enumerate(ring):\\n            char_pos[c].add(i)\\n        \\n        # decide next step\\n        def minStep(fromm, to):\\n            if fromm == to:\\n                return 0\\n            minSteps = abs(fromm - to)\\n            minSteps = min(minSteps, abs(len(ring) - minSteps))\\n            return minSteps\\n\\n        # initialization\\n        n = len(key)\\n        dp = [0] * len(ring)\\n        for p in char_pos[key[0]]:\\n            dp[p] = minStep(0, p)\\n        prev_char = key[0]\\n        # get relationship between current node to next node\\n        for c in key[1:]:\\n            if prev_char == c:\\n                continue\\n            for next_pos in char_pos[c]:\\n                dp[next_pos] = min(dp[prev_pos] + minStep(prev_pos, next_pos) for prev_pos in char_pos[prev_char])\\n            prev_char = c\\n        return min(dp[p] for p in char_pos[prev_char]) + len(key)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        char_pos = defaultdict(set)\\n        for i, c in enumerate(ring):\\n            char_pos[c].add(i)\\n        \\n        # decide next step\\n        def minStep(fromm, to):\\n            if fromm == to:\\n                return 0\\n            minSteps = abs(fromm - to)\\n            minSteps = min(minSteps, abs(len(ring) - minSteps))\\n            return minSteps\\n\\n        # initialization\\n        n = len(key)\\n        dp = [0] * len(ring)\\n        for p in char_pos[key[0]]:\\n            dp[p] = minStep(0, p)\\n        prev_char = key[0]\\n        # get relationship between current node to next node\\n        for c in key[1:]:\\n            if prev_char == c:\\n                continue\\n            for next_pos in char_pos[c]:\\n                dp[next_pos] = min(dp[prev_pos] + minStep(prev_pos, next_pos) for prev_pos in char_pos[prev_char])\\n            prev_char = c\\n        return min(dp[p] for p in char_pos[prev_char]) + len(key)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059490,
                "title": "python3-dynamic-programming",
                "content": "# Approach\\nThis problem wants us to calculate the minimum steps of rotating ring to get key. Extrame value problem can always be solved by dynamic programming.\\n\\n- Definition: dp[i][j] will store the minimum steps of getting key[j:] when ring points to i. So dp[0][0] is the minimum steps of getting key when ring points to 12:00, which is the answer we\\'re looking for.\\n- Base case: dp[...][len(key)] = 0. Because we have already reached the end of the key.\\n- Status Transition: for each element in key, we have multiple ways to reach: 1. we can rotate the ring clockwise 2. we can rotate the ring anticlockwise 3. we can rotate to every element equalling to key[j]\\n\\n# Complexity\\n- Time complexity: O(n * m^2), where m=len(ring) and n=len(key). We need to calculate m*n status values O(m * n) and for each value we need to rotate the ring once O(m).\\n\\n- Space complexity: O(m * n)\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        m, n = len(ring), len(key)\\n        memo = [[float(\\'INF\\') for _ in range(n)] for _ in range(m)]\\n        ring_indices_dict = defaultdict(list)\\n        for i in range(m):\\n            ring_indices_dict[ring[i]].append(i) # store the indices list for each element\\n        \\n        def dp(i, j):\\n            # reach the end of the key -> finish rotating\\n            if j == len(key):\\n                return 0\\n            if memo[i][j] != float(\\'INF\\'):\\n                return memo[i][j]\\n            val = float(\\'INF\\')\\n            for k in ring_indices_dict[key[j]]:\\n                rotate_steps = min(abs(i-k), len(ring)-abs(i-k)) # Clockwise or Anticlockwise. Abs(i-k)! not abs(len(ring)-(i-k))  \\n                next_steps = dp(k, j+1) # if ring points to k, we also need to consider the rest steps\\n                val = min(val, rotate_steps+next_steps+1) # one extra step to push enter button\\n            memo[i][j] = val\\n            return val\\n        return dp(0,0)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        m, n = len(ring), len(key)\\n        memo = [[float(\\'INF\\') for _ in range(n)] for _ in range(m)]\\n        ring_indices_dict = defaultdict(list)\\n        for i in range(m):\\n            ring_indices_dict[ring[i]].append(i) # store the indices list for each element\\n        \\n        def dp(i, j):\\n            # reach the end of the key -> finish rotating\\n            if j == len(key):\\n                return 0\\n            if memo[i][j] != float(\\'INF\\'):\\n                return memo[i][j]\\n            val = float(\\'INF\\')\\n            for k in ring_indices_dict[key[j]]:\\n                rotate_steps = min(abs(i-k), len(ring)-abs(i-k)) # Clockwise or Anticlockwise. Abs(i-k)! not abs(len(ring)-(i-k))  \\n                next_steps = dp(k, j+1) # if ring points to k, we also need to consider the rest steps\\n                val = min(val, rotate_steps+next_steps+1) # one extra step to push enter button\\n            memo[i][j] = val\\n            return val\\n        return dp(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058312,
                "title": "java-dp-solution-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    HashMap<Character,List<Integer>> map;\\n    int[][] memo;\\n    public int findRotateSteps(String ring, String key) {\\n        //map the index and the Character of ring\\n        //there may be same characters in ring,so we need to count the index of each and to know which one cost less steps\\n        map= new HashMap<>();\\n        for(int i = 0 ; i < ring.length();i++){\\n            char c = ring.charAt(i);\\n            if(!map.containsKey(c)){\\n                map.put(c,new ArrayList<Integer>());\\n                \\n            }\\n            map.get(c).add(i);\\n        }\\n        int m = ring.length();\\n        int n = key.length();\\n        memo = new int[m][n];\\n        return dp(0,0,ring,key);\\n\\n    }\\n//dp(i,j) means when in i position of ring, j position of key\\n//the minimum number of steps\\n    public int dp(int i,int j,String ring, String key){\\n        //base case\\n        if(j == key.length()){\\n            return 0;\\n        }\\n        if(memo[i][j] != 0){\\n            return memo[i][j];\\n        }\\n        int res = Integer.MAX_VALUE;\\n        //we need to find the minimum step so that ring[i] == key[j]\\n        for(int k: map.get(key.charAt(j))){\\n            int cloDis = Math.abs(k - i);\\n            //if it is wiseClock,the distance will be (ring.length() - cloDis)\\n            cloDis = Math.min(cloDis,ring.length() - cloDis);\\n            int remaining = dp(k,j + 1,ring,key);\\n            res = Math.min(res, remaining + cloDis + 1);\\n\\n        }\\n        memo[i][j] = res;\\n        return res;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Character,List<Integer>> map;\\n    int[][] memo;\\n    public int findRotateSteps(String ring, String key) {\\n        //map the index and the Character of ring\\n        //there may be same characters in ring,so we need to count the index of each and to know which one cost less steps\\n        map= new HashMap<>();\\n        for(int i = 0 ; i < ring.length();i++){\\n            char c = ring.charAt(i);\\n            if(!map.containsKey(c)){\\n                map.put(c,new ArrayList<Integer>());\\n                \\n            }\\n            map.get(c).add(i);\\n        }\\n        int m = ring.length();\\n        int n = key.length();\\n        memo = new int[m][n];\\n        return dp(0,0,ring,key);\\n\\n    }\\n//dp(i,j) means when in i position of ring, j position of key\\n//the minimum number of steps\\n    public int dp(int i,int j,String ring, String key){\\n        //base case\\n        if(j == key.length()){\\n            return 0;\\n        }\\n        if(memo[i][j] != 0){\\n            return memo[i][j];\\n        }\\n        int res = Integer.MAX_VALUE;\\n        //we need to find the minimum step so that ring[i] == key[j]\\n        for(int k: map.get(key.charAt(j))){\\n            int cloDis = Math.abs(k - i);\\n            //if it is wiseClock,the distance will be (ring.length() - cloDis)\\n            cloDis = Math.min(cloDis,ring.length() - cloDis);\\n            int remaining = dp(k,j + 1,ring,key);\\n            res = Math.min(res, remaining + cloDis + 1);\\n\\n        }\\n        memo[i][j] = res;\\n        return res;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057583,
                "title": "java-dynamic-programming",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(m * n^2) time\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O (m * n) space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwhere n is the length of String ring and m is the length of the String key\\n# Code\\n```\\nclass Solution {\\n    // O(m * n^2) time | O (m * n) space\\n    // where n is the length of String ring and m is the length of the String key\\n    int len;\\n    HashMap<String, Integer> map;\\n    public int findRotateSteps(String ring, String key) {\\n        len = ring.length();\\n        map = new HashMap<>();\\n\\n        return backtrack(ring, key, 0, 0);\\n    }\\n\\n    public int backtrack(String ring, String key, int lastIdx, int currentStep){\\n        if(currentStep == key.length()){\\n            return 0;\\n        }\\n\\n        String currentKey = lastIdx + \",\" + currentStep;\\n        if(map.containsKey(currentKey)){\\n            return map.get(currentKey);\\n        }\\n\\n        char currentChar = key.charAt(currentStep);\\n        int res = Integer.MAX_VALUE;\\n\\n        int minClockSteps = 1;\\n        int clockIdx = lastIdx;\\n        for(int i = 0; i < len; i++){\\n            clockIdx = (lastIdx + i) % len;\\n            if(ring.charAt(clockIdx) == currentChar){\\n                int minAnticlockSteps = len + 1 - minClockSteps + 1;\\n                res = Math.min(\\n                    Math.min(minClockSteps, minAnticlockSteps) +  \\n                    backtrack(ring, key, clockIdx, currentStep + 1), \\n                    res\\n                    );\\n            }\\n            minClockSteps++;\\n        }\\n\\n        map.put(currentKey, res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // O(m * n^2) time | O (m * n) space\\n    // where n is the length of String ring and m is the length of the String key\\n    int len;\\n    HashMap<String, Integer> map;\\n    public int findRotateSteps(String ring, String key) {\\n        len = ring.length();\\n        map = new HashMap<>();\\n\\n        return backtrack(ring, key, 0, 0);\\n    }\\n\\n    public int backtrack(String ring, String key, int lastIdx, int currentStep){\\n        if(currentStep == key.length()){\\n            return 0;\\n        }\\n\\n        String currentKey = lastIdx + \",\" + currentStep;\\n        if(map.containsKey(currentKey)){\\n            return map.get(currentKey);\\n        }\\n\\n        char currentChar = key.charAt(currentStep);\\n        int res = Integer.MAX_VALUE;\\n\\n        int minClockSteps = 1;\\n        int clockIdx = lastIdx;\\n        for(int i = 0; i < len; i++){\\n            clockIdx = (lastIdx + i) % len;\\n            if(ring.charAt(clockIdx) == currentChar){\\n                int minAnticlockSteps = len + 1 - minClockSteps + 1;\\n                res = Math.min(\\n                    Math.min(minClockSteps, minAnticlockSteps) +  \\n                    backtrack(ring, key, clockIdx, currentStep + 1), \\n                    res\\n                    );\\n            }\\n            minClockSteps++;\\n        }\\n\\n        map.put(currentKey, res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056487,
                "title": "java-recursion-memo",
                "content": "```\\nclass Solution {\\n    Map<Character, List<Integer>> map;\\n    int[][] memo;\\n    public int findRotateSteps(String ring, String key) {\\n        int length = ring.length() > key.length() ? ring.length() : key.length();\\n        memo = new int[length][length];\\n        for (int[] row : memo) {\\n            Arrays.fill(row, -1);\\n        }\\n        char[] arr = ring.toCharArray();\\n        map = new HashMap<>(); \\n        //write down all index for same char, then later we need to try all of them when meet that char\\n        //since not sure which one is best\\n        for (int i = 0; i < arr.length; i++) {\\n            map.putIfAbsent(arr[i], new ArrayList<Integer>());\\n            map.get(arr[i]).add(i);\\n        }\\n        \\n        return dfs(arr, 0, 0, key);\\n    }\\n\\n    private int dfs (char[] arr, int from, int to, String key) {\\n        if (to == key.length()) return 0;\\n\\n        if (memo[from][to] != -1) return memo[from][to];\\n        List<Integer> list = map.get(key.charAt(to));\\n        int res = Integer.MAX_VALUE;\\n        //try all the possible index for target char, then get the min one\\n        for (int i = 0; i < list.size(); i++) {\\n            int dis = findDistance(arr, from, list.get(i)); \\n            res = Math.min(res, dfs(arr, list.get(i), to + 1, key) + dis + 1);\\n        }\\n        return memo[from][to] = res;\\n    }\\n\\n    private int findDistance(char[] arr, int start, int target) {\\n        int toRight = start > target ? arr.length - start + target : target - start;\\n        int toLeft = start > target ?  start - target : start + arr.length - target;\\n       \\n        return Math.min(toRight, toLeft);\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Character, List<Integer>> map;\\n    int[][] memo;\\n    public int findRotateSteps(String ring, String key) {\\n        int length = ring.length() > key.length() ? ring.length() : key.length();\\n        memo = new int[length][length];\\n        for (int[] row : memo) {\\n            Arrays.fill(row, -1);\\n        }\\n        char[] arr = ring.toCharArray();\\n        map = new HashMap<>(); \\n        //write down all index for same char, then later we need to try all of them when meet that char\\n        //since not sure which one is best\\n        for (int i = 0; i < arr.length; i++) {\\n            map.putIfAbsent(arr[i], new ArrayList<Integer>());\\n            map.get(arr[i]).add(i);\\n        }\\n        \\n        return dfs(arr, 0, 0, key);\\n    }\\n\\n    private int dfs (char[] arr, int from, int to, String key) {\\n        if (to == key.length()) return 0;\\n\\n        if (memo[from][to] != -1) return memo[from][to];\\n        List<Integer> list = map.get(key.charAt(to));\\n        int res = Integer.MAX_VALUE;\\n        //try all the possible index for target char, then get the min one\\n        for (int i = 0; i < list.size(); i++) {\\n            int dis = findDistance(arr, from, list.get(i)); \\n            res = Math.min(res, dfs(arr, list.get(i), to + 1, key) + dis + 1);\\n        }\\n        return memo[from][to] = res;\\n    }\\n\\n    private int findDistance(char[] arr, int start, int target) {\\n        int toRight = start > target ? arr.length - start + target : target - start;\\n        int toLeft = start > target ?  start - target : start + arr.length - target;\\n       \\n        return Math.min(toRight, toLeft);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041223,
                "title": "not-optimal-but-easy-understandable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    Map<String, Integer> mp;\\n    public int findRotateSteps(String ring, String key) {\\n        mp = new HashMap<>();\\n        return findMinSteps(0, ring, key);\\n    }\\n\\n    int findMinSteps(int index, String ring, String key) {\\n\\n        if(index==key.length())\\n        return 0;\\n        if(mp.get(ring+\"$\"+index) != null)\\n        return mp.get(ring+\"$\"+index);\\n\\n        int ans = Integer.MAX_VALUE;\\n        String first,second;\\n        for(int i=0; i<ring.length(); i++) {\\n            if(ring.charAt(i) == key.charAt(index)) {\\n                first = ring.substring(0, i);\\n                second = ring.substring(i, ring.length());\\n                ans = Math.min(ans, findMinSteps(index+1, second+first, key)+i+1);\\n            }\\n        }\\n\\n\\n        int n = ring.length();\\n        for(int i=1; i<ring.length(); i++) {\\n            if(ring.charAt(n-i) == key.charAt(index)) {\\n                first = ring.substring(n-i, n);\\n                second = ring.substring(0, n-i);\\n                ans = Math.min(ans, findMinSteps(index+1, first+second, key)+i+1);\\n            }\\n        }\\n        mp.put(ring+\"$\"+index, ans);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Map<String, Integer> mp;\\n    public int findRotateSteps(String ring, String key) {\\n        mp = new HashMap<>();\\n        return findMinSteps(0, ring, key);\\n    }\\n\\n    int findMinSteps(int index, String ring, String key) {\\n\\n        if(index==key.length())\\n        return 0;\\n        if(mp.get(ring+\"$\"+index) != null)\\n        return mp.get(ring+\"$\"+index);\\n\\n        int ans = Integer.MAX_VALUE;\\n        String first,second;\\n        for(int i=0; i<ring.length(); i++) {\\n            if(ring.charAt(i) == key.charAt(index)) {\\n                first = ring.substring(0, i);\\n                second = ring.substring(i, ring.length());\\n                ans = Math.min(ans, findMinSteps(index+1, second+first, key)+i+1);\\n            }\\n        }\\n\\n\\n        int n = ring.length();\\n        for(int i=1; i<ring.length(); i++) {\\n            if(ring.charAt(n-i) == key.charAt(index)) {\\n                first = ring.substring(n-i, n);\\n                second = ring.substring(0, n-i);\\n                ans = Math.min(ans, findMinSteps(index+1, first+second, key)+i+1);\\n            }\\n        }\\n        mp.put(ring+\"$\"+index, ans);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3002903,
                "title": "simple-c-solution-using-breadth-first-search",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Top-Down Approach**\\nCreate the graph, for each character present in the key string store the index of the same character present in the ring string. In this way we will create a 2d vector graph, which will contain the indices of the ith character present in the string ring. We will now do a breadth-first search beginning from the elements present in 0th row of graph and print the minimum value.\\n\\n# Complexity\\n- Time complexity: O(key.length()*ring.length())\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(key.length()*ring.length())\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n,m;\\n    int bfs(vector<vector<int>>& graph,vector<vector<int>>& dp,int row,int col)\\n    {\\n        // base case\\n        // we reached the last row\\n        if(row==n-1)\\n            return 0;\\n        if(dp[row][col]!=-1)\\n            return dp[row][col];\\n        int mVal=INT_MAX;\\n        int nextRow=row+1;\\n        for(auto i:graph[nextRow])\\n        {\\n            mVal=min(mVal,min(abs(col-i),m-abs(col-i))+bfs(graph,dp,nextRow,i));\\n        }\\n        dp[row][col]=mVal;\\n        return dp[row][col];\\n    }\\n    int findRotateSteps(string ring, string key) {\\n        n=key.length(),m=ring.length();\\n        // building the graph\\n        vector<vector<int>>graph(n);\\n        for(int i=0;i<key.length();i++)\\n        {\\n            for(int j=0;j<ring.length();j++)\\n            {\\n                if(key[i]==ring[j])\\n                    graph[i].push_back(j);\\n            }\\n        }\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        int res=INT_MAX;\\n        for(auto i:graph[0])\\n        {\\n            res=min(res,min(i,m-i)+bfs(graph,dp,0,i));\\n        }\\n        return res+n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    int bfs(vector<vector<int>>& graph,vector<vector<int>>& dp,int row,int col)\\n    {\\n        // base case\\n        // we reached the last row\\n        if(row==n-1)\\n            return 0;\\n        if(dp[row][col]!=-1)\\n            return dp[row][col];\\n        int mVal=INT_MAX;\\n        int nextRow=row+1;\\n        for(auto i:graph[nextRow])\\n        {\\n            mVal=min(mVal,min(abs(col-i),m-abs(col-i))+bfs(graph,dp,nextRow,i));\\n        }\\n        dp[row][col]=mVal;\\n        return dp[row][col];\\n    }\\n    int findRotateSteps(string ring, string key) {\\n        n=key.length(),m=ring.length();\\n        // building the graph\\n        vector<vector<int>>graph(n);\\n        for(int i=0;i<key.length();i++)\\n        {\\n            for(int j=0;j<ring.length();j++)\\n            {\\n                if(key[i]==ring[j])\\n                    graph[i].push_back(j);\\n            }\\n        }\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        int res=INT_MAX;\\n        for(auto i:graph[0])\\n        {\\n            res=min(res,min(i,m-i)+bfs(graph,dp,0,i));\\n        }\\n        return res+n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939869,
                "title": "effectively-the-fastest-solution-java",
                "content": "2-10 times faster than top solutions on big datasets(thousands of chars in a ring and key).\\n\\n-No need to calculate all possible scenarios\\n-On each step we only look for the closest left and right path\\n-If distance is higher than half of the ring - we can exclude it from the next iteration\\n-TreeSet is used to store the positions of the chars. It allows us to find the closest char in a quick way\\n-Cache for paths which are already found\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n   \\n    public int findRotateSteps(String ring, String key) {\\n\\n        char[] ringChars = ring.toCharArray();\\n        char[] keyChars = key.toCharArray();\\n\\n        //collect unique key chars\\n        HashSet<Character> keySet = new HashSet<>();\\n        for (int i = 0; i < keyChars.length; i++)\\n            keySet.add(keyChars[i]);\\n\\n        //collect sorted positions in ring only for key chars\\n        HashMap<Character, TreeSet<Integer>> positions = new HashMap<>();\\n        for (int i = 0; i < ringChars.length; i++) {\\n            if (keySet.contains(ringChars[i]))\\n                positions.computeIfAbsent(ringChars[i], k -> new TreeSet<>()).add(i);\\n        }\\n\\n        int ringLength = ringChars.length;\\n        int leftHalf = (ringLength - 1) / 2;\\n        int rightHalf = (ringLength - 1) - leftHalf;\\n\\n        //stores list of active positions. Initial position is 0\\n        Set<Integer> solutions = new HashSet<>();\\n        solutions.add(0);\\n        //stores costs for active positions\\n        int[] costs = new int[ringChars.length];\\n\\n        //cache for calculated distances between chars. key1 -> char position in ring, key2 -> char, value -> distance\\n        int[][] cache = new int[ringChars.length][];\\n\\n        //iterate through keys\\n        for (char keyChar : keyChars) {\\n            Set<Integer> nextSolutions = new HashSet<>();\\n\\n            int leftCharIndex = keyChar - \\'a\\';\\n            int rightCharIndex = leftCharIndex + 26;\\n\\n            //for each active position\\n            for (int position : solutions) {\\n\\n                //if current position is a char we\\'re looking for - just skip it\\n                if (ringChars[position] == keyChar) {\\n                    nextSolutions.add(position);\\n                    continue;\\n                }\\n\\n                //if cache for this position is empty - create it.\\n                //first 26 indexes are used to store left distances, last 26 - for right distances\\n                if (cache[position] == null) cache[position] = new int[52];\\n\\n                //if cache for left char is empty - fill it\\n                if (cache[position][leftCharIndex] == 0) {\\n                    //get the closest left position for the char we look for\\n                    Integer closest = positions.get(keyChar).lower(position);\\n                    //if position not found - we can take the last one\\n                    closest = closest == null ? position - positions.get(keyChar).last() + ringLength : position - closest;\\n                    //if char distance is higher than half of the ring - ignore it since it\\'s cheaper to get it from other side\\n                    cache[position][leftCharIndex] = closest <= leftHalf ? closest : -1;\\n                }\\n\\n                //if cache for right char is empty - fill it\\n                if (cache[position][rightCharIndex] == 0) {\\n                    //get the closest right position for the char we look for\\n                    Integer closest = positions.get(keyChar).higher(position);\\n                    //if position not found - we can take the first one\\n                    closest = closest == null ? positions.get(keyChar).first() + ringLength - position : closest - position;\\n                    cache[position][rightCharIndex] = closest <= rightHalf ? closest : -1;\\n                }\\n                \\n                int left = cache[position][leftCharIndex];\\n                int right = cache[position][rightCharIndex];\\n\\n                //if left is reachable:\\n                if (left > 0) {\\n                    int target = position - left;\\n                    target = target < 0 ? ringLength + target : target;\\n                    int newDistance = costs[position] + left;\\n                    if (nextSolutions.contains(target)) {\\n                        //overwrite with the shortest path \\n                        costs[target] = Math.min(costs[target], newDistance);\\n                    } else {\\n                        //create record\\n                        nextSolutions.add(target);\\n                        costs[target] = newDistance;\\n                    }\\n                }\\n\\n                //if right is reachable:\\n                if (right > 0) {\\n                    int target = position + right;\\n                    target = target > ringLength - 1 ? target - ringLength : target;\\n                    int newDistance = costs[position] + right;\\n                    if (nextSolutions.contains(target)) {\\n                        costs[target] = Math.min(costs[target], newDistance);\\n                    } else {\\n                        nextSolutions.add(target);\\n                        costs[target] = newDistance;\\n                    }\\n                }\\n            }\\n\\n            //overwrite with next iteration\\n            solutions = nextSolutions;\\n        }\\n\\n        //get min and add amount of key chars\\n        return solutions.stream().mapToInt(i -> costs[i]).min().orElse(0) + keyChars.length;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Memoization",
                    "Iterator"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n   \\n    public int findRotateSteps(String ring, String key) {\\n\\n        char[] ringChars = ring.toCharArray();\\n        char[] keyChars = key.toCharArray();\\n\\n        //collect unique key chars\\n        HashSet<Character> keySet = new HashSet<>();\\n        for (int i = 0; i < keyChars.length; i++)\\n            keySet.add(keyChars[i]);\\n\\n        //collect sorted positions in ring only for key chars\\n        HashMap<Character, TreeSet<Integer>> positions = new HashMap<>();\\n        for (int i = 0; i < ringChars.length; i++) {\\n            if (keySet.contains(ringChars[i]))\\n                positions.computeIfAbsent(ringChars[i], k -> new TreeSet<>()).add(i);\\n        }\\n\\n        int ringLength = ringChars.length;\\n        int leftHalf = (ringLength - 1) / 2;\\n        int rightHalf = (ringLength - 1) - leftHalf;\\n\\n        //stores list of active positions. Initial position is 0\\n        Set<Integer> solutions = new HashSet<>();\\n        solutions.add(0);\\n        //stores costs for active positions\\n        int[] costs = new int[ringChars.length];\\n\\n        //cache for calculated distances between chars. key1 -> char position in ring, key2 -> char, value -> distance\\n        int[][] cache = new int[ringChars.length][];\\n\\n        //iterate through keys\\n        for (char keyChar : keyChars) {\\n            Set<Integer> nextSolutions = new HashSet<>();\\n\\n            int leftCharIndex = keyChar - \\'a\\';\\n            int rightCharIndex = leftCharIndex + 26;\\n\\n            //for each active position\\n            for (int position : solutions) {\\n\\n                //if current position is a char we\\'re looking for - just skip it\\n                if (ringChars[position] == keyChar) {\\n                    nextSolutions.add(position);\\n                    continue;\\n                }\\n\\n                //if cache for this position is empty - create it.\\n                //first 26 indexes are used to store left distances, last 26 - for right distances\\n                if (cache[position] == null) cache[position] = new int[52];\\n\\n                //if cache for left char is empty - fill it\\n                if (cache[position][leftCharIndex] == 0) {\\n                    //get the closest left position for the char we look for\\n                    Integer closest = positions.get(keyChar).lower(position);\\n                    //if position not found - we can take the last one\\n                    closest = closest == null ? position - positions.get(keyChar).last() + ringLength : position - closest;\\n                    //if char distance is higher than half of the ring - ignore it since it\\'s cheaper to get it from other side\\n                    cache[position][leftCharIndex] = closest <= leftHalf ? closest : -1;\\n                }\\n\\n                //if cache for right char is empty - fill it\\n                if (cache[position][rightCharIndex] == 0) {\\n                    //get the closest right position for the char we look for\\n                    Integer closest = positions.get(keyChar).higher(position);\\n                    //if position not found - we can take the first one\\n                    closest = closest == null ? positions.get(keyChar).first() + ringLength - position : closest - position;\\n                    cache[position][rightCharIndex] = closest <= rightHalf ? closest : -1;\\n                }\\n                \\n                int left = cache[position][leftCharIndex];\\n                int right = cache[position][rightCharIndex];\\n\\n                //if left is reachable:\\n                if (left > 0) {\\n                    int target = position - left;\\n                    target = target < 0 ? ringLength + target : target;\\n                    int newDistance = costs[position] + left;\\n                    if (nextSolutions.contains(target)) {\\n                        //overwrite with the shortest path \\n                        costs[target] = Math.min(costs[target], newDistance);\\n                    } else {\\n                        //create record\\n                        nextSolutions.add(target);\\n                        costs[target] = newDistance;\\n                    }\\n                }\\n\\n                //if right is reachable:\\n                if (right > 0) {\\n                    int target = position + right;\\n                    target = target > ringLength - 1 ? target - ringLength : target;\\n                    int newDistance = costs[position] + right;\\n                    if (nextSolutions.contains(target)) {\\n                        costs[target] = Math.min(costs[target], newDistance);\\n                    } else {\\n                        nextSolutions.add(target);\\n                        costs[target] = newDistance;\\n                    }\\n                }\\n            }\\n\\n            //overwrite with next iteration\\n            solutions = nextSolutions;\\n        }\\n\\n        //get min and add amount of key chars\\n        return solutions.stream().mapToInt(i -> costs[i]).min().orElse(0) + keyChars.length;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932889,
                "title": "beats-100-python-solutions-dfs-with-memoization-also-concept-of-dynamic-programming-used",
                "content": "# Beats 100% python solutions\\n\\n# Approach\\nNormal DFS with Memoization\\n\\n# Complexity\\n- Time complexity:\\n< O(M*N * M) where M = len(ring) and N = len(key)\\nM is multiplied twice because of the extra for loop \\n\\n- Space complexity:\\nO(M*N) for stroing chars_to_ring_idxes and visited\\n\\n# Code\\n```\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    def findRotateSteps(self, ring, key):\\n        \"\"\"\\n        :type ring: str\\n        :type key: str\\n        :rtype: int\\n        \"\"\"\\n\\n        chars_to_ring_idxes = defaultdict(list)\\n\\n        for i in range(len(ring)):\\n            chars_to_ring_idxes[ring[i]].append(i)\\n        \\n        #value taken from the input constraint\\n        res = [1001]\\n\\n        visited = {}\\n\\n        r = self.steps(ring, 0, key, visited, chars_to_ring_idxes, 0)\\n\\n        return r\\n            \\n\\n    def steps(self, ring, ring_idx, key, visited, chars_to_ring_idxes, key_idx):\\n\\n        if (ring_idx, key_idx) in visited:\\n            return visited[(ring_idx, key_idx)]\\n\\n        if key_idx == len(key):\\n            return 0\\n        \\n        nexts = chars_to_ring_idxes[key[key_idx]]\\n\\n        #value taken from the input constraint\\n        mn = 10001\\n\\n        for next_ring_idx in nexts:\\n            s = ring_idx\\n            e = next_ring_idx\\n            if ring_idx > next_ring_idx:\\n                s = next_ring_idx\\n                e = ring_idx\\n\\n            dist = min(abs(e - s), len(ring) - e + s)\\n\\n            mn = min(mn, dist + 1 + self.steps(ring, next_ring_idx, key, visited, mps, key_idx+1))\\n        \\n        visited[(ring_idx, key_idx)] = mn\\n\\n        return mn\\n                \\n\\n\\n\\n                \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    def findRotateSteps(self, ring, key):\\n        \"\"\"\\n        :type ring: str\\n        :type key: str\\n        :rtype: int\\n        \"\"\"\\n\\n        chars_to_ring_idxes = defaultdict(list)\\n\\n        for i in range(len(ring)):\\n            chars_to_ring_idxes[ring[i]].append(i)\\n        \\n        #value taken from the input constraint\\n        res = [1001]\\n\\n        visited = {}\\n\\n        r = self.steps(ring, 0, key, visited, chars_to_ring_idxes, 0)\\n\\n        return r\\n            \\n\\n    def steps(self, ring, ring_idx, key, visited, chars_to_ring_idxes, key_idx):\\n\\n        if (ring_idx, key_idx) in visited:\\n            return visited[(ring_idx, key_idx)]\\n\\n        if key_idx == len(key):\\n            return 0\\n        \\n        nexts = chars_to_ring_idxes[key[key_idx]]\\n\\n        #value taken from the input constraint\\n        mn = 10001\\n\\n        for next_ring_idx in nexts:\\n            s = ring_idx\\n            e = next_ring_idx\\n            if ring_idx > next_ring_idx:\\n                s = next_ring_idx\\n                e = ring_idx\\n\\n            dist = min(abs(e - s), len(ring) - e + s)\\n\\n            mn = min(mn, dist + 1 + self.steps(ring, next_ring_idx, key, visited, mps, key_idx+1))\\n        \\n        visited[(ring_idx, key_idx)] = mn\\n\\n        return mn\\n                \\n\\n\\n\\n                \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929519,
                "title": "c-dp-memoization-code-beat-94",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint dp[105][105];\\nint cal(int n,int eidx,int cidx){\\n    if(eidx>=cidx){\\n        return min(eidx-cidx,cidx+n-eidx);\\n    }\\n    return min(cidx-eidx,eidx+n-cidx);\\n}\\nint solve(string &s,int idx,int curr,vector<vector<int>>&p,int n){\\n    if(idx==s.size())return 0;\\n    if(dp[idx][curr]!=-1)return dp[idx][curr];\\n    int ans=100000;\\n    for(auto i:p[s[idx]-\\'a\\']){\\n        ans=min(ans,1+cal(n,i,curr)+solve(s,idx+1,i,p,n));\\n    }\\n    return dp[idx][curr]=ans;\\n}\\n    int findRotateSteps(string ring, string key) {\\n        vector<vector<int>> p(26);\\n        memset(dp,-1,sizeof(dp));\\n        int n=ring.size();\\n        for(int i=0;i<n;i++){\\n            p[ring[i]-\\'a\\'].push_back(i);\\n        }\\n        return solve(key,0,0,p,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint dp[105][105];\\nint cal(int n,int eidx,int cidx){\\n    if(eidx>=cidx){\\n        return min(eidx-cidx,cidx+n-eidx);\\n    }\\n    return min(cidx-eidx,eidx+n-cidx);\\n}\\nint solve(string &s,int idx,int curr,vector<vector<int>>&p,int n){\\n    if(idx==s.size())return 0;\\n    if(dp[idx][curr]!=-1)return dp[idx][curr];\\n    int ans=100000;\\n    for(auto i:p[s[idx]-\\'a\\']){\\n        ans=min(ans,1+cal(n,i,curr)+solve(s,idx+1,i,p,n));\\n    }\\n    return dp[idx][curr]=ans;\\n}\\n    int findRotateSteps(string ring, string key) {\\n        vector<vector<int>> p(26);\\n        memset(dp,-1,sizeof(dp));\\n        int n=ring.size();\\n        for(int i=0;i<n;i++){\\n            p[ring[i]-\\'a\\'].push_back(i);\\n        }\\n        return solve(key,0,0,p,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2921214,
                "title": "java-bfs",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    class Pair{\\n        int i;\\n        int j;\\n        Pair(int i,int j)\\n        {\\n            this.i=i;\\n            this.j=j;\\n        }\\n    }\\n\\n    public int findRotateSteps(String ring, String key) {\\n\\n        int [][]visited=new int [ring.length()][key.length()];\\n\\n    int ans=key.length();\\n        Queue<Pair>dq=new ArrayDeque<>();\\n        dq.add(new Pair(0,0));\\n        visited[0][0]=1;\\n\\n           int x=0,y=0;\\nint steps=-1;;\\n        while(dq.size()!=0)\\n        {\\n            steps++;\\n\\n            int size=dq.size();\\n            boolean f=false;\\n\\n              while(size-->0)\\n            { \\n            Pair rem=dq.remove();\\n\\n\\n          \\n            while(rem.j<key.length()&&ring.charAt(rem.i)==key.charAt(rem.j))\\n            {\\n                \\n                   visited[rem.i][rem.j]=1;\\n\\n\\n                 rem.j++;\\n\\n\\n            }        \\n            if(key.length()==rem.j)\\n            {\\n                f=true;\\n                break;\\n\\n            }\\n            int idx=rem.i;\\n            // 2 direction\\n            int ahead=(idx+1)%ring.length();\\n            int before=(idx==0)?ring.length()-1:idx-1;\\n            if(visited[ahead][rem.j]!=1)\\n            {\\n                   dq.add(new Pair(ahead,rem.j));\\n                   visited[ahead][rem.j]=1;\\n\\n            }\\n            if(visited[before][rem.j]!=1)\\n            {\\n                  dq.add(new Pair(before,rem.j));\\n                  visited[before][rem.j]=1;\\n\\n            }\\n         \\n          \\n  }\\n  if(f)\\n  {\\n      break;\\n  }\\n\\n\\n        }\\n\\n        return steps+ans;\\n\\n\\n\\n\\n\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        int i;\\n        int j;\\n        Pair(int i,int j)\\n        {\\n            this.i=i;\\n            this.j=j;\\n        }\\n    }\\n\\n    public int findRotateSteps(String ring, String key) {\\n\\n        int [][]visited=new int [ring.length()][key.length()];\\n\\n    int ans=key.length();\\n        Queue<Pair>dq=new ArrayDeque<>();\\n        dq.add(new Pair(0,0));\\n        visited[0][0]=1;\\n\\n           int x=0,y=0;\\nint steps=-1;;\\n        while(dq.size()!=0)\\n        {\\n            steps++;\\n\\n            int size=dq.size();\\n            boolean f=false;\\n\\n              while(size-->0)\\n            { \\n            Pair rem=dq.remove();\\n\\n\\n          \\n            while(rem.j<key.length()&&ring.charAt(rem.i)==key.charAt(rem.j))\\n            {\\n                \\n                   visited[rem.i][rem.j]=1;\\n\\n\\n                 rem.j++;\\n\\n\\n            }        \\n            if(key.length()==rem.j)\\n            {\\n                f=true;\\n                break;\\n\\n            }\\n            int idx=rem.i;\\n            // 2 direction\\n            int ahead=(idx+1)%ring.length();\\n            int before=(idx==0)?ring.length()-1:idx-1;\\n            if(visited[ahead][rem.j]!=1)\\n            {\\n                   dq.add(new Pair(ahead,rem.j));\\n                   visited[ahead][rem.j]=1;\\n\\n            }\\n            if(visited[before][rem.j]!=1)\\n            {\\n                  dq.add(new Pair(before,rem.j));\\n                  visited[before][rem.j]=1;\\n\\n            }\\n         \\n          \\n  }\\n  if(f)\\n  {\\n      break;\\n  }\\n\\n\\n        }\\n\\n        return steps+ans;\\n\\n\\n\\n\\n\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2881597,
                "title": "java-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->First of all i saw that it has optimisation + choice so i thought dp should sit nicely with this one\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst we write a recursive solution, setting two pointers, one on key and one on ring and rotate using abs(m-i) and m-abs(m-i) then finally we memotize the solution.\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n\\n    public int solve(String ring,String key,int ringc,int keyc,int[][] dp)\\n    {\\n        if(dp[keyc][ringc]!=-1)return dp[keyc][ringc];\\n        int n = key.length();\\n        int m= ring.length();\\n        if(keyc>=n)return 0;\\n\\n        int steps = Integer.MAX_VALUE;\\n        for(int i=0;i<m;i++)\\n        {\\n            if(ring.charAt(i)==key.charAt(keyc))\\n            {\\n                steps = Math.min(steps,Math.min(Math.abs(i-ringc),m-Math.abs(i-ringc))+1+solve(ring,key,i,keyc+1,dp));\\n            }\\n        }\\n        return dp[keyc][ringc]=steps;\\n\\n    }\\n\\n\\n\\n    public int findRotateSteps(String ring, String key) {\\n        int ringc = 0;\\n        int keyc=0;\\n        int m=ring.length();\\n        int n=key.length();\\n        int[][] dp = new int[n+1][m+1];\\n       for(int i=0;i<n+1;i++)\\n       {\\n           for(int j=0;j<m+1;j++)\\n           {\\n               dp[i][j]=-1;\\n           }\\n       }\\n\\n       return solve(ring,key,ringc,keyc,dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n\\n    public int solve(String ring,String key,int ringc,int keyc,int[][] dp)\\n    {\\n        if(dp[keyc][ringc]!=-1)return dp[keyc][ringc];\\n        int n = key.length();\\n        int m= ring.length();\\n        if(keyc>=n)return 0;\\n\\n        int steps = Integer.MAX_VALUE;\\n        for(int i=0;i<m;i++)\\n        {\\n            if(ring.charAt(i)==key.charAt(keyc))\\n            {\\n                steps = Math.min(steps,Math.min(Math.abs(i-ringc),m-Math.abs(i-ringc))+1+solve(ring,key,i,keyc+1,dp));\\n            }\\n        }\\n        return dp[keyc][ringc]=steps;\\n\\n    }\\n\\n\\n\\n    public int findRotateSteps(String ring, String key) {\\n        int ringc = 0;\\n        int keyc=0;\\n        int m=ring.length();\\n        int n=key.length();\\n        int[][] dp = new int[n+1][m+1];\\n       for(int i=0;i<n+1;i++)\\n       {\\n           for(int j=0;j<m+1;j++)\\n           {\\n               dp[i][j]=-1;\\n           }\\n       }\\n\\n       return solve(ring,key,ringc,keyc,dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2879732,
                "title": "c-simple-dfs-memoization-77-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int cache[101][101];\\n    \\n    int search(string& ring, string& key, int r_idx, int k_idx){\\n        if(k_idx >= key.size()) return 0;\\n        if(cache[r_idx][k_idx]) return cache[r_idx][k_idx];\\n        \\n        int ret = 0;\\n        int lmin = INT_MAX;\\n        \\n        for(int i=r_idx;i<r_idx+ring.size();i++){\\n            int idx = i%ring.size();\\n            if(ring[idx] == key[k_idx])\\n            {\\n                lmin= min(lmin, search(ring, key, idx, k_idx+1) + min(abs(i-r_idx)+1, abs((int)(ring.size())-(i-r_idx))+1));\\n                }\\n            }\\n        cache[r_idx][k_idx] = ret = lmin;\\n        return ret;\\n    }\\n        \\n    int findRotateSteps(string ring, string key) {\\n        return search(ring, key, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int cache[101][101];\\n    \\n    int search(string& ring, string& key, int r_idx, int k_idx){\\n        if(k_idx >= key.size()) return 0;\\n        if(cache[r_idx][k_idx]) return cache[r_idx][k_idx];\\n        \\n        int ret = 0;\\n        int lmin = INT_MAX;\\n        \\n        for(int i=r_idx;i<r_idx+ring.size();i++){\\n            int idx = i%ring.size();\\n            if(ring[idx] == key[k_idx])\\n            {\\n                lmin= min(lmin, search(ring, key, idx, k_idx+1) + min(abs(i-r_idx)+1, abs((int)(ring.size())-(i-r_idx))+1));\\n                }\\n            }\\n        cache[r_idx][k_idx] = ret = lmin;\\n        return ret;\\n    }\\n        \\n    int findRotateSteps(string ring, string key) {\\n        return search(ring, key, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2865846,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn find_rotate_steps(ring: String, key: String) -> i32 {\\n        let mut f: Vec<Vec<i64>> = vec![vec![std::i32::MAX as i64; ring.len()]; key.len()];\\n        let mut map = std::collections::HashMap::<char, Vec<usize>>::new();\\n        for (i, c) in ring.char_indices() {\\n            map.entry(c).or_default().push(i);\\n        }\\n        let key: Vec<char> = key.chars().collect();\\n        for &i in map[&key[0]].iter() {\\n            f[0][i] = (ring.len() as i64 - i as i64).abs().min(i as i64);\\n        }\\n\\n        for k in 1..key.len() {\\n            for &to in map[&key[k]].iter() {\\n                for &from in map[&key[k - 1]].iter() {\\n                    let diff = (from as i64 - to as i64).abs();\\n                    let diff = diff.min((ring.len() as i64 - diff).abs());\\n                    f[k][to] = f[k][to].min(f[k - 1][from] + diff);\\n                }\\n            }\\n        }\\n        map[&key[key.len() - 1]]\\n            .iter()\\n            .fold(std::i64::MAX, |ret, idx| ret.min(f[key.len() - 1][*idx])) as i32\\n            + key.len() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_rotate_steps(ring: String, key: String) -> i32 {\\n        let mut f: Vec<Vec<i64>> = vec![vec![std::i32::MAX as i64; ring.len()]; key.len()];\\n        let mut map = std::collections::HashMap::<char, Vec<usize>>::new();\\n        for (i, c) in ring.char_indices() {\\n            map.entry(c).or_default().push(i);\\n        }\\n        let key: Vec<char> = key.chars().collect();\\n        for &i in map[&key[0]].iter() {\\n            f[0][i] = (ring.len() as i64 - i as i64).abs().min(i as i64);\\n        }\\n\\n        for k in 1..key.len() {\\n            for &to in map[&key[k]].iter() {\\n                for &from in map[&key[k - 1]].iter() {\\n                    let diff = (from as i64 - to as i64).abs();\\n                    let diff = diff.min((ring.len() as i64 - diff).abs());\\n                    f[k][to] = f[k][to].min(f[k - 1][from] + diff);\\n                }\\n            }\\n        }\\n        map[&key[key.len() - 1]]\\n            .iter()\\n            .fold(std::i64::MAX, |ret, idx| ret.min(f[key.len() - 1][*idx])) as i32\\n            + key.len() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2833101,
                "title": "simple-dfs-with-memoization-cache-python",
                "content": "For every character key[j], we search from the current ring[i] to find the match character ring[m] == ring[j] and find the smallest step to reach m from i (clockwise or counterclockwise).\\n```\\n@cache\\ndef dfs(i, j):\\n\\tif j == len(key):\\n\\t\\treturn 0\\n\\tstepInit = float(\"inf\")\\n\\tfor m in range(len(ring)):\\n\\t\\tif ring[m] == key[j]:\\n\\t\\t\\tif m > i:\\n\\t\\t\\t\\tsteps = min(m-i, i+len(ring)-m)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tsteps = min(i-m, len(ring)-i+m)\\n\\t\\t\\tstepInit = min(stepInit, steps+dfs(m, j+1)+1)\\n\\n\\treturn stepInit\\n\\nreturn dfs(0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\n@cache\\ndef dfs(i, j):\\n\\tif j == len(key):\\n\\t\\treturn 0\\n\\tstepInit = float(\"inf\")\\n\\tfor m in range(len(ring)):\\n\\t\\tif ring[m] == key[j]:\\n\\t\\t\\tif m > i:\\n\\t\\t\\t\\tsteps = min(m-i, i+len(ring)-m)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tsteps = min(i-m, len(ring)-i+m)\\n\\t\\t\\tstepInit = min(stepInit, steps+dfs(m, j+1)+1)\\n\\n\\treturn stepInit\\n\\nreturn dfs(0, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2819258,
                "title": "dp-solution-with-transit-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe additional steps required to match a character (i) is determined by the position of the ring at 12:00 for matching the last character (i - 1).\\n```\\nf(i, j) = min(f(i - 1, k) + move(k, j)) if key[i - 1] == ring [k] and key[i] == ring[j];\\nOtherwise f(i, j) = sys.maxsize. \\n\\nans = min(f(len(key - 1), j) for j in range(len(ring))) + presses\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(m * n^2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(mn)$$\\n# Code\\n```\\nimport sys\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        m = len(key)\\n        n = len(ring)\\n        dp = [[sys.maxsize for i in range(n)] for j in range(m)]\\n        for i, c in enumerate(ring):\\n            if c == key[0]:\\n                dp[0][i] = min(i, n - i)\\n        \\n        for i in range(1, m):\\n            for j in range(n):\\n                if key[i] == ring[j]:\\n                    for k in range(n):\\n                        if key[i - 1] == ring[k]:\\n                            dp[i][j] = min(dp[i][j], dp[i - 1][k] + min(abs(j - k), n - abs(j - k)))\\n        \\n        return min(dp[m - 1]) + m\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nf(i, j) = min(f(i - 1, k) + move(k, j)) if key[i - 1] == ring [k] and key[i] == ring[j];\\nOtherwise f(i, j) = sys.maxsize. \\n\\nans = min(f(len(key - 1), j) for j in range(len(ring))) + presses\\n```\n```\\nimport sys\\nclass Solution:\\n    def findRotateSteps(self, ring: str, key: str) -> int:\\n        m = len(key)\\n        n = len(ring)\\n        dp = [[sys.maxsize for i in range(n)] for j in range(m)]\\n        for i, c in enumerate(ring):\\n            if c == key[0]:\\n                dp[0][i] = min(i, n - i)\\n        \\n        for i in range(1, m):\\n            for j in range(n):\\n                if key[i] == ring[j]:\\n                    for k in range(n):\\n                        if key[i - 1] == ring[k]:\\n                            dp[i][j] = min(dp[i][j], dp[i - 1][k] + min(abs(j - k), n - abs(j - k)))\\n        \\n        return min(dp[m - 1]) + m\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567272,
                "content": [
                    {
                        "username": "zqfan",
                        "content": "otherwise there will be a tag named \"Dynamic Programming\" with only this problem, rather than merged with other Dynamic Programming problems."
                    },
                    {
                        "username": "shaw1331",
                        "content": "Why isnt this a greedy problem?\\nThat we greedily choose whether to rotate clockwise or anticlockwise from current position and choose the closest next character of key required?"
                    },
                    {
                        "username": "sphericalXenox",
                        "content": "That will not be optimal, because we need to minimise the total number of steps. It is possible that the next characters take more steps from the closest character.\\n\\neg: with ring as abcdefghc and key as cde, choosing the further c would have a minimum number of total steps as we will have fewer steps for d and e"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> memo;\\n    int helper_fn(string& ring, string& key, int ring_pos, int key_pos) {\\n        if (key_pos >= key.size()) return 0;\\n        int cost = INT_MAX, n = ring.size();\\n        if (memo[ring_pos][key_pos] > 0) {\\n                return memo[ring_pos][key_pos];\\n        }\\n        /// it\\'s dp, not greedy, because you don\\'t know what\\'s comming though\\n        for (int j = 0, i = ring_pos; j < n; ++i, ++j) {\\n            if (i >= n) i = 0;\\n            if (ring[i] == key[key_pos]) {\\n                cost = min(cost,min(j,n-j)+1+helper_fn(ring,key,i,key_pos+1));\\n            }\\n        }\\n        memo[ring_pos][key_pos] = cost;\\n        return cost;\\n    }\\n    \\n    int findRotateSteps(string ring, string key) {\\n        int n = ring.size(), m = key.size();\\n        memo = vector<vector<int>>(n,vector<int>(m,0));\\n        return helper_fn(ring,key,0,0);\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2042675,
                "content": [
                    {
                        "username": "zqfan",
                        "content": "otherwise there will be a tag named \"Dynamic Programming\" with only this problem, rather than merged with other Dynamic Programming problems."
                    },
                    {
                        "username": "shaw1331",
                        "content": "Why isnt this a greedy problem?\\nThat we greedily choose whether to rotate clockwise or anticlockwise from current position and choose the closest next character of key required?"
                    },
                    {
                        "username": "sphericalXenox",
                        "content": "That will not be optimal, because we need to minimise the total number of steps. It is possible that the next characters take more steps from the closest character.\\n\\neg: with ring as abcdefghc and key as cde, choosing the further c would have a minimum number of total steps as we will have fewer steps for d and e"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> memo;\\n    int helper_fn(string& ring, string& key, int ring_pos, int key_pos) {\\n        if (key_pos >= key.size()) return 0;\\n        int cost = INT_MAX, n = ring.size();\\n        if (memo[ring_pos][key_pos] > 0) {\\n                return memo[ring_pos][key_pos];\\n        }\\n        /// it\\'s dp, not greedy, because you don\\'t know what\\'s comming though\\n        for (int j = 0, i = ring_pos; j < n; ++i, ++j) {\\n            if (i >= n) i = 0;\\n            if (ring[i] == key[key_pos]) {\\n                cost = min(cost,min(j,n-j)+1+helper_fn(ring,key,i,key_pos+1));\\n            }\\n        }\\n        memo[ring_pos][key_pos] = cost;\\n        return cost;\\n    }\\n    \\n    int findRotateSteps(string ring, string key) {\\n        int n = ring.size(), m = key.size();\\n        memo = vector<vector<int>>(n,vector<int>(m,0));\\n        return helper_fn(ring,key,0,0);\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1764208,
                "content": [
                    {
                        "username": "zqfan",
                        "content": "otherwise there will be a tag named \"Dynamic Programming\" with only this problem, rather than merged with other Dynamic Programming problems."
                    },
                    {
                        "username": "shaw1331",
                        "content": "Why isnt this a greedy problem?\\nThat we greedily choose whether to rotate clockwise or anticlockwise from current position and choose the closest next character of key required?"
                    },
                    {
                        "username": "sphericalXenox",
                        "content": "That will not be optimal, because we need to minimise the total number of steps. It is possible that the next characters take more steps from the closest character.\\n\\neg: with ring as abcdefghc and key as cde, choosing the further c would have a minimum number of total steps as we will have fewer steps for d and e"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> memo;\\n    int helper_fn(string& ring, string& key, int ring_pos, int key_pos) {\\n        if (key_pos >= key.size()) return 0;\\n        int cost = INT_MAX, n = ring.size();\\n        if (memo[ring_pos][key_pos] > 0) {\\n                return memo[ring_pos][key_pos];\\n        }\\n        /// it\\'s dp, not greedy, because you don\\'t know what\\'s comming though\\n        for (int j = 0, i = ring_pos; j < n; ++i, ++j) {\\n            if (i >= n) i = 0;\\n            if (ring[i] == key[key_pos]) {\\n                cost = min(cost,min(j,n-j)+1+helper_fn(ring,key,i,key_pos+1));\\n            }\\n        }\\n        memo[ring_pos][key_pos] = cost;\\n        return cost;\\n    }\\n    \\n    int findRotateSteps(string ring, string key) {\\n        int n = ring.size(), m = key.size();\\n        memo = vector<vector<int>>(n,vector<int>(m,0));\\n        return helper_fn(ring,key,0,0);\\n    }\\n};\\n```"
                    }
                ]
            }
        ]
    },
    {
        "title": "Average Salary: Departments VS Company",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1574961,
                "content": [
                    {
                        "username": "CharlesLoveStudy",
                        "content": "# Write your MySQL query statement below\\nWITH tb1 AS(SELECT LEFT(pay_date,7) AS pay_month, department_id,\\nAVG(amount) OVER(PARTITION BY LEFT(pay_date,7),department_id) AS dept_avg_amount,\\nAVG(amount) OVER(PARTITION BY LEFT(pay_date,7)) AS company_avg_amount\\nFROM salary s JOIN employee e ON s.employee_id=e.employee_id)\\n\\nSELECT DISTINCT pay_month, department_id,\\n(CASE WHEN dept_avg_amount<company_avg_amount THEN \\'lower\\'\\n      WHEN dept_avg_amount>company_avg_amount THEN \\'higher\\'\\n ELSE \\'same\\'\\n END) AS comparison\\nFROM tb1\\n"
                    },
                    {
                        "username": "pawelofficial",
                        "content": "as always the wording of the question is terrible. The report should contain comparison of monthly salaries per department vs monthly salaries for whole company."
                    },
                    {
                        "username": "zedzogrind",
                        "content": "awfully written question?"
                    },
                    {
                        "username": "Cyue0813",
                        "content": "Question: Why I delete avg1 and avg_d, the output will change to an incorrect answer? But, if I add them, the comparison is correct. \\n\\nCODE:\\n\\nWITH average AS (SELECT DISTINCT DATE_FORMAT(pay_date, \\'%Y-%m\\') AS pay_month, AVG(amount)OVER(partition by pay_date) AS avg1\\nFROM Salary AS s),\\nunion_all AS(\\n  SELECT DISTINCT DATE_FORMAT(pay_date, \\'%Y-%m\\') AS pay_month, s.employee_id, e.department_id, avg(amount)over(partition by department_id, pay_date) AS avg_d\\n  FROM Salary AS s\\n  JOIN Employee AS e\\n  ON s.employee_id = e.employee_id\\n)\\nSELECT a.pay_month, u.department_id, avg1, avg_d,\\nCASE WHEN avg_d > avg1 THEN \\'higher\\'\\n         WHEN avg_d < avg1 THEN \\'lower\\'\\n         ELSE \\'same\\' \\nEND AS comparison\\nFROM average AS a\\nLEFT JOIN union_all AS u\\nON a.pay_month = u.pay_month \\nGROUP BY  a.pay_month, u.department_id\\nORDER BY  u.department_id, a.pay_month"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "Simple Solution Using CTE (SQL SERVER)\\nwith avg_company_salary as\\n(select s.employee_id, department_id, amount, pay_date\\n  ,avg(amount) over (partition by pay_date)avg_company_salary\\n     from salary s\\n       join employee e on s.employee_id = e.employee_id)\\n\\n,avg_dept_salary as\\n(select department_id, pay_date\\n  ,avg(amount) over \\n     (partition by pay_date, department_id)avg_dept_salary,\\n         cast(avg_company_salary as float)avg_company_salary from avg_company_salary)\\n\\nselect distinct \\n  concat(datepart(year, pay_date),\\'-\\', RIGHT(CONCAT(\\'0\\', MONTH([pay_date])), 2))\\n    pay_month,  \\n      department_id,\\n    ( case \\n      when avg_dept_salary > avg_company_salary then \\'higher\\'\\n        when avg_dept_salary < avg_company_salary then \\'lower\\'\\n          else \\'same\\' end) comparison\\n            from avg_dept_salary"
                    },
                    {
                        "username": "Kurt1999",
                        "content": "select distinct date_format(pay_date,\\'%Y-%m\\') as pay_month, department_id, case when avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\')) - avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\'), department_id) > 0 then \\'lower\\'\\nwhen  avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\')) - avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\'), department_id) < 0 then \\'higher\\'\\nelse \\'same\\' end as comparison\\nfrom Salary S\\nleft join Employee E\\non S.employee_id = E.employee_id;"
                    },
                    {
                        "username": "kjcooper17",
                        "content": "Adding group by elements messes up window function calculation?\\n\\nIf I run this without department_id, pay_date (also remove group by) this calculates the right values, when I add them it screws it up, how come?\\n\\nselect\\ndepartment_id,\\npay_date,\\navg(amount) over (partition by a.pay_date,b.department_id) as dept_salary,\\navg(amount) over (partition by a.pay_date) as salary\\nfrom Salary a \\nleft join Employee b on a.employee_id = b.employee_id\\ngroup by 1,2 @"
                    },
                    {
                        "username": "novicewhistler",
                        "content": "Could anyone help me in debugging this? Not able to see the bug for the life of me -_-.\\n\\nMy code is \\n `\\nwith enhanced_salary_table as (\\n    select \\n        date_format(pay_date, \\'%Y-%m\\') as pay_month ,\\n        Employee.department_id,\\n        Salary.amount\\n    from Salary\\n    left join Employee\\n    on Salary.employee_id = Employee.employee_id\\n),\\nmonthly_org_avg as (\\n    select \\n        date_format(pay_date, \\'%Y-%m\\') as pay_month ,\\n        avg(Salary.amount) as org_avg_salary\\n    from Salary\\n    group by pay_month\\n)\\n\\nselect \\n    enhanced_salary_table.pay_month,\\n    enhanced_salary_table.department_id,\\n    case \\n        when avg(enhanced_salary_table.amount) < monthly_org_avg.org_avg_salary then \"lower\"\\n        when avg(enhanced_salary_table.amount) > monthly_org_avg.org_avg_salary then \"higher\"\\n        else \"same\" \\n    end as comparison\\nfrom enhanced_salary_table\\nleft join monthly_org_avg \\non enhanced_salary_table.pay_month = monthly_org_avg.pay_month\\ngroup by enhanced_salary_table.pay_month, enhanced_salary_table.department_id;\\n\\n`\\n\\nI fail the last test case where \\nSalary =\\n| id | employee_id | amount | pay_date   |\\n| -- | ----------- | ------ | ---------- |\\n| 1  | 1           | 9000   | 2017/03/31 |\\n| 2  | 2           | 6000   | 2017/03/31 |\\n| 3  | 3           | 10000  | 2017/03/31 |\\n| 4  | 1           | 7000   | 2017/02/26 |\\n| 5  | 2           | 6000   | 2017/02/27 |\\n| 6  | 3           | 8000   | 2017/02/22 |\\n\\n\\nEmployee =\\n| employee_id | department_id |\\n| ----------- | ------------- |\\n| 1           | 1             |\\n| 2           | 1             |\\n| 3           | 1             |\\n\\n\\nExpected\\n\\n| pay_month | department_id | comparison |\\n| --------- | ------------- | ---------- |\\n| 2017-02   | 1             | same       |\\n| 2017-03   | 1             | same       |\\n\\n\\nOutput\\n\\n| pay_month | department_id | comparison |\\n| --------- | ------------- | ---------- |\\n| 2017-03   | 1             | higher     |\\n| 2017-02   | 1             | same       |\\n\\n\\n\\nNo clue why I have higher in the comparison, where it should have been same. "
                    },
                    {
                        "username": "jfmsouza",
                        "content": "[@user1415gR](/user1415gR) round() worked for me! Thanks!"
                    },
                    {
                        "username": "user1415gR",
                        "content": "This is maybe due to the decimals. trying to use round() function in your case when clause, maybe it can help(you don\\'t know what would be showed in the endless decimals, so give a limitation)"
                    }
                ]
            },
            {
                "id": 2073332,
                "content": [
                    {
                        "username": "CharlesLoveStudy",
                        "content": "# Write your MySQL query statement below\\nWITH tb1 AS(SELECT LEFT(pay_date,7) AS pay_month, department_id,\\nAVG(amount) OVER(PARTITION BY LEFT(pay_date,7),department_id) AS dept_avg_amount,\\nAVG(amount) OVER(PARTITION BY LEFT(pay_date,7)) AS company_avg_amount\\nFROM salary s JOIN employee e ON s.employee_id=e.employee_id)\\n\\nSELECT DISTINCT pay_month, department_id,\\n(CASE WHEN dept_avg_amount<company_avg_amount THEN \\'lower\\'\\n      WHEN dept_avg_amount>company_avg_amount THEN \\'higher\\'\\n ELSE \\'same\\'\\n END) AS comparison\\nFROM tb1\\n"
                    },
                    {
                        "username": "pawelofficial",
                        "content": "as always the wording of the question is terrible. The report should contain comparison of monthly salaries per department vs monthly salaries for whole company."
                    },
                    {
                        "username": "zedzogrind",
                        "content": "awfully written question?"
                    },
                    {
                        "username": "Cyue0813",
                        "content": "Question: Why I delete avg1 and avg_d, the output will change to an incorrect answer? But, if I add them, the comparison is correct. \\n\\nCODE:\\n\\nWITH average AS (SELECT DISTINCT DATE_FORMAT(pay_date, \\'%Y-%m\\') AS pay_month, AVG(amount)OVER(partition by pay_date) AS avg1\\nFROM Salary AS s),\\nunion_all AS(\\n  SELECT DISTINCT DATE_FORMAT(pay_date, \\'%Y-%m\\') AS pay_month, s.employee_id, e.department_id, avg(amount)over(partition by department_id, pay_date) AS avg_d\\n  FROM Salary AS s\\n  JOIN Employee AS e\\n  ON s.employee_id = e.employee_id\\n)\\nSELECT a.pay_month, u.department_id, avg1, avg_d,\\nCASE WHEN avg_d > avg1 THEN \\'higher\\'\\n         WHEN avg_d < avg1 THEN \\'lower\\'\\n         ELSE \\'same\\' \\nEND AS comparison\\nFROM average AS a\\nLEFT JOIN union_all AS u\\nON a.pay_month = u.pay_month \\nGROUP BY  a.pay_month, u.department_id\\nORDER BY  u.department_id, a.pay_month"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "Simple Solution Using CTE (SQL SERVER)\\nwith avg_company_salary as\\n(select s.employee_id, department_id, amount, pay_date\\n  ,avg(amount) over (partition by pay_date)avg_company_salary\\n     from salary s\\n       join employee e on s.employee_id = e.employee_id)\\n\\n,avg_dept_salary as\\n(select department_id, pay_date\\n  ,avg(amount) over \\n     (partition by pay_date, department_id)avg_dept_salary,\\n         cast(avg_company_salary as float)avg_company_salary from avg_company_salary)\\n\\nselect distinct \\n  concat(datepart(year, pay_date),\\'-\\', RIGHT(CONCAT(\\'0\\', MONTH([pay_date])), 2))\\n    pay_month,  \\n      department_id,\\n    ( case \\n      when avg_dept_salary > avg_company_salary then \\'higher\\'\\n        when avg_dept_salary < avg_company_salary then \\'lower\\'\\n          else \\'same\\' end) comparison\\n            from avg_dept_salary"
                    },
                    {
                        "username": "Kurt1999",
                        "content": "select distinct date_format(pay_date,\\'%Y-%m\\') as pay_month, department_id, case when avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\')) - avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\'), department_id) > 0 then \\'lower\\'\\nwhen  avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\')) - avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\'), department_id) < 0 then \\'higher\\'\\nelse \\'same\\' end as comparison\\nfrom Salary S\\nleft join Employee E\\non S.employee_id = E.employee_id;"
                    },
                    {
                        "username": "kjcooper17",
                        "content": "Adding group by elements messes up window function calculation?\\n\\nIf I run this without department_id, pay_date (also remove group by) this calculates the right values, when I add them it screws it up, how come?\\n\\nselect\\ndepartment_id,\\npay_date,\\navg(amount) over (partition by a.pay_date,b.department_id) as dept_salary,\\navg(amount) over (partition by a.pay_date) as salary\\nfrom Salary a \\nleft join Employee b on a.employee_id = b.employee_id\\ngroup by 1,2 @"
                    },
                    {
                        "username": "novicewhistler",
                        "content": "Could anyone help me in debugging this? Not able to see the bug for the life of me -_-.\\n\\nMy code is \\n `\\nwith enhanced_salary_table as (\\n    select \\n        date_format(pay_date, \\'%Y-%m\\') as pay_month ,\\n        Employee.department_id,\\n        Salary.amount\\n    from Salary\\n    left join Employee\\n    on Salary.employee_id = Employee.employee_id\\n),\\nmonthly_org_avg as (\\n    select \\n        date_format(pay_date, \\'%Y-%m\\') as pay_month ,\\n        avg(Salary.amount) as org_avg_salary\\n    from Salary\\n    group by pay_month\\n)\\n\\nselect \\n    enhanced_salary_table.pay_month,\\n    enhanced_salary_table.department_id,\\n    case \\n        when avg(enhanced_salary_table.amount) < monthly_org_avg.org_avg_salary then \"lower\"\\n        when avg(enhanced_salary_table.amount) > monthly_org_avg.org_avg_salary then \"higher\"\\n        else \"same\" \\n    end as comparison\\nfrom enhanced_salary_table\\nleft join monthly_org_avg \\non enhanced_salary_table.pay_month = monthly_org_avg.pay_month\\ngroup by enhanced_salary_table.pay_month, enhanced_salary_table.department_id;\\n\\n`\\n\\nI fail the last test case where \\nSalary =\\n| id | employee_id | amount | pay_date   |\\n| -- | ----------- | ------ | ---------- |\\n| 1  | 1           | 9000   | 2017/03/31 |\\n| 2  | 2           | 6000   | 2017/03/31 |\\n| 3  | 3           | 10000  | 2017/03/31 |\\n| 4  | 1           | 7000   | 2017/02/26 |\\n| 5  | 2           | 6000   | 2017/02/27 |\\n| 6  | 3           | 8000   | 2017/02/22 |\\n\\n\\nEmployee =\\n| employee_id | department_id |\\n| ----------- | ------------- |\\n| 1           | 1             |\\n| 2           | 1             |\\n| 3           | 1             |\\n\\n\\nExpected\\n\\n| pay_month | department_id | comparison |\\n| --------- | ------------- | ---------- |\\n| 2017-02   | 1             | same       |\\n| 2017-03   | 1             | same       |\\n\\n\\nOutput\\n\\n| pay_month | department_id | comparison |\\n| --------- | ------------- | ---------- |\\n| 2017-03   | 1             | higher     |\\n| 2017-02   | 1             | same       |\\n\\n\\n\\nNo clue why I have higher in the comparison, where it should have been same. "
                    },
                    {
                        "username": "jfmsouza",
                        "content": "[@user1415gR](/user1415gR) round() worked for me! Thanks!"
                    },
                    {
                        "username": "user1415gR",
                        "content": "This is maybe due to the decimals. trying to use round() function in your case when clause, maybe it can help(you don\\'t know what would be showed in the endless decimals, so give a limitation)"
                    }
                ]
            },
            {
                "id": 2049872,
                "content": [
                    {
                        "username": "CharlesLoveStudy",
                        "content": "# Write your MySQL query statement below\\nWITH tb1 AS(SELECT LEFT(pay_date,7) AS pay_month, department_id,\\nAVG(amount) OVER(PARTITION BY LEFT(pay_date,7),department_id) AS dept_avg_amount,\\nAVG(amount) OVER(PARTITION BY LEFT(pay_date,7)) AS company_avg_amount\\nFROM salary s JOIN employee e ON s.employee_id=e.employee_id)\\n\\nSELECT DISTINCT pay_month, department_id,\\n(CASE WHEN dept_avg_amount<company_avg_amount THEN \\'lower\\'\\n      WHEN dept_avg_amount>company_avg_amount THEN \\'higher\\'\\n ELSE \\'same\\'\\n END) AS comparison\\nFROM tb1\\n"
                    },
                    {
                        "username": "pawelofficial",
                        "content": "as always the wording of the question is terrible. The report should contain comparison of monthly salaries per department vs monthly salaries for whole company."
                    },
                    {
                        "username": "zedzogrind",
                        "content": "awfully written question?"
                    },
                    {
                        "username": "Cyue0813",
                        "content": "Question: Why I delete avg1 and avg_d, the output will change to an incorrect answer? But, if I add them, the comparison is correct. \\n\\nCODE:\\n\\nWITH average AS (SELECT DISTINCT DATE_FORMAT(pay_date, \\'%Y-%m\\') AS pay_month, AVG(amount)OVER(partition by pay_date) AS avg1\\nFROM Salary AS s),\\nunion_all AS(\\n  SELECT DISTINCT DATE_FORMAT(pay_date, \\'%Y-%m\\') AS pay_month, s.employee_id, e.department_id, avg(amount)over(partition by department_id, pay_date) AS avg_d\\n  FROM Salary AS s\\n  JOIN Employee AS e\\n  ON s.employee_id = e.employee_id\\n)\\nSELECT a.pay_month, u.department_id, avg1, avg_d,\\nCASE WHEN avg_d > avg1 THEN \\'higher\\'\\n         WHEN avg_d < avg1 THEN \\'lower\\'\\n         ELSE \\'same\\' \\nEND AS comparison\\nFROM average AS a\\nLEFT JOIN union_all AS u\\nON a.pay_month = u.pay_month \\nGROUP BY  a.pay_month, u.department_id\\nORDER BY  u.department_id, a.pay_month"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "Simple Solution Using CTE (SQL SERVER)\\nwith avg_company_salary as\\n(select s.employee_id, department_id, amount, pay_date\\n  ,avg(amount) over (partition by pay_date)avg_company_salary\\n     from salary s\\n       join employee e on s.employee_id = e.employee_id)\\n\\n,avg_dept_salary as\\n(select department_id, pay_date\\n  ,avg(amount) over \\n     (partition by pay_date, department_id)avg_dept_salary,\\n         cast(avg_company_salary as float)avg_company_salary from avg_company_salary)\\n\\nselect distinct \\n  concat(datepart(year, pay_date),\\'-\\', RIGHT(CONCAT(\\'0\\', MONTH([pay_date])), 2))\\n    pay_month,  \\n      department_id,\\n    ( case \\n      when avg_dept_salary > avg_company_salary then \\'higher\\'\\n        when avg_dept_salary < avg_company_salary then \\'lower\\'\\n          else \\'same\\' end) comparison\\n            from avg_dept_salary"
                    },
                    {
                        "username": "Kurt1999",
                        "content": "select distinct date_format(pay_date,\\'%Y-%m\\') as pay_month, department_id, case when avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\')) - avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\'), department_id) > 0 then \\'lower\\'\\nwhen  avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\')) - avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\'), department_id) < 0 then \\'higher\\'\\nelse \\'same\\' end as comparison\\nfrom Salary S\\nleft join Employee E\\non S.employee_id = E.employee_id;"
                    },
                    {
                        "username": "kjcooper17",
                        "content": "Adding group by elements messes up window function calculation?\\n\\nIf I run this without department_id, pay_date (also remove group by) this calculates the right values, when I add them it screws it up, how come?\\n\\nselect\\ndepartment_id,\\npay_date,\\navg(amount) over (partition by a.pay_date,b.department_id) as dept_salary,\\navg(amount) over (partition by a.pay_date) as salary\\nfrom Salary a \\nleft join Employee b on a.employee_id = b.employee_id\\ngroup by 1,2 @"
                    },
                    {
                        "username": "novicewhistler",
                        "content": "Could anyone help me in debugging this? Not able to see the bug for the life of me -_-.\\n\\nMy code is \\n `\\nwith enhanced_salary_table as (\\n    select \\n        date_format(pay_date, \\'%Y-%m\\') as pay_month ,\\n        Employee.department_id,\\n        Salary.amount\\n    from Salary\\n    left join Employee\\n    on Salary.employee_id = Employee.employee_id\\n),\\nmonthly_org_avg as (\\n    select \\n        date_format(pay_date, \\'%Y-%m\\') as pay_month ,\\n        avg(Salary.amount) as org_avg_salary\\n    from Salary\\n    group by pay_month\\n)\\n\\nselect \\n    enhanced_salary_table.pay_month,\\n    enhanced_salary_table.department_id,\\n    case \\n        when avg(enhanced_salary_table.amount) < monthly_org_avg.org_avg_salary then \"lower\"\\n        when avg(enhanced_salary_table.amount) > monthly_org_avg.org_avg_salary then \"higher\"\\n        else \"same\" \\n    end as comparison\\nfrom enhanced_salary_table\\nleft join monthly_org_avg \\non enhanced_salary_table.pay_month = monthly_org_avg.pay_month\\ngroup by enhanced_salary_table.pay_month, enhanced_salary_table.department_id;\\n\\n`\\n\\nI fail the last test case where \\nSalary =\\n| id | employee_id | amount | pay_date   |\\n| -- | ----------- | ------ | ---------- |\\n| 1  | 1           | 9000   | 2017/03/31 |\\n| 2  | 2           | 6000   | 2017/03/31 |\\n| 3  | 3           | 10000  | 2017/03/31 |\\n| 4  | 1           | 7000   | 2017/02/26 |\\n| 5  | 2           | 6000   | 2017/02/27 |\\n| 6  | 3           | 8000   | 2017/02/22 |\\n\\n\\nEmployee =\\n| employee_id | department_id |\\n| ----------- | ------------- |\\n| 1           | 1             |\\n| 2           | 1             |\\n| 3           | 1             |\\n\\n\\nExpected\\n\\n| pay_month | department_id | comparison |\\n| --------- | ------------- | ---------- |\\n| 2017-02   | 1             | same       |\\n| 2017-03   | 1             | same       |\\n\\n\\nOutput\\n\\n| pay_month | department_id | comparison |\\n| --------- | ------------- | ---------- |\\n| 2017-03   | 1             | higher     |\\n| 2017-02   | 1             | same       |\\n\\n\\n\\nNo clue why I have higher in the comparison, where it should have been same. "
                    },
                    {
                        "username": "jfmsouza",
                        "content": "[@user1415gR](/user1415gR) round() worked for me! Thanks!"
                    },
                    {
                        "username": "user1415gR",
                        "content": "This is maybe due to the decimals. trying to use round() function in your case when clause, maybe it can help(you don\\'t know what would be showed in the endless decimals, so give a limitation)"
                    }
                ]
            },
            {
                "id": 1890405,
                "content": [
                    {
                        "username": "CharlesLoveStudy",
                        "content": "# Write your MySQL query statement below\\nWITH tb1 AS(SELECT LEFT(pay_date,7) AS pay_month, department_id,\\nAVG(amount) OVER(PARTITION BY LEFT(pay_date,7),department_id) AS dept_avg_amount,\\nAVG(amount) OVER(PARTITION BY LEFT(pay_date,7)) AS company_avg_amount\\nFROM salary s JOIN employee e ON s.employee_id=e.employee_id)\\n\\nSELECT DISTINCT pay_month, department_id,\\n(CASE WHEN dept_avg_amount<company_avg_amount THEN \\'lower\\'\\n      WHEN dept_avg_amount>company_avg_amount THEN \\'higher\\'\\n ELSE \\'same\\'\\n END) AS comparison\\nFROM tb1\\n"
                    },
                    {
                        "username": "pawelofficial",
                        "content": "as always the wording of the question is terrible. The report should contain comparison of monthly salaries per department vs monthly salaries for whole company."
                    },
                    {
                        "username": "zedzogrind",
                        "content": "awfully written question?"
                    },
                    {
                        "username": "Cyue0813",
                        "content": "Question: Why I delete avg1 and avg_d, the output will change to an incorrect answer? But, if I add them, the comparison is correct. \\n\\nCODE:\\n\\nWITH average AS (SELECT DISTINCT DATE_FORMAT(pay_date, \\'%Y-%m\\') AS pay_month, AVG(amount)OVER(partition by pay_date) AS avg1\\nFROM Salary AS s),\\nunion_all AS(\\n  SELECT DISTINCT DATE_FORMAT(pay_date, \\'%Y-%m\\') AS pay_month, s.employee_id, e.department_id, avg(amount)over(partition by department_id, pay_date) AS avg_d\\n  FROM Salary AS s\\n  JOIN Employee AS e\\n  ON s.employee_id = e.employee_id\\n)\\nSELECT a.pay_month, u.department_id, avg1, avg_d,\\nCASE WHEN avg_d > avg1 THEN \\'higher\\'\\n         WHEN avg_d < avg1 THEN \\'lower\\'\\n         ELSE \\'same\\' \\nEND AS comparison\\nFROM average AS a\\nLEFT JOIN union_all AS u\\nON a.pay_month = u.pay_month \\nGROUP BY  a.pay_month, u.department_id\\nORDER BY  u.department_id, a.pay_month"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "Simple Solution Using CTE (SQL SERVER)\\nwith avg_company_salary as\\n(select s.employee_id, department_id, amount, pay_date\\n  ,avg(amount) over (partition by pay_date)avg_company_salary\\n     from salary s\\n       join employee e on s.employee_id = e.employee_id)\\n\\n,avg_dept_salary as\\n(select department_id, pay_date\\n  ,avg(amount) over \\n     (partition by pay_date, department_id)avg_dept_salary,\\n         cast(avg_company_salary as float)avg_company_salary from avg_company_salary)\\n\\nselect distinct \\n  concat(datepart(year, pay_date),\\'-\\', RIGHT(CONCAT(\\'0\\', MONTH([pay_date])), 2))\\n    pay_month,  \\n      department_id,\\n    ( case \\n      when avg_dept_salary > avg_company_salary then \\'higher\\'\\n        when avg_dept_salary < avg_company_salary then \\'lower\\'\\n          else \\'same\\' end) comparison\\n            from avg_dept_salary"
                    },
                    {
                        "username": "Kurt1999",
                        "content": "select distinct date_format(pay_date,\\'%Y-%m\\') as pay_month, department_id, case when avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\')) - avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\'), department_id) > 0 then \\'lower\\'\\nwhen  avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\')) - avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\'), department_id) < 0 then \\'higher\\'\\nelse \\'same\\' end as comparison\\nfrom Salary S\\nleft join Employee E\\non S.employee_id = E.employee_id;"
                    },
                    {
                        "username": "kjcooper17",
                        "content": "Adding group by elements messes up window function calculation?\\n\\nIf I run this without department_id, pay_date (also remove group by) this calculates the right values, when I add them it screws it up, how come?\\n\\nselect\\ndepartment_id,\\npay_date,\\navg(amount) over (partition by a.pay_date,b.department_id) as dept_salary,\\navg(amount) over (partition by a.pay_date) as salary\\nfrom Salary a \\nleft join Employee b on a.employee_id = b.employee_id\\ngroup by 1,2 @"
                    },
                    {
                        "username": "novicewhistler",
                        "content": "Could anyone help me in debugging this? Not able to see the bug for the life of me -_-.\\n\\nMy code is \\n `\\nwith enhanced_salary_table as (\\n    select \\n        date_format(pay_date, \\'%Y-%m\\') as pay_month ,\\n        Employee.department_id,\\n        Salary.amount\\n    from Salary\\n    left join Employee\\n    on Salary.employee_id = Employee.employee_id\\n),\\nmonthly_org_avg as (\\n    select \\n        date_format(pay_date, \\'%Y-%m\\') as pay_month ,\\n        avg(Salary.amount) as org_avg_salary\\n    from Salary\\n    group by pay_month\\n)\\n\\nselect \\n    enhanced_salary_table.pay_month,\\n    enhanced_salary_table.department_id,\\n    case \\n        when avg(enhanced_salary_table.amount) < monthly_org_avg.org_avg_salary then \"lower\"\\n        when avg(enhanced_salary_table.amount) > monthly_org_avg.org_avg_salary then \"higher\"\\n        else \"same\" \\n    end as comparison\\nfrom enhanced_salary_table\\nleft join monthly_org_avg \\non enhanced_salary_table.pay_month = monthly_org_avg.pay_month\\ngroup by enhanced_salary_table.pay_month, enhanced_salary_table.department_id;\\n\\n`\\n\\nI fail the last test case where \\nSalary =\\n| id | employee_id | amount | pay_date   |\\n| -- | ----------- | ------ | ---------- |\\n| 1  | 1           | 9000   | 2017/03/31 |\\n| 2  | 2           | 6000   | 2017/03/31 |\\n| 3  | 3           | 10000  | 2017/03/31 |\\n| 4  | 1           | 7000   | 2017/02/26 |\\n| 5  | 2           | 6000   | 2017/02/27 |\\n| 6  | 3           | 8000   | 2017/02/22 |\\n\\n\\nEmployee =\\n| employee_id | department_id |\\n| ----------- | ------------- |\\n| 1           | 1             |\\n| 2           | 1             |\\n| 3           | 1             |\\n\\n\\nExpected\\n\\n| pay_month | department_id | comparison |\\n| --------- | ------------- | ---------- |\\n| 2017-02   | 1             | same       |\\n| 2017-03   | 1             | same       |\\n\\n\\nOutput\\n\\n| pay_month | department_id | comparison |\\n| --------- | ------------- | ---------- |\\n| 2017-03   | 1             | higher     |\\n| 2017-02   | 1             | same       |\\n\\n\\n\\nNo clue why I have higher in the comparison, where it should have been same. "
                    },
                    {
                        "username": "jfmsouza",
                        "content": "[@user1415gR](/user1415gR) round() worked for me! Thanks!"
                    },
                    {
                        "username": "user1415gR",
                        "content": "This is maybe due to the decimals. trying to use round() function in your case when clause, maybe it can help(you don\\'t know what would be showed in the endless decimals, so give a limitation)"
                    }
                ]
            },
            {
                "id": 1738119,
                "content": [
                    {
                        "username": "CharlesLoveStudy",
                        "content": "# Write your MySQL query statement below\\nWITH tb1 AS(SELECT LEFT(pay_date,7) AS pay_month, department_id,\\nAVG(amount) OVER(PARTITION BY LEFT(pay_date,7),department_id) AS dept_avg_amount,\\nAVG(amount) OVER(PARTITION BY LEFT(pay_date,7)) AS company_avg_amount\\nFROM salary s JOIN employee e ON s.employee_id=e.employee_id)\\n\\nSELECT DISTINCT pay_month, department_id,\\n(CASE WHEN dept_avg_amount<company_avg_amount THEN \\'lower\\'\\n      WHEN dept_avg_amount>company_avg_amount THEN \\'higher\\'\\n ELSE \\'same\\'\\n END) AS comparison\\nFROM tb1\\n"
                    },
                    {
                        "username": "pawelofficial",
                        "content": "as always the wording of the question is terrible. The report should contain comparison of monthly salaries per department vs monthly salaries for whole company."
                    },
                    {
                        "username": "zedzogrind",
                        "content": "awfully written question?"
                    },
                    {
                        "username": "Cyue0813",
                        "content": "Question: Why I delete avg1 and avg_d, the output will change to an incorrect answer? But, if I add them, the comparison is correct. \\n\\nCODE:\\n\\nWITH average AS (SELECT DISTINCT DATE_FORMAT(pay_date, \\'%Y-%m\\') AS pay_month, AVG(amount)OVER(partition by pay_date) AS avg1\\nFROM Salary AS s),\\nunion_all AS(\\n  SELECT DISTINCT DATE_FORMAT(pay_date, \\'%Y-%m\\') AS pay_month, s.employee_id, e.department_id, avg(amount)over(partition by department_id, pay_date) AS avg_d\\n  FROM Salary AS s\\n  JOIN Employee AS e\\n  ON s.employee_id = e.employee_id\\n)\\nSELECT a.pay_month, u.department_id, avg1, avg_d,\\nCASE WHEN avg_d > avg1 THEN \\'higher\\'\\n         WHEN avg_d < avg1 THEN \\'lower\\'\\n         ELSE \\'same\\' \\nEND AS comparison\\nFROM average AS a\\nLEFT JOIN union_all AS u\\nON a.pay_month = u.pay_month \\nGROUP BY  a.pay_month, u.department_id\\nORDER BY  u.department_id, a.pay_month"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "Simple Solution Using CTE (SQL SERVER)\\nwith avg_company_salary as\\n(select s.employee_id, department_id, amount, pay_date\\n  ,avg(amount) over (partition by pay_date)avg_company_salary\\n     from salary s\\n       join employee e on s.employee_id = e.employee_id)\\n\\n,avg_dept_salary as\\n(select department_id, pay_date\\n  ,avg(amount) over \\n     (partition by pay_date, department_id)avg_dept_salary,\\n         cast(avg_company_salary as float)avg_company_salary from avg_company_salary)\\n\\nselect distinct \\n  concat(datepart(year, pay_date),\\'-\\', RIGHT(CONCAT(\\'0\\', MONTH([pay_date])), 2))\\n    pay_month,  \\n      department_id,\\n    ( case \\n      when avg_dept_salary > avg_company_salary then \\'higher\\'\\n        when avg_dept_salary < avg_company_salary then \\'lower\\'\\n          else \\'same\\' end) comparison\\n            from avg_dept_salary"
                    },
                    {
                        "username": "Kurt1999",
                        "content": "select distinct date_format(pay_date,\\'%Y-%m\\') as pay_month, department_id, case when avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\')) - avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\'), department_id) > 0 then \\'lower\\'\\nwhen  avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\')) - avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\'), department_id) < 0 then \\'higher\\'\\nelse \\'same\\' end as comparison\\nfrom Salary S\\nleft join Employee E\\non S.employee_id = E.employee_id;"
                    },
                    {
                        "username": "kjcooper17",
                        "content": "Adding group by elements messes up window function calculation?\\n\\nIf I run this without department_id, pay_date (also remove group by) this calculates the right values, when I add them it screws it up, how come?\\n\\nselect\\ndepartment_id,\\npay_date,\\navg(amount) over (partition by a.pay_date,b.department_id) as dept_salary,\\navg(amount) over (partition by a.pay_date) as salary\\nfrom Salary a \\nleft join Employee b on a.employee_id = b.employee_id\\ngroup by 1,2 @"
                    },
                    {
                        "username": "novicewhistler",
                        "content": "Could anyone help me in debugging this? Not able to see the bug for the life of me -_-.\\n\\nMy code is \\n `\\nwith enhanced_salary_table as (\\n    select \\n        date_format(pay_date, \\'%Y-%m\\') as pay_month ,\\n        Employee.department_id,\\n        Salary.amount\\n    from Salary\\n    left join Employee\\n    on Salary.employee_id = Employee.employee_id\\n),\\nmonthly_org_avg as (\\n    select \\n        date_format(pay_date, \\'%Y-%m\\') as pay_month ,\\n        avg(Salary.amount) as org_avg_salary\\n    from Salary\\n    group by pay_month\\n)\\n\\nselect \\n    enhanced_salary_table.pay_month,\\n    enhanced_salary_table.department_id,\\n    case \\n        when avg(enhanced_salary_table.amount) < monthly_org_avg.org_avg_salary then \"lower\"\\n        when avg(enhanced_salary_table.amount) > monthly_org_avg.org_avg_salary then \"higher\"\\n        else \"same\" \\n    end as comparison\\nfrom enhanced_salary_table\\nleft join monthly_org_avg \\non enhanced_salary_table.pay_month = monthly_org_avg.pay_month\\ngroup by enhanced_salary_table.pay_month, enhanced_salary_table.department_id;\\n\\n`\\n\\nI fail the last test case where \\nSalary =\\n| id | employee_id | amount | pay_date   |\\n| -- | ----------- | ------ | ---------- |\\n| 1  | 1           | 9000   | 2017/03/31 |\\n| 2  | 2           | 6000   | 2017/03/31 |\\n| 3  | 3           | 10000  | 2017/03/31 |\\n| 4  | 1           | 7000   | 2017/02/26 |\\n| 5  | 2           | 6000   | 2017/02/27 |\\n| 6  | 3           | 8000   | 2017/02/22 |\\n\\n\\nEmployee =\\n| employee_id | department_id |\\n| ----------- | ------------- |\\n| 1           | 1             |\\n| 2           | 1             |\\n| 3           | 1             |\\n\\n\\nExpected\\n\\n| pay_month | department_id | comparison |\\n| --------- | ------------- | ---------- |\\n| 2017-02   | 1             | same       |\\n| 2017-03   | 1             | same       |\\n\\n\\nOutput\\n\\n| pay_month | department_id | comparison |\\n| --------- | ------------- | ---------- |\\n| 2017-03   | 1             | higher     |\\n| 2017-02   | 1             | same       |\\n\\n\\n\\nNo clue why I have higher in the comparison, where it should have been same. "
                    },
                    {
                        "username": "jfmsouza",
                        "content": "[@user1415gR](/user1415gR) round() worked for me! Thanks!"
                    },
                    {
                        "username": "user1415gR",
                        "content": "This is maybe due to the decimals. trying to use round() function in your case when clause, maybe it can help(you don\\'t know what would be showed in the endless decimals, so give a limitation)"
                    }
                ]
            },
            {
                "id": 1698319,
                "content": [
                    {
                        "username": "CharlesLoveStudy",
                        "content": "# Write your MySQL query statement below\\nWITH tb1 AS(SELECT LEFT(pay_date,7) AS pay_month, department_id,\\nAVG(amount) OVER(PARTITION BY LEFT(pay_date,7),department_id) AS dept_avg_amount,\\nAVG(amount) OVER(PARTITION BY LEFT(pay_date,7)) AS company_avg_amount\\nFROM salary s JOIN employee e ON s.employee_id=e.employee_id)\\n\\nSELECT DISTINCT pay_month, department_id,\\n(CASE WHEN dept_avg_amount<company_avg_amount THEN \\'lower\\'\\n      WHEN dept_avg_amount>company_avg_amount THEN \\'higher\\'\\n ELSE \\'same\\'\\n END) AS comparison\\nFROM tb1\\n"
                    },
                    {
                        "username": "pawelofficial",
                        "content": "as always the wording of the question is terrible. The report should contain comparison of monthly salaries per department vs monthly salaries for whole company."
                    },
                    {
                        "username": "zedzogrind",
                        "content": "awfully written question?"
                    },
                    {
                        "username": "Cyue0813",
                        "content": "Question: Why I delete avg1 and avg_d, the output will change to an incorrect answer? But, if I add them, the comparison is correct. \\n\\nCODE:\\n\\nWITH average AS (SELECT DISTINCT DATE_FORMAT(pay_date, \\'%Y-%m\\') AS pay_month, AVG(amount)OVER(partition by pay_date) AS avg1\\nFROM Salary AS s),\\nunion_all AS(\\n  SELECT DISTINCT DATE_FORMAT(pay_date, \\'%Y-%m\\') AS pay_month, s.employee_id, e.department_id, avg(amount)over(partition by department_id, pay_date) AS avg_d\\n  FROM Salary AS s\\n  JOIN Employee AS e\\n  ON s.employee_id = e.employee_id\\n)\\nSELECT a.pay_month, u.department_id, avg1, avg_d,\\nCASE WHEN avg_d > avg1 THEN \\'higher\\'\\n         WHEN avg_d < avg1 THEN \\'lower\\'\\n         ELSE \\'same\\' \\nEND AS comparison\\nFROM average AS a\\nLEFT JOIN union_all AS u\\nON a.pay_month = u.pay_month \\nGROUP BY  a.pay_month, u.department_id\\nORDER BY  u.department_id, a.pay_month"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "Simple Solution Using CTE (SQL SERVER)\\nwith avg_company_salary as\\n(select s.employee_id, department_id, amount, pay_date\\n  ,avg(amount) over (partition by pay_date)avg_company_salary\\n     from salary s\\n       join employee e on s.employee_id = e.employee_id)\\n\\n,avg_dept_salary as\\n(select department_id, pay_date\\n  ,avg(amount) over \\n     (partition by pay_date, department_id)avg_dept_salary,\\n         cast(avg_company_salary as float)avg_company_salary from avg_company_salary)\\n\\nselect distinct \\n  concat(datepart(year, pay_date),\\'-\\', RIGHT(CONCAT(\\'0\\', MONTH([pay_date])), 2))\\n    pay_month,  \\n      department_id,\\n    ( case \\n      when avg_dept_salary > avg_company_salary then \\'higher\\'\\n        when avg_dept_salary < avg_company_salary then \\'lower\\'\\n          else \\'same\\' end) comparison\\n            from avg_dept_salary"
                    },
                    {
                        "username": "Kurt1999",
                        "content": "select distinct date_format(pay_date,\\'%Y-%m\\') as pay_month, department_id, case when avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\')) - avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\'), department_id) > 0 then \\'lower\\'\\nwhen  avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\')) - avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\'), department_id) < 0 then \\'higher\\'\\nelse \\'same\\' end as comparison\\nfrom Salary S\\nleft join Employee E\\non S.employee_id = E.employee_id;"
                    },
                    {
                        "username": "kjcooper17",
                        "content": "Adding group by elements messes up window function calculation?\\n\\nIf I run this without department_id, pay_date (also remove group by) this calculates the right values, when I add them it screws it up, how come?\\n\\nselect\\ndepartment_id,\\npay_date,\\navg(amount) over (partition by a.pay_date,b.department_id) as dept_salary,\\navg(amount) over (partition by a.pay_date) as salary\\nfrom Salary a \\nleft join Employee b on a.employee_id = b.employee_id\\ngroup by 1,2 @"
                    },
                    {
                        "username": "novicewhistler",
                        "content": "Could anyone help me in debugging this? Not able to see the bug for the life of me -_-.\\n\\nMy code is \\n `\\nwith enhanced_salary_table as (\\n    select \\n        date_format(pay_date, \\'%Y-%m\\') as pay_month ,\\n        Employee.department_id,\\n        Salary.amount\\n    from Salary\\n    left join Employee\\n    on Salary.employee_id = Employee.employee_id\\n),\\nmonthly_org_avg as (\\n    select \\n        date_format(pay_date, \\'%Y-%m\\') as pay_month ,\\n        avg(Salary.amount) as org_avg_salary\\n    from Salary\\n    group by pay_month\\n)\\n\\nselect \\n    enhanced_salary_table.pay_month,\\n    enhanced_salary_table.department_id,\\n    case \\n        when avg(enhanced_salary_table.amount) < monthly_org_avg.org_avg_salary then \"lower\"\\n        when avg(enhanced_salary_table.amount) > monthly_org_avg.org_avg_salary then \"higher\"\\n        else \"same\" \\n    end as comparison\\nfrom enhanced_salary_table\\nleft join monthly_org_avg \\non enhanced_salary_table.pay_month = monthly_org_avg.pay_month\\ngroup by enhanced_salary_table.pay_month, enhanced_salary_table.department_id;\\n\\n`\\n\\nI fail the last test case where \\nSalary =\\n| id | employee_id | amount | pay_date   |\\n| -- | ----------- | ------ | ---------- |\\n| 1  | 1           | 9000   | 2017/03/31 |\\n| 2  | 2           | 6000   | 2017/03/31 |\\n| 3  | 3           | 10000  | 2017/03/31 |\\n| 4  | 1           | 7000   | 2017/02/26 |\\n| 5  | 2           | 6000   | 2017/02/27 |\\n| 6  | 3           | 8000   | 2017/02/22 |\\n\\n\\nEmployee =\\n| employee_id | department_id |\\n| ----------- | ------------- |\\n| 1           | 1             |\\n| 2           | 1             |\\n| 3           | 1             |\\n\\n\\nExpected\\n\\n| pay_month | department_id | comparison |\\n| --------- | ------------- | ---------- |\\n| 2017-02   | 1             | same       |\\n| 2017-03   | 1             | same       |\\n\\n\\nOutput\\n\\n| pay_month | department_id | comparison |\\n| --------- | ------------- | ---------- |\\n| 2017-03   | 1             | higher     |\\n| 2017-02   | 1             | same       |\\n\\n\\n\\nNo clue why I have higher in the comparison, where it should have been same. "
                    },
                    {
                        "username": "jfmsouza",
                        "content": "[@user1415gR](/user1415gR) round() worked for me! Thanks!"
                    },
                    {
                        "username": "user1415gR",
                        "content": "This is maybe due to the decimals. trying to use round() function in your case when clause, maybe it can help(you don\\'t know what would be showed in the endless decimals, so give a limitation)"
                    }
                ]
            },
            {
                "id": 1675487,
                "content": [
                    {
                        "username": "CharlesLoveStudy",
                        "content": "# Write your MySQL query statement below\\nWITH tb1 AS(SELECT LEFT(pay_date,7) AS pay_month, department_id,\\nAVG(amount) OVER(PARTITION BY LEFT(pay_date,7),department_id) AS dept_avg_amount,\\nAVG(amount) OVER(PARTITION BY LEFT(pay_date,7)) AS company_avg_amount\\nFROM salary s JOIN employee e ON s.employee_id=e.employee_id)\\n\\nSELECT DISTINCT pay_month, department_id,\\n(CASE WHEN dept_avg_amount<company_avg_amount THEN \\'lower\\'\\n      WHEN dept_avg_amount>company_avg_amount THEN \\'higher\\'\\n ELSE \\'same\\'\\n END) AS comparison\\nFROM tb1\\n"
                    },
                    {
                        "username": "pawelofficial",
                        "content": "as always the wording of the question is terrible. The report should contain comparison of monthly salaries per department vs monthly salaries for whole company."
                    },
                    {
                        "username": "zedzogrind",
                        "content": "awfully written question?"
                    },
                    {
                        "username": "Cyue0813",
                        "content": "Question: Why I delete avg1 and avg_d, the output will change to an incorrect answer? But, if I add them, the comparison is correct. \\n\\nCODE:\\n\\nWITH average AS (SELECT DISTINCT DATE_FORMAT(pay_date, \\'%Y-%m\\') AS pay_month, AVG(amount)OVER(partition by pay_date) AS avg1\\nFROM Salary AS s),\\nunion_all AS(\\n  SELECT DISTINCT DATE_FORMAT(pay_date, \\'%Y-%m\\') AS pay_month, s.employee_id, e.department_id, avg(amount)over(partition by department_id, pay_date) AS avg_d\\n  FROM Salary AS s\\n  JOIN Employee AS e\\n  ON s.employee_id = e.employee_id\\n)\\nSELECT a.pay_month, u.department_id, avg1, avg_d,\\nCASE WHEN avg_d > avg1 THEN \\'higher\\'\\n         WHEN avg_d < avg1 THEN \\'lower\\'\\n         ELSE \\'same\\' \\nEND AS comparison\\nFROM average AS a\\nLEFT JOIN union_all AS u\\nON a.pay_month = u.pay_month \\nGROUP BY  a.pay_month, u.department_id\\nORDER BY  u.department_id, a.pay_month"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "Simple Solution Using CTE (SQL SERVER)\\nwith avg_company_salary as\\n(select s.employee_id, department_id, amount, pay_date\\n  ,avg(amount) over (partition by pay_date)avg_company_salary\\n     from salary s\\n       join employee e on s.employee_id = e.employee_id)\\n\\n,avg_dept_salary as\\n(select department_id, pay_date\\n  ,avg(amount) over \\n     (partition by pay_date, department_id)avg_dept_salary,\\n         cast(avg_company_salary as float)avg_company_salary from avg_company_salary)\\n\\nselect distinct \\n  concat(datepart(year, pay_date),\\'-\\', RIGHT(CONCAT(\\'0\\', MONTH([pay_date])), 2))\\n    pay_month,  \\n      department_id,\\n    ( case \\n      when avg_dept_salary > avg_company_salary then \\'higher\\'\\n        when avg_dept_salary < avg_company_salary then \\'lower\\'\\n          else \\'same\\' end) comparison\\n            from avg_dept_salary"
                    },
                    {
                        "username": "Kurt1999",
                        "content": "select distinct date_format(pay_date,\\'%Y-%m\\') as pay_month, department_id, case when avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\')) - avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\'), department_id) > 0 then \\'lower\\'\\nwhen  avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\')) - avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\'), department_id) < 0 then \\'higher\\'\\nelse \\'same\\' end as comparison\\nfrom Salary S\\nleft join Employee E\\non S.employee_id = E.employee_id;"
                    },
                    {
                        "username": "kjcooper17",
                        "content": "Adding group by elements messes up window function calculation?\\n\\nIf I run this without department_id, pay_date (also remove group by) this calculates the right values, when I add them it screws it up, how come?\\n\\nselect\\ndepartment_id,\\npay_date,\\navg(amount) over (partition by a.pay_date,b.department_id) as dept_salary,\\navg(amount) over (partition by a.pay_date) as salary\\nfrom Salary a \\nleft join Employee b on a.employee_id = b.employee_id\\ngroup by 1,2 @"
                    },
                    {
                        "username": "novicewhistler",
                        "content": "Could anyone help me in debugging this? Not able to see the bug for the life of me -_-.\\n\\nMy code is \\n `\\nwith enhanced_salary_table as (\\n    select \\n        date_format(pay_date, \\'%Y-%m\\') as pay_month ,\\n        Employee.department_id,\\n        Salary.amount\\n    from Salary\\n    left join Employee\\n    on Salary.employee_id = Employee.employee_id\\n),\\nmonthly_org_avg as (\\n    select \\n        date_format(pay_date, \\'%Y-%m\\') as pay_month ,\\n        avg(Salary.amount) as org_avg_salary\\n    from Salary\\n    group by pay_month\\n)\\n\\nselect \\n    enhanced_salary_table.pay_month,\\n    enhanced_salary_table.department_id,\\n    case \\n        when avg(enhanced_salary_table.amount) < monthly_org_avg.org_avg_salary then \"lower\"\\n        when avg(enhanced_salary_table.amount) > monthly_org_avg.org_avg_salary then \"higher\"\\n        else \"same\" \\n    end as comparison\\nfrom enhanced_salary_table\\nleft join monthly_org_avg \\non enhanced_salary_table.pay_month = monthly_org_avg.pay_month\\ngroup by enhanced_salary_table.pay_month, enhanced_salary_table.department_id;\\n\\n`\\n\\nI fail the last test case where \\nSalary =\\n| id | employee_id | amount | pay_date   |\\n| -- | ----------- | ------ | ---------- |\\n| 1  | 1           | 9000   | 2017/03/31 |\\n| 2  | 2           | 6000   | 2017/03/31 |\\n| 3  | 3           | 10000  | 2017/03/31 |\\n| 4  | 1           | 7000   | 2017/02/26 |\\n| 5  | 2           | 6000   | 2017/02/27 |\\n| 6  | 3           | 8000   | 2017/02/22 |\\n\\n\\nEmployee =\\n| employee_id | department_id |\\n| ----------- | ------------- |\\n| 1           | 1             |\\n| 2           | 1             |\\n| 3           | 1             |\\n\\n\\nExpected\\n\\n| pay_month | department_id | comparison |\\n| --------- | ------------- | ---------- |\\n| 2017-02   | 1             | same       |\\n| 2017-03   | 1             | same       |\\n\\n\\nOutput\\n\\n| pay_month | department_id | comparison |\\n| --------- | ------------- | ---------- |\\n| 2017-03   | 1             | higher     |\\n| 2017-02   | 1             | same       |\\n\\n\\n\\nNo clue why I have higher in the comparison, where it should have been same. "
                    },
                    {
                        "username": "jfmsouza",
                        "content": "[@user1415gR](/user1415gR) round() worked for me! Thanks!"
                    },
                    {
                        "username": "user1415gR",
                        "content": "This is maybe due to the decimals. trying to use round() function in your case when clause, maybe it can help(you don\\'t know what would be showed in the endless decimals, so give a limitation)"
                    }
                ]
            },
            {
                "id": 1643082,
                "content": [
                    {
                        "username": "CharlesLoveStudy",
                        "content": "# Write your MySQL query statement below\\nWITH tb1 AS(SELECT LEFT(pay_date,7) AS pay_month, department_id,\\nAVG(amount) OVER(PARTITION BY LEFT(pay_date,7),department_id) AS dept_avg_amount,\\nAVG(amount) OVER(PARTITION BY LEFT(pay_date,7)) AS company_avg_amount\\nFROM salary s JOIN employee e ON s.employee_id=e.employee_id)\\n\\nSELECT DISTINCT pay_month, department_id,\\n(CASE WHEN dept_avg_amount<company_avg_amount THEN \\'lower\\'\\n      WHEN dept_avg_amount>company_avg_amount THEN \\'higher\\'\\n ELSE \\'same\\'\\n END) AS comparison\\nFROM tb1\\n"
                    },
                    {
                        "username": "pawelofficial",
                        "content": "as always the wording of the question is terrible. The report should contain comparison of monthly salaries per department vs monthly salaries for whole company."
                    },
                    {
                        "username": "zedzogrind",
                        "content": "awfully written question?"
                    },
                    {
                        "username": "Cyue0813",
                        "content": "Question: Why I delete avg1 and avg_d, the output will change to an incorrect answer? But, if I add them, the comparison is correct. \\n\\nCODE:\\n\\nWITH average AS (SELECT DISTINCT DATE_FORMAT(pay_date, \\'%Y-%m\\') AS pay_month, AVG(amount)OVER(partition by pay_date) AS avg1\\nFROM Salary AS s),\\nunion_all AS(\\n  SELECT DISTINCT DATE_FORMAT(pay_date, \\'%Y-%m\\') AS pay_month, s.employee_id, e.department_id, avg(amount)over(partition by department_id, pay_date) AS avg_d\\n  FROM Salary AS s\\n  JOIN Employee AS e\\n  ON s.employee_id = e.employee_id\\n)\\nSELECT a.pay_month, u.department_id, avg1, avg_d,\\nCASE WHEN avg_d > avg1 THEN \\'higher\\'\\n         WHEN avg_d < avg1 THEN \\'lower\\'\\n         ELSE \\'same\\' \\nEND AS comparison\\nFROM average AS a\\nLEFT JOIN union_all AS u\\nON a.pay_month = u.pay_month \\nGROUP BY  a.pay_month, u.department_id\\nORDER BY  u.department_id, a.pay_month"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "Simple Solution Using CTE (SQL SERVER)\\nwith avg_company_salary as\\n(select s.employee_id, department_id, amount, pay_date\\n  ,avg(amount) over (partition by pay_date)avg_company_salary\\n     from salary s\\n       join employee e on s.employee_id = e.employee_id)\\n\\n,avg_dept_salary as\\n(select department_id, pay_date\\n  ,avg(amount) over \\n     (partition by pay_date, department_id)avg_dept_salary,\\n         cast(avg_company_salary as float)avg_company_salary from avg_company_salary)\\n\\nselect distinct \\n  concat(datepart(year, pay_date),\\'-\\', RIGHT(CONCAT(\\'0\\', MONTH([pay_date])), 2))\\n    pay_month,  \\n      department_id,\\n    ( case \\n      when avg_dept_salary > avg_company_salary then \\'higher\\'\\n        when avg_dept_salary < avg_company_salary then \\'lower\\'\\n          else \\'same\\' end) comparison\\n            from avg_dept_salary"
                    },
                    {
                        "username": "Kurt1999",
                        "content": "select distinct date_format(pay_date,\\'%Y-%m\\') as pay_month, department_id, case when avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\')) - avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\'), department_id) > 0 then \\'lower\\'\\nwhen  avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\')) - avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\'), department_id) < 0 then \\'higher\\'\\nelse \\'same\\' end as comparison\\nfrom Salary S\\nleft join Employee E\\non S.employee_id = E.employee_id;"
                    },
                    {
                        "username": "kjcooper17",
                        "content": "Adding group by elements messes up window function calculation?\\n\\nIf I run this without department_id, pay_date (also remove group by) this calculates the right values, when I add them it screws it up, how come?\\n\\nselect\\ndepartment_id,\\npay_date,\\navg(amount) over (partition by a.pay_date,b.department_id) as dept_salary,\\navg(amount) over (partition by a.pay_date) as salary\\nfrom Salary a \\nleft join Employee b on a.employee_id = b.employee_id\\ngroup by 1,2 @"
                    },
                    {
                        "username": "novicewhistler",
                        "content": "Could anyone help me in debugging this? Not able to see the bug for the life of me -_-.\\n\\nMy code is \\n `\\nwith enhanced_salary_table as (\\n    select \\n        date_format(pay_date, \\'%Y-%m\\') as pay_month ,\\n        Employee.department_id,\\n        Salary.amount\\n    from Salary\\n    left join Employee\\n    on Salary.employee_id = Employee.employee_id\\n),\\nmonthly_org_avg as (\\n    select \\n        date_format(pay_date, \\'%Y-%m\\') as pay_month ,\\n        avg(Salary.amount) as org_avg_salary\\n    from Salary\\n    group by pay_month\\n)\\n\\nselect \\n    enhanced_salary_table.pay_month,\\n    enhanced_salary_table.department_id,\\n    case \\n        when avg(enhanced_salary_table.amount) < monthly_org_avg.org_avg_salary then \"lower\"\\n        when avg(enhanced_salary_table.amount) > monthly_org_avg.org_avg_salary then \"higher\"\\n        else \"same\" \\n    end as comparison\\nfrom enhanced_salary_table\\nleft join monthly_org_avg \\non enhanced_salary_table.pay_month = monthly_org_avg.pay_month\\ngroup by enhanced_salary_table.pay_month, enhanced_salary_table.department_id;\\n\\n`\\n\\nI fail the last test case where \\nSalary =\\n| id | employee_id | amount | pay_date   |\\n| -- | ----------- | ------ | ---------- |\\n| 1  | 1           | 9000   | 2017/03/31 |\\n| 2  | 2           | 6000   | 2017/03/31 |\\n| 3  | 3           | 10000  | 2017/03/31 |\\n| 4  | 1           | 7000   | 2017/02/26 |\\n| 5  | 2           | 6000   | 2017/02/27 |\\n| 6  | 3           | 8000   | 2017/02/22 |\\n\\n\\nEmployee =\\n| employee_id | department_id |\\n| ----------- | ------------- |\\n| 1           | 1             |\\n| 2           | 1             |\\n| 3           | 1             |\\n\\n\\nExpected\\n\\n| pay_month | department_id | comparison |\\n| --------- | ------------- | ---------- |\\n| 2017-02   | 1             | same       |\\n| 2017-03   | 1             | same       |\\n\\n\\nOutput\\n\\n| pay_month | department_id | comparison |\\n| --------- | ------------- | ---------- |\\n| 2017-03   | 1             | higher     |\\n| 2017-02   | 1             | same       |\\n\\n\\n\\nNo clue why I have higher in the comparison, where it should have been same. "
                    },
                    {
                        "username": "jfmsouza",
                        "content": "[@user1415gR](/user1415gR) round() worked for me! Thanks!"
                    },
                    {
                        "username": "user1415gR",
                        "content": "This is maybe due to the decimals. trying to use round() function in your case when clause, maybe it can help(you don\\'t know what would be showed in the endless decimals, so give a limitation)"
                    }
                ]
            }
        ]
    }
]